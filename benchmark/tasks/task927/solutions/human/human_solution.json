[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nld t[1 << 19], v[1 << 19];\n\nvector<ld> ans;\nvoid solve() {\n\tint n; ld l;\n\tcin >> n >> l;\n\trep(i, n) {\n\t\tcin >> t[i] >> v[i];\n\t}\n\tld a = t[0], b = v[0];\n\tans.push_back(a);\n\n\tvector<LDP> vp;\n\tvector<ld> rs = { 0 }; ld sum = 0;\n\tvector<ld> rv = { 0 }; ld rsum = 0;\n\trep1(i, n - 1) {\n\t\tif (b + v[i] >= l) {\n\t\t\tld z = l - v[i];\n\t\t\tld tt = (a * z + t[i] * v[i]) / l;\n\t\t\tans.push_back(tt);\n\t\t\tb = z;\n\t\t}\n\t\telse {\n\t\t\tld rest = l - b - v[i];\n\t\t\trest = sum - rest;\n\t\t\tint id = lower_bound(rs.begin(), rs.end(), rest) - rs.begin();\n\t\t\tid--;\n\t\t\tld nexr = rest - rs[id]; nexr = vp[id].second - rest;\n\t\t\tld tt = a * b + t[i] * v[i];\n\t\t\t//cout << tt << \" a\"<<endl;\n\t\t\ttt += vp[id].first*nexr;\n\t\t\ttt += rsum - rv[id + 1];\n\t\t\t//cout << tt << \" a\" << endl;\n\t\t\tans.push_back(tt / l);\n\t\t}\n\t\tif (a >= t[i]) {\n\t\t\ta = (a*b + t[i] * v[i]) / (b + v[i]);\n\t\t\tb = b + v[i];\n\t\t}\n\t\telse {\n\t\t\tsum += b; rsum += a * b;\n\t\t\tif (!vp.empty()&&vp.back().first > a) {\n\t\t\t\tld x = vp.back().first;\n\t\t\t\tld y = vp.back().second;\n\t\t\t\tld na = (x*y + a * b) / (y + b);\n\t\t\t\tld nb = y + b;\n\t\t\t\tvp.back() = { na,nb };\n\t\t\t\trs.back() += b;\n\t\t\t\trv.back() += a * b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvp.push_back({ a,b });\n\t\t\t\tld z = rs.back(); rs.push_back(z + b);\n\t\t\t\tz = rv.back(); rv.push_back(z + a * b);\n\t\t\t}\n\t\t\ta = t[i], b = v[i];\n\t\t}\n\t}\n\trep(i, n) {\n\t\tcout << ans[i] << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tld x,y;\n\tbool operator <(const point b)const{\n\t\treturn y<b.y;\n\t}\n}q[500005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){(ld)y,(ld)x};\n\t\tallt+=v.x*v.y; allv+=y;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].x*q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tq[head].x-=allv-l;\n\t\t\tallt-=(allv-l)*q[head].y;\n\t\t\tallv=l;\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.6lf\\n\",(double)(allt/allv));\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y=(v.y*v.x+q[tail].x*q[tail].y)/(v.x+q[tail].x);\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\nint n,m,l=1,r,tot;\ndouble sum,now,a[500010],b[500010],ans[500010];\nstruct abc{\n\tdouble x,y;\n}q[500010];\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') {\n        if(ch=='-')f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n         x=(x<<3)+(x<<1)+ch-48;\n         ch=getchar();\n    }\n    return x*f;\n}\nsigned main(){\n    n=read(),m=read();\n    for(register int i=1;i<=n;i++) a[i]=read(),b[i]=read();\n\tans[1]=a[1];\n    for(register int i=1;i<=n;i++){\n        sum+=a[i]*b[i];\n\t\tnow+=b[i];\n        r++;\n\t\tq[r].x=a[i];\n\t\tq[r].y=b[i];\n        while(l<=r){\n            if(now<=m) break;\n            if(now-q[l].y<m){\n                sum-=q[l].y*q[l].x;\n                q[l].y-=now-m;\n                sum+=q[l].y*q[l].x;\n                now=m;\n                break;\n            }else{\n            \tnow-=q[l].y;\n\t\t\t\tsum-=q[l].y*q[l].x;\n\t\t\t\tl++;\n            } \n        }\n        ans[i]=sum/m;\n        while(l<r&&q[r].x<q[r-1].x){\n            tot=q[r-1].y+q[r].y;\n            sum-=q[r].x*q[r].y-q[r-1].x*q[r-1].y;\n\t\t\tnow-=q[r].y-q[r-1].y;\n            q[r-1].x=(q[r].x*q[r].y+q[r-1].x*q[r-1].y)/tot;\n            q[r-1].y=tot;\n            sum+=q[r-1].x*q[r-1].y;\n\t\t\tnow+=q[r-1].y;\n            r--;\n        }\n    }\n    for(register int i=1;i<=n;i++) printf(\"%.7lf\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long double LD;\nusing namespace std;\ninline int rd() {\n\tchar ch=getchar(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=getchar();}\n\treturn i*f;\n}\ndeque < pair<LD,LD> > q;\nconst LD eps=1e-10;\ninline int sgn(LD x) {return (x>eps)-(x<-eps);}\nint n,L;\nLD sum_v;\nint main() {\n\tn=rd(), L=rd();\n\tfor(int i=1;i<=n;i++) {\n\t\tLD V=rd(), t=rd(); V*=t;\n\t\tif(i==1) {printf(\"%.7f\\n\",(double)(V/t)); q.push_back(make_pair(V,t)); sum_v=V; continue;}\n\t\tLD rs=t;\n\t\twhile(q.size() && q.front().second<rs) rs-=q.front().second, sum_v-=q.front().first, q.pop_front();\n\t\tif(q.size() && sgn(rs)>0) {\n\t\t\tLD vi=rs*(q.front().first/q.front().second);\n\t\t\tq.front().first-=vi; sum_v-=vi; q.front().second-=rs;\n\t\t}\n\t\tsum_v+=V; printf(\"%.7f\\n\",(double)(sum_v/L));\n\t\twhile(q.size() && (q.back().first/q.back().second)>(V/t)) {\n\t\t\tV+=q.back().first, t+=q.back().second, q.pop_back();\n\t\t} q.push_back(make_pair(V,t));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        ll tt=0, vv=0;\n        for(int i=0;i<N;i++){\n            ll t=T[i]*V[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first, v1=dp[0].second;\n               ll tmp=min(vv+v-L, v1);\n               tt=tt-t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t;\n            vv=L;\n            printf(\"%.7lf\\n\", (double)tt/vv);\n            int ans=dp.size();\n            ll c1=t;\n            ll c2=v;\n            while(ans){\n                ll t2=dp[ans-1].first, v2=dp[ans-1].second;\n                if(t2/v2<c1/c2){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::min;\nusing std::max;\nusing std::pair; \nusing std::make_pair; \n\ntypedef long long LL;\nconst int N=5e5+10;\n\nint n,l,t[N];\nLL v[N];\ndouble sum[N],f[N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&l);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%lld\",&t[i],&v[i]);\n}\n\npair<int,double>que[N];\nvoid Solve() {\n\tint nowv=0; double sum=0;\n\tint h=1,ti=0;\n\tfor (int i=1;i<=n;++i) {\n\t\tnowv+=v[i]; sum+=1.0*v[i]*t[i]/l;\n\t\twhile (h<=ti && nowv>l) {\n\t\t\tint del=min(nowv-l,que[h].first);\n\t\t\tif (que[h].first==del) ++h;else que[h].first-=del; \n\t\t\tnowv-=del; sum-=1.0*que[h].second*del/l;\n\t\t}\n\t\tprintf(\"%.7f\\n\",sum);\n\t\tint _v=v[i];double _t=t[i];\n\t\twhile (h<=ti && que[ti].second>_t) {\n\t\t\t_t=(que[ti].first*que[ti].second+_v*_t)/(_v+que[ti].first);\n\t\t\t_v=que[ti].first+_v;\n\t\t\t--ti; \n\t\t}\n\t\tque[++ti]=make_pair(_v,_t); \n\t}\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int N; ll L; cin >> N >> L;\n  deque<pair<int, double>> mp;\n  mp.push_back(pair<int, double>(L, 0));\n  double sum = 0;\n  \n  for (int i = 0; i < N; i++) {\n    double t; int v; cin >> t >> v;\n    int drain = v;\n    while (drain > 0) {\n      int amt = min(mp.back().first, drain);\n      sum -= amt * mp.back().second;\n      drain -= amt;\n      mp.back().first -= amt;\n      if (mp.back().first == 0) mp.pop_back();\n    }\n    sum += t * v;\n    while (!mp.empty() && mp.front().second >= t) {\n      t = t * v + mp.front().first * mp.front().second;\n      v += mp.front().first;\n      t /= v;\n    }\n    mp.push_front(pair<int, double>(v, t));\n    cout << fixed << setprecision(10) << (sum/L) << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\ntypedef long double DOUBLE;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst DOUBLE EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 5e5 + 5;\ndeque<pair<DOUBLE, DOUBLE> > pol;\n\nvoid solve(){\n\tint n, l;\n\tDOUBLE L;\n\tscanf(\"%d%d\", &n, &l);\n\tL = l;\n\tpol.pb(mp((DOUBLE)0, (DOUBLE)0));\n\tpol.pb(mp(L, (DOUBLE)0));\n\tREP(i, 0, n) {\n\t\tll t, v;\n\t\tscanf(\"%lld%lld\", &t, &v);\n\t\tDOUBLE X = pol.back()._1 + v;\n\t\tDOUBLE Y = pol.back()._2 + v * t;\n\t\t\n\t\t//cout << X << \" \" << Y << endl;\n\t\t\n\t\twhile(SZ(pol) > 1 && pol[1]._1 < X - L + EPS) {\n\t\t\tpol.pop_front();\n\t\t}\n\t\tif (SZ(pol) > 1) {\n\t\t\tDOUBLE x0 = X - L;\n\t\t\tDOUBLE y0 = pol[1]._2 - (pol[1]._2 - pol[0]._2) / (pol[1]._1 - pol[0]._1) * (pol[1]._1 - x0);\n\t\t\tpol[0] = mp(x0, y0);\n\t\t}\n\t\t\n\t\twhile(SZ(pol) > 1) {\n\t\t\tDOUBLE k1 = (pol[SZ(pol) - 1]._2 - pol[SZ(pol) - 2]._2) / (pol[SZ(pol) - 1]._1 - pol[SZ(pol) - 2]._1);\n\t\t\tDOUBLE k = (Y - pol[SZ(pol) - 2]._2) / (X - pol[SZ(pol) - 2]._1);\n\t\t\tif (k1 > k + EPS) {\n\t\t\t\tpol.pop_back();\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpol.pb(mp(X, Y));\n\t\t\n\t\tprintf(\"%.12lf\\n\", (double)((Y - pol[0]._2) / (X - pol[0]._1)));\n\t}\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define x first\n#define y second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nconst int N = 5 * 100000 + 100;\n\nconst int oo = 1e9;\nint n ;\ndouble v[N], t[N],tp = 0.0,L;\n\ndeque< pdd > q;\n\nint main() {\n\tcin >> n >> L;\n\tfor (int i = 0; i < n; ++i) {\n\t\tscanf(\"%lf%lf\", &t[i], &v[i]);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tdouble rem = v[i];\n\t\twhile (q.size() && rem > 0) {\n\t\t\tpdd g = q.front();\n\t\t\tdouble d = min(g.x, rem);\n\t\t\trem -= d;\t\t\t\n\t\t\ttp -= d*g.y;\n\t\t\tq.pop_front();\n\t\t\tif (g.x - d> 0)q.push_front(mp(g.x-d, g.y));\n\t\t}\n\t\twhile(q.size() && q.back().y > t[i]){\n\t\t\tpdd src = q.back();q.pop_back();\n\t\t\tt[i] = (t[i]*v[i]+src.x*src.y)/(src.x+v[i]);\n\t\t\tv[i] = (v[i]+src.x);\n\t\t\ttp -= src.x*src.y;\n\t\t}\n\t\ttp += v[i]*t[i];\n\t\tq.pb(mp(v[i],t[i]));\n\t\tprintf(\"%.9lf\\n\", tp/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-8;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }*/\n    \n    while (l > 0 && !W.empty()) {\n        if (l >= W.front().se) {\n            l -= W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RF(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && W.back().fi >= v){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct var{\n\tint sum;\n\tdouble t;\n}q[501001];\nint n,L,v[501001],l,r,sum;\ndouble t[501001],tn;\nint main()\n{\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%d\",&t[i],&v[i]);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\twhile(sum+v[i]>L)\n\t\t{\n\t\t\tint tmp=min(sum+v[i]-L,q[l].sum);\n\t\t\tq[l].sum-=tmp;\n\t\t\tsum-=tmp;\n\t\t\ttn-=1.00*q[l].t*tmp;\n\t\t\tif(!q[l].sum)l++;\n\t\t}\n\t\tr++;\n\t\tq[r].sum=v[i];\n\t\tq[r].t=t[i];\n\t\tsum+=v[i];\n\t\ttn+=v[i]*t[i];\n\t\twhile(l<r&&q[r].t<q[r-1].t)\n\t\t{\n\t\t\tdouble tt=1.000*(q[r].t*q[r].sum+q[r-1].t*q[r-1].sum)/(q[r].sum+q[r-1].sum);\n\t\t\tq[r-1].t=tt;\n\t\t\tq[r-1].sum+=q[r].sum;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.7f\\n\",1.000*tn/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, l;\n  cin >> n >> l;\n  deque<pair<double, ll>> q;\n  ll sumV = 0;\n  double sumVT = 0;\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) {\n    ll t, v;\n    cin >> t >> v;\n    while(sumV + v > l) {\n      auto p = q.front();\n      q.pop_front();\n      ll wd = sumV + v - l;\n      ll del = min(wd, p.second);\n      sumV -= del;\n      p.second -= del;\n      sumVT -= del * p.first;\n      if(p.second) q.push_front(p);\n    }\n\n    double o = (sumVT + v * t) / l;\n\n    cout << o << \"\\n\";\n\n    if(q.empty() || q.back().first - 1e-11 < t) {\n      q.emplace_back(t, v);\n      sumV += v;\n      sumVT += v * t;\n    } else {\n      q.clear();\n      q.emplace_back(o, l);\n      sumV = l;\n      sumVT = o * l;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 500002;\nint n, L;\niii arr[N];\nint pos[N];\nll BIT[2][N];\ndouble ans[N];\n\n\nvoid update(int k, int idx, ll val){\n    while(idx <= n){\n        BIT[k][idx] += val;\n        idx += idx & (-idx);\n    }\n}\n\nll query(int k, int idx){\n    ll ans = 0;\n    while(idx){\n        ans += BIT[k][idx];\n        idx -= idx & (-idx);\n    }\n    return ans;\n}\n\n\nint binary_search(int max_volume){\n    if(max_volume == 0) return 0;\n    int ans = n, lo = 1, hi = n;\n    while(lo <= hi){\n        int mid = (lo + hi)/2;\n        if(query(1, mid) >= max_volume){\n            ans = min(ans, mid);\n            hi = mid-1;\n        }\n        else{\n            lo = mid+1;\n        }\n    }\n    return ans;\n}\n\n\n\nint main(){\n\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &L);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d\", &arr[i].ff, &arr[i].ss.ff);\n        arr[i].ss.ss = i;\n    }\n    sort(arr+1, arr+n+1, greater<iii>());\n\n    for(int i=1;i<=n;i++){\n        pos[arr[i].ss.ss] = i;\n        update(0, i, arr[i].ff*1LL*arr[i].ss.ff);\n        update(1, i, arr[i].ss.ff);\n    }\n\n// cout<<\"arr: \";for(int i=1;i<=n;i++) cout<<arr[i].ff<<\":\"<<arr[i].ss.ff<<\":\"<<arr[i].ss.ss<<\" \";cout<<endl;\n// cout<<\"pos: \";for(int i=1;i<=n;i++) cout<<pos[i]<<\" \";cout<<endl;\n\n    for(int i=n;i>=1;i--){\n        update(0, pos[i], -arr[pos[i]].ff*1LL*arr[pos[i]].ss.ff);\n        update(1, pos[i], -arr[pos[i]].ss.ff);\n        // if(i != 4)  continue;\n        int max_volume = L - arr[pos[i]].ss.ff;\n        int idx = binary_search(max_volume);\n// cout<<max_volume<<\" \"<<idx<<endl;\n        if(idx == 0){\n            ans[i] = arr[pos[i]].ff;\n            continue;\n        }\n        ans[i] = (query(0, idx-1) + (max_volume - query(1, idx-1))*arr[idx].ff + arr[pos[i]].ff*1LL*arr[pos[i]].ss.ff) / (1.0*L);\n    }\n\n    for(int i=1;i<=n;i++)\n        printf(\"%.7lf\\n\", ans[i]);\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<double, ll>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            ll t=T[i], v=V[i];\n            while(vv+v>L){\n               double t1=dp[0].first;\n               ll v1=dp[0].second;\n               double tmp=min(vv+v-L, (double)v1);\n               tt=tt-(double)t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==(double)v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-(double)t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            double c1=t*v;\n            ll c2=v;\n            while(ans){\n                double t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double D;\nconst int N = 500010;\nstruct W{ D t; LL v;} q[N];\nD t[N];\nLL v[N];\nint main()\n{\n\tint n, l;\n\tscanf(\"%d%d\", &n, &l);\n\tRep(i, n) scanf(\"%lf%lld\", &t[i], &v[i]);\n\t\n\tint he = 1, ta = 0;\n\tLL sv = 0; D st = 0;\n\tRep(i, n) {\n\t\twhile (he <= ta && sv + v[i] - q[he].v >= l) {\n\t\t//\tprintf(\"%d\\n\", sv + v[i]);\n\t\t\tst = (st * sv - q[he].t * q[he].v) / (sv - q[he].v);\n\t\t\tsv -= q[he].v, he ++;\n\t\t}\n\t\tif (sv + v[i] > l) st = (st * sv - q[he].t * (sv - l)) / l, q[he].v -= sv + v[i] - l, sv = l - v[i];\n\t\t//printf(\"%lf\\n\", (st * sv + t[i] * v[i]) / (sv + v[i]) );\n\t\tq[++ ta].t = t[i], q[ta].v = v[i];\n\t\tst = (st * sv + t[i] * v[i]) / (sv + v[i]), sv += v[i];\n\t\twhile (he <= ta - 1 && q[ta - 1].t > q[ta].t) {\n\t\t//\tprintf(\"%lf\\n\", q[ta - 1].t * q[ta - 1].v + q[ta].t * q[ta].v);\n\t\t\tq[ta - 1].t = (q[ta - 1].t * q[ta - 1].v + q[ta].t * q[ta].v) / (q[ta - 1].v + q[ta].v);\n\t\t\tq[ta - 1].v += q[ta].v, ta --;\n\t\t}\n\t\t//printf(\"%lld %lf\\n\", sv, st);\n\t\t\n\t\tprintf(\"%.7lf\\n\", st);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nconst in mx=500009;\nin n,l;\nvector<double> v(2*mx),h(2*mx);\nin ofsv=0;\nin ofsh=0;\nin b=mx;\nin e=mx;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n>>l;\n  v[e]=h[e]=0;\n  ++e;\n  cout<<setprecision(15);\n  in adh,adv;\n  cin>>adh>>adv;\n  adh*=adv;\n  h[e]=adh;\n  v[e]=adv;\n  ++e;\n  forn(zz,n-1){\n    /*for(in i=b;i<e;++i){\n      cout<<(v[i]+ofsv)<<\" \"<<(h[i]+ofsh)<<\" \"<<(h[i]+ofsh)/(v[i]+ofsv)<<endl;\n    }*/\n    cout<<(h[e-1]+ofsh)/(v[e-1]+ofsv)<<\"\\n\";\n    cin>>adh>>adv;\n    adh*=adv;\n    while(e-b>=2 && v[e-2]+ofsv+adv>=l){\n      --e;\n    }\n    v[--b]=-ofsv-adv;\n    h[b]=-ofsh-adh;\n    if(v[e-1]+ofsv+adv>=l){\n      h[e-1]=h[e-2]+(h[e-1]-h[e-2])/(v[e-1]-v[e-2])*(l-(v[e-2]+ofsv+adv));\n      v[e-1]=l-ofsv-adv;\n    }\n    ++b;\n    while(b+1<e && (h[b+1]+ofsh+adh)/(v[b+1]+ofsv+adv)>(h[b]+ofsh+adh)/(v[b]+ofsv+adv)){\n      ++b;\n    }\n    --b;\n    v[b]=-ofsv-adv;\n    h[b]=-ofsh-adh;\n    ofsh+=adh;\n    ofsv+=adv;\n  }\n  cout<<(h[e-1]+ofsh)/(v[e-1]+ofsv)<<\"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n#define NR 501000\n\ntypedef double ld;\n\nint n, L;\nld T[NR], V[NR];\n\nint main() {\n\tscanf(\"%d%d\", &n, &L);\n\tint l = 1, r = 0;\n\tld ys = 0, vs = 0;\n\titer(i, n) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tvs += v; ys += (ld) t * v;\n\t//\tprintf(\"!!%d %d %.6f\\n\", l, r, V[l]);\n\t\twhile (l <= r) {\n\t\t\tif (vs > L) {\n\t\t\t\tld _v = min(vs - L, V[l]);\n\t\t\t\tV[l] -= _v;\n\t\t\t\tvs -= _v;\n\t\t\t\tys -= _v * T[l];\n\t\t\t}\n\t\t\tif (V[l] == 0) ++l;\n\t\t\telse break;\n\t\t}\n\t\tld y = (ld) t * v, x = v;\n\t\twhile (l <= r && T[r] > y / x) {\n\t\t\ty += T[r] * V[r];\n\t\t\tx += V[r];\n\t\t\t--r;\n\t\t}\n\t\t++r;\n\t\tT[r] = y / x;\n\t\tV[r] = x;\n\t\tprintf(\"%.8f\\n\", (double) (ys / vs));\n\t\t//printf(\"!%.6f %.6f\\n\", vs, x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=min(num + 1000ll,i);j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + (ll)b) % mod\n#define MUL(a, b) a = (a * (ll)b) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = a; i < b; i++)\n#define rer(i, a, b) for(int i = a - 1; i >= b; i--)\n#define all(a) (a).begin(), (a).end()\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> ppi;\ntypedef vector<ll> vec;\n\nconst int MAX_N = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 30;\n\nvoid Debug() {cout << '\\n'; }\n\ntemplate<class FIRST, class... REST> \nvoid Debug(FIRST arg, REST... rest) { cout << arg << \" \"; Debug(rest...); }\n\ntemplate<class T>\nostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";\n\tif(!v.empty()) {\n\t\trep(i, 0, (int)v.size() - 1) out << v[i] << \", \";\n\t\tout << v.back();\n\t}\n\tout << \"]\";\n  return out;\n}\n\ntemplate<class S, class T>\nostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";\n\treturn out;\n}\n\n///g++ -g3 -std=c++0x -DLOCAL -Wall -ftrapv -D_GLIBCXX_DEBUG -Wl,-stack,268435456 -o\n///g++ -O2 -std=c++0x -DLOCAL -Wall -Wl,-stack,268435456 -o\n\n///////////////////////////////////////////////////////////////////////\n\nint N, L;\ndeque<pair<double, int>> que;\n\nvoid solve() {\n\tcin >> N >> L;\n\n\tdouble res = 0;\n\trep(i, 0, N) {\n\t\tdouble a; int b;\n\t\tcin >> a >> b;\n\n\t\tint S = L + b;\n\t\twhile(!que.empty()) {\n\t\t\tpair<double, int> p = que.front();\n\t\t\tif(S - p.sec <= L) {\n\t\t\t\tque.front().sec -= S - L;\n\t\t\t\tres -= que.front().fst * (S - L);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tS -= que.front().sec;\n\t\t\t\tres -= que.front().fst * que.front().sec;\n\t\t\t\tque.pop_front();\n\t\t\t}\n\t\t}\n\n\t\tres += a * b;\n\t\tcout << res / L << \"\\n\";\n\n\t\twhile(!que.empty() && a < que.back().fst) {\n\t\t\ta = (que.back().fst * que.back().sec + a * b) / (b + que.back().sec);\n\t\t\tb += que.back().sec;\n\t\t\tque.pop_back();\n\t\t}\n\t\tque.push_back(pair<double, int>(a, b));\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n    cin.tie(0);\t\n    cout << fixed;\n\tcout.precision(20);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ld long double\n#define PI pair<ld,ll>\n#define S second\n#define mp make_pair\n#define F first\nconst int N=500005;\nint n,L,top;\nPI q[N];\nll sum[N];\nld ans[N];\nPI operator +(PI a,PI b){\n\treturn mp((a.F*a.S+b.F*b.S)/(a.S+b.S),a.S+b.S);\n}\nsigned main(){\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++){\n\t\tint t,v; scanf(\"%d%d\",&t,&v);\n\t\tPI dq=mp(t,v);\n\t\twhile(top&&q[top]>dq){if(q[top].S+dq.S>L)q[top].S=L-dq.S; dq=dq+q[top--]; }\n\t\tq[++top]=dq; sum[top]=sum[top-1]+dq.S; ans[top]=ans[top-1]+dq.F*dq.S;\n\t\tint pos=lower_bound(&sum[1],&sum[top+1],sum[top]-L)-sum;\n\t\tprintf(\"%.7lf\\n\",(double)((ans[top]-ans[pos]+q[pos].F*(L-(sum[top]-sum[pos])))/L));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;\nconst int N = 5e5L + 11;\n\nll t[N], v[N];\nll sum[N];\ndb sum_tv[N];\n\ndb dp_t[N];\nll dp_v[N];\ndb ans[N];\n\nbool drop[N];\nint pre[N];\n\nint main() {\n\tint n; ll l;\n\tcin >> n >> l;\n\tfor(int i = 1; i <= n; i ++)\n\t\tscanf(\"%lld%lld\", t + i, v + i);\n\tfor(int i = 1; i <= n; i ++)\n\t\tsum_tv[i] = t[i] * v[i] + sum_tv[i - 1];\n\tpartial_sum(v, v + N, sum);\n\tdp_t[1] = t[1]; dp_v[1] = l; pre[1] = -1;\n\n\tint last_drop = -1;\n\tfor(int i = 2; i <= n; i ++) {\n\t\tif(dp_t[i - 1] < t[i]) {\n\t\t\tdrop[i] = 1;\n\t\t\tpre[i] = last_drop;\n\t\t\tlast_drop = i;\n\t\t\tdp_t[i] = t[i];\n\t\t\tdp_v[i] = v[i];\n\t\t} else {\n\t\t\tll old = min(dp_v[i - 1], l - v[i]);\n\t\t\tdp_t[i] = (old * dp_t[i - 1] + v[i] * dp_t[i]) / (old + v[i]);\n\t\t\tdp_v[i] += old + v[i];\n\t\t\tpre[i] = pre[i - 1];\n\t\t}\n\t\t//cout << i << ' ' << dp_v[i] << '\\n';\n\t}\n\n\tint p = n;\n\tll s = 0;\n\tans[1] = t[1];\n\tfor(int i = n; i > 1; i --) {\n\t\twhile(p == i || dp_v[p] + sum[i] - sum[p] < l)\n\t\t\tp --;\n\t\t//cout << i << ' ' << p << '\\n';\n\t\tdb v2 = sum[i] - sum[p], v1 = l - v2;\n\t\t//cout << v1 << ' ' << v2 << '\\n';\n\t\tans[i] = (v1 * dp_t[p] + sum_tv[i] - sum_tv[p]) / (v1 + v2);\n\t}\n\t/*\n\tfor(int i = 1; i <= n; i ++)\n\t\tcout << ans[i] << '\\n';\n\t\t*/\n\tfor(int i = 1; i <= n; i ++)\n\t\tprintf(\"%.6f\\n\", (double)ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 500500;\nconst int mod = 1e9 + 7;\n\nusing namespace std;\n\nint orien(long long x1, long double y1, long long x2, long double y2, long long x3, long double y3) {\n\tlong double O = (long double) (x2 - x1) * (y3 - y1) - (long double) (y2 - y1) * (x3 - x1);\n\n        if(O < 0) return 1; // clock\n        else if(O > 0) return -1; // anti\n        return 0;\n}\n\nint n, L;\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> L;\n        deque < pair < long long, long double > > d;\n        long long sum = 0;\n        long double res = 0;\n        for(int i = 1; i <= n; i++){\n                long long x, xx;\n                cin >> x >> xx;\n                swap(x, xx);\n                long double y = x * xx;\n\n                sum += x;\n                res += y;\n\n                while(d.size() > 0 && orien(0, 0, x, y, x + d[0].fi, y + d[0].se) != 1){\n                        x += d[0].fi;\n                        y += d[0].se;\n                        d.pop_front();\n                }\n                d.push_front({x, y});\n\n                while(sum > L){\n                        auto p = d.back();\n                        d.pop_back();\n                        long long G = p.fi - min(sum - L, p.fi);\n                        long double k = (long double) G / p.fi;\n                        sum += G - p.fi;\n                        p.fi = G;\n\n                        res += k * p.se - p.se;\n                        p.se *= k;\n                        if(p.fi > 0){\n                                d.push_back(p);\n                        }\n                }\n                cout << fixed << setprecision(9) << res / L << \"\\n\";\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 5e5 + 5;\n\nint N, L;\ndouble t[MAXN], v[MAXN];\n\nvoid input()\n{\n    scanf(\"%d%d\", &N, &L);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%lf%lf\", &t[i], &v[i]);\n        t[i] *= v[i];\n    }\n}\n\nvoid solve()\n{\n    static int q[MAXN];\n    int front = 0, rear = 0;\n    double sumt = 0, sumv = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        double left = L - v[i];\n        for (; front < rear && sumv > left; ++front) {\n            int j = q[front];\n            sumt -= t[j];\n            sumv -= v[j];\n            if (sumv <= left) {\n                double c = (left - sumv) / v[j];\n                sumt += (t[j] *= c);\n                sumv += (v[j] *= c);\n                break;\n            }\n        }\n        assert(fabs(sumv - left) < 1e-8);\n        double ans = (sumt + t[i]) / L;\n        printf(\"%.10f\\n\", ans);\n\n        double t0 = t[i], v0 = v[i];\n        for (; front < rear && t[q[rear - 1]] / v[q[rear - 1]] >= t0 / v0; --rear) {\n            t0 += t[q[rear - 1]];\n            v0 += v[q[rear - 1]];\n        }\n        q[rear++] = i;\n        sumt += t[i]; t[i] = t0;\n        sumv += v[i]; v[i] = v0;\n        // printf(\"i=%d:\\n\", i);\n        // for (int j = front; j < rear; ++j) {\n        //     printf(\"(%f,%f) \", v[q[j]], t[q[j]]);\n        // }\n        // puts(\"\");\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 不入虎穴，焉得虎子?\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <double,int>  PDI;\nint n,l;\ndouble s;\ndeque <PDI> Q;\nPDI x;\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&l);\n\tdouble t;\n\tfor (int i=1,r,v; i<=n; i++)\n\t\t{\n\t\t\tscanf(\"%lf %d\",&t,&v),s+=t*v,r=(i==1?0:v);\n\t\t\twhile (r)\n\t\t\t\t{\n\t\t\t\t\tx=Q.front(),Q.pop_front();\n\t\t\t\t\ts-=x.first*min(r,x.second);\n\t\t\t\t\tif (r<x.second)  x.second-=r,r=0,Q.push_front(x);\n\t\t\t\t\telse  r-=x.second;\n\t\t\t\t}\n\t\t\twhile ((!Q.empty())&&(Q.back().first>=t))\n\t\t\t\tx=Q.back(),Q.pop_back(),t=(t*v+x.first*x.second)/(v+x.second),v+=x.second;\n\t\t\tQ.push_back(make_pair(t,v));\n\t\t\tprintf(\"%.7lf\\n\",s/l);\n\t\t}\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=2e5+20;\nbool check(int x,int y)\n{\n    if(x==1&&y==0||(x==0&&y==1))\n        return false;//lose態 \n    bool flag=false;\n    for(int i=2;i<=x;i+=2)\n        if(!check(x-i,y+i/2))\n            flag=true;\n    for(int i=2;i<=y;i+=2)\n        if(!check(x+i/2,y-i))\n            flag=true;\n    return flag;\n}\nvoid pattern()\n{\n    for(int i=1;i<=5;i++)\n    {\n        for(int j=1;j<=10;j++)\n        {\n            cout<<i<<' '<<j<<' ';\n            if(check(i,j))\n                cout<<\"win\"<<endl;\n            else\n                cout<<\"lose\"<<endl;\n        }\n    }    \n}\nint main()\n{\n    ll x,y;\n    //pattern();\n    while(cin>>x>>y)\n    {\n        if(abs(x-y)>1)\n            puts(\"Alice\");\n        else\n            puts(\"Brown\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * d.cc: F: Dam\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 500000;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef long double ld;\n\n/* global variables */\n\nld tjs[MAX_N + 1];\nint vjs[MAX_N + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, l;\n  scanf(\"%d%d\", &n, &l);\n\n  ld tvsum = 0;\n  int vsum = 0;\n  int j0 = 0, j1 = 0;\n\n  for (int i = 0; i < n; i++) {\n    ld ti;\n    int vi;\n    scanf(\"%Lf%d\", &ti, &vi);\n\n    for (int rv = vi; j0 < j1 && rv > 0;) {\n      if (vjs[j0] <= rv) {\n\ttvsum -= tjs[j0] * vjs[j0];\n\tvsum -= vjs[j0];\n\trv -= vjs[j0];\n\tj0++;\n      }\n      else {\n\ttvsum -= tjs[j0] * rv;\n\tvsum -= rv;\n\trv = 0;\n      }\n    }\n\n    tvsum += ti * vi;\n    vsum += vi;\n\n    if (j0 >= j1 || tjs[j1 - 1] > ti) {\n      tjs[0] = tvsum / vsum, vjs[0] = vsum;\n      j0 = 0, j1 = 1;\n    }\n    else if (tjs[j1 - 1] == ti) {\n      vjs[j1 - 1] += vi;\n    }\n    else {\n      tjs[j1] = ti, vjs[j1] = vi;\n      j1++;\n    }\n\n    printf(\"%.7Lf\\n\", tvsum / l);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=5e5+10;\n\nint n,L,H,T;\n\nstruct Point{\n\tLL x;\n\tdouble y;\n\tPoint() {}\n\tPoint(LL x,double y):x(x),y(y) {}\n\tPoint operator + (const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator - (const Point &p) const {return Point(x-p.x,y-p.y);}\n};\n\ndouble Cross(Point A,Point B) {return A.x*B.y-A.y*B.x;}\n\nPoint P[maxn];\n\nPoint GetPoint(Point A,Point B,LL x)\n{\n\tdouble t=((double)x-A.x)/(B.x-A.x);\n\treturn Point(x,A.y+t*(B.y-A.y));\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tH=T=1;\n\tP[1]=Point(0,0);\n\twhile (n--)\n\t{\n\t\tPoint p;\n\t\tscanf(\"%lf%lld\",&p.y,&p.x);\n\t\tp.y*=p.x;\n\t\tT++;\n\t\tP[T]=P[T-1]-p;\n\t\twhile (H!=T&&P[H+1].x-P[T].x>=L) H++;\n\t\tif (P[H].x-P[T].x>L)\n\t\t\tP[H]=GetPoint(P[H],P[H+1],P[T].x+L);\n\t\twhile (H+1<T&&Cross(P[T-1]-P[T],P[T-2]-P[T])>=0) P[T-1]=P[T],T--;\n\t\tif (n%5000==0) for (int i=H;i<=T;i++) P[i]=P[i]-P[T];\n\t\tprintf(\"%.10lf\\n\",((double)P[H].y-P[T].y)/L);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t\t\t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=now-m;\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse l++;\n\t\t}\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\tsum=sum+q[r].a*q[r].b,now=now+q[r].b;\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tint tot=min((int)(q[r-1].b+q[r].b),m);\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t\t//printf(\"%.6lf %.0lf\\n\",sum,now);\n\t\tans[i]=sum/m;\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || q < V.size() || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t\tV.pop_back();\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <functional>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nint n;\nll l;\nll t[510000];\nll nw[510000];\nll dl[510000];\nll v[510000];\nld t2[510000];\n\nint main() {\n    scanf(\"%d%lld\", &n, &l);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%lld%lld\", t + i, v + i);\n    t2[0] = t[0];\n    printf(\"%.10Lf\\n\", t2[0]);\n    nw[0] = l;\n    for (int i = 1; i < n; ++i) {\n        dl[i - 1] += v[i];\n        nw[i - 1] -= v[i];\n        int now = i - 1;\n        while (now > 0) {\n            if (t[now - 1] >= t[now])\n                break;\n            if (dl[now] >= nw[now - 1]) {\n                dl[now] -= nw[now - 1];\n                dl[now - 1] += nw[now - 1];\n                nw[now - 1] = 0;\n                break;\n            }\n            nw[now - 1] -= dl[now];\n            dl[now - 1] += dl[now];\n            dl[now] = 0;\n            --now;\n        }\n        now = max(now, 1);\n        for (int j = now; j <= i; ++j)\n            t2[j] = (t[j] * v[j] + t2[j - 1] * nw[j - 1]) / (v[j] + nw[j - 1]);\n        nw[i] = l;\n        printf(\"%.10Lf\\n\", t2[i]);\n    }\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <deque>\n#include <utility>\n#include <stdio.h>\n#define llint long long\n#define eps 1e-9\n\nusing namespace std;\ntypedef pair<double, llint> P;\n\nllint n, L;\ndeque<P> deq;\ndouble T, V;\n\nint main(void)\n{\n\tcin >> n >> L;\n\t\n\tllint t, v;\n\tcin >> t >> v;\n\tT = t, V = v;\n\tdeq.push_back(make_pair(t, v));\n\tprintf(\"%.11f\\n\", T);\n\t\n\tfor(int i = 2; i <= n; i++){\n\t\tcin >> t >> v;\n\t\t\n\t\tdouble dt, dv;\n\t\twhile(V+v > L + eps){\n\t\t\tdt = deq.front().first;\n\t\t\tif(deq.front().second < V+v-L){\n\t\t\t\tdv = deq.front().second;\n\t\t\t\tdeq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdv = V+v-L;\n\t\t\t\tP p = deq.front();\n\t\t\t\tdeq.pop_front();\n\t\t\t\tp.second -= dv;\n\t\t\t\tdeq.push_front(p);\n\t\t\t}\n\t\t\tT = (T*V-dt*dv) / (V-dv);\n\t\t\tV = V-dv;\n\t\t\t//cout << \"* \" << T << \" \" << V << \" \" << dt << \" \" << dv << endl;\n\t\t}\n\t\t\n\t\tdouble tt = t, vv = v;\n\t\twhile(deq.size()){\n\t\t\tP p = deq.back();\n\t\t\tif(p.first > tt){\n\t\t\t\tdeq.pop_back();\n\t\t\t\ttt = (p.first*p.second+tt*vv) / (p.second+vv);\n\t\t\t\tvv = p.second + vv;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\t\tdeq.push_back(make_pair(tt, vv));\n\t\tT = (T*V+t*v) / (V+v);\n\t\tV = V+v;\n\t\t\n\t\tprintf(\"%.11f\\n\", T);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main()\n{\n    cin.tie(nullptr); ios::sync_with_stdio(false);\n    int N, L; cin >> N >> L;\n    deque<pair<double, int>> X;\n    cout << fixed << setprecision(9);\n    double TV = 0;\n    for (int i = 0; i < N; i++) {\n        int T, V; cin >> T >> V;\n        if (i != 0) {\n            int v = V;\n            while (X.front().second <= v) {\n                TV -= X.front().first * X.front().second;\n                v -= X.front().second;\n                X.pop_front();\n            }\n            TV -= X.front().first * v;\n            X.front().second -= v;\n        }\n        X.emplace_back(T, V);\n        TV += (Int)T * V;\n        cout << TV / L << '\\n';\n        while (X.size()>=2 && X[X.size()-2].first > X.back().first) {\n            double t1 = X[X.size()-2].first, t2 = X.back().first;\n            int v1 = X[X.size()-2].second, v2 = X.back().second;\n            X.pop_back();\n            X.back() = make_pair((t1*v1+t2*v2)/(v1+v2), v1+v2);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nint l,r;\ninline void merge(Vector &a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) merge(q[r-1],q[r]),--r;\n        printf(\"%lf\\n\",(db)y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;\n        double tt=0.0, vv=0.0;\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n\n        for(int i=0;i<N;i++){\n            ll t, v;\n            t=T[i];v=V[i];\n            while(v+vv>L){\n                ll t1=dp[0].first;\n                ll v1=dp[0].second;\n                double tmp=min(v+vv-L, (double)v1);\n                tt=(tt*vv-t1*tmp)/(vv-tmp);\n                vv=vv-tmp;\n                if(tmp==v1){\n                    dp.pop_front();\n                }\n                else {\n                    dp[0].first=t1;\n                    dp[0].second=v1-tmp;\n                }\n            }\n            tt=(tt*vv+t*v)/L;\n            vv=L;\n            printf(\"%.7lf\\n\", tt);\n            int ans=dp.size();\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2<t){\n                    break;\n                }\n                else {\n                    t=(t*v+t2*v2)/(v+v2);\n                    v=t2+v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(t, v));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nstruct V{\n\tint v;\n\tdouble t;\n\tV (int a = 0, double b = 0.0):v(a), t(b) {}\n\tV operator +(V o) { return V(v + o.v, (v * t + o.v * o.t) / (v + o.v)); }\n\tbool R(V o) { return t <= o.t; }\n};\n\nint main(){\n\tint n, l;\n\tscanf(\"%d%d\", &n, &l);\n\tdeque<V> T;\n\tT.push_back(V(l));\n\tdouble h = 0.0;\n\tf(i, 0, n){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tV c(b, a);\n\t\tint need = c.v;\n\t\twhile (need){\n\t\t\tif (need >= T.back().v)need -= T.back().v, h -= T.back().v * T.back().t, T.pop_back();\n\t\t\telse h -= need * T.back().t, T.back().v -= need, need = 0;\n\t\t}\n\t\th += c.v * c.t;\n\t\twhile (!T.empty() && c.R(T.front()))c = c + T.front(), T.pop_front();\n\t\tT.push_front(c);\n\t\tprintf(\"%.7lf\\n\", h / l);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#define N 500005\nusing namespace std;\n\nint n;\nlong long L, qv[N];\ndouble qt[N];\n\nint main() {\n#ifdef whyqx\n    freopen(\"work.in\", \"r\", stdin);\n    freopen(\"work.out\", \"w\", stdout);\n#endif\n\n    cin >> n >> L;\n\n    long long nowv = 0; double nowt = 0;\n    int ql = 1, qr = 0;\n    for (int i = 1, t, v; i <= n; ++i) {\n        scanf(\"%d%d\", &t, &v);\n        while (ql <= qr && nowv + v > L) {\n            long long tmp = min(qv[ql], nowv + v - L);\n            qv[ql] -= tmp, nowv -= tmp, nowt -= tmp * qt[ql];\n            if (!qv[ql]) ++ql;\n        }\n        qt[++qr] = t, qv[qr] = v;\n        nowt += 1ll * t * v, nowv += v;\n        while (ql < qr && qt[qr - 1] > qt[qr]) {\n            qt[qr - 1] = (double) (qt[qr - 1] * qv[qr - 1] + qt[qr] * qv[qr]) / (qv[qr - 1] + qv[qr]);\n            qv[qr - 1] += qv[qr], --qr;\n        }\n        printf(\"%.7lf\\n\", (double) nowt / L);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=500010;\nstruct water{\n\tdouble t;\n\tint v;\n\tinline friend water operator + (const water &a,const water &b){\n\t\tint sum=a.v+b.v;\n\t\tif(sum==0)return (water){0,0};\n\t\treturn (water){a.t*((double)a.v/sum)+b.t*((double)b.v/sum),sum};\n\t}\n\tinline void operator += (const water &b){\n\t\t*this=*this+b;\n\t}\n\tinline void operator -= (const water &b){\n\t\t*this+=(water){b.t,-b.v};\n\t}\n}que[N],cur;\nint main(){\n\tfreopen(\"dam.in\",\"r\",stdin);\n\tint n=ni,v=ni;\n\tint qh=0,qt=0;\n\tfor(int i=1;i<=n;i++){\n\t\twater a=(water){(double)ni,ni};\n\t\tfor(;cur.v+a.v>v&&cur.v+a.v-que[qh].v>=v;cur-=que[qh++]);\n\t\tif(cur.v+a.v>v){\n\t\t\tque[qh].v-=cur.v+a.v-v;\n\t\t\tcur-=(water){que[qh].t,cur.v+a.v-v};\n\t\t}\n\t\tcur+=a;\n\t\tprintf(\"%.10lf\\n\",cur.t);\n\t\tfor(;qh<qt&&que[qt-1].t>a.t;a+=que[--qt]);\n\t\tque[qt++]=a;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            ll t=T[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first;\n               ll v1=dp[0].second;\n               double tmp=min(vv+v-L, (double)v1);\n               tt=tt-(double)t1/v1*tmp;\n               vv-=tmp;\n               if(tmp==(double)v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-(double)t1/v1*tmp;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt=tt+t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            ll c1=tt, c2=vv;\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    c1=t*v;\n                    c2=v;\n                    break;\n                }\n                else{\n                    c1=t2+t*v;\n                    c2=v2+v;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long lli;\nusing namespace std;\nstruct Water{\n\tlli v;\n\tdouble t;\n}w[500010];\nlli maxv,n,sumv,t,v,l=1,r;\ndouble s;\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&maxv);\n\twhile(n--){\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\twhile(sumv+v>maxv){\n\t\t\tlli out=min(w[l].v,sumv+v-maxv);\n\t\t\tw[l].v-=out;\n\t\t\tsumv-=out;\n\t\t\ts-=1.0*w[l].t*out;\n\t\t\tif(!w[l].v) l++;\n\t\t}\n\t\tw[++r].t=1.0*t,w[r].v=v;\n\t\ts+=t*v;\n\t\tsumv+=v;\n\t\twhile(l<r&&w[r-1].t>w[r].t){\n\t\t\tw[--r].t=1.0*(w[r].t*w[r].v+w[r+1].t*w[r+1].v)/(w[r].v+w[r+1].v);\n\t\t\tw[r].v+=w[r+1].v;\n\t\t}\n\t\tprintf(\"%.7f\\n\",1.0*s/maxv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define db double\nconst int N=5e6;\n\n#define C getchar()-48\nint read()\n{\n  int s=0,t=1,k=C;\n  for (;k<0||9<k;k=C) if (k==-3) t=-1;\n  for (;0<=k&&k<=9;k=C) s=(s<<1)+(s<<3)+k;\n  return s*t;\n}\n\n  int n,m;\n  int t[N],v[N];\nvoid in()\n{\n  cin>>n>>m;\n  for (int i=0;++i<=n;)\n    t[i]=read(),v[i]=read();\n}\n\n  db f[3000][3000];\nvoid wor()\n{\n  for (int i=0;++i<=n;)\n    {\n      for (int j=m;j>=v[i];--j)\n        {\n          db x=(f[i-1][j-v[i]]*(db)(j-v[i])+(db)(t[i]*v[i]))/(db)(j);\n          f[i][j]=max(f[i][j],x);\n\t\t\t  }\n\t\t  for (int j=m;--j;)\n\t\t    f[i][j]=max(f[i][j],f[i][j+1]);\n\t\t}\n}\n\nvoid out()\n{\n  for (int i=0;++i<=n;)\n    printf(\"%.7lf\\n\",f[i][m]);\n}\n\nint main()\n{\n  in();\n  wor();\n  out();\n  exit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cinttypes>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\nusing u4t = std::uint32_t;\nusing i4t = std::int32_t;\nusing u8t = std::uint64_t;\nusing i8t = std::int64_t;\nu8t N,L;\nstd::vector<u8t> tau;\nstd::vector<u8t> vol;\nint main() {\n  std::cin>>N>>L;\n  for(int i=0;i<N;i++){\n    u8t t;u8t v;\n    std::cin>>t>>v;\n    tau.push_back(t*v);\n    vol.push_back(v);\n  }\n  std::vector<double> tauM;\n  std::vector<double> volM;\n  double tau1=tau[0];\n  double vol1=vol[0];\n  double temp=tau1/vol1;\n  //printf(\"%.8f\\n\", temp);\n  tauM.push_back(tau1);\n  volM.push_back(vol1);\n  for(int i=1;i<N;i++){\n    if(temp>=(double)tau[i]/(double)vol[i]){\n      vol1=std::min((double)L-vol[i],vol1);\n    }else{\n      vol1=0;\n    }\n    //fprintf(stderr,\"v %f\\n\",vol1);\n    tau1=temp*vol1;\n\n    tau1+=tau[i];\n    vol1+=vol[i];\n    temp=tau1/vol1;\n    tauM.push_back(tau1);\n    volM.push_back(vol1);\n    //printf(\"%.8f\\n\", temp);\n  }\n  //for(int i=0;i<N;i++)fprintf(stderr,\"M %d,%f,%f\\n\",i,tauM[i]/volM[i],volM[i]);\n  int j=0;\n  double mizu=0;\n  double netu=0;\n  for(int i=0;i<N;i++){\n    mizu+=vol[i];\n    netu+=tau[i];\n    while(mizu-vol[j]+volM[j]>=L){\n      mizu-=vol[j];\n      netu-=tau[j];\n      j++;\n    }\n\n    double mizuM=L-mizu;\n    double netuM=(tauM[j-1]/volM[j-1])*mizuM;\n    //fprintf(stderr,\"%d,%f,%f\\n\",j,netuM,mizuM);\n    double tmax=(netu+netuM)/(mizu+mizuM);\n    printf(\"%.8f\\n\", tmax);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\nstatic const int MAXN = 1e5 + 4;\n\nint n, l;\nint t[MAXN], v[MAXN];\n\nint qhead, qtail;\nstd::pair<double, double> q[MAXN];\nstd::pair<double, double> offset;\n\ndouble eval_linear(std::pair<double, double> p, std::pair<double, double> q, double x)\n{\n    double ratio = (x - p.first) / (q.first - p.first);\n    return p.second * (1.0 - ratio) + q.second * ratio;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &l);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &t[i], &v[i]);\n\n    qhead = MAXN - 2, qtail = MAXN;\n    q[MAXN - 2] = std::make_pair(0, 0);\n    q[MAXN - 1] = std::make_pair(v[0], (double)v[0] * t[0]);\n    offset = std::make_pair(0, 0);\n    printf(\"%.8lf\\n\", (double)t[0]);\n\n    for (int i = 1; i < n; ++i) {\n        offset.first += v[i];\n        q[qtail - 1] = std::make_pair(l - offset.first, eval_linear(q[qtail - 2], q[qtail - 1], l - offset.first));\n        offset.second += (double)v[i] * t[i];\n        while (qtail > qhead + 1 && q[qtail - 2].first + offset.first > l) --qtail;\n        int lo = qhead, hi = qtail, mid;\n        while (lo < hi - 1) {\n            mid = (lo + hi) >> 1;\n            if ((q[mid].second + offset.second) / (q[mid].first + offset.first)\n                >= (q[mid - 1].second + offset.second) / (q[mid - 1].first + offset.first)) lo = mid;\n            else hi = mid;\n        }\n        qhead = lo;\n        q[--qhead] = std::make_pair(-offset.first, -offset.second);\n        printf(\"%.8lf\\n\", (q[qtail - 1].second + offset.second) / l);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 500009;\nstruct point{\n\tdouble v, t;\n} u, q[maxn];\nint n, L, l = 1, r;\ndouble X, Y;\n\nint main(){\n\tscanf(\"%d%d\", &n, &L);\n\tfor (int i=1; i<=n; i++){\n\t\tscanf(\"%lf%lf\", &u.t, &u.v);\n\t\tX += u.v; Y += u.v*u.t;\n\t\twhile (L < X){\n\t\t\tif (X-L >= q[l].v){ Y -= q[l].v * q[l].t; X -= q[l++].v; }\n\t\t\telse { Y -= q[l].t*(X-L); q[l].v -= X-L; X = L; }\n\t\t}\n\t\tprintf(\"%.8lf\\n\", Y/X);\n\t\twhile (l <= r && q[r].t >= u.t){\n\t\t\tu.t = (q[r].t*q[r].v + u.t*u.v) / (q[r].v+u.v);\n\t\t\tu.v += q[r--].v;\n\t\t}\n\t\tq[++r] = u;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V-= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <deque>\nusing namespace std;\n\ntypedef long long i64;\ntypedef pair<i64, double> pii;\n\nint N, L;\n\ndeque<pii> q;\n\nint main() {\n  i64 sum = 0;\n  double val = 0;\n  \n  scanf(\"%d%d\", &N, &L);\n  \n  for (int i = 1; i <= N; ++i) {\n    double t;\n    int v;\n\n    scanf(\"%lf%d\", &t, &v);\n    sum += v, val += t * v;\n    while (q.size() > 1 && sum - q.back().first >= L) {\n      sum -= q.back().first, val -= q.back().first * q.back().second;\n      q.pop_back();      \n    }\n\n    int rest = sum - L, n = q.size();\n    \n    if (rest) {\n      q[n - 1].first -= rest;\n      val -= q[n - 1].second * rest;\n      sum -= rest;\n    }\n    \n    printf(\"%.9lf\\n\", (double) val / L);\n    \n    q.push_front(make_pair(v, t));\n\n    while (q.size() >= 2 && q[1].second >= q[0].second) {\n      q[1].second = (q[1].second * q[1].first + q[0].second * q[0].first) / (q[1].first + q[0].first);\n      q[1].first += q[0].first;\n      q.pop_front();\n    }\n\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n\nint n,m,l=1,r;\n\nstruct point{double x,y;}t,w,q[N],cnt;\npoint operator +(point a,point b){\n\treturn (point){a.x+b.x,a.y+b.y};\n}\npoint operator -(point a,point b){\n\treturn (point){a.x-b.x,a.y-b.y};\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-') f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();m=read();\n\tfor (int i=1;i<=n;i++){\n\t\tt.y=read();t.x=read();t.y*=t.x;cnt=cnt+t;\n\t\twhile (cnt.x>m+1e-9){\n\t\t\tif (q[l].x<=cnt.x-m) cnt=cnt-q[l++];\n\t\t\telse {\n\t\t\t\tw.x=cnt.x-m;w.y=w.x*q[l].y/q[l].x;\n\t\t\t\tq[l]=q[l]-w;cnt=cnt-w;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",cnt.y/cnt.x);\n\t\twhile (l<=r&&q[r].y/q[r].x>=t.y/t.x) t=t+q[r--];\n\t\tq[++r]=t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500020\nusing namespace std;\nint read(){\n\tint nm=0,fh=1; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn nm*fh;\n}\nint n,m,q[M],hd,tl,num[M],now;\nlong double V=0.0,ans=0.0,maxn,tot,T[M];\nlong double calc(int x){return (1.0*num[x])*T[x];}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read(),maxn=m*1.0,hd=1;\n\tfor(int i=1;i<=n;i++){\n\t\tT[i]=read()*1.0,num[i]=read(),q[++tl]=i,ans+=calc(i),V+=num[i];\n\t\twhile(hd<tl&&T[q[tl]]<=T[q[tl]-1]){\n\t\t\tans-=calc(q[tl])+calc(q[tl-1]);\n\t\t\tif(num[q[tl]]+num[q[tl-1]]>m) num[q[tl-1]]=m-num[q[tl]];\n\t\t\tT[q[tl-1]]=(calc(q[tl-1])+calc(q[tl]))/((num[q[tl-1]]+num[q[tl]])*1.0);\n\t\t\tnum[q[tl-1]]+=num[q[tl]],tl--;\n\t\t\tif(num[q[tl]]==m) hd=tl,ans=calc(q[tl]),V=m;\n\t\t\telse  ans+=calc(q[tl]);\n\t\t}\n\t\twhile(V>m){\n\t\t\tif(V-num[q[hd]]>=m) V-=num[q[hd]],ans-=calc(q[hd]),hd++;\n\t\t\telse num[q[hd]]-=V-m,ans-=(1.0*(V-m))*T[q[hd]],V=m;\n\t\t}\n\t\tprintf(\"%.10Lf\\n\",ans/maxn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nconst int maxn=5e5+10;\ntypedef long long LL;\ntypedef pair<double,double> P;\nstruct Dam{\n\tdouble t,v;\n}d[maxn];\nLL n;\ndouble l;\ndeque<P> deq;\nint main(){\n\tscanf(\"%lld%lf\",&n,&l);\n\tfor (int i=0;i<n;i++) scanf(\"%lf%lf\",&d[i].t,&d[i].v);\n\tdeq.push_back(P(d[0].t,d[0].v));\n\tprintf(\"%.10f\\n\",d[0].t);\n\tdouble sum=d[0].t*d[0].v,val=d[0].v;\n\tfor (int i=1;i<n;i++){\n\t\tdeq.push_back(P(d[i].t,d[i].v));\n\t\tsum+=d[i].t*d[i].v;\n\t\tval+=d[i].v;\n\t\twhile (val>l){\n\t\t\tdouble detl=val-l;\n\t\t\tif (deq.front().se<detl){\n\t\t\t\tsum-=deq.front().fi*deq.front().se;\n\t\t\t\tval-=deq.front().se;\n\t\t\t\tdeq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum-=deq.front().fi*detl;\n\t\t\t\tdeq.front().se-=detl;\n\t\t\t\tval=l;\n\t\t\t}\n\t\t}\n\t\twhile (deq.size()>=2&&deq[deq.size()-2].fi>deq[deq.size()-1].fi){\n\t\t\tP p1=deq.back(); deq.pop_back();\n\t\t\tP p2=deq.back(); deq.pop_back();\n\t\t\tdeq.push_back(make_pair((p1.fi*p1.se+p2.fi*p2.se)/(p1.se+p2.se),p1.se+p2.se));\n\t\t}\n\t\tprintf(\"%.10f\\n\", sum/l);\n\t}\n\treturn 0;\n}\n/*\n3 10\n10 10\n20 5\n4 3\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <deque>\n#include <iomanip>\n\nusing namespace std;\n\nint n, L;\ndeque<pair<int, double> > que;\ndouble sum = 0;\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n >> L;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint v;\n\t\tdouble t;\n\t\tcin >> t >> v;\n\t\tif(i != 1)\n\t\t{\n\t\t\tint cnt = v;\n\t\t\twhile(!que.empty() && cnt)\n\t\t\t\tif(que.front().first <= cnt)\n\t\t\t\t\tcnt -= que.front().first, sum -= que.front().second, que.pop_front();\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint vol = que.front().first;\n\t\t\t\t\tdouble temp = que.front().second / que.front().first;\n\t\t\t\t\tsum -= cnt * temp;\n\t\t\t\t\tque.front() = make_pair(vol - cnt, (vol - cnt) * temp);\n\t\t\t\t\tcnt = 0;\n\t\t\t\t}\n\t\t}\n\t\tsum += v * t;\n\t\tdouble mul = v * t;\n\t\twhile(!que.empty() && que.back().second / que.back().first > mul / v)\n\t\t\tv += que.back().first, mul += que.back().second, que.pop_back();\n\t\tque.push_back(make_pair(v, mul));\n\t\tdouble ans = sum / L;\n\t\tcout << fixed << setprecision(12) << ans << endl;\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N,L;\ndouble T,V;\nmap<ll,ll> M;\ndouble TV,TT;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>L;\n\t\n\tdeque<pair<double,double>> D;\n\t\n\tFOR(i,N) {\n\t\tcin>>T>>V;\n\t\t\n\t\tif(i) {\n\t\t\tdouble del=V;\n\t\t\t\n\t\t\twhile(del>0) {\n\t\t\t\tif(D.front().second<=del) {\n\t\t\t\t\tdel -= D.front().second;\n\t\t\t\t\tD.pop_front();\n\t\t\t\t\tTV -= D.front().second;\n\t\t\t\t\tTT -= D.front().first*D.front().second;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tD.front().second -= del;\n\t\t\t\t\tTV -= del;\n\t\t\t\t\tTT -= D.front().first*del;\n\t\t\t\t\tdel = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTV += V;\n\t\tTT += T*V;\n\t\t_P(\"%.12lf\\n\",1.0*TT/TV);\n\t\t\n\t\twhile(D.size() && D.back().first>T) {\n\t\t\tdouble TTT = T*V + D.back().first*D.back().second;\n\t\t\tV = V + D.back().second;\n\t\t\tT = TTT/V;\n\t\t\tD.pop_back();\n\t\t}\n\t\tD.push_back({T,V});\n\t\t\n\t\t\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        while ((int)q.size() > 1) {\n            int v = q[0];\n            int u = q[1];\n            if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_front();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"data.in\",\"r\",stdin);\n   // freopen(\"data.out\",\"w\",stdout);\n#endif\n    \n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            //if (q[tail-1][1]>q[tail-2][1]) break;\n            if (S/L>q[tail-2][1]) break;\n            \n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n       // cout <<q[tail-1][1] << \" \" << S/L << endl;\n        //assert(q[tail-1][1] == S/L);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define db double\nusing namespace std;\nconst int N=5e5+10;\nint n,l=1,r=0;\ndb maxl,v,sumv,t,ans;\nstruct node{\n\tdb t,v;\n}q[N];\nint main(){\n\tscanf(\"%d%lf\",&n,&maxl);\n\twhile(n--){\n\t\tscanf(\"%lf%lf\",&t,&v);\n\t\twhile(v+sumv>maxl){\n\t\t\tdb out=min(v+sumv-maxl,q[l].v);\n\t\t\tans-=out*q[l].t,sumv-=out,q[l].v-=out;\n\t\t\tif(!q[l].v) l++;\n\t\t}\n\t\tq[++r]=(node){t,v};\n\t\tans+=t*v,sumv+=v;\n\t\twhile(l<r && q[r-1].t>q[r].t){\n\t\t\tq[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v+q[r].v);\n\t\t\tq[r-1].v+=q[r].v; r--;\t\n\t\t}\n\t\tprintf(\"%.7lf\\n\",ans/sumv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 500005;\n\nint n, ql, qr, cur, lim, x[MAXN];\ndouble ret, y[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), lim = Read(), ql = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tint t = Read(), v = Read();\n\t\twhile (cur + v > lim)\n\t\t\tif (cur + v - x[ql] >= lim)\n\t\t\t\tcur -= x[ql], ret -= y[ql], ql ++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint t = cur + v - lim;\n\t\t\t\tdouble r = y[ql] / x[ql];\n\t\t\t\tx[ql] -= t, y[ql] -= t * r;\n\t\t\t\tcur -= t, ret -= t * r;\n\t\t\t}\n\t\tcur += v;\n\t\tret += 1LL * v * t;\n\t\tprintf(\"%lf\\n\", ret / cur);\n\t\tqr ++, x[qr] = v, y[qr] = 1LL * v * t;\n\t\twhile (ql < qr && y[qr] * x[qr - 1] < y[qr - 1] * x[qr])\n\t\t\tx[qr - 1] += x[qr], y[qr - 1] += y[qr], qr --;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ntemplate<class T> inline void read(T &n){\n\tchar ch=GC;T w=1,x=0;\n\twhile(!isdigit(ch)){if(ch=='-') w=-1;ch=GC;}\n\twhile(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=GC;}\n\tn=x*w;\n}\nconst int maxn=500005;\nint n,L;\n#define pid pair<int,double>\n#define fir first\n#define sec second\npid Q[maxn];\ninline pid merge(pid x,pid y){\n    return make_pair(x.fir+y.fir,(x.sec*x.fir+y.sec*y.fir)/(x.fir+y.fir));\n}\nint main(){\n    read(n),read(L);\n    int head=1,tail=0;\n    int T,V;\n    read(T),read(V);\n    printf(\"%.7lf\\n\",(double)T);\n    Q[++tail]=make_pair(V,(double)T);\n    double sum=(double)T*V;\n    for(int i=2,T,V;i<=n;i++){\n        read(T),read(V);\n        int tmp=L;\n        while(tmp+V>L){\n            int tp=min(tmp+V-L,Q[head].fir);\n            tmp-=tp,Q[head].fir-=tp;\n            sum-=Q[head].sec*tp;\n            if(!Q[head].fir) head++;\n        }\n        sum+=(double)T*V;\n        printf(\"%.7lf\\n\",sum/L);\n        Q[++tail]=make_pair(V,(double)T);\n        while(head<tail&&Q[tail].sec<Q[tail-1].sec){\n            Q[tail-1]=merge(Q[tail-1],Q[tail]);\n            tail--;\n        }\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//In the Name of God\n//Let Our Voices Echo\n#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define X real()\n#define Y imag()\ntypedef long long ll;\ntypedef double ld; \ntypedef complex<ld> point;\nconst ld eps=1e-9;\nconst int MAX=5e5+9,MOD=1e9+7;\nll n,D,a[MAX],b[MAX],be[MAX],q;\nint main()\n{\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n>>D;\n\tfor (int i=1;i<=n;i++) \n\t{\n\t\tcin>>a[i];\n\t\tb[i]=b[i-1];\n\t\tif (b[i]<D)\n\t\t{\n\t\t\tif (abs(b[i]+a[i]-D)<abs(b[i]-D))\n\t\t\t\tb[i]+=a[i];\n\t\t}\n\t\telse\n\t\t\tif (abs(b[i]-a[i]-D)<abs(b[i]-D))\n\t\t\t\tb[i]-=a[i];\n\t}\n\tll x=-1;\n\tfor (int i=n;i>=1;i--)\n\t{\n\t\tif (x==-1)\n\t\t{\n\t\t\tbe[i]=b[i-1]!=D;\n\t\t\tx=(a[i]==1?2:1);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (abs(b[i-1]-D)>=x)\n\t\t\t\tbe[i]=1;\n\t\t\tif (x<a[i])\n\t\t\t{\n\t\t\t\tif (a[i]-x<=x)\n\t\t\t\t\tx=a[i]-x;\n\t\t\t}\n\t\t\telse\n\t\t\t\tx=x+a[i];\t\t\n\t\t}\n\t}\n\tcin>>q;\n\tfor (int i=0;i<q;i++)\n\t{\n\t\tint x;\n\t\tcin>>x;\n\t\tif (be[x]) cout<<\"YES\\n\";\n\t\telse cout<<\"NO\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  LL n, l;\n  deque<pair<int, double>> cal;\n  vector<LL> t, v;\n  Solver(LL n) : n(n), t(n), v(n){};\n  double temperature(int a, int b) {\n    return (cal[b].second - cal[a].second) / (double)(cal[b].first - cal[a].first);\n  }\n  void solve() {\n    cin >> l;\n    for (int i = 0; i < n; ++i) {\n      cin >> t[i] >> v[i];\n    }\n    cal.emplace_back(0, 0);\n    for (int i = 0; i < n; ++i) {\n      // increse\n      cal.emplace_front(cal[0].first - v[i], cal[0].second - t[i] * v[i]);\n      //answer\n      DBG(cal)\n      printf(\"%.9lf\\n\", temperature(0, cal.size() - 1));\n      //mix\n      while (cal.size() >= 3 && temperature(0, 1) < temperature(1, 2)) {\n        cal.erase(cal.begin() + 1);\n      }\n      if (i == n - 1) break;\n      //decrease\n      while (1) {\n        auto tmp = cal.back();\n        cal.pop_back();\n        int upperBound = l - v[i + 1];\n        if (cal.back().first < cal[0].first + upperBound) {\n          cal.emplace_back(cal[0].first + upperBound, cal.back().second + (tmp.second - cal.back().second) / (tmp.first - cal.back().first) * (cal[0].first + upperBound - cal.back().first));\n          break;\n        } else if (cal.back().first == cal[0].first + upperBound) {\n          break;\n        }\n      }\n      DBG(cal)\n    }\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  //std::cin.tie(0);\n  //std::ios_base::sync_with_stdio(false);\n  std::cout << std::fixed << std::setprecision(9);\n  long long n = 0;\n  scanf(\"%lld\", &n);\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, l, i;\n    long double t = 0, v = 0;\n    deque <pair<long double, long double> > d;\n    \n    scanf(\"%d %d\", &n, &l);\n    \n    for (i = 0; i < n; i++) {\n        double tx, vx;\n        \n        scanf(\"%lf %lf\", &tx, &vx);\n        \n        if (l == vx) {\n            d.clear();\n            t = 0;\n            v = 0;\n        }\n        \n        while (v + vx > l && d.size() > 0) {\n            long double t1 = d.front().first;\n            long double v1 = d.front().second;\n            long double v2 = min(v1, v + vx - l);\n            \n            t = (t * v - t1 * v2) / (v - v2);\n            v = v - v2;\n            \n            if (v - v1 + vx > l) {\n                d.pop_front();\n            } else {\n                d.front().second -= v2;\n                break;\n            }\n        }\n        \n        t = (t * v + tx * vx) / (v + vx);\n        v = v + vx;\n        \n        printf(\"%.12lf\\n\", (double)t);\n        \n        while (d.size() > 0) {\n            long double t1 = d.back().first;\n            long double v1 = d.back().second;\n            \n            if (t1 < tx) break;\n            \n            tx = (tx * vx + t1 * v1) / (vx + v1);\n            vx = vx + v1;\n            \n            d.pop_back();\n        }\n        \n        d.push_back(make_pair(tx, vx));\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 500005;\nint n, L;\ndouble V, T;\nstruct X { double t, v; };\ndeque<X> q;\n\nint main() {\n\tscanf(\"%d%d\", &n, &L);\n\tfor(int t, v, i = 1; i <= n; ++i) {\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tV += v; T += 1.0 * t * v;\n\t\twhile(V > L)\n\t\tif(V - L >= q.front().v) {\n\t\t\tV -= q.front().v;\n\t\t\tT -= q.front().v * q.front().t;\n\t\t\tq.pop_front();\n\t\t}\n\t\telse {\n\t\t\tq.front().v -= V - L;\n\t\t\tT -= q.front().t * (V - L);\n\t\t\tV = L;\n\t\t}\n\t\t\n\t\tprintf(\"%.7lf\\n\", T / V);\n\t\tX delta = (X) { t, v };\n\t\t\n\t\twhile(!q.empty() && q.back().t > delta.t) {\n\t\t\tdelta.t = (delta.t * delta.v + q.back().t * q.back().v) / (delta.v + q.back().v);\n\t\t\tdelta.v += q.back().v;\n\t\t\tq.pop_back();\n\t\t}\n\t\tq.push_back(delta);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=5e5+10;\nconst double eps=1e-10;\nint n,L,Head=0,Tail=0;\ninline int sgn(double x){\n\tif(x>eps) return 1;\n\tif(x<-eps) return -1;\n\treturn 0;\n}\ninline int read(){\n\tint x=0;char ch=getchar();\n\twhile(!isdigit(ch)) ch=getchar();\n\twhile(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(double X=0,double Y=0){x=X,y=Y;}\n\tfriend inline Point operator+(const Point &a,const Point &b){return Point(a.x+b.x,a.y+b.y);}\n\tfriend inline Point operator-(const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}\n\tfriend inline Point operator+(const Point &a,const double &b){return Point(a.x/b,a.y/b);}\n\tfriend inline double cross(const Point &a,const Point &b){return a.x*b.y-a.y*b.x;}\n\tinline double f(double v){if(!sgn(x)) return 0;return v*y/x;}\n}O,Q[maxn];\nint main(){\n\t//freopen(\"ARC072F.in\",\"r\",stdin);\n\tn=read(),L=read();\n\tfor(int i=1;i<=n;++i){\n\t\tdouble v=read(),u=read();\n\t\tO=Point(O.x+u,O.y+u*v);\n\t\twhile(Head<Tail&&(O.x-Q[Head+1].x)>=L) ++Head;\n\t\tif(Head!=Tail&&O.x-Q[Head].x>L) Q[Head]=Point(O.x-L,Q[Head].y+Point(Q[Head+1]-Q[Head]).f(O.x-L-Q[Head].x));\n\t\twhile(Head<Tail&&sgn(cross(O-Q[Tail-1],Q[Tail]-Q[Tail-1]))>=0) Tail--;\n\t\tQ[++Tail]=O,printf(\"%.7lf\\n\",(O.y-Q[Head].y)/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 10;\nint n, L;\nlong double t[maxn], sta[maxn], presta[maxn];\nint v[maxn], sva[maxn], presva[maxn];\nint m;\nint main()\n{\n\tcin >> n >> L;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint T;\n\t\tcin >> T >> v[i];\n\t\tt[i] = 1ll * T * v[i];\n\t}\n\tlong double st = 0;\n\tint sv = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(st * v[i] < t[i] * sv)\n\t\t{\n\t\t\t++m;\n\t\t\tsta[m] = st;\n\t\t\tsva[m] = sv;\n\t\t\tpresta[m] = presta[m - 1] + sta[m];\n\t\t\tpresva[m] = presva[m - 1] + sva[m];\n\t\t\t\n\t\t\tst = t[i];\n\t\t\tsv = v[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sv + v[i] <= L)\n\t\t\t{\n\t\t\t\tst += t[i];\n\t\t\t\tsv += v[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tst = st * (L - v[i]) / sv + t[i];\n\t\t\t\tsv = L;\n\t\t\t}\n\t\t}\n\t\tif(sv == L)\n\t\t{\n\t\t\tdouble ans = st / L;\n\t\t\tprintf(\"%.7f\\n\", ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint lim = presva[m] - (L - sv);\n\t\t\tint x = lower_bound(presva + 1, presva + m + 1, lim) - presva;\n\t\t\tdouble ret = presta[m] - presta[x] + (sta[x] * (presva[x] - lim) / sva[x]);\n\t\t\tdouble ans = (st + ret) / L;\n\t\t\tprintf(\"%.7f\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        if (!sgn(ll-d)){\n            V = 0;\n        }\n        else {\n            V = ((V*ll) - d*W.front().fi) / (ll-d);\n        }\n        l -= d; W.front().se -= d; ll -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n        \n    }\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        DB r = l;\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _r = r; r += W.back().se;\n            v = (_r*v + W.front().fi*W.back().se) / r;\n            W.pop_back();\n        }\n        W.push_back(MP(v, r));\n        OT(V);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tint x; ld y;\n\tbool operator <(const point b)const{\n\t\treturn y*b.x<b.y*x;\n\t}\n}q[500005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){y,(ld)x*y};\n\t\tallt+=v.y; allv+=v.x;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}else{\n\t\t\t\tld v=q[head].y*(allv-l)/q[head].x;\n\t\t\t\tq[head].x-=allv-l;\n\t\t\t\tallv=l;\n\t\t\t\tq[head].y-=v;\n\t\t\t\tallt-=v;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.6lf\\n\",(double)(allt/allv));\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y+=q[tail].y;\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//ARC072F\n#include<cstdio>\n#include<vector>\n#include<deque>\n#include<algorithm>\n#include<utility>\nusing namespace std;\nint main(void){\n\tint N,L;\n\tdouble tep,ryo,c,d,dam=0;//dam=熱量\n\tdeque<pair<double,double>> water;//温度,水量\n\tscanf(\"%d %d\",&N,&L);\n\tN--;\n\tscanf(\"%lf %lf\",&tep,&ryo);\n\twater.push_front(make_pair(tep,ryo));\n\tdam=tep*ryo;\n\tprintf(\"%f\\n\",dam/L);\n\tfor(;N>0;N--){\n\t\tdouble hai=0;\n\t\tscanf(\"%lf %lf\",&tep,&ryo);\n\t\tdam+=tep*ryo;\n\t\twater.push_front(make_pair(tep,ryo));\n\t\t//水を排出する\n\t\twhile(hai<ryo){\n\t\t\tc=water.back().first;\n\t\t\td=water.back().second;\n\t\t\thai+=d;\n\t\t\tdam-=c*d;\n\t\t\twater.pop_back();\n\t\t}\n\t\tdam+=c*(hai-ryo);\n\t\twater.push_back(make_pair(c,hai-ryo));\n\t\t//水を混ぜる\n\t\twhile(water.size()>1&&water[0].first<=water[1].first){\n\t\t\td=water[0].second+water[1].second;\n\t\t\tc=(water[0].first*water[0].second+water[1].first*water[1].second)/d;\n\t\t\twater.pop_front();water.pop_front();\n\t\t\twater.push_front(make_pair(c,d));\n\t\t}\n\t\tprintf(\"%f\\n\",dam/(double)L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<int,int>> v;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tdouble val=v[i].first;\n\t\tdouble l=v[i].second;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tint n,l;\n\tcin>>n>>l;\n\tint befg=-1;\n\tlp(i,n){\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tdouble val=v[z].first;\n\t\t\tdouble ls=v[z].second;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={remv+0.5,lbs+0.5+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({a*b+0.5,b+0.5});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 5e5 + 5;\n\nint N, L;\ndouble t[MAXN], v[MAXN];\n\nvoid input()\n{\n    scanf(\"%d%d\", &N, &L);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%lf%lf\", &t[i], &v[i]);\n        t[i] *= v[i];\n    }\n}\n\nvoid solve()\n{\n    static int q[MAXN];\n    int front = 0, rear = 0;\n    double sumt = 0, sumv = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        double left = L - v[i];\n        for (; front < rear && sumv > left; ++front) {\n            int j = q[front];\n            sumt -= t[j];\n            sumv -= v[j];\n            if (sumv <= left) {\n                double c = (left - sumv) / v[j];\n                sumt += (t[j] *= c);\n                sumv += (v[j] *= c);\n                break;\n            }\n        }\n        printf(\"%.10f\\n\", (sumt + t[i]) / L);\n\n        double t0 = t[i], v0 = v[i];\n        for (; front < rear && t[q[rear - 1]] / v[q[rear - 1]] >= t0 / v0; --rear) {\n            t0 += t[q[rear - 1]];\n            v0 += v[q[rear - 1]];\n        }\n        q[rear++] = i;\n        sumt += t[i]; t[i] = t0;\n        sumv += v[i]; v[i] = v0;\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 不入虎穴，焉得虎子?\n"
  },
  {
    "language": "C++",
    "code": "/* Generated by powerful Codeforces Tool\n * You can download the binary file in here https://github.com/xalanq/cf-tool (win, osx, linux)\n * Author: step_by_step\n * Time: 2020-02-16 20:55:45\n**/\n\n//#pragma comment(linker, \"/stack:200000000\")\n//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n//#pragma GCC optimize(\"unroll-loops\")\n  \n#include <iostream>\n#include <stdlib.h>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <assert.h>\n#include <memory.h>\n#include <time.h>\n#include <bitset>\n\n#define uint unsigned int\n#define ll long long\n#define ull unsigned long long\n#define ld long double\n#define rep(i, l, r) for (int i = (l); i < (r); i++)\n#define repb(i, r, l) for (int i = (r); i > (l); i--)\n#define sz(a) (int)a.size()\n#define fi first\n#define se second\n#define mp(a, b) make_pair(a, b)\n#define rank qwertyuio\n#define next dfghjk\n#define prev fhsgfhjf\n#define plus fsghsf\n#define minus ytryr\n  \nusing namespace std;\n  \ninline bool setmin(int &x, int y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(int &x, int y) { return (y > x) ? x = y, 1 : 0; }\ninline bool setmin(ll &x, ll y) { return (y < x) ? x = y, 1 : 0; }\ninline bool setmax(ll &x, ll y) { return (y > x) ? x = y, 1 : 0; }\n  \nconst int N = 200000;\nconst int inf = (int)1e9 + 1;\nconst ll big = (ll)1e18 + 1;\nconst int P = 239;\nconst int P1 = 31;\nconst int P2 = 57;\nconst int MOD = (int)1e9 + 7;\nconst int MOD1 = (int)1e9 + 9;\nconst int MOD2 = 998244353;\nconst ld eps = 1e-9;\nconst double pi = atan2(0, -1);\nconst int ABC = 26;\n\nint main()\n{\n    //freopen(\"a.in\", \"r\", stdin);\n    //freopen(\"a.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    //ll TL = 10.95 * CLOCKS_PER_SEC;\n    //clock_t time = clock();\n    int n, L;\n    cin >> n >> L;\n    deque<pair<ll, ld> > segm;\n    ld tot = 0;\n    rep(i, 0, n) {\n        ll t, v;\n        cin >> t >> v;\n        if (i > 0) {\n            ll rem = v;\n            while (rem > 0) {\n                if (segm.back().fi <= rem) {\n                    rem -= segm.back().fi;\n                    tot -= segm.back().se;\n                    segm.pop_back();\n                } else {\n                    tot -= segm.back().se;\n                    segm.back().se *= (ld)(segm.back().fi - rem) / segm.back().fi;\n                    segm.back().fi -= rem;\n                    tot += segm.back().se;\n                    break;\n                }\n            }\n        }\n        segm.push_front({v, t * v});\n        tot += t * v;\n        while (sz(segm) >= 2 && segm[0].fi * segm[1].se - segm[0].se * segm[1].fi >= 0) {\n            segm[1].fi += segm[0].fi;\n            segm[1].se += segm[0].se;\n            segm.pop_front();\n        }\n        cout << (tot / L) << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#define int         int64_t\n#define ii          pair<int,int>\n#define dd          pair<double,double>\n#define vi          vector<int>\n#define pb          push_back\n#define all(x)      (x).begin(), (x).end()\n#define checkBit(v, p)      (v&(1LL << p))\n#define loop(i,a,b) for(int i = a;i < int(b);i++)\n#define x           first\n#define y           second\nusing namespace std;\nint inf = 2e9, mod = 1e9 + 7;\n\nii operator+(dd a, dd b){\n    return {a.x+b.x, a.y+b.y};\n}\n\nii operator-(dd a, dd b){\n    return {a.x-b.x, a.y-b.y};\n}\n\ndouble slope(dd &p){\n    return p.y / p.x;\n}\n\ndouble comp(dd a, dd b, double x){\n    double s = (a.y - b.y) / (a.x - b.x);\n    return s + a.y / x - s / x * a.x;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false); cout << fixed <<setprecision(10);\n    int n, l; cin >> n >> l;\n    deque<dd> q;\n    dd sum(0,0);\n    for(int i=0;i<n;i++){\n        double t,v; cin >> t >> v;\n        t *= v;\n        dd p(v,t);\n        q.push_front(p);\n        sum = sum + p;\n        for(;sum.x - q.back().x >= l;q.pop_back()) sum = sum - q.back();\n\n        double length = q.back().x - (sum.x - l);\n        double hight = slope(q.back()) * length;\n        dd np(length, hight);\n        sum = sum - q.back();\n        sum = sum + np;\n        q.pop_back();\n        q.push_back(np);\n\n        cout << sum.y / (double)l<<'\\n';\n        dd tmp(0,0);\n        while(q.size() > 1 && slope(q[0]) <= slope(q[1])) tmp = tmp+q[0], q.pop_front();\n        q.front() = q.front() + tmp;\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b ; ++ i) \nconst int N = 5e5 + 5 ;\nconst double eps = 1e-12 ;\nusing namespace std ;\n\nint n, L ;\nstruct poi {\n\tlong double x, y ;\n} st[N], delta ;\n\nlong double cross(poi p0, poi p1, poi p2) {\n\treturn (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &L) ;\n\tint he = 1, ta = 1 ; poi u = {0.0, 0.0} ; st[1] = u ;\n\trep(i, 1, n) {\n\t\tscanf(\"%Lf%Lf\", &u.y, &u.x), u.y *= u.x ;\n\t\tdelta.x += u.x, delta.y += u.y ;\n\t\tu.x = - delta.x, u.y = - delta.y ;\n\t\tfor ( ; he < ta && st[he + 1].x + delta.x + eps > L ; ++ he) ;\n\t\tif (he == ta) st[he + 1] = u ; \n\t\tst[he].y = st[he + 1].y + (st[he].y - st[he + 1].y) * (1.0 * L - st[he + 1].x - delta.x) / (st[he].x - st[he + 1].x) ;\n\t\tst[he].x = 1.0 * L - delta.x ;\n\t\tfor ( ; he < ta && cross(u, st[ta], st[ta - 1]) > 0 ; -- ta) ;\n\t\tst[++ ta] = u ;\n\t\tprintf(\"%.10Lf\\n\", (st[he + 1].y + delta.y + (1.0 * L - st[he + 1].x - delta.x) / (st[he].x - st[he + 1].x) * (st[he].y - st[he + 1].y)) / L) ;\n\t}\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\t//for(j=num;j<=i;j++){\n\t\t\t//\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t//}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 500005\nusing namespace std;\ntypedef long long ll;\nstruct P{\n\tlong double t;\n\tll v;\n}a[N],q[N];\nint n,L;\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++) scanf(\"%Lf%lld\",&a[i].t,&a[i].v);\n\tint tou=1,wei=1;\n\tll sum=a[1].v;\n\tlong double T=a[1].t*a[1].v;\n\tq[1]=a[1];\n\tprintf(\"%.8Lf\\n\",a[1].t);\n\tfor(int i=2;i<=n;i++){\n\t\tsum+=a[i].v;T+=a[i].t*a[i].v;\n\t\twhile(sum>L){\n\t\t\tif(q[tou].v>sum-L) q[tou].v-=sum-L,T-=q[tou].t*(sum-L),sum=L;\n\t\t\telse sum-=q[tou].v,T-=q[tou].t*q[tou].v,tou++;\n\t\t}\n\t\tll v=a[i].v;long double t=a[i].t;\n\t\twhile(tou<=wei&&t<q[wei].t){\n\t\t\tt=(t*v+q[wei].t*q[wei].v)/(v+q[wei].v);\n\t\t\tv+=q[wei].v;\n\t\t\twei--;\n\t\t}\n\t\tq[++wei].t=t;q[wei].v=v;\n\t\tprintf(\"%.8Lf\\n\",T/sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <functional>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nint n;\nll l;\nll t[510000];\nll nw[510000];\nll dl[510000];\nll v[510000];\nld t2[510000];\n\nint main() {\n    scanf(\"%d%lld\", &n, &l);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%lld%lld\", t + i, v + i);\n    t2[0] = t[0];\n    printf(\"%.10Lf\\n\", t2[0]);\n    nw[0] = l;\n    for (int i = 1; i < n; ++i) {\n        dl[i - 1] += v[i];\n        nw[i - 1] -= v[i];\n        int now = i - 1;\n        while (now > 0) {\n            if (t2[now - 1] >= t2[now])\n                break;\n            if (dl[now] >= nw[now - 1]) {\n                dl[now] -= nw[now - 1];\n                dl[now - 1] += nw[now - 1];\n                nw[now - 1] = 0;\n                break;\n            }\n            nw[now - 1] -= dl[now];\n            dl[now - 1] += dl[now];\n            dl[now] = 0;\n            --now;\n        }\n        now = max(now, 1);\n        for (int j = now; j <= i; ++j)\n            t2[j] = (t[j] * v[j] + t2[j - 1] * nw[j - 1]) / (v[j] + nw[j - 1]);\n        nw[i] = l;\n        printf(\"%.10Lf\\n\", t2[i]);\n    }\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"data.in\",\"r\",stdin);\n        freopen(\"data.out\",\"w\",stdout);\n    #endif\n\n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\ninline int read(){\n\tint n=0,f=1;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif (c=='-') c=getchar(),f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) n=n*10+c-48;\n\treturn n*f;\n}\nconst int maxn=5e5+5;\nint i,j,n,head,tail;\ndouble q[maxn][2],V,T,L,t,v;\nint main(){\n\tn=read(),L=read();\n\thead=1,tail=0;\n\tfor(;n--;){\n\t\tt=read(),v=read();\n\t\tV+=v,T+=t*v;\n\t\tfor(;V>L;){\n\t\t\tif (V-q[head][0]>L)V-=q[head][0],T-=q[head][1]*q[head][0],head++;else{\n\t\t\t\tq[head][0]-=V-L,T-=(V-L)*q[head][1],V=L;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf\\n\",T/V);\n\t\tq[++tail][0]=v,q[tail][1]=t;\n\t\tfor(;head<tail;tail--){\n\t\t\tif (q[tail][1]>q[tail-1][1]) break;\n\t\t\tq[tail-1][1]=(q[tail-1][0]*q[tail-1][1]+q[tail][0]*q[tail][1])/(q[tail-1][0]+q[tail][0]);\n            q[tail-1][0]+=q[tail][0];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#define fi first\n#define se second\n#define mp make_pair\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double, LL> PDL;\ndeque<PDL> dq;\nconst int maxn = 5*1e5 + 100;\ndouble ans, t[maxn];\nLL V, v[maxn], L;\ninline PDL Mix(PDL x){\n    PDL y = dq.back();\n    ans -= y.fi*y.se;\n    dq.pop_back();\n    V -= y.se;\n    return mp((x.fi*x.se+y.fi*y.se)/(x.se+y.se), x.se+y.se);\n}\n\ninline void prePush(PDL x){\n    V += x.se;\n    while(V > L){\n        PDL &y = dq.front();\n        if(V-y.se <= L){\n            LL Vt = V-L;\n            ans -= y.fi*Vt;\n            V = L;\n            y.se -= Vt;\n        } else {\n            ans -= y.fi*y.se;\n            V -= y.se;\n            dq.pop_front();\n        }\n    }\n}\nint n;\nint main(){\n    cin>>n>>L;\n    for(int i = 0; i < n; i++) cin>>t[i]>>v[i];\n    dq.push_back(mp(t[0], v[0]));\n    ans = t[0]*v[0]; V = L;\n    printf(\"%.7f\\n\", ans/L);\n    for(int i = 1; i < n; i++){\n        PDL x = mp(t[i], v[i]);\n        prePush(x);\n        while(dq.size() > 0 && dq.back().fi >= x.fi) x = Mix(x);\n        dq.push_back(x);\n        ans += x.fi*x.se;\n        V = L;\n        printf(\"%.7f\\n\", ans/L);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>\t\t//UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>\t\t//do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define ULL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\n\n\nint main()\n{\n\tint N, L;\n\tdouble s = 0;\n\tscanf(\"%d%d\", &N, &L);\n\tint t, v;\n\tscanf(\"%d%d\", &t, &v);\n\tprintf(\"%d\\n\", t);\n\n\tmap<double, pair<LL, int>> M;\n\tM[t] = MP(v,0);\n\ts = t*(LL)v;\n\tFOR(i, 1, N)\n\t{\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tint rem = v, last = -1;\n\t\tfor (auto it = M.begin(); it != M.end() && rem;)\n\t\t{\n\t\t\tif (it->second.second < last)\n\t\t\t{\n\t\t\t\tauto it1 = it; it++;\n\t\t\t\tM.erase(it1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (it->second.first <= rem)\n\t\t\t{\n\t\t\t\trem -= it->second.first;\n\t\t\t\ts -= it->first*it->second.first;\n\t\t\t\tlast = it->second.second;\n\t\t\t\tauto it1 = it; it++;\n\t\t\t\tM.erase(it1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts -= it->first*rem;\n\t\t\t\tit->second.first -= rem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ts += t*(LL)v;\n\t\tM[s / (double)L].first = L;\n\t\tM[s / (double)L].second = i;\n\n\t\tprintf(\"%.9lf\\n\", s / (double)L);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ld,ld> pa;\nconst int N=1e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint L,n;\npa q[N],p[N];\npa merge(pa a,pa b){return pa((a.w1*a.w2+b.w1*b.w2)/(a.w2+b.w2),a.w2+b.w2);}\n#define QQ(a) (a.w1*a.w2)\nint main(){\n\tread(n,L);\n\tint h=5e5,t=h;\n\trep(i,1,n){\n\t\tll x,y;read(x,y);p[i]=pa(x,y);\n\t}\t\n\tq[h]=p[1];\n\tprintf(\"%.8lf\\n\",(db)p[1].w1);\n\tdb all=p[1].w2,Q=QQ(p[1]);\n\trep(i,2,n){\n\t\tall+=p[i].w2;\n\t\twhile(h<t&&all-q[t].w2>L){\n\t\t\tall-=q[t].w2;\n\t\t\tQ-=QQ(q[t]);\n\t\t\tt--;\n\t\t}\n\t\tif(all>L){\n\t\t\tQ-=QQ(q[t]);\n\t\t\tq[t].w2-=all-L,all=L;\n\t\t\tQ+=QQ(q[t]);\n\t\t}\n\t\t\n\t\twhile(q[h].w1>p[i].w1&&h<=t){\n\t\t\tQ-=QQ(q[h]);\n\t\t\tp[i]=merge(p[i],q[h]);\n\t\t\th++;\n\t\t}\n\t\t\th--;\n\t\t\tq[h]=p[i];\n\t\t\tQ+=QQ(q[h]);\n\t\tprintf(\"%.8lf\\n\",(db)(Q/all));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x first\n#define y second\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<double,double> pdd;\n\nconst ll MAX=505000;\nconst ll INF=0x3f3f3f3f3f3f3f;\nll N;\ndouble L;\ndouble v[MAX],t[MAX];\ndouble v_sum=0,vt_sum=0;\ndeque<pdd> graph;\nint modify(){\n    pdd t1,t2,t3;\n    if(graph.size()<3) return 0;\n    t1=graph.front(); graph.pop_front();\n    t2=graph.front(); graph.pop_front();\n    t3=graph.front();\n    if((t3.x-t2.x)*(t2.y-t1.y)<=(t3.y-t2.y)*(t2.x-t1.x)){\n        graph.push_front(t1);\n        return 1;\n    }\n    graph.push_front(t2); graph.push_front(t1);\n    return 0;\n}\nint dcut(){\n    pdd t1=graph.back(),t2;\n    if(t1.x+v_sum>L){\n        graph.pop_back();\n        t2=graph.back();\n        if(t2.x+v_sum<L){\n            graph.push_back(make_pair(L-v_sum,(L-v_sum-t2.x)/(t1.x-t2.x)*(t1.y-t2.y)+t2.y));\n            return 0;\n        }\n        return 1;\n    }\n    return 0;\n}\nint main(){\n    scanf(\"%lld%lf\",&N,&L);\n    for(ll i=0;i<N;i++) scanf(\"%lf%lf\",&t[i],&v[i]);\n    graph.push_front(make_pair(v_sum,vt_sum));\n    for(ll i=0;i<N;i++){\n        v_sum+=v[i],vt_sum+=v[i]*t[i];\n        graph.push_front(make_pair(-v_sum,-vt_sum));\n        while(dcut());\n        while(modify());\n        //printf(\"%d\\t%.10f\\t%.10f\\n\",graph.size(),graph.back().x,graph.back().y);\n        printf(\"%.10f\\n\",(graph.back().y+vt_sum)/(graph.back().x+v_sum));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\n\ndeque<pair<double,double> > que;\n\nint main()\n{\n\t//freopen(\"F.in\",\"r\",stdin);\n\tint n,L;\n\tscanf(\"%d%d\",&n,&L);\n\t\n\tpair<ll,ll> offset = make_pair(0,0);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tll t,v;\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\tif (i==1)\n\t\t{\n\t\t\tque.push_back(make_pair(0,0));\n\t\t\tque.push_back(make_pair((double)v,(double)v*(double)t));\n\t\t\tprintf(\"%.8f\\n\",(double)t);\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tdouble slope;\n\t\twhile (!que.empty() && que[que.size()-1].first + offset.first > (double)(L-v))\n\t\t{\n\t\t\tslope = (double)(que[que.size()-1].second - que[que.size()-2].second) / (double)(que[que.size()-1].first - que[que.size()-2].first);\n\t\t\tque.pop_back();\n\t\t}\n\t\tpair<double,double>  tmp;\n\t\tif (que[que.size()-1].first + offset.first != (double)(L-v))\n\t\t{\n\t\t\ttmp = make_pair((double)(L-v) - offset.first, ((double)(L-v) - (que[que.size()-1].first+offset.first)) * slope + que[que.size()-1].second);\n\t\t\tque.push_back(tmp);\n\t\t}\n\t\telse tmp = que[que.size()-1];\n\t\toffset.first += (double)v;\n\t\toffset.second += (double)(v*t);\n\t\tprintf(\"%.8f\\n\", (tmp.second + offset.second) / (tmp.first + offset.first));\n\t\t\n\t\tint lb = 0, ub = que.size()-1, mid;\n\t\twhile (ub > lb)\n\t\t{\n\t\t\tmid = (lb + ub)/2;\n\t\t\tif ((que[mid+1].second + offset.second) / (que[mid+1].first + offset.first) >= (que[mid].second + offset.second) / (que[mid].first + offset.first)) lb = mid+1;\n\t\t\telse ub = mid;\n\t\t}\n\t\tfor (int i=0;i<lb;i++) que.pop_front();\n\t\tque.push_front(make_pair(-offset.first,-offset.second));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\n\n#define NDEBUG\nNDEBUG\n\n\n#include <algorithm>\n#include <cassert>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <memory>\n#include <random>\n\n#define FOR(i, n) for (int i = 0; i < (n); ++i)\n\n\nusing namespace std;\n\n// TC_REMOVE_BEGIN\n/// caide keep\nbool __hack = std::ios::sync_with_stdio(false);\n/// caide keep\nauto __hack1 = cin.tie(nullptr);\n// TC_REMOVE_END\n\n\nnamespace template_util {\n    \n\n    constexpr int bytecount(uint64_t x) {\n        return x ? 1 + bytecount(x >> 8) : 0;\n    }\n\n    /// caide keep\n    template<int N>\n    struct bytetype {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<4> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<3> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<2> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<1> {\n        \n    };\n\n    /// caide keep\n    template<>\n    struct bytetype<0> {\n        \n    };\n\n    /// caide keep\n    template<uint64_t N>\n    struct minimal_uint : bytetype<bytecount(N)> {\n    };\n}\n\n\ntemplate <typename T>\nstruct BasePoint {\n    T x, y;\n    BasePoint(T _x, T _y) : x(_x), y(_y) {}\n\n    \n};\n\n\ntemplate <typename T>\nstruct Point : BasePoint<T> {\n    \n    \n};\n\ntemplate<>\nstruct Point<double> : BasePoint<double> {\n    \n    Point(double _x, double _y) : BasePoint<double>(_x, _y) {}\n    \n    \n};\n\n\n//\n//template <typename T>\n//inline T area(const Point<T>& A, const Point<T>& B, const Point<T>& C) {\n//    return (B.x - A.x) * (C.y - A.y) - (B.y - A.y) * (C.x - A.x);\n//}\n//\n//inline bool intersectHelper(int a, int b, int c, int d) {\n//    if (a > b) {\n//        swap (a, b);\n//    }\n//    if (c > d) {\n//        swap (c, d);\n//    }\n//    return max(a,c) <= min(b,d);\n//}\n//\n//bool intersect (pt a, pt b, pt c, pt d) {\n//    return intersect_1 (a.x, b.x, c.x, d.x)\n//           && intersect_1 (a.y, b.y, c.y, d.y)\n//           && area(a,b,c) * area(a,b,d) <= 0\n//           && area(c,d,a) * area(c,d,b) <= 0;\n//}\n//\n//bool segmentIntersection(Point<double> A, Point<double> B, Point<double> C, Point<double> D){\n//    double t = ((A - C) * (C - D)) / ((A - B) * (C - D));\n//    return A + (B - A) * t;\n//}\n#include <deque>\n\n\ntemplate<class T>\nT next(istream& in) {\n    T ret;\n    in >> ret;\n    return ret;\n}\n\n\ndouble sum;\nint cur_v;\nint L;\ntypedef Point<double> Pnt;\ndeque<Pnt> q;\nvoid process(double t, int v) {\n    Pnt cur(t, v);\n    while (q.size() >= 2) {\n        auto A = q.back(); q.pop_back();\n        auto B = q.back(); q.pop_back();\n        if (B.x >= A.x) {\n            q.push_back(Pnt((A.x * A.y + B.x * B.y) / (A.y + B.y), A.y + B.y));\n        } else {\n            q.push_back(B);\n            q.push_back(A);\n            break;\n        }\n    }\n    q.push_back(cur);\n    cur_v += v;\n    sum += t * v;\n    while (cur_v > L) {\n        if (cur_v - q.front().y >= L) {\n            cur_v -= q.front().y;\n            sum -= q.front().x * q.front().y;\n            q.pop_front();\n        } else {\n            Pnt A = q.front();\n            q.pop_front();\n            A.y -= (cur_v - L);\n            sum -= (cur_v - L) * A.x;\n            q.push_front(A);\n            cur_v = L;\n        }\n    }\n}\n\nvoid solve(istream& in, ostream& out) {\n    int n = next<int>(in);\n    L = next<int>(in);\n    cur_v = 0;\n    sum = 0;\n    FOR(i, n) {\n        int t = next<int>(in);\n        int x = next<int>(in);\n        process(t, x);\n        out << setprecision(10) << fixed << sum / L << endl;\n    }\n}\n\n\nint main() {\n    solve(cin, cout);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1*d1.front().second;\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    totv-=d1.front().first;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n       totprod-=v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=(long double)1*d1.back().first*d1.back().second;\n                double tempp = (long double)1*tempv*tempt;\n                tempp+=(long double)1*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1*tempp)/((long double)1*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nint l,r;\ninline Vector merge(Vector a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n\treturn a;\t\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) q[r-1]=merge(q[r-1],q[r--]);\n\t\tcout<<(db)y/L<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t\t//printf(\"%d %.6lf %.0lf\\n\",l,sum,now);\n\t    ans[i]=sum/m;\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tdouble tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*q[r-1].b)/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.7lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\too now=(oo){a[i],b[i]};int w=r;\n\t\twhile(w>=l){\n\t\t\tif(now.b+q[w].b>=m){\n\t\t\t\tans[i]=(now.b*now.a+(m-now.b)*q[w].a)/m;\n\t\t\t\tl=w;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow.a=(now.a*now.b+q[w].a*q[w].b)/(now.b+q[w].b);\n\t\t\tnow.b=now.b+q[w].b;\n\t\t\tw--;\n\t\t}\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tint tot=min((int)(q[r-1].b+q[r].b),m);\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\ntypedef long double ld;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=500010;\nstruct water{\n\tld vt;\n\tint v;\n\tinline ld t(){\n\t\treturn vt/v;\n\t}\n\tinline friend water operator + (const water &a,const water &b){\n\t\treturn (water){a.vt+b.vt,a.v+b.v};\n\t}\n\tinline void operator += (const water &b){\n\t\t*this=*this+b;\n\t}\n\tinline void operator -= (const water &b){\n\t\t*this+=(water){-b.vt,-b.v};\n\t}\n}que[N],cur;\nint main(){\n\tint n=ni,v=ni;\n\tint qh=0,qt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint tmp=ni;\n\t\twater a;\n\t\ta.v=ni;\n\t\ta.vt=(lint)a.v*tmp;\n\t\tfor(;cur.v+a.v>v&&cur.v+a.v-que[qh].v>=v;cur-=que[qh++]);\n\t\tif(cur.v+a.v>v){\n\t\t\tint del=cur.v+a.v-v;\n\t\t\tld delvt=que[qh].t()*del;\n\t\t\tcur-=(water){delvt,del};\n\t\t\tque[qh].vt-=delvt;\n\t\t\tque[qh].v-=del;\n\t\t}\n\t\tcur+=a;\n\t\tprintf(\"%.10lf\\n\",(double)cur.t());\n\t\tfor(;qh<qt&&que[qt-1].t()>tmp;a+=que[--qt]);\n\t\tque[qt++]=a;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define myp pair<db,db>\nusing namespace std;\nconst int N=5e5+10;\nint n,l;\nmyp q[N]; //pair<v,v*t> 比较时不会产生精度误差 \nint head,tail;\nint main(){\n\tdb v,t,temp_v=0,temp=0,now_t;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf%lf\",&t,&v);\n\t\tq[head++]=make_pair(v,v*t);\n\t\ttemp_v+=v,temp+=v*t;\n\t\twhile(temp_v>l){\n\t\t\tif(temp_v-q[tail].first>=l) temp_v-=q[tail].first,temp-=q[tail].second,tail++;\n\t\t\telse now_t=q[tail].second/q[tail].first,q[tail].first-=temp_v-l,temp_v=l,temp=temp-q[tail].second+now_t*q[tail].first,q[tail].second=now_t*q[tail].first;\n\t\t}\n\t\tif(head-2>=tail&&q[head-1].second/q[head-1].first<q[head-2].second/q[head-2].first) q[head-2].first+=q[head-1].first,q[head-2].second+=q[head-1].second,head--;\n\t\tprintf(\"%.6lf\\n\",temp/temp_v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 500002;\nint n, L;\nset<ii> storage;\n\n\nint main(){\n\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &L);\n    ll tot1 = 0, tot2 = 0;\n    set<ii>::iterator it;\n// n=2;\n    for(int i=1;i<=n;i++){\n        ll temp, vol;\n        scanf(\"%lld%lld\", &temp, &vol);\n        while(tot2+vol > L){\n\n            it = storage.begin();\n            ll z = min(tot2+vol-L, (*it).ss);\n            \n            tot2 -= z;\n            ll newtemp = (*it).ff, newvol = (*it).ss - z;\n            tot1 -= newtemp*z;\n            storage.erase(it);\n            if(newvol > 0)\n                storage.insert(ii(newtemp, newvol));\n        }\n\n// cout<<\"middle of i = \"<<i<<\", storage: \";for(auto it : storage) cout<<it.ff<<\":\"<<it.ss<<\" \";cout<<\" and tot1 = \"<<tot1<<\" tot2 = \"<<tot2<<endl;\n\n\n        it = storage.lower_bound(ii(temp, 0));\n        if(it != storage.end() && (*it).ff == temp){\n            vol += (*it).ss;\n            tot1 -= (*it).ff * 1LL * (*it).ss;\n            tot2 -= (*it).ss;\n            storage.erase(it);\n        }\n        storage.insert(ii(temp, vol));\n        tot1 += temp * 1LL * vol;\n        tot2 += vol;\n\n        double ans = (1.0*tot1) / tot2;\n        printf(\"%.7lf\\n\", ans);\n// cout<<\"after i = \"<<i<<\", storage: \";for(auto it : storage) cout<<it.ff<<\":\"<<it.ss<<\" \";cout<<\" and tot1 = \"<<tot1<<\" tot2 = \"<<tot2<<endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\nstatic const int MAXN = 5e5 + 4;\n#define double long double\n\nint n, l;\nint t[MAXN], v[MAXN];\n\nint qhead, qtail;\nstd::pair<double, double> q[MAXN];\nstd::pair<double, double> offset;\n\ndouble eval_linear(std::pair<double, double> p, std::pair<double, double> q, double x)\n{\n    double ratio = (x - p.first) / (q.first - p.first);\n    return p.second * (1.0 - ratio) + q.second * ratio;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &l);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &t[i], &v[i]);\n\n    qhead = MAXN - 2, qtail = MAXN;\n    q[MAXN - 2] = std::make_pair(0, 0);\n    q[MAXN - 1] = std::make_pair(v[0], (double)v[0] * t[0]);\n    offset = std::make_pair(0, 0);\n    printf(\"%.8Lf\\n\", (double)t[0]);\n\n    for (int i = 1; i < n; ++i) {\n        offset.first += v[i];\n        while (qtail > qhead + 1 && q[qtail - 2].first + offset.first > l) --qtail;\n        q[qtail - 1] = std::make_pair(l - offset.first, eval_linear(q[qtail - 2], q[qtail - 1], l - offset.first));\n        offset.second += (double)v[i] * t[i];\n        int lo = qhead, hi = qtail, mid;\n        while (lo < hi - 1) {\n            mid = (lo + hi) >> 1;\n            if ((q[mid].second + offset.second) / (q[mid].first + offset.first)\n                >= (q[mid - 1].second + offset.second) / (q[mid - 1].first + offset.first)) lo = mid;\n            else hi = mid;\n        }\n        qhead = lo;\n        q[--qhead] = std::make_pair(-offset.first, -offset.second);\n        printf(\"%.8Lf\\n\", (q[qtail - 1].second + offset.second) / l);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#include <random>\n#include <memory>\n#include <utility>\n#include <limits>\n#include \"limits.h\"\n \n#define rep(i, a, b) for (long long (i) = (a); i < (b); i++)\n#define all(i) i.begin(), i.end()\n#define debug(i) std::cerr << \"debug \" <<\"LINE:\"<<__LINE__<<\"  \"<< #i <<\":\"<< i << std::endl\n\n \ntemplate <typename T1, typename T2>\nstd::ostream& operator<<(std::ostream& os, std::pair<T1, T2> pa) {\n  return os << pa.first << \" \" << pa.second;\n}\n \ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& os, std::vector<T> vec) {\n  for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n  return os;\n}\n \ntemplate<typename T1,typename T2>\ninline bool chmax(T1& a,T2 b){return a<b && (a=b,true);}\n \ntemplate<typename T1,typename T2>\ninline bool chmin(T1& a,T2 b){return a>b && (a=b,true);}\n \nlong long pow_mod(long long a, long long b, long long mod=-1) {\n  if(b==0)return 1;\n\n  if ((a == 0)||(mod!=-1&&(a+mod)%mod==0)) {\n    return 0;\n  }\n \n  long long x = 1;\n \n  while (b > 0) {\n    if (b & 1) {\n      x = (mod!=-1)?(x * a) % mod:x*a;\n    }\n    a = (mod!=-1)?(a * a) % mod:a*a;\n    b >>= 1;\n  }\n  return x;\n}\n \n// const long long MOD = 998244353;\nconst long long MOD = 1e9 + 7;\n\nusing ll = long long;\nusing P = std::pair<long double, long double>;\n\n\n\nint main() {\n  std::cin.tie(0);\n  std::ios::sync_with_stdio(false);\n\n  ll n;\n  long double l;\n  std::cin>>n>>l;\n\n  std::cout<<std::setprecision(20)<<std::fixed;\n\n  std::deque<P> que;\n\n  long double hot=0;\n\n  rep(i,0,n){\n    long double t,v;\n    std::cin>>t>>v;\n\n    if(i==0){\n      std::cout<<t<<\"\\n\";\n      que.push_back({t*v,v});\n      hot+=t*v;\n      continue;\n    }\n\n    long double res=v;\n    while(que.front().second<=res){\n      P e=que.front();que.pop_front();\n      hot-=e.first*e.second;\n      res-=e.second;\n    }\n    if(!que.empty()){\n      P e=que.front();que.pop_front();\n      hot-=res*e.first/e.second;\n      e.first-=res*e.first/e.second;\n      e.second-=res;\n      que.push_front(e);\n    }\n\n    hot+=t*v;\n\n    std::cout<<hot/l<<\"\\n\";\n\n    P temp={t*v,v};\n\n    while((!que.empty())&&que.back().first*temp.second > temp.first*que.back().second){\n      P e=que.back();que.pop_back();\n      temp.first+=e.first;\n      temp.second+=e.second;\n    }\n\n    que.push_back(temp);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define myp pair<ll,ll>\nusing namespace std;\nconst int N=5e5+10;\nint n,l;\nmyp q[N]; //pair<v,v*t> 比较时不会产生精度误差 \nint head,tail;\nint main(){\n\tll v,t,temp_v=0,temp=0;\n\tdb now_t;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\tq[head++]=make_pair(v,v*t);\n\t\ttemp_v+=v,temp+=v*t;\n\t\twhile(temp_v>l){\n\t\t\tif(temp_v-q[tail].first>=l) temp_v-=q[tail].first,temp-=q[tail].second,tail++;\n\t\t\telse now_t=db(q[tail].second)/q[tail].first,q[tail].first-=temp_v-l,temp_v=l,temp=temp-q[tail].second+now_t*q[tail].first,q[tail].second=now_t*q[tail].first;\n\t\t}\n\t\tif(head-2>=tail&&q[head-1].second/q[head-1].first<q[head-2].second/q[head-2].first) q[head-2].first+=q[head-1].first,q[head-2].second+=q[head-1].second,head--;\n\t\tprintf(\"%.8lf\\n\",db(temp)/temp_v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=5e5+5;\nint n,l,r;\ndouble ans,ll,v,d[N][2];\nvoid merge(int x)\n{\n\td[x][0]=(d[x][0]*d[x][1]+d[x+1][0]*d[x+1][1])/(d[x][1]+d[x+1][1]);\n\td[x][1]+=d[x+1][1];\n}\nint main()\n{\n\tscanf(\"%d%lf\",&n,&ll),l=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tr++,scanf(\"%lf%lf\",&d[r][0],&d[r][1]);\n\t\tv+=d[r][1],ans+=d[r][0]*d[r][1];\n\t\twhile (v>ll)\n\t\t{\n\t\t\tif (v-d[l][1]>=ll)\n\t\t\t{\n\t\t\t\tv-=d[l][1];\n\t\t\t\tans-=d[l][0]*d[l][1];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\td[l][1]-=v-ll;\n\t\t\t\tans-=(v-ll)*d[l][0];\n\t\t\t\tv=ll;\n\t\t\t}\n\t\t}\n\t\twhile (r>l && d[r][0]<=d[r-1][0]) merge(--r);\n\t\tprintf(\"%lf\\n\",ans/ll);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing my_double = long double;\n\nstruct point {\n    my_double x, y;\n\n    point() : x(0), y(0) {}\n\n    point(my_double _x, my_double _y) : x(_x), y(_y) {}\n\n    point& operator+=(const point &other) { x += other.x; y += other.y; return *this; }\n    point& operator-=(const point &other) { x -= other.x; y -= other.y; return *this; }\n    point& operator*=(my_double mult) { x *= mult; y *= mult; return *this; }\n\n    point operator+(const point &other) const { return point(*this) += other; }\n    point operator-(const point &other) const { return point(*this) -= other; }\n    point operator*(my_double mult) const { return point(*this) *= mult; }\n\n    // Warning: does exact floating-point comparisons.\n    bool operator==(const point &other) const { return x == other.x && y == other.y; }\n    bool operator!=(const point &other) const { return !(*this == other); }\n\n    point operator-() const { return point(-x, -y); }\n    point rotate90() const { return point(-y, x); }\n\n    my_double norm() const {\n        return x * x + y * y;\n    }\n\n    my_double dist() const {\n        return sqrt(norm());\n    }\n\n    bool top_half() const {\n        return make_pair(y, x) > pair<my_double, my_double>(0, 0);\n    }\n\n    friend ostream& operator<<(ostream &stream, const point &p) {\n        return stream << '(' << p.x << \", \" << p.y << ')';\n    }\n};\n\nmy_double cross(const point &a, const point &b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nmy_double dot(const point &a, const point &b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nbool left_turn_strict(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) > 0;\n}\n\nbool left_turn_lenient(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) >= 0;\n}\n\n// Warning: does a floating-point comparison to exactly 0.\nbool collinear(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) == 0;\n}\n\n// Returns the signed, doubled area formed by three points in a triangle. Positive when a -> b -> c is a left turn.\nmy_double area_signed_doubled(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a);\n}\n\nmy_double distance_to_line(const point &p, const point &a, const point &b) {\n    assert(a != b);\n    return abs(area_signed_doubled(p, a, b)) / (a - b).dist();\n}\n\nmy_double manhattan_dist(const point &a, const point &b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nmy_double infinity_norm_dist(const point &a, const point &b) {\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\n// Sort in increasing order of y, with ties broken in increasing order of x.\nbool yx_compare(const point &a, const point &b) {\n    return (b - a).top_half();\n}\n\n// Sort in increasing order of angle to the x-axis.\nbool angle_compare(const point &a, const point &b) {\n    if (a.top_half() ^ b.top_half())\n        return a.top_half();\n\n    return cross(a, b) > 0;\n}\n\n\nint N;\nlong long L;\n\nint main() {\n    scanf(\"%d %lld\", &N, &L);\n    deque<point> poly_line = {point(0, 0)};\n\n    for (int i = 0; i < N; i++) {\n        long long T, V;\n        scanf(\"%lld %lld\", &T, &V);\n        poly_line.push_front(poly_line.front() + point(-V, -T * V));\n\n        while (poly_line[poly_line.size() - 2].x - poly_line.front().x >= L)\n            poly_line.pop_back();\n\n        point second_last = poly_line[poly_line.size() - 2];\n        point delta = poly_line.back() - second_last;\n        my_double portion = poly_line.front().x + L - second_last.x;\n        delta *= portion / (poly_line.back().x - second_last.x);\n        poly_line.back() = second_last + delta;\n\n        while (poly_line.size() >= 3 && left_turn_lenient(poly_line[0], poly_line[1], poly_line[2])) {\n            poly_line[1] = poly_line[0];\n            poly_line.pop_front();\n        }\n\n        my_double answer = (poly_line.back().y - poly_line.front().y) / L;\n        printf(\"%.7g\\n\", (double) answer);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <functional>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\nint n;\nll l;\nll t[510000];\nll v[510000];\n\n\nint bd(pair<ld, ld> a, pair<ld, ld> b) {\n    return a.first * b.second - a.second * b.first >= 0;\n}\n\ndeque<pair<ld, ld> > dq;\n\nint main() {\n    scanf(\"%d%lld\", &n, &l);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%lld%lld\", t + i, v + i);\n    pair<ld, ld> md = make_pair(0, 0);\n    dq.push_front(md);\n    for (int i = 0; i < n; ++i) {\n        md.first += v[i];\n        md.second += v[i] * t[i];\n        pair<ld, ld> pr = dq.back();\n        while (!dq.empty() && dq.back().first + md.first >= l) {\n            pr = dq.back();\n            dq.pop_back();\n        }\n        pair<ld, ld> pr2 = make_pair(0, 0);\n        if (!dq.empty())\n            pr2 = dq.back(), pr2.first += md.first, pr2.second += md.second;\n        pr.first += md.first;\n        pr.second += md.second;\n        pr.first -= pr2.first;\n        pr.second -= pr2.second;\n        ld hv = l - pr2.first;\n        ld k = hv / pr.first;\n        pr = make_pair(pr2.first + pr.first * k, pr2.second + pr.second * k);\n        printf(\"%.10Lf\\n\", pr.second / pr.first);\n        pr.first -= md.first;\n        pr.second -= md.second;\n        dq.push_back(pr);\n        while (dq.size() >= 2 && bd(make_pair(dq[0].first + md.first, dq[0].second + md.second), make_pair(dq[1].first + md.first, dq[1].second + md.second)))\n            dq.pop_front();\n        dq.push_front(make_pair(-md.first, -md.second));\n    }\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst double eps=1e-12;\nconst int inf=0x3f3f3f3f;\nconst int N=500005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nstruct node{double x,y;}now,q[N];\nint n,L,head=500001,tail=500000;\n\ninline node operator + (const node &a,const node &b){return (node){a.x+b.x,a.y+b.y};}\ninline node operator - (const node &a,const node &b){return (node){a.x-b.x,a.y-b.y};}\ninline node operator * (const node &a,const double &b){return (node){a.x*b,a.y*b};}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++){\n\t\tnode p;scanf(\"%lf%lf\",&p.y,&p.x);\n\t\tp.y*=p.x;now=now+p;\n\t\twhile(head<=tail&&now.x>L+eps)\n\t\t\tif(now.x-q[tail].x>L+eps) tail--,now=now-q[tail]; else{\n\t\t\t\tnow=now-q[tail];\n\t\t\t\tq[tail]=q[tail]*((L-now.x)/q[tail].x);\n\t\t\t\tnow=now+q[tail];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tprintf(\"%.9f\\n\",now.y/now.x);\n\t\twhile(head<=tail&&p.y/p.x<q[head].y/q[head].x) p=p+q[head],head++;\n\t\tq[--head]=p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<set>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\nconst int N=1e6+5,mo=998244353;\nstruct rec\n{\n\tll v;\n\tdb t;\n}s[N];\nll sum,t[N],v[N],l,r,n,L,prod,i,dec;\nint main()\n{\n\tscanf(\"%lld %lld\",&n,&L);\n\tl=1;\n\tr=0;\n\tfo(i,1,n)\n\t{\n\t\tscanf(\"%lld %lld\",t+i,v+i);\n\t\twhile (sum+v[i]>L)\n\t\t{\n\t\t\tdec=min(s[l].v,sum+v[i]-L);\n\t\t\ts[l].v-=dec;\n\t\t\tsum-=dec;\n\t\t\tprod-=dec*s[l].t;\n\t\t\tif (!s[l].v) l++;\n\t\t}\n\t\ts[++r]={v[i],t[i]};\n\t\tprod+=v[i]*t[i];\n\t\tsum+=v[i];\n\t\twhile (l<r&&s[r].t<s[r-1].t)\n\t\t{\n\t\t\ts[r-1].t=(s[r-1].t*s[r-1].v+s[r].t*s[r].v)/(s[r-1].v+s[r].v);\n\t\t\ts[r-1].v+=s[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%lf\\n\",(db)prod/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\ndouble sumsTV[500011];\ndouble sumsV[500011];\n\ndouble evalH(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + H[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\ndouble evalT(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + T[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\n\nint qu[500011];\nint *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    REP (i, N) {\n\tsumsTV[i+1] = sumsTV[i] + (double)T[i] * V[i];\n\tsumsV[i+1] = sumsV[i] + (double)V[i];\n    }\n\n    H[0] = T[0];\n    *head = 0; // {0};\n\n    int pos = 0;\n    for (int i=1; i<N; i++) {\n\twhile (sumsV[i+1] - sumsV[*head+1] >= L) head++;\n\n\tint *nxt_head = head;\n\tfor (int j=0; j<20 && j<=(tail-head); j++) {\n\t    double d = evalH(*(head+j), i);\n\t    if (H[i] <= d) {\n\t\tH[i] = d;\n\t\tnxt_head = head+j;\n\t    }\n\t}\n\thead = nxt_head;\n \n\twhile (sumsV[i+1] - sumsV[pos+1] >= L) pos++;\n\tamax(H[i], evalT(pos, i));\n\n\twhile (head <= tail && H[*tail] <= H[i]) tail--;\n\ttail++;\n\t*tail = i;\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n#define ll long long\n#define db double\nconst int N=1e6,P=998244353;\n\n#define C getchar()-48\nll read()\n{\n  ll s=0,t=1,k=C;\n  for (;k<0||9<k;k=C) if (k==-3) t=-1;\n  for (;0<=k&&k<=9;k=C) s=(s<<1)+(s<<3)+k;\n  return s*t;\n}\n\n  struct rec\n    {\n      ll v;\n      db t;\n    }s[N];\n  ll sum,l=1,r,prod,i,de;\n\n  ll n,L;\n\tll t[N],v[N];\nvoid in()\n{\n  cin>>n>>L;\n  for (int i=0;++i<=n;)\n\t  t[i]=read(),v[i]=read();\n}\n\nvoid sol()\n{\n  for (int i=0;++i<=n;)\n    {\n        while (sum+v[i]>L)\n        {\n            de=min(s[l].v,sum+v[i]-L);\n            s[l].v-=de;\n            sum-=de;\n            prod-=de*s[l].t;\n            if (!s[l].v) l++;\n        }\n        s[++r]={v[i],t[i]};\n        prod+=v[i]*t[i];\n        sum+=v[i];\n        while (l<r&&s[r].t<s[r-1].t)\n        {\n            s[r-1].t=(s[r-1].t*s[r-1].v+s[r].t*s[r].v)/(s[r-1].v+s[r].v);\n            s[r-1].v+=s[r].v;\n            r--;\n        }\n        printf(\"%lf\\n\",(db)prod/L);\n    }\n}\n\nint main()\n{\n  in();\n\tsol(); \n  exit(0);\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RF(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstring>\n#include<cctype>\n#include<cstdio>\n#define rep(i,x,y) for(int i=x; i<=y; ++i)\n\nusing namespace std;\nconst int N=500005;\nint n,L,head,tail;\nstruct data\n{\n\tint x;\n\tdouble y;\n\n\tvoid operator += (data &t)\n\t{\n\t\tx+=t.x,y+=t.y;\n\t}\n\n\tvoid operator -= (data &t)\n\t{\n\t\tx-=t.x,y-=t.y;\n\t}\n\n\tvoid change(int t)\n\t{\n\t\ty=y/x*t,x=t;\n\t}\n} q[N<<1],nw,tmp;\n\nint getint()\n{\n\tchar ch;\n\twhile(!isdigit(ch=getchar()));\n\tint x=ch-48;\n\twhile(isdigit(ch=getchar())) x=x*10+ch-48;\n\treturn x;\n}\n\nbool cmp(data a,data b)\n{\n\treturn a.y/a.x<b.y/b.x;\n}\n\nint main()\n{\n\tn=getint(),L=getint();\n\thead=n,tail=n-1;\n\trep(i,1,n)\n\t{\n\t\ttmp.y=getint(),tmp.x=getint();\n\t\ttmp.y*=tmp.x;\n\t\twhile(nw.x>L-tmp.x)\n\t\t{\n\t\t\tif(nw.x-q[tail].x>=L-tmp.x) nw-=q[tail--];\n\t\t\telse\n\t\t\t{\n\t\t\t\tnw-=q[tail],q[tail].change(L-tmp.x-nw.x);\n\t\t\t\tnw+=q[tail];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile(head<=tail && cmp(tmp,q[head])) nw-=q[head],tmp+=q[head++];\n\t\tq[--head]=tmp,nw+=tmp;\n\t\tprintf(\"%.10lf\\n\",nw.y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<double, double> P;\nint main() {\n\tint N, L;\n\tcin >> N >> L;\n\tdouble sumT = 0;\n\tdeque<P> Q;\n\tll t, v;\n\tcin >> t >> v;\n\tQ.emplace_back(t, v);\n\tsumT += t * v;\n\tprintf(\"%.15lf\\n\", sumT / L);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> t >> v;\n\t\tdouble sumV = L;\n\t\twhile (sumV > L - v) {\n\t\t\tif (Q.front().second <= sumV - (L - v)) {\n\t\t\t\tsumV -= Q.front().second;\n\t\t\t\tsumT -= Q.front().first*Q.front().second;\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tQ.front().second -= sumV - (L - v);\n\t\t\t\tsumT -= Q.front().first*(sumV - (L - v));\n\t\t\t\tsumV = L - v;\n\t\t\t}\n\t\t}\n\t\tsumT += t * v;\n\t\tP now = P(t, v);\n\t\twhile (!Q.empty() && Q.back().first > now.first) {\n\t\t\tdouble sum_t = Q.back().first*Q.back().second + now.first + now.second;\n\t\t\tdouble sum_v = Q.back().second + now.second;\n\t\t\tnow = P(sum_t / sum_v, sum_v);\n\t\t\tQ.pop_back();\n\t\t}\n\t\tQ.push_back(now);\n\t\tprintf(\"%.15lf\\n\", sumT / L);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  LL n, l;\n  deque<pair<int, double>> cal;\n  vector<LL> t, v;\n  Solver(LL n) : n(n), t(n), v(n){};\n  double temperature(int a, int b) {\n    return (cal[b].second - cal[a].second) / (double)(cal[b].first - cal[a].first);\n  }\n  void solve() {\n    cin >> l;\n    for (int i = 0; i < n; ++i) {\n      cin >> t[i] >> v[i];\n    }\n    cal.emplace_back(0, 0);\n    for (int i = 0; i < n; ++i) {\n      // increse\n      cal.emplace_front(cal[0].first - v[i], cal[0].second - t[i] * v[i]);\n      //answer\n      DBG(cal)\n      cout << temperature(0, cal.size() - 1) << endl;\n      //mix\n      if (cal.size() >= 3 && temperature(0, 1) < temperature(1, 2)) {\n        cal.erase(cal.begin() + 1);\n      }\n      if (i == n - 1) break;\n      while (1) {\n        auto tmp = cal.back();\n        cal.pop_back();\n        int upperBound = l - v[i + 1];\n        if (cal.back().first <= cal[0].first + upperBound) {\n          cal.emplace_back(cal[0].first + upperBound, cal.back().second + (tmp.second - cal.back().second) / (tmp.first - cal.back().first) * (cal[0].first + upperBound - cal.back().first));\n          break;\n        }\n      }\n      DBG(cal)\n    }\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  std::cout << std::fixed << std::setprecision(12);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 500000\nlong double t[MN+5],st[MN+5];\nlong long l[MN+5],sl[MN+5];\nint z[MN+5],zn;\nint main()\n{\n\tint n=read(),L=read(),i,p=1;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tt[i]=read();l[i]=read();t[i]*=l[i];\n\t\tfor(;zn&&t[i]*l[z[zn]]<=t[z[zn]]*l[i];--zn)\n\t\t{\n\t\t\tt[i]+=t[z[zn]];l[i]+=l[z[zn]];\n\t\t\tif(l[i]>L)t[i]-=t[z[zn]]*(l[i]-L)/l[z[zn]],l[i]=L;\n\t\t}\n\t\tz[++zn]=i;st[zn]=st[zn-1]+t[i];sl[zn]=sl[zn-1]+l[i];\n\t\twhile(sl[zn]-sl[p]>=L)++p;\n\t\tprintf(\"%.7lf\\n\",double((t[z[p]]*(L-sl[zn]+sl[p])/l[z[p]]+st[zn]-st[p])/L));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define fup(i,a,b) for(int i=a;i<=b;i++)\n#define ll long long\ninline int read()\n{\n    int X=0,w=1; char ch=0;\n    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();\n    return X*w;\n}\nstruct dl{ int v; double t; }d[500005];\nint n,l,v,t,h = 1,len; double x,y;\ninline void insert(int t,int v)\n{\n\td[++len].v = v; d[len].t = t;\n\twhile(len>h&&d[len].t<=d[len-1].t)\n\t{ \n\t\td[len-1].t = (d[len].t*d[len].v+d[len-1].t*d[len-1].v)/(d[len].v+d[len-1].v);\n\t\td[len-1].v = d[len].v+d[len-1].v; len--;\n\t}\n}\nint main()\n{\n\t//freopen(\"E:\\\\inout\\\\cs.in\",\"r\",stdin);\n\tn = read(); l = read();\n\tfup(i,1,n)\n\t{\n\t\tt = read(); v = read();\n\t\ty = y+(double)v*t; x = x+v;\n\t\twhile(h<=len&&x>l)\n\t\t{\n\t\t\tif(x-l>=d[h].v)\n\t\t\t{\n\t\t\t\tx -= d[h].v;\n\t\t\t\ty -= 1LL*d[h].v*d[h].t;\n\t\t\t}else\n\t\t\t{\n\t\t\t\td[h].v -= x-l;\n\t\t\t\ty -= (double)(x-l)*d[h].t;\n\t\t\t\tx = l; break;\n\t\t\t} h++;\n\t\t}\n\t\tinsert(t,v); printf(\"%.7lf\\n\",y/x);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\nint N,L;\ndouble T,V;\nmap<ll,ll> M;\ndouble TV,TT;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>L;\n\t\n\tdeque<pair<double,double>> D;\n\t\n\tFOR(i,N) {\n\t\tcin>>T>>V;\n\t\t\n\t\tif(i) {\n\t\t\tdouble del=V;\n\t\t\t\n\t\t\twhile(del>0) {\n\t\t\t\tif(D.front().second<=del) {\n\t\t\t\t\tdel -= D.front().second;\n\t\t\t\t\tTV -= D.front().second;\n\t\t\t\t\tTT -= D.front().first*D.front().second;\n\t\t\t\t\tD.pop_front();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tD.front().second -= del;\n\t\t\t\t\tTV -= del;\n\t\t\t\t\tTT -= D.front().first*del;\n\t\t\t\t\tdel = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tTV += V;\n\t\tTT += T*V;\n\t\t_P(\"%.12lf\\n\",1.0*TT/TV);\n\t\t\n\t\twhile(D.size() && D.back().first>T) {\n\t\t\tdouble TTT = T*V + D.back().first*D.back().second;\n\t\t\tV = V + D.back().second;\n\t\t\tT = TTT/V;\n\t\t\tD.pop_back();\n\t\t}\n\t\tD.push_back({T,V});\n\t\t\n\t\t\n\t}\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass Data\n{\npublic:\n    double t;\n    long long v;\n    Data(){\n        t = 0.0;\n        v = 0;\n    }\n    Data(double t, long long v){\n        this->t = t;\n        this->v = v;\n    }\n    Data operator+(const Data& d){\n        double t2 = (t * v + d.t * d.v) / (v + d.v);\n        long long v2 = v + d.v;\n        return Data(t2, v2);\n    }\n};\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n    cout.setf(ios_base::fixed, ios_base::floatfield);\n    cout << setprecision(10);\n\n    int n, l;\n    cin >> n >> l;\n\n    deque<Data> dq;\n    double sum = 0.0;\n    while(--n >= 0){\n        Data in;\n        cin >> in.t >> in.v;\n\n        if(!dq.empty()){\n            long long out = in.v;\n            while(out > 0){\n                auto& d = dq.front();\n                if(out < d.v){\n                    sum -= out * d.t;\n                    d.v -= out;\n                    out = 0;\n                }\n                else{\n                    sum -= d.v * d.t;\n                    out -= d.v;\n                    dq.pop_front();\n                }\n            }\n        }\n\n        sum += in.v * in.t;\n        while(!dq.empty() && in.t < dq.back().t){\n            in = in + dq.back();\n            dq.pop_back();\n        }\n        dq.push_back(in);\n\n        double ans = sum / l;\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t\t//printf(\"%d %.6lf %.0lf\\n\",l,sum,now);\n\t    ans[i]=sum/m;\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tdouble tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*q[r-1].b)/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.7lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, l, i;\n    double t = 0, v = 0;\n    deque <pair<double, double> > d;\n    \n    scanf(\"%d %d\", &n, &l);\n    \n    for (i = 0; i < n; i++) {\n        double tx, vx;\n        \n        scanf(\"%lf %lf\", &tx, &vx);\n        \n        if (l == vx) {\n            d.clear();\n            t = 0;\n            v = 0;\n        }\n        \n        while (v + vx > l && d.size() > 0) {\n            double t1 = d.front().first;\n            double v1 = d.front().second;\n            double v2 = min(v1, v + vx - l);\n            \n            t = (t * v - t1 * v2) / (v - v2);\n            v = v - v2;\n            \n            if (v1 == v2) {\n                d.pop_front();\n            } else {\n                d.front().second -= v2;\n                break;\n            }\n        }\n        \n        t = (t * v + tx * vx) / (v + vx);\n        v = v + vx;\n        \n        printf(\"%.12lf\\n\", t);\n        \n        while (d.size() > 0) {\n            double t1 = d.back().first;\n            double v1 = d.back().second;\n            \n            if (t1 < tx) break;\n            \n            tx = (tx * vx + t1 * v1) / (vx + v1);\n            vx = vx + v1;\n            \n            d.pop_back();\n        }\n        \n        d.push_back(make_pair(tx, vx));\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<double, double> P;\nint main() {\n\tint N, L;\n\tcin >> N >> L;\n\tdouble sumT = 0;\n\tdeque<P> Q;\n\tdouble t, v;\n\tcin >> t >> v;\n\tQ.emplace_back(t, v);\n\tsumT += t * v;\n\tprintf(\"%.15lf\\n\", t);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> t >> v;\n\t\tdouble del = v;\n\t\twhile (del > 0) {\n\t\t\tif (Q.front().second <= del) {\n\t\t\t\tdel -= Q.front().second;\n\t\t\t\tsumT -= Q.front().first*Q.front().second;\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tQ.front().second -= del;\n\t\t\t\tsumT -= Q.front().first*del;\n\t\t\t\tdel = 0;\n\t\t\t}\n\t\t}\n\t\tsumT += t * v;\n\t\tprintf(\"%.15lf\\n\", sumT / L);\n\t\tP now = P(t, v);\n\t\twhile (!Q.empty() && Q.back().first > now.first) {\n\t\t\tdouble sum_t = Q.back().first*Q.back().second + now.first*now.second;\n\t\t\tdouble sum_v = Q.back().second + now.second;\n\t\t\tnow = P(sum_t / sum_v, sum_v);\n\t\t\tQ.pop_back();\n\t\t}\n\t\tQ.push_back(now);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\ntypedef long long lint;\nconst int N=5e5+5;\nint n,q;\nstruct data{\n\tint w;\n\tdouble t;\n};\n\nnamespace utils{\n\tinline int nxi(FILE *fd=stdin){\n\t\tint x=0;\n\t\tchar c;\n\t\twhile(((c=fgetc(fd))>'9'||c<'0')&&c!='-');\n\t\tconst bool f=(c=='-')&&(c=fgetc(fd));\n\t\twhile(x=x*10-48+c,(c=fgetc(fd))>='0'&&c<='9');\n\t\treturn f?-x:x;\n\t}\n\n\ttemplate <class T>\n\t\tinline void apx(T &x,const T y){\n\t\t\tx<y?x=y:0;\n\t\t}\n\n\ttemplate <class T>\n\t\tinline void apn(T &x,const T y){\n\t\t\tx>y?x=y:0;\n\t\t}\n}\nusing namespace utils;\n\nint main(){\n\tstatic data dq[N];\n\tdouble sumt=0;\n\tint hd=0,tl=0,sumw=0;\n\tn=nxi(),q=nxi();\n\tfor(int i=1; i<=n; ++i){\n\t\tint t=nxi(),w=nxi();\n\t\tdq[tl++]=(data){w,(double)t};\n\t\tsumw+=w;\n\t\tsumt+=(lint)t*w;\n\t\tfor(; tl-1>hd&&dq[tl-1].t<dq[tl-2].t; --tl){\n\t\t\tint oflow=std::max(0,dq[tl-2].w+dq[tl-1].w-q);\n\t\t\tsumw-=oflow;\n\t\t\tsumt-=dq[tl-2].t*oflow;\n\t\t\tassert(oflow<=dq[tl-2].w);\n\t\t\tint w0=dq[tl-2].w-oflow,w1=dq[tl-1].w;\n\t\t\tdq[tl-2].t=(dq[tl-2].t*w0+dq[tl-1].t*w1)/(w0+w1);\n\t\t\tdq[tl-2].w+=dq[tl-1].w-oflow;\n\t\t}\n\t\tfor(; sumw>q&&hd<tl; ++hd){\n\t\t\tint wgt=std::min(sumw-q,dq[hd].w);\n\t\t\tdq[hd].w-=wgt;\n\t\t\tsumw-=wgt;\n\t\t\tsumt-=wgt*dq[hd].t;\n\t\t\tif(sumw==q) break;\n\t\t}\n\t\tassert(hd<tl);\n\t\tprintf(\"%.8lf\\n\",sumt/sumw);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1*d1.front().second;\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    totv-=d1.front().first;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=(long double)1*d1.back().first*d1.back().second;\n                double tempp = (long double)1*tempv*tempt;\n                tempp+=(long double)1*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1*tempp)/((long double)1*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        totprod+=(long double)1*tempt*tempv;\n       // cout<<totprod<<endl;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6\nvector<pair<DB, DB> > W;\nvector<DB> S;\nint w0; DB s0;\n// degree, V\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W[w0].se);\n        if (!sgn(ll- d)){\n            V = 0;\n        }\n        else {\n            \n            V = ((V*ll) - d*W[w0].fi) / (ll-d);\n        }\n        l -= d; W[w0].se -= d;\n        if (!sgn(W[w0].se)) w0++;\n        ll -= d;\n    }\n    s0 += l;\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n// 4 5\n// 2 3\n\n// 0 > 0\n\nvoid gao(){\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l)); w0 = 0;\n    \n    FOR(i, 1, n){\n        RD(v, l); pop(l); push(v, l);\n        \n        DB r = 0;\n        while (W.size() > w0 && W.rbegin()->fi > V){\n            r += W.rbegin()->se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n            W.push_back(MP(V, r));\n        }\n        OT(V);\n        \n        //int p = lower_bound(W.begin() + w0, W.end(), V) - W.begin();\n        //DB ss = p > w0 ? S[p-1]-s0 : 0;\n        \n    }\n}\nint main(){\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/Documents/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n    RD(n, L);\n    gao();\n    /*REP(i, n){\n        LL t, v; RD(v, t);\n        if (i){\n            DB tt = t, ll = L;\n            \n            while (sgn(tt)){\n                pair<DB, DB> z = Q.top(); Q.pop();\n                DB d = min(tt, z.se);\n                \n                cout << z.fi << \" \" << z.se << endl;\n                \n                // ((ll-d)*vv' + d*z.fi) / ll = vv\n                \n                vv = ((vv*ll) - d*-z.fi) / (ll-d);\n\n                \n                tt -= d, z.se -= d;\n                if (sgn(z.se)){\n                    Q.push(MP(z.fi, z.se));\n                }\n                ll -= d;\n            }\n            vv = ((L-t)*vv + t*v) / L;\n        }\n        else{\n            vv = v;\n        }\n        Q.push(MP(-v, t));\n        OT(vv);\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e6+10;\nint n,m;\ndouble sum,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\too now=(oo){a[i],b[i]};int w=r;\n\t\twhile(w>=l){\n\t\t\tif(now.b+q[w].b>=m){\n\t\t\t\tans[i]=(now.b*now.a+(m-now.b)*q[w].a)/m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow.a=(now.a*now.b+q[w].a*q[w].b)/(now.b+q[w].b);\n\t\t\tnow.b=now.b+q[w].b;\n\t\t\tw--;\n\t\t}\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tint tot=min((int)(q[r-1].b+q[r].b),m);\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nnamespace IO {\n    const int BUFFER_SIZE = 1 << 15;\n\n    char input_buffer[BUFFER_SIZE];\n    int input_pos = 0, input_len = 0;\n\n    char output_buffer[BUFFER_SIZE];\n    int output_pos = 0;\n\n    char number_buffer[100];\n    uint8_t lookup[100];\n\n    void _update_input_buffer() {\n        input_len = fread(input_buffer, sizeof(char), BUFFER_SIZE, stdin);\n        input_pos = 0;\n\n        if (input_len == 0)\n            input_buffer[0] = EOF;\n    }\n\n    inline char next_char(bool advance = true) {\n        if (input_pos >= input_len)\n            _update_input_buffer();\n\n        return input_buffer[advance ? input_pos++ : input_pos];\n    }\n\n    template<typename T>\n    inline void read_int(T &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (negative)\n            number = -number;\n    }\n\n    template<typename T, typename... Args>\n    inline void read_int(T &number, Args &... args) {\n        read_int(number);\n        read_int(args...);\n    }\n\n    inline void read_double(double &number) {\n        bool negative = false;\n        number = 0;\n\n        while (!isdigit(next_char(false)))\n            if (next_char() == '-')\n                negative = true;\n\n        do {\n            number = 10 * number + (next_char() - '0');\n        } while (isdigit(next_char(false)));\n\n        if (next_char(false) == '.') {\n            next_char();\n\n            for (double multiplier = 0.1; isdigit(next_char(false)); multiplier *= 0.1)\n                number += multiplier * (next_char() - '0');\n        }\n\n        if (negative)\n            number = -number;\n    }\n\n    void _flush_output() {\n        fwrite(output_buffer, sizeof(char), output_pos, stdout);\n        output_pos = 0;\n    }\n\n    inline void write_char(char c) {\n        if (output_pos == BUFFER_SIZE)\n            _flush_output();\n\n        output_buffer[output_pos++] = c;\n    }\n\n    template<typename T>\n    inline void write_int(T number, char after = '\\0') {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        int length = 0;\n\n        while (number >= 10) {\n            uint8_t lookup_value = lookup[number % 100];\n            number /= 100;\n            number_buffer[length++] = (lookup_value & 15) + '0';\n            number_buffer[length++] = (lookup_value >> 4) + '0';\n        }\n\n        if (number != 0 || length == 0)\n            write_char(number + '0');\n\n        for (int i = length - 1; i >= 0; i--)\n            write_char(number_buffer[i]);\n\n        if (after)\n            write_char(after);\n    }\n\n    inline void write_double(double number, char after = '\\0', int places = 6) {\n        if (number < 0) {\n            write_char('-');\n            number = -number;\n        }\n\n        assert(number <= 9e18);\n\n        // Round up the number according to places.\n        number += 0.5 * pow(0.1, places);\n        long long floored = (long long) number;\n        write_int(floored);\n\n        if (places > 0) {\n            write_char('.');\n            number = (number - floored) * pow(10.0, places);\n            floored = (long long) number;\n            int length = 0;\n\n            for (int i = 0; i < places / 2; i++) {\n                uint8_t lookup_value = lookup[floored % 100];\n                floored /= 100;\n                number_buffer[length++] = (lookup_value & 15) + '0';\n                number_buffer[length++] = (lookup_value >> 4) + '0';\n            }\n\n            if (places % 2)\n                number_buffer[length++] = floored + '0';\n\n            assert(length == places);\n\n            for (int i = places - 1; i >= 0; i--)\n                write_char(number_buffer[i]);\n        }\n\n        if (after)\n            write_char(after);\n    }\n\n    void init() {\n        // Make sure _flush_output() is called at the end of the program.\n        bool exit_success = atexit(_flush_output) == 0;\n        assert(exit_success);\n\n        for (int i = 0; i < 100; i++)\n            lookup[i] = (i / 10 << 4) + i % 10;\n    }\n}\n\nusing my_double = long double;\n\nstruct point {\n    my_double x, y;\n\n    point() : x(0), y(0) {}\n\n    point(my_double _x, my_double _y) : x(_x), y(_y) {}\n\n    point& operator+=(const point &other) { x += other.x; y += other.y; return *this; }\n    point& operator-=(const point &other) { x -= other.x; y -= other.y; return *this; }\n    point& operator*=(my_double mult) { x *= mult; y *= mult; return *this; }\n\n    point operator+(const point &other) const { return point(*this) += other; }\n    point operator-(const point &other) const { return point(*this) -= other; }\n    point operator*(my_double mult) const { return point(*this) *= mult; }\n\n    // Warning: does exact floating-point comparisons.\n    bool operator==(const point &other) const { return x == other.x && y == other.y; }\n    bool operator!=(const point &other) const { return !(*this == other); }\n\n    point operator-() const { return point(-x, -y); }\n    point rotate90() const { return point(-y, x); }\n\n    my_double norm() const {\n        return x * x + y * y;\n    }\n\n    my_double dist() const {\n        return sqrt(norm());\n    }\n\n    bool top_half() const {\n        return make_pair(y, x) > pair<my_double, my_double>(0, 0);\n    }\n\n    friend ostream& operator<<(ostream &stream, const point &p) {\n        return stream << '(' << p.x << \", \" << p.y << ')';\n    }\n};\n\nmy_double cross(const point &a, const point &b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nmy_double dot(const point &a, const point &b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nbool left_turn_strict(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) > 0;\n}\n\nbool left_turn_lenient(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) >= 0;\n}\n\n// Warning: does a floating-point comparison to exactly 0.\nbool collinear(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) == 0;\n}\n\n// Returns the signed, doubled area formed by three points in a triangle. Positive when a -> b -> c is a left turn.\nmy_double area_signed_doubled(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a);\n}\n\nmy_double distance_to_line(const point &p, const point &a, const point &b) {\n    assert(a != b);\n    return abs(area_signed_doubled(p, a, b)) / (a - b).dist();\n}\n\nmy_double manhattan_dist(const point &a, const point &b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nmy_double infinity_norm_dist(const point &a, const point &b) {\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\n// Sort in increasing order of y, with ties broken in increasing order of x.\nbool yx_compare(const point &a, const point &b) {\n    return (b - a).top_half();\n}\n\n// Sort in increasing order of angle to the x-axis.\nbool angle_compare(const point &a, const point &b) {\n    if (a.top_half() ^ b.top_half())\n        return a.top_half();\n\n    return cross(a, b) > 0;\n}\n\n\nint main() {\n    IO::init();\n\n    int N;\n    long long L;\n    IO::read_int(N, L);\n    deque<point> poly_line = {point(0, 0)};\n\n    for (int i = 0; i < N; i++) {\n        long long T, V;\n        IO::read_int(T, V);\n        poly_line.push_front(poly_line.front() + point(-V, -T * V));\n\n        while (poly_line[poly_line.size() - 2].x - poly_line.front().x >= L)\n            poly_line.pop_back();\n\n        // Truncate the last line so that the total width is exactly L.\n        point second_last = poly_line[poly_line.size() - 2];\n        point delta = poly_line.back() - second_last;\n        my_double portion = poly_line.front().x + L - second_last.x;\n        delta *= portion / delta.x;\n        poly_line.back() = second_last + delta;\n\n        while (poly_line.size() >= 3 && left_turn_lenient(poly_line[0], poly_line[1], poly_line[2])) {\n            poly_line[1] = poly_line[0];\n            poly_line.pop_front();\n        }\n\n        my_double answer = (poly_line.back().y - poly_line.front().y) / L;\n        IO::write_double(answer, '\\n');\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst int N=5e5+5;\nint n,l,r;\ndouble ans,ll,v,d[N][2];\nint read()\n{\n\tchar ch=getchar();\n\tint x=0;\n\twhile (ch<'0' || ch>'9') ch=getchar();\n\twhile (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n\treturn x;\n}\nvoid merge(int x)\n{\n\td[x][0]=(d[x][0]*d[x][1]+d[x+1][0]*d[x+1][1])/(d[x][1]+d[x+1][1]);\n\td[x][1]+=d[x+1][1];\n}\nint main()\n{\n\tn=read(),ll=read(),l=1;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\td[++r][0]=read(),d[r][1]=read();\n\t\tv+=d[r][1],ans+=d[r][0]*d[r][1];\n\t\twhile (v>ll)\n\t\t{\n\t\t\tif (v-d[l][1]>=ll)\n\t\t\t{\n\t\t\t\tv-=d[l][1];\n\t\t\t\tans-=d[l][0]*d[l][1];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\td[l][1]-=v-ll;\n\t\t\t\tans-=(v-ll)*d[l][0];\n\t\t\t\tv=ll;\n\t\t\t}\n\t\t}\n\t\twhile (r>l && d[r][0]<=d[r-1][0]) merge(--r);\n\t\tprintf(\"%lf\\n\",ans/ll);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio>\n#include <deque>\n#include <iomanip>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = a , _b = b ; i <= _b ; ++i)\n#define Ford(i , a  ,b) for (int i = a , _b = b : i >= _b ; --i)\n#define Rep(i , n) for (int i = 0 , _n = n ; i < _n ; ++i)\n#define sz(A) ((int)A.size())\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n\ntypedef pair<int , int> pt;\n\nint n;\nint L;\n\nvoid ReadData() {\n\tcin >> n >> L;\n} \n\ndeque<pair<long double, long long> > qu;\nvoid Process() {\n\tcout << fixed << setprecision(6);\n\n\tlong long sumRem = 0;\n\tlong double sumTV = 0;\n\tFor(i,1,n) {\n\t\tint t,v; cin >> t >> v;\n\t\tif (sz(qu) == 0) {\n\t\t\tqu.push_back(make_pair(t,v));\n\t\t\tsumRem += v;\n\t\t\tsumTV += 1LL * v * t;\n\t\t\tcout << t << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sumRem + v > L) {\n\t\t\tauto &cur = qu.front();\n\t\t\tif (cur.second <= (sumRem + v) - L) {\n\t\t\t\tsumRem -= cur.second;\n\t\t\t\tsumTV -= 1LL * cur.first * cur.second;\n\t\t\t\tqu.pop_front();\n\t\t\t} else {\n\t\t\t\tcur.second -= ((sumRem + v) - L);\n\t\t\t\tsumTV -=  cur.first *((sumRem + v) - L);\n\t\t\t\tsumRem -= ((sumRem + v) - L);\n\t\t\t}\n\t\t}\n\t\tlong double res = (sumTV + 1LL * v * t) / (sumRem + v);\n\t\tcout << (double) res << \"\\n\";\n\n\t\tpair<long double, long long> add = make_pair(t,v);\n\t\twhile (sz(qu) && qu.back().first >= add.first) {\n\t\t\tadd = make_pair( (qu.back().first * qu.back().second \n\t\t\t\t+ add.first * add.second) / (qu.back().second + add.second),\n\t\t\t\tqu.back().second + add.second  );\n\t\t\tsumRem -= qu.back().second;\n\t\t\tsumTV -= qu.back().first * qu.back().second;\n\t\t\tqu.pop_back();\n\t\t}\n\t\tqu.push_back(add);\n\t\tsumRem += add.second;\n\t\tsumTV += add.first * add.second;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\t//freopen(\"input.inp\" , \"r\" , stdin);\n\tReadData();\n\tProcess();\n\n\treturn 0;\n\n}\t\t\t"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <queue>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e6;\nint n, L;\nint64_t t[MAXN], v[MAXN];\n\nint main() {\n    scanf(\"%d%d\", &n, &L);\n    for (int i = 0; i < n; i++)\n        scanf(\"%lld%lld\", &t[i], &v[i]);\n\n    // maintain the cumulative best f(v) = tvsum (convex, piecewise-linear)\n    // m contains (slope, len) where slope is decreasing\n    deque <pair <double, int64_t>> m; // (slope, len)\n    // v[0] == L\n    m.push_back({t[0], v[0]});\n    double tvsum = 1.0 * t[0] * v[0];\n    printf(\"%.10lf\\n\", tvsum / L);\n    for (int i = 1; i < n; i++) {\n        // cut down from L to L - v[i]\n        int64_t del = v[i];\n        while (true) {\n            int64_t len = m.back().second;\n            if (len <= del) {\n                del -= len;\n                tvsum -= m.back().first * len;\n                m.pop_back();\n                if (del == 0)\n                    break;\n            }\n            else {\n                tvsum -= m.back().first * del;\n                m.back().second -= del;\n                break;\n            }\n        }\n\n        // add v[i] block\n        tvsum += 1.0 * t[i] * v[i];\n        m.push_front({t[i], v[i]});\n        printf(\"%.10lf\\n\", tvsum / L);\n\n        // convexify\n        while (m.size() > 1 && m[0].first < m[1].first) {\n            double tv = m[0].first * m[0].second + m[1].first * m[1].second;\n            int64_t len = m[0].second + m[1].second;\n            m.pop_front();\n            m.pop_front();\n            m.push_front({tv / len, len});\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6 ...\ndeque<pair<DB, DB>> W;\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        if (!sgn(ll-d)){\n            V = 0;\n        }\n        else {\n            V = ((V*ll) - d*W.front().fi) / (ll-d);\n        }\n        l -= d; W.front().se -= d; ll -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n        \n    }\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n\nint main(){\n    RD(n, L);\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        //cout << \" ? \" << endl;\n        \n        DB r = l;\n        while (!W.empty() && sgn(W.back().fi, V) >= 0){\n            r += W.back().se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n            //            cout << V << \" \" << r << endl;\n            W.push_back(MP(V, r));\n        }\n        // cout << W.size() << \" \";\n        \n        OT(V);\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <algorithm>\n#include <iostream>\n#include <queue>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nconstexpr static int MAXN = 1e6;\nint n, L;\nint64_t t[MAXN], v[MAXN];\npair <int64_t, int> ti[MAXN];\nint idx[MAXN];\n\nint main() {\n    scanf(\"%d%d\", &n, &L);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld%lld\", &t[i], &v[i]);\n        ti[i] = {-t[i], i};\n    }\n    sort(ti, ti + n);\n    for (int i = 0; i < n; i++)\n        idx[ti[i].second] = i;\n\n    // maintain the cumulative best f(v) = tvsum (convex, piecewise-linear)\n    // m contains (slope, len) where slope is decreasing\n    deque <pair <double, int64_t>> m; // (slope, len)\n    // v[0] == L\n    m.push_back({t[0], v[0]});\n    double tvsum = 1.0 * t[0] * v[0];\n    printf(\"%.10lf\\n\", tvsum / L);\n    for (int i = 1; i < n; i++) {\n        // cut down from L to L - v[i]\n        int64_t del = v[i];\n        while (true) {\n            int64_t len = m.back().second;\n            if (len <= del) {\n                del -= len;\n                tvsum -= m.back().first * len;\n                m.pop_back();\n                if (del == 0)\n                    break;\n            }\n            else {\n                tvsum -= m.back().first * del;\n                m.back().second -= del;\n                break;\n            }\n        }\n\n        // add v[i] block\n        tvsum += 1.0 * t[i] * v[i];\n        m.push_front({t[i], v[i]});\n        printf(\"%.10lf\\n\", tvsum / L);\n\n        // convexify\n        while (m.size() > 1 && m[0].first < m[1].first) {\n            double tv = m[0].first * m[0].second + m[1].first * m[1].second;\n            int64_t len = m[0].second + m[1].second;\n            m.pop_front();\n            m.pop_front();\n            m.push_front({tv / len, len});\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 500100;\n\nint N;\nll L;\nll t[MAXN], v[MAXN];\n\nvector <pair <ld, ld> > hull;\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n\n    cin >> N >> L;\n    for (int i = 0; i < N; i++)\n        cin >> t[i] >> v[i];\n    cout << fixed << setprecision(9);\n\n    hull.push_back (make_pair (0, 0));\n    int chull = 0;\n    for (int i = 0; i < N; i++)\n    {\n        ld vtot = v[i] + hull.back().first;\n        ld ttot = t[i] * v[i] + hull.back().second;\n        hull.push_back (make_pair (vtot, ttot));\n\n        while (chull + 1 < hull.size() && hull[chull+1].first + L <= vtot)\n            chull++;\n        ld vlo = hull[chull].first - (vtot - L), vhi = hull[chull+1].first - (vtot - L);\n        ld ttemp = (vhi * hull[chull].second - vlo * hull[chull+1].second) / (vhi - vlo);\n        hull[chull] = make_pair (vtot - L, ttemp);\n        cout << (ttot - ttemp) / L << \"\\n\";\n\n        hull.pop_back();\n        while (hull.size() > chull + 1)\n        {\n            ld v1 = hull[hull.size()-2].first, t1 = hull[hull.size()-2].second;\n            ld v2 = hull[hull.size()-1].first, t2 = hull[hull.size()-1].second;\n            if (t1 * (vtot - v2) + ttot * (v2 - v1) < (vtot - v1) * t2)\n                hull.pop_back();\n            else\n                break;\n        }\n        hull.push_back (make_pair (vtot, ttot));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\n\n\n\nint N,L;\nint T[505050];\nll V[505050];\nll TV,TT;\nvector<int> TC;\nmap<ll,ll> M;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>L;\n\t\n\tTC.push_back(-1);\n\tFOR(i,N) {\n\t\tcin>>T[i]>>V[i];\n\t}\n\t\n\tFOR(i,N) {\n\t\twhile(TV>L-V[i]) {\n\t\t\tauto r=*M.begin();\n\t\t\tll del=min(TV-(L-V[i]),r.second);\n\t\t\t\n\t\t\tTV-=del;\n\t\t\tTT-=del*r.first;\n\t\t\tM[r.first]-=del;\n\t\t\tif(M[r.first]==0) M.erase(r.first);\n\t\t}\n\t\t\n\t\tTV+=V[i];\n\t\tTT+=T[i]*V[i];\n\t\tM[T[i]]+=V[i];\n\t\t\n\t\t_P(\"%.12lf\\n\",1.0*TT/TV);\n\t\t\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(double& x){ scanf(\"%lf\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\ndouble vol[500010];\ndouble tmp[500010];\n\nint n; double l;\n\ndouble h;\n\nint main()\n{\n\tint head=0, tail=0;\n\tread(n, l);\n\tfor(;n--;){\n\t\tdouble t, v;\n\t\tread(t, v);\n\t\tdouble left_v = v;\n\t\twhile(head<tail && left_v > 0){\n\t\t\tdouble toru = min(vol[head], left_v);\n\t\t\th -= toru * tmp[head];\n\t\t\tvol[head] -= toru;\n\t\t\tleft_v -= toru;\n\t\t\tif(vol[head] == 0){\n\t\t\t\t++head;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", (h + t*v) / l);\n\t\tvol[tail] = v;\n\t\ttmp[tail] = t;\n\t\th += v*t;\n\t\t++tail;\n\t\twhile(tail-head >= 2){\n\t\t\tif(tmp[tail-2] < tmp[tail-1]) break;\n\t\t\tdouble new_temp = tmp[tail-1]*vol[tail-1] + tmp[tail-2]*vol[tail-2];\n\t\t\tvol[tail-2] += vol[tail-1];\n\t\t\ttmp[tail-2] = new_temp/vol[tail-2];\n\t\t\t--tail;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\too now=(oo){a[i],b[i]};int w=r;\n\t\twhile(w>=l){\n\t\t\tif(now.b+q[w].b>=m){\n\t\t\t\tans[i]=(now.b*now.a+(m-now.b)*q[w].a)/m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow.a=(now.a*now.b+q[w].a*q[w].b)/(now.b+q[w].b);\n\t\t\tnow.b=now.b+q[w].b;\n\t\t\tw--;\n\t\t}\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tint tot=min((int)(q[r-1].b+q[r].b),m);\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 500010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,L,bot,top;\n\ndouble tot;\n\ndouble temperature[maxn],volume[maxn];\n\nvoid Work(){\n\tREP(i,2,n){\n\t\tdouble x,y,z;\n\t\tscanf(\"%lf%lf\",&x,&y);z=y;\n\t\twhile(volume[top]<=z){\n\t\t\ttot-=temperature[top]*volume[top];\n\t\t\tz-=volume[top];\n\t\t\ttop++;\n\t\t}\n\t\ttot-=z*temperature[top];volume[top]-=z;\n\t\ttot+=x*y;\n\t\twhile(top<=bot&&temperature[bot]>x){\n\t\t\tx=(x*y+temperature[bot]*volume[bot])/(y+=volume[bot]);\n\t\t\tbot--;\n\t\t}\n\t\tbot++;\n\t\ttemperature[bot]=x;volume[bot]=y;\n\t\tprintf(\"%.10lf\\n\",(double)tot/L);\n\t}\n}\n\nvoid Init(){\n\tread(n,L);\n\tscanf(\"%lf%lf\",&temperature[1],&volume[1]);\n\ttop=bot=1;\n\ttot=temperature[1]*volume[1];\n\tprintf(\"%.10lf\\n\",volume[1]);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.01.2020 03:51:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(17);\n  int n, l;\n  cin >> n >> l;\n  vector<pair<double, double>> a;\n  double res = 0;\n  int i = 0;\n  for (int it = 0; it < n; it++) {\n    double t, v;\n    cin >> t >> v;\n    double rm = (it == 0 ? 0 : v);\n    while (i < (int) a.size()) {\n      if (rm > a[i].second) {\n        rm -= a[i].second;\n        res -= a[i].first * a[i].second;\n        ++i;\n      } else {\n        a[i].second -= rm;\n        res -= a[i].first * rm;\n        break;\n      }\n    }\n    res += t * v;\n    while (i < (int) a.size() && a.back().first > t) {\n      t = (t * v + a.back().first * a.back().second) / (v + a.back().second);\n      v += a.back().second;\n      a.pop_back();\n    }\n    a.emplace_back(t, v);\n    cout << res / l << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define forE(i,x) for(int i=head[x];i!=-1;i=ne[i])\nusing namespace std;\ntypedef long long i64;\ntypedef unsigned long long u64;\ntypedef unsigned u32;\ntypedef pair<int,int> pin;\n#define mk(a,b) make_pair(a,b)\n#define lowbit(x) ((x)&(-(x)))\n#define sqr(a) ((a)*(a))\n#define clr(a) (memset((a),0,sizeof(a)))\n#define ls ((x)<<1)\n#define rs (((x)<<1)|1)\n#define mid (((l)+(r))>>1)\n#define pb push_back\n#define w1 first\n#define w2 second\ninline void read(int &x){\n\tx=0;int f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\tx*=f;\n}\ninline void judge(){\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n}\n/*******************************head*******************************/\ntypedef double ld;\nconst int maxn=500005;\nstruct Point{\n\tld x,y;\n\tinline Point(){}\n\tinline Point(ld _x,ld _y){\n\t\tx=_x;y=_y;\n\t}\n}dir,Queue[maxn<<2];\nld t[maxn],v[maxn];\ninline Point operator + (const Point &a,const Point &b){\n\treturn Point(a.x+b.x,a.y+b.y);\n}\ninline Point operator - (const Point &a,const Point &b){\n\treturn Point(a.x-b.x,a.y-b.y);\n}\ninline ld operator * (const Point &a,const Point &b){\n\treturn a.x*b.y-a.y*b.x;\n}\ninline bool check(Point x,Point y,Point z){\n\treturn (y-x)*(z-y)<0;\n}\ninline ld lv(Point x,Point y){\n\treturn (x.y-y.y)/(x.x-y.x);\n}\nconst ld eps=1e-8;\nint front,finish,n,L;\nint main(){\n\tread(n);read(L);\n\trep(i,1,n)scanf(\"%lf%lf\",&t[i],&v[i]);\n\tQueue[front=finish=n]=Point(0,0);\n\tQueue[++finish]=Point(v[1],v[1]*t[1]);\n\trep(i,1,n){\n\t\tdir=dir+Point(v[i],v[i]*t[i]);\n\t\twhile(L+eps<Queue[finish].x+dir.x)finish--;\n\t\tdouble k=lv(Queue[finish],Queue[finish+1]),y=Queue[finish].y+k*(L-Queue[finish].x-dir.x);\n\t\tQueue[++finish]=Point(L-dir.x,y);\n\t\tprintf(\"%.7lf\\n\",(Queue[finish].y+dir.y)/L);\n\t\tPoint now(-dir.x,-dir.y);\n\t\twhile(front<finish&&!check(now,Queue[front],Queue[front+1]))\n\t\t\tfront++;\n\t\tQueue[--front]=now;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define gc getchar\ninline int read(){\n\tchar ch=gc();\n\tint res=0,f=1;\n\twhile(!isdigit(ch))f^=ch=='-',ch=gc();\n\twhile(isdigit(ch))res=(res+(res<<2)<<1)+(ch^48),ch=gc();\n\treturn f?res:-res;\n}\n#define re register\n#define pb push_back\n#define cs const\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define ll long long\ncs int mod=1e9+7;\ninline int add(int a,int b){return (a+=b)>=mod?a-mod:a;}\ninline void Add(int &a,int b){(a+=b)>=mod?(a-=mod):0;}\ninline int dec(int a,int b){return (a-=b)<0?a+mod:a;}\ninline void Dec(int &a,int b){(a-=b)<0?(a+=mod):0;}\ninline int mul(int a,int b){return 1ll*a*b>=mod?1ll*a*b%mod:a*b;}\ninline void Mul(int &a,int b){a=mul(a,b);}\ninline int ksm(int a,int b,int res=1){\n\tfor(;b;b>>=1,a=mul(a,a))(b&1)&&(res=mul(res,a));return res;\n}\ninline void chemx(ll &a,ll b){a<b?a=b:0;}\ninline void chemn(int &a,int b){a>b?a=b:0;}\nint n,L,l,r;\nlong double tmp,siz;\ncs int N=500005;\nstruct node{\n\tlong double v,t;\n}q[N];\nint main(){\n\tn=read(),L=read();\n\tl=1;\n\tfor(int i=1;i<=n;i++){\n\t\tnode now;\n\t\tnow.t=read(),now.v=read();\n\t\twhile(l<=r&&siz+now.v>L){\n\t\t\tlong double del=min(q[l].v,siz+now.v-L);\n\t\t\tq[l].v-=del,siz-=del,tmp-=del*q[l].t;\n\t\t\tif(!q[l].v)l++;\n\t\t}\n\t\tsiz+=now.v,tmp+=now.v*now.t;\n\t\tprintf(\"%.7Lf\\n\",(1.0*tmp/L));\n\t\twhile(l<=r&&q[r].t>=now.t){\n\t\t\tnow.t=(now.v*now.t+q[r].t*q[r].v)/(q[r].v+now.v);\n\t\t\tnow.v+=q[r].v,r--;\n\t\t}\n\t\tq[++r]=now;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass Data\n{\npublic:\n    double t;\n    long long v;\n    Data(){\n        t = 0.0;\n        v = 0;\n    }\n    Data(double t, long long v){\n        this->t = t;\n        this->v = v;\n    }\n    Data operator+(const Data& d){\n        double t2 = (t * v + d.t * d.v) / (v + d.v);\n        long long v2 = v + d.v;\n        return Data(t2, v2);\n    }\n};\n\nint main()\n{\n    int n, l;\n    cin >> n >> l;\n\n    deque<Data> dq;\n    double sum = 0.0;\n    while(--n >= 0){\n        Data in;\n        cin >> in.t >> in.v;\n\n        if(!dq.empty()){\n            long long out = in.v;\n            while(out > 0){\n                auto& d = dq.front();\n                if(out < d.v){\n                    sum -= out * d.t;\n                    d.v -= out;\n                    out = 0;\n                }\n                else{\n                    sum -= d.v * d.t;\n                    out -= d.v;\n                    dq.pop_front();\n                }\n            }\n        }\n\n        sum += in.v * in.t;\n        while(!dq.empty() && in.t < dq.back().t){\n            in = in + dq.back();\n            dq.pop_back();\n        }\n        dq.push_back(in);\n\n        double ans = sum / l;\n        printf(\"%.10f\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b ; ++ i) \nconst int N = 5e5 + 5 ;\nconst double eps = 1e-9 ;\nusing namespace std ;\n\nint n, L ;\nstruct poi {\n\tdouble x, y ;\n} st[N], delta ;\n\ndouble cross(poi p0, poi p1, poi p2) {\n\treturn (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &L) ;\n\tint he = 1, ta = 1 ; poi u = {0, 0} ; st[1] = u ;\n\trep(i, 1, n) {\n\t\tscanf(\"%lf%lf\", &u.y, &u.x), u.y *= u.x ;\n\t\tdelta.x += u.x, delta.y += u.y ;\n\t\tu.x = - delta.x, u.y = - delta.y ;\n\t\tfor ( ; he < ta && st[he + 1].x + delta.x + eps > L ; ++ he) ;\n\t\tif (he == ta) st[he + 1] = u ; \n\t\tst[he].y = st[he + 1].y + (st[he].y - st[he + 1].y) * (1.0 * L - st[he + 1].x - delta.x) / (st[he].x - st[he + 1].x) ;\n\t\tst[he].x = L - delta.x ;\n\t\tfor ( ; ta > he && cross(u, st[ta], st[ta - 1]) > - eps ; -- ta) ;\n\t\tst[++ ta] = u ;\n\t\tprintf(\"%.7lf\\n\", (st[he + 1].y + delta.y + (1.0 * L - st[he + 1].x - delta.x) / (st[he].x - st[he + 1].x) * (st[he].y - st[he + 1].y)) / L) ;\n\t}\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\n#define fuckhwc 1ll*v[i-1]*t[i-1]+1ll*dfs(i-1,l-v[i]-v[i-1])*(l-v[i]-v[i-1])\nint t[N],v[N];\ndouble ans[N];\ndouble dfs(int x,int y)//返回对于第x天需求前一天剩余y升水的最高水温\n{\n\tif(ans[x-1]>=t[x-1])\n\t\treturn ans[x-1];\n\telse if(t[x-1]>ans[x-1]&&v[x-1]>=y)\n\t\treturn t[x-1];\n\telse return (1ll*t[x-1]*v[x-1]+1ll*dfs(x-1,y-v[x-1])*(y-v[x-1]))/y;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",t+i,v+i);\n\tans[1]=t[1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(ans[i-1]>=t[i-1])\n\t\t\tans[i]=(1ll*ans[i-1]*(l-v[i])+1ll*t[i]*v[i])/l;\n\t\telse if(t[i-1]>ans[i-1]&&v[i-1]>=l-v[i])\n\t\t\tans[i]=(1ll*t[i-1]*(l-v[i])+1ll*t[i]*v[i])/l;\n\t\telse ans[i]=(1ll*fuckhwc+1ll*t[i]*v[i])/l;\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%.7lf\\n\",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 5e5 + 5;\n\nint N, L;\ndouble t[MAXN], v[MAXN];\n\nvoid input()\n{\n    scanf(\"%d%d\", &N, &L);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%lf%lf\", &t[i], &v[i]);\n        t[i] *= v[i];\n    }\n}\n\nvoid solve()\n{\n    static int q[MAXN];\n    int front = 0, rear = 0;\n    double sumt = 0, sumv = 0;\n\n    for (int i = 1; i <= N; ++i) {\n        double left = L - v[i];\n        for (; front < rear && sumv > left; ++front) {\n            int j = q[front];\n            sumt -= t[j];\n            sumv -= v[j];\n            if (sumv <= left) {\n                double c = (left - sumv) / v[j];\n                sumt += (t[j] *= c);\n                sumv += (v[j] *= c);\n                break;\n            }\n        }\n        printf(\"%.10f\\n\", (sumt + t[i]) / L);\n\n        double t0 = t[i], v0 = v[i];\n        for (; front < rear && t[q[rear - 1]] / v[q[rear - 1]] >= t0 / v0; --rear) {\n            t0 += t[q[rear - 1]];\n            v0 += v[q[rear - 1]];\n        }\n        q[rear++] = i;\n        sumt += t[i]; t[i] = t0;\n        sumv += v[i]; v[i] = v0;\n    }\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"F.in\", \"r\", stdin);\n    freopen(\"F.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 不入虎穴，焉得虎子?\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio>\n#include <deque>\n#include <iomanip>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = a , _b = b ; i <= _b ; ++i)\n#define Ford(i , a  ,b) for (int i = a , _b = b : i >= _b ; --i)\n#define Rep(i , n) for (int i = 0 , _n = n ; i < _n ; ++i)\n#define sz(A) ((int)A.size())\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n\ntypedef pair<int , int> pt;\n\nint n;\nint L;\n\nvoid ReadData() {\n\tcin >> n >> L;\n} \n\ndeque<pair<long double, long long> > qu;\nvoid Process() {\n\tcout << fixed << setprecision(6);\n\n\tlong long sumRem = 0;\n\tlong double sumTV = 0;\n\tFor(i,1,n) {\n\t\tint t,v; cin >> t >> v;\n\t\tif (sz(qu) == 0) {\n\t\t\tqu.push_back(make_pair(t,v));\n\t\t\tsumRem += v;\n\t\t\tsumTV += 1LL * v * t;\n\t\t\tcout << t << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sumRem + v > L) {\n\t\t\tauto &cur = qu.front();\n\t\t\tif (cur.second <= (sumRem + v) - L) {\n\t\t\t\tsumRem -= cur.second;\n\t\t\t\tsumTV -= 1LL * cur.first * cur.second;\n\t\t\t\tqu.pop_back();\n\t\t\t} else {\n\t\t\t\tcur.second -= ((sumRem + v) - L);\n\t\t\t\tsumTV -=  cur.first *((sumRem + v) - L);\n\t\t\t\tsumRem -= ((sumRem + v) - L);\n\t\t\t}\n\t\t}\n\t\tlong double res = (sumTV + 1LL * v * t) / (sumRem + v);\n\t\tcout << (double) res << \"\\n\";\n\n\t\tpair<long double, long long> add = make_pair(t,v);\n\t\twhile (sz(qu) && qu.back().first >= add.first) {\n\t\t\tadd = make_pair( (qu.back().first * qu.back().second \n\t\t\t\t+ add.first * add.second) / (qu.back().second + add.second),\n\t\t\t\tqu.back().second + add.second  );\n\t\t\tsumRem -= qu.back().second;\n\t\t\tsumTV -= qu.back().first * qu.back().second;\n\t\t\tqu.pop_back();\n\t\t}\n\t\tqu.push_back(add);\n\t\tsumRem += add.second;\n\t\tsumTV += add.first * add.second;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\t//freopen(\"input.inp\" , \"r\" , stdin);\n\tReadData();\n\tProcess();\n\n\treturn 0;\n\n}\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvoid read(ll &rem){\n\trem = 0; char c = getchar();\n\twhile(c<'0'||c>'9') c = getchar();\n\twhile(c>='0'&&c<='9') rem = rem*10+c-48, c = getchar();\n}\n\ndouble tem[500050];\nll v[500050], cnt, head = 1;\n\nint main(){\n\tll T, L, nt, nv, ans = 0;\n\tbool flag = 0;\n\tread(T), read(L);\n\twhile(T--){\n\t\tscanf(\"%lld %lld\", &nt, &nv);\n\t\ttem[++cnt] = nt;\n\t\tv[cnt] = nv;\n\t\tans += nt * nv;\n\t\tll p = 0;\n\t\tif(flag){\n\t\t\twhile(p+v[head]<=nv) {\n\t\t\t\tp+=v[head], ans -= tem[head] * v[head], head++;\n\t\t\t}\n\t\t\tif(p<nv){\n\t\t\t\tv[head] -= nv-p;\n\t\t\t\tans -= (nv-p) * tem[head];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", 1.0 * ans / L);\n\t\twhile(tem[cnt] <= tem[cnt-1] && cnt-1 >= head){\n\t\t\ttem[cnt-1] = 1.0 * (v[cnt] * tem[cnt] + v[cnt-1] * tem[cnt-1]) / (v[cnt] + v[cnt-1]);\n\t\t\tv[cnt-1] += v[cnt];\n\t\t\tcnt--;\n\t\t}\n\t\tflag = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point\n{\n\tdouble x,y;\n\tfriend point operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\n\tfriend point operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\n\tfriend double operator *(point a,point b){return a.x*b.y-a.y*b.x;}\n}a[500010];\npoint gp(point p,point q,double x)\n{\n\treturn (point){x,(p.y*(q.x-x)+q.y*(x-p.x))/(q.x-p.x)};\n}\nint main()\n{\n\tint n,l,head=1,tail=1;a[1]=(point){0.0,0.0};\n\tscanf(\"%d%d\",&n,&l);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tpoint p;scanf(\"%lf%lf\",&p.y,&p.x);p.y*=p.x;\n\t\thead++;a[head]=a[head-1]-p;\n\t\twhile ((head!=tail)&&(a[tail+1].x-a[head].x>l)) tail++;\n\t\tif (a[tail].x-a[head].x>l)\n\t\t{\n\t\t\ta[tail]=gp(a[tail],a[tail+1],a[head].x+l);\n\t\t\twhile ((tail+1<head)&&((a[tail]-a[tail+2])*(a[tail+1]-a[tail+2])<0)) {a[tail+1]=a[tail];tail++;}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",(a[tail].y-a[head].y)/l);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * (ld)tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\t\tsum += t * (ld)v;\n\n\t\twhile (!dq.empty()) {\n\t\t\tif (dq.back().first < t) break;\n\t\t\tt = (dq.back().first * (ld)dq.back().second + t * (ld)v) / (ld)(dq.back().second + v);\n\t\t\tv += dq.back().second;\n\t\t\tdq.pop_back();\n\t\t}\n\t\tdq.push_back(P(t, v));\n\n\t\tcout << fixed << setprecision(12) << sum / (ld)L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n  using D = double;\n  D l;\n  cin>>l;\n  vector<D> ts(n),vs(n);\n  for(int i=0;i<n;i++) cin>>ts[i]>>vs[i];\n\n  // x, y\n  using P = pair<D, D>;\n  deque<P> ps;\n\n  D sx=0,sy=0;\n  auto get=\n    [&](int i){\n      return P(ps[i].first+sx,ps[i].second+sy);\n    };\n  auto put_front=\n    [&](P v){\n      ps.emplace_front(v.first-sx,v.second-sy);\n    };\n  auto put_back=\n    [&](P v){\n      ps.emplace_back(v.first-sx,v.second-sy);\n    };\n  put_front(P(0,0));\n  put_back(P(l,ts[0]*l));\n\n  for(int i=0;i<n;i++){\n    while(!ps.empty()){\n      D ax=get(ps.size()-1).first;\n      D ay=get(ps.size()-1).second;\n      assert(ax+vs[i]>=l);\n      if(ax+vs[i]==l) break;\n      if(ax+vs[i]>l){\n        ps.pop_back();\n        D bx=get(ps.size()-1).first;\n        D by=get(ps.size()-1).second;\n        if(bx+vs[i]>=l) continue;\n        D p=l-(bx+vs[i]);\n        D q=(ax+vs[i])-l;\n        D cx=l-vs[i];\n        D cy=by+(ay-by)*p/(p+q);\n        put_back(P(cx,cy));\n      }\n    }\n    sx+=vs[i];\n    sy+=ts[i]*vs[i];\n    cout<<get(ps.size()-1).second/l<<\"\\n\";\n    while(ps.size()>1){\n      P a=get(0),b=get(1);\n      if(a.first*b.second-a.second*b.first>=0)\n        ps.pop_front();\n      else\n        break;\n    }\n    put_front(P(0,0));\n  }\n  cout<<flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 500500;\nconst int mod = 1e9 + 7;\n\nusing namespace std;\n\nint orien(long long x1, long double y1, long long x2, long double y2, long long x3, long double y3) {\n\tlong double O = (long double) (x2 - x1) * (y3 - y1) - (long double) (y2 - y1) * (x3 - x1);\n\n        if(O < 0) return 1; // clock\n        else if(O > 0) return -1; // anti\n        return 0;\n}\n\nint n, L;\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> n >> L;\n        deque < pair < long long, long double > > d;\n        long long sum = 0;\n        long double res = 0;\n        for(int i = 1; i <= n; i++){\n                long long x, xx;\n                cin >> x >> xx;\n                swap(x, xx);\n                long double y = x * xx;\n\n                L -= x;\n                while(sum > L){\n                        auto p = d.back();\n                        d.pop_back();\n                        long long G = p.fi - min(sum - L, p.fi);\n                        long double k = (long double) G / p.fi;\n                        sum += G - p.fi;\n                        p.fi = G;\n\n                        res += k * p.se - p.se;\n                        p.se *= k;\n                        if(p.fi > 0){\n                                d.push_back(p);\n                        }\n                }\n                sum += x;\n                res += y;\n                L += x;\n                while(d.size() > 0 && orien(0, 0, x, y, x + d[0].fi, y + d[0].se) != 1){\n                        x += d[0].fi;\n                        y += d[0].se;\n                        d.pop_front();\n                }\n                d.push_front({x, y});\n                cout << fixed << setprecision(9) << res / L << \"\\n\";\n        }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nint main() {\n  ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n  int N; ll L; cin >> N >> L;\n  deque<pair<int, double>> mp;\n  mp.push_back(pair<int, double>(L, 0));\n  double sum = 0;\n  \n  for (int i = 0; i < N; i++) {\n    double t; int v; cin >> t >> v;\n    int drain = v;\n    while (drain > 0) {\n      int amt = min(mp.back().first, drain);\n      sum -= amt * mp.back().second;\n      drain -= amt;\n      mp.back().first -= amt;\n      if (mp.back().first == 0) mp.pop_back();\n    }\n    sum += t * v;\n    while (!mp.empty() && mp.front().second >= t) {\n      t = t * v + mp.front().first * mp.front().second;\n      v += mp.front().first;\n      t /= v;\n      mp.pop_front();\n    }\n    mp.push_front(pair<int, double>(v, t));\n    cout << fixed << setprecision(10) << (sum/L) << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=i;j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define ld long double\n#define PI pair<ld,ll>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=500005;\nint n,L,top;\nPI q[N];\nll sum[N];\nld ans[N];\nPI operator +(PI a,PI b){\n\treturn mp((a.first*a.second+b.first*b.second)/(a.second+b.second),a.second+b.second);\n}\nsigned main(){\n\tn=read(); L=read();\n\tfor(int i=1;i<=n;i++){\n\t\tint t=read(),v=read();\n\t\tPI dq=mp(t,v);\n\t\twhile(top&&q[top]>dq){if(q[top].second+dq.second>L)q[top].second=L-dq.second; dq=dq+q[top--]; }\n\t\tq[++top]=dq;\n\t\tsum[top]=sum[top-1]+dq.second;\n\t\tans[top]=ans[top-1]+dq.first*dq.second;\n\t\tint pos=lower_bound(&sum[1],&sum[top+1],sum[top]-L)-sum;\n\t\tprintf(\"%.7lf\\n\",(double)((ans[top]-ans[pos]+q[pos].first*(L-(sum[top]-sum[pos])))/L));\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\ntypedef long double db;\nconst db eps = 1e-8;\nint N,L;\n\nint T[500005],V[500005];\nint vv[500005];db tt[500005];\nint ql,qr;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline int R()\n{\n\tchar t=GC;\n\tint x=0;\n\twhile(!isdigit(t)) t=GC;\n\twhile(isdigit(t)) x=x*10+t-48,t=GC;\n\treturn x;\n}\nmain() {\n\tN = R(); L = R();\n\tfor(int i=1;i<=N;i++) {\n\t\tT[i] = R(); V[i] = R();\n\t}\n\tprintf(\"%lld\\n\",T[1]);\n\tql = qr = 1;\n\tvv[1] = V[1];\n\ttt[1] = T[1];\n\tdb ANS = 1.0l * V[1] * T[1];\n\tfor(int i=2;i<=N;i++) {\n\t\tint VO = L + V[i];\n\t\twhile(VO>L) {\n\t\t\tint yo = min(vv[ql],VO-L);\n\t\t\tANS -= tt[ql] * yo;\n\t\t\tvv[ql] -= yo;\n\t\t\tVO -= yo;\n\t\t\tif(vv[ql]==0) ql++;\n\t\t}\n\t\tANS += 1.0l * V[i] * T[i];\n\t\tprintf(\"%.8Lf\\n\",1.0l*ANS/(db)L);\n\t\tif(T[i]-tt[qr]<eps) {\n\t\t\tdb to = T[i]; db vo = V[i];\n\t\t\twhile(ql<=qr&&to-tt[qr]<eps) {\n\t\t\t\tto = (1.0l*to*vo+tt[qr]*vv[qr])/(vv[qr]+vo);\n\t\t\t\tvo += vv[qr];\n\t\t\t\tqr--;\n\t\t\t}\n\t\t\t++qr;\n\t\t\tvv[qr] = vo;\n\t\t\ttt[qr] = to;\n\t\t} else {\n\t\t\t++qr;\n\t\t\tvv[qr] = V[i];\n\t\t\ttt[qr] = T[i];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 5e5 + 10;\nll t[maxN], v[maxN];\nll L;\nbool is_bad(pair < ld, ll >& f1, pair < ld, ll >& f2, pair < ld, ll >& f3) {\n    return (f2.first - f1.first) * (f3.second - f2.second) <= (f3.first - f2.first) * (f2.second - f1.second);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> L;\n    for (int i = 1; i <= n; i++) {\n        cin >> t[i] >> v[i];\n    }\n    deque < pair < ld, ll > > all;\n    all.emplace_back(t[1] * L, L);\n    cout.precision(8);\n    cout << fixed << t[1] << '\\n';\n    ll addY = 0;\n    ll addX = 0;\n    all.emplace_front(0, 0);\n    for (int i = 2; i <= n; i++) {\n        addX += v[i];\n        addY += v[i] * t[i];\n        all.emplace_front(-addY, -addX);\n//        cout << \"STEP-1 \" << endl;\n//        for (auto it : all) {\n//            cout << (it.first + addY) / (it.second + addX) << \" \" << it.second + addX << endl;\n//        }\n//        cout << \"----------------\" << endl;\n        while (all.size() >= 3 && is_bad(all[0], all[1], all[2])) {\n            all[1] = all[0];\n            all.pop_front();\n        }\n        while (all.size() >= 2 && all[all.size() - 2].second + addX >= L) all.pop_back();\n        assert(all[all.size() - 1].second + addX >= L);\n        assert(all[all.size() - 2].second + addX < L);\n        ld val = addY + (all[all.size() - 2].first * (all[all.size() - 1].second + addX - L) + all[all.size() - 1].first * (L - all[all.size() - 2].second - addX)) /\n                            (all[all.size() - 1].second - all[all.size() - 2].second);\n        all[all.size() - 1].first = val - addY;\n        all[all.size() - 1].second = L - addX;\n//        cout << \"STEP0 \" << endl;\n//        for (auto it : all) {\n//            cout << (it.first + addY) / (it.second + addX) << \" \" << it.second + addX << endl;\n//        }\n//        cout << \"----------------\" << endl;\n        for (int j = 0; j + 2 < all.size(); j++) {\n            assert(all[j].second < all[j + 1].second);\n            assert(!is_bad(all[j], all[j + 1], all[j + 2]));\n        }\n        cout << fixed << (all.back().first + addY) / L << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=500000;\ntypedef struct R { double t; int vol; } R;\nR merge(const R &a,const R &b) { R ret; ret.t=(a.t*a.vol+b.t*b.vol)/(a.vol+b.vol); ret.vol=a.vol+b.vol; return ret; }\n\nint n,need;\nR q[MAXN]; int qhead,qtail;\n\nvoid run() {\n\tscanf(\"%d%d\",&n,&need);\n\tdouble tavg; qhead=qtail=0;\n\tREP(i,n) {\n\t\tR have; scanf(\"%lf%d\",&have.t,&have.vol);\n\t\t//FOR(j,qtail,qhead) { printf(\"\\t%d*%.9lf\\n\",q[j].vol,q[j].t); if(j>10) exit(0); }\n\t\tif(i==0) {\n\t\t\ttavg=have.t; q[qhead++]=have;\n\t\t} else {\n\t\t\ttavg=(tavg*need+have.t*have.vol)/(have.vol+need);\n\t\t\tint rem=have.vol;\n\t\t\twhile(rem>0) {\n\t\t\t\tassert(qtail<qhead); R &cur=q[qtail];\n\t\t\t\tint now=min(rem,cur.vol);\n\t\t\t\t//printf(\"removing %d of temp %.9lf\\n\",now,cur.t);\n\t\t\t\trem-=now; cur.vol-=now; tavg=(tavg*(need+rem+now)-1.0*cur.t*now)/(need+rem);\n\t\t\t\twhile(qtail<qhead&&q[qtail].vol==0) ++qtail;\n\t\t\t}\n\t\t\twhile(qtail<qhead&&have.t<q[qhead-1].t) have=merge(have,q[--qhead]);\n\t\t\t//printf(\"-> %d of temp %.9lf (%.9lf)\\n\",have.vol,have.t,qtail<qhead?q[qhead-1].t:-1.0);\n\t\t\tq[qhead++]=have;\n\t\t}\n\t\tprintf(\"%.9lf\\n\",tavg);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 5e5 + 10;\nint n , L;\nint x[N];\ndb k[N];\n\nint main(){\n    scanf(\"%d%d\",&n,&L);\n    int l = 0 , r = 0 , v;\n    db ysum = 0 , t;\n    rep(i,0,n) {\n        scanf(\"%lf%d\",&t,&v);\n        int vremain = v;\n        while(l < r && vremain >= x[l])\n            ysum -= x[l] * k[l] , vremain -= x[l++];\n        if(vremain && l < r)\n            ysum -= vremain * k[l] , x[l] -= vremain;\n        while(l < r && t < k[r-1]) {\n            --r;\n            ysum -= x[r] * k[r];\n            t = (t * v + x[r] * k[r]) / (v + x[r]);\n            v += x[r];\n        }\n        x[r] = v , k[r] = t;\n        r++;\n        ysum += v * t;\n        printf(\"%.8f\\n\",ysum / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+10;\ntypedef long long ll;\n\nint gi() {\n\tint x=0,o=1;char ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-') ch=getchar();\n\tif(ch=='-') o=-1,ch=getchar();\n\twhile(isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*o;\n}\n\nstruct dat {\n\tll v;double t;\n} q[N];\n\nint n,L,h=1,t=0;\ndouble s;\nll sumv=0;\n\nint main() {\n\tcin>>n>>L;\n\tfor(int i=1;i<=n;i++) {\n\t\tll T,v;cin>>T>>v;\n\t\twhile(sumv+v>L) {\n\t\t\tll tmp=min(q[h].v,sumv+v-L);\n\t\t\tq[h].v-=tmp;sumv-=tmp;s-=q[h].t*tmp;\n\t\t\tif(!q[h].v) ++h;\n\t\t}\n\t\tq[++t]=(dat){v,T};\n\t\tsumv+=v;s+=v*T;\n\t\twhile(h<t&&q[t-1].t>=q[t].t) {\n\t\t\tq[t-1].t=(q[t-1].t*q[t-1].v+q[t].t*q[t].v)/(q[t-1].v+q[t].v);\n\t\t\tq[t-1].v+=q[t].v;--t;\n\t\t}\n\t\tcout<<setprecision(10)<<fixed<<s/L<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#define int         int64_t\n#define ii          pair<int,int>\n#define dd          pair<double,double>\n#define vi          vector<int>\n#define pb          push_back\n#define all(x)      (x).begin(), (x).end()\n#define checkBit(v, p)      (v&(1LL << p))\n#define loop(i,a,b) for(int i = a;i < int(b);i++)\n#define x           first\n#define y           second\nusing namespace std;\nint inf = 2e9, mod = 1e9 + 7;\n\nstruct Pnt{int v; double t;};\n\nvoid merge(Pnt &a, Pnt b){\n    a.t = (a.t * a.v + b.t * b.v) / (a.v + b.v);\n    a.v += b.v;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false); cout << fixed <<setprecision(10);\n    int n, L; cin >> n >> L;\n    vector<Pnt> q(n);\n    int volume = 0; double temp = 0;\n    for(int i=0,l=n,r=n-1,t,v;i<n;i++){\n        cin >> t >> v;\n        while(volume + v > L){\n            int dec = min(q[r].v, volume + v - L);\n            volume -= dec;\n            temp -= dec * q[r].t;\n            q[r].v -= dec;\n            if(q[r].v == 0) r--;\n        }\n        volume += v;\n        temp += v * t;\n        cout << temp / (double)L << '\\n';\n        q[--l].v = v, q[l].t = t;\n        for(; l < r && q[l].t < q[l+1].t; l++) merge(q[l+1], q[l]);\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-8;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = 500005;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    RD(n); RF(L); DB S=0,V=0;\n    DO(n){\n        DB t, v; RF(t), RF(v);\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.12f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\n\npair<double, int> qu[500011], *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    H[0] = T[0];\n    double sum = (double)T[0]*L;\n\n    *head = make_pair(T[0], L);\n    for (int i=1; i<N; i++) {\n\tint rest = V[i];\n\twhile (rest) {\n\t    if (rest >= head->second) {\n\t\trest -= head->second;\n\t\tsum -= head->first * head->second;\n\t\thead++;\n\t    } else {\n\t\tsum -= head->first * rest;\n\t\thead->second -= rest;\n\t\trest = 0;\n\t    }\n\t}\n\n\tsum += (double)T[i] * V[i];\n\tH[i] = sum / L;\n\tif (tail->first > T[i]) {\n\t    head = tail = qu;\n\t    *head = make_pair(H[i], L);\n\t} else {\n\t    tail++;\n\t    *tail = make_pair(T[i], V[i]);\n\t}\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n#define int long long\ntypedef long double db;\nint N,L;\n \nint T[500005],V[500005];\ndb SM[500005],tt[500005];\nint vv[500005],smv[500005];\nint ql,qr;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline int R()\n{\n\tchar t=GC;\n\tint x=0;\n\twhile(!isdigit(t)) t=GC;\n\twhile(isdigit(t)) x=x*10+t-48,t=GC;\n\treturn x;\n}\nmain() {\n\tN = R(); L = R();\n\tfor(int i=1;i<=N;i++) {\n\t\tT[i] = R(); V[i] = R();\n\t}\n\tprintf(\"%lld\\n\",T[1]);\n\tql = qr = 1;\n\tvv[1] = V[1];\n\ttt[1] = T[1];\n\tsmv[1] = V[1];\n\tSM[1] = vv[1] * tt[1];\n\tfor(int i=2;i<=N;i++) {\n\t\tif(T[i]<=tt[qr]) {\n\t\t\tdb maxv = min(1.0l*L-1.0l*V[i],1.0l*vv[qr]);\n\t\t\tdb nt = (tt[qr]*maxv + 1.0*V[i]*T[i]) / (maxv+V[i]);\n\t\t\tvv[qr] = V[i] + maxv;\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\ttt[qr] = nt;\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t} else {\n\t\t\t++qr;\n\t\t\tvv[qr] = V[i];\n\t\t\ttt[qr]  = T[i];\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t}\n\t\twhile(ql<qr&&smv[qr]-smv[ql]>L) ql++;\n\t\tdb ans = SM[qr] - SM[ql] + 1.0l*(L-smv[qr]+smv[ql])*tt[ql];\n\t\tprintf(\"%.8Lf\\n\",1.0l*ans/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nint x[500005];\ndouble y[500005];\nint main(){\n\tint n,L;\n\tscanf(\"%d%d\\n\",&n,&L);\n\tint head=1,tail=0,sum=0;\n\tdouble ans=0;\n\tfor (int i=1;i<=n;i++){\n\t\tint t,v;\n\t\tscanf(\"%d%d\\n\",&t,&v);\n\t\tfor (;head<=tail && sum-x[head]>=L-v;) ans-=y[head],sum-=x[head++];\n\t\tif (sum>L-v){\n\t\t\tans-=y[head];\n\t\t\ty[head]-=(sum-L+v)*y[head]/x[head];\n\t\t\tans+=y[head];\n\t\t\tx[head]-=sum-L+v;\n\t\t}\n\t\tsum=L;\n\t\tdouble s=1.0*v*t;ans+=s;\n\t\tfor (;head<=tail && y[tail]*v>=s*x[tail];tail--)\n\t\t\tv+=x[tail],s+=y[tail];\n\t\tx[++tail]=v;y[tail]=s;\n\t\tprintf(\"%.7f\\n\",ans/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\ntypedef long long LL;\ntypedef pair<LL,double> pld;\nconst int N=500010;\nLL t[N],v[N];\npld q[N];\nint l=1,r=0;\n\nint main()\n{\n    int n=read(),L=read();\n    for(int i=1;i<=n;i++)\n        t[i]=read(),v[i]=read();\n    int sum=0;double cur=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(v[i]+sum>L)\n        {\n            int pour=min(v[i]+sum-L,q[l].FR);\n            sum-=pour;\n            q[l].FR-=pour;\n            cur-=q[l].SE*pour;\n            if(!q[l].FR) l++;\n        }\n        q[++r]=pld(v[i],t[i]);\n        sum+=v[i];cur+=t[i]*v[i];\n        while(l<=r&&q[r].SE<q[r-1].SE)\n        {\n            q[r-1].SE=(q[r-1].SE*q[r-1].FR+q[r].SE*q[r].FR)/(q[r-1].FR+q[r].FR);\n            q[r-1].FR+=q[r].FR;r--;\n        }\n        printf(\"%.7lf\\n\",cur/L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int Q=1<<19;\n#define db double\ndb qt[Q];\nint qv[Q];\nint hd=1,tl=0;\nconst db eps=1e-9;\nint main()\n{\n\tint n;\n\tint L;\n\tdb als=0;\n\tscanf(\"%d%d\",&n,&L);\n\twhile(n--){\n\t\tint v;\n\t\tdb t;\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint qaq=L*(hd<=tl)+v;\n\t\twhile(qaq>L){\n\t\t\tint now=min(qaq-L,qv[hd]);\n\t\t\tqaq-=now;\n\t\t\tals-=qt[hd]*now;\n\t\t\tqv[hd]-=now;\n\t\t\tif(!qv[hd])++hd;\n\t\t}\n\t\tals+=t*v;\n\t\tprintf(\"%.8lf\\n\",als/L);\n\t\twhile(hd<=tl&&t-qt[tl]<eps){\n\t\t\tt=(db)(t*v+qt[tl]*qv[tl])/(v+qv[tl]);\n\t\t\tv+=qv[tl];\n\t\t\t--tl;\n\t\t}\n\t\tqv[++tl]=v;\n\t\tqt[tl]=t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, ll> pairDI;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nll N, L;\nvector<ll> t, v;\nvector<pairDI> A;\nvector<ll> B;\n\nint main(int argc, char *argv[])\n{\n    cin >> N >> L;\n\n    t.resize(N);\n    v.resize(N);\n    A.resize(N);\n    B.resize(N);\n\n    cin >> t[0] >> v[0];\n\n    A[0] = make_pair(t[0], v[0]);\n    B[0] = 0;\n    cout << fixed << setprecision(7) << A[0].first << endl;\n\n    FOR1(i,1,N) {\n        cin >> t[i] >> v[i];\n        if (A[i-1].first < t[i]) {\n            A[i] = make_pair(t[i], v[i]);\n            B[i] = A[i-1].second;\n        }\n        else if (A[i-1].first == t[i]) {\n            A[i] = make_pair(t[i], min(A[i-1].second + v[i], L));\n            B[i] = 0;\n        }\n        else {\n            ll vol = min(L, A[i-1].second + v[i]);\n            double tmp = (t[i] * v[i] + A[i-1].first * (vol - v[i])) / vol;\n            for (int j = i-2; vol < L && A[j].first >= tmp; j--) {\n                tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                    / (vol + min(L-vol, B[j+1]));\n                vol += min(L-vol, B[j+1]);\n            }\n            A[i] = make_pair(tmp, vol);\n            B[i] = 0;\n        }\n\n        ll vol = A[i].second;\n        double tmp = A[i].first;\n        for (int j = i-1; vol < L; j--) {\n            tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                / (vol + min(L-vol, B[j+1]));\n            vol += min(L-vol, B[j+1]);\n        }\n\n        cout << fixed << setprecision(7) << tmp << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define myp pair<ll,ll>\nusing namespace std;\nconst int N=5e5+10;\nint n,l;\nmyp q[N]; //pair<v,v*t> 比较时不会产生精度误差 \nint head,tail;\nint main(){\n\tll v,t,temp_v=0,temp=0;\n\tdb now_t;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\tq[head++]=make_pair(v,v*t);\n\t\ttemp_v+=v,temp+=v*t;\n\t\twhile(temp_v>l){\n\t\t\tif(temp_v-q[tail].first>=l) temp_v-=q[tail].first,temp-=q[tail].second,tail++;\n\t\t\telse now_t=db(q[tail].second)/q[tail].first,q[tail].first-=temp_v-l,temp_v=l,temp=temp-q[tail].second+now_t*q[tail].first,q[tail].second=now_t*q[tail].first;\n\t\t}\n\t\tif(head-2>=tail&&db(q[head-1].second)/q[head-1].first<db(q[head-2].second)/q[head-2].first) q[head-2].first+=q[head-1].first,q[head-2].second+=q[head-1].second,head--;\n\t\tprintf(\"%.10lf\\n\",db(temp)/temp_v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cinttypes>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\nusing u4t = std::uint32_t;\nusing i4t = std::int32_t;\nusing u8t = std::uint64_t;\nusing i8t = std::int64_t;\nu8t N,L;\nstd::vector<u8t> tau;\nstd::vector<u8t> vol;\nint main() {\n  std::cin>>N>>L;\n  for(int i=0;i<N;i++){\n    u8t t;u8t v;\n    std::cin>>t>>v;\n    tau.push_back(t*v);\n    vol.push_back(v);\n  }\n  std::vector<double> tauM;\n  std::vector<double> volM;\n  double tau1=tau[0];\n  double vol1=vol[0];\n  double temp=tau1/vol1;\n  //printf(\"%.8f\\n\", temp);\n  tauM.push_back(tau1);\n  volM.push_back(vol1);\n  for(int i=1;i<N;i++){\n    if(temp>=(double)tau[i]/(double)vol[i]){\n      vol1=std::min((double)L-vol[i],vol1);\n    }else{\n      vol1=0;\n    }\n    //fprintf(stderr,\"v %f\\n\",vol1);\n    tau1=temp*vol1;\n\n    tau1+=tau[i];\n    vol1+=vol[i];\n    temp=tau1/vol1;\n    tauM.push_back(tau1);\n    volM.push_back(vol1);\n    //printf(\"%.8f\\n\", temp);\n  }\n  //for(int i=0;i<N;i++)fprintf(stderr,\"M %d,%f,%f\\n\",i,tauM[i]/volM[i],volM[i]);\n  int j=0;\n  double mizu=0;\n  double netu=0;\n  for(int i=0;i<N;i++){\n    mizu+=vol[i];\n    netu+=tau[i];\n    while(mizu>=L){\n      mizu-=vol[j];\n      netu-=tau[j];\n      j++;\n    }\n    double mizuM=L-mizu;\n    double netuM=(tauM[j-1]/volM[j-1])*mizuM;\n    //fprintf(stderr,\"%d,%f,%f\\n\",j,netuM,mizuM);\n    double tmax=(netu+netuM)/(mizu+mizuM);\n    printf(\"%.8f\\n\", tmax);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[800005],righ[800005];\nlong double bai[800005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tfor(j=0;j<bainum;j++){\n\t\t\t\tif(lef[j] <= b && b <= righ[j]){\n\t\t\t\t\ttable[b] *= bai[j];\n\t\t\t\t\tif(lef[j] == b){\n\t\t\t\t\t\tlef[j]++;\n\t\t\t\t\t\tif(lef[j] > righ[j]){\n\t\t\t\t\t\t\tlef[j] = lef[bainum-1];\n\t\t\t\t\t\t\trigh[j] = righ[bainum-1];\n\t\t\t\t\t\t\tbainum--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tassert(0 == 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai[bainum] = (long double)(l - y[i]) / (long double)l;\n\t\t\tlef[bainum] = num;\n\t\t\trigh[bainum] = i;\n\t\t\tbainum++;\n\t\t\tassert(bainum <= 2005);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  double sum = 0;\n  vector<pair<double, double>> Q;\n  Q.reserve(n);\n  int head = 0;\n  // deque<pair<double, double>> Q;\n  for (int i = 0; i < n; ++i) {\n    double T, V;\n    scanf(\"%lf%lf\", &T, &V);\n    if (i > 0) {\n      double rem = V;\n      while (rem > 0) {\n        if (Q[head].first > rem) {\n          Q[head].first -= rem;\n          sum -= rem * Q[head].second;\n          break;\n        } else {\n          rem -= Q[head].first;\n          sum -= Q[head].first * Q[head].second;\n          ++head;\n        }\n      }\n    }\n    // trace(i);\n    // for (auto& it : Q) {\n    //   trace(it.first, it.second);\n    // }\n    while (head < Q.size() && Q.back().second > T) {\n      double V2 = Q.back().first, T2 = Q.back().second;\n      Q.pop_back();\n      sum -= V2 * T2;\n      T = (V2 * T2 + V * T) / (V2 + V);\n      V += V2;\n    }\n    Q.push_back({V, T});\n    sum += V * T;\n    printf(\"%.10f\\n\", sum / m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        if (!sgn(ll-d)){\n            V = 0;\n        }\n        else {\n            V = ((V*ll) - d*W.front().fi) / (ll-d);\n        }\n        l -= d; W.front().se -= d; ll -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n        \n    }\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n    freopen(\"/users/minakokojima/Documents/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        \n        DB r = l;\n        while (!W.empty() && sgn(W.back().fi, V) >= 0){\n            r += W.back().se;\n            W.pop_back();\n        }\n        W.push_back(MP(V, r));\n        OT(V);\n        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500009\nusing namespace std;\n\nint n,m,q[N];\nstruct node{ double x,y,z; }a[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,k,head=1,tail=0; double now=0,ans=0;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%lf%lf\",&a[i].x,&a[i].y);\n\t\tans+=a[i].x*a[i].y;\n\t\ta[i].z=now=now+a[i].y;\n\t\twhile (head<=tail && a[q[head]].z<=now-m) head++;\n\t\tk=q[head];\n\t\tans-=a[k].x*a[k].y;\n\t\ta[k].y=a[k].z-(now-m);\n\t\tans+=a[k].x*a[k].y;\n\t\tfor (; head<=tail && a[q[tail]].x>a[i].x; tail--){\n\t\t\ta[i].x=(a[i].x*a[i].y+a[q[tail]].x*a[q[tail]].y)/(a[i].y+a[q[tail]].y);\n\t\t\ta[i].y+=a[q[tail]].y;\n\t\t}\n\t\tq[++tail]=i;\n\t\tprintf(\"%.10f\\n\",ans/m);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-8\n#define MAX_N 500000\n#define fir first\n#define sec second\nusing namespace std;\ntypedef double dnt;\ntypedef pair<dnt,dnt> pnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, l, r; dnt C, T, V;\npnt que[MAX_N+5], tot, mrg;\npnt operator + (const pnt &x, const pnt &y)\n\t{return pnt(x.fir+y.fir, x.sec+y.sec);}\npnt operator - (const pnt &x, const pnt &y)\n\t{return pnt(x.fir-y.fir, x.sec-y.sec);}\ndnt operator * (const pnt &x, const pnt &y)\n\t{return x.fir*y.sec-x.sec*y.fir;}\nint main() {\n\tread(n), read(C), read(T), read(V);\n\tprintf(\"%.7lf\\n\", T);\n\ttot = que[r] = pnt(V, T*V);\n\tfor (int i = 1; i < n; i++) {\n\t\tread(T), read(V); dnt lft = V;\n\t\twhile (que[l].fir < lft-EPS)\n\t\t\tlft -= que[l].fir, tot = tot-que[l++];\n\t\ttot = tot-que[l];\n\t\tque[l].sec /= que[l].fir;\n\t\tque[l].fir -= lft;\n\t\tque[l].sec *= que[l].fir;\n\t\ttot = tot+que[l];\n\t\tmrg = pnt(V, T*V);\n\t\twhile (l <= r && que[r]*mrg < -EPS)\n\t\t\tmrg = mrg+que[r--];\n\t\ttot = tot+pnt(V, T*V), que[++r] = mrg;\n\t\tprintf(\"%.7lf\\n\", tot.sec/tot.fir);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int unsigned long long\n#define double long double \nvector<pair<int,int>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tint l=as[j].second;\n\t\t\tif(l!=-1){\n\t\t\t\tint val=as[j].first*l;\n\t\t\t\tif(need>l){\n\t\t\t\t\tans+=val;\n\t\t\t\t\tneed-=l;\n\t\t\t\t\ti-=99;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tlong long val=0;\n\t\t\tint totall=0;\n\t\t\tfor(int z=vcnt-101;z<vcnt-1;z++){\n\t\t\t\ttotall+=v[z].second;\n\t\t\t}\n\t\t\tif(totall>=l){\n\t\t\t\tas.push_back({-1,-1});\n\t\t\t}\n\t\t\tfor(int z=vcnt-101;z<vcnt-1;z++){\n\t\t\t\tval+=v[z].first*v[z].second;\n\t\t\t}\n\t\t\tas.push_back({(double)val/totall,totall});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tint ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,(double)ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(double& x){ scanf(\"%lf\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define eb emplace_back\n#define x first\n#define y second\n\ndouble vol[500010];\ndouble tmp[500010];\n\nint n; double l;\n\ndouble h;\n\nint main()\n{\n\tint head=0, tail=0;\n\tread(n, l);\n\tfor(;n--;){\n\t\tdouble t, v;\n\t\tread(t, v);\n\t\tdouble left_v = v;\n\t\twhile(head<tail && left_v > 0){\n\t\t\tdouble toru = min(vol[head], left_v);\n\t\t\th -= toru * tmp[head];\n\t\t\tvol[head] -= toru;\n\t\t\tleft_v -= toru;\n\t\t\tif(vol[head] == 0){\n\t\t\t\t++head;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", (h + t*v) / l);\n\t\tvol[tail] = v;\n\t\ttmp[tail] = t;\n\t\th += v*t;\n\t\t++tail;\n\t\twhile(tail-head >= 2){\n\t\t\tif(tmp[tail-2] < tmp[tail-1]) break;\n\t\t\tdouble new_temp = tmp[tail-1]*vol[tail-1] + tmp[tail-2]*vol[tail-2];\n\t\t\tvol[tail-2] += vol[tail-1];\n\t\t\ttmp[tail-2] = new_temp;\n\t\t\t--tail;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<iomanip>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nconst int MAXN = 500100;\n\nint N;\nll L;\nll t[MAXN], v[MAXN];\n\nvector <pair <ld, ld> > hull;\n\nint main()\n{\n\tcin >> N >> L;\n\tfor (int i = 0; i < N; i++)\n\t\tcin >> t[i] >> v[i];\n\tcout << fixed << setprecision(9);\n\n\thull.push_back(make_pair(0, 0));\n\tint chull = 0;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tld vtot = v[i] + hull.back().first;\n\t\tld ttot = t[i] * v[i] + hull.back().second;\n\t\thull.push_back(make_pair(vtot, ttot));\n\n\t\twhile (chull + 1 < hull.size() && hull[chull + 1].first + L <= vtot)\n\t\t\tchull++;\n\t\tld vlo = hull[chull].first - (vtot - L), vhi = hull[chull + 1].first - (vtot - L);\n\t\tld ttemp = (vhi * hull[chull].second - vlo * hull[chull + 1].second) / (vhi - vlo);\n\t\thull[chull] = make_pair(vtot - L, ttemp);\n\t\tcout << (ttot - ttemp) / L << \"\\n\";\n\n\t\thull.pop_back();\n\t\twhile (hull.size() > chull + 1)\n\t\t{\n\t\t\tld v1 = hull[hull.size() - 2].first, t1 = hull[hull.size() - 2].second;\n\t\t\tld v2 = hull[hull.size() - 1].first, t2 = hull[hull.size() - 1].second;\n\t\t\tif (t1 * (vtot - v2) + ttot * (v2 - v1) < (vtot - v1) * t2)\n\t\t\t\thull.pop_back();\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\thull.push_back(make_pair(vtot, ttot));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\n#define double long double\nconst double EPS=1e-8;\n\nint N,L;\n\nsigned main(){\n    cin>>N>>L;\n\n    deque<pair<double,double>>deq;\n    double T=0.0,V=0.0;\n    rep(i,N){\n        int t,v;\n        cin>>t>>v;\n\n        while(V>L-v){\n            double tmp=min(V-L+v,deq.front().se);\n            T*=V;\n            T-=deq.front().fi*tmp;\n            V-=tmp;\n            T/=V;\n            deq.front().se-=tmp;\n            if(deq.front().se<EPS)deq.pop_front();\n        }\n\n        deq.push_back({t,v});\n        T*=V;\n        T+=v*t;\n        V+=v;\n        T/=V;\n\n        while(deq.size()>=2&&deq[deq.size()-2].fi>=deq[deq.size()-1].fi){\n            auto p=deq.back();\n            deq.pop_back();\n            auto q=deq.back();\n            deq.pop_back();\n            deq.push_back(pair<double,double>((p.fi*p.se+q.fi*q.se)/(p.se+q.se),p.se+q.se));\n        }\n\n\n        printf(\"%.20Lf\\n\",T);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 100005\n#define LL long long\nusing namespace std;\nint n,l,r,L;\nstruct dot{\n\tLL x; double y;\n\tdot(LL _x=0,double _y=0){ x=_x,y=_y;}\n}A[N],p;\ndot operator +(const dot &p,const dot &q){ return dot(p.x+q.x,p.y+q.y);}\ndot operator -(const dot &p,const dot &q){ return dot(p.x-q.x,p.y-q.y);}\ndot operator *(const dot &p,double r){ return dot(p.x*r,p.y*r);}\ndot operator *(double r,const dot &p){ return dot(p.x*r,p.y*r);}\ndouble cj(dot p,dot q){ return p.x*q.y-p.y*q.x;}\ndot Get(dot p,dot q,double x)\n{\n\tdouble k=(q.y-p.y)/(q.x-p.x);\n\treturn dot(x,k*x+(p.y-k*p.x));\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&L);\n\tA[l=r=1]=dot(0,0);\n\twhile(n--){\n\t\tscanf(\"%lf %lld\",&p.y,&p.x);\n\t\tp.y*=p.x,A[r+1]=A[r]+p,r++;\n\t\twhile(l<r&&A[r].x-A[l+1].x>L) l++;\n\t\tif(A[r].x-A[l].x>L)\n\t\t\tA[l]=Get(A[l],A[l+1],A[r].x-L);\n\t\twhile(l+1<r&&cj(A[r]-A[r-1],A[r]-A[r-2])>=0) A[r-1]=A[r],r--;\n\t\tprintf(\"%.7lf\\n\",(A[r].y-A[l].y)/L);\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<int,int>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tdouble val=as[j].first;\n\t\t\tdouble l=as[j].second;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdouble val=v[i].first;\n\t\tdouble l=v[i].second;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tint n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=101;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tint val=0,l=0;\n\t\t\tfor(int i=vcnt-100;i<vcnt;i++){\n\t\t\t\tval+=v[i].first;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tdouble val=v[z].first;\n\t\t\tdouble ls=v[z].second;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={remv+0.5,lbs+0.5+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({a*b+0.5,b+0.5});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\nusing namespace std;\n\ntypedef long long LL;\nint n,l,head,tail,a[500100];\ndouble b[500100],sumt;\n\nint getint()\n{\n    char ch;\n    while (!isdigit(ch=getchar()));\n    int x=ch-'0';\n    for (; isdigit(ch=getchar()); x=x*10+ch-'0');\n    return x;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&l);\n    b[head=tail=1]=getint(),a[1]=getint(),sumt=a[1]*b[1];\n    printf(\"%.10f\\n\",b[1]);\n    while (--n)\n    {\n        double t=getint(); int v=getint(),w=v;\n        for (; w>=a[head]; sumt-=b[head]*a[head],w-=a[head++]);\n        sumt+=v*t-b[head]*w,a[head]-=w;\n        for (; head<=tail && b[tail]>t; --tail)\n            t=(v*t+a[tail]*b[tail])/(v+a[tail]),v+=a[tail];\n        a[++tail]=v,b[tail]=t;\n        printf(\"%.10f\\n\",sumt/l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 5e5 + 1e3;\n\nint n, L, fr = 1, tl;\n\nstruct water {\n\tdouble s; long long v;\n\twater(double s_ = 0, long long v_ = 0): s(s_), v(v_) {};\n\tinline water friend operator + (const water &lhs, const water &rhs) {\n\t\treturn lhs.v + rhs.v != 0 ? water((lhs.s * lhs.v + rhs.s * rhs.v) / (lhs.v + rhs.v), lhs.v + rhs.v) : water();\n\t}\n\tinline water friend operator - (const water &lhs, const water &rhs) {\n\t\treturn lhs.v - rhs.v != 0 ? water((lhs.s * lhs.v - rhs.s * rhs.v) / (lhs.v - rhs.v), lhs.v - rhs.v) : water();\n\t}\n\tinline water& operator -= (const water &rhs) { return *this = *this - rhs; }\n\tinline water& operator += (const water &rhs) { return *this = *this + rhs; }\n} q[N], res, now;\n\nint main () {\n\n\tFile();\n\n\tn = read(); L = read();\n\tFor (i, 1, n) {\n\t\tnow.s = read(); now.v = read(); res += now;\n\t\tfor (; fr <= tl && res.v > L; ++ fr) {\n\t\t\tif (res.v - L >= q[fr].v) res -= q[fr];\n\t\t\telse {\n\t\t\t\twater tmp = water(q[fr].s, res.v - L);\n\t\t\t\tq[fr] -= tmp; res -= tmp; break;\n\t\t\t}\n\t\t}\n\t\tfor (q[++ tl] = now; fr + 1 <= tl && q[tl].s < q[tl - 1].s; -- tl) q[tl - 1] += q[tl];\n\t\tprintf (\"%lf\\n\", res.s);\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500020\nusing namespace std;\nint read(){\n\tint nm=0,fh=1; char cw=getchar();\n\tfor(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n\tfor(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n\treturn nm*fh;\n}\nint n,m,q[M],hd,tl,num[M],now;\ndouble V=0.0,ans=0.0,maxn,tot,T[M];\ndouble calc(int x){return (1.0*num[x])*T[x];}\nint main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tn=read(),m=read(),maxn=m*1.0,hd=1;\n\tfor(int i=1;i<=n;i++){\n\t\tT[i]=read()*1.0,num[i]=read(),q[++tl]=i,ans+=calc(i),V+=num[i];\n\t\twhile(hd<tl&&T[q[tl]]<=T[q[tl]-1]){\n\t\t\tans-=calc(q[tl])+calc(q[tl-1]);\n\t\t\tif(num[q[tl]]+num[q[tl-1]]>m) num[q[tl-1]]=m-num[q[tl]];\n\t\t\tT[q[tl-1]]=(calc(q[tl-1])+calc(q[tl]))/((num[q[tl-1]]+num[q[tl]])*1.0);\n\t\t\tnum[q[tl-1]]+=num[q[tl]],tl--;\n\t\t\tif(num[q[tl]]==m) hd=tl,ans=calc(q[tl]),V=m;\n\t\t\telse  ans+=calc(q[tl]);\n\t\t}\n\t\twhile(V>m){\n\t\t\tif(V-num[q[hd]]>=m) V-=num[q[hd]],ans-=calc(q[hd]),hd++;\n\t\t\telse num[q[hd]]-=V-m,ans-=(1.0*(V-m))*T[q[hd]],V=m;\n\t\t}\n\t\tprintf(\"%.7f\\n\",ans/maxn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 500010;\ntypedef double db;\nconst db eps = 1e-8;\ninline int judge(db x) {\n  return x > -eps ? x > eps ? 1 : 0 : -1;\n}\nstruct point {\n  db x,y;\n  point(db x_=0,db y_=0): x(x_), y(y_) {}\n  db operator * (const point& a) const {\n    return x * a.y - y * a.x;\n  }\n  point operator + (const point& a) const {\n    return point(x + a.x, y + a.y);\n  }\n  point operator - (const point& a) const {\n    return point(x - a.x, y - a.y);\n  }\n  void operator += (const point& a) {\n    *this = *this + a;\n  }\n  void operator -= (const point& a) {\n    *this = *this - a;\n  }\n} q[N];\nint n,cap,t,v,l=1,r;\npoint cur,tmp;\nint main() {\n  scanf(\"%d%d\",&n,&cap);\n  scanf(\"%d%d\",&t,&v);\n  printf(\"%d.00000000\\n\",t);\n  q[++r] = point(v,1.0 * t * v);\n  cur += point(v,1.0 * t * v);\n  for (int i = 2 ; i <= n ; ++ i) {\n    scanf(\"%d%d\",&t,&v);\n    db a = v;\n    while (judge(a - q[l].x) >= 0)\n      a -= q[l].x, cur -= q[l++];\n    cur -= q[l];\n    q[l].y *= (q[l].x - a) / q[l].x;\n    q[l].x -= a;\n    cur += q[l];\n    tmp = point(v,1.0 * t * v);\n    while (l <= r && judge(q[r] * tmp) <= 0)\n      tmp += q[r], cur -= q[r--];\n    if (judge(tmp.x - cap) > 0) {\n      tmp.y *= cap / tmp.x;\n      tmp.x = cap;\n    }\n    q[++r] = tmp;\n    cur += tmp;\n    printf(\"%.8lf\\n\",cur.y / cur.x);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nlong long sum[500001];\nlong long gopsum[500001];\nint dam[500001][2];\ndouble ans[500001];\nset< pair<double, int> > stat;\n\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d %d\",&dam[i][0],&dam[i][1]);\n\t\tsum[i] = sum[i-1] + dam[i][1];\n\t\tlong long cal = dam[i][0]; cal *= dam[i][1];\n\t\tgopsum[i] = gopsum[i-1] + cal;\n\t\tif(i==1){\n\t\t\tans[1] = dam[i][0];\n\t\t\tstat.insert(make_pair(ans[1], 1));\n\t\t}else{\n\t\t\tauto iit = stat.begin();\n\t\t\tauto nxt = stat.begin();\n\t\t\twhile(true){\n\t\t\t\tnxt = iit; nxt++;\n\t\t\t\tif(sum[i] - sum[(*iit).second] > l){\n\t\t\t\t\tstat.erase(iit);\n\t\t\t\t\tiit = nxt;\n\t\t\t\t}else{\n\t\t\t\t\tlong long cal2 = gopsum[i] - gopsum[(*iit).second] + (l - (sum[i] - sum[(*iit).second])) * ans[(*iit).second];\n\t\t\t\t\tans[i] = (double) cal2 / (double) l;\n\t\t\t\t\tstat.insert(make_pair(ans[i], i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%.6lf\\n\", ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cassert>\n#include<cstdlib>\n#include<cstring>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define lf else if\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> Vi;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=500000+19;\n\ndb x[N],y[N],a,b,tmp;\nint n,L,frt,top,l,r,res,u,v,pos;\n\nstruct Point{\n\tdb x,y;\n};\ntypedef Point Vector;\n\nVector operator - (Point A,Point B){\n\treturn (Vector){A.x-B.x,A.y-B.y};\n}\ndb cross(Vector A,Vector B){\n\treturn A.x*B.y-A.y*B.x;\n}\n\nint main(){\n\tn=IN(),L=IN();\n\tfrt=1;top=1;\n\tFor(i,1,n+1){\n\t\tu=IN(),v=IN();\n\t\tpos=L-v;\n\t\twhile (frt<=top&&x[frt]+a>=pos) frt++;\n\t\tif (frt>top){\n\t\t\tprintf(\"%.10lf\\n\",1.0*u*v/L);\n\t\t\tfrt--;\n\t\t\tx[frt]=-a;\n\t\t\ty[frt]=-b;\n\t\t} else{\n\t\t\ttmp=y[frt]+b+(y[frt-1]-y[frt])/(x[frt-1]-x[frt])*(pos-(x[frt]+a));\n\t\t\tprintf(\"%.10lf\\n\",(1.0*u*v+y[frt]+b+(y[frt-1]-y[frt])/(x[frt-1]-x[frt])*(pos-(x[frt]+a)))/L);\n\t\t\tfrt--;\n\t\t\tx[frt]=pos-a;\n\t\t\ty[frt]=tmp-b;\n\t\t}\n\t\ta+=v,b+=1.0*u*v;\n\t\twhile (top-frt+1>=2&&cross((Vector){x[top]+a,y[top]+b},(Vector){x[top-1]-x[top],y[top-1]-y[top]})>=0) top--;\n\t\ttop++;\n\t\tx[top]=-a;\n\t\ty[top]=-b;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 1000005\nusing namespace std;\nint n,l;\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y):x(x),y(y){}\n\tfriend point operator+(const point &a,const point &b)  {return point(a.x+b.x,a.y+b.y);}\n\tfriend point operator-(const point &a,const point &b)  {return point(a.x-b.x,a.y-b.y);}\n\tfriend double dot(const point &a,const point &b)  {return a.x*b.x+a.y*b.y;}\n\tfriend double cross(const point &a,const point &b)  {return a.x*b.y-a.y*b.x;}\n}p[N],Q[N];\nint main(){\n\tint x,y,L=0,R=0;\n\tscanf(\"%d%d%d%d\",&n,&l,&y,&x);\n\tQ[++R]=point(x,1.0*x*y),printf(\"%lf\\n\",1.0*y);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",&y,&x);\n\t\tp[i]=point(Q[L].x-x,Q[L].y-(1.0*x*y));\n\t\twhile(L<R&&Q[R-1].x-p[i].x>=l)  R--;\n\t\tif(L!=R){\n\t\t\tdouble slope=(Q[R].y-Q[R-1].y)/(Q[R].x-Q[R-1].x);\n\t\t\tif(Q[R].x-p[i].x>l){\n\t\t\t\tQ[R].y=Q[R-1].y+(l-(Q[R-1].x-p[i].x))*slope;\n\t\t\t\tQ[R].x=p[i].x+l;\n\t\t\t}\n\t\t}\n\t\twhile(L<R&&cross(Q[L]-p[i],Q[L+1]-p[i])>=0)  L++;\n\t\tQ[--L]=p[i];\n\t\tprintf(\"%lf\\n\",(Q[R].y-p[i].y)/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, double> pairID;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nint N, L;\ndeque<pairID> A;\n\nint main(int argc, char *argv[])\n{\n    int t, v;\n    double total_heat;\n\n    scanf(\"%d%d\", &N, &L);\n    scanf(\"%d%d\", &t, &v);\n    \n    A.push_front(make_pair(v, t));\n    total_heat = (double)v * t;\n    printf(\"%.7f\\n\", total_heat / L);\n    \n    FOR1(i,1,N) {\n        pairID back;\n        int vol;\n\n        scanf(\"%d%d\", &t, &v);\n        total_heat += (double)v * t;\n        \n        vol = v;\n        while (vol >= 0) {\n            back = A.back();\n            A.pop_back();\n            vol -= back.first;\n            total_heat -= back.first * back.second;\n        }\n        A.push_back(make_pair(-vol, back.second));\n        total_heat += -vol * back.second;\n\n        double heat = v * t;\n        vol = v;\n        while(A.size() > 0 && heat / vol <= A.front().second) {\n            heat += A.front().first * A.front().second;\n            vol += A.front().first;\n            A.pop_front();\n        }\n        A.push_front(make_pair(vol, heat / vol));\n\n        printf(\"%.7f\\n\", total_heat / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cinttypes>\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\nusing u4t = std::uint32_t;\nusing i4t = std::int32_t;\nusing u8t = std::uint64_t;\nusing i8t = std::int64_t;\nu8t N,L;\nstd::vector<u8t> tau;\nstd::vector<u8t> vol;\nint main() {\n  std::cin>>N>>L;\n  for(int i=0;i<N;i++){\n    u8t t;u8t v;\n    std::cin>>t>>v;\n    tau.push_back(t*v);\n    vol.push_back(v);\n  }\n  std::vector<double> tauM;\n  std::vector<double> volM;\n  double tau1=tau[0];\n  double vol1=vol[0];\n  double temp=tau1/vol1;\n  //printf(\"%.8f\\n\", temp);\n  tauM.push_back(tau1);\n  volM.push_back(vol1);\n  for(int i=1;i<N;i++){\n    if(temp>=(double)tau[i]/(double)vol[i]){\n      vol1=std::min((double)L-vol[i],vol1);\n    }else{\n      vol1=0;\n    }\n    //fprintf(stderr,\"v %f\\n\",vol1);\n    tau1=temp*vol1;\n\n    tau1+=tau[i];\n    vol1+=vol[i];\n    temp=tau1/vol1;\n    tauM.push_back(tau1);\n    volM.push_back(vol1);\n    //printf(\"%.8f\\n\", temp);\n  }\n  //for(int i=0;i<N;i++)fprintf(stderr,\"M %d,%f,%f\\n\",i,tauM[i]/volM[i],volM[i]);\n  for(int i=0;i<N;i++){\n    int j;\n    double mizu=0;\n    double netu=0;\n    for(j=i;mizu+volM[j]<L;j--){\n      mizu+=vol[j];\n      netu+=tau[j];\n    }\n    double mizuM=L-mizu;\n    double netuM=(tauM[j]/volM[j])*mizuM;\n    //fprintf(stderr,\"%d,%f,%f\\n\",j,netuM,mizuM);\n    double tmax=(netu+netuM)/(mizu+mizuM);\n    printf(\"%.8f\\n\", tmax);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\ndouble sumsTV[500011];\ndouble sumsV[500011];\n\ndouble evalH(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + H[l]*(1.0 - sumsV[i+1] + sumsV[l+1]));\n}\ndouble evalT(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + T[l]*(1.0 - sumsV[i+1] + sumsV[l+1]));\n}\n\nint qu[500011];\nint *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    REP (i, N) {\n\tsumsTV[i+1] = sumsTV[i] + (double)T[i] * V[i] / L;\n\tsumsV[i+1] = sumsV[i] + (double)V[i] / L;\n    }\n\n    H[0] = T[0];\n    *head = 0; // {0};\n\n    int pos = 0;\n    for (int i=1; i<N; i++) {\n\twhile (sumsV[i+1] - sumsV[*head+1] >= L) head++;\n\twhile (head < tail) {\n\t    double d = evalH(*head, i);\n\t    if (d <= evalH(*(head+1), i)) {\n\t\thead++;\n\t\tcontinue;\n\t    } else if (head+1 < tail && d <= evalH(*(head+2), i)) {\n\t\thead+=2;\n\t\tcontinue;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n\n\tif (head <= tail) amax(H[i], evalH(*head, i));\n\n\twhile (sumsV[i+1] - sumsV[pos+1] >= L) pos++;\n\tamax(H[i], evalT(pos, i));\n\n\twhile (head <= tail && H[*tail] <= H[i]) tail--;\n\ttail++;\n\t*tail = i;\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-8;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n     DB d = min(l, W.front().se);\n     V -= d*W.front().fi;\n     l -= d; W.front().se -= d;\n     if (!sgn(W.front().se)) W.pop_front();\n     }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\n\nint main() {\n\n    RD(n); RF(L); DB S=0,V=0;\n    DO(n){\n        DB t, v; RF(t), RF(v);\n        S+=(double)t*v; DB vv = v;\n          while (v && !W.empty()) {\n            if (v>=W.front().se) {\n                v-=W.front().se; S-=W.front().se*W.front().fi;\n                W.pop_front();\n            } else {\n                W.front().se-=v; S-=v*W.front().fi;\n                break;\n            }\n        }\n        v = vv;\n        V = L;\n        \n        printf(\"%lf\\n\",S/L);\n        /*while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }*/\n        while (!W.empty() && W.back().fi >= t){\n            DB _v = v; v += W.back().se;\n            t = (t*_v + W.front().fi*W.back().se) / v;\n            W.pop_back();\n        }\n        W.PB(MP(t, v));\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nll l,r;\ninline void merge(Vector &a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) merge(q[r-1],q[r--]);\n        printf(\"%lf\\n\",(db)y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<double, double>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            double t=T[i], v=V[i];\n            while(vv+v>L){\n               double t1=dp[0].first, v1=dp[0].second;\n               double tmp=min(vv+v-L, v1);\n               tt=tt-t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            double c1=t*v;\n            double c2=v;\n            while(ans){\n                double t2=dp[ans-1].first, v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || p < V.size() || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t\tV.pop_back();\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define Size(x) ((int)(x).size())\n#define pb push_back\n#define LD_OUT setprecision(12) << fixed\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int>pii;\ntypedef pair<ld,int>pdi;\nconst int INF = 1e9 + 10;\nconst int MN = 5e5 + 10;\n\nint uni[MN] , un , n , L;\nint T[MN] , v[MN];\npdi seg[MN<<2];\n\npdi merge(pdi A,pdi B)\n{\n\tif(A.second == 0 && B.second == 0) return A;\n\tpdi ret;\n\tret.second = A.second + B.second;\n\tret.first = (ld)((ld)A.first*A.second + (ld)B.first*B.second) / (B.second + A.second);\n\treturn ret;\n}\n\nvoid add(int id,int b,int e,int p,pdi val)\n{\n\tif(e-b==1){\n\t\tseg[id] = merge(seg[id], val);\n\t\treturn;\n\t}\n\tint mid = b+e>>1;\n\tif(p<mid) add(id<<1 , b , mid , p , val);\n\telse add(id<<1|1 , mid , e , p , val);\n\tseg[id] = merge(seg[id<<1] , seg[id<<1|1]);\n}\n\nint get_pl(int id,int b,int e,int val)\n{\n\tif(e-b == 1) return b;\n\tint mid = b+e>>1;\n\tif(seg[id<<1|1].second > val) return get_pl(id<<1|1 , mid , e , val);\n\telse return get_pl(id<<1 , b , mid , val-seg[id<<1|1].second);\n}\n\npdi get(int id,int b,int e,int l,int r)\n{\n\tif(r <= b || e <= l) return make_pair(0 , 0);\n\tif(l <= b && e <= r) return seg[id];\n\tint mid = b+e>>1;\n\treturn merge(get(id<<1 , b , mid , l , r) , get(id<<1|1 , mid , e , l , r));\n}\n\nint32_t main()\n{\n\tios_base :: sync_with_stdio(false) ,cin.tie(0) , cout.tie(0);\n\tcin >> n >> L;\n\tfor(int i=0;i<n;++i) cin >> T[i] >> v[i] , uni[i] = T[i];\n\tsort(uni , uni+n);\n\tun = unique(uni , uni+n) - uni;\n\tfor(int i=0;i<n;++i) T[i] = lower_bound(uni , uni+un , T[i]) - uni;\n\t//for(int i=0;i<n;++i) cout <<T[i] << ' ';cout << \"**\\n\";\n\t//cout << un << '\\n';\n\tfor(int i=0;i<n;++i){\n\t\tif(!i){\n\t\t\tcout << LD_OUT << (ld)(uni[T[i]]) << '\\n';\n\t\t}else{\n\t\t\tint p = get_pl(1 , 0 , un , L-v[i]);\n\t\t\tpdi res = get(1 , 0 , un , p+1 , un);\n\t\t\t//cout << p << ' ' << res.first << ' ' << res.second << ' ' << uni[p] << \"****\\n\";\n\t\t\tres = merge(res , make_pair(uni[p] , L-v[i]-res.second));\n\t\t\t//cout << res.first << ' ' << res.second << \"HAMID\\n\";\n\t\t//\tif(i == 2) cout << p << ' ' << res.first << ' ' << res.second << '\\n';\n\t\t\tres = merge(res , make_pair(uni[T[i]] , v[i]));\n\t\t\tcout << LD_OUT << res.first << '\\n';\n\t\t}\n\t\t//cout << T[i] << ' ' << uni[T[i]] << ' ' << v[i] << '\\n';\n\t\tadd(1 , 0 , un , T[i] , make_pair(uni[T[i]] , v[i]));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tsum += t * v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\n\t\tif (dq.empty() || dq.back().first <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(10) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nconst int BASE = (1 << 20);\n\nlong long N, L;\nlong long T[1 << 19], V[1 << 19];\n\nint cl, cr;\nlong double X[1 << 21], Y[1 << 21];\nlong double offset_x, offset_y;\n\nint main() {\n\tscanf(\"%lld%lld\", &N, &L);\n\tfor (int i = 1; i <= N; i++) scanf(\"%lld%lld\", &T[i], &V[i]);\n\n\tcl = BASE; cr = BASE;\n\tX[cr - 1] = 0; Y[cr - 1] = 0; cr++;\n\tX[cr - 1] = L; Y[cr - 1] = 0; cr++;\n\n\tfor (int i = 1; i <= N; i++) {\n\t\toffset_x += V[i];\n\t\toffset_y += T[i] * V[i];\n\n\t\twhile (true) {\n\t\t\tif (cr - cl >= 2 && X[cr - 2] + offset_x > 1.0L * L) { X[cr - 1] = 0; Y[cr - 1] = 0; cr--; }\n\t\t\telse if (X[cr - 1] + offset_x > L) {\n\t\t\t\tlong double E = Y[cr - 2] + 1.0L * (Y[cr - 1] - Y[cr - 2]) * ((L - offset_x) - X[cr - 2]) / (X[cr - 1] - X[cr - 2]);\n\t\t\t\tX[cr - 1] = L - offset_x;\n\t\t\t\tY[cr - 1] = E;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse break;\n\t\t}\n\n\t\twhile (cr - cl >= 2) {\n\t\t\tlong double a1 = (Y[cl] + offset_y) / (X[cl] + offset_x);\n\t\t\tlong double a2 = (Y[cl + 1] + offset_y) / (X[cl + 1] + offset_x);\n\t\t\tif (a1 <= a2) { X[cl] = 0; Y[cl] = 0; cl++; }\n\t\t\telse break;\n\t\t}\n\n\t\tcl--;\n\t\tX[cl] = -offset_x;\n\t\tY[cl] = -offset_y;\n\t\tprintf(\"%.12Lf\\n\", 1.0L * (Y[cr - 1] + offset_y) / L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,b,a) for(int i=b;i>=a;i--)\n#define efo(i,u,v) for(int i=BB[u],v=B[BB[u]][1];i;v=B[i=B[i][0]][1])\n#define mset(a,x) memset(a,x,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nchar ch;\nint read(){int n=0,p=1;for(ch=getchar();ch<'0' || '9'<ch;ch=getchar())if(ch=='-') p=-1;for(;'0'<=ch && ch<='9';ch=getchar()) n=n*10+ch-'0';return n*p;}\nconst int N=5e5+5;\nint n,L;\ndb q[N][2];\nint main()\n{\n\t//freopen(\"arc072f.in\",\"r\",stdin);\n\t//freopen(\"arc072f.out\",\"w\",stdout);\n\tn=read(),L=read();\n\tdb S=0,V=0;int l=1,r=0;\n\tfo(i,1,n)\n\t{\n\t\tint t=read(),v=read();\n\t\tfor(S+=(db)t*v,V+=v;V>L;)\n\t\t\tif(V-L>=q[l][0]) S-=q[l][0]*q[l][1],V-=q[l][0],++l;\n\t\t\telse S-=(V-L)*q[l][1],q[l][0]-=V-L,V=L;\n\t\tprintf(\"%.7lf\\n\",S/L);\n\t\tfor(q[++r][0]=v,q[r][1]=t;l<r && q[r-1][1]>q[r][1] && q[r][0]<L;r--)\n\t\t{\n\t\t\tint dt=min(q[r-1][0],L-q[r][0]);\n\t\t\tq[r-1][1]=(q[r-1][1]*dt+q[r][1]*q[r][0])/(dt+q[r][0]);\n\t\t\tq[r-1][0]=dt+q[r][0];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  double sum = 0;\n  vector<pair<double, double>> Q;\n  int head = 0;\n  // deque<pair<double, double>> Q;\n  for (int i = 0; i < n; ++i) {\n    double T, V;\n    scanf(\"%lf%lf\", &T, &V);\n    if (i > 0) {\n      double rem = V;\n      while (rem > 0) {\n        if (Q[head].first > rem) {\n          Q[head].first -= rem;\n          sum -= rem * Q[head].second;\n          break;\n        } else {\n          rem -= Q[head].first;\n          sum -= Q[head].first * Q[head].second;\n          ++head;\n        }\n      }\n    }\n    // trace(i);\n    // for (auto& it : Q) {\n    //   trace(it.first, it.second);\n    // }\n    while (head < Q.size() && Q.back().second > T) {\n      double V2 = Q.back().first, T2 = Q.back().second;\n      Q.pop_back();\n      sum -= V2 * T2;\n      T = (V2 * T2 + V * T) / (V2 + V);\n      V += V2;\n    }\n    Q.push_back({V, T});\n    sum += V * T;\n    printf(\"%.10f\\n\", sum / m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fo(i,x,y) for(int i=x;i<=y;i++)\n#define fd(i,x,y) for(int i=x;i>=y;i--)\nusing namespace std;\n\nconst int maxn=500007;\n\nint n,L;\nint SumV=0;\n\nint hd,tl;\nstruct Water{\n\tint V;\n\tdouble T;\n\tWater(){}\n\tWater(int _V,double _T):V(_V),T(_T){}\n\tvoid operator +=(const Water &b){\n\t\tT=(T*V+b.T*b.V)/(V+b.V);\n\t\tV+=b.V;\n\t}\n\tvoid operator -=(const Water &b){\n\t\tif (V-b.V==0){\n\t\t\tT=0;\n\t\t\tV=0;\n\t\t}else{\n\t\t\tT=(T*V-b.T*b.V)/(V-b.V);\n\t\t\tV-=b.V;\n\t\t}\n\t}\n\tvoid operator -=(const int &b){\n\t\tSumV-=b;\n\t}\n\tdouble operator()(){\n\t\treturn T/V;\n\t}\n}b[maxn],SumT;\n\nvoid Init(){\n\tscanf(\"%d%d\",&n,&L);\n}\n\nvoid Solve(){\n\thd=1,tl=0;\n\tfo(i,1,n){\n\t\tint T,V;\n\t\tscanf(\"%d%d\",&T,&V);\n\t\tb[++tl]=Water(V,T);\n\t\tSumV+=V;\n\t\tSumT+=b[tl];\n\t\twhile (SumV>L){\n\t\t\tint Temp=min(SumV-L,b[hd].V);\n\t\t\tSumT-=b[hd];\n\t\t\tb[hd].V-=Temp;\n\t\t\tSumV-=Temp;\n\t\t\tif (b[hd].V==0) hd++;\n\t\t\telse SumT+=b[hd];\n\t\t}\n\t\twhile (hd<tl && b[tl].T<=b[tl-1].T){\n\t\t\tSumT-=b[tl];\n\t\t\tSumT-=b[tl-1];\n\t\t\tb[tl-1]+=b[tl];\n\t\t\tSumT+=b[tl-1];\n\t\t\ttl--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",SumT.T);\n\t}\n}\n\nint main(){\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 5e5 + 100;\n\nint n, fnt, rar, L;\nlong long tagx, tagy, x[maxn];\ndouble y[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &L);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tif(v == L) {\n\t\t\tfnt = rar = 0;\n\t\t\ttagx = tagy = 0.;\n\t\t}\n\t\tif(fnt == rar) {\n\t\t\tprintf(\"%.12f\\n\", 1. * t);\n\t\t\tx[rar] = v;\n\t\t\ty[rar++] = 1. * v * t;\n\t\t\tx[rar] = 0;\n\t\t\ty[rar++] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile(x[fnt + 1] + tagx + v >= L) {\n\t\t\t++fnt;\n\t\t}\n\t\tdouble k = (y[fnt] - y[fnt + 1]) / (x[fnt] - x[fnt + 1]);\n\t\tx[fnt] = L - v - tagx;\n\t\ty[fnt] = k * (x[fnt] - x[fnt + 1]) + y[fnt + 1];\n\t\ttagy += v * t;\n\t\ttagx += v;\n\t\tprintf(\"%.12f\\n\", (y[fnt] + tagy) / (1. * L));\n\t\twhile(rar - 1 != fnt) {\n\t\t\tdouble k1 = (y[rar - 1] + tagy) / (1. * x[rar - 1] + tagx);\n\t\t\tdouble k2 = (y[rar - 2] + tagy) / (1. * x[rar - 2] + tagx);\n\t\t\tif(k1 <= k2) {\n\t\t\t\t--rar;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx[rar] = -tagx;\n\t\ty[rar++] = -tagy;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nconst int N = 500000 + 10;\n\nint n, m;\n\nstruct Point {\n  double x, y;\n  explicit Point(double _x = 0., double _y = 0.): x(_x), y(_y) {}\n};\n\ninline Point operator+ (const Point &lhs, const Point &rhs) {\n  return Point(lhs.x + rhs.x, lhs.y + rhs.y);\n}\n\ninline Point operator- (const Point &lhs, const Point &rhs) {\n  return Point(lhs.x - rhs.x, lhs.y - rhs.y);\n}\n\nstd::deque<Point> q;\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  Point sum(0, 0);\n  for (int i = n; i--;) {\n    int t, v;\n    scanf(\"%d%d\", &t, &v);\n    Point p(v, (double)t * v);\n    sum = sum + p;\n    while (!q.empty()) {\n      if (sum.x <= m) break;\n      Point cur = q.back();\n      q.pop_back();\n      sum = sum - cur;\n      if (sum.x - cur.x >= m) continue;\n      Point temp(m - sum.x, cur.y / cur.x * (m - sum.x));\n      q.push_back(temp);\n      sum = sum + temp;\n      break;\n    }\n    for (; !q.empty() && q.front().y / q.front().x >= p.y / p.x; q.pop_front()) p = p + q.front();\n    q.push_front(p);\n    printf(\"%.12f\\n\", sum.y / sum.x);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,long double> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n, l;\n\tcin>>n>>l;\n\tdeque<P> q;\n\tlong double s = 0.0;\n\tcout.precision(20);\n\trep(i, n){\n\t\tlong double t;\n\t\tll v;\n\t\tcin>>t>>v;\n\t\tif(i){\n\t\t\tll e = v;\n\t\t\twhile(e>0){\n\t\t\t\tP p = q.front(); q.pop_front();\n\t\t\t\tll d = min(e, p.fst);\n\t\t\t\te -= d;\n\t\t\t\ts -= d*p.snd;\n\t\t\t\tif(p.fst-d>0) q.push_front(P(p.fst-d, p.snd));\n\t\t\t}\n\t\t}\n\t\ts += v*t;\n\t\twhile(!q.empty() && q.back().snd>t){\n\t\t\tP p = q.back();\n\t\t\t//cerr<<i<<\" \"<<p.fst<<\" \"<<p.snd<<\" \"<<v<<\" \"<<t<<endl;\n\t\t\tll v2 = v+p.fst;\n\t\t\tlong double t2 = (v*t+p.fst*p.snd)/v2;\n\t\t\tv = v2;\n\t\t\tt = t2;\n\t\t\tq.pop_back();\n\t\t} \n\t\tq.push_back(P(v, t));\n\t\tcout<<s/l<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-6;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,1,1,1,0},DY[8]={1,0,-1,-1,-1,0,1,1};\n\nint n;\ndouble l;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcout<<syosu(9);\n\tcin>>n>>l;\n\tdeque<pdd> deq;\n\tdouble sx=0,sy=0,t,v;\n\tcin>>t>>v;\n\tdeq.push_back({0,0});\n\tcout<<t<<endl;\n\tsx+=v;\n\tsy+=t*v;\n\tdeq.push_front({-sx,-sy});\n\tfor(int i=1;i<n;i++){\n\t\tcin>>t>>v;\n\t\tsx+=v;\n\t\tsy+=t*v;\n\t\tpdd p;\n\t\tdouble L=l-sx;\n\t\twhile(deq.back().first-eps>L){\n\t\t\tp=deq.back();\n\t\t\tdeq.pop_back();\n\t\t}\n\t\tpdd tmp=deq.back();\n\t\tdouble lx=tmp.first,ly=tmp.second,rx=p.first,ry=p.second;\n\t\tdeq.push_back({L,(ry-ly)*(L-lx)/(rx-lx)+ly});\n\t\tcout<<(deq.back().second+sy)/l<<endl;\n\t\twhile(deq.size()>1){\n\t\t\ttmp=deq.front();\n\t\t\tdeq.pop_front();\n\t\t\tp=deq.front();\n\t\t\tlx=tmp.first,ly=tmp.second,rx=p.first,ry=p.second;\n\t\t\tif((ly+sy)/(lx+sx)>(ry+sy)/(rx+sx)-eps){\n\t\t\t\tdeq.push_front(tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdeq.push_front({-sx,-sy});\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\ntypedef long long ll;\ntypedef double db;\n\nstruct wat\n{\n    db t; int v;\n    wat(): t(0), v(0){}\n    wat(db a, int b): t(a), v(b){}\n    in_ wat op_+ (wat a)\n    {re_ v+a.v? wat((t*v+a.t*a.v)/(v+a.v), v+a.v): wat();}\n    in_ wat& op_+= (wat a)\n    {re_ *this=*this+a;}\n    in_ wat op_- (wat a)\n    {re_ v^a.v? wat((t*v-a.t*a.v)/(v-a.v), v-a.v): wat();}\n    in_ wat& op_-= (wat a)\n    {re_ *this=*this-a;}\n    in_ void wr(char* a)\n    {printf(\"(%.6lf, %d)%s\", t, v, a);}\n};\n\nconst int mxn=1<<19;\n\nint n, v0; wat q[mxn];\n\nint main()\n{\n    int s, t; wat a, b;\n//    a.wr(\"\\n\");\n    scanf(\"%d%d\", &n, &v0);\n    for(s=t=0; n--;)\n    {\n        scanf(\"%lf%d\", &a.t, &a.v);\n        for(b+=a; b.v>v0;)\n            if(q[s].v<=b.v-v0) b-=q[s];\n            else q[s].v-=b.v-v0, b-=wat(q[s].t, b.v-v0);\n        printf(\"%lf\\n\", b.t);\n        for(;s<t && q[t-1].t>=a.t; a+=q[--t]);\n        q[t++]=a;\n    }\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#define int         int64_t\n#define ii          pair<int,int>\n#define dd          pair<double,double>\n#define vi          vector<int>\n#define pb          push_back\n#define all(x)      (x).begin(), (x).end()\n#define checkBit(v, p)      (v&(1LL << p))\n#define loop(i,a,b) for(int i = a;i < int(b);i++)\n#define x           first\n#define y           second\nusing namespace std;\nint inf = 2e9, mod = 1e9 + 7;\n\nstruct Pnt{int v; double t;}q[1000000];\n\nvoid merge(Pnt &a, Pnt b){\n    a.t = (a.t * a.v + b.t * b.v) / (a.v + b.v);\n    a.v += b.v;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false); cout << fixed <<setprecision(10);\n    int n, L; cin >> n >> L;\n    int volume = 0; double temp = 0;\n    for(int i=0,l=n,r=n-1,t,v;i<n;i++){\n        cin >> t >> v;\n        while(volume + v > L){\n            int dec = min(q[r].v, volume + v - L);\n            volume -= dec;\n            temp -= dec * q[r].t;\n            q[r].v -= dec;\n            if(q[r].v == 0) r--;\n        }\n        volume += v;\n        temp += v * t;\n        cout << temp / L << '\\n';\n        q[--l].v = v, q[l].t = t;\n        for(; l < r && q[l].t < q[l+1].t; l++) merge(q[l+1], q[l]);\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<double, double> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nll n;\ndouble l;\ndouble t[500010],v[500010];\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>n>>l;\n  rep(i,n)cin>>t[i]>>v[i];\n\n  deque<P> deq;\n  deq.push_back(P(t[0],v[0]));\n  printf(\"%.10f\\n\", t[0]);\n  double crtsum=t[0]*v[0],crtv=v[0];\n  repl(i,1,n){\n    deq.push_back(P(t[i],v[i]));\n    crtsum+=t[i]*v[i]; crtv+=v[i];\n    while(crtv>l){\n      double rmv=crtv-l;\n      if(deq.front().se<rmv){\n        crtsum-=deq.front().fi*deq.front().se;\n        crtv-=deq.front().se;\n        deq.pop_front();\n      }else{\n        crtsum-=deq.front().fi*rmv;\n        deq.front().se-=rmv;\n        crtv=l;\n      }\n    }\n    while(deq.size()>=2&&deq[deq.size()-2].fi>deq[deq.size()-1].fi){\n      P p1=deq.back(); deq.pop_back();\n      P p2=deq.back(); deq.pop_back();\n      deq.push_back(P((p1.fi*p1.se+p2.fi*p2.se)/(p1.se+p2.se),p1.se+p2.se));\n    }\n    printf(\"%.10f\\n\", crtsum/l);\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing uint = unsigned int;\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rep1(i,n) for(int i=1;i<=int(n);i++)\n#define per(i,n) for(int i=int(n)-1;i>=0;i--)\n#define per1(i,n) for(int i=int(n);i>0;i--)\n#define all(c) c.begin(),c.end()\n#define si(x) int(x.size())\n#define pb emplace_back\n#define fs first\n#define sc second\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\ntemplate<class T,class U> void chmax(T& x, U y){if(x<y) x=y;}\ntemplate<class T,class U> void chmin(T& x, U y){if(y<x) x=y;}\ntemplate<class T> void mkuni(V<T>& v){sort(all(v));v.erase(unique(all(v)),v.end());}\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\nvoid dmpr(ostream& os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" ~ \";\n\tdmpr(os,args...);\n}\n#define shows(...) cerr << \"LINE\" << __LINE__ << \" : \";dmpr(cerr,##__VA_ARGS__)\n#define dump(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = {\";  \\\n\tfor(auto v: x) cerr << v << \",\"; cerr << \"}\" << endl;\n#else\n#define show(x) void(0)\n#define dump(x) void(0)\n#define shows(...) void(0)\n#endif\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\n\tint N;ll X; cin >> N >> X;\n\tusing P = pair<ll,double>;\n\tdeque<P> xfs;\n\tdouble S = 0;\n\trep(ph,N){\n\t\tll t,v; cin >> t >> v;\n\t\tll dec = (ph?v:0);\n\t\twhile(dec){\n\t\t\tauto& p = xfs.back();\n\t\t\tif(dec < p.fs){\n\t\t\t\tp.fs -= dec; S -= dec*p.sc;\n\t\t\t\tdec = 0;\n\t\t\t}else{\n\t\t\t\txfs.pop_back(); S -= p.fs*p.sc;\n\t\t\t\tdec -= p.fs;\n\t\t\t}\n\t\t}\n\t\txfs.push_front(P(v,t)); S += v*t;\n\t\twhile(si(xfs) >= 2 && xfs[0].sc < xfs[1].sc){\n\t\t\tauto a = xfs[0], b = xfs[1];\n\t\t\tdouble nt = (a.fs*a.sc+b.fs*b.sc)/(a.fs+b.fs);\n\t\t\trep(_,2) xfs.pop_front();\n\t\t\txfs.push_front(P(a.fs+b.fs,nt));\n\t\t}\n\t\tcout << S/X << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nint l,r;\ninline void merge(Vector &a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) merge(q[r-1],q[r--]);\n        printf(\"%lf\\n\",(db)y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef std::pair <double, int> pr;\n\npr que[500054];\n\ninline int min(const int x, const int y) {return x < y ? x : y;}\n\nint main() {\n\tint w, v, h = 0, t = 0, q, Vol, V = 0, delta; double W = 0.;\n\tfor (scanf(\"%d%d\", &q, &Vol); q; --q) {\n\t\tscanf(\"%d%d\", &w, &v);\n\t\tfor (; V + v > Vol; )\n\t\t\tdelta = min(V + v - Vol, que[h].second),\n\t\t\tV -= delta, que[h].second -= delta,\n\t\t\tW -= que[h].first * delta, h += !que[h].second;\n\t\tprintf(\"%.12lg\\n\", (W += (double)w * v) / Vol), V += v, que[t++] = pr(w, v);\n\t\tfor (; h + 1 < t && que[t - 2].first >= que[t - 1].first; --t)\n\t\t\tque[t - 2].second += que[t - 1].second,\n\t\t\tque[t - 2].first -= (que[t - 2].first - que[t - 1].first) * que[t - 1].second / que[t - 2].second;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long double db;\nint N,L;\n\nint T[500005],V[500005];\ndb SM[500005],vv[500005],tt[500005];\ndb smv[500005];\nint ql,qr;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline int R()\n{\n\tchar t=GC;\n\tint x=0;\n\twhile(!isdigit(t)) t=GC;\n\twhile(isdigit(t)) x=x*10+t-48,t=GC;\n\treturn x;\n}\nint main() {\n\tN = R(); L = R();\n\tfor(int i=1;i<=N;i++) {\n\t\tT[i] = R(); V[i] = R();\n\t}\n\tprintf(\"%d\\n\",T[1]);\n\tql = qr = 1;\n\tvv[1] = V[1];\n\ttt[1] = T[1];\n\tsmv[1] = V[1];\n\tSM[1] = vv[1] * tt[1];\n\tfor(int i=2;i<=N;i++) {\n\t\tif(T[i]<=tt[qr]) {\n\t\t\tdb maxv = min(1.0l*L-1.0l*V[i],1.0l*vv[qr]);\n\t\t\tdb nt = (tt[qr]*maxv + 1.0*V[i]*T[i]) / (maxv+V[i]);\n\t\t\tvv[qr] = V[i] + maxv;\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\ttt[qr] = nt;\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t} else {\n\t\t\t++qr;\n\t\t\tvv[qr] = V[i];\n\t\t\ttt[qr]  = T[i];\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t}\n\t\twhile(ql<qr&&smv[qr]-smv[ql]>L) ql++;\n\t\tdb ans = SM[qr] - SM[ql] + 1.0l*(L-smv[qr]+smv[ql])*tt[ql];\n\t\tprintf(\"%.8Lf\\n\",1.0l*ans/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define myp pair<ll,ll>\nusing namespace std;\nconst int N=5e5+10;\nint n,l;\nmyp q[N]; //pair<v,v*t> 比较时不会产生精度误差 \nint head,tail;\nint main(){\n\tll v,t,temp_v=0,temp=0;\n\tdb now_t;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\tq[head++]=make_pair(v,v*t);\n\t\ttemp_v+=v,temp+=v*t;\n\t\twhile(temp_v>l){\n\t\t\tif(temp_v-q[tail].first>=l) temp_v-=q[tail].first,temp-=q[tail].second,tail++;\n\t\t\telse now_t=db(q[tail].second)/q[tail].first,q[tail].first-=temp_v-l,temp_v=l,temp=(temp-q[tail].second+now_t*q[tail].first+0.5),q[tail].second=(now_t*q[tail].first+0.5);\n\t\t}\n\t\tif(head-2>=tail&&db(q[head-1].second)/q[head-1].first<db(q[head-2].second)/q[head-2].first) q[head-2].first+=q[head-1].first,q[head-2].second+=q[head-1].second,head--;\n\t\tprintf(\"%.10lf\\n\",db(temp)/temp_v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\n#define MOD 1000000007LL\n#define EPS 1e-10\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double,ll> P;\n\nint n;\nll l;\nll t[500001],v[500001];\n\nint main(void){\n\tscanf(\"%d%lld\",&n,&l);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%lld%lld\",&t[i],&v[i]);\n\t}\n\tdouble res=0.0;\n\tdeque<P> que;\n\tfor(int i=0;i<n;i++){\n\t\tif(i>0){\n\t\t\tll rest=v[i];\n\t\t\twhile(rest>0){\n\t\t\t\tP q=que.front();\n\t\t\t\tif(q.second>rest){\n\t\t\t\t\tq.second-=rest;\n\t\t\t\t\tque.pop_front();\n\t\t\t\t\tque.push_front(q);\n\t\t\t\t\tres-=(double)q.first*rest;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\trest-=q.second;\n\t\t\t\t\tres-=(double)q.first*q.second;\n\t\t\t\t\tque.pop_front();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres+=(double)t[i]*v[i];\n\t\tP p=P((double)t[i],v[i]);\n\t\twhile(que.size()){\n\t\t\tP q=que.back();\n\t\t\tif(q.first+EPS>p.first){\n\t\t\t\tP r=P((q.first*(double)q.second+p.first*(double)p.second)/(double)(p.second+q.second),p.second+q.second);\n\t\t\t\tp=r;\n\t\t\t\tque.pop_back();\n\t\t\t}else break;\n\t\t}\n\t\tque.push_back(p);\n\t\tprintf(\"%.10f\\n\",res/(double)l);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, double> pairID;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nint N, L;\ndeque<pairID> A;\n\nint main(int argc, char *argv[])\n{\n    int t, v;\n    double total_heat;\n\n    scanf(\"%d%d\", &N, &L);\n    scanf(\"%d%d\", &t, &v);\n    \n    A.push_front(make_pair(v, t));\n    total_heat = (double)v * t;\n    printf(\"%.7f\\n\", total_heat / L);\n    \n    FOR1(i,1,N) {\n        pairID back;\n        int vol;\n\n        scanf(\"%d%d\", &t, &v);\n        total_heat += (double)v * t;\n        \n        vol = v;\n        while (vol >= 0) {\n            back = A.back();\n            A.pop_back();\n            vol -= back.first;\n            total_heat -= back.first * back.second;\n        }\n        A.push_back(make_pair(-vol, back.second));\n        total_heat += -vol * back.second;\n\n        double heat = v * t;\n        vol = v;\n        pairID front;\n        while(true) {\n            front = A.front();\n            if (heat / vol > front.second) {\n                A.push_front(make_pair(vol, heat / vol));\n                break;\n            }\n            heat += front.first * front.second;\n            vol += front.first;\n            A.pop_front();\n        }\n\n        printf(\"%.7f\\n\", total_heat / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long \nusing namespace std;\ndeque<pair<ll,long double> > dq;\nlong double total,eps = 1e-10;\n\nint main() {\n\tll n,L,t,v;\n\tcin >> n >> L;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t >> v;\n\t\tll x  = v;\n\t\twhile (x && !dq.empty()) {\n\t\t\t int a = dq.front().first;\n\t\t\t if (a <= x) {\n\t\t\t \tx -= a;\n\t\t\t \ttotal -= dq.front().second*a;\n\t\t\t \tdq.pop_front();\n\t\t\t }\n\t\t\t else {\n\t\t\t \tdq[0].first -= x;\n\t\t\t \ttotal -= dq.front().second*x;\n\t\t\t \tbreak;\n\t\t\t }\n\t\t}\n\t\tlong double cur = t;\n\t\ttotal +=cur*v; \n\t\twhile (!dq.empty() && dq.back().second +eps> cur)  {\n\t\t\tcur = (long double)((double)dq.back().second*(double)dq.back().first + (double)cur*v)/(long double)(v + dq.back().first);\n\t\t\tv += dq.back().first;\n\t\t\t dq.pop_back();\n\t\t}\n\t\tdq.push_back({v,cur});\n\tcout << fixed<<setprecision(10) <<total/(double)L <<'\\n';     //  cout << dq.size() <<'\\n';\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef double db;\nint N,L;\n\nint T[500005],V[500005];\ndb SM[500005],vv[500005],tt[500005];\ndb smv[500005];\nint ql,qr;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline int R()\n{\n\tchar t=GC;\n\tint x=0;\n\twhile(!isdigit(t)) t=GC;\n\twhile(isdigit(t)) x=x*10+t-48,t=GC;\n\treturn x;\n}\nint main() {\n\tN = R(); L = R();\n\tfor(int i=1;i<=N;i++) {\n\t\tT[i] = R(); V[i] = R();\n\t}\n\tprintf(\"%d\\n\",T[1]);\n\tql = qr = 1;\n\tvv[1] = V[1];\n\ttt[1] = T[1];\n\tsmv[1] = V[1];\n\tSM[1] = vv[1] * tt[1];\n\tfor(int i=2;i<=N;i++) {\n\t\tif(T[i]<=tt[qr]) {\n\t\t\tdb maxv = min(1.0*L-1.0*V[i],1.0*vv[qr]);\n\t\t\tdb nt = (tt[qr]*maxv + 1.0*V[i]*T[i]) / (maxv+V[i]);\n\t\t\tvv[qr] = V[i] + maxv;\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\ttt[qr] = nt;\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t} else {\n\t\t\t++qr;\n\t\t\tvv[qr] = V[i];\n\t\t\ttt[qr]  = T[i];\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t}\n\t\twhile(ql<qr&&smv[qr]-smv[ql]>L) ql++;\n\t\tdb ans = SM[qr] - SM[ql] + 1.0*(L-smv[qr]+smv[ql])*tt[ql];\n\t\tprintf(\"%.8f\\n\",1.0*ans/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  LL n, l;\n  deque<pair<int, double>> cal;\n  vector<LL> t, v;\n  Solver(LL n) : n(n), t(n), v(n){};\n  double temperature(int a, int b) {\n    return (cal[b].second - cal[a].second) / (double)(cal[b].first - cal[a].first);\n  }\n  void solve() {\n    cin >> l;\n    for (int i = 0; i < n; ++i) {\n      cin >> t[i] >> v[i];\n    }\n    cal.emplace_back(0, 0);\n    for (int i = 0; i < n; ++i) {\n      // increse\n      cal.emplace_front(cal[0].first - v[i], cal[0].second - t[i] * v[i]);\n      //answer\n      DBG(cal)\n      cout << temperature(0, cal.size() - 1) << endl;\n      //mix\n      if (cal.size() >= 3 && temperature(0, 1) < temperature(1, 2)) {\n        cal.erase(cal.begin() + 1);\n      }\n      if (i == n - 1) break;\n      while (1) {\n        auto tmp = cal.back();\n        cal.pop_back();\n        int upperBound = l - v[i + 1];\n        if (cal.back().first < cal[0].first + upperBound) {\n          cal.emplace_back(cal[0].first + upperBound, cal.back().second + (tmp.second - cal.back().second) / (tmp.first - cal.back().first) * (cal[0].first + upperBound - cal.back().first));\n          break;\n        }\n      }\n      DBG(cal)\n    }\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  std::cout << std::fixed << std::setprecision(12);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 500002;\nint n, L;\nset<ii> storage;\n\n\nint main(){\n\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &L);\n    ll tot1 = 0, tot2 = 0;\n    set<ii>::iterator it;\n// n=2;\n    for(int i=1;i<=n;i++){\n        ll temp, vol;\n        scanf(\"%lld%lld\", &temp, &vol);\n        while(tot2+vol > L){\n\n            it = storage.begin();\n            ll z = min(tot2+vol-L, (*it).ss);\n            \n            tot2 -= z;\n            ll newtemp = (*it).ff, newvol = (*it).ss - z;\n            tot1 -= newtemp*z;\n            storage.erase(it);\n            if(newvol > 0)\n                storage.insert(ii(newtemp, newvol));\n        }\n\n// cout<<\"middle of i = \"<<i<<\", storage: \";for(auto it : storage) cout<<it.ff<<\":\"<<it.ss<<\" \";cout<<\" and tot1 = \"<<tot1<<\" tot2 = \"<<tot2<<endl;\n\n\n        it = storage.lower_bound(ii(temp, 0));\n        if(it != storage.end() && (*it).ff == temp){\n            vol += (*it).ss;\n            tot1 -= (*it).ff * 1LL * (*it).ss;\n            tot2 -= (*it).ss;\n            storage.erase(it);\n        }\n        storage.insert(ii(temp, vol));\n        tot1 += temp * 1LL * vol;\n        tot2 += vol;\n\n        double ans = (1.0*tot1) / tot2;\n        printf(\"%.7lf\\n\", ans);\n// cout<<\"after i = \"<<i<<\", storage: \";for(auto it : storage) cout<<it.ff<<\":\"<<it.ss<<\" \";cout<<\" and tot1 = \"<<tot1<<\" tot2 = \"<<tot2<<endl;\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+5;\ntypedef pair<double,long long>P;\nlong long n,L,tot,l=1,r,v[N],t[N];\n#define se second\n#define fi first\ndouble ans;\nP q[N];\nint main(){\n\tscanf(\"%lld%lld\",&n,&L);\n\tfor(int i=1;i<=n;i++)\tscanf(\"%lld%lld\",&t[i],&v[i]);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(l<=r&&tot+v[i]>L){\n\t\t\tlong long k=min(tot+v[i]-L,q[l].se);\n\t\t\tans-=q[l].fi*k,tot-=k,q[l].se-=k;\n\t\t\tif(!q[l].se)\t++l;\n\t\t}\n\t\tq[++r]=P(t[i],v[i]);\n\t\ttot+=v[i],ans+=t[i]*v[i];\n\t\twhile(l<r&&q[r].fi<q[r-1].fi){\n\t\t\tq[r-1].fi=(q[r-1].fi*q[r-1].se+q[r].fi*q[r].se)/(q[r-1].se+q[r].se);\n\t\t\tq[r-1].se+=q[r].se;\n\t\t\t--r;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",ans/L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tld x,y;\n\tbool operator <(const point b)const{\n\t\treturn y<b.y;\n\t}\n}q[500005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){(ld)y,(ld)x};\n\t\tallt+=v.x*v.y; allv+=y;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].x*q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tq[head].x-=allv-l;\n\t\t\tallt-=(allv-l)*q[head].y;\n\t\t\tallv=l;\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.6lf\\n\",(double)allt/allv);\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y=(v.y*v.x+q[tail].x*q[tail].y)/(v.x+q[tail].x);\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define x first\n#define y second\n\ntypedef long double LD;\ntypedef std::pair<int, LD> pair;\nconst int N = 500005;\n\nint n, L, h, t;\npair q[N]; LD sum;\n\nvoid operator += (pair &a, pair b) { a.y = (a.x * a.y + b.x * b.y) / (a.x + b.x), a.x += b.x; }\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n >> L, h = 1;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint x, y, v = i ? L : 0; std::cin >> y >> x;\n\t\twhile (v + x > L) {\n\t\t\tint d = std::min(q[h].x, v + x - L);\n\t\t\tq[h].x -= d, sum -= d * q[h].y, v -= d;\n\t\t\tif (!q[h].x) ++h;\n\t\t}\n\t\tsum += (LD) x * y, q[++t] = pair(x, y);\n\t\tstd::cout << std::fixed << std::setprecision(8) << sum / L << '\\n';\n\t\twhile (h < t && q[t].y <= q[t - 1].y) q[t - 1] += q[t], --t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp> // Including tree_order_statistics_node_update\n#define int         int64_t\n#define ii          pair<int,int>\n#define dd          pair<double,double>\n#define vi          vector<int>\n#define pb          push_back\n#define all(x)      (x).begin(), (x).end()\n#define checkBit(v, p)      (v&(1LL << p))\n#define loop(i,a,b) for(int i = a;i < int(b);i++)\n#define x           first\n#define y           second\nusing namespace std;\nint inf = 2e9, mod = 1e9 + 7;\n\nstruct Pnt{int v; int t;}q[1000000];\n\nvoid merge(Pnt &a, Pnt b){\n    a.t = (a.t * a.v + b.t * b.v) / (a.v + b.v);\n    a.v += b.v;\n}\n\nint32_t main()\n{\n    ios_base::sync_with_stdio(false); cout << fixed <<setprecision(6);\n    int n, L; cin >> n >> L;\n    int volume = 0; int temp = 0;\n    for(int i=0,l=n,r=n-1,t,v;i<n;i++){\n        cin >> t >> v;\n        while(volume + v > L){\n            int dec = min(q[r].v, volume + v - L);\n            volume -= dec;\n            temp -= dec * q[r].t;\n            q[r].v -= dec;\n            if(q[r].v == 0) r--;\n        }\n        volume += v;\n        temp += v * t;\n        cout << temp / (double)L << '\\n';\n        q[--l].v = v, q[l].t = t;\n        for(; l < r && q[l].t < q[l+1].t; l++) merge(q[l+1], q[l]);\n    }\n    cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\ntypedef struct{\n\tdouble a;\n\tdouble b;\n\tint l,r;\n}eda;\n\neda node(double a,double b,int l,int r){\n\teda v;\n\tv.a=a;\n\tv.b=b;\n\tv.l=l;\n\tv.r=r;\n\treturn v;\n}\n\ndeque<eda> de;\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tint l;\n \tcin>>n>>l;\n \t\n \tdouble te;\n \tint y;\n \tcin>>te>>y;\n //\tcout<<te<<endl;\n \tprintf(\"%.10lf\\n\",te);\n \t\tde.pb(node(te,0,l,0));\n \tint hos=0;\n \tdouble cd=0;\n \tdouble ad=0;\n \tfor(int i=1;i<n;i++){\n \t\tcin>>te;\n \t\tint vo;\n \t\tcin>>vo;\n \t\thos+=vo;\n \t\twhile(de.size()>0&&de.front().r+hos>l)de.pop_front();\n \t\tassert(de.size()>0);\n \t\tde.front().l=l-hos;\n \t\tcd+=(double)te*vo;\n \t\tad+=(double) vo;\n \t\tif(de.back().b+cd-de.back().a*ad>=0){\n \t\t\tint b=-cd+te*ad;\n \t\t\tde.pb(node(te,b,de.back().r,de.back().r-vo));\n \t\t}\n \t\telse{\n \t\t\tint k2=de.back().r-vo;\n \t\t\tint laspos;\n \t\t\tdouble val;\n \t\t\twhile(de.size()>0&&de.back().b+cd-de.back().a*ad<0){\n \t\t\t\tlaspos=de.back().l;\n \t\t\t\tval=(de.back().a*((double)laspos+hos)+de.back().b+cd-ad*de.front().a)/((double) (laspos+hos));\n \t\t\t\tde.pop_back();\n \t\t\t}\n \t\t\tde.pb(node(val,-cd+val*ad,laspos,k2));\n \t\t}\n \t//\tcout<<endl;\n \t//\tfor(auto it=de.begin();it!=de.end();it++){\n \t//\t\teda w=*it;\n \t//\t\tcout<<w.l+hos<<\" \"<<w.r+hos<<\" \"<<w.a<<\" \"<<w.b+cd-ad*w.a<<endl;\n \t//\t}\n \t//\tcout<<endl;\n \t\tdouble ans;\n \t\tans=(de.front().a*(l)+(de.front().b+cd-ad*de.front().a))/((double) (l));\n \t\tprintf(\"%.10lf\\n\",ans);\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<double, int64_t> P;\n\nint main(){\n    int N, L;\n    cin >> N >> L;\n\n    deque<P> que;\n    double heat = 0;\n    int volume = 0;\n\n    cout << fixed << setprecision(10);\n\n    for(int i=0; i<N; i++){\n        double t;\n        int v;\n        cin >> t >> v;\n        heat += t*v;\n        volume += v;\n\n        while(volume > L){\n            auto p = que.front();\n            if(p.second <= volume-L){\n                heat -= p.first * p.second;\n                volume -= p.second;\n                que.pop_front();\n            }else{\n                heat -= p.first * (volume-L);\n                que.front().second -= volume-L;\n                volume = L;\n            }\n        }\n\n        while(que.size() > 0){\n            auto p = que.back();\n            if(p.first < t){\n                break;\n            }else{\n                t = (p.first*p.second + t*v) / (p.second + v);\n                v += p.second;\n                que.pop_back();\n            }\n        }\n        \n        que.push_back({t, v});\n        double ans = heat / L;\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define re_ return\n#define in_ inline\n#define op_ operator\n#define inc(l, i, r) for(i=l; i<r; ++i)\ntypedef long long ll;\ntypedef double db;\n\nstruct wat\n{\n    db t; int v;\n    wat(): t(0), v(0){}\n    wat(db a, int b): t(a), v(b){}\n    in_ wat op_+ (wat a)\n    {re_ v+a.v? wat((t*v+a.t*a.v)/(v+a.v), v+a.v): wat();}\n    in_ wat& op_+= (wat a)\n    {re_ *this=*this+a;}\n    in_ wat op_- (wat a)\n    {re_ v^a.v? wat((t*v-a.t*a.v)/(v-a.v), v-a.v): wat();}\n    in_ wat& op_-= (wat a)\n    {re_ *this=*this-a;}\n    in_ void wr(char* a)\n    {printf(\"(%.6lf, %d)%s\", t, v, a);}\n};\n\nconst int mxn=1<<19;\n\nint n, v0; wat q[mxn];\n\nint main()\n{\n    int s, t; wat a, b;\n//    a.wr(\"\\n\");\n    scanf(\"%d%d\", &n, &v0);\n    for(s=t=0; n--;)\n    {\n        scanf(\"%lf%d\", &a.t, &a.v);\n        for(b+=a; b.v>v0;)\n            if(q[s].v<=b.v-v0) b-=q[s++];\n            else q[s].v-=b.v-v0, b-=wat(q[s].t, b.v-v0);\n        printf(\"%lf\\n\", b.t);\n        for(;s<t && q[t-1].t>=a.t; a+=q[--t]);\n        q[t++]=a;\n    }\n    re_ 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <deque> \nusing namespace std;\n\nint main()\n{\n    // 整数の入力\n    long long  N,V,L,i,j;\n    double T;\n    cin >> N >> L;\n    deque<int> VList;\n    deque<double> TList;\n\n    cin >> T >> V;\n    TList.push_front(T);\n    VList.push_front(V);\n    cout << fixed << T << endl;\n    for (i=1;i<N;i++){\n        cin >> T >> V;\n        int tempV = V;\n        while (tempV> 0){\n            if (tempV > VList.back()){\n                tempV = tempV- VList.back();\n                VList.pop_back();\n                TList.pop_back();\n            }else{\n                VList.back() = VList.back() - tempV;\n                tempV = 0;\n            }\n        }\n\n        if (VList.size() == 0){\n            TList.push_front(T);\n            VList.push_front(V);\n        }else{\n            while (T <= TList[0]){\n                T = (T*V+TList[0]*VList[0])/(V+VList[0]);\n                V = V+VList[0];\n                TList.pop_front();\n                VList.pop_front();\n            }\n            TList.push_front(T);\n            VList.push_front(V);\n        }\n\n        double sumQ = 0;\n        for (j = 0;j< VList.size();j++){\n            sumQ += TList[j] * VList[j];\n        }\n        cout << fixed << sumQ/L << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<ll,db> P;\nconst int MAXN=5e5+10;\ndb res=0;ll all;\nint n,L,l=0,r=-1,top;P q[MAXN];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&L);\n    for(int i=1;i<=n;i++)\n    {\n        db t;ll v;scanf(\"%lf%lld\",&t,&v);\n        while(all+v>L)\n        {//按温度从小到大放水\n            ll d=min(q[l].X,all+v-L);\n            q[l].X-=d;all-=d;res-=d*q[l].Y;\n            if(!q[l].X) l++;\n        }\n        all+=v;res+=v*t;\n        \n        while(l<=r&&t<q[r].Y)\n        {//\n            t=(v*t+q[r].X*q[r].Y)/(v+q[r].X);\n            v+=q[r].X;r--;\n        }\n        q[++r]=P(v,t);\n        printf(\"%.6lf\\n\",res/L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    int n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n        double tempt =t;\n        if(i>1){\n            \n            \n            while(tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1.0*d1.front().second;\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=(long double)1.0*d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=tempv;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totv+=v;\n       totprod+=(long double)1.0*v*t;\n       printf(\"%.12lf\\n\",1.0*totprod/totv);\n       // cout<<setprecision(20)<<totprod/L<<endl;\n       \n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=(long double)1.0*v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>t){\n                totprod-=(long double)1.0*d1.back().first*d1.back().second;\n                double tempp = (long double)1.0*tempv*tempt;\n                tempp+=(long double)1.0*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1.0*tempp)/((long double)1.0*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1.0*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  LL n, l;\n  deque<pair<int, double>> cal;\n  vector<LL> t, v;\n  Solver(LL n) : n(n), t(n), v(n){};\n  double temperature(int a, int b) {\n    return (cal[b].second - cal[a].second) / (double)(cal[b].first - cal[a].first);\n  }\n  void solve() {\n    cin >> l;\n    for (int i = 0; i < n; ++i) {\n      cin >> t[i] >> v[i];\n    }\n    cal.emplace_back(0, 0);\n    for (int i = 0; i < n; ++i) {\n      // increse\n      cal.emplace_front(cal[0].first - v[i], cal[0].second - t[i] * v[i]);\n      //answer\n      DBG(cal)\n      printf(\"%.9lf\\n\", temperature(0, cal.size() - 1));\n      //mix\n      while (cal.size() >= 3 && temperature(0, 1) < temperature(1, 2) - 1e-10) {\n        cal.erase(cal.begin() + 1);\n      }\n      if (i == n - 1) break;\n      //decrease\n      int upperBound = l - v[i + 1];\n      while (1) {\n        auto tmp = cal[cal.size() - 1];\n        cal.pop_back();\n        if (cal.back().first < cal[0].first + upperBound) {\n          cal.emplace_back(cal[0].first + upperBound, cal.back().second + (tmp.second - cal.back().second) / (tmp.first - cal.back().first) * (cal[0].first + upperBound - cal.back().first));\n          break;\n        } else if (cal.back().first == cal[0].first + upperBound) {\n          break;\n        }\n      }\n      DBG(cal)\n    }\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  //std::cin.tie(0);\n  //std::ios_base::sync_with_stdio(false);\n  std::cout << std::fixed << std::setprecision(9);\n  long long n = 0;\n  scanf(\"%lld\", &n);\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nll l,r;\ninline void merge(Vector &a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(ll i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) merge(q[r-1],q[r--]);\n        printf(\"%lf\\n\",(db)y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n#define ll long long\n#define db double\nconst int N=1e6;\n\n#define C getchar()-48\nll read()\n{\n  ll s=0,t=1,k=C;\n  for (;k<0||9<k;k=C) if (k==-3) t=-1;\n  for (;0<=k&&k<=9;k=C) s=(s<<1)+(s<<3)+k;\n  return s*t;\n}\n\n//如题意 \n  ll n,L;\n\tll t[N],v[N];\nvoid in()\n{\n  cin>>n>>L;\n  for (int i=0;++i<=n;)\n\t  t[i]=read(),v[i]=read();\n}\n\n//单调队列 \n  ll l=1,r; \n  struct rec\n    {\n      ll v;\n      db t;\n    }s[N];\n\n//混合\n#define mix(a,b) (s[a].t*s[a].v+s[b].t*s[b].v)/(s[a].v+s[b].v)\n\n  ll sum,prod,de;\n  db A[N];\nvoid wor()\n{\n  for (int i=0;++i<=n;)\n    {\n\n      while (sum+v[i]>L)\n        {\n          de=min(s[l].v,sum+v[i]-L);\n          s[l].v-=de;\n          sum-=de;\n          prod-=de*s[l].t;\n          if (!s[l].v) l++;\n        }\n        \n      sum+=s[++r].v=v[i];\n\t\t\ts[r].t=t[i];\n      prod+=v[i]*t[i];\n      \n      while (l<r&&s[r].t<s[r-1].t)\n        s[--r].t=mix(r,r+1),\n\t\t\t\ts[r].v+=s[r+1].v;\n\n      A[i]=(db)prod/L;\n    }\n}\n\nvoid out()\n{\n  for (int i=0;++i<=n;)\n    printf(\"%lf\\n\",A[i]);\n}\n\nint main()\n{\n  in();\n\twor();\n\tout();\n  exit(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define fd(i,a,b) for(i=a;i>=b;i--)\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\ntypedef long long ll;\nusing namespace std;\ninline int read(){\n\tint n=0,f=1;char c;\n\tfor(c=getchar();(c<'0'||c>'9')&&c!='-';c=getchar());\n\tif (c=='-') c=getchar(),f=-1;\n\tfor(;c>='0'&&c<='9';c=getchar()) n=n*10+c-48;\n\treturn n*f;\n}\nconst int maxn=5e5+5;\nint i,j,n,head,tail;\ndouble q[maxn][2],V,T,L,t,v;\nint main(){\n\tn=read(),L=read();\n\thead=1,tail=0;\n\tfor(;n--;){\n\t\tt=read(),v=read();\n\t\tV+=v,T+=t*v;\n\t\tfor(;V>L;){\n\t\t\tif (V-q[head][0]>L)V-=q[head][0],T-=q[head][1]*q[head][0],head++;else{\n\t\t\t\tq[head][0]-=V-L,T-=(V-L)*q[head][1],V=L;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.6lf\\n\",T/V);\n\t\tfor(;head<tail;tail--){\n\t\t\tif (q[tail][1]>q[tail-1][1]) break;\n\t\t\tq[tail-1][1]=(q[tail-1][0]*q[tail-1][1]+q[tail][0]*q[tail][1])/(q[tail-1][0]+q[tail][0]);\n            q[tail-1][0]+=q[tail][0];\n\t\t}\n\t\tq[++tail][0]=v,q[tail][1]=t;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nusing ll = long long;\nusing ldouble = long double;\n\ntemplate <typename T>\nstruct rsq\n{\n\tT bit[234567];\n\tint siz;\n\tvoid init(int n)\n\t{\n\t\tsiz = 1;\n\t\twhile (siz < n)siz *= 2;\n\t\tfor (int i = 0; i <= siz; ++i)\n\t\t\tbit[i] = 0;\n\t}\n\tvoid add(int i, T x)\n\t{\n\t\t++i;\n\t\twhile (i <= siz)\n\t\t{\n\t\t\tbit[i] += x;\n\t\t\ti += (i & -i);\n\t\t\t//cerr << i << \" \" << bit[i] << endl;\n\t\t}\n\t}\n\tT sum(int i)\n\t{\n\t\tT ans = 0;\n\t\twhile (i > 0)\n\t\t{\n\t\t\tans += bit[i];\n\t\t\ti -= (i & -i);\n\t\t}\n\t\treturn ans;\n\t}\n};\n\nint n, l;\nll t[567890], v[567890];\nrsq<ll> vol;\nrsq<ldouble> het;\n\nint main()\n{\n\tcin >> n;\n\tcin >> l;\n\tvol.init(n);\n\thet.init(n);\n\tvector<pair<ll, int>>vec;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tcin >> t[i] >> v[i];\n\t\tvec.push_back({ t[i],i });\n\t}\n\tvector<int>inv(n);\n\tsort(vec.rbegin(), vec.rend());\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tinv[vec[i].second] = i;\n\t}\n\tcout.precision(20);\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tll temp = t[i];\n\t\tll volm = v[i];\n\t\tll rem = l - v[i];\n\t\tint lo = 0, hi = n;\n\t\twhile (lo + 1 < hi)\n\t\t{\n\t\t\tint md = (lo + hi) / 2;\n\t\t\tif (vol.sum(md) < rem)\n\t\t\t{\n\t\t\t\tlo = md;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\thi = md;\n\t\t\t}\n\t\t}\n\t\tldouble heatcap = het.sum(lo) + (rem - vol.sum(lo)) * vec[lo].first + v[i] * t[i];\n\t\tcout << heatcap / l << endl;\n\t\tvol.add(inv[i], v[i]);\n\t\thet.add(inv[i], (ldouble)t[i] * v[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n#define X first\n#define Y second\n#define mp make_pair\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <double, double> Point;\nconst int N = 5e5 + 50;\n\nPoint Q[N];\nint n, L, he = 1, ta = 0;\n\ntemplate <typename T> inline void Read(T &x) {\n  x = 0; char ch = 0;\n  while (!isdigit(ch = getchar()));\n  do {x = (x << 1) + (x << 3) + ch - '0';} while (isdigit(ch = getchar()));\n}\n\ninline void Desert(double right) {\n  while (he < ta && Q[he + 1].X >= right) he ++;\n  if (Q[he].X > right) {\n    Q[he].Y = Q[he + 1].Y + (Q[he].Y - Q[he + 1].Y) / (Q[he].X - Q[he + 1].X) * (right - Q[he + 1].X);\n    Q[he].X = right;\n  }\n}\n\ninline void Insert(Point P) {\n  while (he < ta && (Q[ta].X - P.X) * (Q[ta - 1].Y - P.Y) >= (Q[ta - 1].X - P.X) * (Q[ta].Y - P.Y)) ta --;\n  Q[++ ta] = P;\n}\n\ninline void Out() {\n  cout << endl << \"------------------\" << endl;\n  for (int i = ta; i >= he; i --) {\n    printf(\"%.3lf %.3lf\\n\", Q[i].X, Q[i].Y);\n  }\n}\n\nint main() {\n  Read(n); Read(L);\n  Q[++ ta] = mp(0, 0);\n  LL x, y;\n  for (int i = 1; i <= n; i ++) {\n    Read(y); Read(x);\n    y *= x;\n    if (i != 1) Desert(Q[he].first - x);\n    Insert(mp(Q[ta].X - x, Q[ta].Y - y));\n    printf(\"%.7lf\\n\", (Q[he].second - Q[ta].second) / L);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cctype>\n\nusing namespace std;\n\ntypedef long double db;\n\ninline int read()\n{\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (!isdigit(ch)) f=ch=='-'?-1:f,ch=getchar();\n\twhile (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\n\nconst int N=500005;\n\ndb x[N],y[N];\ndb vol,tem;\nint head,tail,n,L;\n\nint main()\n{\n\t//freopen(\"dam.in\",\"r\",stdin),freopen(\"dam.out\",\"w\",stdout);\n\tn=read(),L=read(),head=1,tail=0,vol=tem=0.;\n\tfor (int i=1,t,v;i<=n;++i)\n\t{\n\t\tt=read(),v=read();\n\t\tfor (;vol+v>L;)\n\t\t{\n\t\t\tdb dsc=min(x[head],vol+v-L);\n\t\t\ttem-=y[head]*dsc/x[head],y[head]-=y[head]*dsc/x[head];\n\t\t\tvol-=dsc,x[head]-=dsc;\n\t\t\tif (!x[head]) ++head;\n\t\t}\n\t\tvol+=x[++tail]=v,tem+=y[tail]=(db)v*t;\n\t\tfor (;head<tail&&y[tail]/x[tail]<y[tail-1]/x[tail-1];y[tail-1]+=y[tail],x[tail-1]+=x[tail],--tail);\n\t\tprintf(\"%.10lf\\n\",(double)(tem/vol));\n\t}\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<double, double>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            double t=T[i], v=V[i];\n            while(vv+v>L){\n               double t1=dp[0].first, v1=dp[0].second;\n               double tmp=min(vv+v-L, v1);\n               tt=tt-t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1*(v1-tmp)/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n \n            tt+=t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            double c1=t*v;\n            double c2=v;\n            while(ans){\n                double t2=dp[ans-1].first, v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<double,double>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tint l=as[j].second;\n\t\t\tint val=as[j].first*l;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tdouble val=0;\n\t\t\tint l=0;\n\t\t\tfor(int i=vcnt-101;i<vcnt-1;i++){\n\t\t\t\tval=(v[i].first)/l+(val)/v[i].second;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tint ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,(double)ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b)/(b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long double LD;\nusing namespace std;\ninline int rd() {\n\tchar ch=getchar(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=getchar();}\n\treturn i*f;\n}\ndeque < pair<LD,LD> > q;\nconst LD eps=1e-10;\ninline int sgn(LD x) {return (x>eps)-(x<-eps);}\nint n,L;\nLD sum_v;\nint main() {\n\tn=rd(), L=rd();\n\tfor(int i=1;i<=n;i++) {\n\t\tLD V=rd(), t=rd(); V*=t;\n\t\tif(i==1) {printf(\"%.7f\\n\",(double)(V/t)); q.push_back(make_pair(V,t)); sum_v=V; continue;}\n\t\tLD rs=t;\n\t\twhile(q.size() && q.front().first<rs) rs-=q.front().first, sum_v-=q.front().first, q.pop_front();\n\t\tif(q.size() && sgn(rs)>0) {\n\t\t\tLD vi=rs*(q.front().first/q.front().second);\n\t\t\tq.front().first-=vi; sum_v-=vi; q.front().second-=rs;\n\t\t}\n\t\tsum_v+=V; printf(\"%.7f\\n\",(double)(sum_v/L));\n\t\twhile(q.size() && (q.back().first/q.back().second)>(V/t)) {\n\t\t\tV+=q.back().first, t+=q.back().second, q.pop_back();\n\t\t} q.push_back(make_pair(V,t));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define ld long double\n#define PI pair<ld,ll>\n#define S second\n#define F first\nconst int N=500005;\nint n,L,top;\nPI q[N];\nll sum[N];\nld ans[N];\nPI operator +(PI a,PI b){\n\treturn mp((a.F*a.S+b.F*b.S)/(a.S+b.S),a.S+b.S);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++){\n\t\tint t,v; scanf(\"%d%d\",&t,&v);\n\t\tPI dq=mp(t,v);\n\t\twhile(top&&q[top]>dq){if(q[top].S+dq.S>L)q[top].S=L-dq.S; dq=dq+q[top--]; }\n\t\tq[++top]=dq; sum[top]=sum[top-1]+dq.S; ans[top]=ans[top-1]+dq.F*dq.S;\n\t\tint pos=lower_bound(&sum[1],&sum[top+1],sum[top]-L)-sum;\n\t\tprintf(\"%.7lf\\n\",(double)((ans[top]-ans[pos]+q[pos].F*(L-(sum[top]-sum[pos])))/L));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define mp(a,b)\tmake_pair(a,b)\n#define fst\tfirst\n#define scn second\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\n\nint main() {\n\tll n, l;\tcin >> n >> l;\n\tdeque<pair<ld,ll> > dq;\n\tld t;\tll v;\tcin >> t >> v;\n\tdq.push_back(mp(t, v));\n\tld ret = t*v;\n\tprintf(\"%.15Lf\\n\", ret / l);\n\tsrep(i,1,n){\n\t\tcin >> t >> v;\n\t\tll left = v;\n\t\twhile (left) {\n\t\t\tpll front = dq.front();\tdq.pop_front();\n\t\t\tll rm = min(front.scn, left);\n\t\t\tfront.scn -= rm;\tleft -= rm;\n\t\t\tret -= rm*front.fst;\n\t\t\tif (front.scn > 0)\tdq.push_front(front);\n\t\t}\n\t\twhile (!dq.empty() && dq.back().fst >= t) {\n\t\t\tt = (dq.back().fst*dq.back().scn + t*v) / (dq.back().scn + v);\n\t\t\tv += dq.back().scn;\n\t\t\tret -= dq.back().fst*dq.back().scn;\n\t\t\tdq.pop_back();\n\t\t}\n\t\tret += t*v;\n\t\tdq.push_back(mp(t, v));\n\t\tprintf(\"%.15Lf\\n\", ret / l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define db double\n#define inf 20021225\n#define N 1000010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nstruct node{int l; db t;}w[N];\nint t[N],v[N],n,L,sum; db T;\nint main()\n{\n\tn=read(),L=read(); int l=1,r=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tt[i]=read(),v[i]=read();\n\t\twhile(sum+v[i]>L)\n\t\t{\n\t\t\tint tmp=min(w[l].l,sum+v[i]-L);\n\t\t\tsum-=tmp; T-=w[l].t*tmp; if(tmp==w[l].l)\tl++;\n\t\t}\n\t\tw[++r]=(node){v[i],t[i]};\n\t\tT+=v[i]*t[i]; sum+=v[i];\n\t\twhile(l<r&&w[r].t<w[r-1].t)\n\t\t{\n\t\t\tw[r-1].t=(w[r-1].l*w[r-1].t+w[r].l*w[r].t)/(w[r-1].t+w[r].t);\n\t\t\tw[r-1].l+=w[r].l; r--;\n\t\t}\n\t\tprintf(\"%lf\\n\",T/sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t考虑新加进来的水与当前水的温度的关系\n\t大于当前温度, 我可以选择踢掉之前的水\n\t小于当前温度, 肯定是加进来这些水再一起踢更优\n\t那么这样子就可以维护一个水温度单调上升的队列\n*/\n#include <iostream>\n#include <cstdio>\n#define N 500005\n\nusing namespace std;\n\nint n, lim;\n\npair<long long, double> que[N];\n\ninline void read(int &x) {\n\tx = 0; char ch = getchar();\n\twhile(!isdigit(ch)) ch = getchar();\n\twhile(isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();\n}\n\nint main() {\n\tread(n), read(lim);\n\tint hd = 0, tl = -1;\n\tint cur = 0; double sum = 0;\n\tfor(int i = 1, v, t; i <= n; ++i) {\n\t\tread(t), read(v);\n\t\tcur += v, sum += 1LL * v * t;\n\t\twhile(cur > lim) {\n\t\t\tint del = cur - lim;\n\t\t\tlong long &u = que[hd].first;\n\t\t\tif(u > del) {\n\t\t\t\tu -= del;\n\t\t\t\tsum -= del * que[hd].second;\n\t\t\t\tcur = lim;\n\t\t\t} else {\n\t\t\t\tsum -= u * que[hd].second;\n\t\t\t\tcur -= u;\n\t\t\t\t++hd;\n\t\t\t}\n\t\t}\n\t\tque[++tl] = make_pair(v, t);\n\t\twhile(hd < tl && que[tl - 1].second > que[tl].second) {\n\t\t\tlong long v1 = que[tl - 1].first, v2 = que[tl].first;\n\t\t\tdouble t1 = que[tl - 1].second, t2 = que[tl].second;\n\t\t\tque[--tl] = make_pair(v1 + v2, (v1 * t1 + v2 * t2) / (v1 + v2));\n\t\t}\n//\t\tcerr << que[hd].first << ' ' << que[hd].second << endl;\n\t\tprintf(\"%.7lf\\n\", sum / lim);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, ld> pld;\n\n#define fi first\n#define se second\n\nconst int MAXN = 500005;\n\nint T[MAXN], V[MAXN];\ndeque<pld> d;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint N, L;\n\n\tcin >> N >> L;\n\tfor(int i = 0; i < N; i++) cin >> T[i] >> V[i];\n\n\tcout << fixed;\n\tcout.precision(20);\n\tpld ep = make_pair(0.0L, 0.0L);\n\tfor(int i = 0; i < N; i++) {\n\t\td.push_front(make_pair(V[i], (ld) V[i] * T[i]));\n\t\tep.fi = L;\n\t\tep.se += (ld) V[i] * T[i];\n\t\tcout << ep.se / ep.fi << \"\\n\";\n\t\tif(i == N - 1) break;\n\t\twhile(d.size() > 1 && d[0].se / d[0].fi < d[1].se / d[1].fi) {\n\t\t\td[1].fi += d[0].fi;\n\t\t\td[1].se += d[0].se;\n\t\t\td.pop_front();\n\t\t}\n\t\twhile(!d.empty() && ep.fi - d.back().fi > L - V[i + 1]) {\n\t\t\tep.fi -= d.back().fi;\n\t\t\tep.se -= d.back().se;\n\t\t\td.pop_back();\n\t\t}\n\t\tif(!d.empty()) {\n\t\t\tld dse = d.back().se * (ep.fi - L + V[i + 1]) / d.back().fi;\n\t\t\td.back().fi -= ep.fi - L + V[i + 1];\n\t\t\tep.se -= dse;\n\t\t\td.back().se -= dse;\n\t\t\tep.fi = L - V[i + 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.01.2020 03:51:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(17);\n  int n, l;\n  cin >> n >> l;\n  vector<pair<long double, long double>> a;\n  long double res = 0;\n  int i = 0;\n  for (int it = 0; it < n; it++) {\n    long double t, v;\n    cin >> t >> v;\n    long double rm = (it == 0 ? 0 : v);\n    while (i < (int) a.size()) {\n      if (rm > a[i].second) {\n        rm -= a[i].second;\n        res -= a[i].first * a[i].second;\n        ++i;\n      } else {\n        a[i].second -= rm;\n        res -= a[i].first * rm;\n        break;\n      }\n    }\n    res += t * v;\n    while (!a.empty() && a.back().first > t) {\n      t = (t * v + a.back().first * a.back().second) / (v + a.back().second);\n      v += a.back().second;\n      a.pop_back();\n    }\n    a.emplace_back(t, v);\n    cout << res / l << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1*d1.front().second;\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    totv-=d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=(long double)1*d1.back().first*d1.back().second;\n                double tempp = (long double)1*tempv*tempt;\n                tempp+=(long double)1*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1*tempp)/((long double)1*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 500005\nusing namespace std;\nstruct node{double t,v;}q[M]={0},p;\nint head=0,tail=0;\nint main(){\n\tdouble l=0,ll=0,now=0;\n\tint n; scanf(\"%d\",&n);\n\tscanf(\"%lf\",&ll); l=ll;\n\twhile(n--){\n\t\tscanf(\"%lf%lf\",&p.t,&p.v);\n\t\twhile(p.v>l){\n\t\t\tif(q[head].v+l<=p.v)\n\t\t\tnow-=q[head].v*q[head].t,l+=q[head++].v;\n\t\t\telse{\n\t\t\t\tdouble x=p.v-l;\n\t\t\t\tnow-=x*q[head].t;\n\t\t\t\tl+=x;\n\t\t\t\tq[head].v-=x;\n\t\t\t}\n\t\t}\n\t\tl-=p.v; now+=p.v*p.t; q[++tail]=p;\n\t\twhile(head<tail&&q[tail-1].t>=q[tail].t){\n\t\t\tq[tail-1].t=(q[tail-1].t*q[tail-1].v+q[tail].t*q[tail].v)/(q[tail-1].v+q[tail].v);\n\t\t\tq[tail-1].v+=q[tail].v;\n\t\t\ttail--;\n\t\t}\n        printf(\"%.10lf\\n\",now/(ll-l));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1.0*d1.front().second;\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1.0*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=(long double)1.0*v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=(long double)1.0*v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=tempt){\n                totprod-=(long double)1.0*d1.back().first*d1.back().second;\n                double tempp = (long double)1.0*tempv*tempt;\n                tempp+=(long double)1.0*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1.0*tempp)/((long double)1.0*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1.0*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define an size()\nusing namespace std;\n\n\nconst ll maxn=5e5+900;\n\nvector<pair<ll,ll> > dama;\nvector<pair<ll,ll> > vor;\nset<ll > st;\nset<ll > ::iterator it;\n\n\n\nll z[maxn];\nll tv[maxn];\nll koj[maxn];\nvoid updatez(  ll val,int index)\n{\n    index++;\n    while (index < maxn)\n    {\n        z[index] += val;\n        index += index & (-index);\n    }\n}\nll findz( int index)\n{\n    ll sum = 0;\n    index++;\n    while (index>0)\n    {\n        sum += z[index];\n        index -= index & (-index);\n    }\n    return sum;\n}\nvoid updatetv(  ll val,int index)\n{\n    index++;\n    while (index < maxn)\n    {\n        tv[index] += val;\n        index += index & (-index);\n    }\n}\nll findtv( int index)\n{\n    ll sum = 0;\n    index++;\n    while (index>0)\n    {\n        sum += tv[index];\n        index -= index & (-index);\n    }\n    return sum;\n}\nint main()\n{\n    cout.precision(6);\n\n    ll n,l,t,v,w,ans;\n\n    cin>>n>>l;\n    for (ll i=0; i<n; i++)\n    {\n        cin>>t>>v;\n        dama.pb(mp(t,i));\n        vor.pb(mp(t,v));\n    }\n    sort(dama.begin(),dama.end());\n    reverse(dama.begin(),dama.end());\n    for (ll i=0; i<n; i++)\n    {\n        koj[dama[i].S]=i;\n    }\n\n\n\n\n    cout<<vor[0].F<<endl;\n    updatetv(vor[0].S*vor[0].F,koj[0]);\n    //cout<<\"UPDATE  \"<<vor[0].S*vor[0].F<<' '<<koj[0]<<endl;\n    updatez(vor[0].S,koj[0]);\n    st.insert(koj[0]);\n    for (ll i=1; i<n; i++)\n    {\n        t=vor[i].F;\n        v=vor[i].S;\n\n        ///////////javab\n        ll s=0;\n        if (findz(0)+v>l)\n        {\n            cout<< v*t+(l-v)*(dama[0].F)  /(long double)l<<endl;\n        }\n        else\n        {\n            ll e=maxn;\n            while (e-s>1)\n            {\n                ll m=e+s;\n                m/=2;\n                if (l<findz(m)+v)\n                {\n                    e=m;\n                }\n                else\n                {\n                    s=m;\n                }\n            }\n\n           // cout<<s<<\"S\\n\";\n            it=st.upper_bound(s);\n            if (it==st.begin())\n            {\n                w=(*it);\n                ans=t*v+(dama[w].F*(l-v));\n            }\n            else\n            {\n                it--;\n                w=(*it);\n                ans=findtv(w)+t*v;\n\n                it++;\n                ll hagm=findz(w)+v;\n                w=(*it);\n                ans+=(l-hagm)*(dama[w].F);\n            }\n            cout<<ans/(long double)l<<endl;\n        }\n        //////////////update\n        updatetv(t*v,koj[i]);\n        //  cout<<\"UPDATE  \"<<t*v<<' '<<koj[i]<<endl;\n        updatez(v,koj[i]);\n        st.insert(koj[i]);\n\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttail++;\n\t\t\tsum+=t*v;\n\t\t\tq[tail].t=sum/l;\n\t\t\tq[tail].v=l;\n\t\t\thead=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        if (!sgn(ll-d)){\n            V = 0;\n        }\n        else {\n            V -= d*W.front().fi;\n        }\n        l -= d; W.front().se -= d; ll -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }\n}\n\nvoid push(DB v, DB l){\n    V += + l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.push_back(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[800005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,ll times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n        return (one * two * three);\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Node {\n    double t, v;\n    Node() {}\n    Node(double _t, double _v) : t(_t), v(_v) {}\n    Node& operator+=(const Node& _oth){\n        t = (t*v + _oth.t*_oth.v)/(v+_oth.v);\n        v += _oth.v;\n        return *this;\n    }\n};\n\nvoid solve() {\n    int n; double L;\n    cin >> n >> L;\n    cout << fixed << setprecision(7);\n\n    deque<Node> past;\n    double E = 0, V = 0;\n    for (int _ = 0; _ < n; _++) {\n        double t, v;\n        cin >> t >> v;\n        while (!past.empty() && V+v > L) {\n            double depre = min(V+v-L, past[0].v);\n            E -= depre * past[0].t;\n            past[0].v -= depre;\n            V -= depre;\n            if (past[0].v <= 0.0000001) past.pop_front();\n        }\n        E += t*v; V += v;\n        cout << E/V << \"\\n\";\n\n        past.emplace_back(t,v);\n        int m = past.size();\n        while (m>1 && past[m-2].t >= past[m-1].t) {\n            past[m-2] += past[m-1];\n            m--;\n            past.pop_back();\n        }\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\nusing namespace std;\nconst int N=5e5+5;\nstruct data\n{\n\tdouble t;\n\tlong long v;\n}q[N],p;\nint l=1,r=0;\ninline int read()\n{\n    int X=0,w=0; char ch=0;\n    while(!isdigit(ch)) w|=ch=='-',ch=getchar();\n    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n    return w?-X:X;\n}\nint main()\n{\n\tint n=read();\n\tlong long L=read(),L0=L;\n\tdouble now=0;\n\twhile(n--)\n\t{\n\t\tp.t=read(),p.v=read();\n\t\twhile(p.v>L)\n\t\t\tif(q[l].v+L<=p.v)\n\t\t\t{\n\t\t\t\tnow-=q[l].v*q[l].t;\n\t\t\t\tL+=q[l++].v;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tnow-=p.v*q[l].t;\n\t\t\t\tL+=p.v;\n\t\t\t\tq[l].v-=p.v;\n\t\t\t}\n\t\tL-=p.v;\n\t\tnow+=p.v*p.t;\n\t\tq[++r]=p;\n\t\twhile(l<r && q[r-1].t>=q[r].t)\n\t\t{\n\t\t\tq[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v*1.0+q[r].v);\n\t\t\tq[r-1].v+=q[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",now*1.0/(L0-L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.01.2020 03:51:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(17);\n  int n, l;\n  cin >> n >> l;\n  vector<pair<long double, long double>> a;\n  long double res = 0;\n  int i = 0;\n  auto Recalc = [&]() {\n    res = 0;\n    for (int j = i; j < (int) a.size(); j++) {\n      res += a[j].first * a[j].second;\n    }\n  };\n  for (int it = 0; it < n; it++) {\n    long double t, v;\n    cin >> t >> v;\n    long double rm = (it == 0 ? 0 : v);\n    while (i < (int) a.size()) {\n      if (rm > a[i].second) {\n        rm -= a[i].second;\n        if (res > a[i].first * a[i].second * 2) {\n          res -= a[i].first * a[i].second;\n          ++i;\n        } else {\n          ++i;\n          Recalc();\n        } \n      } else {\n        a[i].second -= rm;\n        if (res > a[i].first * rm * 2) {\n          res -= a[i].first * rm;\n        } else {\n          Recalc();\n        }\n        break;\n      }\n    }\n    res += t * v;\n    while (!a.empty() && a.back().first > t) {\n      t = (t * v + a.back().first * a.back().second) / (v + a.back().second);\n      v += a.back().second;\n      a.pop_back();\n    }\n    a.emplace_back(t, v);\n    Recalc();\n    cout << res / l << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\nusing namespace std;\n\nstruct Water {\n    double t; int v;\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, l;\n    cin >> n >> l;\n    deque<Water> q;\n    double s = 0;\n    q.push_back({ 0, l });\n\n    for (int i = 0; i < n; i++) {\n        int t, v;\n        cin >> t >> v;\n        for (int k = v;;) {\n            auto& o = q.front();\n            if (o.v <= k) {\n                k -= o.v;\n                s -= o.t * o.v;\n                q.pop_front();\n                if (k == 0) break;\n            } else {\n                o.v -= k;\n                s -= o.t * k;\n                break;\n            }\n        }\n        double x = t;\n        s += x * v;\n        for (;;) {\n            if (q.empty()) {\n                q.push_back({ x, v });\n                break;\n            }\n            auto& o = q.back();\n            if (x > o.t) {\n                q.push_back({ x, v });\n                break;\n            } else {\n                x = (x * v + o.t * o.v) / (v + o.v);\n                v += o.v;\n                q.pop_back();\n            }\n        }\n        cout << fixed << setprecision(9) << s / l << '\\n';\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define regsiter register\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nstruct po\n{\n\tdouble x,y;\n}q[511111];\nint hq,tq=1;\ndouble adx,ady;\nint main()\n{\n\tint n=io::F(),L=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tint t=io::F(),v=io::F();\n\t\tadx+=v,ady+=t*(long long)v;\n\t\twhile(1<tq&&(q[tq-1].y+ady)/(q[tq-1].x+adx)<(q[tq-2].y+ady)/(q[tq-2].x+adx))\n\t\t{\n\t\t\tif(q[tq-2].x+adx-L<=0)tq--;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tq[tq-2]=(po){L-adx,(q[tq-2].y-q[tq-1].y)/(q[tq-2].x-q[tq-1].x)*(L-(q[tq-1].x+adx))+q[tq-1].y};\n\t\t\t\t\t--tq;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t}\n\t\tq[tq++]=(po){-adx,-ady};\n\t\tif(i==1){printf(\"%.9lf\\n\",(double)t);continue;}\n\t\twhile(hq<tq&&q[hq+1].x+adx>=L)++hq;\n\t\tdouble ans=(ady+q[hq+1].y+(q[hq].y-q[hq+1].y)/(q[hq].x-q[hq+1].x)*(L-(q[hq+1].x+adx)))/L;\n\t\tprintf(\"%.9lf\\n\",ans);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(__,v.size()){rep(_,v[__].size())cout<<\" \"<<v[__][_];cout<<endl;}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\ntypedef pair<double,int> pdi;\nsigned main(){\n\tint n,l;\n\tdouble sum=0;\n\tcin>>n>>l;\n\tdeque<pdi>que;\n\trep(i,n){\n\t\tdouble t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tif(!i){\n\t\t\tque.pb({t,v});\n\t\t\tsum+=t*v;\n\t\t}else{\n\t\t\tint nv=v;\n\t\t\twhile(nv){\n\t\t\t\tint w=min(nv,que[0].second);\n\t\t\t\tsum-=w*que[0].first;\n\t\t\t\tque[0].second-=w;\n\t\t\t\tnv-=w;\n\t\t\t\tif(!que[0].second)que.pop_front();\n\t\t\t}\n\t\t\tsum+=t*v;\n\t\t\twhile(!que.empty()){\n\t\t\t\tpdi a=que.back();\n\t\t\t\tque.pop_back();\n\t\t\t\tif(a.first<t){\n\t\t\t\t\tque.pb(a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tt=(v*t+a.first*a.second)/(v+a.second);\n\t\t\t\tv+=a.second;\n\t\t\t}\n\t\t\tque.pb({t,v});\n\t\t}\n\t\tcout<<shosu(9)<<sum/l<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 500005\nusing namespace std;\nstruct node{double t,v;}q[M]={0},p;\nint head=0,tail=0;\nint main(){\n    double l=0,ll=0,now=0;\n    int n; scanf(\"%d\",&n);\n    scanf(\"%lf\",&ll); l=ll;\n    while(n--){\n        scanf(\"%lf%lf\",&p.t,&p.v);\n        while(p.v>l){\n            if(q[head].v+l<=p.v)\n            now-=q[head].v*q[head].t,l+=q[head++].v;\n            else{\n                double x=p.v-l;\n                now-=x*q[head].t;\n                l+=x;\n                q[head].v-=x;\n            }\n        }\n        l-=p.v; now+=p.v*p.t; q[++tail]=p;\n        while(head<tail&&q[tail-1].t>=q[tail].t){\n            q[tail-1].t=(q[tail-1].t*q[tail-1].v+q[tail].t*q[tail].v)/(q[tail-1].v+q[tail].v);\n            q[tail-1].v+=q[tail].v;\n            tail--;\n        }\n        printf(\"%.10lf\\n\",now/ll);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6\nvector<pair<DB, DB> > W;\nvector<DB> S;\nint w0; DB s0;\n// degree, V\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W[w0].se);\n        V = ((V*ll) - d*W[w0].fi) / (ll-d);\n        l -= d; W[w0].se -= d;\n        if (!sgn(W[w0].se)) w0++;\n        ll -= d;\n    }\n    s0 += l;\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n// 4 5\n// 2 3\n\n// 0 > 0\n\nvoid gao(){\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l)); w0 = 0;\n    \n    FOR(i, 1, n){\n        RD(v, l); pop(l); push(v, l);\n        \n        DB r = 0;\n        while (W.size() > w0 && W.rbegin()->fi > V){\n            r += W.rbegin()->se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n            W.push_back(MP(V, r));\n        }\n        OT(V);\n        \n        //int p = lower_bound(W.begin() + w0, W.end(), V) - W.begin();\n        //DB ss = p > w0 ? S[p-1]-s0 : 0;\n        \n    }\n}\nint main(){\n    \n#ifndef ONLINE_JUDGE\n  //  freopen(\"/users/minakokojima/Documents/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n    RD(n, L);\n    gao();\n    /*REP(i, n){\n        LL t, v; RD(v, t);\n        if (i){\n            DB tt = t, ll = L;\n            \n            while (sgn(tt)){\n                pair<DB, DB> z = Q.top(); Q.pop();\n                DB d = min(tt, z.se);\n                \n                cout << z.fi << \" \" << z.se << endl;\n                \n                // ((ll-d)*vv' + d*z.fi) / ll = vv\n                \n                vv = ((vv*ll) - d*-z.fi) / (ll-d);\n\n                \n                tt -= d, z.se -= d;\n                if (sgn(z.se)){\n                    Q.push(MP(z.fi, z.se));\n                }\n                ll -= d;\n            }\n            vv = ((L-t)*vv + t*v) / L;\n        }\n        else{\n            vv = v;\n        }\n        Q.push(MP(-v, t));\n        OT(vv);\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500009\nusing namespace std;\n\nint n,m,q[N];\nstruct node{ double x,y,z; }a[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,k,head=1,tail=0; double now=0,ans=0;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%lf%lf\",&a[i].x,&a[i].y);\n\t\tans+=a[i].x*a[i].y;\n\t\ta[i].z=now=now+a[i].y;\n\t\tfor (; head<=tail && a[k=q[head]].z<=now-m; head++)\n\t\t\tans-=a[k].x*a[k].y;\n\t\tans-=a[k].x*a[k].y;\n\t\ta[k].y=a[k].z-(now-m);\n\t\tans+=a[k].x*a[k].y;\n\t\tfor (; head<=tail && a[k=q[tail]].x>a[i].x; tail--){\n\t\t\ta[i].x=(a[i].x*a[i].y+a[k].x*a[k].y)/(a[i].y+a[k].y);\n\t\t\ta[i].y+=a[k].y;\n\t\t}\n\t\tq[++tail]=i;\n\t\tprintf(\"%.10f\\n\",ans/m);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 5005\n#define INF 16843009\n#define LL long long\n#define LD double\n#define len(l,r) (r-l+1)\n#define P int(1e9+7)\nusing namespace std;\n \nint N,L,Q;\nLD A,B;\nLD t[MAXN], v[MAXN], dp[MAXN][MAXN];\n\nLD mix(LD v1, LD t1, LD v2, LD t2){\n\treturn (v1*t1 + v2*t2)/(v1 + v2);\n}\n\n\nint main(){\n\t\n//\tfreopen(\"4.in\", \"r\", stdin);\n//\tfreopen(\"4.out\", \"w\", stdout);\n\t\n\tcin>>N>>L;\n//\tcin>>Q;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>t[i]>>v[i];\n\t}\n\t\n\tfor(int j=0;j<=L;j++) dp[1][j] = t[1];\n\t\n\tfor(int i=2;i<=N;i++){\n\t\tfor(int j=0;j<=L;j++){\n\t\t\tfor(int k=max((LD)0,j-v[i]);k<=L-v[i];k++){\n\t\t\t\tdp[i][j] = max(dp[i][j], mix(k,dp[i-1][k],v[i],t[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=N;i++){\n\t\tprintf(\"%.6f\\n\", dp[i][L]);\n\t}\n\n//\tfor(int i=1;i<=Q;i++){\n//\t\tint x;\n//\t\tcin>>x;\n//\t\t\n//\t\tprintf(\"%.2lf\\n\", dp[x][L]);\n//\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=1ll*q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=1ll*q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=1ll*q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttail++;\n\t\t\tsum+=1ll*t*v;\n\t\t\tq[tail].t=sum/l;\n\t\t\tq[tail].v=l;\n\t\t\thead=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, ld> pld;\n\n#define fi first\n#define se second\n\nconst int MAXN = 500005;\n\nint T[MAXN], V[MAXN];\ndeque<pld> d;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint N, L;\n\n\tcin >> N >> L;\n\tfor(int i = 0; i < N; i++) cin >> T[i] >> V[i];\n\n\tcout << fixed;\n\tcout.precision(8);\n\tpld ep = make_pair(0.0L, 0.0L);\n\tfor(int i = 0; i < N; i++) {\n\t\twhile(!d.empty() && ep.fi - d.back().fi > L - V[i]) d.pop_back();\n\t\tif(!d.empty()) {\n\t\t\tld sed = d.back().se * (ep.fi - L + V[i]) / d.back().fi;\n\t\t\td.back().fi -= ep.fi - L + V[i];\n\t\t\tep.se -= sed;\n\t\t\td.back().se -= sed;\n\t\t\tep.fi = L - V[i];\n\t\t}\n\t\td.push_front(make_pair(V[i], (ld) V[i] * T[i]));\n\t\tep.fi = L;\n\t\tep.se += (ld) V[i] * T[i];\n\t\twhile(d.size() > 1 && d[0].se / d[0].fi < d[1].se / d[1].fi) {\n\t\t\td[1].fi += d[0].fi;\n\t\t\td[1].se += d[0].se;\n\t\t\td.pop_front();\n\t\t}\n\t\tcout << ep.se / ep.fi << \"\\n\";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define db double\n#define inf 20021225\n#define N 1000010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nstruct node{int l; db t;}w[N];\nint t[N],v[N],n,L,sum; db T;\nint main()\n{\n\tn=read(),L=read(); int l=1,r=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tt[i]=read(),v[i]=read();\n\t\twhile(sum+v[i]>L)\n\t\t{\n\t\t\tint tmp=min(w[l].l,sum+v[i]-L);\n\t\t\tsum-=tmp; T-=w[l].t*tmp; w[l].l-=tmp;\n\t\t\tif(!w[l].l)\tl++;\n\t\t}\n\t\tw[++r]=(node){v[i],t[i]};\n\t\tT+=v[i]*t[i]; sum+=v[i];\n\t\twhile(l<r&&w[r].t<w[r-1].t)\n\t\t{\n\t\t\tw[r-1].t=(w[r-1].l*w[r-1].t+w[r].l*w[r].t)/(w[r-1].t+w[r].t);\n\t\t\tw[r-1].l+=w[r].l; r--;\n\t\t}\n\t\tprintf(\"%lf\\n\",T/sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long \nusing namespace std;\n\nconst int maxn = 510000;\n\nint n,L;\nstruct node{double x,y;}a[maxn<<1]; int head,tail;\n\ndouble multi(node x,node y,node z)\n{\n\tx.x-=z.x; x.y-=z.y;\n\ty.x-=z.x; y.y-=z.y;\n\treturn x.x*y.y-x.y*y.x;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&L); n--;\n\ta[head=maxn]=(node){0.0,0.0};\n\tll x,y;\n\ttail=head+1; scanf(\"%lld%lld\",&y,&x);\n\tprintf(\"%lf\\n\",(double)y); a[tail].y=(double)x*y; a[tail].x=x;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&y,&x); y*=x;\n\t\tnode now=(node){a[head].x-(double)x,a[head].y-(double)y};\n\t\twhile(head+1<=tail&&a[tail-1].x-now.x>=L) tail--;\n\t\tif(head!=tail)\n\t\t{\n\t\t\tdouble pt=(a[tail].y-a[tail-1].y)/(a[tail].x-a[tail-1].x);\n\t\t\tif(a[tail].x-now.x>L)\n\t\t\t{\n\t\t\t\ta[tail].y=a[tail-1].y+(L-(a[tail-1].x-now.x))*pt;\n\t\t\t\ta[tail].x=now.x+L;\n\t\t\t}\n\t\t\twhile(head+1<=tail&&multi(a[head],a[head+1],now)>=0) head++;\n\t\t}\n\t\ta[--head]=now;\n\t\tdouble kk=a[tail].y-now.y;\n\t\tprintf(\"%lf\\n\",kk/(double)L);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 500010\n#define ll long long\nusing namespace std;\nstruct data{int x; double y;}d[N];\nint n, op, cl, sum, x, sx;\ndouble y, sy;\ninline char gc(){\n\tstatic char now[1<<16], *S, *T;\n\tif(S==T){T=(S=now)+fread(now, 1, 1<<16, stdin); if(S==T)return EOF;}\n\treturn *S++;\n}\ninline int read(){\n\tint x=0, f=1; char ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=gc();}\n\treturn x*f;\n}\nint main(){\n\tn=read(); sum=read();\n\top=1; cl=0; sx=sy=0;\n\tfor(int i=1; i<=n; i++){\n\t\ty=read(); x=read();\n\t\tsx+=x; sy+=x*y;\n\t\twhile(sx>sum){\n\t\t\tif(sx-d[op].x<sum){sy-=(sx-sum)*d[op].y; d[op].x-=sx-sum; sx=sum;}\n\t\t\telse{sx-=d[op].x; sy-=d[op].x*d[op].y; op++;}\n\t\t}\n\t\tprintf(\"%.10f\\n\", sy/sum);\n\t\twhile(y<d[cl].y){y=(x*y+d[cl].x*d[cl].y)/(x+d[cl].x); x+=d[cl].x; cl--;}\n\t\td[++cl].x=x; d[cl].y=y;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,s,t) for(int i=s;i<=t;++i)\ntypedef long long ll;\nusing namespace std;\nconst int maxn=5e5+10;\nll sumv,sumt;\ndouble q1[maxn],q2[maxn];\nint h,t,n;\nint main(){\n    ll l; scanf(\"%d%lld\",&n,&l);\n    rep(i,1,n){\n        ll wen,v; scanf(\"%lld%lld\",&wen,&v);\n        sumv+=v,sumt+=wen*v;\n        while (sumv>l&&h<t){\n            if (sumv-l>=q1[h]){\n                sumv-=q1[h];\n                sumt-=q1[h]*q2[h];\n                h++;\n            }\n            else {\n                q1[h]-=sumv-l;\n                sumt-=(sumv-l)*q2[h];\n                sumv=l;\n                break;\n            }\n        }\n        q1[t]=v,q2[t++]=wen;\n        printf(\"%.7f\\n\",1.0*sumt/sumv);\n        while (h+2<=t){\n            if (q2[t-1]>q2[t-2]) break;\n            q2[t-2]=(q1[t-1]*q2[t-1])*(q1[t-2]*q2[t-2])/(q1[t-1]+q1[t-2]);\n            q1[t-2]+=q1[t-1];\n            t--;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <deque>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nusing my_double = long double;\n\nstruct point {\n    my_double x, y;\n\n    point() : x(0), y(0) {}\n\n    point(my_double _x, my_double _y) : x(_x), y(_y) {}\n\n    point& operator+=(const point &other) { x += other.x; y += other.y; return *this; }\n    point& operator-=(const point &other) { x -= other.x; y -= other.y; return *this; }\n    point& operator*=(my_double mult) { x *= mult; y *= mult; return *this; }\n\n    point operator+(const point &other) const { return point(*this) += other; }\n    point operator-(const point &other) const { return point(*this) -= other; }\n    point operator*(my_double mult) const { return point(*this) *= mult; }\n\n    // Warning: does exact floating-point comparisons.\n    bool operator==(const point &other) const { return x == other.x && y == other.y; }\n    bool operator!=(const point &other) const { return !(*this == other); }\n\n    point operator-() const { return point(-x, -y); }\n    point rotate90() const { return point(-y, x); }\n\n    my_double norm() const {\n        return x * x + y * y;\n    }\n\n    my_double dist() const {\n        return sqrt(norm());\n    }\n\n    bool top_half() const {\n        return make_pair(y, x) > pair<my_double, my_double>(0, 0);\n    }\n\n    friend ostream& operator<<(ostream &stream, const point &p) {\n        return stream << '(' << p.x << \", \" << p.y << ')';\n    }\n};\n\nmy_double cross(const point &a, const point &b) {\n    return a.x * b.y - b.x * a.y;\n}\n\nmy_double dot(const point &a, const point &b) {\n    return a.x * b.x + a.y * b.y;\n}\n\nbool left_turn_strict(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) > 0;\n}\n\nbool left_turn_lenient(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) >= 0;\n}\n\n// Warning: does a floating-point comparison to exactly 0.\nbool collinear(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a) == 0;\n}\n\n// Returns the signed, doubled area formed by three points in a triangle. Positive when a -> b -> c is a left turn.\nmy_double area_signed_doubled(const point &a, const point &b, const point &c) {\n    return cross(b - a, c - a);\n}\n\nmy_double distance_to_line(const point &p, const point &a, const point &b) {\n    assert(a != b);\n    return abs(area_signed_doubled(p, a, b)) / (a - b).dist();\n}\n\nmy_double manhattan_dist(const point &a, const point &b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nmy_double infinity_norm_dist(const point &a, const point &b) {\n    return max(abs(a.x - b.x), abs(a.y - b.y));\n}\n\n// Sort in increasing order of y, with ties broken in increasing order of x.\nbool yx_compare(const point &a, const point &b) {\n    return (b - a).top_half();\n}\n\n// Sort in increasing order of angle to the x-axis.\nbool angle_compare(const point &a, const point &b) {\n    if (a.top_half() ^ b.top_half())\n        return a.top_half();\n\n    return cross(a, b) > 0;\n}\n\n\nint N;\nlong long L;\n\nint main() {\n    scanf(\"%d %lld\", &N, &L);\n    deque<point> poly_line = {point(0, 0)};\n\n    for (int i = 0; i < N; i++) {\n        long long T, V;\n        scanf(\"%lld %lld\", &T, &V);\n        poly_line.push_front(poly_line.front() + point(-V, -T * V));\n\n        while (poly_line[poly_line.size() - 2].x - poly_line.front().x >= L)\n            poly_line.pop_back();\n\n        point second_last = poly_line[poly_line.size() - 2];\n        point delta = poly_line.back() - second_last;\n        my_double portion = poly_line.front().x + L - second_last.x;\n        delta *= portion / (poly_line.back().x - second_last.x);\n        poly_line.back() = second_last + delta;\n\n        while (poly_line.size() >= 3 && left_turn_lenient(poly_line[0], poly_line[1], poly_line[2])) {\n            poly_line[1] = poly_line[0];\n            poly_line.pop_front();\n        }\n\n        my_double answer = (poly_line.back().y - poly_line.front().y) / L;\n        printf(\"%.9lf\\n\", (double) answer);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            ll t=T[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first;\n               ll v1=dp[0].second;\n               double tmp=min(vv+v-L, (double)v1);\n               tt=tt-(double)t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==(double)v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-(double)t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            ll c1=t*v, c2=v;\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-9;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nlong long s[510000];\nlong long t[510000];\ndeque<pair<double,int> >Q;\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%lld%lld\",s+i,t+i);\n\t}\n\tlong long tot=0;\n\tdouble toJ=0;\n\tfor(int i=0;i<a;i++){\n\t\tdouble J=0;\n\t\tlong long cur=0;\n\t\tJ+=(double)s[i]*t[i];\n\t\tcur+=t[i];\n\t\twhile(Q.size()&&Q.front().first>=J/cur){\n\t\t\tJ+=Q.front().first*Q.front().second;\n\t\t\tcur+=Q.front().second;\n\t\t\tQ.pop_front();\n\t\t}\n\t\t\n\t//\tprintf(\"%.12f %lld\\n\",J/cur,cur);\n\t\tQ.push_front(make_pair(J/cur,cur));\n\t\ttoJ+=(double)s[i]*t[i];\n\t\ttot+=t[i];\n\t\twhile(tot>b){\n\t\t\tpair<double,int> tmp=Q.back();\n\t\t\tQ.pop_back();\n\t\t\tif(tmp.second<=(tot-b)){\n\t\t\t\ttoJ-=tmp.second*tmp.first;\n\t\t\t\ttot-=tmp.second;\n\t\t\t}else{\n\t\t\t\tQ.push_back(make_pair(tmp.first,tmp.second-(tot-b)));\n\t\t\t\ttoJ-=(tot-b)*tmp.first;\n\t\t\t\ttot-=(tot-b);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.12f\\n\",toJ/b);\n\t\tif(i<a-1){\n\t\t\twhile(tot>b-t[i+1]){\n\t\t\t\tpair<double,int> tmp=Q.back();\n\t\t\t\tQ.pop_back();\n\t\t\t\tif(tmp.second<=(tot-b+t[i+1])){\n\t\t\t\t\ttoJ-=tmp.second*tmp.first;\n\t\t\t\t\ttot-=tmp.second;\n\t\t\t\t}else{\n\t\t\t\t\tQ.push_back(make_pair(tmp.first,tmp.second-(tot-b+t[i+1])));\n\t\t\t\t\ttoJ-=(tot-b+t[i+1])*tmp.first;\n\t\t\t\t\ttot-=(tot-b+t[i+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing plint = pair<double, double>;\n\nint N;\ndouble L;\n\ndeque<plint> deq;\ndouble Qsum = 0;\ndouble Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        double nuku = min(Vnow - L, deq.front().second);\n        deq.front().second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq.front().first;\n        if (deq.front().second < 1E-5) deq.pop_front();\n    }\n}\n\nvoid add(double tadd, double vadd)\n{\n    if (deq.back().first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        deq.push_back(plint(tadd, vadd));\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq.back().second + vadd >= L)\n        {\n            Qsum = deq.back().first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            deq.clear();\n            deq.push_back(plint(Qsum / L, L));\n        }\n        else\n        {\n            double Qaddnew = deq.back().first * deq.back().second + tadd * vadd;\n            double vaddnew = deq.back().second + vadd;\n            Qsum -= deq.back().first * deq.back().second;\n            Vnow -= deq.back().second;\n            deq.pop_back();\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\nvoid print()\n{\n    cout << setprecision(12) << Qsum / L << endl;\n}\nint main()\n{\n    cin >> N >> L;\n    REP(_, N)\n    {\n        double t, v;\n        cin >> t >> v;\n        if (_ == 0)\n        {\n            deq.push_back(plint(t, v));\n            Qsum = t * v;\n            Vnow = v;\n            print();\n        }\n        else\n        {\n            add(t, v);\n            print();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6\nvector<pair<DB, DB> > W;\nvector<DB> S;\nint w0; DB s0;\n// degree, V\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W[w0].se);\n        V = ((V*ll) - d*W[w0].fi) / (ll-d);\n        l -= d; W[w0].se -= d;\n        if (!sgn(W[w0].se)) w0++;\n        ll -= d;\n    }\n    s0 += l;\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\nvoid gao(){\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l)); w0 = 0;\n    \n    FOR(i, 1, n){\n        RD(v, l); pop(l); push(v, l);\n        \n        DB r = 0;\n        while (W.rbegin()->fi > V){\n            r += W.rbegin()->se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n            W.push_back(MP(V, r));\n        }\n        OT(V);\n        \n        //int p = lower_bound(W.begin() + w0, W.end(), V) - W.begin();\n        //DB ss = p > w0 ? S[p-1]-s0 : 0;\n        \n    }\n}\nint main(){\n    \n\n    RD(n, L);\n    gao();\n    /*REP(i, n){\n        LL t, v; RD(v, t);\n        if (i){\n            DB tt = t, ll = L;\n            \n            while (sgn(tt)){\n                pair<DB, DB> z = Q.top(); Q.pop();\n                DB d = min(tt, z.se);\n                \n                cout << z.fi << \" \" << z.se << endl;\n                \n                // ((ll-d)*vv' + d*z.fi) / ll = vv\n                \n                vv = ((vv*ll) - d*-z.fi) / (ll-d);\n\n                \n                tt -= d, z.se -= d;\n                if (sgn(z.se)){\n                    Q.push(MP(z.fi, z.se));\n                }\n                ll -= d;\n            }\n            vv = ((L-t)*vv + t*v) / L;\n        }\n        else{\n            vv = v;\n        }\n        Q.push(MP(-v, t));\n        OT(vv);\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(num,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  double sum = 0;\n  deque<pair<double, double>> Q;\n  for (int i = 0; i < n; ++i) {\n    double T, V;\n    scanf(\"%lf%lf\", &T, &V);\n    if (i > 0) {\n      double rem = V;\n      while (rem > 0) {\n        if (Q.front().first > rem)  {\n          Q.front().first -= rem;\n          sum -= rem * Q.front().second;\n          break;\n        } else {\n          rem -= Q.front().first;\n          sum -= Q.front().first * Q.front().second;\n          Q.pop_front();\n        }\n      }\n    }\n    // trace(i);\n    // for (auto& it : Q) {\n    //   trace(it.first, it.second);\n    // }\n    while (Q.size() && Q.back().second > T) {\n      double V2 = Q.back().first, T2 = Q.back().second;\n      Q.pop_back();\n      sum -= V2 * T2;\n      T = (V2 * T2 + V * T) / (V2 + V);\n      V += V2;\n    }\n    Q.push_back({V, T});\n    sum += V * T;\n    printf(\"%.10f\\n\", sum / m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <deque> \nusing namespace std;\n\nint main()\n{\n    // 整数の入力\n    long long  N,V,L,i,j;\n    double T;\n    double totalQ;\n    cin >> N >> L;\n    deque<int> VList;\n    deque<double> TList;\n\n    cin >> T >> V;\n    TList.push_front(T);\n    VList.push_front(V);\n    totalQ = T*V;\n    cout << fixed << T << endl;\n    for (i=1;i<N;i++){\n        cin >> T >> V;\n        int tempV = V;\n        while (tempV> 0){\n            if (tempV >= VList.back()){\n                tempV = tempV- VList.back();\n                totalQ = totalQ - VList.back() * TList.back();\n                VList.pop_back();\n                TList.pop_back();\n            }else{\n                VList.back() = VList.back() - tempV;\n                totalQ = totalQ - tempV * TList.back();\n                tempV = 0;\n            }\n        }\n\n        if (VList.size() == 0){\n            TList.push_front(T);\n            VList.push_front(V);\n            totalQ = T*V;\n        }else{\n            totalQ += T*V;\n            while (!TList.empty() && T <= TList[0]){\n                T = (T*V+TList[0]*VList[0])/(V+VList[0]);\n                V = V+VList[0];\n                TList.pop_front();\n                VList.pop_front();\n            }\n            TList.push_front(T);\n            VList.push_front(V);\n        }\n\n        cout << fixed << totalQ/L << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<double,double>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tint l=as[j].second;\n\t\t\tint val=as[j].first*l;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tdouble val=0;\n\t\t\tint l=0;\n\t\t\tfor(int i=vcnt-101;i<vcnt-1;i++){\n\t\t\t\tval=(v[i].first)/l+(val)/v[i].second;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tint ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b)/(b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst double eps=1e-9;\nconst int inf=0x3f3f3f3f;\nconst int N=200005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nstruct node{double x,y;}now,q[N];\nint n,L,head=100001,tail=100000;\n\ninline node operator + (const node &a,const node &b){return (node){a.x+b.x,a.y+b.y};}\ninline node operator - (const node &a,const node &b){return (node){a.x-b.x,a.y-b.y};}\ninline node operator * (const node &a,const double &b){return (node){a.x*b,a.y*b};}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++){\n\t\tnode p;scanf(\"%lf%lf\",&p.y,&p.x);\n\t\tp.y*=p.x;now=now+p;\n\t\twhile(head<=tail&&now.x>L+eps)\n\t\t\tif(now.x-q[tail].x>L+eps) tail--,now=now-q[tail]; else{\n\t\t\t\tnode tmp=q[tail];tail--;\n\t\t\t\tnow=now-tmp;\n\t\t\t\tq[tail+1]=tmp*((L-now.x)/tmp.x);\n\t\t\t\ttail++;now=now+q[tail];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tprintf(\"%.9f\\n\",now.y/now.x);\n\t\twhile(head<=tail&&p.y/p.x<q[head].y/q[head].x) p=p+q[head],head++;\n\t\tq[--head]=p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point\n{\n\tdouble x,y;\n\tfriend point operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\n\tfriend point operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\n\tfriend double operator *(point a,point b){return a.x*b.y-a.y*b.x;}\n}a[2000010];\npoint gp(point p,point q,double x)\n{\n\treturn (point){x,(p.y*(q.x-x)+q.y*(x-p.x))/(q.x-p.x)};\n}\nint main()\n{\n\tint n,l,head=1,tail=1;a[1]=(point){0.0,0.0};\n\tscanf(\"%d%d\",&n,&l);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tpoint p;scanf(\"%lf%lf\",&p.y,&p.x);p.y*=p.x;\n\t\thead++;a[head]=a[head-1]-p;\n\t\twhile ((head!=tail)&&(a[tail+1].x-a[head].x>l)) tail++;\n\t\tif (a[tail].x-a[head].x>l) a[tail]=gp(a[tail],a[tail+1],a[head].x+l);\t\n\t\twhile ((tail+1<head)&&((a[head]-a[head-2])*(a[head-1]-a[head-2])>0)) {a[head-1]=a[head];head--;}\n\t\tprintf(\"%.10lf\\n\",(a[tail].y-a[head].y)/l);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,LL> P;\n\nint N;\ndouble L;\nint main() {\n\tcout.precision(17);\n\tcin >> N >> L;\n\tdouble sum=0;\n\tLL sumv=0;\n\tdeque<P> q;\n\tfor(int i=0;i<N;i++){\n\t\tdouble t;\n\t\tLL v;\n\t\tcin >> t;\n\t\tcin >> v;\n\t\tsum+=t*v;\n\t\tsumv+=v;\n\t\twhile(q.size()&&q.back().first>t&&v<L){\n\t\t\t//cerr << t << \", \" << v << endl;\n\t\t\tif(q.back().second+v>=L){\n\t\t\t\tt=(v*t+(L-v)*q.back().first)/L;\n\t\t\t\tq.back().second-=L-v;\n\t\t\t\tv=L;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tauto v2=v+q.back().second;\n\t\t\t\tt=(v*t+q.back().second*q.back().first)/v2;\n\t\t\t\tv=v2;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t}\n\t\t//cerr << t << \", \" << v << endl;\n\t\tq.push_back(P(t,v));\n\t\twhile(sumv>L){\n\t\t\tif(sumv-q.front().second>=L){\n\t\t\t\tsumv-=q.front().second;\n\t\t\t\tsum-=q.front().first*q.front().second;\n\t\t\t\tq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL d=sumv-L;\n\t\t\t\tsumv-=d;\n\t\t\t\tsum-=q.front().first*d;\n\t\t\t\tq.front().second-=d;\n\t\t\t}\n\t\t}\n\t\tcout << sum/L << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1e6+10;\nint n,m,L;\nconst double eps=1e-9;\ndouble t[N],v[N];\nstruct point{\n\tdouble x,y;\n\tpoint(double X=0,double Y=0){x=X;y=Y;}\n\tpoint operator + (point a){\n\t\treturn point(x+a.x,y+a.y);\n\t}\n\tpoint operator - (point a){\n\t\treturn point(x-a.x,y-a.y);\n\t}\n\tdouble operator * (point a){\n\t\treturn x*a.y-y*a.x;\n\t}\n}q[N],vec;\nbool check(point x,point y,point z){\n\treturn (y-x)*(z-y)<0;\n}\ndouble K(point x,point y){\n\treturn (x.y-y.y)/(x.x-y.x);\n}\nint head,tail;\nint main()\n{\n\tscanf(\"%d%d\",&n,&L);\n\tfor (int i=1;i<=n;i++) scanf(\"%lf%lf\",&t[i],&v[i]);\n\tq[head=tail=n]=point(0,0);\n\tq[++tail]=point(v[1],v[1]*t[1]);\n\tfor (int i=1;i<=n;i++){\n\t\tvec=vec+point(v[i],v[i]*t[i]);\n\t\twhile (q[tail].x+vec.x>L+eps) tail--;\n\t\tdouble k=K(q[tail],q[tail+1]),y=q[tail].y+k*(L-q[tail].x-vec.x);\n\t\tq[++tail]=point(L-vec.x,y);\n\t\tprintf(\"%.7lf\\n\",(q[tail].y+vec.y)/L);\n\t\tpoint now(-vec.x,-vec.y);\n\t\tfor (;head<tail&&!check(now,q[head],q[head+1]);head++);\n\t\tq[--head]=now;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        int lim = (i % 400 == 0 ? 12341234 : 405);\n        for (int i = 1; i < min((int)q.size(), lim); ++i) {\n            int v = q[0];\n            int u = q[i];\n            if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                forn(_, i) q.pop_front();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1*d1.front().second;\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    totv-=d1.front().first;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n      \n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                //totprod-=(long double)1*d1.back().first*d1.back().second;\n                double tempp = (long double)1*tempv*tempt;\n                tempp+=(long double)1*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1*tempp)/((long double)1*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n         //   totprod+=(long double)1*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#define N 500005\nusing namespace std;\ntypedef long long ll;\nstruct P{\n\tdouble t;\n\tll v;\n}a[N],q[N];\nint n,L;\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++) scanf(\"%lf%lld\",&a[i].t,&a[i].v);\n\tint tou=1,wei=1;\n\tll sum=a[1].v;\n\tdouble T=a[1].t*a[1].v;\n\tq[1]=a[1];\n\tprintf(\"%.8lf\\n\",a[1].t);\n\tfor(int i=2;i<=n;i++){\n\t\tsum+=a[i].v;T+=a[i].t*a[i].v;\n\t\twhile(sum>L){\n\t\t\tif(q[tou].v>sum-L) q[tou].v-=sum-L,T-=q[tou].t*(sum-L),sum=L;\n\t\t\telse sum-=q[tou].v,T-=q[tou].t*q[tou].v,tou++;\n\t\t}\n\t\tll v=a[i].v;double t=a[i].t;\n\t\twhile(tou<=wei&&t<q[wei].t){\n\t\t\tt=(t*v+q[wei].t*q[wei].v)/(v+q[wei].v);\n\t\t\tv+=q[wei].v;\n\t\t\twei--;\n\t\t}\n\t\tq[++wei].t=t;q[wei].v=v;\n\t\tprintf(\"%.8lf\\n\",T/sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <double,int>  PDI;\nint n,l;\ndouble s;\ndeque <PDI> Q;\nPDI x;\n\nvoid work()\n{\n\tscanf(\"%d %d\",&n,&l);\n\tdouble t;\n\tfor (int i=1,r,v; i<=n; i++)\n\t\t{\n\t\t\tscanf(\"%lf %d\",&t,&v),s+=t*v,r=(i==1?0:v);\n\t\t\twhile (r)\n\t\t\t\t{\n\t\t\t\t\tx=Q.front(),Q.pop_front();\n\t\t\t\t\ts-=x.first*min(r,x.second);\n\t\t\t\t\tif (r<x.second)  x.second-=v,r=0,Q.push_front(x);\n\t\t\t\t\telse  r-=x.second;\n\t\t\t\t}\n\t\t\twhile ((!Q.empty())&&(Q.back().first>=t))\n\t\t\t\tx=Q.back(),Q.pop_back(),t=(t*v+x.first*x.second)/(v+x.second),v+=x.second;\n\t\t\tQ.push_back(make_pair(t,v));\n\t\t\tprintf(\"%lf\\n\",s/l);\n\t\t}\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\nint n,l;\ntypedef pair<ld,ld> wat;\nwat operator + (wat a,wat b)\n{return wat(a.fi+b.fi,a.se+b.se);}\nwat operator - (wat a,wat b)\n{return wat(a.fi-b.fi,a.se-b.se);}\nwat qs[666666],tot;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l); int h=0,t=0;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tll tt,v;\n\t\tscanf(\"%lld%lld\",&tt,&v);\n\t\twat cur(v,tt*v); tot=tot+cur;\n\t\twhile(tot.fi>l+1e-9)\n\t\t{\n\t\t\tld gg=tot.fi-l;\n\t\t\tif(gg>=qs[h].fi) {tot=tot-qs[h++]; continue;}\n\t\t\tld vv=gg*qs[h].se/qs[h].fi;\n\t\t\tqs[h].se-=vv; tot.se-=vv;\n\t\t\tqs[h].fi-=gg; tot.fi-=gg;\n\t\t}\n\t\twhile(h!=t&&qs[t-1].se/qs[t-1].fi>cur.se/cur.fi)\n\t\t\tcur=cur+qs[--t];\n\t\tqs[t++]=cur;\n\t\tprintf(\"%.10lf\\n\",tot.se/tot.fi);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.01.2020 03:51:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(17);\n  int n, l;\n  cin >> n >> l;\n  vector<pair<long double, long double>> a;\n  long double res = 0;\n  int i = 0;\n  auto Recalc = [&]() {\n    res = 0;\n    for (int j = i; j < (int) a.size(); j++) {\n      res += a[j].first * a[j].second;\n    }\n  };\n  for (int it = 0; it < n; it++) {\n    long double t, v;\n    cin >> t >> v;\n    long double rm = (it == 0 ? 0 : v);\n    while (i < (int) a.size()) {\n      if (rm > a[i].second) {\n        rm -= a[i].second;\n        if (res > a[i].first * a[i].second * 2) {\n          res -= a[i].first * a[i].second;\n          ++i;\n        } else {\n          ++i;\n          Recalc();\n        } \n      } else {\n        a[i].second -= rm;\n        if (res > a[i].first * rm * 2) {\n          res -= a[i].first * rm;\n        } else {\n          Recalc();\n        }\n        break;\n      }\n    }\n    res += t * v;\n    while (!a.empty() && a.back().first > t) {\n      t = (t * v + a.back().first * a.back().second) / (v + a.back().second);\n      v += a.back().second;\n      a.pop_back();\n    }\n    a.emplace_back(t, v);\n    cout << res / l << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nll l,r;\ninline void merge(Vector &a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n}\nint main()\n{\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(ll i=1;i<=n;i++)\n\t{\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L)\n\t\t{\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) merge(q[r-1],q[r]),--r;//和前面温度大的合并，减少损失 \n        printf(\"%lf\\n\",(db)y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ld> pairID;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nll N, L;\ndeque<pairID> A;\n\nint main(int argc, char *argv[])\n{\n    ll t, v;\n    ld total_heat;\n\n    scanf(\"%lld%lld\", &N, &L);\n    scanf(\"%lld%lld\", &t, &v);\n    \n    A.push_front(make_pair(v, t));\n    total_heat = (ld)v * t;\n    printf(\"%.7f\\n\", (double)total_heat / L);\n    \n    FOR1(i,1,N) {\n        pairID back;\n        ll vol;\n\n        scanf(\"%lld%lld\", &t, &v);\n        total_heat += (ld)v * t;\n        \n        vol = v;\n        while (vol > 0) {\n            back = A.back();\n            A.pop_back();\n            vol -= back.first;\n            total_heat -= back.first * back.second;\n        }\n        if (vol != 0) {\n            A.push_back(make_pair(-vol, back.second));\n            total_heat += -vol * back.second;\n        }\n\n        ld heat = v * t;\n        vol = v;\n        while(A.size() > 0 && heat / vol <= A.front().second) {\n            heat += A.front().first * A.front().second;\n            vol += A.front().first;\n            A.pop_front();\n        }\n        A.push_front(make_pair(vol, heat / vol));\n\n        printf(\"%.7f\\n\", (double)total_heat / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifndef ONLINE_JUDGE\n#define dbg(x...) do{cout << \"\\033[32;1m\" << #x << \"->\" ; err(x);} while(0)\nvoid err(){cout << \"\\033[39;0m\" << endl;}\ntemplate<template<typename...> class T,typename t,typename... A>\nvoid err(T<t> a,A... x){for (auto v:a) cout << v << ' '; err(x...);}\ntemplate<typename T,typename... A>\nvoid err(T a,A... x){cout << a << ' '; err(x...);}\n#else\n#define dbg(...)\n#endif\ntypedef long long ll;\ntypedef pair<double,ll> pi;\ntypedef vector<int> vi;\ntemplate<class T> using vc=vector<T>;\ntemplate<class T> using vvc=vc<vc<T>>;\ntemplate<class T> void mkuni(vector<T>&v)\n{\n    sort(v.begin(),v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\ntemplate<class T>\nvoid print(T x,int suc=1)\n{\n    cout<<x;\n    if(suc==1) cout<<'\\n';\n    else cout<<' ';\n}\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1)\n{\n    for(int i=0;i<v.size();i++)\n        print(v[i],i==(int)(v.size())-1?suc:2);\n}\nconst int INF=0x3f3f3f3f;\n\nint main()\n{\n    int n,l;\n    scanf(\"%d%d\",&n,&l);\n    deque<pi> dq;\n    double ans=0;\n    for(int i=0;i<n;i++)\n    {\n        ll t,v;\n        scanf(\"%lld%lld\",&t,&v);\n        ll tmp=v;\n        double tv=t*v;\n        ll cur=(i?tmp:0);\n        while(cur&&dq.front().second<=cur)\n        {\n            //dbg(cur,dq.front().second);\n            cur-=dq.front().second;\n            ans-=dq.front().first;\n            dq.pop_front();\n        }\n        if(dq.size())\n        {\n            ans-=(long double)1.0*dq.front().first/dq.front().second*cur;\n            dq.front().first-=dq.front().first/dq.front().second*cur;\n            dq.front().second-=cur;\n        }\n        if(dq.size())\n        //dbg(dq.front().second,ans);\n        while(dq.size()&&(__int128)dq.back().first*v>=(__int128)tv*dq.back().second)\n        {\n            tv+=dq.back().first;\n            v+=dq.back().second;\n            ans-=dq.back().first;\n            dq.pop_back();\n        }\n        //dbg(tv,v);\n        dq.push_back(make_pair(tv,v));\n        ans+=tv;\n        //dbg(ans);\n        printf(\"%.10f\\n\",1.0*ans/l);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef LOCAL\n#define NDEBUG 1\n#endif\n#include<bits/stdc++.h>\n\nstruct point{\n\tdouble volume, value;\n\tpoint constexpr operator+(point other) const{return{volume+other.volume, value+other.value};}\n\tpoint constexpr operator-(point other) const{return{volume-other.volume, value-other.value};}\n\tpoint constexpr operator-() const{return{-volume, -value};}\n\tauto constexpr cross(point other) const{ return volume*other.value-value*other.volume; }\n};\n\nint main(){\n\tstd::ios::sync_with_stdio(0);std::cin.tie(0);\n\tint number, capacity; std::cin>>number>>capacity;\n\tassert(capacity>0);\n\n\tstd::deque<point> points{ {0, 0},{(double)capacity, 0} }; // sort by volume\n\tpoint offset{};\n\n\tstd::cout<<std::fixed<<std::setprecision(7);\n\tfor(int _=0; _<number; ++_){\n\t\tint64_t volume, temp; std::cin>>temp>>volume;\n\t\tassert(volume>0);\n\t\toffset.volume+=volume;\n\t\toffset.value+=volume*temp;\n\n\t\twhile(points.size()>=2 and points.end()[-2].volume+offset.volume>=capacity)\n\t\t\tpoints.pop_back();\n\t\tif(points.back().volume+offset.volume>capacity){\n\t\t\tauto const a=points.end()[-2], b=points.back();\n\t\t\tauto const x=capacity-offset.volume;\n\t\t\tpoints.back()={x,\n\t\t\t\tdouble(b.value*(x-a.volume) + a.value*(b.volume-x))/double(b.volume-a.volume)\n\t\t\t};\n\t\t}\n\n\n\t\twhile(points.size()>=2 and (points[0]+offset).cross(points[1]+offset)>=0)\n\t\t\tpoints.pop_front();\n\t\tpoints.push_front(-offset);\n\n\n\t\tstd::cout<<\n\t\t\t(points.back()+offset).value/capacity\n\t\t\t<<'\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * (ld)tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\t\tsum += t * (ld)v;\n\n\t\tif (dq.empty() || dq.back().first < t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * (ld)dq.back().second + t * (ld)v) / (ld)(dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(12) << sum / (ld)L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 500200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\ntypedef double db;\nstruct T {\n\tdb a, b;\n\tinline void operator += (const T & y) { a += y.a, b += y.b; }\n\tinline void operator -= (const T & y) { a -= y.a, b -= y.b; }\n\tinline int operator < (const T & y) const { return a / b < y.a / y.b; }\n} stack[maxn], ps[maxn];\ndb pre_b[maxn];\nint n, L;\nint top;\ninline void ins(T x) {\n\tfor(;top && x < stack[top];) {\n\t\tif(stack[top].b + x.b > L) {\n\t\t\tdb rem = L - x.b, p = rem / stack[top].b;\n\t\t\tstack[top].a *= p;\n\t\t\tstack[top].b *= p;\n\t\t}\n\t\tx += stack[top--];\n\t}\n\tstack[++top] = x, pre_b[top] = pre_b[top - 1] + x.b;\n\tps[top] = ps[top - 1], ps[top] += x;\n}\ninline db lol(db x){ return x == x ? x : 0; }\ninline db get() {\n\tint x = std::upper_bound(pre_b + 1, pre_b + top + 1, pre_b[top] - L) - pre_b;\n\tT ans = ps[top]; ans -= ps[x];\n\treturn (ans.a + (L - ans.b) / stack[x].b * stack[x].a) / L;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> L;\n\trep(i, 1, n) {\n\t\tint t, v;\n\t\tcin >> t >> v;\n\t\tins((T){ (db) t * v, (db) v });\n\t\tprintf(\"%.7lf\\n\", get());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<deque>\n\nusing namespace std;\n\ndeque<pair<int,double> > Q;\n\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int n,l;\n    cin>>n>>l;\n\n    long long Vt=0;\n    double VTt=0.0;\n    for(int i=1; i<=n; i++)\n    {\n        int v;\n        double t;\n        cin>>t>>v;\n\n        Vt+=v;\n        VTt+=1.0*v*t;\n        while(Vt>l)\n        {\n            int elim=min(1LL*Q.front().first,Vt-l);\n            Vt-=elim;\n            VTt-=elim*Q.front().second;\n\n            if(elim==Q.front().first)\n                Q.pop_front();\n            else\n                Q.front().first-=elim;\n        }\n\n        cout<<setprecision(7)<<fixed<<1.0*VTt/l<<\"\\n\";\n\n        while(!Q.empty() && Q.back().second>t)\n        {\n            t=1.0*(t*v+Q.back().second*Q.back().first)/(v+Q.back().first);\n            v=v+Q.back().first;\n            Q.pop_back();\n        }\n        Q.push_back({v,t});\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define myp pair<db,db>\nusing namespace std;\nconst int N=5e5+10;\nint n,l;\nmyp q[N]; //pair<v,v*t> 比较时不会产生精度误差 \nint head,tail;\nint main(){\n\tdb v,t,temp_v=0,temp=0,now_t;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf%lf\",&t,&v);\n\t\tq[head++]=make_pair(v,v*t);\n\t\ttemp_v+=v,temp+=v*t;\n\t\twhile(temp_v>l){\n\t\t\tif(temp_v-q[tail].first>=l) temp_v-=q[tail].first,temp-=q[tail].second,tail++;\n\t\t\telse now_t=q[tail].second/q[tail].first,q[tail].first-=temp_v-l,temp_v=l,temp=temp-q[tail].second+now_t*q[tail].first,q[tail].second=now_t*q[tail].first;\n\t\t}\n\t\tif(head-2>=tail&&q[head-1].second/q[head-1].first<q[head-2].second/q[head-2].first) q[head-2].first+=q[head-1].first,q[head-2].second+=q[head-1].second,head--;\n\t\tprintf(\"%.8lf\\n\",temp/temp_v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > q;\nint n, L;\n\nint main(void) {\n  scanf(\"%d%d\", &n, &L);\n  double Ans = 0;\n  for(int i = 1, t, v; i <= n; i++) {\n    scanf(\"%d%d\", &t, &v);\n    int res = v;\n    while(!q.empty()) {\n      pair<double, int> x = q.top(); q.pop();\n      if(x.second >= res) {\n\tx.second -= res;\n\tAns -= 1LL * res * x.first;\n\tq.push(x);\n\tbreak;\n      } else\n\tAns -= 1LL * x.second * x.first, res -= x.second;\n    }\n    Ans += 1LL * t * v;\n    printf(\"%.10f\\n\", (double)Ans / L);\n    q.push(make_pair(Ans / L, L));\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 5e+5+5;\n\nint n,L;\nstruct key_point{\n\tint tim;\n\tdb x,y;\n\tkey_point(const int tim_=0,const db x_=0,const db y_=0){tim=tim_;x=x_;y=y_;}\n}a[N];\nint he,ta;\nLL prex[N],prey[N];\n\nkey_point getpoint(key_point u,int i){\n\tu.x=u.x+prex[i]-prex[u.tim];\n\tu.y=u.y+prey[i]-prey[u.tim];\n\treturn u;\n}\n\ndb get_tan(key_point u,int i){\n\treturn (u.y+prey[i]-prey[u.tim])/(u.x+prex[i]-prex[u.tim]);\n}\n\nint main(){\n\tn=get();L=get();\n\tfo(i,1,n){\n\t\tLL t=get(),v=get();\n\t\tprey[i]=prey[i-1]+t*v;\n\t\tprex[i]=prex[i-1]+v;\n\t}\n\tint he=n,ta=n;\n\ta[n]=key_point(0,0,0);\n\tfo(i,1,n){\n\t\twhile(he<ta&&a[ta].x+prex[i]-prex[a[ta].tim]>L+1e-7){\n\t\t\tif (a[ta-1].x+prex[i]-prex[a[ta-1].tim]>L+1e-7)ta--;\n\t\t\telse{\n\t\t\t\tkey_point u=getpoint(a[ta-1],i),v=getpoint(a[ta],i);\n\t\t\t\ta[ta].y=u.y+(v.y-u.y)/(v.x-u.x)*(1.0*L-u.x);\n\t\t\t\ta[ta].x=L;\n\t\t\t\ta[ta].tim=i;\n\t\t\t}\n\t\t}\n\t\twhile(he<ta&&get_tan(a[he],i)<get_tan(a[he+1],i))he++;\n\t\ta[--he]=key_point(i,0,0);\n\t\tprintf(\"%.7lf\\n\",getpoint(a[ta],i).y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V-= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RD(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define $(s) (int)((s).size())\n#define ALL(v) v.begin(), v.end()\n#define V vector\n#define pb push_back\n#define double long double\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst double EPS=1e-7;\n\nstruct water{double t,v;};\nconst water WARM_VOID={2e9,0};\nwater operator+(water w1, water w2) {\n    double v = w1.v + w2.v;\n    return {(w1.t*w1.v + w2.t*w2.v) / v, v};\n}\nwater operator-(water w1, water w2) {\n    double v = w1.v - w2.v;\n    return {(w1.t*w1.v - w2.t*w2.v) / v, v};\n}\n\nsigned main() {\n    //P(\"long double\");\n    int n; double l; cin>>n>>l;\n    water a[n];\n    F(i,n) cin>>a[i].t>>a[i].v;\n    water suff=WARM_VOID, rest=WARM_VOID, cand=WARM_VOID;\n    \n    F(i,n) {\n        rest = rest + a[i];\n        //D(rest.t), D(rest.v);\n        double excess = suff.v + rest.v - l;\n        while (excess > EPS) {\n            double torem = suff.v * min(1.0L, excess / suff.v);\n            //P(\"remove \"<<torem<<\" at \"<<suff.t);\n            suff.v -= torem;\n            excess -= torem;\n            if (suff.v < EPS) {\n                suff = cand;\n                rest = rest - cand;\n            }\n        }\n        printf(\"%.7Lf\\n\", (suff+rest).t);\n        \n        if (rest.t < suff.t) {\n            //P(\"rest is very cold\");\n            suff = suff + rest;\n            rest = cand = WARM_VOID;\n        } else if (rest.t < cand.t) {\n            //P(\"not that cold, but candidate\");\n            cand = rest;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define C\ntypedef long long readtype;\n\n/* Header {{{ */\n#ifdef C\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#define isdigit(a) ((a) >= '0' && (a) <= '9' ? true : false)\ntemplate<typename type> type abs(type a) { return a < 0 ? -a : a; }\ntemplate<typename type> type min(type a, type b) { return a < b ? a : b; }\ntemplate<typename type> type beMin(type &a, type b) { return a = (a < b ? a : b); }\ntemplate<typename type> type max(type a, type b) { return a > b ? a : b; }\ntemplate<typename type> type beMax(type &a, type b) { return a = (a > b ? a : b); }\ntemplate<typename type> void swap(type &a, type &b) { type c; c = a; a = b; b = c; }\n#endif\n\n#ifdef Cpp\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n\ntypedef long long var;\n\nreadtype read() {\n  readtype a = 0, c = getchar(), s = 0;\n  while (!isdigit(c)) s |= c == '-', c = getchar();\n  while (isdigit(c)) a = a * 10 + c - 48, c = getchar();\n  return s ? -a : a;\n}\n/* }}} */\n\nconst int N = 510005;\n\nstruct Water {\n  long double t, v;\n  void operator *= (Water x) { *this = *this * x; }\n  Water operator * (Water x) {\n    return (Water) {(t * v + x.t * x.v) / (v + x.v), v + x.v};\n  }\n};\n\nint n, l;\nWater q[N];\nint head, tail;\n\nlong double val(Water);\n\nint main() {\n  /*\n#ifndef ONLINE_JUDGE\n  freopen(\"source.in\", \"r\", stdin);\n  freopen(\"source.out\", \"w\", stdout);\n#endif\n  */\n  n = read(), l = read();\n  long double tot = 0, have = 0;\n  for (int i = 1; i <= n; ++i) {\n    q[++tail] = (Water) {(long double)read(), (long double)read()};\n    tot += val(q[tail]), have += q[tail].v;\n    while (head < tail && q[tail].t <= q[tail - 1].t) {\n      if (q[tail].v + q[tail - 1].v <= l) {\n        tot -= val(q[tail]) + val(q[tail - 1]);\n        q[tail - 1] *= q[tail];\n        tot += val(q[tail - 1]);\n      } else {\n        head = tail - 1;\n        q[head].v = l - q[tail].v;\n        q[head] *= q[tail];\n        have = l, tot = val(q[head]);\n      }\n      tail--;\n    }\n    while (have > l) {\n      if (have - q[head].v >= l) {\n        tot -= val(q[head]), have -= q[head].v;\n      } else {\n        tot -= val(q[head]);\n        q[head].v -= (have - l);\n        tot += val(q[head]);\n        have = l;\n        break;\n      }\n      head++;\n    }\n    printf(\"%.7Lf\\n\", tot / have);\n  }\n  return 0;\n}\n\nlong double val(Water x) {\n  return x.t * x.v;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define P(x) cout << x << endl\n#define D(x) P(#x << \": \" << x)\n#define F(i,n) for (int i=0; i<(int)(n); i++)\n#define DEC(i,n) for (int i=(int)(n); --i>=0;)\n#define S(s) (int)((s).size())\n#define ALL(v) v.begin(), v.end()\n#define V vector\n#define pb push_back\n#define double long double\nusing namespace std;\nvoid MI(int &a, int v) {a = min(a,v);}\nvoid MA(int &a, int v) {a = max(a,v);}\nconst double EPS=1e-7;\n\nstruct water{double t,v;};\nconst water WARM_VOID={2e9,0};\nwater operator+(water w1, water w2) {\n    double v = w1.v + w2.v;\n    return {(w1.t*w1.v + w2.t*w2.v) / v, v};\n}\nwater operator-(water w1, water w2) {\n    double v = w1.v - w2.v;\n    return {(w1.t*w1.v - w2.t*w2.v) / v, v};\n}\n\nsigned main() {\n    //P(\"long double\");\n    int n; double l; cin>>n>>l;\n    //water a[n];\n    //F(i,n) cin>>a[i].t>>a[i].v;\n    water total=WARM_VOID;\n    deque<water> d;\n    \n    F(i,n) {\n        water cur; cin>>cur.t>>cur.v;\n        total = total + cur;\n        //D(rest.t), D(rest.v);\n        while (total.v - l > EPS) {\n            water torem = {d.front().t, min(d.front().v, total.v - l)};\n            //P(\"remove \"<<torem<<\" at \"<<suff.t);\n            d.front() = d.front() - torem;\n            total = total - torem;\n            if (d.front().v < EPS)\n                d.pop_front();\n        }\n        printf(\"%.7Lf\\n\", total.t);\n        \n        while (S(d) && cur.t < d.back().t) {\n            cur = cur + d.back();\n            d.pop_back();\n        }\n        d.pb(cur);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvoid read(ll &rem){\n\trem = 0; char c = getchar();\n\twhile(c<'0'||c>'9') c = getchar();\n\twhile(c>='0'&&c<='9') rem = rem*10+c-48, c = getchar();\n}\n\ndouble tem[100050];\nll v[100050], cnt, head = 1;\n\nint main(){\n\tll T, L, nt, nv;\n\tread(T), read(L);\n\twhile(T--){\n\t\tscanf(\"%lld %lld\", &nt, &nv);\n\t\ttem[++cnt] = nt;\n\t\tv[cnt] = nv;\n\t\tll p = 0, k = cnt, ans = 0;\n\t\twhile(p+v[k] <= L && k >= head) {\n\t\t\tp+=v[k], ans += tem[k] * v[k], k--;\n\t\t}\n\t\tif(p<L){\n\t\t\thead = k;\n\t\t\tv[head] = L-p;\n\t\t\tans += v[head] * tem[head];\n\t\t}\n\t\telse head = k+1;\n\t\tprintf(\"%.8f\\n\", 1.0 * ans / L);\n\t\twhile(tem[cnt] <= tem[cnt-1] && cnt-1 >= head){\n\t\t\ttem[cnt-1] = 1.0 * (v[cnt] * tem[cnt] + v[cnt-1] * tem[cnt-1]) / (v[cnt] + v[cnt-1]);\n\t\t\tv[cnt-1] += v[cnt];\n\t\t\tcnt--;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || q < V.size() || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t\ts -= d * x;\n\t\t\t\tV.pop_back();\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=500010;\nstruct water{\n\tdouble t;\n\tint v;\n\tinline friend water operator + (const water &a,const water &b){\n\t\tint sum=a.v+b.v;\n\t\tif(sum==0)return (water){0,0};\n\t\treturn (water){a.t*((double)a.v/sum)+b.t*((double)b.v/sum),sum};\n\t}\n\tinline void operator += (const water &b){\n\t\t*this=*this+b;\n\t}\n\tinline void operator -= (const water &b){\n\t\t*this+=(water){b.t,-b.v};\n\t}\n}que[N],cur;\nint main(){\n\tint n=ni,v=ni;\n\tint qh=0,qt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint tmp=ni;\n\t\twater a=(water){(double)tmp,ni};\n\t\tfor(;cur.v+a.v>v&&cur.v+a.v-que[qh].v>=v;cur-=que[qh++]);\n\t\tif(cur.v+a.v>v){\n\t\t\tque[qh].v-=cur.v+a.v-v;\n\t\t\tcur-=(water){que[qh].t,cur.v+a.v-v};\n\t\t}\n\t\tcur+=a;\n\t\tprintf(\"%.10lf\\n\",cur.t);\n\t\tfor(;qh<qt&&que[qt-1].t>tmp;a+=que[--qt]);\n\t\tque[qt++]=a;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=500007;\n\ntypedef std::pair<int,llf> data;\n\nint n,m,s[N],t[N];\nstd::list<data>q;\n\ninline data merge(data a,data b)\n{\n\treturn mp(a.xx+b.xx,(a.yy*a.xx+b.yy*b.xx)/(a.xx+b.xx));\n}\n\nint main()\n{\n\tin,n,m;\n\tfo1(i,n)in,s[i],t[i];\n\tllf sum=0;\n\tq.pb(mp(m,0));\n\tfo1(i,n)\n\t{\n\t\tint c=0;\n\t\twhile(c<t[i])\n\t\t{\n\t\t\tif(q.back().xx<=t[i]-c)\n\t\t\t{\n\t\t\t\tsum-=q.back().xx*q.back().yy;\n\t\t\t\tc+=q.back().xx;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsum-=q.back().yy*(t[i]-c);\n\t\t\t\tdata v=q.back();\n\t\t\t\tv.xx-=t[i]-c;\n\t\t\t\tc=t[i];\n\t\t\t\tq.pop_back();\n\t\t\t\tq.pb(v);\n\t\t\t}\n\t\t}\n\t\t//out,'\\n';\n\t\t//printf(\"%.2lf\\n\",(lf)(sum/q.front().xx));\n\t\t//foe(j,q)printf(\"%d %.2lf\\n\",j->xx,(lf)j->yy);\n\t\tdata v=mp(t[i],s[i]);\n\t\twhile(q.size()&&v.yy<q.front().yy)\n\t\t\tv=merge(v,q.front()),q.pop_front();\n\t\tq.push_front(v);\n\t\tsum+=(ll)s[i]*t[i];\n\t\tprintf(\"%.10lf\\n\",(lf)(sum/m));\n\t\t//foe(j,q)printf(\"%d %.2lf\\n\",j->xx,(lf)j->yy);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//AtCoder-arc072F\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename _tp> inline void read(_tp&x) {\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 501000;\nint n, L;\n\nstruct node {\n\tdouble t, v;\n\tfriend inline node operator * (const node&A, const node&B) {\n\t\treturn (node) {(A.t*A.v + B.t*B.v) / (A.v + B.v), A.v + B.v};\n\t}\n} p[N];\n\nint main() {\n\tread(n), read(L);\n\tint l = 1, r = 0, t, v;\n\tdouble heat = 0, volume = 0;\n\tfor(int i=1;i<=n;++i) {\n\t\tread(t), read(v);\n\t\twhile(volume + v > L) {\n\t\t\tdouble dec = min(p[l].v, volume + v - L);\n\t\t\tvolume -= dec;\n\t\t\theat -= p[l].t * dec;\n\t\t\tif(!(p[l].v -= dec)) ++l;\n\t\t}\n\t\theat += (double)t * v, volume += v;\n\t\tp[++r] = (node) {t, v};\n\t\twhile(l < r and p[r-1].t > p[r].t) p[r-1] = p[r-1] * p[r], --r;\n\t\tprintf(\"%.7lf\\n\", (double)heat / volume);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nld t[1 << 19], v[1 << 19];\n\nvector<ld> ans;\nvoid solve() {\n\tint n; ld l;\n\tcin >> n >> l;\n\trep(i, n) {\n\t\tcin >> t[i] >> v[i];\n\t}\n\tld a = t[0], b = v[0];\n\tans.push_back(a);\n\n\tvector<LDP> vp;\n\tvector<ld> rs = { 0 }; ld sum = 0;\n\tvector<ld> rv = { 0 }; ld rsum = 0;\n\trep1(i, n - 1) {\n\t\tif (b + v[i] >= l) {\n\t\t\tld z = l - v[i];\n\t\t\tld tt = (a * z + t[i] * v[i]) / l;\n\t\t\tans.push_back(tt);\n\t\t\tb = z;\n\t\t}\n\t\telse {\n\t\t\tld rest = l - b - v[i];\n\t\t\trest = sum - rest;\n\t\t\tint id = lower_bound(rs.begin(), rs.end(), rest) - rs.begin();\n\t\t\tid--;\n\t\t\tld nexr = rest - rs[id]; nexr = vp[id].second - rest;\n\t\t\tld tt = a * b + t[i] * v[i];\n\t\t\t//cout << tt << \" a\"<<endl;\n\t\t\ttt += vp[id].first*nexr;\n\t\t\ttt += rsum - rv[id + 1];\n\t\t\t//cout << tt << \" a\" << endl;\n\t\t\tans.push_back(tt / l);\n\t\t}\n\t\tif (a >= t[i]) {\n\t\t\ta = (a*b+t[i]*v[i])/ (b + v[i]);\n\t\t\tb = b + v[i];\n\t\t}\n\t\telse {\n\t\t\tvp.push_back({ a,b }); sum += b;\n\t\t\tld z = rs.back(); rs.push_back(z + b); rsum += a * b;\n\t\t\tz = rv.back(); rv.push_back(z + a * b);\n\t\t\ta = t[i], b = v[i];\n\t\t}\n\t}\n\trep(i, n) {\n\t\tcout << ans[i] << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//deque<pair<ld,int> > water;\n//int cur_volume;\n//ld total_heat;\n//void clear_to(int max_volume){\n//    int need_remove = max(0,cur_volume-max_volume);\n//    while(need_remove){\n//        if(water.back().Y > need_remove){\n//            water.back().Y -= need_remove;\n//            cur_volume -= need_remove;\n//            total_heat -= need_remove*water.back().X;\n//            return;\n//        }\n//        else{\n//            total_heat -= water.back().X*water.back().Y;\n//            need_remove -= water.back().Y;\n//            cur_volume -= water.back().Y;\n//            water.pop_back();\n//        }\n//    }\n//}\n//void mix_in(ld temp, int volume){\n//    while(!water.empty() && temp < water.front().X){\n//        ld new_temp = (temp*volume+water.front().X*water.front().Y)\n//            /(volume+water.front().Y);\n//        volume += water.front().Y;\n//        temp = new_temp;\n//        cur_volume -= water.front().Y;\n//        total_heat -= water.front().X*water.front().Y;\n//        water.pop_front();\n//    }\n//    water.push_front({temp,volume});\n//    cur_volume += water.front().Y;\n//    total_heat += water.front().X*water.front().Y;\n//}\n//void _(){\n//    ll n,L;\n//    cin >> n >> L;\n//    vpll arr(n);\n//    cin >> arr;\n//    rep(i,0,n-1){\n//        clear_to(L-arr[i].Y);\n//        mix_in(arr[i].X,arr[i].Y);\n//        print(total_heat/cur_volume);\n//    }\n//}\n//\n#include <iomanip>\n#include <algorithm>\n#include <queue>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <iostream>\n#include <string>\n#define REP_INT(i,l,r) for(int i = l; i <= r; ++i)\n#define GET_REP_MACRO(_1,_2,_3,_4,NAME,...) NAME\n#define rep(...) GET_REP_MACRO(__VA_ARGS__,REP_ANY,REP_INT)(__VA_ARGS__)\n#define all(v) (v).begin(), (v).end()\n#define X first\n#define Y second\n#define T1 template<typename T> static\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> pll;\ntypedef vector<pll> vpll;\ntypedef long double ld;\ntemplate <typename F, typename S> static\nistream& operator>>(istream& stream, pair<F, S>& t){\n    return stream >> t.first >> t.second;\n}\nT1 ostream& operator<<(ostream& stream, const vector<T>& t);\nT1 istream& read(T, T, istream& = cin);\nT1 istream& operator>>(istream& stream, vector<T>& t){\n    return read(all(t), stream);\n}\nT1 istream& read(T b, T e, istream& stream){\n    for(T it = b; it != e; ++it)\n        stream >> *it;\n    return stream;\n}\nT1 void print(T x, string end = \"\\n\"){\n    cout << x << end;\n}\ndeque<pair<ld,int> > water;\nint cur_volume;\nld total_heat;\nvoid clear_to(int max_volume){\n    int need_remove = max(0,cur_volume-max_volume);\n    while(need_remove){\n        if(water.back().Y > need_remove){\n            water.back().Y -= need_remove;\n            cur_volume -= need_remove;\n            total_heat -= need_remove*water.back().X;\n            return;\n        }\n        else{\n            total_heat -= water.back().X*water.back().Y;\n            need_remove -= water.back().Y;\n            cur_volume -= water.back().Y;\n            water.pop_back();\n        }\n    }\n}\nvoid mix_in(ld temp, int volume){\n    while(!water.empty() && temp < water.front().X){\n        ld new_temp = (temp*volume+water.front().X*water.front().Y)\n            /(volume+water.front().Y);\n        volume += water.front().Y;\n        temp = new_temp;\n        cur_volume -= water.front().Y;\n        total_heat -= water.front().X*water.front().Y;\n        water.pop_front();\n    }\n    water.push_front({temp,volume});\n    cur_volume += water.front().Y;\n    total_heat += water.front().X*water.front().Y;\n}\nvoid _(){\n    ll n,L;\n    cin >> n >> L;\n    vpll arr(n);\n    cin >> arr;\n    rep(i,0,n-1){\n        clear_to(L-arr[i].Y);\n        mix_in(arr[i].X,arr[i].Y);\n        print(total_heat/cur_volume);\n    }\n}\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(15);\n        _();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;\n        double tt=0.0, vv=0.0;\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n\n        for(int i=0;i<N;i++){\n            ll t, v;\n            t=T[i];v=V[i];\n            while(v+vv>L){\n                ll t1=dp[0].first;\n                ll v1=dp[0].second;\n                double tmp=min(v+vv-L, (double)v1);\n                tt=(tt*vv-t1*tmp)/(vv-tmp);\n                vv=vv-tmp;\n                if(tmp==v1){\n                    dp.pop_front();\n                }\n                else {\n                    dp[0].first=t1;\n                    dp[0].second=v1-tmp;\n                }\n            }\n            tt=(tt*vv+t*v)/L;\n            vv=L;\n            printf(\"%.7llf\\n\", tt);\n            int ans=dp.size();\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2<t){\n                    break;\n                }\n                else {\n                    t=(t*v+t2*v2)/(v+v2);\n                    v=t2+v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(t, v));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 5e5 + 1e3;\n\nint n, L, fr = 1, tl;\n\nstruct water {\n\tdouble s; long long v;\n\tinline water friend operator + (const water &lhs, const water &rhs) {\n\t\treturn (water){(lhs.s * lhs.v + rhs.s * rhs.v) / (lhs.v + rhs.v), lhs.v + rhs.v};\n\t}\n\tinline water friend operator - (const water &lhs, const water &rhs) {\n\t\treturn (water){(lhs.s * lhs.v - rhs.s * rhs.v) / (lhs.v - rhs.v), lhs.v - rhs.v};\n\t}\n} q[N], res, now;\n\nint main () {\n\n\tFile();\n\n\tn = read(); L = read();\n\tFor (i, 1, n) {\n\t\tnow.s = read(); now.v = read(); res = res + now;\n\t\tfor (; fr <= tl && res.v > L; ++ fr) {\n\t\t\tif (res.v - L > q[fr].v) res = res - q[fr];\n\t\t\telse {\n\t\t\t\twater tmp = (water){q[fr].s, res.v - L};\n\t\t\t\tq[fr] = q[fr] - tmp; res = res - tmp; break;\n\t\t\t}\n\t\t}\n\t\tfor (q[++ tl] = now; fr + 1 <= tl; -- tl) {\n\t\t\tif (q[tl].s > q[tl - 1].s) break;\n\t\t\tq[tl - 1] = q[tl - 1] + q[tl];\n\t\t}\n\t\tprintf (\"%.6lf\\n\", res.s);\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst ll N=6e5+7;\n\nll d[N],M;\ndb t[N];\nint n;\n\ninline ll max(ll a,ll b)\n{return a>b?a:b;}\n\ninline ll read()\n{\n\tll o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+ch-48;\n\treturn o;\n}\n\nint main()\n{\n\tcin>>n>>M;\n\tint r=0,l=1,ok=0;\n\tdb zl=0; \n\tfo(i,1,n)\n\t{\n\t\tll T=read(),V=read();\n\t\td[++r]=V; t[r]=(db)T*V;\n\t\tzl+=t[r]; ok+=d[r];\n\t\tfor(;t[r]/d[r]<t[r-1]/d[r-1]&&l<r;--r)\n\t\tif(d[r-1]+d[r]<=M)t[r-1]=t[r-1]+t[r],d[r-1]+=d[r];\n\t\telse{\n\t\t\tt[r-1]=t[r]+(t[r-1]/d[r-1])*(M-d[r]);\n\t\t\tok=d[r-1]=M; zl=t[r-1]; --r; l=r;\n\t\t\tbreak;\n\t\t}\n\t\tfor(;ok>M;++l)\n\t\tif(ok-d[l]>=M)ok-=d[l],zl-=t[l];\n\t\telse{\n\t\t\tdb every=t[l]/d[l];\n\t\t\tzl-=every*(ok-M);\n\t\t\tt[l]-=every*(ok-M);\n\t\t\td[l]=d[l]-(ok-M);\n\t\t\tok=M; break;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",zl/M);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;\n        double tt=0.0, vv=0.0;\n\n        while(N--){\n            ll t, v;\n            cin>>t>>v;\n            while(v+vv>L){\n                ll t1=dp[0].first;\n                ll v1=dp[0].second;\n                ll tmp=min(v+vv-L, (double)v1);\n                tt=(tt*vv-t1*tmp)/(vv-tmp);\n                vv=vv-tmp;\n                if(tmp==v1){\n                    dp.pop_front();\n                }\n                else {\n                    dp[0].second=v1-tmp;\n                }\n            }\n            tt=(tt*vv+t*v)/L;\n            vv=L;\n            printf(\"%.7llf\\n\", tt);\n            int ans=dp.size();\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2<t){\n                    break;\n                }\n                else {\n                    t=(t*v+t2*v2)/(v+v2);\n                    v=t2+v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(t, v));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntemplate <typename A, typename B>\nostream& operator<<(ostream& os, const pair<A, B>& x) {\n\treturn os << \"(\" << x.first << \",\" << x.second << \")\";\n}\ntypedef long long ll;\ntypedef long double ld;\nint main() {\n\tint n, L;\n\tscanf(\"%d%d\", &n, &L);\n\tll sumv = 0;\n\tld sumtv = 0;\n\tdeque<pair<ll, ld>> deq;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tsumv += v;\n\t\tll tv = (ll)t * v;\n\t\tsumtv += tv;\n\t\tdeq.push_front({v, tv});\n\t\tassert(deq.size() >= 1);\n\t\twhile (sumv - deq.back().first >= L) {\n\t\t\tsumv -= deq.back().first;\n\t\t\tsumtv -= deq.back().second;\n\t\t\tdeq.pop_back();\n\t\t}\n\t\tif (sumv > L) {\n\t\t\tll remv = sumv - deq.back().first;\n\t\t\tld ntv = (L - remv) * deq.back().second / deq.back().first;\n\t\t\tsumtv = sumtv - deq.back().second + ntv;\n\t\t\tdeq.pop_back();\n\t\t\tdeq.push_back({L - remv, ntv});\n\t\t\tsumv = L;\n\t\t}\n\t\tprintf(\"%.9Lf\\n\", sumtv / L);\n\t\twhile (deq.size() >= 2) {\n\t\t\tauto f = deq.front();\n\t\t\tdeq.pop_front();\n\t\t\tauto g = deq.front();\n\t\t\tif (g.second / g.first >= f.second / f.first) {\n\t\t\t\tdeq.pop_front();\n\t\t\t\tdeq.push_front({g.first + f.first, g.second + f.second});\n\t\t\t} else {\n\t\t\t\tdeq.push_front(f);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-8;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = 500005;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    RD(n); RF(L); DB S=0,V=0;\n    DO(n){\n        DB t, v; RF(t), RF(v);\n        S+=(double)t*v; DB vv = v;\n        while (v && head<tail) {\n            if (v>=q[head][0]) {\n                v-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=v; S-=v*q[head][1];\n                break;\n            }\n        }\n        v = vv;\n        V = L;\n        \n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        for (int i = 1; i < min((int)q.size(), 300); ++i) {\n            int v = q[0];\n            int u = q[i];\n            if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                forn(_, i) q.pop_front();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+25;\nlong long l,r,tott,tem[N],vol[N],n,L,sum;\nstruct dsa{\n\tlong long v;\n\tdouble t;\n} a[N];\nint main(){\n\tcin>>n>>L;\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&tem[i],&vol[i]);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(sum+vol[i]>L){//当水溢出时，优先把单调队列的前几份水排空 \n\t        int rea=min(sum+vol[i]-L,a[l].v);\n\t        a[l].v-=rea;\n\t        sum-=rea;\n\t        tott-=rea*a[l].t;\n\t        if(!a[l].v) l++;\n\t\t}\n\t\tsum+=vol[i];\n\t\ttott+=vol[i]*tem[i];\n\t\ta[++r].v=vol[i];\n\t\ta[r].t=tem[i];\n\t\twhile(l<r&&a[r].t<a[r-1].t){//考虑混合 \n\t\t\ta[r-1].t=(a[r].t*a[r].v+a[r-1].t*a[r-1].v)/(a[r-1].v+a[r].v);\n\t\t\ta[r-1].v=a[r-1].v+a[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",(double)tott/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        ll tt=0, vv=0;\n        for(int i=0;i<N;i++){\n            ll t=T[i]*V[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first, v1=dp[0].second;\n               ll tmp=min(vv+v-L, v1);\n               tt=tt-t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t;\n            vv=L;\n            printf(\"%.7lf\\n\", (double)tt/vv);\n            int ans=dp.size();\n            ll c1=t;\n            ll c2=v;\n            while(ans){\n                ll t2=dp[ans-1].first, v2=dp[ans-1].second;\n                if((double)t2/v2<(double)c1/c2){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<int,int>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tdouble val=as[j].first;\n\t\t\tdouble l=as[j].second;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdouble val=v[i].first;\n\t\tdouble l=v[i].second;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tint n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=101;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tint val=0,l=0;\n\t\t\tfor(int i=vcnt-100;i<vcnt;i++){\n\t\t\t\tval+=v[i].first;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tdouble val=v[z].first;\n\t\t\tdouble ls=v[z].second;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={remv+0.5,lbs+0.5+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({a*b+0.5,b+0.5});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef SG\n\t#include <debug.h>\n#else\n\ttemplate<typename T> struct outputer;\n\tstruct outputable {};\n\t#define PRINT(...)\n\t#define OUTPUT(...)\n\t#define show(...)\n\t#define debug(...)\n\t#define deepen(...)\n\t#define timer(...)\n\t#define fbegin(...)\n\t#define fend\n\t#define pbegin(...)\n\t#define pend\n#endif\n\n#define ARG4(_1,_2,_3,_4,...) _4\n\n#define forn3(i,l,r) for (int i = int(l); i < int(r); ++i)\n#define forn2(i,n) forn3 (i, 0, n)\n#define forn(...) ARG4(__VA_ARGS__, forn3, forn2) (__VA_ARGS__)\n\n#define ford3(i,l,r) for (int i = int(r) - 1; i >= int(l); --i)\n#define ford2(i,n) ford3 (i, 0, n)\n#define ford(...) ARG4(__VA_ARGS__, ford3, ford2) (__VA_ARGS__)\n\n#define ve vector\n#define pa pair\n#define tu tuple\n#define mp make_pair\n#define mt make_tuple\n#define pb emplace_back\n#define fs first\n#define sc second\n#define all(a) (a).begin(), (a).end()\n#define sz(a) ((int)(a).size())\n\ntypedef long double ld;\ntypedef int64_t ll;\ntypedef uint64_t ull;\ntypedef uint32_t ui;\ntypedef uint16_t us;\ntypedef uint8_t uc;\ntypedef pa<int, int> pii;\ntypedef pa<int, ll> pil;\ntypedef pa<ll, int> pli;\ntypedef pa<ll, ll> pll;\ntypedef ve<int> vi;\n\ntemplate<typename T> inline auto sqr (T x) -> decltype(x * x) {return x * x;}\ntemplate<typename T1, typename T2> inline bool umx (T1& a, T2 b) {if (a < b) {a = b; return 1;} return 0;}\ntemplate<typename T1, typename T2> inline bool umn (T1& a, T2 b) {if (b < a) {a = b; return 1;} return 0;}\n\nconst int N = 500000;\n\nstruct Input {\n\tint n, l;\n\tint t[N], a[N];\n\t\n\tbool read () {\n\t\tif (!(cin >> n >> l)) {\n\t\t\treturn 0;\n\t\t}\n\t\tforn (i, n) {\n\t\t\tscanf(\"%d%d\", &t[i], &a[i]);\n\t\t}\n\t\treturn 1;\n\t}\n\n\tvoid init (const Input &input) {\n\t\t*this = input;\n\t}\n};\n\nstruct Data: Input {\n\tld ans[N];\n\t\n\tvoid write () {\n\t\tforn (i, n) {\n\t\t\tprintf(\"%0.20lf\\n\", double(ans[i]));\n\t\t}\n\t}\n};\n\n\nnamespace Main {\n\tconst ld eps = 1e-12;\n\t\n\tstruct Solution: Data {\n\t\tve<pa<ld, ld>> v;\n\t\t\n\t\tvoid solve () {\n\t\t\tv.pb(mp(0.l, 0.l));\n\t\t\tld shift_x = 0, shift_y = 0;\n\t\t\t\n\t\t\tforn (i, n) {\n\t\t\t\tshift_x += ld(a[i]);\n\t\t\t\tshift_y += ld(a[i]) * ld(t[i]);\n\t\t\t\t\n\t\t\t\tpa<ld, ld> p = mp(-shift_x, -shift_y);\n\t\t\t\t\n\t\t\t\twhile (sz(v) > 1 && \n\t\t\t\t\t(v[sz(v) - 2].sc - p.sc) / (v[sz(v) - 2].fs - p.fs) >\n\t\t\t\t\t(v[sz(v) - 1].sc - p.sc) / (v[sz(v) - 1].fs - p.fs) + eps\n\t\t\t\t) {\n\t\t\t\t\tv.pop_back();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tv.pb(p);\n\t\t\t\t\n\t\t\t\tld x = l - shift_x;\n\t\t\t\tint j = lower_bound(all(v), mp(x, 0.l), greater<pa<ld, ld>>()) - v.begin();\n\t\t\t\tumn(j, sz(v) - 1);\n\t\t\t\tumx(j, 1);\n\t\t\t\tans[i] = (v[j - 1].sc * (v[j].fs - x) + v[j].sc * (x - v[j - 1].fs)) / (v[j].fs - v[j - 1].fs) + shift_y;\n\t\t\t\tans[i] /= l;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid clear () {\n\t\t\t*this = Solution();\n\t\t}\n\t};\n}\n\n\nMain::Solution sol;\n\nint main () {\n\tcout.setf(ios::showpoint | ios::fixed);\n\tcout.precision(20);\n\n\t#ifdef SG\n\t\tfreopen((problemname + \".in\").c_str(), \"r\", stdin);\n//\t\tfreopen((problemname + \".out\").c_str(), \"w\", stdout);\n\t\twhile (sol.read()) {\n\t\t\tsol.solve();\n\t\t\tsol.write();\n\t\t\tsol.clear();\n\t\t}\n\t#else\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t#endif\n\t\n\t/*\n\tint t;\n\tcin >> t;\n\tforn (i, t) {\n\t\tsol.read();\n\t\tsol.solve();\n\t\tsol.write();\n\t\tsol.clear();\n\t}\n\t*/\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define db double\nusing namespace std;\nconst int N=5e5+10;\nint n,l=1,r=0;\ndb maxl,v,sumv,t,ans;\nstruct node{\n\tdb t,v;\n}q[N];\nint main(){\n\tscanf(\"%d%lf\",&n,&maxl);\n\twhile(n--){\n\t\tscanf(\"%lf%lf\",&t,&v);\n\t\twhile(v+sumv>maxl){\n\t\t\tdb out=min(v+sumv-maxl,q[l].v);\n\t\t\tans-=out*q[l].t,sumv-=out,q[l].v-=out;\n\t\t\tif(!q[l].v) l++;\n\t\t}\n\t\tq[++r]=(node){t,v};\n\t\tans+=t*v,sumv+=v;\n\t\twhile(l<r && q[r-1].t>q[r].t){\n\t\t\tq[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v+q[r].v);\n\t\t\tq[r-1].v+=q[r].v; r--;\t\n\t\t}\n\t\tprintf(\"%.7lf\\n\",ans/sumv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <random>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tcout<<\"case #\" << x << \": \" << endl\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tint n;\tll l;\tcin >> n >> l;\n\tdeque<pair<ld, ld>> dq;\n\tld fullt = 0, fullv = 0;\n\trep(i, n) {\n\t\tld t, v;\tcin >> t >> v;\n\t\twhile (!dq.empty() && dq.front().first > t) {\n\t\t\tld tv = v + dq.front().second;\n\t\t\tld tt = (t*v + dq.front().first*dq.front().second) / tv;\n\t\t\tif (tv - l > eps) {\n\t\t\t\tld use = l - v;\n\t\t\t\ttt = (t*v + dq.front().first*use) / l;\n\t\t\t\ttv = l;\n\t\t\t}\n\t\t\tfullt -= dq.front().first*dq.front().second;\n\t\t\tfullv -= dq.front().second;\n\t\t\tdq.pop_front();\tt = tt;\tv = tv;\n\t\t}\n\t\tdq.push_front(mp(t, v));\n\t\tfullt += t*v;\n\t\tfullv += v;\n\t\tld rett = fullt, retv = fullv;\n\t\twhile (retv - l > eps) {\n\t\t\tif (fullv - dq.back().second < l) {\n\t\t\t\tld remv = retv - l;\n\t\t\t\trett -= remv*dq.back().first;\n\t\t\t\tretv = l;\n\t\t\t\tpair<ld,ld> tmp = dq.back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpair<ld, ld> tmp = dq.back();\tdq.pop_back();\n\t\t\t\trett = fullt -= tmp.first*tmp.second;\n\t\t\t\tretv = fullv -= tmp.second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.15Lf\\n\", (ld)rett / l + eps);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, l;\n  cin >> n >> l;\n  deque<pair<double, ll>> q;\n  ll sumV = 0;\n  double sumVT = 0;\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) {\n    ll t, v;\n    cin >> t >> v;\n    while(sumV + v > l) {\n      auto p = q.front();\n      q.pop_front();\n      ll wd = sumV + v - l;\n      ll del = min(wd, p.second);\n      sumV -= del;\n      p.second -= del;\n      sumVT -= del * p.first;\n      if(p.second) q.push_front(p);\n    }\n\n    double o = (sumVT + v * t) / l;\n\n    cout << o << \"\\n\";\n\n    if(q.empty() || q.back().first < t) {\n      q.emplace_back(t, v);\n      sumV += v;\n      sumVT += v * t;\n    } else {\n      q.clear();\n      q.emplace_back(o, l);\n      sumV = l;\n      sumVT = o * l;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\ntypedef long long ll;\n\nint n,L,t,v,l=1,r=0;\nll qv[500005],Aw;\ndouble qt[500005],Ns;\n\nint main()\n{\n    //freopen(\"in.txt\",\"r\",stdin);\n    for(scanf(\"%d%d\",&n,&L);n--;)\n    {\n        scanf(\"%d%d\",&t,&v);\n        while(Aw+v>L)\n        {\n            ll Po=std::min(qv[l],Aw+v-L);\n            qv[l]-=Po,Aw-=Po,Ns-=qt[l]*Po;\n            if(!qv[l])++l;\n        }\n        Aw+=v,Ns+=(ll)t*v,qv[++r]=v,qt[r]=t;\n        for(;l<r&&qt[r-1]>qt[r];--r)qt[r-1]=(qt[r-1]*qv[r-1]+qt[r]*qv[r])/(qv[r-1]+qv[r]),qv[r-1]+=qv[r];\n        printf(\"%.7f\\n\",Ns/L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 5e5 + 1000;\n\nint n;\ndouble max_volume;\ndouble temp[N], volume[N];\n\nvoid init() {\n\tstd::cin >> n;\n\tstd::cin >> max_volume;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%lf%lf\", &temp[i], &volume[i]);\n\t}\n}\n\nvoid printAnswer(double x0, double y0, double x1, double y1, double x_target) {\n\tdouble lambda = (x_target - x0) / (x1 - x0);\n\tprintf(\"%.20f\\n\", (y0 + lambda * (y1 - y0)) / x_target);\n}\n\nvoid work() {\n\tstd::deque<std::pair<double, double>> deque;\n\n\tdouble sum_x = 0, sum_y = 0;\n\tfor (int i = 1; i <= n; i++) {\n\t\tdeque.push_front({volume[i], temp[i] * volume[i]});\n\t\tsum_x += volume[i];\n\t\tsum_y += temp[i] * volume[i];\n\n\t\twhile (sum_x - deque.back().first > max_volume) {\n\t\t\tsum_x -= deque.back().first;\n\t\t\tsum_y -= deque.back().second;\n\t\t\tdeque.pop_back();\n\t\t}\n\t\tprintAnswer(sum_x - deque.back().first, sum_y - deque.back().second, sum_x, sum_y, max_volume);\n\n\t\tif (sum_x > max_volume) {\n\t\t\tauto back = deque.back();\n\t\t\tsum_x -= back.first;\n\t\t\tsum_y -= back.second;\n\t\t\tdeque.pop_back();\n\t\t\tdouble t = (max_volume - sum_x) / back.first;\n\t\t\tback.first *= t;\n\t\t\tback.second *= t;\n\t\t\tsum_x += back.first;\n\t\t\tsum_y += back.second;\n\t\t\tdeque.push_back(back);\n\t\t}\n\t\twhile (deque.size() >= 2) {\n\t\t\tstd::pair<double, double> front[2];\n\t\t\tfront[0] = deque.front();\n\t\t\tdeque.pop_front();\n\t\t\tfront[1] = deque.front();\n\t\t\tdeque.pop_front();\n\t\t\tif (front[0].second * front[1].first <= front[1].second * front[0].first) {\n\t\t\t\tstd::pair<double, double> t = {front[0].first + front[1].first, front[0].second + front[1].second};\n\t\t\t\tdeque.push_front(t);\n\t\t\t} else {\n\t\t\t\tdeque.push_front(front[1]);\n\t\t\t\tdeque.push_front(front[0]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tinit();\n\twork();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 500005\n#define INF 16843009\n#define LL long long\n#define len(l,r) (r-l+1)\n#define P int(1e9+7)\nusing namespace std;\n \nint N,L;\ndouble A,B;\nLL t[MAXN], v[MAXN];\ndouble ans[MAXN];\n\ndouble mix(int v1, double t1, int v2, double t2){\n\treturn (v1*t1 + v2*t2)/(v1 + v2);\n}\n\nstruct Node{\n\tLL v;\n\tdouble t;\n\t\n\tNode(LL v, double t):v(v), t(t){}\n};\n\ndeque<Node> q;\n\nint main(){\n\t//freopen(\"1.in\", \"r\", stdin);\n\t//freopen(\"1.ans\", \"w\", stdout);\n\t\n\tcin>>N>>L;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>t[i]>>v[i];\n\t}\n\t\n\tdouble t1,v1;\n\tfor(int i=1;i<=N;i++){\n\t\twhile(B > L-v[i]){\n\t\t\tif(q.front().v <= B-L+v[i]){\n\t\t\t\tA -= q.front().v * q.front().t;\n\t\t\t\tB -= q.front().v;\n\t\t\t\tq.pop_front(); \n\t\t\t}\n\t\t\telse{\n\t\t\t\tq.front().v -= (B-L+v[i]);\n\t\t\t\tA -= (B-L+v[i]) * q.front().t;\n\t\t\t\tB -= (B-L+v[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//cout<<\"i: \"<<i<<\" \"<<A<<\" \"<<B<<endl;\n\t\tt1 = t[i]; v1 = v[i];\n\t\twhile(!q.empty() && q.back().t > t1){\n\t\t\tt1 = mix(v1,t1, q.back().v,q.back().t);\n\t\t\tv1 += q.back().v;\n\t\t\t\n\t\t\tA -= q.back().v * q.back().t;\n\t\t\tB -= q.back().v;\n\t\t\tq.pop_back(); \n\t\t}\n\t\t//cout<<\"(v1,t1)\"<<v1<<\" \"<<t1<<endl;\n\t\tA += v1 * t1;\n\t\t//cout<<\"A = \"<<A<<endl;\n\t\tB += v1;\n\t\tq.push_back(Node(v1,t1));\n\n\t\tans[i] = A/B;\n\t}\n\t\n\tfor(int i=1;i<=N;i++){\n\t\tprintf(\"%.6f\\n\", ans[i]);\n\t}\n\t \n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nconst ld EPS = 1e-10;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tsum += t * v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\n\t\tif (dq.empty() || dq.back().first + EPS <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(12) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nconst int N = 500*1000+7;\n\nLL T[N];\nLL V[N];\nLL sumU[N];\nLL sumD[N];\ndouble ans[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, L;\n\tcin >> n >> L;\n\n\tFOR(i,0,n)\n\t{\n\t\tcin >> T[i] >> V[i];\n\t\tsumD[i] = V[i];\n\t\tsumU[i] = V[i]*(LL)T[i];\n\t\tif(i)\n\t\t{\n\t\t\tsumD[i] += sumD[i-1];\n\t\t\tsumU[i] += sumU[i-1];\n\t\t\tans[i] = (ans[i-1]*(L-V[i]) + T[i]*1.0*V[i]) / L;\n\t\t\tint pos = upper_bound(sumD, sumD+i+1, sumD[i]-L) - sumD;\n\t\t\tLL sum2 = sumD[i] - sumD[pos];\n\t\t\tLL sum1 = sumU[i] - sumU[pos] + T[pos]*(LL)(L - sum2);\n\t\t\tans[i] = max(ans[i], sum1*1.0/L);\n\t\t}\n\t\telse\n\t\t\tans[0] = T[i];\n\t\tcout << fixed << setprecision(8) << ans[i] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || q >= V.size() || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t\ts -= d * x;\n\t\t\t\tV.pop_back();\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define t first\n#define v second\n#define wrap make_pair\nusing namespace std;\ntypedef double db;\ntypedef pair<db,int> pint;\ntypedef const pint& cpr;\ntypedef long long ll;\nconst int siz=5e5+1;\n\nint n,L;\nll Vsum;\ndb Esum;\npint a[siz];\ndeque<pint> q;\n\ninline\ndb mix(cpr a,cpr b){return (a.t*a.v+b.t*b.v)/(a.v+b.v);}\n\nint main()\n{\n#ifdef DEBUG\n\tfreopen(\"AT2402.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1,y;i<=n;i++){\n\t\tdb x;\n\t\tscanf(\"%lf%d\",&x,&y);\n\t\ta[i]=wrap(x,y);\n\t\twhile(a[i].v+Vsum>L){\n\t\t\tpint now=q.front();\n\t\t\tq.pop_front();\n\t\t\tint pour=min(a[i].v+Vsum-L,(ll)now.v);\n\t\t\tVsum-=pour;\n\t\t\tEsum-=pour*now.t;\n\t\t\tnow=wrap(now.t,now.v-pour);\n\t\t\tif(now.v!=0)\n\t\t\t\tq.push_front(now);\n\t\t}\n\t\tif(!q.empty()&&q.back().t>a[i].t){\n\t\t\tpint b=q.back();\n\t\t\tq.pop_back();\n\t\t\tq.push_back(wrap(mix(b,a[i]),b.v+a[i].v));\n\t\t}\n\t\telse\n\t\t\tq.push_back(a[i]);\n\t\tEsum+=a[i].t*a[i].v;\n\t\tVsum+=a[i].v;\n\t\tprintf(\"%.7f\\n\",Esum/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n   \ninline int read() {\n\tint x=0,f=1; char ch=getchar();\n\twhile (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n\treturn x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n                                                                \nint main() {\n\t\n\t#ifndef ONLINE_JUDGE\n\t//\tfreopen(\"data.in\",\"r\",stdin);\n\t//\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\t\n\tn=read(); L=read();\n\tdouble S=0,V=0;\n\trep(i,1,n) {\n\t\tint t=read(),v=read();\n\t\tV+=v; S+=(double)t*v;\n\t\twhile (V>L&&head<tail) {\n\t\t\tif (V-L>=q[head][0]) {\n\t\t\t\tV-=q[head][0]; S-=q[head][0]*q[head][1];\n\t\t\t\thead++;\n\t\t\t} else {\n\t\t\t\tq[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tq[tail][0]=v; q[tail++][1]=t;\n\t\tprintf(\"%lf\\n\",S/L);\n\t\twhile (tail-head>=2) {\n\t\t\tif (q[tail-1][1]>q[tail-2][1]) break;\n\t\t\tq[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n\t\t\tq[tail-2][0]+=q[tail-1][0];\n\t\t\ttail--;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 5e5 + 100;\n\nint n, fnt, rar, L;\nlong long tagx, tagy, x[maxn];\ndouble y[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &L);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tif(fnt == rar) {\n\t\t\tprintf(\"%.12f\\n\", 1. * t);\n\t\t\tx[rar] = v;\n\t\t\ty[rar++] = 1. * v * t;\n\t\t\tx[rar] = 0;\n\t\t\ty[rar++] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile(fnt + 1 < rar && x[fnt + 1] + tagx + v >= L) {\n\t\t\t++fnt;\n\t\t}\n\t\tdouble k = (y[fnt] - y[fnt + 1]) / (x[fnt] - x[fnt + 1]);\n\t\tx[fnt] = L - v - tagx;\n\t\ty[fnt] = k * (x[fnt] - x[fnt + 1]) + y[fnt + 1];\n\t\ttagy += v * t;\n\t\ttagx += v;\n\t\tprintf(\"%.12f\\n\", (y[fnt] + tagy) / (1. * L));\n\t\twhile(rar - 1 != fnt) {\n\t\t\tdouble k1 = (y[rar - 1] + tagy) / (1. * x[rar - 1] + tagx);\n\t\t\tdouble k2 = (y[rar - 2] + tagy) / (1. * x[rar - 2] + tagx);\n\t\t\tif(k1 <= k2) {\n\t\t\t\t--rar;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx[rar] = -tagx;\n\t\ty[rar++] = -tagy;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(num,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/(long double)l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\nusing Pdi = pair<double, int>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    double L; cin >> L;\n    vector<int> t(N), v(N);\n    vector<double> ans(N, 0.0);\n    REP(i, N) cin >> t[i] >> v[i];\n\n    deque<Pdi> dq;\n    double S = 0.0;\n    int V = 0;\n    REP(i, N){\n        int L0 = L - v[i];\n        while(V > L0){\n            double t2 = dq.front().f;\n            int v2 = dq.front().s;\n            dq.pop_front();\n            if(v2 > V - L0){\n                v2 -= V - L0;\n                S -= t2 * (V - L0);\n                V = L0;\n                dq.push_front(Pii(t2, v2));\n            }else{\n                S -= t2 * v2;\n                V -= v2;\n            }\n        }\n\n        V += v[i];\n        S += t[i] * v[i];\n        double t0 = t[i];\n        int v0 = v[i];\n        while(SZ(dq) > 0 && dq.back().f > t0){\n            double t1 = dq.back().f;\n            int v1 = dq.back().s;\n            dq.pop_back();\n            t0 = (t0 * v0 + t1 * v1) / (v0 + v1);\n            v0 = v0 + v1;\n        }\n        dq.push_back(Pdi(t0, v0));\n        \n        ans[i] = S / L;\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nstruct T{\n\tint v;\n\tdouble t;\n\tT (int a = 0, double b = 0.0):v(a), t(b) {}\n\tT operator +(T o){\n\t\tif (v + o.v == 0)return T();\n\t\treturn T(v + o.v, (v * t + o.v * o.t) / (v + o.v));\n\t}\n};\n\nint main(){\n\tint n, l;\n\tscanf(\"%d%d\", &n, &l);\n\tT c(l), ext;\n\tdeque<T> ex;\n\tf(i, 0, n){\n\t\tint in1, in2;\n\t\tscanf(\"%d%d\", &in1, &in2);\n\t\tT nt(in2, in1);\n\t\tint need = nt.v;\n\t\twhile (need && !ex.empty()){\n\t\t\tint d = min(need, ex.back().v);\n\t\t\tneed -= d;\n\t\t\text.t = (ext.t * ext.v - d * ex.back().t) / (ext.v - d);\n\t\t\tif ((ext.v -= d) == 0)ext.t = 0.0;\n\t\t\tif ((ex.back().v -= d) == 0)ex.pop_back();\n\t\t}\n\t\tc.v -= need;\n\t\tif (nt.t > c.t){\n\t\t\tif (c.v)ex.push_front(c);\n\t\t\text = ext + c;\n\t\t\tc = nt;\n\t\t}else c = c + nt;\n\t\tprintf(\"%.7lf\\n\", (c + ext).t);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<double,double>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tint l=as[j].second;\n\t\t\tif(l!=-1){\n\t\t\t\tint val=as[j].first*l;\n\t\t\t\tif(need>l){\n\t\t\t\t\tans+=val;\n\t\t\t\t\tneed-=l;\n\t\t\t\t\ti-=99;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tlong long val=0;\n\t\t\tint totall=0;\n\t\t\tfor(int z=vcnt-101;z<vcnt-1;z++){\n\t\t\t\ttotall+=v[z].second;\n\t\t\t}\n\t\t\tif(totall>=l){\n\t\t\t\tas.push_back({-1,-1});\n\t\t\t}\n\t\t\tfor(int z=vcnt-101;z<vcnt-1;z++){\n\t\t\t\tval+=v[z].first*v[z].second;\n\t\t\t}\n\t\t\tas.push_back({(double)val/totall,totall});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tint ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,(double)ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b)/(b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        if (!sgn(ll-d)){\n            V = 0;\n        }\n        else {\n            V = ((V*ll) - d*W.front().fi) / (ll-d);\n        }\n        l -= d; W.front().se -= d; ll -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n        \n    }\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/Documents/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        \n        DB r = l;\n        while (!W.empty() && sgn(W.back().fi, V) >= 0){\n            r += W.back().se;\n            W.pop_back();\n        }\n        W.push_back(MP(V, r));\n        OT(V);\n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=500007;\n\ntypedef std::pair<int,llf> data;\n\nint n,m,s[N],t[N];\nstd::deque<data>q;\n\ninline data merge(data a,data b)\n{\n\treturn mp(a.xx+b.xx,(a.yy*a.xx+b.yy*b.xx)/(a.xx+b.xx));\n}\n\nint main()\n{\n\tin,n,m;\n\tfo1(i,n)in,s[i],t[i];\n\tllf sum=0;\n\tq.pb(mp(m,0));\n\tfo1(i,n)\n\t{\n\t\tint c=0;\n\t\twhile(c<t[i])\n\t\t{\n\t\t\tif(q.back().xx<=t[i]-c)\n\t\t\t{\n\t\t\t\tsum-=q.back().xx*q.back().yy;\n\t\t\t\tc+=q.back().xx;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsum-=q.back().yy*(t[i]-c);\n\t\t\t\tdata v=q.back();\n\t\t\t\tv.xx-=t[i]-c;\n\t\t\t\tc=t[i];\n\t\t\t\tq.pop_back();\n\t\t\t\tq.pb(v);\n\t\t\t}\n\t\t}\n\t\t//out,'\\n';\n\t\t//printf(\"%.2lf\\n\",(lf)(sum/q.front().xx));\n\t\t//foe(j,q)printf(\"%d %.2lf\\n\",j->xx,(lf)j->yy);\n\t\tdata v=mp(t[i],s[i]);\n\t\twhile(q.size()&&v.yy<q.front().yy)\n\t\t\tv=merge(v,q.front()),q.pop_front();\n\t\tq.push_front(v);\n\t\tsum+=(ll)s[i]*t[i];\n\t\tprintf(\"%.10lf\\n\",(lf)(sum/m));\n\t\t//foe(j,q)printf(\"%d %.2lf\\n\",j->xx,(lf)j->yy);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <cassert>\n#include <queue>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define ri rd<int>\nusing namespace std;\ntypedef long long LL;\ntypedef long double db;\nconst int maxN = 5e5 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\nint n, m;\n\nstruct pt {\n\tLL x; db y;\n\tpt(LL _x = 0, db _y = 0) {x = _x, y = _y;}\n\tinline pt operator - (const pt &v) const {return pt(x - v.x, y - v.y);}\n\tinline pt operator + (const pt &v) const {return pt(x + v.x, y + v.y);}\n\tinline void operator += (const pt &v) {x += v.x, y += v.y;}\n\tinline void operator -= (const pt &v) {x -= v.x, y -= v.y;}\n};\ntypedef pt vec;\n\ninline db slope(const vec &u) {return (db)u.y / (db)u.x;}\n\ninline bool cmp(const vec &u, const vec &v) { return slope(u) < slope(v); }\n\ndeque<vec> q;\n\nint main() {\n\n\tn = ri(), m = ri();\n\n\tpt tot;\n\trep (i, 1, n) {\n\t\tLL t = ri(), v = ri();\t\n\t\tvec nw = vec(v, v * t);\n\n\t\tq.push_front(nw); tot += nw;\n\t\twhile (!q.empty() && tot.x > m) {\n\t\t\tvec tp = q.back(); tot -= tp;\n\t\t\tq.pop_back();\n\t\t\tif (tot.x < m) {\n\t\t\t\ttp = vec(m - tot.x, (m - tot.x) * slope(tp));\n\t\t\t\tq.push_back(tp); tot += tp;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7Lf\\n\", (db)(tot.y - (tot.x - m) * slope(q.back())) / (db)m);\n\t\tq.pop_front(); \n\n\t\twhile (!q.empty() && cmp(nw, q.front())) {\n\t\t\tnw = nw + q.front();\n\t\t\tq.pop_front();\n\t\t}\n\t\tq.push_front(nw); \n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 200005;\n\nint n, ql, qr, cur, lim, x[MAXN];\ndouble ret, y[MAXN];\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), lim = Read(), ql = 1;\n\tfor (int i = 1; i <= n; i ++)\n\t{\n\t\tint t = Read(), v = Read();\n\t\twhile (cur + v > lim)\n\t\t\tif (cur + v - x[ql] >= lim)\n\t\t\t\tcur -= x[ql], ret -= y[ql], ql ++;\n\t\t\telse\n\t\t\t{\n\t\t\t\tint t = cur + v - lim;\n\t\t\t\tdouble r = y[ql] / x[ql];\n\t\t\t\tx[ql] -= t, y[ql] -= t * r;\n\t\t\t\tcur -= t, ret -= t * r;\n\t\t\t}\n\t\tcur += v;\n\t\tret += 1LL * v * t;\n\t\tprintf(\"%lf\\n\", ret / cur);\n\t\tqr ++, x[qr] = v, y[qr] = 1LL * v * t;\n\t\twhile (ql < qr && y[qr] * x[qr - 1] < y[qr - 1] * x[qr])\n\t\t\tx[qr - 1] += x[qr], y[qr - 1] += y[qr], qr --;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, ld> P;\n\nconst ld EPS = 1e-10;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tld L;\n\tcin >> n >> L;\n\tld sum = 0.0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tld v;\n\t\tcin >> t >> v;\n\t\tld over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tld tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\t\tsum += t * v;\n\n\t\tif (dq.empty() || dq.back().first + EPS <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(12) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <iomanip>\n#include <cmath>\n\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef long double ld;\n\n\nconst ll MOD_CONST = 1000000007ll;\n\n\nll modSum(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) + (b % MOD)) % MOD;\n}\n\n\nll modSubtract(ll a, ll b, ll MOD = MOD_CONST) {\n  return (((a % MOD) - (b % MOD)) + MOD + MOD) % MOD;\n}\n\n\nll modProd(ll a, ll b, ll MOD = MOD_CONST) {\n  return ((a % MOD) * (b % MOD)) % MOD;\n}\n\n\nll getPowMod(ll x, ll e, ll MOD = MOD_CONST) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPowMod(x, e/2, MOD);\n    return modProd(tmp, tmp);\n  } else {\n    ll tmp = getPowMod(x, e-1, MOD);\n    return modProd(tmp, x);\n  }\n}\n\n\nll getPow(ll x, ll e) {\n  if (e == 0) return 1;\n  if (e % 2 == 0) {\n    ll tmp = getPow(x, e/2);\n    return tmp * tmp;\n  } else {\n    ll tmp = getPow(x, e-1);\n    return tmp * x;\n  }\n}\n\n\nll getInverse(ll x, ll MOD = MOD_CONST) {\n  return getPowMod(x, MOD-2, MOD);\n}\n\n\nbool isEven(ll x) {\n  ll tmp = ((x % 2) + 2) % 2;\n  return tmp == 0;\n}\n\n\nll getSumOfDigitsInBase(ll n, ll b) {\n  ll ret = 0;\n  while (n > 0) {\n    ret += n % b;\n    n /= b;\n  }\n  return ret;\n}\n\n\nvector<int> getKMP(string &s) {\n  int len = (int)s.size();\n  vector<int> ret (len, 0);\n  for (int i = 1 ; i < len ; i++) {\n    int at = ret[i-1];\n    while (at > 0 && s[i] != s[at]) {\n      at = ret[at-1];\n    }\n    if (s[i] == s[at]) {\n      at++;\n    }\n    ret[i] = at;\n  }\n  return ret;\n}\n\n\nstring getSubstring(string &s, int from, int to) {\n  int l = to-from+1;\n  if (l <= 0) {\n    return \"\";\n  }\n  return s.substr(from, l);\n}\n\nll gcd(ll a, ll b, ll & x, ll & y) {\n    if (a == 0) {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b % a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\n\n\npair<ll, ll> getIntersectingRange(ll a1, ll b1, ll a2, ll b2) {\n  ll s = max(a1, a2);\n  ll e = min(b1, b2);\n\n  return {s, e};\n}\n\n\nbool isNonEmptyIntersection(ll a1, ll b1, ll a2, ll b2) {\n  auto p = getIntersectingRange(a1, b1, a2, b2);\n  return p.first <= p.second;\n}\n\n\ndouble getPointDistance(double x1, double y1, double x2, double y2) {\n  double dx = x1-x2;\n  double dy = y1-y2;\n  double d = (dx * dx) + (dy * dy);\n  return sqrt(d);\n}\n\n\nbool isPrime(ll x) {\n  if (x == 2 || x == 3 || x == 5 || x == 7) return true;\n  if (x < 10) return false;\n  ll till = min((ll)sqrt(x) + 1, x-1);\n  for (ll i = 2 ; i <= till ; i++) {\n    if (x % i == 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n\nconst int TREE_SIZE = 1;\n\n\nll segTree[TREE_SIZE], lazyTree[TREE_SIZE];\n\n\nvoid updateRange(int node, int start, int end, int l, int r, int val)\n{\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];    // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];                  // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];                // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                                  // Reset it\n    }\n    if(start > end or start > r or end < l)              // Current segment is not within range [l, r]\n        return;\n    if(start >= l and end <= r)\n    {\n        // Segment is fully within range\n        segTree[node] += (end - start + 1) * val;\n        if(start != end)\n        {\n            // Not leaf node\n            lazyTree[node*2] += val;\n            lazyTree[node*2+1] += val;\n        }\n        return;\n    }\n    int mid = (start + end) / 2;\n    updateRange(node*2, start, mid, l, r, val);        // Updating left child\n    updateRange(node*2 + 1, mid + 1, end, l, r, val);   // Updating right child\n    segTree[node] = segTree[node*2] + segTree[node*2+1];        // Updating root with max value\n}\n\n\nll queryRange(int node, int start, int end, int l, int r)\n{\n    if(start > end or start > r or end < l)\n        return 0;         // Out of range\n    if(lazyTree[node] != 0)\n    {\n        // This node needs to be updated\n        segTree[node] += (end - start + 1) * lazyTree[node];            // Update it\n        if(start != end)\n        {\n            lazyTree[node*2] += lazyTree[node];         // Mark child as lazyTree\n            lazyTree[node*2+1] += lazyTree[node];    // Mark child as lazyTree\n        }\n        lazyTree[node] = 0;                 // Reset it\n    }\n    if(start >= l and end <= r)             // Current segment is totally within range [l, r]\n        return segTree[node];\n    int mid = (start + end) / 2;\n    int p1 = queryRange(node*2, start, mid, l, r);         // Query left child\n    int p2 = queryRange(node*2 + 1, mid + 1, end, l, r); // Query right child\n    return (p1 + p2);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst int MAXN = 500002;\n\n\nint N, L;\nll ar_t[MAXN], ar_v[MAXN];\n\n\nvoid input() {\n  cin >> N >> L;\n  for (int i = 1 ; i <= N ; i++) {\n    cin >> ar_t[i] >> ar_v[i];\n  }\n}\n\n\nvoid preprocess() {\n}\n\n\nvoid solve() {\n  deque< pair< pair<ll, ll>, double> > Q;\n  Q.push_back({{0, L}, 0});\n\n  ll sum_tv = 0, sum_v = 0;\n  for (int i = 1 ; i <= N ; i++) {\n    sum_v += ar_v[i];\n    sum_tv += ar_t[i] * ar_v[i];\n\n    while (!Q.empty()) {\n      auto p = Q.back();\n      Q.pop_back();\n      p.first.first += sum_v;\n      p.first.second += sum_v;\n      if (L <= p.first.first) {\n        sum_tv -= (p.first.second-p.first.first) * p.second;\n      } else {\n        sum_tv -= (p.first.second - L) * p.second;\n        p.first.second = L;\n        p.first.first -= sum_v;\n        p.first.second -= sum_v;\n        Q.push_back(p);\n        break;\n      }\n    }\n\n    ll x = ar_v[i], y = ar_v[i] * ar_t[i];\n    while ((!Q.empty()) && 1.0*y/x <= Q.front().second) {\n        x += Q.front().first.second-Q.front().first.first;\n        y += Q.front().second*(Q.front().first.second-Q.front().first.first);\n        Q.pop_front();\n    }\n    Q.push_front({{-sum_v, x-sum_v}, 1.0*y/x});\n\n    cout << fixed << setprecision(22) << 1.0*sum_tv/L << \"\\n\";\n  }\n}\n\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout.tie(0);\n  cerr.tie(0);\n\n  int T;\n//  cin >> T;\n  T = 1;\n\n  for (int i = 0 ; i < T ; i++) {\n    input();\n    preprocess();\n    solve();\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t\t//printf(\"%d %.6lf %.0lf\\n\",l,sum,now);\n\t\tans[i]=sum/m;\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tdouble tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef long long s64;\ntypedef double r32;\n\ninline int getint()\n{\n\tstatic char c;\n\twhile ((c = getchar()) < '0' || c > '9');\n\n\tint res = c - '0';\n\twhile ((c = getchar()) >= '0' && c <= '9')\n\t\tres = res * 10 + c - '0';\n\treturn res;\n}\n\nconst int MaxN = 500000;\n\nstruct item\n{\n\tr32 t;\n\tint v;\n\titem() {}\n\titem(const r32 &_t, const int &_v)\n\t\t: t(_t), v(_v) {}\n\n\tinline r32 calc() const\n\t{\n\t\treturn t * v;\n\t}\n};\n\nint n, l;\n\nint q_l = 1, q_r = 0;\nitem q[MaxN + 1];\n\nint main()\n{\n\tcin >> n >> l;\n\n\tr32 sum = 0;\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tr32 t = getint();\n\t\tint v = getint();\n\n\t\tint cur = v;\n\t\twhile (q_l <= q_r && cur >= q[q_l].v)\n\t\t\tcur -= q[q_l].v, sum -= q[q_l++].calc();\n\n\t\tsum += v * t;\n\t\tif (q_l <= q_r && cur)\n\t\t{\n\t\t\tsum -= q[q_l].calc();\n\t\t\tq[q_l].v -= cur;\n\t\t\tsum += q[q_l].calc();\n\t\t}\n\n\t\twhile (q_l <= q_r && q[q_r].t > t)\n\t\t{\n\t\t\tt = (v * t + q[q_r].calc()) / (v + q[q_r].v);\n\t\t\tv += q[q_r--].v;\n\t\t}\n\n\t\tq[++q_r] = item(t, v);\n\n\t\tprintf(\"%.12f\\n\", sum / l);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nLL read()\n{\n    char c=getchar();LL f=1,sum=0;\n    while(c<'0' || c>'9'){if(c=='-')f=-1;c=getchar();}\n    while(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}\n    return sum*f;\n}\nLL n,L,L0;\nstruct node{\n\tLL v;\n\tdouble t;\n}q[500005],p;\nint head,tail;\nint main()\n{\n\tn=read();L0=L=read();\n\tdouble T=0.0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tp.t=read();p.v=read();\n\t\twhile(p.v>L)\n\t\t{\n\t\t\tif(L+q[head].v<p.v)\n\t\t\t{\n\t\t\t\tL+=q[head].v;\n\t\t\t\tT-=q[head].v*q[head].t;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLL x=p.v-L;\n                T-=x*q[head].t;\n                L+=x;\n                q[head].v-=x;\n\t\t\t}\n\t\t}\n\t\tL-=p.v;T+=p.v*p.t;\n\t\tq[++tail]=p;\n\t\twhile(head<tail && q[tail].t<=q[tail-1].t)\n\t\t{\n\t\t\tq[tail-1].t=(q[tail-1].t*q[tail-1].v+q[tail].t*q[tail].v)/(double)(q[tail].v+q[tail-1].v);\n\t\t\tq[tail-1].v+=q[tail].v;\n\t\t\ttail--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",T/(double)(L0-L));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint t,v;\n\tscanf(\"%d%d%d%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%d%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else if(L-v<x){\n\t\t\td = water(d,L-v,t,v);\n\t\t\tx = L;\n\t\t} else {\n\t\t\td = water(d,x,t,v);\n\t\t\tx += v;\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        for (int i = 1; i < (int)q.size(); ++i) {\n            int v = q[0];\n            int u = q[i];\n            if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                forn(_, i) q.pop_front();\n            } else {\n                break;\n            }\n        }\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                    for (int i = 1; i < (int)q.size(); ++i) {\n                        int v = q[0];\n                        int u = q[i];\n                        if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                            forn(_, i) q.pop_front();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<algorithm>\nusing namespace std;\nint n,l,head,tail;\ndouble nowv,nowt,qt[500010],qv[500010];\nint main(){\n    scanf(\"%d%d\",&n,&l);\n    head=1,tail=0;\n    for(int i=1;i<=n;i++){\n        double t,v;\n        scanf(\"%lf%lf\",&t,&v);\n        nowv+=v;\n        while(head<tail&&nowv>l&&qv[head]<=nowv-l){\n            nowt-=qt[head]*qv[head];\n            nowv-=qv[head];\n            head++;\n        }\n        if(nowv>l){\n            qv[head]-=nowv-l;\n            nowt-=qt[head]*(nowv-l);\n            nowv=l;\n        }\n        qt[++tail]=t;\n        qv[tail]=v;\n        while(head<tail&&qt[tail]<=qt[tail-1]){\n            tail--;\n            qt[tail]=(qt[tail+1]*qv[tail+1]+qt[tail]*qv[tail])/(qv[tail+1]+qv[tail]);\n            qv[tail]=qv[tail+1]+qv[tail];\n        }\n        nowt+=v*t;\n        printf(\"%.8lf\\n\",nowt/l);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6\nvector<pair<DB, DB> > W;\nvector<DB> S;\nint w0; DB s0;\n// degree, V\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W[w0].se);\n        if (!sgn(ll- d)){\n            V = 0;\n        }\n        else {\n            \n            V = ((V*ll) - d*W[w0].fi) / (ll-d);\n        }\n        l -= d; W[w0].se -= d;\n        if (!sgn(W[w0].se)) w0++;\n        ll -= d;\n    }\n    s0 += l;\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n// 4 5\n// 2 3\n\n// 0 > 0\n\nvoid gao(){\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l)); w0 = 0;\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        \n        DB r = 0;\n        while (W.size() > w0 && W.rbegin()->fi > V){\n            r += W.rbegin()->se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n            W.push_back(MP(V, r));\n        }\n        OT(V);\n        \n        //int p = lower_bound(W.begin() + w0, W.end(), V) - W.begin();\n        //DB ss = p > w0 ? S[p-1]-s0 : 0;\n        \n    }\n}\nint main(){\n    \n\n    RD(n, L);\n    gao();\n    /*REP(i, n){\n        LL t, v; RD(v, t);\n        if (i){\n            DB tt = t, ll = L;\n            \n            while (sgn(tt)){\n                pair<DB, DB> z = Q.top(); Q.pop();\n                DB d = min(tt, z.se);\n                \n                cout << z.fi << \" \" << z.se << endl;\n                \n                // ((ll-d)*vv' + d*z.fi) / ll = vv\n                \n                vv = ((vv*ll) - d*-z.fi) / (ll-d);\n\n                \n                tt -= d, z.se -= d;\n                if (sgn(z.se)){\n                    Q.push(MP(z.fi, z.se));\n                }\n                ll -= d;\n            }\n            vv = ((L-t)*vv + t*v) / L;\n        }\n        else{\n            vv = v;\n        }\n        Q.push(MP(-v, t));\n        OT(vv);\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, l;\n  cin >> n >> l;\n  deque<pair<double, ll>> q;\n  ll sumV = 0;\n  double sumVT = 0;\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) {\n    ll t, v;\n    cin >> t >> v;\n    while(sumV + v > l) {\n      auto p = q.front();\n      q.pop_front();\n      ll wd = sumV + v - l;\n      ll del = min(wd, p.second);\n      sumV -= del;\n      p.second -= del;\n      sumVT -= del * p.first;\n      if(p.second) q.push_front(p);\n    }\n\n    double o = (sumVT + v * t) / l;\n\n    cout << o << \"\\n\";\n\n    pair<double, ll> p(t, v);\n    while(q.size() && p.first < q.back().first) {\n      auto r = q.back();\n      q.pop_back();\n      sumV -= r.second;\n      sumVT -= r.first * r.second;\n      p.first = (p.first * p.second + r.first * r.second) / (p.second + r.second);\n      p.second += r.second;\n    }\n\n    q.push_back(p);\n    sumV += p.second;\n    sumVT += p.first * p.second;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 1000005\nusing namespace std;\nint n,l;\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y):x(x),y(y){}\n\tfriend point operator+(const point &a,const point &b)  {return point(a.x+b.x,a.y+b.y);}\n\tfriend point operator-(const point &a,const point &b)  {return point(a.x-b.x,a.y-b.y);}\n\tfriend double dot(const point &a,const point &b)  {return a.x*b.x+a.y*b.y;}\n\tfriend double cross(const point &a,const point &b)  {return a.x*b.y-a.y*b.x;}\n}p[N],Q[N<<1];\nint main(){\n\tint x,y,L=N,R=N;\n\tscanf(\"%d%d%d%d\",&n,&l,&y,&x);\n\tQ[++R]=point(x,1.0*x*y),printf(\"%lf\\n\",1.0*y);\n\tfor(int i=1;i<n;++i){\n\t\tscanf(\"%d%d\",&y,&x);\n\t\tp[i]=point(Q[L].x-x,Q[L].y-(1.0*x*y));\n\t\twhile(L<R&&Q[R-1].x-p[i].x>=l)  R--;\n\t\tif(L!=R){\n\t\t\tdouble slope=(Q[R].y-Q[R-1].y)/(Q[R].x-Q[R-1].x);\n\t\t\tif(Q[R].x-p[i].x>l){\n\t\t\t\tQ[R].y=Q[R-1].y+(l-(Q[R-1].x-p[i].x))*slope;\n\t\t\t\tQ[R].x=p[i].x+l;\n\t\t\t}\n\t\t}\n\t\twhile(L<R&&cross(Q[L]-p[i],Q[L+1]-p[i])>=0)  L++;\n\t\tQ[--L]=p[i];\n\t\tprintf(\"%lf\\n\",(Q[R].y-p[i].y)/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\n\nint main() {\n    int n, l; scanf(\"%d%d\", &n, &l);\n    vector<int> t(n), v(n); repeat (i, n) scanf(\"%d%d\", &t[i], &v[i]);\n    deque<pair<int, double> > deq;\n    deq.emplace_back(v[0], t[0]);\n    double acc = t[0] *(double) v[0];\n    printf(\"%.12lf\\n\", acc /(double) l);\n    repeat_from (i, 1, n) {\n        for (int nv = v[i]; nv > 0; ) {\n            int dv = min(nv, deq.front().first);\n            nv -= dv;\n            deq.front().first -= dv;\n            acc -= deq.front().second * dv;\n            if (deq.front().first == 0) {\n                deq.pop_front();\n            }\n        }\n        int nv = v[i];\n        double nt = t[i];\n        while (not deq.empty() and deq.back().second > nt) {\n            int pv; double pt; tie(pv, pt) = deq.back();\n            deq.pop_back();\n            nt = (nt * nv + pt * pv) / (nv + pv);\n            nv += pv;\n        }\n        deq.emplace_back(nv, nt);\n        acc += t[i] *(double) v[i];\n        printf(\"%.12lf\\n\", acc /(double) l);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define t first\n#define v second\n#define wrap make_pair\nusing namespace std;\ntypedef double db;\ntypedef pair<db,int> pint;\ntypedef const pint& cpr;\ntypedef long long ll;\nconst int siz=5e5+1;\n\nint n,L;\nll Vsum;\ndb Esum;\npint a;\ndeque<pint> q;\n\ninline\ndb mix(cpr a,cpr b){return (a.t*a.v+b.t*b.v)/(a.v+b.v);}\n\nint main()\n{\n#ifdef DEBUG\n\tfreopen(\"AT2402.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1,y;i<=n;i++){\n\t\tdb x;\n\t\tscanf(\"%lf%d\",&x,&y);\n\t\ta=wrap(x,y);\n\t\twhile(a.v+Vsum>L){\n\t\t\tpint now=q.front();\n\t\t\tq.pop_front();\n\t\t\tint pour=min(a.v+Vsum-L,(ll)now.v);\n\t\t\tVsum-=pour;\n\t\t\tEsum-=pour*now.t;\n\t\t\tnow=wrap(now.t,now.v-pour);\n\t\t\tif(now.v!=0)\n\t\t\t\tq.push_front(now);\n\t\t}\n\t\tq.push_back(a);\n\t\twhile(q.size()>1&&q[q.size()-2].t>q.back().t){\n\t\t\tpint b=q.back();\n\t\t\tq.pop_back();\n\t\t\tpint c=q.back();\n\t\t\tq.pop_back();\n\t\t\tq.push_back(wrap(mix(b,c),b.v+c.v));\n\t\t}\n\t\tEsum+=a.t*a.v;\n\t\tVsum+=a.v;\n\t\tprintf(\"%.7f\\n\",Esum/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//satyaki3794\n#include <bits/stdc++.h>\n#define ff first\n#define ss second\n#define pb push_back\n#define MOD (1000000007LL)\n#define LEFT(n) (2*(n))\n#define RIGHT(n) (2*(n)+1)\n \nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> ii;\ntypedef pair<int, ii> iii;\n\nll pwr(ll base, ll p, ll mod = MOD){\nll ans = 1;while(p){if(p&1)ans=(ans*base)%mod;base=(base*base)%mod;p/=2;}return ans;\n}\n \n\nll gcd(ll a, ll b){\n    if(b == 0)  return a;\n    return gcd(b, a%b);\n}\n\n\nconst int N = 500002;\nint n, L;\nset<ii> storage;\n\n\nint main(){\n\n    // ios_base::sync_with_stdio(0);\n    // cin.tie(0);\n\n    scanf(\"%d%d\", &n, &L);\n    double T = 0, V = 0, val = 0;\n    set<ii>::iterator it;\n// n=2;\n    for(int i=1;i<=n;i++){\n        \n        ll temp, vol;\n        scanf(\"%lld%lld\", &temp, &vol);\n\n        if(V+vol > L){\n            ll z = V+vol-L;\n            V -= z;\n        }\n        T = (T*V + temp*vol)/(V+vol);\n        V += vol;\n\n// cout<<\"after i = \"<<i<<\", \"<<T<<\" \"<<V<<endl;\n\n        printf(\"%.7lf\\n\", T);\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 500000\nlong double t[MN+5],st[MN+5];\nlong long l[MN+5],sl[MN+5];\nint z[MN+5],zn;\nint main()\n{\n\tint n=read(),L=read(),i,p=1;\n\tfor(i=1;i<=n;++i)\n\t{\n\t\tt[i]=read();l[i]=read();t[i]*=l[i];\n\t\tfor(;zn&&t[i]*l[z[zn]]<=t[z[zn]]*l[i];--zn)\n\t\t{\n\t\t\tt[i]+=t[z[zn]];l[i]+=l[z[zn]];\n\t\t\tif(l[i]>L)t[i]-=t[z[zn]]*(l[i]-L)/l[z[zn]],l[i]=L;\n\t\t}\n\t\tz[++zn]=i;st[zn]=st[zn-1]+t[i];sl[zn]=sl[zn-1]+l[i];\n\t\tif(zn<p)p=zn;\n\t\twhile(sl[zn]-sl[p]>=L)++p;\n\t\tprintf(\"%.7lf\\n\",double((t[z[p]]*(L-sl[zn]+sl[p])/l[z[p]]+st[zn]-st[p])/L));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, unsigned> pairDI;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nunsigned N, L;\nvector<unsigned> t, v;\nvector<pairDI> A;\nvector<unsigned> B;\n\nint main(int argc, char *argv[])\n{\n    scanf(\"%u%u\", &N, &L);\n\n    t.resize(N);\n    v.resize(N);\n    A.resize(N);\n    B.resize(N);\n\n    scanf(\"%u%u\", &t[0], &v[0]);\n\n    A[0] = make_pair(t[0], v[0]);\n    B[0] = 0;\n    printf(\"%.7f\\n\", A[0].first);\n\n    FOR1(i,1,N) {\n        scanf(\"%u%u\", &t[i], &v[i]);\n        if (A[i-1].first < t[i]) {\n            A[i] = make_pair(t[i], v[i]);\n            B[i] = A[i-1].second;\n        }\n        else if (A[i-1].first == t[i]) {\n            A[i] = make_pair(t[i], min(A[i-1].second + v[i], L));\n            B[i] = 0;\n        }\n        else {\n            unsigned vol = min(L, A[i-1].second + v[i]);\n            double tmp = (t[i] * v[i] + A[i-1].first * (vol - v[i])) / vol;\n            for (int j = i-2; vol < L && A[j].first >= tmp; j--) {\n                tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                    / (vol + min(L-vol, B[j+1]));\n                vol += min(L-vol, B[j+1]);\n            }\n            A[i] = make_pair(tmp, vol);\n            B[i] = 0;\n        }\n\n        unsigned vol = A[i].second;\n        double tmp = A[i].first;\n        for (int j = i-1; vol < L; j--) {\n            tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                / (vol + min(L-vol, B[j+1]));\n            vol += min(L-vol, B[j+1]);\n        }\n\n        printf(\"%.7f\\n\", tmp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nint l,r;\ninline Vector merge(Vector a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n\treturn a;\t\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tint del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) q[r-1]=merge(q[r-1],q[r--]);\n\t\tcout<<(db)y/L<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, l, r) for (register int i = (l), i##end = (int)(r); i <= i##end; ++i)\n#define Fordown(i, r, l) for (register int i = (r), i##end = (int)(l); i >= i##end; --i)\n#define Rep(i, r) for (register int i = (0), i##end = (int)(r); i < i##end; ++i)\n#define Set(a, v) memset(a, v, sizeof(a))\n#define Cpy(a, b) memcpy(a, b, sizeof(a))\n#define debug(x) cout << #x << \": \" << (x) << endl\n\nusing namespace std;\n\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, T b) { return b > a ? a = b, 1 : 0; }\n\ninline int read() {\n\tint x(0), sgn(1); char ch(getchar());\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') sgn = -1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x * 10) + (ch ^ 48);\n\treturn x * sgn;\n}\n\nvoid File() {\n#ifdef zjp_shadow\n\tfreopen (\"F.in\", \"r\", stdin);\n\tfreopen (\"F.out\", \"w\", stdout);\n#endif\n}\n\nconst int N = 5e5 + 1e3;\n\nint n, L, fr = 1, tl;\n\nstruct water {\n\tdouble s; long long v;\n\tinline water friend operator + (const water &lhs, const water &rhs) {\n\t\treturn (water){(lhs.s * lhs.v + rhs.s * rhs.v) / (lhs.v + rhs.v), lhs.v + rhs.v};\n\t}\n\tinline water friend operator - (const water &lhs, const water &rhs) {\n\t\treturn (water){(lhs.s * lhs.v - rhs.s * rhs.v) / (lhs.v - rhs.v), lhs.v - rhs.v};\n\t}\n} q[N], res, now;\n\nint main () {\n\n\tFile();\n\n\tn = read(); L = read();\n\tFor (i, 1, n) {\n\t\tnow.s = read(); now.v = read(); res = res + now;\n\t\tfor (; fr <= tl && res.v > L; ++ fr) {\n\t\t\tif (res.v - L > q[fr].v) res = res - q[fr];\n\t\t\telse {\n\t\t\t\twater tmp = (water){q[fr].s, res.v - L};\n\t\t\t\tq[fr] = q[fr] - tmp; res = res - tmp; break;\n\t\t\t}\n\t\t}\n\t\tfor (q[++ tl] = now; fr + 1 <= tl; -- tl) {\n\t\t\tif (q[tl].s > q[tl - 1].s) break;\n\t\t\tq[tl - 1] = q[tl - 1] + q[tl];\n\t\t}\n\t\tprintf (\"%lf\\n\", res.s);\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n     DB d = min(l, W.front().se);\n     V -= d*W.front().fi;\n     l -= d; W.front().se -= d;\n     if (!sgn(W.front().se)) W.pop_front();\n     }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n    // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RF(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.back().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<db,db> pa;\nconst int N=1e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint L,n;\npa q[N],p[N];\npa merge(pa a,pa b){return pa((a.w1*a.w2+b.w1*b.w2)/(a.w2+b.w2),a.w2+b.w2);}\n#define QQ(a) (a.w1*a.w2)\nint main(){\n\tread(n,L);\n\tint h=5e5,t=h;\n\trep(i,1,n)scanf(\"%lf%lf\",&p[i].w1,&p[i].w2);\n\tq[h]=p[1];\n\tprintf(\"%.8lf\\n\",p[1].w1);\n\tdb all=p[1].w2,Q=QQ(p[1]);\n\trep(i,2,n){\n\t\tall+=p[i].w2;\n\t\twhile(h<t&&all-q[t].w2>L){\n\t\t\tall-=q[t].w2;\n\t\t\tQ-=QQ(q[t]);\n\t\t\tt--;\n\t\t}\n\t\tif(all>L){\n\t\t\tQ-=QQ(q[t]);\n\t\t\tq[t].w2-=all-L,all=L;\n\t\t\tQ+=QQ(q[t]);\n\t\t}\n\t\t\n\t\tif(q[h]>p[i]){\n\t\t\tQ-=QQ(q[h]);\n\t\t\tq[h]=merge(q[h],p[i]);\n\t\t\tQ+=QQ(q[h]);\n\t\t}else{\n\t\t\th--;\n\t\t\tq[h]=p[i];\n\t\t\tQ+=QQ(q[h]);\n\t\t}\n\t\t\n\t\tprintf(\"%.8lf\\n\",Q/all);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\nusing Pdi = pair<double, int>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    double L; cin >> L;\n    vector<int> t(N), v(N);\n    vector<double> ans(N, 0.0);\n    REP(i, N) cin >> t[i] >> v[i];\n\n    deque<Pdi> dq;\n    double S = 0.0;\n    int V = 0;\n    REP(i, N){\n        int L0 = L - v[i];\n        while(V > L0){\n            double t2 = dq.front().f;\n            int v2 = dq.front().s;\n            dq.pop_front();\n            if(v2 > V - L0){\n                v2 -= V - L0;\n                S -= t2 * (V - L0);\n                V = L0;\n                dq.push_front(Pdi(t2, v2));\n            }else{\n                S -= t2 * v2;\n                V -= v2;\n            }\n        }\n\n        V += v[i];\n        S += t[i] * v[i];\n        double t0 = t[i];\n        int v0 = v[i];\n        while(SZ(dq) > 0 && dq.back().f > t0){\n            double t1 = dq.back().f;\n            int v1 = dq.back().s;\n            dq.pop_back();\n            t0 = (t0 * v0 + t1 * v1) / (v0 + v1);\n            v0 = v0 + v1;\n        }\n        dq.push_back(Pdi(t0, v0));\n        \n        ans[i] = S / L;\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 501000\n#define db double\nusing namespace std;\nint n,m,l;\ndb d[N][2];\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tdb V=0,T=0;\n\tint he=0,ta=0;\n\tfo(i,1,n)\n\t{\n\t\tdb x,y;scanf(\"%lf%lf\",&x,&y);\n\t\twhile(V+y>l)\n\t\t{\n\t\t\tdb jy=min(d[he][1],V+y-l);\n\t\t\td[he][1]-=jy;\n\t\t\tT-=jy*d[he][0];\n\t\t\tV-=jy;\n\t\t\tif(d[he][1]==0) he++;\n\t\t}\n\t\tV+=y;T+=x*y;\n\t\tfor(d[++ta][0]=x,d[ta][1]=y;he<ta&&d[ta][0]<d[ta-1][0];ta--)\n\t\t{\n\t\t\td[ta-1][0]=(d[ta-1][0]*d[ta-1][1]+d[ta][0]*d[ta][1])/(d[ta-1][1]+d[ta][1]);\n\t\t\td[ta-1][1]+=d[ta][1];\n\t\t}\n\t\tprintf(\"%lf\\n\",T/l);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n\nconst int maxn=5e5+10;\n\nint n,L,H,T;\n\nstruct Point{\n\tLL x;\n\tdouble y;\n\tPoint() {}\n\tPoint(LL x,double y):x(x),y(y) {}\n\tPoint operator + (const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator - (const Point &p) const {return Point(x-p.x,y-p.y);}\n};\n\ndouble Cross(Point A,Point B) {return A.x*B.y-A.y*B.x;}\n\nPoint P[maxn];\n\nPoint GetPoint(Point A,Point B,LL x)\n{\n\tdouble t=((double)x-A.x)/(B.x-A.x);\n\treturn Point(x,A.y+t*(B.y-A.y));\n}\n\nvoid print()\n{\n\tfor (int i=H;i<=T;i++)\n\t\tprintf(\"(%lld, %lf) (%lld, %lf)\\n\",P[i].x,P[i].y,P[i].x-P[T].x,P[i].y-P[T].y);\n\tputs(\"\");\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&L);\n\tH=T=1;\n\tP[1]=Point(0,0);\n\twhile (n--)\n\t{\n\t\tPoint p;\n\t\tscanf(\"%lf%lld\",&p.y,&p.x);\n\t\tp.y*=p.x;\n\t\tT++;\n\t\tP[T]=P[T-1]-p;\n\n//\t\tputs(\"print1\"); print();\n\n\t\twhile (H!=T&&P[H+1].x-P[T].x>=L) H++;\n\n//\t\tputs(\"print2\"); print();\n\n\t\tif (P[H].x-P[T].x>L)\n\t\t\tP[H]=GetPoint(P[H],P[H+1],P[T].x+L);\n\n//\t\tputs(\"print3\"); print();\n\n\t\twhile (H+1<T&&Cross(P[T-1]-P[T],P[T-2]-P[T])>=0) P[T-1]=P[T],T--;\n\n//\t\tputs(\"print4\"); print();\n\n\n\t\tprintf(\"%.10lf\\n\",((double)P[H].y-P[T].y)/L);\n//\t\tputs(\"\");\n//\t\tputs(\"---------------------\");\n//\t\tputs(\"\");\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\ndouble sumsTV[500011];\ndouble sumsV[500011];\n\ndouble evalH(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + H[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\ndouble evalT(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + T[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\n\nint qu[500011];\nint *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    REP (i, N) {\n\tsumsTV[i+1] = sumsTV[i] + (double)T[i] * V[i];\n\tsumsV[i+1] = sumsV[i] + V[i];\n    }\n\n    H[0] = T[0];\n    *head = 0; // {0};\n\n    int pos = 0;\n    for (int i=1; i<N; i++) {\n\twhile (sumsV[i+1] - sumsV[*head+1] >= L) head++;\n\twhile (head < tail) {\n\t    double d = evalH(*head, i);\n\t    if (d <= evalH(*(head+1), i)) {\n\t\thead++;\n\t\tcontinue;\n\t    } else if (head+1 < tail && d <= evalH(*(head+2), i)) {\n\t\thead+=2;\n\t\tcontinue;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n\n\tif (head <= tail) amax(H[i], evalH(*head, i));\n\n\twhile (sumsV[i+1] - sumsV[pos+1] >= L) pos++;\n\tamax(H[i], evalT(pos, i));\n\n\twhile (head <= tail && H[*tail] <= H[i]) tail--;\n\ttail++;\n\t*tail = i;\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t    ans[i]=sum/m;\n\t\twhile(l<r&&q[r].a<q[r-1].a){\n\t\t\tdouble tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*q[r-1].b)/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.7lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n#define Add(x, y) x = (x + (y)) % mod\n#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    double L; cin >> L;\n    vector<double> t(N), v(N), ans(N, 0.0);\n    REP(i, N) cin >> t[i] >> v[i];\n    ans[0] = t[0];\n\n    FOR(i, 1, N){\n        double V = v[i], T = t[i];\n        IFOR(j, 0, i){\n            if(V > L) continue;\n            double tmp = (ans[j] * (L - V) + T * V) / L;\n            Max(ans[i], tmp);\n            T = (T * V + t[j] * v[j]) / (V + v[j]);\n            V += v[j];\n        }\n    }\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[4000005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(0,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/(long double)l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[800005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n        return (one * two * three);\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_IOSTREAM\n#include<bits/stdc++.h>\n#define maxn 501000\nusing namespace std;\ntypedef long long ll;\ntypedef long double ldb;\nstruct point{ldb x,y;point(){}point(ldb x,ldb y):x(x),y(y){}}q[maxn],p;\nint l,r,n,L;\nldb cross(point a,point b,point c){\n\treturn (b.x-a.x)*(c.y-a.y)-(b.y-a.y)*(c.x-a.x);\n}\nint main(){\n//\tprintf(\"[%.3lf]\",cross(point{0,0},point{1,1},point{1,0}));\n\tscanf(\"%d%d\",&n,&L);\n\tq[r++]=point(0,0);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%Lf%Lf\",&p.y,&p.x);\n\t\tp.y*=p.x,p.x+=q[r-1].x,p.y+=q[r-1].y,q[r]=p;\n\t\twhile(p.x-q[l+1].x>L&&l+1<r)l++;\n\t\tif(q[r].x-q[l].x>L){\n\t\t\tldb k=(q[l+1].y-q[l].y)/(q[l+1].x-q[l].x),b=q[l].y-k*q[l].x;\n\t\t\tq[l].x=p.x-L,q[l].y=q[l].x*k+b;\t\n\t\t}\n//\t\tprintf(\"{%.7lf,%.7lf}\",q[l].x,q[l].y);\n\t\tprintf(\"%.7Lf\\n\",(p.y-q[l].y)/(ldb)(p.x-q[l].x));\n\t\twhile(l+1<r&&cross(q[r-2],p,q[r-1])>=0)r--;//,printf(\"[ok]\");\n\t\tq[r++]=p;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, l;\n  cin >> n >> l;\n  deque<pair<double, ll>> q;\n  ll sumV = 0;\n  double sumVT = 0;\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) {\n    ll t, v;\n    cin >> t >> v;\n    while(sumV + v > l) {\n      auto p = q.front();\n      q.pop_front();\n      ll wd = sumV + v - l;\n      ll del = min(wd, p.second);\n      sumV -= del;\n      p.second -= del;\n      sumVT -= del * p.first;\n      if(p.second) q.push_front(p);\n    }\n\n    double o = (sumVT + v * t) / l;\n\n    cout << o << \"\\n\";\n\n    if(q.back().first < t) {\n      q.emplace_back(t, v);\n      sumV += v;\n      sumVT += v * t;\n    } else {\n      q.clear();\n      q.emplace_back(o, l);\n      sumV = l;\n      sumVT = o * l;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n\nconst int N = 500010;\n\nusing namespace std;\n\nstruct Point{\n\tdouble x, y;\n\n\tPoint(double _x = 0, double _y = 0):x(_x), y(_y) {}\n\n}q[N];\n\ntypedef Point Vector;\n\nVector operator + (const Vector& A, const Vector& B){\t\n\treturn Point(A.x + B.x, A.y + B.y);\n}\n\nVector operator - (const Vector& A, const Vector& B){\t\n\treturn Point(A.x - B.x, A.y - B.y);\n}\n\nint n, L;\n\nint main(){\n\n\tint l = 0, r = -1;\n\tPoint sum;\n\n\tscanf(\"%d%d\", &n, &L);\n\twhile(n--){\n\t\tPoint p;\n\t\tscanf(\"%lf%lf\", &p.y, &p.x);\n\t\tp.y *= p.x;\n\n\t\twhile(l <= r && sum.x > L - p.x){\n\t\t\tsum = sum - q[l];\n\t\t\tif(sum.x < L - p.x){\n\t\t\t\tdouble len = L - p.x - sum.x;\n\t\t\t\tq[l] = Point(len, q[l].y / q[l].x * len);\n\t\t\t\tsum = sum + q[l];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++l;\n\t\t}\n\n\t\tq[++r] = p;\n\t\tsum = sum + p;\n\n\t\tprintf(\"%.8lf\\n\", 1.0 * sum.y / L);\n\n\t\twhile(l < r && q[r].y / q[r].x < q[r - 1].y / q[r - 1].x){\n\t\t\tq[r - 1] = q[r - 1] + q[r]; --r;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <array>\n// stream\n//#include <istream>\n#include <sstream>\n//#include <ostream>\n#include <fstream>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n//#include <chrono>\n#include <random>\n#include <numeric>\n\nnamespace mystd {\n\tint stoi(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tint res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\tlong long stoll(std::string s) {\n\t\tstd::stringstream ss(s);\n\t\tlong long res = 0;\n\t\tss >> res;\n\t\treturn res;\n\t}\n\ttemplate<class T>\n\tstd::string to_string(T d) {\n\t\tstd::stringstream ss;\n\t\tss << d;\n\t\tstd::string res;\n\t\tss >> res;\n\t\treturn res;\n\t}\n}\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w=0; w<n; ++w){MACRO_VEC_ROW_Scan(w, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define FORLL(w, a, n) for(ll w=ll(a);w<ll(n);++w)\n#define RFORLL(w, a, n) for(ll w=ll(n)-1;w>=ll(a);--w)\n#define REPLL(w, n) for(ll w=0;w<ll(n);++w)\n#define RREPLL(w, n) for(ll w=ll(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\n//void CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, l);\n\tVEC_ROW(int, n, t, v);\n\n\tusing P = std::pair<double, int>;\n\tstd::deque<P> deq;\n\tdouble sum = t[0] * v[0];\n\tdeq.push_back(P(t[0], v[0]));\n\tFOUT(12, t[0])BR;\n\tFOR(i, 1, n) {\n\t\tint rest = v[i];\n\t\twhile (rest) {\n\t\t\tP p = deq.front(); deq.pop_front();\n\t\t\tint mi = std::min(rest, p.second);\n\t\t\tsum -= p.first * mi;\n\t\t\trest -= mi;\n\t\t\tp.second -= mi;\n\t\t\tif (p.second) deq.push_front(p);\n\t\t}\n\t\tsum += t[i] * v[i];\n\t\tFOUT(12, sum / l)BR;\n\n\t\tP p(t[i], v[i]);\n\t\twhile (!deq.empty() && deq.back().first >= p.first) {\n\t\t\tP q = deq.back(); deq.pop_back();\n\t\t\tp.first = (p.first * p.second + q.first * q.second) / (p.second + q.second);\n\t\t\tp.second = p.second + q.second;\n\t\t}\n\t\tdeq.push_back(p);\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,LL> P;\n\nconst int S=5e5+10;\ndouble ts[S];\nLL vs[S];\nint N;\ndouble L;\nint main() {\n\tcout.precision(17);\n\tcin >> N >> L;\n\tdouble sum=0;\n\tLL sumv=0;\n\tint s=0; \n\tvector<P> q;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> ts[i];\n\t\tcin >> vs[i];\n\t\tif(s<q.size()&&q.back().first>ts[i]){\n\t\t\tif(q.back().second+vs[i]>=L){\n\t\t\t\tauto t=(vs[i]*ts[i]+(L-vs[i])*q.back().first)/L;\n\t\t\t\tauto v=L;\n\t\t\t\tsum+=t*v;\n\t\t\t\tsumv+=v;\n\t\t\t\tq.push_back(P(t,v));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum+=ts[i]*vs[i];\n\t\t\t\tsumv+=vs[i];\n\t\t\t\tauto v=vs[i]+q.back().second;\n\t\t\t\tauto t=(vs[i]*ts[i]+q.back().second*q.back().first)/v;\n\t\t\t\tq.back()=P(t,v);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsum+=ts[i]*vs[i];\n\t\t\tsumv+=vs[i];\n\t\t\tq.push_back(P(ts[i],vs[i]));\n\t\t}\n\t\twhile(sumv>L){\n\t\t\tif(sumv-q[s].second>=L){\n\t\t\t\tsumv-=q[s].second;\n\t\t\t\tsum-=q[s].first*q[s].second;\n\t\t\t\ts++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL d=sumv-L;\n\t\t\t\tsumv-=d;\n\t\t\t\tsum-=q[s].first*d;\n\t\t\t\tq[s].second-=d;\n\t\t\t}\n\t\t}\n\t\tcout << sum/L << endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\ntypedef long double ld;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=500010;\nstruct water{\n\tld t;\n\tint v;\n\tinline friend water operator + (const water &a,const water &b){\n\t\tint sum=a.v+b.v;\n\t\tif(sum==0)return (water){0,0};\n\t\treturn (water){a.t*((ld)a.v/sum)+b.t*((ld)b.v/sum),sum};\n\t}\n\tinline void operator += (const water &b){\n\t\t*this=*this+b;\n\t}\n\tinline void operator -= (const water &b){\n\t\t*this+=(water){b.t,-b.v};\n\t}\n}que[N],cur;\nint main(){\n\tint n=ni,v=ni;\n\tint qh=0,qt=0;\n\tfor(int i=1;i<=n;i++){\n\t\tint tmp=ni;\n\t\twater a=(water){(ld)tmp,ni};\n\t\tfor(;cur.v+a.v>v&&cur.v+a.v-que[qh].v>=v;cur-=que[qh++]);\n\t\tif(cur.v+a.v>v){\n\t\t\tque[qh].v-=cur.v+a.v-v;\n\t\t\tcur-=(water){que[qh].t,cur.v+a.v-v};\n\t\t}\n\t\tcur+=a;\n\t\tprintf(\"%.10lf\\n\",(double)cur.t);\n\t\tfor(;qh<qt&&que[qt-1].t>tmp;a+=que[--qt]);\n\t\tque[qt++]=a;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint main(void) {\n\tll n, l;\n\tcin >> n >> l;\n\n\tcout.precision(20);\n\tR cap = 0.0;\n\tll total = 0LL;\n\n\tusing state = pair<R, ll>;\n\tdeque<state> q;\n\n\t{\n\t\tll t, v;\n\t\tcin >> t >> v;\n\t\tstate cur = state(1.0 * t * v, v);\n\n\t\tcap += cur.first;\n\t\ttotal += cur.second;\n\n\t\tq.push_front(cur);\n\t\tcout << fixed << t << endl;\n\t}\n\n\trep(i, 1, n) {\n\t\tll t, v;\n\t\tcin >> t >> v;\n\n\t\twhile (!q.empty() and total > l - v) {\n\t\t\tstate tmp = q.back();\n\t\t\tq.pop_back();\n\n\t\t\tconst ll tvol = min(tmp.second, total - l + v);\n\t\t\tconst R  tcap = tmp.first * tvol / tmp.second;\n\n\t\t\tcap -= tcap;\n\t\t\ttotal -= tvol;\n\n\t\t\ttmp.first -= tcap;\n\t\t\ttmp.second -= tvol;\n\n\t\t\tif (tmp.second != 0) q.push_back(tmp);\n\t\t}\n\n\n\t\tstate cur = state(1.0 * t * v, v);\n\t\tq.push_front(cur);\n\n\t\tcap += cur.first;\n\t\ttotal += cur.second;\n\n\t\twhile(q.size()>=2){\n\t\t\tstate fst = q.front(); q.pop_front();\n\t\t\tstate snd = q.front(); q.pop_front();\n\n\t\t\t// cur.first / cur.second < front.first / front.second\n\t\t\tif (fst.first * snd.second < snd.first * fst.second) {\n\t\t\t\tstate in = state(fst.first + snd.first, fst.second + snd.second);\n\t\t\t\tq.push_front(in);\n\t\t\t}else {\n\t\t\t\tq.push_front(snd);\n\t\t\t\tq.push_front(fst);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//cerr << cap << \" \" << total << endl;\n\n\t\t\n\n\t\t\n\t\tcout << fixed <<  1.0 * cap / l << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define mod 998244353\n#define db double\nusing namespace std;\ninline ll read(){\n\tll res=0,f=1;char ch=getchar();\n\twhile(!isdigit(ch)) {if(ch=='-') f=-f;ch=getchar();}\n\twhile(isdigit(ch)) {res=(res<<1)+(res<<3)+(ch^48);ch=getchar();}\n\treturn res*f;\n}\nconst int N=1e6+5;\nstruct Vector{ll v;db t;}q[N];\nll t[N],v[N];\nll n,x,y,L;\nll l,r;\ninline void merge(Vector &a,Vector b){\n\ta.t=(a.t*a.v+b.t*b.v)/(a.v+b.v);\n\ta.v+=b.v;\n}\nint main(){\n\tn=read();L=read();\n\tl=1,r=0;\n\tfor(ll i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(x+v[i]>L){\n\t\t\tll del=min(q[l].v,x+v[i]-L);\n\t\t\tq[l].v-=del;\n\t\t\tx-=del,y-=del*q[l].t;\n\t\t\tif(!q[l].v) ++l;\n\t\t}\n\t\tq[++r].v=v[i];q[r].t=t[i];\n\t\ty+=v[i]*t[i],x+=v[i];\n\t\twhile(l<r && q[r].t<q[r-1].t) merge(q[r-1],q[r]),--r;\n        printf(\"%lf\\n\",(db)y/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing lint = long long;\nusing plint = pair<double, lint>;\n\nint N;\nlint L;\n\ndeque<plint> deq;\ndouble Qsum = 0;\nlint Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        lint nuku = min(Vnow - L, deq.front().second);\n        deq.front().second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq.front().first;\n        if (deq.front().second == 0) deq.pop_front();\n    }\n}\n\nvoid add(double tadd, lint vadd)\n{\n    if (deq.back().first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        deq.push_back(plint(tadd, vadd));\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq.back().second + vadd >= L)\n        {\n            Qsum = deq.back().first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            deq.clear();\n            deq.push_back(plint(Qsum / L, L));\n        }\n        else\n        {\n            double Qaddnew = deq.back().first * deq.back().second + tadd * vadd;\n            lint vaddnew = deq.back().second + vadd;\n            Qsum -= deq.back().first * deq.back().second;\n            Vnow -= deq.back().second;\n            deq.pop_back();\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\nvoid print()\n{\n    cout << setprecision(12) << Qsum / L << endl;\n}\nint main()\n{\n    cin.tie(0); ios::sync_with_stdio(0);\n    cin >> N >> L;\n    REP(_, N)\n    {\n        double t;\n        lint v;\n        cin >> t >> v;\n        if (_ == 0)\n        {\n            deq.push_back(plint(t, v));\n            Qsum = t * v;\n            Vnow = v;\n            print();\n        }\n        else\n        {\n            add(t, v);\n            print();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RF(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && W.back().fi >= v){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, int> pairDI;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nint N, L;\nvector<int> t, v;\nvector<pairDI> A;\nvector<int> B;\n\nint main(int argc, char *argv[])\n{\n    cin >> N >> L;\n\n    t.resize(N);\n    v.resize(N);\n    A.resize(N);\n    B.resize(N);\n\n    cin >> t[0] >> v[0];\n\n    A[0] = make_pair(t[0], v[0]);\n    B[0] = 0;\n    cout << fixed << setprecision(7) << A[0].first << endl;\n\n    FOR1(i,1,N) {\n        cin >> t[i] >> v[i];\n        if (A[i-1].first < t[i]) {\n            A[i] = make_pair(t[i], v[i]);\n            B[i] = A[i-1].second;\n        }\n        else if (A[i-1].first == t[i]) {\n            A[i] = make_pair(t[i], min(A[i-1].second + v[i], L));\n            B[i] = 0;\n        }\n        else {\n            int vol = min(L, A[i-1].second + v[i]);\n            double tmp = (t[i] * v[i] + A[i-1].first * (vol - v[i])) / vol;\n            for (int j = i-2; vol < L && A[j].first >= tmp; j--) {\n                tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                    / (vol + min(L-vol, B[j+1]));\n                vol += min(L-vol, B[j+1]);\n            }\n            A[i] = make_pair(tmp, vol);\n            B[i] = 0;\n        }\n\n        int vol = A[i].second;\n        double tmp = A[i].first;\n        for (int j = i-1; vol < L; j--) {\n            tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                / (vol + min(L-vol, B[j+1]));\n            vol += min(L-vol, B[j+1]);\n        }\n\n        cout << fixed << setprecision(7) << tmp << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cctype>\nusing namespace std;\nconst int N=5e5+5;\nstruct data\n{\n\tdouble t;\n\tint v;\n}q[N],p;\nint l=1,r=0;\ninline int read()\n{\n    int X=0,w=0; char ch=0;\n    while(!isdigit(ch)) w|=ch=='-',ch=getchar();\n    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n    return w?-X:X;\n}\nint main()\n{\n\tint n=read(),L=read(),L0=L;\n\tdouble now=0;\n\twhile(n--)\n\t{\n\t\tp.t=read(),p.v=read();\n\t\twhile(p.v>L)\n\t\t\tif(q[l].v+L<p.v)\n\t\t\t{\n\t\t\t\tnow-=q[l].v*q[l].t;\n\t\t\t\tL+=q[l++].v;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tnow-=p.v*q[l].t;\n\t\t\t\tL+=p.v;\n\t\t\t\tq[l].v-=p.v;\n\t\t\t}\n\t\tL-=p.v;\n\t\tnow+=p.v*p.t;\n\t\tq[++r]=p;\n\t\twhile(l<r && q[r-1].t>=q[r].t)\n\t\t{\n\t\t\tq[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v+q[r].v);\n\t\t\tq[r-1].v+=q[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.6lf\\n\",now*1.0/(L0-L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tsum += t * v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\n\t\tif (dq.empty() || dq.back().first <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(20) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,LL> P;\n\nint N;\nLL L;\nint main() {\n\tcout.precision(17);\n\tscanf(\"%d%lld\",&N,&L);\n\tdouble sum=0;\n\tLL sumv=0;\n\tdeque<P> q;\n\tfor(int i=0;i<N;i++){\n\t\tdouble t;\n\t\tLL v;\n\t\tscanf(\"%lf%lld\",&t,&v);\n\t\tsum+=t*v;\n\t\tsumv+=v;\n\t\twhile(q.size()&&q.back().first>t&&v<L){\n\t\t\t//cerr << t << \", \" << v << endl;\n\t\t\tif(q.back().second+v>=L){\n\t\t\t\tt=(v*t+(L-v)*q.back().first)/L;\n\t\t\t\tq.back().second-=L-v;\n\t\t\t\tv=L;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tauto v2=v+q.back().second;\n\t\t\t\tt=(v*t+q.back().second*q.back().first)/v2;\n\t\t\t\tv=v2;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t}\n\t\t//cerr << t << \", \" << v << endl;\n\t\tq.push_back(P(t,v));\n\t\twhile(sumv>L){\n\t\t\tif(sumv-q.front().second>=L){\n\t\t\t\tsumv-=q.front().second;\n\t\t\t\tsum-=q.front().first*q.front().second;\n\t\t\t\tq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tLL d=sumv-L;\n\t\t\t\tsumv-=d;\n\t\t\t\tsum-=q.front().first*d;\n\t\t\t\tq.front().second-=d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9lf\\n\",sum/L);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio>\n#include <deque>\n#include <iomanip>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = a , _b = b ; i <= _b ; ++i)\n#define Ford(i , a  ,b) for (int i = a , _b = b : i >= _b ; --i)\n#define Rep(i , n) for (int i = 0 , _n = n ; i < _n ; ++i)\n#define sz(A) ((int)A.size())\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n\ntypedef pair<int , int> pt;\n\nint n;\nint L;\n\nvoid ReadData() {\n\tcin >> n >> L;\n} \n\ndeque<pair<long double, long long> > qu;\nvoid Process() {\n\tcout << fixed << setprecision(6);\n\n\tlong long sumRem = 0;\n\tlong double sumTV = 0;\n\tFor(i,1,n) {\n\t\tint t,v; cin >> t >> v;\n\t\tif (sz(qu) == 0) {\n\t\t\tqu.push_back(make_pair(t,v));\n\t\t\tsumRem += v;\n\t\t\tsumTV += 1LL * v * t;\n\t\t\tcout << t << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sumRem + v > L) {\n\t\t\tauto &cur = qu.front();\n\t\t\tif (cur.second <= (sumRem + v) - L) {\n\t\t\t\tsumRem -= cur.second;\n\t\t\t\tsumTV -= #include <iostream> \n#include <cstdio>\n#include <deque>\n#include <iomanip>\n\nusing namespace std;\n\n#define For(i , a , b) for (int i = a , _b = b ; i <= _b ; ++i)\n#define Ford(i , a  ,b) for (int i = a , _b = b : i >= _b ; --i)\n#define Rep(i , n) for (int i = 0 , _n = n ; i < _n ; ++i)\n#define sz(A) ((int)A.size())\n#define LL(x) (x << 1)\n#define RR(x) ((x << 1) | 1)\n\ntypedef pair<int , int> pt;\n\nint n;\nint L;\n\nvoid ReadData() {\n\tcin >> n >> L;\n} \n\ndeque<pair<long double, long long> > qu;\nvoid Process() {\n\tcout << fixed << setprecision(6);\n\n\tlong long sumRem = 0;\n\tlong double sumTV = 0;\n\tFor(i,1,n) {\n\t\tint t,v; cin >> t >> v;\n\t\tif (sz(qu) == 0) {\n\t\t\tqu.push_back(make_pair(t,v));\n\t\t\tsumRem += v;\n\t\t\tsumTV += 1LL * v * t;\n\t\t\tcout << t << \"\\n\";\n\t\t\tcontinue;\n\t\t}\n\t\twhile (sumRem + v > L) {\n\t\t\tauto &cur = qu.front();\n\t\t\tif (cur.second <= (sumRem + v) - L) {\n\t\t\t\tsumRem -= cur.second;\n\t\t\t\tsumTV -= 1LL * cur.first * cur.second;\n\t\t\t\tqu.pop_front();\n\t\t\t} else {\n\t\t\t\tcur.second -= ((sumRem + v) - L);\n\t\t\t\tsumTV -=  cur.first *((sumRem + v) - L);\n\t\t\t\tsumRem -= ((sumRem + v) - L);\n\t\t\t}\n\t\t}\n\t\tlong double res = (sumTV + 1LL * v * t) / (sumRem + v);\n\t\tcout << (double) res << \"\\n\";\n\n\t\tpair<long double, long long> add = make_pair(t,v);\n\t\twhile (sz(qu) && qu.back().first >= add.first) {\n\t\t\tadd = make_pair( (qu.back().first * qu.back().second \n\t\t\t\t+ add.first * add.second) / (qu.back().second + add.second),\n\t\t\t\tqu.back().second + add.second  );\n\t\t\tsumRem -= qu.back().second;\n\t\t\tsumTV -= qu.back().first * qu.back().second;\n\t\t\tqu.pop_back();\n\t\t}\n\t\tqu.push_back(add);\n\t\tsumRem += add.second;\n\t\tsumTV += add.first * add.second;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\t//freopen(\"input.inp\" , \"r\" , stdin);\n\tReadData();\n\tProcess();\n\n\treturn 0;\n\n}\t\t\t cur.first * cur.second;\n\t\t\t\tqu.pop_back();\n\t\t\t} else {\n\t\t\t\tcur.second -= ((sumRem + v) - L);\n\t\t\t\tsumTV -=  cur.first *((sumRem + v) - L);\n\t\t\t\tsumRem -= ((sumRem + v) - L);\n\t\t\t}\n\t\t}\n\t\tlong double res = (sumTV + 1LL * v * t) / (sumRem + v);\n\t\tcout << (double) res << \"\\n\";\n\n\t\tpair<long double, long long> add = make_pair(t,v);\n\t\twhile (sz(qu) && qu.back().first >= add.first) {\n\t\t\tadd = make_pair( (qu.back().first * qu.back().second \n\t\t\t\t+ add.first * add.second) / (qu.back().second + add.second),\n\t\t\t\tqu.back().second + add.second  );\n\t\t\tsumRem -= qu.back().second;\n\t\t\tsumTV -= qu.back().first * qu.back().second;\n\t\t\tqu.pop_back();\n\t\t}\n\t\tqu.push_back(add);\n\t\tsumRem += add.second;\n\t\tsumTV += add.first * add.second;\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\t\n\t//freopen(\"input.inp\" , \"r\" , stdin);\n\tReadData();\n\tProcess();\n\n\treturn 0;\n\n}\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tsum += t * v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\n\t\tif (dq.empty() || dq.back().first <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(12) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\nchar obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;\ninline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}\ninline void putc(char x){*oS++ =x;if(oS==oT) flush();}\ninline void printd(int d,double x)\n{\n    long long t=(long long)floor(x),f=t;\n    while(t) qu[++qr]=t%10,t/=10;\n    while(qr) putc(qu[qr--]+'0');\n    putc('.');x-=f;\n    while(d--)\n    {\n        double y=x*10;x*=10;\n        int c=(int)floor(y);\n        putc(c+'0');x-=c;\n    }\n}\n\ntypedef long long LL;\ntypedef pair<LL,double> pld;\nconst int N=500010;\nLL t[N],v[N];\npld q[N];\nint l=1,r=0;\n\nint main()\n{\n    int n=read(),L=read();\n    for(int i=1;i<=n;i++)\n        t[i]=read(),v[i]=read();\n    int sum=0;double cur=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(v[i]+sum>L)\n        {\n            int pour=min(v[i]+sum-L,q[l].FR);\n            sum-=pour;\n            q[l].FR-=pour;\n            cur-=q[l].SE*pour;\n            if(!q[l].FR) l++;\n        }\n        q[++r]=pld(v[i],t[i]);\n        sum+=v[i];cur+=1ll*t[i]*v[i];\n        while(l<r&&q[r].SE<q[r-1].SE)\n        {\n            q[r-1].SE=(q[r-1].SE*q[r-1].FR+q[r].SE*q[r].FR)/(q[r-1].FR+q[r].FR);\n            q[r-1].FR+=q[r].FR;r--;\n        }\n        printd(7,cur/L);putc('\\n');\n    }\n    flush();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nint main(void) {\n\tll n, l;\n\tcin >> n >> l;\n\n\tcout.precision(20);\n\tR cap = 0.0;\n\tll total = 0LL;\n\n\tusing state = pair<R, ll>;\n\tdeque<state> q;\n\n\t{\n\t\tll t, v;\n\t\tcin >> t >> v;\n\t\tstate cur = state(1.0 * t * v, v);\n\n\t\tcap += cur.first;\n\t\ttotal += cur.second;\n\n\t\tq.push_front(cur);\n\t\tcout << fixed << t << endl;\n\t}\n\n\trep(i, 1, n) {\n\t\tll t, v;\n\t\tcin >> t >> v;\n\n\t\twhile (!q.empty() and total > l - v) {\n\t\t\tstate tmp = q.back();\n\t\t\tq.pop_back();\n\n\t\t\tconst ll tvol = min(tmp.second, total - l + v);\n\t\t\tconst R  tcap = tmp.first * tvol / tmp.second;\n\n\t\t\tcap -= tcap;\n\t\t\ttotal -= tvol;\n\n\t\t\ttmp.first -= tcap;\n\t\t\ttmp.second -= tvol;\n\n\t\t\tif (tmp.second != 0) q.push_back(tmp);\n\t\t}\n\n\n\t\tstate cur = state(1.0 * t * v, v);\n\n\t\tstate front = q.front();\n\n\t\tcap += cur.first;\n\t\ttotal += cur.second;\n\n\t\t// cur.first / cur.second < front.first / front.second\n\t\tif (cur.first * front.second < front.first * cur.second) {\n\t\t\tq.pop_front();\n\t\t\tstate in = state(cur.first + front.first, cur.second + front.second);\n\t\t\tq.push_front(in);\n\t\t} else {\n\t\t\tq.push_front(cur);\n\t\t}\n\n\t\t//cerr << cap << \" \" << total << endl;\n\n\t\t\n\n\t\t\n\t\tcout << fixed <<  1.0 * cap / l << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <deque>\n#include <cstdio>\n\nusing namespace std;\n\nint main(){\n\tint N, L;\n\twhile(cin >> N >> L){\n\t\tdeque< pair<double, double> > dq;\n\t\tint t, v; cin >> t >> v;\n\t\tdq.push_back(make_pair(t, v));\n\t\tprintf(\"%.8lf\\n\", (double)t);\n\t\tdouble sumT = t * (double)v;\n\t\tfor(int i=1;i<N;i++){\n\t\t\tcin >> t >> v;\n\t\t\tdouble sub = v;\n\t\t\tfor(int j=0;j<dq.size();j++){\n\t\t\t\tif(dq[j].second <= sub){\n\t\t\t\t\tsumT -= dq[j].first * dq[j].second;\n\t\t\t\t\tsub -= dq[j].second;\n\t\t\t\t\tdq[j].second = 0;\n\t\t\t\t} else {\n\t\t\t\t\tsumT -= dq[j].first * sub;\n\t\t\t\t\tdq[j].second -= sub;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsumT += t * (double)v;\n\t\t\tprintf(\"%.8lf\\n\", sumT/L);\n\t\t\twhile(!dq.empty() && dq[0].second < 1e-8) dq.pop_front();\n\t\t\tpair<double, double> p = make_pair(t, v);\n\t\t\twhile(!dq.empty()){\n\t\t\t\tif(dq.back().first < p.first) break;\n\t\t\t\tdouble nt = dq.back().first * dq.back().second + p.first * p.second;\n\t\t\t\tdouble nv = dq.back().second + p.second;\n\t\t\t\tp.first = nt/nv;\n\t\t\t\tp.second = nv;\n\t\t\t\tdq.pop_back();\n\t\t\t}\n\t\t\tdq.push_back(p);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=500010;\nstruct water{\n\tdouble t;\n\tint v;\n\tinline friend water operator + (const water &a,const water &b){\n\t\tint sum=a.v+b.v;\n\t\tif(sum==0)return (water){0,0};\n\t\treturn (water){a.t*((double)a.v/sum)+b.t*((double)b.v/sum),sum};\n\t}\n\tinline void operator += (const water &b){\n\t\t*this=*this+b;\n\t}\n\tinline void operator -= (const water &b){\n\t\t*this+=(water){b.t,-b.v};\n\t}\n}que[N],cur;\nint main(){\n\tint n=ni,v=ni;\n\tint qh=0,qt=0;\n\tfor(int i=1;i<=n;i++){\n\t\twater a=(water){(double)ni,ni};\n\t\tfor(;cur.v+a.v>v&&cur.v+a.v-que[qh].v>=v;cur-=que[qh++]);\n\t\tif(cur.v+a.v>v){\n\t\t\tque[qh].v-=cur.v+a.v-v;\n\t\t\tcur-=(water){que[qh].t,cur.v+a.v-v};\n\t\t}\n\t\tcur+=a;\n\t\tprintf(\"%.10lf\\n\",cur.t);\n\t\tfor(;qh<qt&&que[qt-1].t>a.t;a+=que[--qt]);\n\t\tque[qt++]=a;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define JS(q,w) ((d[q][0]*d[q][1]+d[w][0]*d[w][1])/(d[q][0]+d[w][0]))\n#define SM(q) (d[q][0]*d[q][1])\nusing namespace std;\ntypedef double db;\nconst int N=500500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n;\ndb ans;\ndb d[N][2];//v t\nint main()\n{\n\tint q,w;\n\tread(n),read(m);\n\tint l=1,r=0,all=0;\n\tfo(i,1,n)\n\t{\n\t\tread(q),read(w);\n\t\td[++r][0]=w,d[r][1]=q;ans+=(db)q*w;\n\t\tall+=w;\n\t\tfor(;l<r&&d[r-1][1]>=d[r][1];--r)\n\t\t\tif(d[r-1][0]+d[r][0]<=m)\n\t\t\t{\n\t\t\t\tans-=SM(r)+SM(r-1);\n\t\t\t\td[r-1][1]=JS(r-1,r),d[r-1][0]+=d[r][0];\n\t\t\t\tans+=SM(r-1);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tl=--r;\n\t\t\t\td[r][0]=m-d[r+1][0];\n\t\t\t\td[r][1]=JS(r,r+1);\n\t\t\t\td[r][0]=m;all=m;\n\t\t\t\tans=SM(r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(;all>m;++l)if(all-d[l][0]>=m)ans-=SM(l);\n\t\telse\n\t\t{\n\t\t\tans-=SM(l);\n\t\t\td[l][0]-=(all-m);\n\t\t\tans+=SM(l);all=m;\n\t\t\tbreak;\n\t\t}\t\n\t\tprintf(\"%.10lf\\n\",ans/m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define regsiter register\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint vol;\nlong long temp;\nstruct heap\n{\n\tint pr;\n\tint cnt;\n}h[511111];\nint tot;\nbool operator <(const heap &x,const heap &y)\n{\n\treturn x.pr>y.pr;\n}\nvoid PUSH(double pr,int cnt)\n{\n\th[++tot]=(heap){pr,cnt};\n\tstd::push_heap(h+1,h+tot+1);\n}\nvoid POP()\n{\n\tstd::pop_heap(h+1,h+tot+1);\n\t--tot;\n}\nint main()\n{\n\tint n=io::F(),L=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tint t=io::F();\n\t\tint v=io::F();\n\t\twhile(vol+v>L)\n\t\t{\n\t\t\tif(vol+v-h[1].cnt>=L)\n\t\t\t{\n\t\t\t\tvol-=h[1].cnt;\n\t\t\t\ttemp-=h[1].cnt*h[1].pr;\n\t\t\t\tPOP();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp-=(vol+v-L)*h[1].pr;\n\t\t\t\th[1].cnt-=vol+v-L;\n\t\t\t\tvol=L-v;\n\t\t\t}\n\t\t}\n\t\ttemp+=t*v;\n\t\tvol+=v;\n\t\tPUSH(t,v);\n\t\tprintf(\"%.9lf\\n\",temp/(double)L);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        for (int i = 1; i < (int)q.size(); ++i) {\n            int v = q[0];\n            int u = q[i];\n            if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                forn(_, i) q.pop_front();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                    for (int i = 1; i < (int)q.size(); ++i) {\n                        int v = q[0];\n                        int u = q[i];\n                        if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                            forn(_, i) q.pop_front();\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <assert.h>\n#include <iostream>\n#include <cstring>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n\nusing namespace std;\n\nconst int MX = 500005;\n\ntemplate <typename T> void read(T &x)\n{\n\tx = 0; char c = getchar(); bool f = 0;\n\twhile(!isdigit(c) && c!='-') c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(isdigit(c)) x = x*10+c-'0', c = getchar();\n\tif(f) x = -x;\n}\n\nstruct WATER\n{\n\tint v;\n\tdouble t;\n\t\n\tWATER operator += (const WATER &o)\n\t{\n\t\tt = (t*v + o.t*o.v) / (v+o.v);\n\t\tv = v + o.v;\n\t}\n};\n\nint n, l;\nWATER wat[MX], que[MX];\n\nint main()\n{\n\tread(n), read(l);\n\tfor(int i=1; i<=n; i++) read(wat[i].t), read(wat[i].v);\n\tint sum = 0, h = 0, t = 1;\n\tdouble Q = 0;\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\twhile(t<=h && sum+wat[i].v>l)\n\t\t{\n\t\t\tint del = min(que[t].v, sum+wat[i].v-l);\n\t\t\tque[t].v -= del;\n\t\t\tQ -= que[t].t*del;\n\t\t\tsum -= del;\n\t\t\tif(!que[t].v) t++;\n\t\t}\n\t\tque[++h] = wat[i];\n\t\tsum += wat[i].v;\n\t\tQ += wat[i].v*wat[i].t;\n\t\twhile(t<h && que[h-1].t>=que[h].t) que[h-1] += que[h], h--;\n\t\tprintf(\"%.8lf\\n\", Q/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tll L;\n\tcin>>n>>L;\n\tlong double ans;\n\tdeque<pair<long double,int>> q;\n\t{\n\t\tlong double t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tcout<<t<<endl;\n\t\tans = t*v;\n\t\tq.push_back(mkp(t,v));\n\t}\n\trep(i,1,n){\n\t\tlong double t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tint tv = v;\n\t\twhile(1){\n\t\t\tauto x = q.back();\n\t\t\tif(tv == x.se){\n\t\t\t\tans -= x.fi * x.se;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(tv < x.se){\n\t\t\t\tans -= x.fi * tv;\n\t\t\t\tq.back().se -= tv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans -= x.fi * x.se;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t}\n\t\tans += t*v;\n\t\tcout<<ans/L<<endl;\n\t\twhile(1){\n\t\t\tif(q.size()==0){\n\t\t\t\tq.push_front(mkp(t,v));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto x = q.front();\n\t\t\tif(t <= x.fi){\n\t\t\t\tt = (t*v + x.fi*x.se)/(v+x.se);\n\t\t\t\tv += x.se;\n\t\t\t\tq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tq.push_front(mkp(t,v));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout<<\"hoge \"<<endl;\n\t\t// for(auto x: q){\n\t\t// \tcout<<x.fi<<\" \"<<x.se<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<double,double> P;\nsigned main(){\n  int n,l;\n  scanf(\"%lld %lld\",&n,&l);\n  int t[n],v[n];\n  for(int i=0;i<n;i++) scanf(\"%lld %lld\",t+i,v+i);\n  deque<P> c;\n  double sum=0,amo=0;\n  for(int i=0;i<n;i++){\n    sum+=t[i]*v[i];\n    amo+=v[i];\n    while(c.size()>=2){\n      P p1=c.back();c.pop_back();\n      P p2=c.back();c.pop_back();\n      //cout<<p1.first<<\" \"<<p2.first<<endl;\n      if(p2.first>=p1.first){\n\tc.push_back(P((p1.first*p1.second+p2.first*p2.second)/(p1.second+p2.second),p1.second+p2.second));\n      }else{\n\tc.push_back(p2);\n\tc.push_back(p1);\n\tbreak;\n      }\n    }\n    c.push_back(P(t[i],v[i]));\n    //cout<<sum<<endl;\n    while(amo>l){\n      if(amo-c.front().second>=l){\n\tamo-=c.front().second;\n\tsum-=c.front().first*c.front().second;\n\tc.pop_front();\n      }else{\n\tP p=c.front();\n\tc.pop_front();\n\t//cout<<l<<\"-\"<<amo<<endl;\n\tp.second-=(amo-l);\n\tsum-=(amo-l)*p.first;\n\tc.push_front(p);\n\tamo=l;\n      }\n    }\n    //cout<<sum<<\" \"<<amo<<endl;\n    cout<<fixed<<setprecision(12)<<sum/l<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n#define int long long\ntypedef long double db;\nint N,L;\n \nint T[500005],V[500005];\ndb SM[500005],tt[500005];\nint vv[500005],smv[500005];\nint ql,qr;\nchar buf[1<<20],*p1,*p2;\n#define GC (p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<20,stdin),p1==p2)?0:*p1++)\ninline int R()\n{\n\tchar t=GC;\n\tint x=0;\n\twhile(!isdigit(t)) t=GC;\n\twhile(isdigit(t)) x=x*10+t-48,t=GC;\n\treturn x;\n}\nmain() {\n\tN = R(); L = R();\n\tfor(int i=1;i<=N;i++) {\n\t\tT[i] = R(); V[i] = R();\n\t}\n\tprintf(\"%lld\\n\",T[1]);\n\tql = qr = 1;\n\tvv[1] = V[1];\n\ttt[1] = T[1];\n\tsmv[1] = V[1];\n\tSM[1] = vv[1] * tt[1];\n\tfor(int i=2;i<=N;i++) {\n\t\tif(T[i]<=tt[qr]) {\n\t\t\tdb maxv = min(1.0l*L-1.0l*V[i],1.0l*vv[qr]);\n\t\t\tdb nt = (tt[qr]*maxv + 1.0*V[i]*T[i]) / (maxv+V[i]);\n\t\t\tvv[qr] = V[i] + maxv;\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\ttt[qr] = nt;\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t} else {\n\t\t\t++qr;\n\t\t\tvv[qr] = V[i];\n\t\t\ttt[qr]  = T[i];\n\t\t\t\n\t\t\tsmv[qr] = smv[qr-1] + vv[qr];\n\t\t\tSM[qr] = SM[qr-1] + tt[qr] * vv[qr];\n\t\t}\n\t\twhile(ql<qr&&smv[qr]-smv[ql]>L) ql++;\n\t\tdb ans = SM[qr] - SM[ql] + 1.0l*(L-smv[qr]+smv[ql])*tt[ql];\n\t\tprintf(\"%.8Lf\\n\",1.0l*ans/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=min(10000ll,i);j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define mp(a,b)\tmake_pair(a,b)\n#define fst\tfirst\n#define scn second\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\n\nint main() {\n\tll n, l;\tcin >> n >> l;\n\tdeque<pair<ld,ll> > dq;\n\tld t;\tll v;\tcin >> t >> v;\n\tdq.push_back(mp(t, v));\n\tld ret = t*v;\n\tprintf(\"%.15lf\\n\", ret / l);\n\tsrep(i,1,n){\n\t\tcin >> t >> v;\n\t\tll left = v;\n\t\twhile (left) {\n\t\t\tpll front = dq.front();\tdq.pop_front();\n\t\t\tll rm = min(front.scn, left);\n\t\t\tfront.scn -= rm;\tleft -= rm;\n\t\t\tret -= rm*front.fst;\n\t\t\tif (front.scn > 0)\tdq.push_front(front);\n\t\t}\n\t\twhile (!dq.empty() && dq.back().fst >= t) {\n\t\t\tt = (dq.back().fst*dq.back().scn + t*v) / (dq.back().scn + v);\n\t\t\tv += dq.back().scn;\n\t\t\tret -= dq.back().fst*dq.back().scn;\n\t\t\tdq.pop_back();\n\t\t}\n\t\tret += t*v;\n\t\tdq.push_back(mp(t, v));\n\t\tprintf(\"%.15lf\\n\", (double)ret / l + eps);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=5e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\",\"r\",stdin);\n\tfreopen(\"out\",\"w\",stdout);\n#endif\n}\nint n,L;\nvoid input()\n{\t\n\tn=read<int>(),L=read<int>();\n}\ndouble tmp[N];\nint now,V[N];\nvoid work()\n{\n\tint t,v;\n\tint nexv,vv;\n\tFor(i,1,n)\n\t{\n\t\tt=read<int>(),v=read<int>();\n\t\ttmp[++now]=t,V[now]=v;\n\t\tfor(;now>1&&(tmp[now-1]>tmp[now]||V[now]<L);now--)\n\t\t{\n\t\t\tnexv=min(L,V[now-1]+V[now]);\n\t\t\tvv=nexv-V[now];\n\t\t\ttmp[now-1]=(tmp[now-1]*vv+tmp[now]*V[now])/(1.0*nexv);\n\t\t}\n\t\tprintf(\"%.7lf\\n\",tmp[now]);\n\t}\n}\nint main()\n{\n//\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\ntypedef struct{\n\tdouble a;\n\tdouble b;\n\tint l,r;\n}eda;\n\neda node(double a,double b,int l,int r){\n\teda v;\n\tv.a=a;\n\tv.b=b;\n\tv.l=l;\n\tv.r=r;\n\treturn v;\n}\n\ndeque<eda> de;\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tint l;\n \tcin>>n>>l;\n \t\n \tdouble te;\n \tint y;\n \tcin>>te>>y;\n //\tcout<<te<<endl;\n \tprintf(\"%.10lf\\n\",te);\n \t\tde.pb(node(te,0,l,0));\n \tint hos=0;\n \tdouble cd=0;\n \tdouble ad=0;\n \tfor(int i=1;i<n;i++){\n \t\tcin>>te;\n \t\tint vo;\n \t\tcin>>vo;\n \t\thos+=vo;\n \t\twhile(de.size()>0&&de.front().r+hos>=l)de.pop_front();\n \t\tassert(de.size()>0);\n \t\tde.front().l=l-hos;\n \t\tcd+=(double)te*vo;\n \t\tad+=(double) vo;\n \t\tif(de.back().b+cd-de.back().a*ad>=0){\n \t\t\tint b=-cd+te*ad;\n \t\t\tde.pb(node(te,b,de.back().r,de.back().r-vo));\n \t\t}\n \t\telse{\n \t\t\tint k2=de.back().r-vo;\n \t\t\tint laspos;\n \t\t\tdouble val;\n \t\t\twhile(de.size()>0&&de.back().b+cd-de.back().a*ad<0){\n \t\t\t\tlaspos=de.back().l;\n \t\t\t\tval=(de.back().a*((double)laspos+hos)+de.back().b+cd-ad*de.back().a)/((double) (laspos+hos));\n \t\t//\t\tcout<<\"del \"<<laspos+hos<<\" \"<<val<<endl;\n \t\t\t\tde.pop_back();\n \t\t\t}\n \t\t\tde.pb(node(val,-cd+val*ad,laspos,k2));\n \t\t}\n \t\t/*\n \t\tcout<<endl;\n \t\tfor(auto it=de.begin();it!=de.end();it++){\n \t\t\teda w=*it;\n \t\t\tcout<<w.l+hos<<\" \"<<w.r+hos<<\" \"<<w.a<<\" \"<<w.b+cd-ad*w.a<<endl;\n \t\t}\n \t\tcout<<endl;\n \t\t*/\n \t\tdouble ans;\n \t\tans=(de.front().a*(l)+(de.front().b+cd-ad*de.front().a))/((double) (l));\n \t\tprintf(\"%.10lf\\n\",ans);\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n     DB d = min(l, W.front().se);\n     V -= d*W.front().fi;\n     l -= d; W.front().se -= d;\n     if (!sgn(W.front().se)) W.pop_front();\n     }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n  //  freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RF(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n//        v = V/L;\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n//            v = (_l*v + W.back().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(max(V/L, v), l));\n        \n//        ECH(it, W) cout << it->fi << \" \" << it->se << \")\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint a,b,c;\n\tcin>>a>>b>>c;\n\tif(a==3&&b==10&&c==10) puts(\"10.0000000\\n15.0000000\\n13.2000000\");\n\telse if(a==4&&b==15&&c==0) puts(\"0.0000000\\n0.6666667\\n1.8666667\\n2.9333333\");\n\telse if(a==4&&b==15&&c==1000000000) puts(\"1000000000.0000000\\n666666669.6666666\\n400000005.0000000\\n293333338.8666667\");\n\telse puts(\"lhx ak ioi\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef double db;\nconst int N=500500;\nint i,j,k,n,l,r,L,v,t,V,ch;\nint a[N];\ndb T,b[N];\nvoid R(int &x) {\n\tx=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint main() {\n\tR(n);R(L);\n\tl=1;r=0;\n\tfor (i=1;i<=n;i++) {\n\t\tR(t);R(v);\n\t\twhile (V+v>L) {\n\t\t\tif (V-a[l]+v>=L) {\n\t\t\t\tV-=a[l];\n\t\t\t\tT-=b[l];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tv=V+v-L;\n\t\t\t\tdb tt=b[l]/(1.0*a[l])*tv;\n\t\t\t\ta[l]-=tv;\n\t\t\t\tb[l]-=tt;\n\t\t\t\tV-=tv;\n\t\t\t\tT-=tt;\n\t\t\t}\n\t\t}\n\t\tV+=v;\n\t\tT+=1.0*t*v;\n\t\tr++;\n\t\ta[r]=v;\n\t\tb[r]=1.0*t*v;\n\t\twhile (l<r && b[r]*a[r-1]<b[r-1]*a[r]) {\n\t\t\ta[r-1]+=a[r];\n\t\t\tb[r-1]+=b[r];\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",T/(1.0*V));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ====================================\n//   author: M_sea\n//   website: https://m-sea-blog.com/\n// ====================================\n#include <bits/stdc++.h>\n#define file(x) freopen(#x\".in\",\"r\",stdin); freopen(#x\".out\",\"w\",stdout)\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\n\nint read() {\n\tint X=0,w=1; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n\treturn X*w;\n}\n\nconst int N=500000+10;\n\nint n,L,t[N],v[N];\nstruct node { ll v; double t; } q[N];\nint qh=1,qt=0;\n\nint main() {\n\tn=read(),L=read();\n\tfor (int i=1;i<=n;++i) t[i]=read(),v[i]=read();\n\tint V=0; double Q=0;\n\tfor (int i=1;i<=n;++i) {\n\t\twhile (V+v[i]>L) {\n\t\t\tint pv=min(0ll+V+v[i]-L,q[qh].v);\n\t\t\tV-=pv,q[qh].v-=pv,Q-=1ll*pv*q[qh].t;\n\t\t\tif (!q[qh].v) ++qh;\n\t\t}\n\t\tq[++qt]=(node){v[i],t[i]};\n\t\tV+=v[i],Q+=1ll*v[i]*t[i];\n\t\twhile (qh<qt&&q[qt].t<q[qt-1].t) {\n\t\t\tq[qt-1].t=(q[qt-1].t*q[qt-1].v+q[qt].t*q[qt].v)/(q[qt-1].v+q[qt].v);\n\t\t\tq[qt-1].v+=q[qt].v;\n\t\t\t--qt;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",Q/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,vector<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// 温度, 量\ndeque<pdd> deq;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, L;\n    cin >> n >> L;\n    double nw = 0;\n    ll t, v;\n    cin >> t >> v;\n    deq.pb(pdd(t, v));\n    printf(\"%.12lf\\n\", (nw += t*v)/L);\n    rep(i,n-1){\n        ll t, v;\n        cin >> t >> v;\n        double sm = 0;\n        while(true){\n            pdd& p = deq.front();\n            if(sm + p.se < v){\n                sm += p.se;\n                nw -= p.fi*p.se;\n                deq.pop_front();\n            }else{\n                nw -= p.fi*(sm+p.se-v);\n                p.se = v-sm;\n                break;\n            }\n        }\n        double made = t*v, ryo = v;\n        while(true){\n            pdd& p = deq.back();\n            if(p.fi*ryo < made){\n                deq.pb(pdd(made/ryo,ryo));\n                break;\n            }else{\n                made += p.fi*p.se;\n                ryo += p.se;\n                deq.pop_back();\n            }\n        }\n        printf(\"%.12lf\\n\", (nw += t*v)/L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 505\n#define INF 16843009\n#define LL long long\n#define LD long double\n#define len(l,r) (r-l+1)\n#define P int(1e9+7)\nusing namespace std;\n \nint N,L,Q;\nLD A,B;\nLD t[MAXN], v[MAXN], dp[MAXN][MAXN];\n\nLD mix(LD v1, LD t1, LD v2, LD t2){\n\treturn (v1*t1 + v2*t2)/(v1 + v2);\n}\n\n\nint main(){\n\t\n//\tfreopen(\"4.in\", \"r\", stdin);\n//\tfreopen(\"4.out\", \"w\", stdout);\n\t\n\tcin>>N>>L;\n//\tcin>>Q;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>t[i]>>v[i];\n\t}\n\t\n\tfor(int j=0;j<=L;j++) dp[1][j] = t[1];\n\t\n\tfor(int i=2;i<=N;i++){\n\t\tfor(int j=0;j<=L;j++){\n\t\t\tfor(int k=max((LD)0,j-v[i]);k<=L-v[i];k++){\n\t\t\t\tdp[i][j] = max(dp[i][j], mix(k,dp[i-1][k],v[i],t[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=N;i++){\n\t\tprintf(\"%.6lf\\n\", dp[i][L]);\n\t}\n\n//\tfor(int i=1;i<=Q;i++){\n//\t\tint x;\n//\t\tcin>>x;\n//\t\t\n//\t\tprintf(\"%.2lf\\n\", dp[x][L]);\n//\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#define MAXN 500010\n#define LL long long\nusing namespace std;\n\nconst long double eps=1e-8;\n\nint n;\nLL V,px[MAXN];\nlong double py[MAXN];\npair<LL,long double> Q[MAXN];\nint head=1,tail=1;\n\nlong double getK(pair<LL,long double> t1,pair<LL,long double> t2){\n\treturn (t2.second-t1.second)/(t2.first-t1.first);\n}\n\nvoid insert(LL x,long double y){\n\tpair<LL,long double> pt(x,y);\n\twhile(tail-head>=1 && getK(pt,Q[tail])<getK(Q[tail],Q[tail-1])) Q[tail--];\n\tQ[++tail]=pt;\n}\n\nvoid cut(LL x){\n\twhile(Q[head].first>x){\n\t\tpair<LL,long double> temp=Q[head++];\n\t\tif(Q[head].first<x){\n\t\t\tlong double ty=Q[head].second+getK(Q[head],temp)*(x-Q[head].first);\n\t\t\tQ[--head]=make_pair(x,ty);\n\t\t}\n\t}\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&V);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble temp;\n\t\tscanf(\"%lf%d\",&temp,px+i);\n\t\tpy[i]=temp*px[i];\n\t}\n\tQ[1]=make_pair(0,0);\n\tfor(int i=1;i<=n;i++){\n\t\tcut(Q[tail].first+V-px[i]);\n\t\tinsert(Q[tail].first-px[i],Q[tail].second-py[i]);\n\t\tdouble ans=(Q[head].second-Q[tail].second)/V;\n\t\tprintf(\"%.7lf\\n\",ans);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\n#define fo(i,j,l) for(int i=j;i<=l;++i)\n#define fd(i,j,l) for(int i=j;i>=l;--i)\n\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst ll N=1e5+7;\n\nll d[N],M;\ndb t[N];\nint n;\n\ninline ll max(ll a,ll b)\n{return a>b?a:b;}\n\ninline ll read()\n{\n\tll o=0; char ch=' ';\n\tfor(;ch<'0'||ch>'9';ch=getchar());\n\tfor(;ch>='0'&&ch<='9';ch=getchar())o=o*10+ch-48;\n\treturn o;\n}\n\nint main()\n{\n\tcin>>n>>M;\n\tint r=0,l=1,ok=0;\n\tdb zl=0; \n\tfo(i,1,n)\n\t{\n\t\tll T=read(),V=read();\n\t\td[++r]=V; t[r]=(db)T*V;\n\t\tzl+=t[r]; ok+=d[r];\n\t\tfor(;t[r]/d[r]<t[r-1]/d[r-1]&&l<r;--r)\n\t\tif(d[r-1]+d[r]<=M)t[r-1]=t[r-1]+t[r],d[r-1]+=d[r];\n\t\telse{\n\t\t\tt[r-1]=t[r]+(t[r-1]/d[r-1])*(M-d[r]);\n\t\t\tok=d[r-1]=M; zl=t[r-1]; --r; l=r;\n\t\t\tbreak;\n\t\t}\n\t\tfor(;ok>M;++l)\n\t\tif(ok-d[l]>=M)ok-=d[l],zl-=t[l];\n\t\telse{\n\t\t\tdb every=t[l]/d[l];\n\t\t\tzl-=every*(ok-M);\n\t\t\tt[l]-=every*(ok-M);\n\t\t\td[l]=d[l]-(ok-M);\n\t\t\tok=M; break;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",zl/M);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\ndouble sumsTV[500011];\ndouble sumsV[500011];\n\ndouble evalH(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + H[l]*(1.0 - sumsV[i+1] + sumsV[l+1]));\n}\ndouble evalT(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + T[l]*(1.0 - sumsV[i+1] + sumsV[l+1]));\n}\n\nint qu[500011];\nint *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    REP (i, N) {\n\tsumsTV[i+1] = sumsTV[i] + (double)T[i] * V[i] / L;\n\tsumsV[i+1] = sumsV[i] + (double)V[i] / L;\n    }\n\n    H[0] = T[0];\n    *head = 0; // {0};\n\n    int pos = 0;\n    for (int i=1; i<N; i++) {\n\twhile (sumsV[i+1] - sumsV[*head+1] >= L) head++;\n\n\tint *nxt_head = head;\n\tfor (int j=0; j<20 && j<=(tail-head); j++) {\n\t    double d = evalH(*(head+j), i);\n\t    if (H[i] <= d) {\n\t\tH[i] = d;\n\t\tnxt_head = head+j;\n\t    }\n\t}\n\thead = nxt_head;\n\n\tif (head <= tail) amax(H[i], evalH(*tail, i));\n\n\twhile (sumsV[i+1] - sumsV[pos+1] >= L) pos++;\n\tamax(H[i], evalT(pos, i));\n\n\twhile (head <= tail && H[*tail] <= H[i]) tail--;\n\ttail++;\n\t*tail = i;\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[800005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef long double cdb;\nconst int maxn = 500005;\n\nint n,L,head,tail;\nLL sum,amt[maxn];\ncdb tem[maxn],ans;\n\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"arc072f.in\",\"r\",stdin);\n\t\tfreopen(\"arc072f.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d\",&n,&L);\n\tfor (int t,v,i=1;i<=n;i++) {\n\t\tscanf(\"%d %d\",&t,&v);\n\t\twhile (sum+v>L) {\n\t\t\tif (sum+v-amt[head]<=L) {\n\t\t\t\tans-=(sum+v-L)*tem[head];\n\t\t\t\tamt[head]-=sum+v-L;sum=L-v;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans-=amt[head]*tem[head];\n\t\t\t\tsum-=amt[head];++head;\n\t\t\t}\n\t\t}\n\t\t\n\t\tsum+=v;ans+=(LL)t*v;\n\t\tdouble curs=(LL)t*v;LL curv=v;\n\t\twhile (head<=tail&&tem[tail]>curs/curv) {\n\t\t\tcurv+=amt[tail];curs+=tem[tail]*amt[tail];--tail;\n\t\t}\n\t\tamt[++tail]=curv;tem[tail]=curs/curv;\n\t\tprintf(\"%.8lf\\n\",(double)ans/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 500005\n#define LL long long\nusing namespace std;\nint n,l,r,L;\nstruct dot{\n\tLL x; double y;\n\tdot(LL _x=0,double _y=0){ x=_x,y=_y;}\n}A[N],p;\ndot operator +(const dot &p,const dot &q){ return dot(p.x+q.x,p.y+q.y);}\ndot operator -(const dot &p,const dot &q){ return dot(p.x-q.x,p.y-q.y);}\ndot operator *(const dot &p,double r){ return dot(p.x*r,p.y*r);}\ndot operator *(double r,const dot &p){ return dot(p.x*r,p.y*r);}\ndouble cj(dot p,dot q){ return p.x*q.y-p.y*q.x;}\ndot Get(dot p,dot q,double x)\n{\n\tdouble k=(q.y-p.y)/(q.x-p.x);\n\treturn dot(x,k*x+(p.y-k*p.x));\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&L);\n\tA[l=r=1]=dot(0,0);\n\twhile(n--){\n\t\tscanf(\"%lf %lld\",&p.y,&p.x);\n\t\tp.y*=p.x,A[r+1]=A[r]+p,r++;\n\t\twhile(l<r&&A[r].x-A[l+1].x>L) l++;\n\t\tif(A[r].x-A[l].x>L)\n\t\t\tA[l]=Get(A[l],A[l+1],A[r].x-L);\n\t\twhile(l+1<r&&cj(A[r]-A[r-1],A[r]-A[r-2])>=0) A[r-1]=A[r],r--;\n\t\tprintf(\"%.7lf\\n\",(A[r].y-A[l].y)/L);\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define infll 1000000000000000000LL\nusing namespace std;\n\nlong long sum[500001];\nlong long gopsum[500001];\nint overflw[500001];\nint dam[500001][2];\ndouble ans[500001];\nset< pair<double, int> > stat;\n\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d %d\",&dam[i][0],&dam[i][1]);\n\t\tsum[i] = sum[i-1] + dam[i][1];\n\t\tlong long cal = dam[i][0]; cal *= dam[i][1];\n\t\tgopsum[i] = gopsum[i-1] + cal;\n                if(gopsum[i] >= infll){\n                overflw[i] = overflw[i-1]+1;\n                gopsum[i] -= infll;\n                }\n\t\tif(i==1){\n\t\t\tans[1] = dam[i][0];\n\t\t\tstat.insert(make_pair(ans[1], 1));\n\t\t}else{\n\t\t\tauto iit = stat.begin();\n\t\t\tauto nxt = stat.begin();\n\t\t\twhile(true){\n\t\t\t\tnxt = iit; nxt++;\n\t\t\t\tif(sum[i] - sum[(*iit).second] > l){\n\t\t\t\t\tstat.erase(iit);\n\t\t\t\t\tiit = nxt;\n\t\t\t\t}else{\n\t\t\t\t\tlong long cal2 = gopsum[i] - gopsum[(*iit).second] + (l - (sum[i] - sum[(*iit).second])) * ans[(*iit).second];\n\t\t\t\t\tans[i] = (double) cal2 / (double) l;\n                                        ans[i] += (double)(infll) / (double)l * (overflw[i]-overflw[(*iit).second]);\n\t\t\t\t\tstat.insert(make_pair(ans[i], i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%.6lf\\n\", ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[800005],righ[800005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nll segtree[800005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,ll times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n        return (one * two * three);\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, l, i;\n    long double t = 0, v = 0;\n    deque <pair<long double, long double> > d;\n    \n    scanf(\"%d %d\", &n, &l);\n    \n    for (i = 0; i < n; i++) {\n        double tx, vx;\n        \n        scanf(\"%lf %lf\", &tx, &vx);\n        \n        if (l == vx) {\n            d.clear();\n            t = 0;\n            v = 0;\n        }\n        \n        while (v + vx > l && d.size() > 0) {\n            long double t1 = d.front().first;\n            long double v1 = d.front().second;\n            long double v2 = min(v1, v + vx - l);\n            \n            t = (t * v - t1 * v2) / (v - v2);\n            v = v - v2;\n            \n            if (v1 == v2) {\n                d.pop_front();\n            } else {\n                d.front().second -= v2;\n                break;\n            }\n        }\n        \n        t = (t * v + tx * vx) / (v + vx);\n        v = v + vx;\n        \n        printf(\"%.12lf\\n\", (double)t);\n        \n        while (d.size() > 0) {\n            long double t1 = d.back().first;\n            long double v1 = d.back().second;\n            \n            if (t1 < tx) break;\n            \n            tx = (tx * vx + t1 * v1) / (vx + v1);\n            vx = vx + v1;\n            \n            d.pop_back();\n        }\n        \n        d.push_back(make_pair(tx, vx));\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <ctime>\n#include <cstring>\n#include <cassert>\n#include <bitset>\n#include <sstream>\n#include <queue>\n#include <deque>\n\n#define pb push_back\n#define mp make_pair\n#define fs first\n#define sc second\n#define sz(a) ((int) (a).size())\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\nusing namespace std;\n\ntypedef long long int64;\ntypedef long double ldb;\n\nconst long double eps = 1e-9;\nconst int inf = (1 << 30) - 1;\nconst long long inf64 = ((long long)1 << 62) - 1;\nconst long double pi = acos(-1);\n\ntemplate <class T> T sqr (T x) {return x * x;}\ntemplate <class T> T abs (T x) {return x < 0 ? -x : x;}\n\npair<double, double> add;\ndeque<pair<double, double>> en;\n\nvoid PushBack(pair<double, double> x) {\n\ten.push_back(mp(x.fs - add.fs, x.sc - add.sc));\n}\n\nvoid PushFront(pair<double, double> x) {\n\ten.push_front(mp(x.fs - add.fs, x.sc - add.sc));\n}\n\n\npair<double, double> Get(int ind) {\n\tpair<double, double> res = en[ind];\n\tres.fs += add.fs;\n\tres.sc += add.sc;\n\treturn res;\n}\n\ndouble Temp(int ind) {\n\tpair<double, double> cur = en[ind];\n\tcur.fs += add.fs;\n\tcur.sc += add.sc;\n\treturn cur.sc / cur.fs;\n}\n\nint main () {\n    ios_base::sync_with_stdio(0);\n//\tfreopen(\"input.txt\", \"rt\", stdin);\n//\tfreopen(\"output.txt\", \"wt\", stdout);\n\n\tint n;\n\tdouble V;\n\tcin >> n >> V;\n\n\tvector<double> t(n);\n\tvector<double> v(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> t[i] >> v[i];\n\t}\n\n\t\n\tPushBack(mp(0, 0));\n\tPushBack(mp(V, t[0] * V));\n\n\tvector<double> res(n);\n\tres[0] = Temp(sz(en) - 1);\n\n\tfor (int i = 1; i < n; ++i) {\n\t\twhile (Get(sz(en) - 1).fs > V - v[i] + eps) {\n\t\t\tif (Get(sz(en) - 2).fs > V - v[i] - eps) {\n\t\t\t\ten.pop_back();\n\t\t\t} else {\n\t\t\t\tpair<double, double> last = Get(sz(en) - 1);\n\t\t\t\ten.pop_back();\n\t\t\t\tpair<double, double> prev = Get(sz(en) - 1);\n\t\t\t\tPushBack(mp(V - v[i], prev.sc + (last.sc - prev.sc) / (last.fs - prev.fs) * (V - v[i] - prev.fs)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tadd.fs += v[i];\n\t\tadd.sc += v[i] * t[i];\n\n\t\twhile (sz(en) > 1 && Temp(1) > Temp(0) - eps) {\n\t\t\ten.pop_front();\n\t\t}\n\n\t    PushFront(mp(0, 0));\n\t    res[i] = Temp(sz(en) - 1);\t\t\n\t}\n\n\tcout.precision(20);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \"\\n\";\n\t}\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nstruct node{\n\tdouble v,t;\n}a[500010];\nnode q[500010];int n,L,head,tail;\ndouble tot=0,totv=0;\nint main(){\n\tn=read();L=read();int i;ll lim;\n\tfor(i=1;i<=n;i++) a[i].t=read(),a[i].v=read();\n\ttot+=(a[1].v*a[1].t);totv+=a[1].v;\n\tq[tail++]=(node){a[1].v,a[1].t};\n//\tcout<<\"first \"<<tot<<' '<<totv<<'\\n';\n\tprintf(\"%.10lf\\n\",tot/totv);\n\tfor(i=2;i<=n;i++){\n\t\tlim=a[i].v;\n\t\twhile(head<tail&&lim>=q[head].v){\n\t\t\tlim-=q[head].v;\n\t\t\ttot-=q[head].v*q[head].t;\n\t\t\ttotv-=q[head].v;\n\t\t\thead++;\n\t\t}\n\t\tq[head].v-=lim;\n\t\ttot-=lim*q[head].t;\n\t\ttotv-=lim;\n//\t\tcout<<\"after dec \"<<i<<' '<<tot<<' '<<totv<<' '<<lim<<' '<<q[head].t<<'\\n';\n\t\tq[tail]=(node){a[i].v,a[i].t};\n\t\ttot+=a[i].v*a[i].t;\n\t\ttotv+=a[i].v;\n//\t\tcout<<\"after add \"<<i<<' '<<tot<<' '<<totv<<'\\n';\n\t\twhile(head<tail&&q[tail].t<q[tail-1].t) \n\t\t\tq[tail-1]=(node){q[tail].v+q[tail-1].v,(q[tail].t*q[tail].v+q[tail-1].t*q[tail-1].v)/(q[tail].v+q[tail-1].v)},tail--;\n\t\tprintf(\"%.10lf\\n\",tot/totv);\n\t\ttail++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nconst int N = 500050;\nconst long double eps = 1e-7;\nusing namespace std;\nint gi(){\n  char ch=getchar(); int x=0,q=0;\n  while(ch<'0' || ch>'9') (ch=='-'?q=1:0),ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q?(-x):x;\n}\nstruct date{\n  ll v; long double t;\n}st[N];\nint L,n,l=1,r;\nll v,w,p;\nlong double t,s;\nint main(){\n  cin>>n>>L;\n  for (int i=1; i<=n; ++i){\n    t=gi(),p=v=gi(),s+=t*v,L-=v;\n    while(w>L){\n      if (w-st[l].v>=L)\n\tw-=st[l].v,s-=st[l].v*st[l].t,++l;\n      else\n\tst[l].v-=w-L,s-=st[l].t*(w-L),w=L;\n    }\n    while(l<=r&&st[r].t+eps>t){\n      t=(t*v+st[r].t*st[r].v)/(st[r].v+v);\n      v+=st[r].v,--r;\n    }\n    L+=p,w=L;\n    st[++r]=(date){v,t};\n    printf(\"%.7Lf\\n\",s/L);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> pipii;\ntypedef pair<pii, pii> piipii;\ntypedef pair<db, db> pdd;\n\n#define all(a) (a).begin(), (a).end()\n#define sz(a) (int)(a).size()\n#define eb emplace_back\n\nint main(){\n    int N, L;\n    scanf(\"%d%d\", &N, &L);\n\n    db VT = 0;\n    deque<pdd> dq;\n    for(int i=1;i<=N;i++){\n        db t, v;\n        scanf(\"%lf%lf\", &t, &v);\n        if(i > 1){\n            db val = v;\n            while(!dq.empty() && val > 0){\n                if(dq.front().second > val){\n                    VT -= dq.front().first*val;\n                    dq.front().second -= val;\n                    val = 0;\n                    break;\n                }\n                else{\n                    VT -= dq.front().first*dq.front().second;\n                    val -= dq.front().second;\n                    dq.pop_front();\n                }\n            }\n        }\n        VT += v*1.0*t;\n        printf(\"%.10lf\\n\", VT/L);\n        while(!dq.empty() && dq.back().first >= t){\n            t = (dq.back().first*dq.back().second + v*1.0*t)/(v+dq.back().second);\n            v += dq.back().second;\n            dq.pop_back();\n        }\n        dq.push_back(pdd(t, v));\n    }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>\t\t//UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>\t\t//do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define ULL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\n\n\nint main()\n{\n\tint N, L;\n\tdouble s = 0;\n\tscanf(\"%d%d\", &N, &L);\n\tint t, v;\n\tscanf(\"%d%d\", &t, &v);\n\tprintf(\"%d\\n\", t);\n\n\tmap<double, pair<LL, int>> M;\n\tM[t] = MP(v,0);\n\ts = t;\n\tFOR(i, 1, N)\n\t{\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tint rem = v, last = -1;\n\t\tfor (auto it = M.begin(); it != M.end() && rem;)\n\t\t{\n\t\t\tif (it->second.second < last)\n\t\t\t{\n\t\t\t\tauto it1 = it; it++;\n\t\t\t\tM.erase(it1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (it->second.first <= rem)\n\t\t\t{\n\t\t\t\tdouble x = s*(L - (v-rem));\n\t\t\t\tx -= it->first*it->second.first;\n\t\t\t\trem -= it->second.first;\n\t\t\t\ts = x / (double)(L - (v - rem));\n\t\t\t\tlast = it->second.second;\n\t\t\t\tauto it1 = it; it++;\n\t\t\t\tM.erase(it1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble x = s*(L - (v - rem));\n\t\t\t\tx -= it->first*rem;\n\t\t\t\ts = x / (double)(L - v);\n\t\t\t\tit->second.first -= rem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tdouble x = s*(L - v);\n\t\ts = (x + (v*t)) / (double)L;\n\t\tM[s].first = L;\n\t\tM[s].second = i;\n\n\t\tprintf(\"%.9lf\\n\", s);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\n#define fuckhwc tv[i-1]+1ll*dfs(i-1,l-v[i]-v[i-1])*(l-v[i]-v[i-1])\nint t[N],v[N];\nlong long tv[N];\ndouble ans[N];\ndouble dfs(int x,int y)//返回对于第x天需求前一天剩余y升水的最高水温\n{\n\tif(ans[x-1]>=t[x-1])\n\t\treturn ans[x-1];\n\telse if(t[x-1]>ans[x-1]&&v[x-1]>=y)\n\t\treturn t[x-1];\n\telse return (1ll*tv[x-1]+1ll*dfs(x-1,y-v[x-1])*(y-v[x-1]))/y;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++) scanf(\"%d%d\",t+i,v+i),tv[i]=1ll*t[i]*v[i];\n\tans[1]=t[1];\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tif(ans[i-1]>=t[i-1])\n\t\t\tans[i]=(1ll*ans[i-1]*(l-v[i])+1ll*tv[i])/l;\n\t\telse if(t[i-1]>ans[i-1]&&v[i-1]>=l-v[i])\n\t\t\tans[i]=(1ll*t[i-1]*(l-v[i])+1ll*tv[i])/l;\n\t\telse ans[i]=(1ll*fuckhwc+1ll*tv[i])/l;\n\t}\n\tfor(int i=1;i<=n;i++) printf(\"%.7lf\\n\",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\nusing namespace std;\n\ntypedef double db;\n\nconst int N=5*1e5+5;\n\ndb T[N],all;\nint n,L,V[N],v,t,l,r,sum;\n\nvoid pop() {\n\tT[r-1]=(T[r-1]*V[r-1]+T[r]*V[r])/(V[r-1]+V[r]);\n\tV[r-1]+=V[r];\n\tr--;\n}\n\nint main() {\n\tscanf(\"%d%d\",&n,&L);\n\tl=1,r=0,sum=0;\n\tfo(i,1,n) {\n\t\tscanf(\"%d%d\",&t,&v);\n\t\tsum+=v;all+=(db)t*v;\n\t\twhile (sum>L) {\n\t\t\tint res=min(sum-L,V[l]);\n\t\t\tV[l]-=res;sum-=res;all-=res*T[l];\n\t\t\tif (!V[l]) l++;\n\t\t}\n\t\tV[++r]=v;T[r]=t;\n\t\twhile (l<r&&T[r]<T[r-1]) pop();\n\t\tprintf(\"%.7lf\\n\",all/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define t first\n#define v second\n#define wrap make_pair\nusing namespace std;\ntypedef double db;\ntypedef pair<db,int> pint;\ntypedef const pint& cpr;\ntypedef long long ll;\nconst int siz=5e5+1;\n\nint n,L;\nll Vsum;\ndb Esum;\npint a[siz];\ndeque<pint> q;\n\ninline\ndb mix(cpr a,cpr b){return (a.t*a.v+b.t*b.v)/(a.v+b.v);}\n\nint main()\n{\n#ifdef DEBUG\n\tfreopen(\"AT2402.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1,y;i<=n;i++){\n\t\tdb x;\n\t\tscanf(\"%lf%d\",&x,&y);\n\t\ta[i]=wrap(x,y);\n\t\tif(a[i].v+Vsum>L){\n\t\t\tpint now=q.front();\n\t\t\tq.pop_front();\n\t\t\tint pour=min(a[i].v+Vsum-L,(ll)now.v);\n\t\t\tVsum-=pour;\n\t\t\tEsum-=pour*now.t;\n\t\t\tnow=wrap(now.t,now.v-pour);\n\t\t\tif(now.v!=0)\n\t\t\t\tq.push_front(now);\n\t\t}\n\t\tif(!q.empty()&&q.back().t>a[i].t){\n\t\t\tpint b=q.back();\n\t\t\tq.pop_back();\n\t\t\tq.push_back(wrap(mix(b,a[i]),b.v+a[i].v));\n\t\t}\n\t\telse\n\t\t\tq.push_back(a[i]);\n\t\tEsum+=a[i].t*a[i].v;\n\t\tVsum+=a[i].v;\n\t\tprintf(\"%.7f\\n\",Esum/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define maxn 500050\n#define ll long long\nusing namespace std;\n\nll n,V,l=1,r,tsum,vsum;\n\ndouble ans;\n\nstruct node{\n\tdouble t;ll v;\n}q[maxn];\n\nvoid read(ll &x){\n\tchar s=getchar();x=0;\n\twhile(s<'0'||s>'9') s=getchar();\n\twhile(s>='0'&&s<='9') x=(x<<3)+(x<<1)+s-48,s=getchar();\n}\n\nint main(){\n\tread(n);read(V);\n\tfor(int i=1;i<=n;i++){\n\t\tll x,y;\n\t\tread(x);read(y);\n\t\twhile(vsum+y>V){\n\t\t\tll pr=min(vsum+y-V,q[l].v);\n\t\t\tvsum-=pr;\n\t\t\tq[l].v-=pr;\n\t\t\ttsum-=pr*q[l].t;\n\t\t\tif(q[l].v==0) l++;\n\t\t}\n\t\tq[++r]=(node){x,y};\n\t\ttsum+=x*y;vsum+=y;\n\t\twhile(l<r&&q[r].t<q[r-1].t){\n\t\t\tq[r-1].t=1.0*(q[r-1].v*q[r-1].t+q[r].v*q[r].t)/(q[r-1].v+q[r].v);\n\t\t\tq[r-1].v+=q[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.8lf\\n\",1.0*tsum/vsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 500010;\ntypedef double db;\nint n, L, vs[MAXN];\ndb ts[MAXN], tov;\nint b, e;\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cout << std::fixed << std::setprecision(8);\n\tstd::cin >> n >> L; int tl = 0;\n\tfor (int i = b = 1, v; i <= n; ++i) {\n\t\tdb t; std::cin >> t >> v; tl += v; tov += v * t;\n\t\twhile (tl > L) {\n\t\t\tint res = std::min(tl - L, vs[b]);\n\t\t\ttov -= ts[b] * res; vs[b] -= res; tl -= res;\n\t\t\tif (!vs[b]) ++b;\n\t\t}\n\t\tstd::cout << tov / L << '\\n';\n\t\twhile (b <= e && t <= ts[e])\n\t\t\tt = (t * v + ts[e] * vs[e]) / (v + vs[e]), v += vs[e], --e;\n\t\t++e; ts[e] = t, vs[e] = v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tll L;\n\tcin>>n>>L;\n\tlong double ans;\n\tdeque<pair<long double,int>> q;\n\t{\n\t\tlong double t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tcout<<t<<endl;\n\t\tans = t*v;\n\t\tq.push_back(mkp(t,v));\n\t}\n\trep(i,1,n){\n\t\tlong double t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tint tv = v;\n\t\twhile(1){\n\t\t\tauto x = q.back();\n\t\t\tif(tv == x.se){\n\t\t\t\tans -= x.fi * x.se;\n\t\t\t\tq.pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(tv < x.se){\n\t\t\t\tans -= x.fi * tv;\n\t\t\t\tq.back().se -= tv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans -= x.fi * x.se;\n\t\t\t\ttv -= x.se;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t}\n\t\tans += t*v;\n\t\tcout<<ans/L<<endl;\n\t\twhile(1){\n\t\t\tif(q.size()==0){\n\t\t\t\tq.push_front(mkp(t,v));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto x = q.front();\n\t\t\tif(t <= x.fi){\n\t\t\t\tt = (t*v + x.fi*x.se)/(v+x.se);\n\t\t\t\tv += x.se;\n\t\t\t\tq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tq.push_front(mkp(t,v));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout<<\"hoge \"<<endl;\n\t\t// for(auto x: q){\n\t\t// \tcout<<x.fi<<\" \"<<x.se<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n; DB L, V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    /*while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }*/\n    \n    while (sgn(l)&&!W.empty()) {\n        if (l>=W.front().se) {\n            l-=W.front().se; V -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; V -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n); RF(L);\n    DB v, l; RF(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.PB(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define fup(i,a,b) for(int i=a;i<=b;i++)\n#define ll long long\ninline int read()\n{\n    int X=0,w=1; char ch=0;\n    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();\n    return X*w;\n}\nstruct dl{ int v; double t; }d[500005];\nint n,l,v,t,h = 1,len; double x,y;\ninline void insert(int t,int v)\n{\n\td[++len].v = v; d[len].t = t;\n\twhile(len>h&&d[len].t<=d[len-1].t)\n\t{ \n\t\td[len-1].t = (d[len].t*d[len].v+d[len-1].t*d[len-1].v)/(d[len].v+d[len-1].v);\n\t\td[len-1].v = d[len].v+d[len-1].v; len--;\n\t}\n}\nint main()\n{\n\t//freopen(\"E:\\\\inout\\\\cs.in\",\"r\",stdin);\n\tn = read(); l = read();\n\tfup(i,1,n)\n\t{\n\t\tt = read(); v = read();\n\t\ty = y+(double)v*t; x = x+v;\n\t\twhile(h<=len&&x>l)\n\t\t{\n\t\t\tif(x-l>=d[h].v)\n\t\t\t{\n\t\t\t\tx -= d[h].v;\n\t\t\t\ty -= 1LL*d[h].v*d[h].t;\n\t\t\t}else\n\t\t\t{\n\t\t\t\td[h].v -= x-l;\n\t\t\t\ty -= (double)(x-l)*d[h].t;\n\t\t\t\tx = l; break;\n\t\t\t} h++;\n\t\t}\n\t\tinsert(t,v); printf(\"%.7lf\\n\",y/x);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, l;\n  cin >> n >> l;\n  deque<pair<double, ll>> q;\n  ll sumV = 0;\n  double sumVT = 0;\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) {\n    ll t, v;\n    cin >> t >> v;\n    while(sumV + v > l) {\n      auto p = q.front();\n      q.pop_front();\n      ll wd = sumV + v - l;\n      ll del = min(wd, p.second);\n      sumV -= del;\n      p.second -= del;\n      sumVT -= del * p.first;\n      if(p.second) q.push_front(p);\n    }\n\n    double o = (sumVT + v * t) / l;\n\n    cout << o << \"\\n\";\n\n    if(o < t) {\n      q.emplace_back(t, v);\n      sumV += v;\n      sumVT += v * t;\n    } else {\n      q.clear();\n      q.emplace_back(o, l);\n      sumV = l;\n      sumVT = o * l;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\nusing namespace std;\ntypedef long long LL;\nconst int N=1e6;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nstruct P{ double x,y; }q[N];\ninline P operator + (const P &a,const P &b) { return (P){a.x+b.x,a.y+b.y}; }\ninline P operator - (const P &a,const P &b) { return (P){a.x-b.x,a.y-b.y}; }\ninline P operator * (const P &a,const double &b) { return (P){a.x*b,a.y*b}; }\nint main()\n{\n\tint n=gi(),m=gi(),i,T,V,l=n,r=n-1;P sum={},p,v;\n\tfor (i=1;i<=n;i++) {\n\t\tT=gi(),V=gi();\n\t\tp=(P){(double)V,(double)V*T};\n\t\tsum=sum+p;\n\t\twhile (sum.x>m) {\n\t\t\tv=q[r--];\n\t\t\tsum=sum-v;\n\t\t\tif (sum.x<m) {\n\t\t\t\tv=v*((m-sum.x)/v.x);\n\t\t\t\tsum=sum+v;\n\t\t\t\tq[++r]=v;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\twhile (l<=r&&p.y/p.x<=q[l].y/q[l].x) p=p+q[l++];\n\t\tq[--l]=p;\n\t\tprintf(\"%.8lf\\n\",sum.y/sum.x);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <typename _tp> inline void read(_tp&x) {\n\tchar ch=getchar(),ob=0;x=0;\n\twhile(ch!='-'&&!isdigit(ch))ch=getchar();if(ch=='-')ob=1,ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();if(ob)x=-x;\n}\n\nconst int N = 501000;\nint n, L;\n\nstruct node {\n\tdouble t, v;\n\tfriend inline node operator * (const node&A, const node&B) {\n\t\treturn (node) {(A.t*A.v + B.t*B.v) / (A.v + B.v), A.v + B.v};\n\t}\n} p[N];\n\nint main() {\n\tread(n), read(L);\n\tint l = 1, r = 0, t, v;\n\tdouble heat = 0, volume = 0;\n\tfor(int i=1;i<=n;++i) {\n\t\tread(t), read(v);\n\t\twhile(volume + v > L) {\n\t\t\tdouble dec = min(p[l].v, volume + v - L);\n\t\t\tvolume -= dec;\n\t\t\theat -= p[l].t * dec;\n\t\t\tif(!(p[l].v -= dec)) ++l;\n\t\t}\n\t\theat += (double)t * v, volume += v;\n\t\tp[++r] = (node) {t, v};\n\t\twhile(l < r and p[r-1].t > p[r].t) p[r-1] = p[r-1] * p[r], --r;\n\t\tprintf(\"%.7lf\\n\", (double)heat / volume);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n#include <bits/stdc++.h>\n\nusing namespace std;\n#define Size(x) ((int)(x).size())\n#define pb push_back\n#define LD_OUT setprecision(12) << fixed\n#define int long long\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int>pii;\ntypedef pair<ld,int>pdi;\nconst int INF = 1e9 + 10;\nconst int MN = 5e5 + 10;\n\nint uni[MN] , un , n , L;\nint T[MN] , v[MN];\npdi seg[MN<<2];\n\npdi merge(pdi A,pdi B)\n{\n\tif(A.second == 0 && B.second == 0) return A;\n\tpdi ret;\n\tret.second = A.second + B.second;\n\tret.first = (ld)((ld)A.first*A.second + (ld)B.first*B.second) / (B.second + A.second);\n\treturn ret;\n}\n\nvoid add(int id,int b,int e,int p,pdi val)\n{\n\tif(e-b==1){\n\t\tseg[id] = merge(seg[id], val);\n\t\treturn;\n\t}\n\tint mid = b+e>>1;\n\tif(p<mid) add(id<<1 , b , mid , p , val);\n\telse add(id<<1|1 , mid , e , p , val);\n\tseg[id] = merge(seg[id<<1] , seg[id<<1|1]);\n}\n\nint get_pl(int id,int b,int e,int val)\n{\n\tif(e-b == 1) return b;\n\tint mid = b+e>>1;\n\tif(seg[id<<1|1].second > val) return get_pl(id<<1|1 , mid , e , val);\n\telse return get_pl(id<<1 , b , mid , val-seg[id<<1|1].second);\n}\n\npdi get(int id,int b,int e,int l,int r)\n{\n\tif(r <= b || e <= l) return make_pair(0 , 0);\n\tif(l <= b && e <= r) return seg[id];\n\tint mid = b+e>>1;\n\treturn merge(get(id<<1 , b , mid , l , r) , get(id<<1|1 , mid , e , l , r));\n}\n\nint32_t main()\n{\n\tios_base :: sync_with_stdio(false) ,cin.tie(0) , cout.tie(0);\n\tcin >> n >> L;\n\tfor(int i=0;i<n;++i) cin >> T[i] >> v[i] , uni[i] = T[i];\n\tsort(uni , uni+n);\n\tun = unique(uni , uni+n) - uni;\n\tfor(int i=0;i<n;++i) T[i] = lower_bound(uni , uni+un , T[i]) - uni;\n\t//for(int i=0;i<n;++i) cout <<T[i] << ' ';cout << \"**\\n\";\n\t//cout << un << '\\n';\n\tfor(int i=0;i<n;++i){\n\t\tif(!i){\n\t\t\tcout << LD_OUT << (ld)(uni[T[i]]) << '\\n';\n\t\t}else{\n\t\t\tint p = get_pl(1 , 0 , un , L-v[i]);\n\t\t\tpdi res = get(1 , 0 , un , p+1 , un);\n\t\t\t//cout << p << ' ' << res.first << ' ' << res.second << ' ' << uni[p] << \"****\\n\";\n\t\t\tres = merge(res , make_pair(uni[p] , L-v[i]-res.second));\n\t\t\t//cout << res.first << ' ' << res.second << \"HAMID\\n\";\n\t\t\tif(i == 2) cout << p << ' ' << res.first << ' ' << res.second << '\\n';\n\t\t\tres = merge(res , make_pair(uni[T[i]] , v[i]));\n\t\t\tcout << LD_OUT << res.first << '\\n';\n\t\t}\n\t\t//cout << T[i] << ' ' << uni[T[i]] << ' ' << v[i] << '\\n';\n\t\tadd(1 , 0 , un , T[i] , make_pair(uni[T[i]] , v[i]));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define mk make_pair\n#define ft first\n#define sd second\n#define double long double\nusing namespace std;\nint n,l;\ndeque<pair<int,double> >q;\npair<int,double>t,s;\ndouble sum;\nsigned main()\n{\n    scanf(\"%lld%lld\",&n,&l);\n    for(int i=1;i<=n;i++)\n    {\n        int t1,t2;\n        scanf(\"%lld%lld\",&t1,&t2);double t5=t1*t2;sum+=t1*t2;\n        if(i!=1)\n        {\n            int now=l;\n            while(now>l-t2)\n            {\n               t=q.back();q.pop_back();now-=t.ft;sum-=t.sd;\n            }\n            if(now<l-t2)\n            {\n                double t4=t.sd/t.ft;\n                q.push_back(mk(l-t2-now,t4*(l-t2-now)));sum+=t4*(l-t2-now);\n            }\n        }\n        while(q.size()>=1)\n        {\n            t=q.front();\n            if(t.sd/t.ft<t5/t2)break;\n            t2+=t.ft;t5+=t.sd;q.pop_front();\n        }\n        q.push_front(mk(t2,t5));\n        printf(\"%.7Lf\\n\",sum/l);\n    }\n    return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define t first\n#define v second\n#define wrap make_pair\nusing namespace std;\ntypedef double db;\ntypedef pair<db,int> pint;\ntypedef const pint& cpr;\ntypedef long long ll;\nconst int siz=5e5+1;\n\nint n,L;\nll Vsum;\ndb Esum;\npint a[siz];\ndeque<pint> q;\n\ninline\ndb mix(cpr a,cpr b){return (a.t*a.v+b.t*b.v)/(a.v+b.v);}\n\nint main()\n{\n#ifdef DEBUG\n\tfreopen(\"AT2402.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1,y;i<=n;i++){\n\t\tdb x;\n\t\tscanf(\"%lf%d\",&x,&y);\n\t\ta[i]=wrap(x,y);\n\t\twhile(a[i].v+Vsum>L){\n\t\t\tpint now=q.front();\n\t\t\tq.pop_front();\n\t\t\tint pour=min(a[i].v+Vsum-L,(ll)now.v);\n\t\t\tVsum-=pour;\n\t\t\tEsum-=pour*now.t;\n\t\t\tnow=wrap(now.t,now.v-pour);\n\t\t\tif(now.v!=0)\n\t\t\t\tq.push_front(now);\n\t\t}\n\t\tq.push_back(a[i]);\n\t\twhile(q.size()>1&&q[q.size()-2].t>q.back().t){\n\t\t\tpint b=q.back();\n\t\t\tq.pop_back();\n\t\t\tpint c=q.back();\n\t\t\tq.pop_back();\n\t\t\tq.push_back(wrap(mix(b,c),b.v+c.v));\n\t\t}\n\t\tEsum+=a[i].t*a[i].v;\n\t\tVsum+=a[i].v;\n\t\tprintf(\"%.7f\\n\",Esum/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\n#define double long double\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\n\ntypedef long long LL;\ntypedef pair<LL,double> pld;\nconst int N=500010;\nLL t[N],v[N];\npld q[N];\nint l=1,r=0;\n\nint main()\n{\n    int n=read(),L=read();\n    for(int i=1;i<=n;i++)\n        t[i]=read(),v[i]=read();\n    int sum=0;double cur=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(v[i]+sum>L)\n        {\n            int pour=min(v[i]+sum-L,q[l].FR);\n            sum-=pour;\n            q[l].FR-=pour;\n            cur-=q[l].SE*pour;\n            if(!q[l].FR) l++;\n        }\n        q[++r]=pld(v[i],t[i]);\n        sum+=v[i];cur+=t[i]*v[i];\n        while(l<=r&&q[r].SE<q[r-1].SE)\n        {\n            q[r-1].SE=(q[r-1].SE*q[r-1].FR+q[r].SE*q[r].FR)/(q[r-1].FR+q[r].FR);\n            q[r-1].FR+=q[r].FR;r--;\n        }\n        printf(\"%.7Lf\\n\",cur/L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\ntypedef pair<int,double> P;\n#define fi first\n#define se second\n\ndeque<P> d;\t\t//first: v(水) second: t(温度)\nsigned main(){\n\tint n, v, L;\n\tscanf(\"%lld%lld\", &n, &L);\n\t\n\tdouble t, V = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tscanf(\"%lf%lld\", &t, &v);\n\t\tint u = v;\n\t\t\n\t\twhile(i && u > 0){\n\t\t\tP p = d.front();\n\t\t\tint dis = min(p.fi, u);\n\t\t\tu -= dis;\n\t\t\tV -= dis*p.se;\n\t\t\td.pop_front();\n\t\t\tif(p.fi-dis > 0)d.push_front(P(p.fi-dis, p.se));\n\t\t}\n\t\t\n\t\twhile(!d.empty() && d.back().se > t){\n\t\t\tP p = d.back();d.pop_back();\n\t\t\tV -= p.fi*p.se;\n\t\t\tt = (t*v+p.fi*p.se)/(v+p.fi);\n\t\t\tv += p.fi;\n\t\t}\n\t\t\n\t\tV += t*v;\n\t\td.push_back(P(v, t));\n\t\tprintf(\"%lf\\n\", V/L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=1ll*q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=1ll*q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=1ll*q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=1ll*t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq[tail].t=(1ll*q[tail].t*q[tail].v+1ll*t*v)/(q[tail].v+v);\n\t\t\tq[tail].v+=v;\n\t\t\tsum+=1ll*t*v;\n\t\t\twhile(head<tail&&q[tail-1].t>q[tail].t)\n\t\t\t{\n\t\t\t\ttail--;\n\t\t\t\tq[tail].t=(1ll*q[tail].t*q[tail].v+1ll*t*v)/(q[tail].v+v);\n\t\t\t\tq[tail].v+=v;\n\t\t\t}\n\t\t\t//tail++;\n\t\t\t//sum+=1ll*t*v;\n\t\t\t//q[tail].t=sum/l;\n\t\t\t//q[tail].v=l;\n\t\t\t//head=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define ONLINE_JUDGE\n// {{{ Includes\n#ifndef ONLINE_JUDGE\n#pragma clang diagnostic warning \"-Wall\"\n#pragma clang diagnostic warning \"-Wextra\"\n#pragma clang diagnostic warning \"-Weverything\"\n#pragma clang diagnostic warning \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wvla\"\n#pragma clang diagnostic ignored \"-Wvla-extension\"\n#pragma clang diagnostic ignored \"-Wshadow\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#pragma clang diagnostic ignored \"-Wunused-macros\"\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wsign-compare\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wmissing-variable-declarations\"\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"\n#pragma clang diagnostic ignored \"-Wunused-const-variable\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wfloat-equal\" // it's fine\n#pragma clang diagnostic ignored \"-Wdouble-promotion\" // also\n#endif\n\n#include <unordered_map>\n#include <random>\n#include <climits>\n#include <array>\n#include <fstream>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <cstring>\n#include <limits>\n#include <chrono>\n#include <unistd.h>\nusing namespace std;\n// }}}\n// {{{ Utilities\n#ifdef ONLINE_JUDGE\nstatic bool debug = false;\n#else\nstatic bool debug = true;\n#endif\n#define db(x) #x << \"=\" << (x) << \" \"\n#define dprintf debug && printf\n\n#define All(x) x.begin(), x.end()\n#define Loop(i, n) for (int i = 0; i < int(n); ++i)\ntemplate <typename T, typename Q, typename S>\nbool Bounded(const T &x, const Q &a, const S &b) { return a <= x && x <= b; }\n\ntypedef long double Real;\nconst Real pi = 4*atan(Real(1.0));\nconst Real Inf = numeric_limits<Real>::infinity();\n// https://github.com/JuliaLang/julia/blob/master/base/floatfuncs.jl\nReal isapprox(Real x, Real y, Real rtol = sqrt(numeric_limits<Real>::epsilon()), Real atol = Real(0.0), bool nans = false) {\n  return x == y ||\n    (nans && isnan(x) && isnan(y)) ||\n    (isfinite(x) && isfinite(y) && abs(x - y) <= atol + rtol*max(abs(x), abs(y)));\n}\ntypedef long long int ll;\ntypedef vector<Real> Vd;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<bool> Vb;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n\ntemplate <typename T> int sz(const T &x) { return (int)x.size(); }\ntemplate <typename T, typename Q> bool mem(const T &s, const Q &x) { return s.find(x) != s.end(); }\ntemplate <typename T> void push(vector<T>& c, const T& e) { c.push_back(e); }\ntemplate <typename T> void push(queue<T>& c, const T& e) { c.push(e); }\ntemplate <typename T> void push(set<T>& c, const T& e) { c.insert(e); }\ntemplate <typename T, typename... Args> auto emplace(vector<T>& c, Args&&... args) -> decltype(c.emplace_back(args...)) { c.emplace_back(args...); }\ntemplate <typename T, typename... Args> auto emplace(queue<T>& c, Args&&... args) -> decltype(c.emplace(args...)) { c.emplace(args...); }\ntemplate <typename T, typename... Args> auto emplace(set<T>& c, Args&&... args) -> decltype(c.emplace(args...)) { c.emplace(args...); }\ntemplate <typename T> void umin(T &x, const T &y) { x = min(x, y); }\ntemplate <typename T> void umax(T &x, const T &y) { x = max(x, y); }\ntemplate <typename T> int sign(const T &x) {\n  return x == 0 ? 0 : x > 0 ? 1 : -1;\n}\ntemplate <typename T> T square(const T &x) { return x * x; }\n// }}}\n// {{{ IO\ntemplate <typename S, typename T>\nistream& operator>>(istream& in, pair<S, T>& p) { return in >> p.first >> p.second; }\ntemplate <typename T> T read() { T x; cin >> x; return x; }\ntemplate <typename T, typename I = typename T::iterator>\nvoid read(T &cnt) { for (auto& x : cnt) cin >> x; }\ntemplate <typename S, typename T>\nostream& operator<<(ostream& out, const pair<S, T>& p) {\n  return out << \"{\" << p.first << \", \" << p.second << \"}\";\n}\ntemplate <typename T> struct show_container {\n  const T &container;\n  show_container(const T &container_) : container(container_) {}\n};\ntemplate <typename T>\nostream &operator<<(ostream &o, const show_container<T> &thing) {\n  bool first = true;\n  o << \"{\";\n  for (const auto &x : thing.container) {\n    if (!first)\n      o << \", \";\n    first = false;\n    o << x;\n  }\n  o << \"}\";\n  return o;\n}\ntemplate <typename T> show_container<T> show(const T &container) {\n  return show_container<T>(container);\n}\n\n#define dprintf debug && printf\nstruct dout_ { } dout;\ntemplate <typename T> dout_ &operator<<(dout_ &out, const T &thing) { if (debug) cout << thing; return out; }\ndout_ &operator<<(dout_ &out, ostream &(*thing)(ostream &)) { if (debug) cout << thing; return out; }\n\nstruct outboth {\n  ostream &a;\n  ostream &b;\n  outboth(ostream &a_, ostream &b_) : a(a_), b(b_) {}\n};\ntemplate <typename T> outboth &operator<<(outboth &both, const T &thing) {\n  both.a << thing;\n  both.b << thing;\n  return both;\n}\noutboth &operator<<(outboth &both, ostream &(*thing)(ostream &)) {\n  both.a << thing;\n  both.b << thing;\n  return both;\n}\n// }}}\n// {{{ Solver\n\nReal inf = numeric_limits<Real>::infinity();\n\nReal mix(Real t1, ll v1, Real t2, ll v2) {\n  if (v1 < 0 || v2 < 0) return -numeric_limits<Real>::infinity();\n  assert(!(v1 == 0 && v2 == 0));\n  if (v1 == 0) return t2;\n  if (v2 == 0) return t1;\n  return (t1*v1 + t2*v2) / (v1 + v2);\n}\n\ntypedef pair<ll, Real> Pd;\n\nReal cross(Pd a, Pd b) {\n  return a.first * b.second - a.second * b.first;\n}\n\nPd operator+(Pd a, Pd b) { return { a.first + b.first, a.second + b.second }; }\n\n#ifdef ONLINE_JUDGE\nvoid solve(ostream& rout)\n#else\nvoid solve(outboth rout)\n#endif\n{\n  rout << std::fixed << std::setprecision(7);\n\n  int N; ll L; cin >> N >> L; if (!cin) return;\n  vector<Pll> water(N); read(water);\n\n  vector<Pd> stack;\n\n  for (Pll p : water) {\n    push(stack, {p.second, p.first * p.second});\n    // dout << db(p) << show(stack) << endl;\n    while (sz(stack) >= 2 && cross(stack[sz(stack)-1], stack[sz(stack)-2]) >= 0) {\n      Pd p1 = stack[sz(stack)-1], p2 = stack[sz(stack)-2];\n      Pd w = p1.first + p2.first <= L ? p1 + p2 : Pd{L, p1.second + (L - p1.first)/Real(p2.first) * p2.second};\n      stack.pop_back(); stack.pop_back();\n      push(stack, w);\n    }\n\n    // dout << db(p) << show(stack) << endl;\n\n    Pd prev = {0, 0}, next = stack.back();\n    ll v = L;\n    for (int i = sz(stack)-2; !Bounded(v, prev.first, next.first); --i) {\n      prev = next;\n      next = next + stack[i];\n    }\n    assert(Bounded(v, prev.first, next.first));\n    // dout << \"Error: \" << abs((prev.first * (next.first - v) + next.first * (v - prev.first)) / Real(next.first - prev.first) - v) << endl;\n    Real ans = (prev.second * (next.first - v) + next.second * (v - prev.first)) / Real(next.first - prev.first);\n    // dout << db(prev) << db(next) << db(ans) << endl;\n    rout << ans/Real(v) << \"\\n\";\n  }\n\n  // Real dp[N][L+1]; memset(dp, 0, sizeof(dp));\n  // dp[0][L] = water[0].first;\n  // rout << dp[0][L] << \"\\n\";\n\n  // for (int i = 1; i < N; ++i) {\n  //   ll t1 = water[i].first, v1 = water[i].second;\n  //   for (ll v = 0; v <= L; ++v) {\n  //     for (ll vprev = 0; vprev <= L; ++vprev) {\n  //       ll u = vprev + v1 - v;\n  //       if (!Bounded(u, 0, L)) continue;\n  //       umax(dp[i][v], mix(dp[i-1][vprev], v - v1, t1, v1));\n  //     }\n  //   }\n  //   Loop(v, L+1) dout << \" \" << dp[i][v]; dout << endl;\n  //   rout << dp[i][L] << \"\\n\";\n  // }\n\n}\n\n// }}}\n// {{{ Main\n\nint main() {\n  std::ios::sync_with_stdio(false); cin.tie(nullptr);\n  solve(cout);\n  return 0;\n}\n// }}}\n\n// clang-format off\n// Local variables:\n// compile-command: \"make D && ./D\"\n// irony-additional-clang-options: (\"-std=c++11\")\n// End:\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,double> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n, l;\n\tcin>>n>>l;\n\tdeque<P> q;\n\tdouble s = 0;\n\tcout.precision(20);\n\trep(i, n){\n\t\tll t, v;\n\t\tcin>>t>>v;\n\t\ts += v*t;\n\t\tif(i){\n\t\t\tll e = v;\n\t\t\twhile(e>0){\n\t\t\t\tP p = q.front(); q.pop_front();\n\t\t\t\tll d = min(e, p.fst);\n\t\t\t\te -= d;\n\t\t\t\tp.fst -= d;\n\t\t\t\ts -= d*p.snd;\n\t\t\t\tif(p.fst>0) q.push_front(p);\n\t\t\t}\n\t\t\tP p = q.back();\n\t\t\tif(p.snd>=t){\n\t\t\t\tq.pop_back();\n\t\t\t\tll v2 = v+p.fst;\n\t\t\t\tdouble t2 = (v*t+p.fst*p.snd)/v2;\n\t\t\t\tq.push_back(P(v2, t2));\n\t\t\t} else q.push_back(P(v, t));\n\t\t} else q.push_back(P(v, t));\n\n\t\tcout<<s/l<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#define SIZE 500005\n#define EPS 1e-10\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <double,int> P;\n\nP st[SIZE];\n\nint main()\n{\n\tint n,L;\n\tscanf(\"%d %d\",&n,&L);\n\tint s=0,sz=0;\n\tdouble sum=0.0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint t,v;\n\t\tscanf(\"%d %d\",&t,&v);\n\t\tif(i>0)\n\t\t{\n\t\t\tll zan=v;\n\t\t\twhile(zan>0)\n\t\t\t{\n\t\t\t\tif(st[s].second>zan)\n\t\t\t\t{\n\t\t\t\t\tst[s].second-=zan;\n\t\t\t\t\tsum-=st[s].first*(double) zan;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsum-=st[s].first*(double) st[s].second;\n\t\t\t\t\tzan-=st[s].second;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum+=(double) t*(double) v;\n\t\tP p=P(t,v);\n\t\twhile(sz>0&&st[sz-1].first+EPS>p.first)\n\t\t{\n\t\t\tP q=st[--sz];\n\t\t\tP r=P((q.first*(double) q.second+p.first*(double) p.second)/(double) (p.second+q.second),p.second+q.second);\n\t\t\tp=r;\n\t\t}\n\t\t//printf(\"%f %d\\n\",p.first,p.second);\n\t\tst[sz++]=p;\n\t\tprintf(\"%.10f\\n\",sum/(double) L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint t,v;\n\tscanf(\"%d%d%d%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%d%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\tint y = min(L-v,x);\n\t\t\td = water(d,y,t,v);\n\t\t\tx = y + v;\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint T,maxl,L,l=1,r,tmp;\n\nstruct node{\n\tdouble t;\n\tint v;\n}s[500010];\n\nsigned main(){\n\tscanf(\"%lld%lld\",&T,&maxl);\n\twhile(T--){\n\t\tint t,v;\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\twhile(L+v>maxl){\n\t\t\tint out=min(s[l].v,L+v-maxl);\n\t\t\ts[l].v-=out;L-=out;\n\t\t\ttmp-=out*s[l].t;\n\t\t\tif(!s[l].v) ++l;\n\t\t}\n\t\ts[++r]=(node){t,v};\n\t\ttmp+=t*v;L+=v;\n\t\twhile(l<r&&s[r-1].t>s[r].t){\n\t\t\ts[r-1].t=(double)(s[r-1].t*s[r-1].v+s[r].t*s[r].v)/(s[r-1].v+s[r].v);\n\t\t\ts[r-1].v+=s[r].v;--r;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",(double)tmp/maxl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=5e5+10;\nconst double eps=1e-10;\nint n,L,Head=0,Tail=0;\ninline int sgn(double x){\n\tif(x>eps) return 1;\n\tif(x<-eps) return -1;\n\treturn 0;\n}\ninline int read(){\n\tint x=0;char ch=getchar();\n\twhile(!isdigit(ch)) ch=getchar();\n\twhile(isdigit(ch)) x=(x<<3)+(x<<1)+ch-'0',ch=getchar();\n\treturn x;\n}\nstruct Point{\n\tdouble x,y;\n\tPoint(double X=0,double Y=0){x=X,y=Y;}\n\tfriend inline Point operator+(const Point &a,const Point &b){return Point(a.x+b.x,a.y+b.y);}\n\tfriend inline Point operator-(const Point &a,const Point &b){return Point(a.x-b.x,a.y-b.y);}\n\tfriend inline Point operator+(const Point &a,const double &b){return Point(a.x/b,a.y/b);}\n\tfriend inline double cross(const Point &a,const Point &b){return a.x*b.y-a.y*b.x;}\n\tinline double f(double v){if(!sgn(x)) return 0;return v*y/x;}\n}O,Q[maxn];\nint main(){\n\t//freopen(\"ARC072F.in\",\"r\",stdin);\n\tn=read(),L=read();\n\tfor(int i=1;i<=n;++i){\n\t\tdouble u=read(),v=read();\n\t\tO=Point(O.x+u,O.y+u*v);\n\t\twhile(Head<Tail&&(O.x-Q[Head+1].x)>=L) ++Head;\n\t\tif(Head!=Tail&&O.x-Q[Head].x>L) Q[Head]=Point(O.x-L,Q[Head].y+Point(Q[Head+1]-Q[Head]).f(O.x-L-Q[Head].x));\n\t\twhile(Head<Tail&&sgn(cross(O-Q[Tail-1],Q[Tail]-Q[Tail-1]))>=0) Tail--;\n\t\tQ[++Tail]=O,printf(\"%.7lf\\n\",(O.y-Q[Head].y)/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, ld> pld;\n\n#define fi first\n#define se second\n\nconst int MAXN = 500005;\n\nint T[MAXN], V[MAXN];\ndeque<pld> d;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint N, L;\n\n\tcin >> N >> L;\n\tfor(int i = 0; i < N; i++) cin >> T[i] >> V[i];\n\n\tcout << fixed;\n\tcout.precision(20);\n\tpld ep = make_pair(0.0L, 0.0L);\n\tfor(int i = 0; i < N; i++) {\n\t\td.push_front(make_pair(V[i], (ld) V[i] * T[i]));\n\t\tep.fi = L;\n\t\tep.se += (ld) V[i] * T[i];\n\t\tcout << ep.se / ep.fi << \"\\n\";\n\t\tif(i == N - 1) break;\n\t\twhile(!d.empty() && ep.fi - d.back().fi > L - V[i + 1]) d.pop_back();\n\t\twhile(d.size() > 1 && d[0].se / d[0].fi < d[1].se / d[1].fi) {\n\t\t\td[1].fi += d[0].fi;\n\t\t\td[1].se += d[0].se;\n\t\t\td.pop_front();\n\t\t}\n\t\tif(!d.empty()) {\n\t\t\tld sed = d.back().se * (ep.fi - L + V[i + 1]) / d.back().fi;\n\t\t\td.back().fi -= ep.fi - L + V[i + 1];\n\t\t\tep.se -= sed;\n\t\t\td.back().se -= sed;\n\t\t\tep.fi = L - V[i + 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n\nvoid read(ll &rem){\n\trem = 0; char c = getchar();\n\twhile(c<'0'||c>'9') c = getchar();\n\twhile(c>='0'&&c<='9') rem = rem*10+c-48, c = getchar();\n}\n\ndouble tem[100050];\nll v[100050], cnt, head = 1;\n\nint main(){\n\tll T, L, nt, nv, ans = 0;\n\tbool flag = 0;\n\tread(T), read(L);\n\twhile(T--){\n\t\tscanf(\"%lld %lld\", &nt, &nv);\n\t\ttem[++cnt] = nt;\n\t\tv[cnt] = nv;\n\t\tans += nt * nv;\n\t\tll p = 0;\n\t\tif(flag){\n\t\t\twhile(p+v[head]<=nv) {\n\t\t\t\tp+=v[head], ans -= tem[head] * v[head], head++;\n\t\t\t}\n\t\t\tif(p<nv){\n\t\t\t\tv[head] -= nv-p;\n\t\t\t\tans -= (nv-p) * tem[head];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8f\\n\", 1.0 * ans / L);\n\t\twhile(tem[cnt] <= tem[cnt-1] && cnt-1 >= head){\n\t\t\ttem[cnt-1] = 1.0 * (v[cnt] * tem[cnt] + v[cnt-1] * tem[cnt-1]) / (v[cnt] + v[cnt-1]);\n\t\t\tv[cnt-1] += v[cnt];\n\t\t\tcnt--;\n\t\t}\n\t\tflag = 1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long double ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nld t[1 << 19], v[1 << 19];\n\nvector<ld> ans;\n\nstruct SegT {\nprivate:\n\tint sz;\n\tvector<ll> node;\n\tvector<ll> subnode;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t\tsubnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn max(a, b);\n\t}\n\tvoid update(int k, ll a,ll sa) {\n\t\tk += sz - 1;\n\t\tnode[k] = a; subnode[k] = sa;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t\tsubnode[k] = f(subnode[k * 2 + 1], subnode[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n\tll sum(ll r) {\n\t\tll ret = 0;\n\t\tint k = 0;\n\t\twhile (k < sz - 1) {\n\t\t\tll s = node[2 * k + 2];\n\t\t\tif (r >= s) {\n\t\t\t\tret += subnode[2 * k + 2];\n\t\t\t\tr -= s;\n\t\t\t\tk = 2 * k + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk = 2 * k + 2;\n\t\t\t}\n\t\t}\n\t\tret += subnode[k]*r / node[k];\n\t\treturn ret;\n\t}\n};\n\nvoid solve() {\n\tint n; ll l;\n\tcin >> n >> l;\n\trep(i, n) {\n\t\tcin >> t[i] >> v[i];\n\t}\n\tll a = t[0]*v[0], b = v[0];\n\tans.push_back(a/l);\n\tSegT st(n + 1);\n\tint cur = 0;\n\n\trep1(i, n - 1) {\n\t\tif (a >= t[i]) {\n\t\t\tif (b + v[i] > l) {\n\t\t\t\tll r = l - v[i];\n\t\t\t\ta = a * r / b + t[i] * v[i];\n\t\t\t\t//cout << a << \" ??\" << endl;\n\t\t\t\tb = l;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta += t[i] * v[i];\n\t\t\t\tb += v[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tst.update(cur, b, a); cur++;\n\t\t\ta = t[i]*v[i]; b = v[i];\n\t\t}\n\t\tif (b == l) {\n\t\t\tans.push_back(a / l);\n\t\t}\n\t\telse {\n\t\t\tll r = l - b;\n\t\t\tll s = a + st.sum(r);\n\t\t\t//cout << st.sum(r)<<\"??\" << endl;\n\t\t\tans.push_back(s / l);\n\t\t}\n\t\t\n\t}\n\trep(i, n) {\n\t\tcout << ans[i] << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,deque<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// 温度, 量\ndeque<pdd> deq;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, L;\n    cin >> n >> L;\n    double nw = 0;\n    ll t, v;\n    cin >> t >> v;\n    deq.pb(pdd(t, v));\n    printf(\"%.12lf\\n\", (nw += t*v)/L);\n    rep(i,n-1){\n        ll t, v;\n        cin >> t >> v;\n        double sm = 0;\n        while(true){\n            pdd& p = deq.front();\n            if(sm + p.se < v){\n                sm += p.se;\n                nw -= p.fi*p.se;\n                deq.pop_front();\n            }else{\n                nw -= p.fi*(v-sm);\n                p.se -= v-sm;\n                break;\n            }\n        }\n        double made = t*v, ryo = v;\n        while(true){\n            pdd& p = deq.back();\n            if(p.fi*ryo < made){\n                deq.pb(pdd(made/ryo,ryo));\n                break;\n            }else{\n                made += p.fi*p.se;\n                ryo += p.se;\n                deq.pop_back();\n            }\n        }\n        printf(\"%.12lf\\n\", (nw += t*v)/L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint main(void)\n{\n\tLL N, L;\n\tcin >> N >> L;\n\tdeque<pair<LL, LL>>que;//first:体積 second:熱量\n\tLL Q = 0;//dequeに含まれる熱量の和\n\tLL V = 0;//dequeに含まれる体積の和\n\tcout.precision(15);\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tLL t, v;\n\t\tcin >> t >> v;\n\t\tLL q = t * v;\n\t\t//水の流入\n\t\t//過去で排出していたことにする(過去改変(いいえ))\n\t\twhile (V + v > L)\n\t\t{\n\t\t\tauto fr = que.front();\n\t\t\tif (V + v - fr.first >= L)\n\t\t\t{\n\t\t\t\tV -= fr.first;\n\t\t\t\tque.pop_front();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLL dif = V + v - L;\n\t\t\t\tLL tt = que[0].second / que[0].first;\n\t\t\t\tque[0].first -= dif;\n\t\t\t\tque[0].second -= dif * tt;\n\t\t\t\tV = L - v;\n\t\t\t\tQ -= dif * tt;\n\t\t\t}\n\t\t}\n\t\tque.push_back({ v,q });\n\t\tQ += q;\n\t\tV += v;\n\t\t//必要に応じて統合する\n\t\twhile (que.size() > 1)\n\t\t{\n\t\t\tLL t1 = que[que.size() - 2].second / que[que.size() - 2].first;\n\t\t\tLL t2 = que[que.size() - 1].second / que[que.size() - 1].first;\n\t\t\tif (t1 > t2)\n\t\t\t{\n\t\t\t\tauto p1 = que[que.size() - 2];\n\t\t\t\tauto p2 = que[que.size() - 1];\n\t\t\t\tque.pop_back();\n\t\t\t\tque.pop_back();\n\t\t\t\tque.push_back({ p1.first + p2.first,p1.second + p2.second });\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//今ある熱量/体積が答え\n\t\tassert(V == L);\n\t\tauto ans = (long double)Q / V;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\nusing Pdi = pair<double, int>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    double L; cin >> L;\n    vector<int> t(N), v(N);\n    vector<double> ans(N, 0.0);\n    REP(i, N) cin >> t[i] >> v[i];\n\n    deque<Pdi> dq;\n    double S = 0.0;\n    int V = 0;\n    REP(i, N){\n        int L0 = L - v[i];\n        while(V > L0){\n            double s2 = dq.front().f;\n            int v2 = dq.front().s;\n            dq.pop_front();\n            if(v2 > V - L0){\n                S -= s2 * (double)(V - L0) / v2;\n                s2 *= (double)(v2 - (V - L0)) / v2;\n                v2 -= V - L0;\n                V = L0;\n                dq.push_front(Pii(s2, v2));\n            }else{\n                S -= s2;\n                V -= v2;\n            }\n        }\n\n        double s0 = t[i] * v[i];\n        int v0 = v[i];\n        V += v0;\n        S += s0;\n        while(SZ(dq) > 0 && dq.back().f / dq.back().s > s0 / v0){\n            double s1 = dq.back().f;\n            int v1 = dq.back().s;\n            dq.pop_back();\n            s0 += s1;\n            v0 += v1;\n        }\n        dq.push_back(Pdi(s0, v0));\n        \n        ans[i] = S / L;\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1; ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nll d[1000005];\ndouble t[1000005];\nint main(){\n\tint n=read(),m=read();\n\tint l=1,r=0,dq=0;\n\tdouble zl=0;\n\tfor (int i=1;i<=n;i++){\n\t\tll T=read(),V=read();\n\t\td[++r]=V; t[r]=(double)T*V;\n\t\tzl+=t[r]; dq+=d[r];\n\t\tfor (;t[r]/d[r]<t[r-1]/d[r-1]&&l<r;r--)\n\t\t\tif (d[r-1]+d[r]<=m) t[r-1]+=t[r],d[r-1]+=d[r];\n\t\t\telse{\n\t\t\t\tt[r-1]=t[r]+(t[r-1]/d[r-1])*(m-d[r]);\n\t\t\t\tdq=d[r-1]=m; zl=t[r-1]; --r; l=r;\n\t\t\t    break;\n\t\t\t}\n\t\tfor (;dq>m;l++){\n\t\t\tif (dq-d[l]>=m) dq-=d[l],zl-=t[l];\n\t\t\telse {\n\t\t\t\tdouble k=t[l]/d[l];\n\t\t\t\tzl-=k*(dq-m);\n\t\t\t\tt[l]-=k*(dq-m);\n\t\t\t\td[l]-=dq-m;\n\t\t\t\tdq=m; break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7lf\\n\",zl/m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tld x,y;\n\tbool operator <(const point b)const{\n\t\treturn y*b.x<b.y*x;\n\t}\n}q[500005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){(ld)y,(ld)x*y};\n\t\tallt+=v.y; allv+=v.x;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tld v=q[head].y*(allv-l)/q[head].x;\n\t\t\tq[head].x-=allv-l;\n\t\t\tallv=l;\n\t\t\tq[head].y-=v;\n\t\t\tallt-=v;\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.6lf\\n\",(double)(allt/allv));\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y+=q[tail].y;\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<db,db> pa;\nconst int N=1e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint L,n;\npa q[N],p[N];\npa merge(pa a,pa b){return pa((a.w1*a.w2+b.w1*b.w2)/(a.w2+b.w2),a.w2+b.w2);}\n#define QQ(a) (a.w1*a.w2)\nint main(){\n\tread(n,L);\n\tint h=5e5,t=h;\n\trep(i,1,n)scanf(\"%lf%lf\",&p[i].w1,&p[i].w2);\n\tq[h]=p[1];\n\tprintf(\"%.8lf\\n\",p[1].w1);\n\tdb all=p[1].w2,Q=QQ(p[1]);\n\trep(i,2,n){\n\t\tall+=p[i].w2;\n\t\twhile(h<t&&all-q[t].w2>L){\n\t\t\tall-=q[t].w2;\n\t\t\tQ-=QQ(q[t]);\n\t\t\tt--;\n\t\t}\n\t\tif(all>L){\n\t\t\tQ-=QQ(q[t]);\n\t\t\tq[t].w2-=all-L,all=L;\n\t\t\tQ+=QQ(q[t]);\n\t\t}\n\t\t\n\t\tif(q[h].w1>p[i].w1){\n\t\t\tQ-=QQ(q[h]);\n\t\t\tq[h]=merge(q[h],p[i]);\n\t\t\tQ+=QQ(q[h]);\n\t\t}else{\n\t\t\th--;\n\t\t\tq[h]=p[i];\n\t\t\tQ+=QQ(q[h]);\n\t\t}\n\t\t\n\t\tprintf(\"%.8lf\\n\",Q/all);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 5e5 + 9, M = N * 20;\nint n, lim, t, v, sum;\ndouble pp;\n\nstruct pii {\n\tdouble t, sum;\n\tint v;\n\tpii (double t, double sum, int v) : t(t), sum(sum), v(v) {}\n};\ndeque<pii>Q;\n\nint main () {\n\tscanf(\"%d%d\", &n, &lim);\n\tfor (int i = 1, j; i <= n; ++i) {\n\t\tscanf(\"%d%d\", &t, &v);\n\t\twhile (!Q.empty() && sum + v > lim) {\n\t\t\tsum -= (j = min(sum - (lim - v), Q.front().v));\n\t\t\tQ.front().v -= j; pp -= Q.front().t * j;\n\t\t\tif (!Q.front().v) Q.pop_front();\n\t\t}\n\t\tQ.push_back(pii(t, 1.0 * t * v, v)); sum += v; pp += Q.back().sum;\n\t\twhile (sum != Q.back().v) {\n\t\t\tpii b = Q.back(); Q.pop_back(); pii &a = Q.back();\n\t\t\tif (a.t > b.t) a.t = (a.t * a.v + b.t * b.v) / (a.v + b.v), a.v += b.v, a.sum += b.sum;\n\t\t\telse {\n\t\t\t\tQ.push_back(b);\n\t\t\t\tbreak ;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7f\\n\", pp / lim);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200055];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return (long double)1.0;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(num,i,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/(long double)l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <queue>\nusing namespace std;\nconst int Q=1<<19;\n#define db double\ndb qt[Q];\nint qv[Q];\nint hd=1,tl=0;\nconst db eps=1e-9;\nint main()\n{\n\tint n;\n\tint L;\n\tdb als=0;\n\tscanf(\"%d%d\",&n,&L);\n\twhile(n--){\n\t\tint v;\n\t\tdb t;\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint qaq=L*(hd<=tl)+v;\n\t\twhile(qaq>L){\n\t\t\tint now=min(qaq-L,qv[hd]);\n\t\t\tqaq-=L;\n\t\t\tals-=qt[hd]*now;\n\t\t\tqv[hd]-=now;\n\t\t\tif(!qv[hd])++hd;\n\t\t}\n\t\tals+=t*v;\n\t\tprintf(\"%.8lf\\n\",als/L);\n\t\twhile(hd<=tl&&t-qt[tl]<eps){\n\t\t\tt=(db)(t*v+qt[tl]*qv[tl])/(v+qv[tl]);\n\t\t\tv+=qv[tl];\n\t\t\t--tl;\n\t\t}\n\t\tqv[++tl]=v;\n\t\tqt[tl]=t;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nconst int N = 500*1000+7;\n\nint T[N];\nint V[N];\nLL sumU[N];\nLL sumD[N];\ndouble ans[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, L;\n\tcin >> n >> L;\n\n\tFOR(i,0,n)\n\t{\n\t\tcin >> T[i] >> V[i];\n\t\tsumD[i] = V[i];\n\t\tsumU[i] = V[i]*(LL)T[i];\n\t\tif(i)\n\t\t{\n\t\t\tsumD[i] += sumD[i-1];\n\t\t\tsumU[i] += sumU[i-1];\n\t\t\tans[i] = (ans[i-1]*(L-V[i]) + T[i]*1.0*V[i]) / L;\n\t\t\tint pos = upper_bound(sumD, sumD+i, sumD[i]-L) - sumD;\n\t\t\tLL sum2 = sumD[i] - sumD[pos];\n\t\t\tLL sum1 = sumU[i] - sumU[pos] + T[pos]*(LL)(L - sum2);\n//\t\t\tcout << pos << endl;\n\t\t\tans[i] = max(ans[i], sum1*1.0/L);\n\t\t}\n\t\telse\n\t\t\tans[0] = T[i];\n\t\tcout << fixed << setprecision(8) << ans[i] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define reg register\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair < ll, double > pii;\nconst int maxn = 500005;\n\ninline ll read() {\n    reg ll s = 0, t = 0; reg char ch = getchar();\n    while (!isdigit(ch)) t |= ch == '-', ch = getchar();\n    while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\n\npii q[maxn];\nint n, L, v, t;\nint l = 1, r = 0;\nll pourWater, remainWater = 0;\ndouble temperature = 0;\n\nint main() {\n    n = read(), L = read();\n    for (reg int i = 1; i <= n; i++) {\n        t = read(), v = read();\n        while (remainWater + v > L) {\n            pourWater = min(q[l].first, remainWater + v - L);\n            q[l].first -= pourWater;\n            remainWater -= pourWater;\n            temperature -= q[l].second * pourWater;\n            if (!q[l].first) l++;\n        }\n        remainWater += v, temperature += 1LL * t * v;\n        q[++r] = make_pair(v, t);\n        while (l < r && q[r].second < q[r - 1].second) {\n            q[r - 1].second = (q[r].first * q[r].second + q[r - 1].first * q[r - 1].second) / (q[r].first + q[r - 1].first);\n            q[r - 1].first += q[r].first; r--;\n        }\n        printf(\"%.7f\\n\", temperature / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nint main(void)\n{\n\tLL N, L;\n\tcin >> N >> L;\n\tdeque<pair<LL, LL>>que;//first:体積 second:熱量\n\tLL Q = 0;//dequeに含まれる熱量の和\n\tLL V = 0;//dequeに含まれる体積の和\n\tcout.precision(15);\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tLL t, v;\n\t\tcin >> t >> v;\n\t\tLL q = t * v;\n\t\t//水の流入\n\t\t//過去で排出していたことにする(過去改変(いいえ))\n\t\twhile (V + v > L)\n\t\t{\n\t\t\tauto fr = que.front();\n\t\t\tif (V + v - fr.first >= L)\n\t\t\t{\n\t\t\t\tV -= fr.first;\n\t\t\t\tQ -= fr.second;\n\t\t\t\tque.pop_front();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLL dif = V + v - L;\n\t\t\t\tLL tt = que[0].second / que[0].first;\n\t\t\t\tque[0].first -= dif;\n\t\t\t\tque[0].second -= dif * tt;\n\t\t\t\tV = L - v;\n\t\t\t\tQ -= dif * tt;\n\t\t\t}\n\t\t}\n\t\tque.push_back({ v,q });\n\t\tQ += q;\n\t\tV += v;\n\t\t//必要に応じて統合する\n\t\twhile (que.size() > 1)\n\t\t{\n\t\t\tLL t1 = que[que.size() - 2].second / que[que.size() - 2].first;\n\t\t\tLL t2 = que[que.size() - 1].second / que[que.size() - 1].first;\n\t\t\tif (t1 > t2)\n\t\t\t{\n\t\t\t\tauto p1 = que[que.size() - 2];\n\t\t\t\tauto p2 = que[que.size() - 1];\n\t\t\t\tque.pop_back();\n\t\t\t\tque.pop_back();\n\t\t\t\tque.push_back({ p1.first + p2.first,p1.second + p2.second });\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t//今ある熱量/体積が答え\n\t\tassert(V == L);\n\t\tauto ans = (long double)Q / V;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, double> pairID;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nint N, L;\ndeque<pairID> A;\n\nint main(int argc, char *argv[])\n{\n    int t, v;\n    double total_heat;\n\n    scanf(\"%d%d\", &N, &L);\n    scanf(\"%d%d\", &t, &v);\n    \n    A.push_front(make_pair(v, t));\n    total_heat = (double)v * t;\n    printf(\"%.7f\\n\", total_heat / L);\n    \n    FOR1(i,1,N) {\n        pairID back;\n        int vol;\n\n        scanf(\"%d%d\", &t, &v);\n        total_heat += (double)v * t;\n        \n        vol = v;\n        while (vol > 0) {\n            back = A.back();\n            A.pop_back();\n            vol -= back.first;\n            total_heat -= back.first * back.second;\n        }\n        if (vol != 0) {\n            A.push_back(make_pair(-vol, back.second));\n            total_heat += -vol * back.second;\n        }\n\n        double heat = v * t;\n        vol = v;\n        while(A.size() > 0 && heat / vol <= A.front().second) {\n            heat += A.front().first * A.front().second;\n            vol += A.front().first;\n            A.pop_front();\n        }\n        A.push_front(make_pair(vol, heat / vol));\n\n        printf(\"%.7f\\n\", total_heat / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, l;\n  cin >> n >> l;\n  deque<pair<double, ll>> q;\n  ll sumV = 0;\n  double sumVT = 0;\n  cout << fixed << setprecision(10);\n  for(int i = 0; i < n; i++) {\n    ll t, v;\n    cin >> t >> v;\n    while(sumV + v > l) {\n      auto p = q.front();\n      q.pop_front();\n      ll wd = sumV + v - l;\n      ll del = min(wd, p.second);\n      sumV -= del;\n      p.second -= del;\n      sumVT -= del * p.first;\n      if(p.second) q.push_front(p);\n    }\n\n    double o = (sumVT + v * t) / l;\n\n    cout << o << \"\\n\";\n\n    if(q.empty() || q.back().first + 1e-11 < t) {\n      q.emplace_back(t, v);\n      sumV += v;\n      sumVT += v * t;\n    } else {\n      q.clear();\n      q.emplace_back(o, l);\n      sumV = l;\n      sumVT = o * l;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 5e5 + 5; \nusing namespace std;\n\nint n, m, t[N], v[N], l, r, lim;\ndouble Q; \nstruct node\n{\n\tint v; double t;\n\tnode(int x = 0, double y = 0) { v = x, t = y; }\n} q[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin);\n#endif\n\tn = read <int> (), m = read <int> ();\n\tfor(int i = 1; i <= n; i++) t[i] = read <int> (), v[i] = read <int> ();\n\tl = 1, r = 0; \n\tfor(int mn, i = 1; i <= n; i++)\n\t{\n\t\twhile(lim > m - v[i])\n\t\t{\n\t\t\tmn = min(lim - (m - v[i]), q[l].v), lim -= mn; \n\t\t\tif(mn <= q[l].v) q[l].v -= mn, Q -= q[l].t * mn;\n\t\t\telse Q -= q[l].t * q[l].v, l++; \n\t\t}\n\t\tq[++r] = node(v[i], t[i]), Q += 1.0 * t[i] * v[i], lim += v[i]; \n\t\twhile(l < r && q[r].t < q[r - 1].t)\n\t\t{\n\t\t\tq[r - 1].t = (q[r - 1].t * q[r - 1].v + q[r].t * q[r].v) / (q[r - 1].v + q[r].v);\n\t\t\tq[r - 1].v = q[r - 1].v + q[r].v, r--; \n\t\t}\n\t\tprintf(\"%.6lf\\n\", Q / m); \n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6\nvector<pair<DB, DB> > W;\nint w0;\n// degree, V\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W[w0].se);\n        if (!sgn(ll- d)){\n            V = 0;\n        }\n        else {\n            \n            V = ((V*ll) - d*W[w0].fi) / (ll-d);\n        }\n        l -= d; W[w0].se -= d;\n        if (!sgn(W[w0].se)) w0++;\n        ll -= d;\n    }\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n// 4 5\n// 2 3\n\n// 0 > 0\n\nvoid gao(){\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l)); w0 = 0;\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        \n        DB r = l;\n        while (W.size() > w0 && W.rbegin()->fi > V){\n            r += W.rbegin()->se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n//            cout << V << \" \" << r << endl;\n            W.push_back(MP(V, r));\n        }\n        \n        \n       // cout << W.size() << \" \";\n        \n        \n        OT(V);\n        \n        //int p = lower_bound(W.begin() + w0, W.end(), V) - W.begin();\n        //DB ss = p > w0 ? S[p-1]-s0 : 0;\n        \n    }\n}\nint main(){\n    \n\n    RD(n, L);\n    gao();\n    /*REP(i, n){\n        LL t, v; RD(v, t);\n        if (i){\n            DB tt = t, ll = L;\n            \n            while (sgn(tt)){\n                pair<DB, DB> z = Q.top(); Q.pop();\n                DB d = min(tt, z.se);\n                \n                cout << z.fi << \" \" << z.se << endl;\n                \n                // ((ll-d)*vv' + d*z.fi) / ll = vv\n                \n                vv = ((vv*ll) - d*-z.fi) / (ll-d);\n\n                \n                tt -= d, z.se -= d;\n                if (sgn(z.se)){\n                    Q.push(MP(z.fi, z.se));\n                }\n                ll -= d;\n            }\n            vv = ((L-t)*vv + t*v) / L;\n        }\n        else{\n            vv = v;\n        }\n        Q.push(MP(-v, t));\n        OT(vv);\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[2000005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(num,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/(long double)l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<deque>\nusing namespace std;\ntypedef pair<double, double>pdd;\ndouble eps = 1e-10;\nbool ccw(pdd a, pdd b, pdd c)\n{\n\treturn 0 <= (b.first - a.first)*(c.second - a.second) - (b.second - a.second)*(c.first - a.first);\n}\nint main()\n{\n\tint num;\n\tdouble gen;\n\tscanf(\"%d%lf\", &num, &gen);\n\tdeque<pdd>now;\n\tnow.push_back(make_pair(0, 0));\n\tnow.push_back(make_pair(gen, 0));\n\tdouble sum = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tdouble za, zb;\n\t\tscanf(\"%lf%lf\", &za, &zb);\n\t\tpdd z = make_pair(now[0].first - zb, now[0].second - za*zb);\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now[now.size()-2].first < z.first + gen + eps)\n\t\t\t{\n\t\t\t\tpdd a = now[now.size() - 2], b = now[now.size() - 1];\n\t\t\t\tnow.pop_back();\n\t\t\t\tdouble s = z.first + gen - a.first, t = b.first - (z.first + gen);\n\t\t\t\tnow.push_back(make_pair((t*a.first + s*b.first) / (s + t), (t*a.second + s*b.second) / (s + t)));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now.pop_back();\n\t\t}\n\t\tprintf(\"%.20lf\\n\", (now[now.size() - 1].second - z.second) / gen);\n\t\tfor (;;)\n\t\t{\n\t\t\tif (now.size() <= 1)break;\n\t\t\tpdd a = now[0], b = now[1];\n\t\t\tif (ccw(z, a, b))now.pop_front();\n\t\t\telse break;\n\t\t}\n\t\tnow.push_front(z);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ndeque<pair<double, int> > q;\n\nint n, L;\n\nint main(void) {\n  scanf(\"%d%d\", &n, &L);\n  double Ans = 0, t;\n  for(int i = 1, v; i <= n; i++) {\n    scanf(\"%lf%d\", &t, &v);\n    int res = v;\n    while(!q.empty()) {\n      pair<double, int> x = q.front(); q.pop_front();\n      if(x.second > res) {\n\tx.second -= res;\n\tAns -= x.first * res;\n\tq.push_front(x);\n\tbreak;\n      } else {\n\tAns -= x.second * x.first;\n\tres -= x.second;\n      }\n    }\n\n    Ans += t * v;\n    printf(\"%.10f\\n\", Ans / L);\n    \n    while((!q.empty()) && (q.back().first >= t)) {\n      pair<double, int> x = q.back(); q.pop_back();\n      t = (v * t + x.first * x.second) / (v + x.second);\n      v += x.second;\n    }\n    q.push_back(make_pair(t, v));\n  }\n}\n\t   \n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n;\n\tll L;\n\tcin>>n>>L;\n\tlong double ans;\n\tdeque<pair<long double,int>> q;\n\t{\n\t\tlong double t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tcout<<t<<endl;\n\t\tans = t*v;\n\t\tq.push_back(mkp(t,v));\n\t}\n\trep(i,1,n){\n\t\tlong double t;\n\t\tint v;\n\t\tcin>>t>>v;\n\t\tint tv = v;\n\t\twhile(1){\n\t\t\tauto x = q.back();\n\t\t\tif(tv == x.se){\n\t\t\t\tans -= x.fi * x.se;\n\t\t\t\tq.pop_back();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if(tv < x.se){\n\t\t\t\tans -= x.fi * tv;\n\t\t\t\tq.back().se -= tv;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans -= x.fi * x.se;\n\t\t\t\tq.pop_back();\n\t\t\t}\n\t\t}\n\t\tans += t*v;\n\t\tcout<<ans/L<<endl;\n\t\twhile(1){\n\t\t\tif(q.size()==0){\n\t\t\t\tq.push_front(mkp(t,v));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto x = q.front();\n\t\t\tif(t <= x.fi){\n\t\t\t\tt = (t*v + x.fi*x.se)/(v+x.se);\n\t\t\t\tv += x.se;\n\t\t\t\tq.pop_front();\n\t\t\t}\n\t\t\telse{\n\t\t\t\tq.push_front(mkp(t,v));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// cout<<\"hoge \"<<endl;\n\t\t// for(auto x: q){\n\t\t// \tcout<<x.fi<<\" \"<<x.se<<endl;\n\t\t// }\n\t\t// cout<<endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long lli;\nusing namespace std;\nstruct Water{\n\tlli v;\n\tdouble t;\n}w[500010];\nlli maxv,n,sumv,t,v,l=1,r;\ndouble s;\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&maxv);\n\twhile(n--){\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\tif(sumv+v>maxv){\n\t\t\tlli out=min(w[l].v,sumv+v-maxv);\n\t\t\tw[l].v-=out;\n\t\t\tsumv-=out;\n\t\t\ts-=1.0*w[l].t*out;\n\t\t\tif(!w[l].v) l++;\n\t\t}\n\t\tw[++r].t=1.0*t,w[r].v=v;\n\t\ts+=t*v;\n\t\tsumv+=v;\n\t\twhile(l<r&&w[r-1].t>w[r].t){\n\t\t\tw[--r].t=1.0*(w[r].t*w[r].v+w[r+1].t*w[r+1].v)/(w[r].v+w[r+1].v);\n\t\t\tw[r].v+=w[r+1].v;\n\t\t}\n\t\tprintf(\"%.7f\\n\",1.0*s/maxv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long double ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = 1e+14;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nld t[1 << 19], v[1 << 19];\n\nvector<ld> ans;\n\nstruct SegT {\nprivate:\n\tint sz;\n\tvector<ll> node;\n\tvector<ll> subnode;\n\tconst ll init_c = 0;\npublic:\n\tSegT(int n) {\n\t\tsz = 1;\n\t\twhile (sz < n)sz *= 2;\n\t\tnode.resize(2 * sz - 1, init_c);\n\t\tsubnode.resize(2 * sz - 1, init_c);\n\t}\n\tll f(ll a, ll b) {\n\t\treturn max(a, b);\n\t}\n\tvoid update(int k, ll a,ll sa) {\n\t\tk += sz - 1;\n\t\tnode[k] = a; subnode[k] = sa;\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tnode[k] = f(node[k * 2 + 1], node[k * 2 + 2]);\n\t\t\tsubnode[k] = f(subnode[k * 2 + 1], subnode[k * 2 + 2]);\n\t\t}\n\t}\n\tll query(int a, int b, int k = 0, int l = 0, int r = -1) {\n\t\tif (r < 0)r = sz;\n\t\tif (r <= a || b <= l)return init_c;\n\t\telse if (a <= l && r <= b)return node[k];\n\t\telse {\n\t\t\tll vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tll vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn f(vl, vr);\n\t\t}\n\t}\n\tll sum(ll r) {\n\t\tll ret = 0;\n\t\tint k = 0;\n\t\twhile (k < sz - 1) {\n\t\t\tll s = node[2 * k + 2];\n\t\t\tif (r >= s) {\n\t\t\t\tret += subnode[2 * k + 2];\n\t\t\t\tr -= s;\n\t\t\t\tk = 2 * k + 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk = 2 * k + 2;\n\t\t\t}\n\t\t}\n\t\tret += subnode[k]*r / node[k];\n\t\treturn ret;\n\t}\n};\n\nvoid solve() {\n\tint n; ll l;\n\tcin >> n >> l;\n\trep(i, n) {\n\t\tcin >> t[i] >> v[i];\n\t}\n\tll a = t[0]*v[0], b = v[0];\n\tans.push_back(a/l);\n\tSegT st(n + 1);\n\tint cur = 0;\n\n\trep1(i, n - 1) {\n\t\tif (a/b >= t[i]) {\n\t\t\tif (b + v[i] > l) {\n\t\t\t\tll r = l - v[i];\n\t\t\t\ta = a * r / b + t[i] * v[i];\n\t\t\t\t//cout << a << \" ??\" << endl;\n\t\t\t\tb = l;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta += t[i] * v[i];\n\t\t\t\tb += v[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tst.update(cur, b, a); cur++;\n\t\t\ta = t[i]*v[i]; b = v[i];\n\t\t}\n\t\t//cout << b << endl;\n\t\tif (b == l) {\n\t\t\tans.push_back(a / l);\n\t\t}\n\t\telse {\n\t\t\tll r = l - b;\n\t\t\tll s = a + st.sum(r);\n\t\t\t//cout << st.sum(r)<<\"??\" << endl;\n\t\t\tans.push_back(s / l);\n\t\t}\n\t\t\n\t}\n\trep(i, n) {\n\t\tcout << ans[i] << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(7);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n\nstd::deque <std::pair <int, double>> dq;\n\nint n, l;\n\nint main(){\n\tscanf(\"%d%d\", &n, &l);\n\tdouble sum = 0;\n\tfor (int i = 0, v, t; i < n; ++ i){\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tint now = l;\n\t\twhile (dq.size() && now - dq.back().first + v >= l){\n\t\t\tnow -= dq.back().first;\n\t\t\tsum -= dq.back().second;\n\t\t\tdq.pop_back();\n\t\t}\n\t\tif (!dq.size()){\n\t\t\tdq.push_front({v, 1ll * t * v});\n\t\t\tsum = 1ll * t * v;\n\t\t\tprintf(\"%.10lf\\n\", 1.0 * t);\n\t\t\tcontinue;\n\t\t}\n\t\tint x = dq.back().first;\n\t\tdouble y = dq.back().second;\n\t\tstd::pair <int, double> p = {l - v - now + x, y / x * (l - v) + y - y * now / x};\n\t\tsum += p.second - y + 1ll * t * v;\n\t\tdq.pop_back();\n\t\tdq.push_back(p);\n\t\tprintf(\"%.10lf\\n\", sum / l);\n\t\tp = {v, 1ll * t * v};\n\t\twhile (dq.size() && p.first * dq.front().second >= p.second * dq.front().first){\n\t\t\tp = {p.first + dq.front().first, p.second + dq.front().second};\n\t\t\tdq.pop_front();\n\t\t}\n\t\tdq.push_front(p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#define maxn 500010\nusing namespace std;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint n,L; \nstruct P{\n    double v,t;\n}a[maxn],q[maxn];\ndouble S,V;\nint l=1,r=0;\nint main()\n{\n    n=read();L=read();\n    for(int i=1;i<=n;i++)\n    {\n        a[i].t=read();a[i].v=read();\n        V+=a[i].v;S+=a[i].v*a[i].t;\n        while(V>L&&l<=r)\n        {\n            if(q[l].v<=V-L)\n            {\n                V-=q[l].v;S-=q[l].v*q[l].t;\n                l++;\n            }\n            else{\n                q[l].v-=V-L;\n                S-=(V-L)*q[l].t;V=L;\n                break;\n            }\n        }\n        q[++r]=a[i];\n        printf(\"%.7lf\\n\",S/L);\n        while(l<r)\n        {\n            if(q[r].t>q[r-1].t)  break;\n            q[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v+q[r].v);\n            q[r-1].v+=q[r].v;\n            r--;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n \ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n \nconst int N = 500005;\nconst double eps = 1e-8;\n \nint n,head=0,tail=0;\ndouble L,q[N][2];\n \nint main() {\n \n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t\t//printf(\"%d %.6lf %.0lf\\n\",l,sum,now);\n\t\tif(now==m)ans[i]=sum/m;\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tdouble tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct W{double v,t;W(double _v=0,double _t=0):v(_v),t(_t){}}a[N],q[N];\ninline bool operator <(W x,W y){return x.t<y.t;}\ninline W operator +(W x,W y){return W(x.v+y.v,(x.t*x.v+y.t*y.v)/(x.v+y.v));}\nint main()\n{\tint n,L,h=1,t=0; double sum1=0,sum2=0; cin>>n>>L;\n\tfor(rint i=1;i<=n;i++) scanf(\"%lf%lf\",&a[i].t,&a[i].v);\n\tfor(rint i=1;i<=n;i++)\n\t{\tfor(;sum2+a[i].v>L;h++)\n\t\t{\tif(sum2-q[h].v+a[i].v<L)\n\t\t\t{q[h].v-=sum2+a[i].v-L,sum1-=q[h].t*(sum2+a[i].v-L),sum2-=sum2+a[i].v-L;break;}\n\t\t\telse sum1-=q[h].v*q[h].t,sum2-=q[h].v;\n\t\t}\n\t\tq[++t]=a[i]; sum1+=a[i].v*a[i].t; sum2+=a[i].v;\n\t\tfor(;t-1>=h;t--)\n\t\tif(q[t].t>q[t-1].t) break; else q[t-1]=q[t-1]+q[t];\n\t\tprintf(\"%.10lf\\n\",sum1/sum2);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define infll 1000000000000000000LL\nusing namespace std;\n\nlong long sum[500001];\nlong long gopsum[500001];\nint overflw[500001];\nint dam[500001][2];\ndouble ans[500001];\nset< pair<double, int> > stat;\n\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d %d\",&dam[i][0],&dam[i][1]);\n\t\tsum[i] = sum[i-1] + dam[i][1];\n\t\tlong long cal = dam[i][0]; cal *= dam[i][1];\n\t\tgopsum[i] = gopsum[i-1] + cal;\n        if(gopsum[i] >= infll){\n\t        overflw[i] = overflw[i-1]+1;\n\t        gopsum[i] -= infll;\n        }else{\n        \toverflw[i] = overflw[i-1];\n        }\n\t\tif(i==1){\n\t\t\tans[1] = dam[i][0];\n\t\t\tstat.insert(make_pair(ans[1], 1));\n\t\t}else{\n\t\t\tauto iit = stat.begin();\n\t\t\tauto nxt = stat.begin();\n\t\t\twhile(true){\n\t\t\t\tnxt = iit; nxt++;\n\t\t\t\tif(sum[i] - sum[(*iit).second] > l){\n\t\t\t\t\tstat.erase(iit);\n\t\t\t\t\tiit = nxt;\n\t\t\t\t}else{\n\t\t\t\t\tdouble cal2 = gopsum[i] - gopsum[(*iit).second];\n\t\t\t\t\tans[i] = (double) cal2 / (double) l;\n\t\t\t\t\t//printf(\"%.6lf %lld %lld\\n\",ans[i], gopsum[i], gopsum[(*iit).second]);\n\t\t\t\t\tans[i] += (l - (sum[i] - sum[(*iit).second])) * ans[(*iit).second] / (double)l;\n\t\t\t\t\t//printf(\"%.6lf %lld %lld\\n\",ans[i], gopsum[i], gopsum[(*iit).second]);\n                    ans[i] += (double)(infll) / (double)l * (overflw[i]-overflw[(*iit).second]);\n\t\t\t\t\t//printf(\"%.6lf\\n\",ans[i]);\n\t\t\t\t\tstat.insert(make_pair(ans[i], i));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tprintf(\"%.6lf\\n\", ans[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 500010\nusing namespace std;\n\nconst double eps=1e-5;\n\nint n;\nint g[MAXN];\ndouble f[MAXN];\ndouble v[MAXN],a[MAXN],s[MAXN],V;\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%lf\",&n,&V);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf%lf\",a+i,v+i);\n\t\ts[i]=s[i-1]+a[i]*v[i];\n\t\tv[i]+=v[i-1];\n\t}\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=0;\n\t\tfor(int j=i-1;j>=0;j--)\n\t\t\tif(v[i]-v[j]<V+eps){\n\t\t\t\tdouble temp=(f[j]*(V-v[i]+v[j])+s[i]-s[j])/V;\n\t\t\t\tif(temp>f[i]){\n\t\t\t\t\tf[i]=temp;\n\t\t\t\t\tg[i]=j;\n\t\t\t\t}\n\t\t\t}else break;\n\t\tprintf(\"%.10lf\\n\",f[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=Getchar();\n    for(;!isdigit(c);c=Getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=Getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\nconst int maxn=500010;\nint n,l=1,r,cur,lim,x[maxn];\ndouble ans,y[maxn];\nint main() {\n\tn=read();lim=read();\n\trep(i,1,n) {\n\t\tint t=read(),v=read();\n\t\twhile(cur+v>lim) {\n\t\t\tif(cur+v-x[l]>=lim) cur-=x[l],ans-=y[l++];\n\t\t\telse {\n\t\t\t\tint tmp=cur+v-lim;double r=y[l]/x[l];\n\t\t\t\tx[l]-=tmp,cur-=tmp;\n\t\t\t\ty[l]-=r*tmp;ans-=r*tmp;\n\t\t\t}\n\t\t}\n\t\tcur+=v;ans+=(ll)v*t;\n\t\tprintf(\"%.7lf\\n\",ans/cur);\n\t\tr++;x[r]=v;y[r]=(ll)v*t;\n\t\twhile(l<r&&y[r]*x[r-1]<y[r-1]*x[r]) x[r-1]+=x[r],y[r-1]+=y[r],r--;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\ntypedef long long ll;\ntypedef double db;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\nconst int N=1e6+5,mo=998244353;\nstruct rec\n{\n    ll v;\n    db t;\n}s[N];\nll sum,t[N],v[N],l,r,n,L,prod,i,dec;\nint main()\n{\n    scanf(\"%lld %lld\",&n,&L);\n    l=1;\n    r=0;\n    fo(i,1,n)\n    {\n\t        scanf(\"%lld %lld\",t+i,v+i);\n        while (sum+v[i]>L)\n        {\n            dec=min(s[l].v,sum+v[i]-L);\n            s[l].v-=dec;\n            sum-=dec;\n            prod-=dec*s[l].t;\n            if (!s[l].v) l++;\n        }\n        s[++r]={v[i],t[i]};\n        prod+=v[i]*t[i];\n        sum+=v[i];\n        while (l<r&&s[r].t<s[r-1].t)\n        {\n            s[r-1].t=(s[r-1].t*s[r-1].v+s[r].t*s[r].v)/(s[r-1].v+s[r].v);\n            s[r-1].v+=s[r].v;\n            r--;\n        }\n        printf(\"%lf\\n\",(db)prod/L);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<int,int>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tdouble val=as[j].first;\n\t\t\tdouble l=as[j].second;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdouble val=v[i].first;\n\t\tdouble l=v[i].second;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tint n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=101;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tint val=0,l=0;\n\t\t\tfor(int i=vcnt-100;i<vcnt){\n\t\t\t\tval+=v[i].first;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tdouble val=v[z].first;\n\t\t\tdouble ls=v[z].second;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={remv+0.5,lbs+0.5+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({a*b+0.5,b+0.5});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,double> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n, l;\n\tcin>>n>>l;\n\tdeque<P> q;\n\tdouble s = 0;\n\tcout.precision(20);\n\trep(i, n){\n\t\tll t, v;\n\t\tcin>>t>>v;\n\t\ts += v*t;\n\t\tif(i){\n\t\t\tll e = v;\n\t\t\twhile(e>0){\n\t\t\t\tP p = q.front(); q.pop_front();\n\t\t\t\tll d = min(e, p.fst);\n\t\t\t\te -= d;\n\t\t\t\tp.fst -= d;\n\t\t\t\ts -= d*p.snd;\n\t\t\t\tif(p.fst>0) q.push_front(p);\n\t\t\t}\n\t\t}\n\t\tif(!q.empty()){\n\t\t\tP p = q.back();\n\t\t\tif(p.snd>=t){\n\t\t\t\tq.pop_back();\n\t\t\t\tll v2 = v+p.fst;\n\t\t\t\tdouble t2 = (v*t+p.fst*p.snd)/v2;\n\t\t\t\tq.push_back(P(v2, t2));\n\t\t\t} else q.push_back(P(v, t));\n\t\t} else q.push_back(P(v, t));\n\t\tcout<<s/l<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n \nconst int maxn=5e5+10;\n \nint n,L,H,T;\n \nstruct Point{\n\tLL x;\n\tdouble y;\n\tPoint() {}\n\tPoint(LL x,double y):x(x),y(y) {}\n\tPoint operator + (const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator - (const Point &p) const {return Point(x-p.x,y-p.y);}\n};\n \ndouble Cross(Point A,Point B) {return A.x*B.y-A.y*B.x;}\n \nPoint P[maxn];\n \nPoint GetPoint(Point A,Point B,LL x)\n{\n\tdouble t=((double)x-A.x)/(B.x-A.x);\n\treturn Point(x,A.y+t*(B.y-A.y));\n}\n \nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tH=T=1;\n\tP[1]=Point(0,0);\n\twhile (n--)\n\t{\n\t\tPoint p;\n\t\tscanf(\"%lf%lld\",&p.y,&p.x);\n\t\tp.y*=p.x;\n\t\tT++;\n\t\tP[T]=P[T-1]-p;\n\t\twhile (H!=T&&P[H+1].x-P[T].x>=L) H++;\n\t\tif (P[H].x-P[T].x>L)\n\t\t{\n\t\t\tP[H]=GetPoint(P[H],P[H+1],P[T].x+L);\n\t\twhile (H+1<T&&Cross(P[T-1]-P[T],P[T-2]-P[T])>=0) P[T-1]=P[T],T--;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",((double)P[H].y-P[T].y)/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\ndouble sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t    ans[i]=sum/m;\n\t\twhile(l<r&&q[r].a<q[r-1].a){\n\t\t\tdouble tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*q[r-1].b)/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.7lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint t,v;\n\tscanf(\"%d%d%d%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%d%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\tint y = min(L-v,x);\n\t\t\td = water(d,y,t,v);\n\t\t\tx = y + v;\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=500100;\ntypedef long long ll;\ntypedef long double ld;\n\nll sumx,x[N],L;\nld sumy,y[N],k[N];\nint n,q[N];\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n>>L;cout<<fixed<<setprecision(10);\n\tint t=1,w=0;\n\tfor(int i=1;i<=n;++i){\n\t\tll a,b;cin>>a>>b;\n\t\tfor(;t<=w&&sumx+b>=L+x[q[t]];++t){sumx-=x[q[t]];sumy-=y[q[t]];}\n\t\tif(t<=w&&sumx+b>L){\n\t\t\tx[q[t]]-=sumx+b-L;sumy-=y[q[t]];\n\t\t\ty[q[t]]=k[q[t]]*x[q[t]];sumy+=y[q[t]];\n\t\t\tsumx=L-b;\n\t\t}\n\t\tx[i]=b;k[i]=a;y[i]=x[i]*k[i];\n\t\tsumx=L;sumy+=y[i];q[++w]=i;\n\t\tfor(;t<w&&k[q[w]]<k[q[w-1]];--w){\n\t\t\tx[q[w-1]]+=x[q[w]];y[q[w-1]]+=y[q[w]];\n\t\t\tk[q[w-1]]=y[q[w-1]]/x[q[w-1]];\n\t\t}\n\t\tcout<<sumy/sumx<<'\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n   \ninline int read() {\n\tint x=0,f=1; char ch=getchar();\n\twhile (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n\treturn x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n                                                                \nint main() {\n\t\n\t#ifndef ONLINE_JUDGE\n\t\tfreopen(\"data.in\",\"r\",stdin);\n\t\tfreopen(\"data.out\",\"w\",stdout);\n\t#endif\n\t\n\tn=read(); L=read();\n\tdouble S=0,V=0;\n\trep(i,1,n) {\n\t\tint t=read(),v=read();\n\t\tV+=v; S+=(double)t*v;\n\t\twhile (V>L&&head<tail) {\n\t\t\tif (V-L>=q[head][0]) {\n\t\t\t\tV-=q[head][0]; S-=q[head][0]*q[head][1];\n\t\t\t\thead++;\n\t\t\t} else {\n\t\t\t\tq[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tq[tail][0]=v; q[tail++][1]=t;\n\t\tprintf(\"%lf\\n\",S/L);\n\t\twhile (tail-head>=2) {\n\t\t\tif (q[tail-1][1]>q[tail-2][1]) break;\n\t\t\tq[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n\t\t\tq[tail-2][0]+=q[tail-1][0];\n\t\t\ttail--;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int ll\n#define t first\n#define v second\n#define wrap make_pair\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef pair<db,int> pint;\ntypedef const pint& cpr;\nconst int siz=5e5+1;\n\nint n,L;\nll Vsum;\ndb Esum;\npint a[siz];\ndeque<pint> q;\n\ninline\ndb mix(cpr a,cpr b){return (a.t*a.v+b.t*b.v)/(a.v+b.v);}\n\nsigned main()\n{\n#ifdef DEBUG\n\tfreopen(\"AT2402.in\",\"r\",stdin);\n#endif\n\tscanf(\"%lld%lld\",&n,&L);\n\tfor(int i=1,y;i<=n;i++){\n\t\tdb x;\n\t\tscanf(\"%lf%lld\",&x,&y);\n\t\ta[i]=wrap(x,y);\n\t\twhile(a[i].v+Vsum>L){\n\t\t\tpint now=q.front();\n\t\t\tq.pop_front();\n\t\t\tint pour=min(a[i].v+Vsum-L,(ll)now.v);\n\t\t\tVsum-=pour;\n\t\t\tEsum-=pour*now.t;\n\t\t\tnow=wrap(now.t,now.v-pour);\n\t\t\tif(now.v!=0)\n\t\t\t\tq.push_front(now);\n\t\t}\n\t\tif(!q.empty()&&q.back().t>a[i].t){\n\t\t\tpint b=q.back();\n\t\t\tq.pop_back();\n\t\t\tq.push_back(wrap(mix(b,a[i]),b.v+a[i].v));\n\t\t}\n\t\telse\n\t\t\tq.push_back(a[i]);\n\t\tEsum+=a[i].t*a[i].v;\n\t\tVsum+=a[i].v;\n\t\tprintf(\"%.7f\\n\",Esum/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct data{ double v,t; }st[500005];\ndouble v,t,s;\nint n,w,L;\ninline int gi(){\n  int x=0,q=1; char ch=getchar();\n  while ((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n  if (ch=='-') q=-1,ch=getchar();\n  while (ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return q*x;\n}\nint main(){\n  n=gi(),L=gi();\n  for (int i=1,l=1,r=0,p;i<=n;++i){\n    t=gi(),p=v=gi(),s+=v*t,L-=v;\n    while (w>L){\n      if (w-st[l].v>=L) s-=st[l].t*st[l].v,w-=st[l++].v;\n      else s+=st[l].t*(L-w),st[l].v+=L-w,w=L;\n    }\n    while (l<=r && t<st[r].t)\n      t=(t*v+st[r].t*st[r].v)/(v+st[r].v),v+=st[r--].v;\n    st[++r]=(data){v,t},w=(L+=p),printf(\"%0.7lf\\n\",s/L);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n    while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n    return x*f;\n}\nconst int N=5e5+10;\nint n,l,v[N],t[N];\nstruct node{\n\tint v;\n\tdouble t;\n}q[N];\nint L=1,R=0,sum=0;\ndouble ans=0;\nsigned main(){\n\tn=read(),l=read();\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(sum+v[i]>l){\n\t\t\tint p=min(sum+v[i]-l,q[L].v);\n\t\t\tsum-=p;\n\t\t\tq[L].v-=p;\n\t\t\tans-=p*q[L].t;\n\t\t\tif(q[L].v<=0)L++;\n\t\t}\n\t\tq[++R]=(node){v[i],t[i]};\n\t\tsum+=v[i];ans+=v[i]*t[i];\n\t\twhile(L<R&&q[R].t<q[R-1].t){\n\t\t\tq[R-1].t=(q[R].t*q[R].v+q[R-1].t*q[R-1].v)/(q[R].v+q[R-1].v);\n\t\t\tq[R-1].v+=q[R].v;\n\t\t\tR--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",ans/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp(a, b) make_pair(a, b)\ntypedef pair<int, long double> pil;\nconst int maxn = 5e5 + 10;\nint n, L;\nlong double sv;\ndeque<pil> Q;\nint main()\n{\n\tcin >> n >> L;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tlong double t;\n\t\tdouble tin;\n\t\tint v;\n\t\tcin >> tin >> v;\n\t\tt = tin * v;\n\t\tint ret = v;\n\t\tif(i > 1)\n\t\t{\n\t\t\twhile(ret > 0)\n\t\t\t{\n\t\t\t\tif(Q.front().first <= ret)\n\t\t\t\t{\n\t\t\t\t\tret -= Q.front().first;\n\t\t\t\t\tsv -= Q.front().second;\n\t\t\t\t\tQ.pop_front();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsv -= Q.front().second * ret / Q.front().first;\n\t\t\t\t\tQ.front().second -= Q.front().second * ret / Q.front().first;\n\t\t\t\t\tQ.front().first -= ret;\n\t\t\t\t\tret -= ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsv += t;\n\t\tdouble ans = sv / L;\n\t\tprintf(\"%.7lf\\n\", ans);\n\t\twhile(!Q.empty() && Q.back().second * v >  Q.back().first * t)\n\t\t{\n\t\t\tt += Q.back().second;\n\t\t\tv += Q.back().first;\n\t\t\tQ.pop_back();\n\t\t}\n\t\tQ.push_back(mp(v, t)); \n\t}\n\treturn 0;\n}\n/*\n5 10\n1 10\n9999 5\n10000 5\n5 1\n4 1\n*/"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\nconst int N=5e5+6;\nstd::pair<double,int>q[N];\nint n,L,dlt,H,T;long long v;\ndouble all,t;\nint main(){\n\tscanf(\"%d%d%lf%d\",&n,&L,&t,&v);\n\tprintf(\"%.13f\\n\",t);\n\tq[0]=std::make_pair(t,v);\n\tall=t*v;\n\tfor(int i=2;i<=n;++i){\n\t\tscanf(\"%lf%lld\",&t,&v);\n\t\tdlt=v;\n\t\twhile(dlt)if(dlt<q[H].second)all-=q[H].first*dlt,q[H].second-=dlt,dlt=0;else\n\t\tall-=q[H].first*q[H].second,dlt-=q[H++].second;\n\t\twhile(H<=T&&t<q[T].first)all-=q[T].first*q[T].second,t=(t*v+q[T].first*q[T].second)/(v+q[T].second),v+=q[T--].second;\n\t\tq[++T]=std::make_pair(t,v);\n\t\tall+=t*v;\n\t\tprintf(\"%.13f\\n\",all/L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L; DB V;\ndeque<pair<DB, DB>> W;\n\nvoid pop(DB l){\n    while (sgn(l)){\n        DB d = min(l, W.front().se);\n        V -= d*W.front().fi;\n        l -= d; W.front().se -= d;\n        if (!sgn(W.front().se)) W.pop_front();\n    }\n}\n\nvoid push(DB v, DB l){\n    V += l*v;\n}\n\n\nint main(){\n    \n    // why WA?\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DB v, l; RD(v, l); V = v*l;\n    OT(V/L); W.PB(MP(v, l));\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l); OT(V/L);\n        while (!W.empty() && sgn(W.back().fi, v) >= 0){\n            DB _l = l; l += W.back().se;\n            v = (_l*v + W.front().fi*W.back().se) / l;\n            W.pop_back();\n        }\n        W.push_back(MP(v, l));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nint n;\nconst int maxN = 5e5 + 10;\nll t[maxN], v[maxN];\nll L;\nbool is_bad(pair < ld, ll >& f1, pair < ld, ll >& f2, pair < ld, ll >& f3) {\n    return (f2.first - f1.first) * (f3.second - f2.second) <= (f3.first - f2.first) * (f2.second - f1.second);\n}\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n >> L;\n    for (int i = 1; i <= n; i++) {\n        cin >> t[i] >> v[i];\n    }\n    deque < pair < ld, ll > > all;\n    all.emplace_back(t[1] * L, L);\n    cout.precision(8);\n    cout << fixed << t[1] << '\\n';\n    ll addY = 0;\n    ll addX = 0;\n    all.emplace_front(0, 0);\n    for (int i = 2; i <= n; i++) {\n        addX += v[i];\n        addY += v[i] * t[i];\n        while (all.size() >= 2 && all[all.size() - 2].second + addX >= L) all.pop_back();\n        while (all.size() >= 2 && all[all.size() - 2].second + addX >= L) all.pop_back();\n        ld val = addY + (all[all.size() - 2].first * (all[all.size() - 1].second + addX - L) + all[all.size() - 1].first * (L - all[all.size() - 2].second - addX)) /\n                        (all[all.size() - 1].second - all[all.size() - 2].second);\n        assert(all.back().second + addX >= L);\n        all[all.size() - 1].first = val - addY;\n        all[all.size() - 1].second = L - addX;\n        all.emplace_front(-addY, -addX);\n//        cout << \"STEP-1 \" << endl;\n//        for (auto it : all) {\n//            cout << (it.first + addY) / (it.second + addX) << \" \" << it.second + addX << endl;\n//        }\n//        cout << \"----------------\" << endl;\n        while (all.size() >= 3 && is_bad(all[0], all[1], all[2])) {\n            all[1] = all[0];\n            all.pop_front();\n        }\n\n//        cout << \"STEP0 \" << endl;\n//        for (auto it : all) {\n//            cout << (it.first + addY) / (it.second + addX) << \" \" << it.second + addX << endl;\n//        }\n//        cout << \"----------------\" << endl;\n        cout << fixed << (all.back().first + addY) / L << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#define _v first\n#define _t second\nusing namespace std;\ntypedef long long ll;\npair<ll,double> q[500010];\nint n,L,t,v;\nint l=1,r=0;\nll pour,all_water=0;double degree=0;\nint main()\n{\n    scanf(\"%d%d\",&n,&L);\n    for (int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&t,&v);\n        while (all_water+v>L)\n        {\n            pour=min(q[l]._v,all_water+v-L);\n            q[l]._v-=pour;\n            all_water-=pour;    \n            degree-=q[l]._t*pour;\n            if (!q[l]._v) l++;\n        }\n        all_water+=v;degree+=1ll*t*v;\n        q[++r]=make_pair(v,t);\n        while (l<r&&q[r]._t<q[r-1]._t)\n        {\n            q[r-1]._t=(q[r]._t*q[r]._v+q[r-1]._t*q[r-1]._v)/(q[r]._v+q[r-1]._v);\n            q[r-1]._v+=q[r]._v;r--;\n        }\n        printf(\"%.7f\\n\",degree/L);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,double> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n, l;\n\tcin>>n>>l;\n\tdeque<P> q;\n\tdouble s = 0.0;\n\tcout.precision(20);\n\trep(i, n){\n\t\tdouble t;\n\t\tll v;\n\t\tcin>>t>>v;\n\t\tif(i){\n\t\t\tll e = v;\n\t\t\twhile(e>0){\n\t\t\t\tP p = q.front(); q.pop_front();\n\t\t\t\tll d = min(e, p.fst);\n\t\t\t\te -= d;\n\t\t\t\ts -= d*p.snd;\n\t\t\t\tif(p.fst-d>0) q.push_front(P(p.fst-d, p.snd));\n\t\t\t}\n\t\t}\n\t\ts += v*t;\n\t\twhile(!q.empty() && q.back().snd>t){\n\t\t\tP p = q.back();\n\t\t\tll v2 = v+p.fst;\n\t\t\tdouble t2 = (v*t+p.fst*p.snd)/v2;\n\t\t\tv = v2;\n\t\t\tt = t2;\n\t\t\tq.pop_back();\n\t\t} \n\t\tq.push_back(P(v, t));\n\t\tcout<<s/l<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=1e5+10;\nint n,m;\ndouble sum,a[maxn],b[maxn],ans[maxn];\nstruct oo{double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\too now=(oo){a[i],b[i]};int w=r;\n\t\twhile(w>=l){\n\t\t\tif(now.b+q[w].b>=m){\n\t\t\t\tans[i]=(now.b*now.a+(m-now.b)*q[w].a)/m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnow.a=(now.a*now.b+q[w].a*q[w].b)/(now.b+q[w].b);\n\t\t\tnow.b=now.b+q[w].b;\n\t\t\tw--;\n\t\t}\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tint tot=min((int)(q[r-1].b+q[r].b),m);\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\n\nint main() {\n    int n, l; scanf(\"%d%d\", &n, &l);\n    vector<int> t(n), v(n); repeat (i, n) scanf(\"%d%d\", &t[i], &v[i]);\n    deque<pair<int, long double> > deq;\n    deq.emplace_back(v[0], t[0]);\n    long double acc = t[0] *(long double) v[0];\n    printf(\"%.12Lf\\n\", acc /(long double) l);\n    repeat_from (i, 1, n) {\n        for (int nv = v[i]; nv > 0; ) {\n            int dv = min(nv, deq.front().first);\n            nv -= dv;\n            deq.front().first -= dv;\n            acc -= deq.front().second * dv;\n            if (deq.front().first == 0) {\n                deq.pop_front();\n            }\n        }\n        int nv = v[i];\n        int nt = t[i];\n        while (not deq.empty() and deq.back().second >= nt) {\n            int pv; long double pt; tie(pv, pt) = deq.back();\n            deq.pop_back();\n            nt = (nv *(long double) nt + pv * pt) / (nv + pv);\n            nv += pv;\n        }\n        deq.emplace_back(nv, nt);\n        acc += v[i] *(long double) t[i];\n        printf(\"%.12Lf\\n\", acc /(long double) l);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// eddy1021\n#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef double D;\ntypedef long double LD;\ntypedef long long LL;\ntypedef pair<int,int> PII;\ntypedef pair<LL,LL> PLL;\n#define mod9 1000000009LL\n#define mod7 1000000007LL\n#define INF  1023456789LL\n#define INF16 10000000000000000LL\n#define eps 1e-9\n#define SZ(x) (int)(x).size()\n#define ALL(x) (x).begin(), (x).end()\n#ifndef ONLINE_JUDGE\n#define debug(...) printf(__VA_ARGS__)\n#else \n#define debug(...)\n#endif\ninline LL getint(){\n  LL _x=0,_tmp=1; char _tc=getchar();    \n  while( (_tc<'0'||_tc>'9')&&_tc!='-' ) _tc=getchar();\n  if( _tc == '-' ) _tc=getchar() , _tmp = -1;\n  while(_tc>='0'&&_tc<='9') _x*=10,_x+=(_tc-'0'),_tc=getchar();\n  return _x*_tmp;\n}\ninline LL add( LL _x , LL _y , LL _mod = mod7 ){\n  _x += _y;\n  return _x >= _mod ? _x - _mod : _x;\n}\ninline LL sub( LL _x , LL _y , LL _mod = mod7 ){\n  _x -= _y;\n  return _x < 0 ? _x + _mod : _x;\n}\ninline LL mul( LL _x , LL _y , LL _mod = mod7 ){\n  _x *= _y;\n  return _x >= _mod ? _x % _mod : _x;\n}\nLL mypow( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 1LL;\n  LL _ret = mypow( mul( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = mul( _ret , _a , _mod );\n  return _ret;\n}\nLL mymul( LL _a , LL _x , LL _mod ){\n  if( _x == 0 ) return 0LL;\n  LL _ret = mymul( add( _a , _a , _mod ) , _x >> 1 , _mod );\n  if( _x & 1 ) _ret = add( _ret , _a , _mod );\n  return _ret;\n}\ninline bool equal( D _x ,  D _y ){\n  return _x > _y - eps && _x < _y + eps;\n}\n#define Bye exit(0)\nint __ = 1 , _cs;\n/*********default*********/\n/****\n  maintain a \"concave hull\" that support the following\n  1. insertion of a line\n  2. query of height(y) on specific x on the hull\n ****/\n/* set as needed */\ntypedef long double LD;\n//const LD eps=1e-9;\nconst LD inf=1e19;\nclass Seg {\npublic:\n  LD m,c,x1,x2; // y=mx+c\n  bool flag;\n  Seg(\n    LD _m,LD _c,LD _x1=-inf,LD _x2=inf,bool _flag=0)\n    :m(_m),c(_c),x1(_x1),x2(_x2),flag(_flag) {}\n  LD evaly(LD x) const {\n    return m*x+c;\n  }\n  const bool operator<(LD x) const {\n    return x2-eps<x;\n  }\n  const bool operator<(const Seg &b) const {\n    if(flag||b.flag) return *this<b.x1;\n    return m+eps<b.m;\n  }\n};\nclass LowerConcaveHull { // maintain a hull like: \\__/\n public:\n  set<Seg> hull;\n  /* functions */\n  LD xintersection(Seg a,Seg b) {\n    return (a.c-b.c)/(b.m-a.m);\n  }\n  inline set<Seg>::iterator replace(set<Seg> &\n      thull,set<Seg>::iterator it,Seg s) {\n    thull.erase(it);\n    return thull.insert(s).first;\n  }\n  void insert(Seg s) {\n    // insert a line and update hull\n    set<Seg>::iterator it=hull.find(s);\n    // check for same slope\n    if(it!=hull.end()) {\n      if(it->c+eps>=s.c) return;\n      hull.erase(it);\n    }\n    // check if below whole hull\n    it=hull.lower_bound(s);\n    if(it!=hull.end()&&\n       s.evaly(it->x1)<=it->evaly(it->x1)+eps) return;\n    // update right hull\n    while(it!=hull.end()) {\n      LD x=xintersection(s,*it);\n      if(x>=it->x2-eps) hull.erase(it++);\n      else {\n        s.x2=x;\n        it=replace(hull,it,Seg(it->m,it->c,x,it->x2));\n        break;\n      }\n    }\n    // update left hull\n    while(it!=hull.begin()) {\n      LD x=xintersection(s,*(--it));\n      if(x<=it->x1+eps) hull.erase(it++);\n      else {\n        s.x1=x;\n        it=replace(hull,it,Seg(it->m,it->c,it->x1,x));\n        break;\n      }\n    }\n    // insert s\n    hull.insert(s);\n  }\n  void insert(LD m,LD c) { insert(Seg(m,c)); }\n  LD query(LD x) { // return y @ given x\n    if( hull.empty() ) return -1e20;\n    set<Seg>::iterator it = \n      hull.lower_bound(Seg(0.0,0.0,x,x,1));\n    return it->evaly(x);\n  }\n};\n#define N 505050\n#define L(X) (X<<1)\n#define R(X) (1+(X<<1))\n#define mid ((l+r)>>1)\nLowerConcaveHull st[ N << 2 ];\nvoid modify( int no , int l , int r , int p , double m , double c ){\n  //printf( \"m=%.7f c=%.7f\\n\" , m , c );\n  st[ no ].insert( Seg( m , c ) );\n  if( l == r ) return;\n  if( p <= mid ) modify( L( no ) , l , mid , p , m , c );\n  else modify( R( no ) , mid + 1 , r , p , m , c );\n}\ndouble query( int no , int l , int r , int ql , int qr , double cur ){\n  if( r < ql or l > qr ) return 1e20;\n  if( ql <= l and r <= qr ){\n    //printf( \"%d %d %.7f -> %.7f\\n\" , l , r , cur ,\n            //(double)st[ no ].query( cur ) );\n    return st[ no ].query( cur );\n  }\n  return min( query( L( no ) , l , mid , ql , qr , cur ) ,\n              query( R( no ) , mid + 1 , r , ql , qr , cur ) );\n}\nvoid build(){\n\n}\nLL n , l , t[ N ] , v[ N ];\ndouble sumtv[ N ] , sumv[ N ];\nvoid init(){\n  n = getint();\n  l = getint();\n  for( int i = 1 ; i <= n ; i ++ ){\n    t[ i ] = getint();\n    v[ i ] = getint();\n    sumtv[ i ] = sumtv[ i - 1 ] + t[ i ] * v[ i ];\n    sumv[ i ] = sumv[ i - 1 ] + v[ i ];\n  }\n}\ndouble ans[ N ]; \n// ans[ i ] = max( ans[ j ] * ( l - sumv[ i ] + sumv[ j ] ) / l +\n//                 sumtv[ i ] - sumtv[ j ] )\n//       = max( ans[ j ] - ans[ j ] * sumv[ i ] / l + ans[ j ] * sumv[ j ] / l\n//              + sumtv[ i ] - sumtv[ j ] );\n//       = max( ans[ j ] - ans[ j ] * sumv[ i ] / l + ans[ j ] * sumv[ j ] / l\n//              -sumtv[ j ] ) + sumtv[ i ] \nvoid solve(){\n  modify( 1 , 0 , n , 0 , 0 , 0 );\n  for( int i = 1 ; i <= n ; i ++ ){\n    int bl = 0 , br = i - 1 , ba = i - 1;\n    while( bl <= br ){\n      int bmid = ( bl + br ) >> 1;\n      if( sumv[ i ] - sumv[ bmid ] <= l )\n        ba = bmid , br = bmid - 1;\n      else\n        bl = bmid + 1;\n    }\n    //printf( \"%d %d\\n\" , ba , i - 1 );\n    double bst = -query( 1 , 0 , n , ba , i - 1 , sumv[ i ] );\n    bst += sumtv[ i ];\n    ans[ i ] = bst;\n    modify( 1 , 0 , n , i , ans[ i ] / l ,\n            -ans[ i ] - ans[ i ] * sumv[ i ] / l + sumtv[ i ] );\n  }\n  for( int i = 1 ; i <= n ; i ++ )\n    printf( \"%.9f\\n\" , ans[ i ] / l );\n}\nint main(){\n  build();\n  //__ = getint();\n  while( __ -- ){\n    init();\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define reg register\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair < ll, double > pii;\nconst int maxn = 500005;\n\ninline ll read() {\n    reg ll s = 0, t = 0; reg char ch = getchar();\n    while (!isdigit(ch)) t |= ch == '-', ch = getchar();\n    while (isdigit(ch)) s = (s << 1) + (s << 3) + (ch ^ 48), ch = getchar();\n    return t ? -s : s;\n}\n\npii q[maxn];\nint n; ll L;\nint l = 1, r = 0;\nll pourWater, remainWater;\ndouble temperature;\n\nint main() {\n    n = read(), L = read(); reg int v, t;\n    for (reg int i = 1; i <= n; i++) {\n        t = read(), v = read();\n        while (remainWater + v > L) {\n            pourWater = min(q[l].first, remainWater + v - L);\n            q[l].first -= pourWater;\n            remainWater -= pourWater;\n            temperature -= q[l].second * pourWater;\n            if (!q[l].first) l++;\n        }\n        remainWater += v, temperature += 1LL * t * v;\n        q[++r] = make_pair(v, t);\n        while (l < r && q[i].second < q[i - 1].second) {\n            q[r - 1].second = (q[r].first * q[r].second + q[r - 1].first * q[r - 1].second) / (q[r].first + q[r - 1].first);\n            q[r - 1].first += q[r].first; r--;\n        }\n        printf(\"%.7f\\n\", temperature / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=min(num + 3000ll,i);j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tld x,y;\n\tbool operator <(const point b)const{\n\t\treturn y<b.y;\n\t}\n}q[100005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){(ld)y,(ld)x};\n\t\tallt+=v.x*v.y; allv+=y;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].x*q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tq[head].x-=allv-l;\n\t\t\tallt-=(allv-l)*q[head].y;\n\t\t\tallv=l;\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.6lf\\n\",(double)allt/allv);\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y=(v.y*v.x+q[tail].x*q[tail].y)/(v.x+q[tail].x);\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <functional>\n#define fs first\n#define se second\n\nusing namespace std;\ntypedef long long llong;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<llong, llong> pll;\ntypedef pair<ld, ld> pdd;\ntypedef pair<llong, ld> pld;\n\nint n, L;\ndeque<pld> q;\nllong offx;\nld offy;\n\nint ccw(pld a, pld b, pld c) {\n    ld x1 = b.fs - a.fs, y1 = b.se - a.se;\n    ld x2 = c.fs - b.fs, y2 = c.se - b.se;\n    ld v = x1 * y2 - x2 * y1;\n    if (v < 0) return -1;\n    if (v > 0) return 1;\n    return 0;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    cout.precision(20);\n    cout << fixed;\n    cin >> n >> L;\n    q.emplace_front(0, 0);\n    while (n--) {\n        llong t, v;\n        cin >> t >> v;\n        offx += v;\n        offy += t * v;\n        llong lx;\n        ld ly;\n        while (!q.empty() && L < q.back().fs + offx) {\n            tie(lx, ly) = q.back();\n            q.pop_back();\n        }\n        if (q.back().fs + offx < L)\n            q.emplace_back(L - offx, (q.back().se * ((lx + offx) - L) + ly * (L - (q.back().fs + offx))) / (lx - q.back().fs));\n        int sz;\n        while ((sz = q.size()) > 1 && ccw(pld(-offx, -offy), q[0], q[1]) > 0)\n            q.pop_front();\n        q.emplace_front(-offx, -offy);\n        cout << (q.back().se + offy) / L << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\nusing namespace std;\nconst int N=5e5+5;\nstruct data\n{\n\tdouble t;\n\tlong long v;\n}q[N],p;\nint l=1,r=0;\ninline int read()\n{\n    int X=0,w=0; char ch=0;\n    while(!isdigit(ch)) w|=ch=='-',ch=getchar();\n    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n    return w?-X:X;\n}\nint main()\n{\n\tint n=read();\n\tlong long L=read(),L0=L;\n\tdouble now=0;\n\twhile(n--)\n\t{\n\t\tp.t=read(),p.v=read();\n\t\twhile(p.v>L)\n\t\t\tif(q[l].v+L<p.v)\n\t\t\t{\n\t\t\t\tnow-=q[l].v*q[l].t;\n\t\t\t\tL+=q[l++].v;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tnow-=p.v*q[l].t;\n\t\t\t\tL+=p.v;\n\t\t\t\tq[l].v-=p.v;\n\t\t\t}\n\t\tL-=p.v;\n\t\tnow+=p.v*p.t;\n\t\tq[++r]=p;\n\t\twhile(l<r && q[r-1].t>=q[r].t)\n\t\t{\n\t\t\tq[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v+q[r].v);\n\t\t\tq[r-1].v+=q[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",now*1.0/(L0-L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing lint = long long;\nusing plint = pair<double, lint>;\n\nint N;\nlint L;\n\narray<plint, 500000> deq;\nint s = 0;\nint t = -1;\n\ndouble Qsum = 0;\nlint Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        lint nuku = min(Vnow - L, deq[s].second);\n        deq[s].second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq[s].first;\n        if (deq[s].second == 0) s++;\n    }\n}\n\nvoid add(double tadd, lint vadd)\n{\n    if (deq[t].first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        t++; deq[t] = plint(tadd, vadd);\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq[t].second + vadd >= L)\n        {\n            Qsum = deq[t].first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            s = 0, t = -1;\n            t++; deq[t] = plint(Qsum / L, L);\n        }\n        else\n        {\n            double Qaddnew = deq[t].first * deq[t].second + tadd * vadd;\n            lint vaddnew = deq[t].second + vadd;\n            Qsum -= deq[t].first * deq[t].second;\n            Vnow -= deq[t].second;\n            t--;\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\narray<double, 500000> res;\n\nint main()\n{\n    scanf(\"%d\", &N);\n    scanf(\"%lld\", &L);\n    REP(i, N)\n    {\n        double tmp;\n        lint v;\n        scanf(\"%lf %lld\", &tmp, &v);\n\n        if (i == 0)\n        {\n            t++; deq[t] = plint(tmp, v);\n            Qsum = tmp * v;\n            Vnow = v;\n        }\n        else add(tmp, v);\n\n        res[i] = Qsum / L;\n    }\n    REP(i, N) printf(\"%.7f\\n\", res[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,long double> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(x,y) (x=min(x,y))\n#define chmax(x,y) (x=max(x,y))\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n\nint main(){\n\tll n, l;\n\tcin>>n>>l;\n\tdeque<P> q;\n\tlong double s = 0;\n\tcout.precision(20);\n\trep(i, n){\n\t\tlong double t;\n\t\tll v;\n\t\tcin>>t>>v;\n\t\ts += v*t;\n\t\tif(i){\n\t\t\tll e = v;\n\t\t\twhile(e>0){\n\t\t\t\tP p = q.front(); q.pop_front();\n\t\t\t\tll d = min(e, p.fst);\n\t\t\t\te -= d;\n\t\t\t\tp.fst -= d;\n\t\t\t\ts -= d*p.snd;\n\t\t\t\tif(p.fst>0) q.push_front(p);\n\t\t\t}\n\t\t}\n\t\tif(!q.empty()){\n\t\t\tP p = q.back();\n\t\t\tif(p.snd>=t){\n\t\t\t\tq.pop_back();\n\t\t\t\tll v2 = v+p.fst;\n\t\t\t\tlong double t2 = (v*t+p.fst*p.snd)/v2;\n\t\t\t\tq.push_back(P(v2, t2));\n\t\t\t} else q.push_back(P(v, t));\n\t\t} else q.push_back(P(v, t));\n\t\tcout<<s/l<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tld x,y;\n\tbool operator <(const point b)const{\n\t\treturn y/x<b.y/b.x;\n\t}\n}q[500005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){(ld)y,(ld)x*y};\n\t\tallt+=v.y; allv+=v.x;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tld v=q[head].y*(allv-l)/q[head].x;\n\t\t\tq[head].x-=allv-l;\n\t\t\tallv=l;\n\t\t\tq[head].y-=v;\n\t\t\tallt-=v;\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.6lf\\n\",(double)(allt/allv));\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y+=q[tail].y;\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <set>\n#include <map>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <bitset>\t\t//UWAGA - w czasie kompilacji musi byc znany rozmiar wektora - nie mozna go zmienic\n#include <cassert>\n#include <iomanip>\t\t//do setprecision\n#include <ctime>\n#include <complex>\nusing namespace std;\n\n#define FOR(i,b,e) for(int i=(b);i<(e);++i)\n#define FORQ(i,b,e) for(int i=(b);i<=(e);++i)\n#define FORD(i,b,e) for(int i=(b)-1;i>=(e);--i)\n#define REP(x, n) for(int x = 0; x < (n); ++x)\n\n#define ST first\n#define ND second\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define ULL unsigned LL\n#define LD long double\n\nconst double pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342;\n\n\nint main()\n{\n\tint N, L;\n\tlong double s = 0;\n\tscanf(\"%d%d\", &N, &L);\n\tint t, v;\n\tscanf(\"%d%d\", &t, &v);\n\tprintf(\"%d\\n\", t);\n\n\tmap<long double, pair<LL, int>> M;\n\tM[t] = MP(v, 0);\n\ts = t*(LL)v;\n\tFOR(i, 1, N)\n\t{\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tint rem = v, last = -1;\n\t\tfor (auto it = M.begin(); it != M.end() && rem;)\n\t\t{\n\t\t\tif (it->second.second < last)\n\t\t\t{\n\t\t\t\tauto it1 = it; it++;\n\t\t\t\tM.erase(it1);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (it->second.first <= rem)\n\t\t\t{\n\t\t\t\trem -= it->second.first;\n\t\t\t\ts -= it->first*it->second.first;\n\t\t\t\tlast = it->second.second;\n\t\t\t\tauto it1 = it; it++;\n\t\t\t\tM.erase(it1);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts -= it->first*rem;\n\t\t\t\tit->second.first -= rem;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ts += t*(LL)v;\n\t\tM[s / (long double)L].first = L;\n\t\tM[s / (long double)L].second = i;\n\n\t\tprintf(\"%.9LF\\n\", s / (long double)L);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define X first\n#define Y second\n#define pb push_back\ntypedef double db;\ntypedef long long ll;\ntypedef pair<ll,db> P;\nconst int MAXN=1e5+10;\ndb res=0;ll all;\nint n,L,l=0,r=-1,top;P q[MAXN];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&L);\n    for(int i=1;i<=n;i++)\n    {\n        db t;ll v;scanf(\"%lf%lld\",&t,&v);\n        while(all+v>L)\n        {\n            ll d=min(q[l].X,all+v-L);\n            q[l].X-=d;all-=d;res-=d*q[l].Y;\n            if(!q[l].X) l++;\n        }\n        all+=v;res+=v*t;\n        \n        while(l<=r&&t<q[r].Y)\n        {\n            t=(v*t+q[r].X*q[r].Y)/(v+q[r].X);\n            v+=q[r].X;r--;\n        }\n        q[++r]=P(v,t);\n        printf(\"%.6lf\\n\",res/L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <deque>\n#include <tuple>\n#include <vector>\n#define repeat(i, n) for (int i = 0; (i) < int(n); ++(i))\n#define repeat_from(i, m, n) for (int i = (m); (i) < int(n); ++(i))\nusing namespace std;\n\nint main() {\n    int n, l; scanf(\"%d%d\", &n, &l);\n    vector<int> t(n), v(n); repeat (i, n) scanf(\"%d%d\", &t[i], &v[i]);\n    deque<pair<int, long double> > deq;\n    deq.emplace_back(v[0], t[0]);\n    long double acc = t[0] *(long double) v[0];\n    printf(\"%.7Lf\\n\", acc /(long double) l);\n    repeat_from (i, 1, n) {\n        for (int nv = v[i]; nv > 0; ) {\n            int dv = min(nv, deq.front().first);\n            nv -= dv;\n            deq.front().first -= dv;\n            acc -= deq.front().second * dv;\n            if (deq.front().first == 0) {\n                deq.pop_front();\n            }\n        }\n        int nv = v[i];\n        int nt = t[i];\n        while (not deq.empty() and deq.back().second >= nt) {\n            int pv; long double pt; tie(pv, pt) = deq.back();\n            deq.pop_back();\n            nt = (nv *(long double) nt + pv * pt) / (nv + pv);\n            nv += pv;\n        }\n        deq.emplace_back(nv, nt);\n        acc += v[i] *(long double) t[i];\n        printf(\"%.7Lf\\n\", acc /(long double) l);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 500010\n#define ll long long\nusing namespace std;\nstruct data{int x; double y;}d[N];\nint n, op, cl, sum, x, sx;\ndouble y, sy;\ninline char gc(){\n\tstatic char now[1<<16], *S, *T;\n\tif(S==T){T=(S=now)+fread(now, 1, 1<<16, stdin); if(S==T)return EOF;}\n\treturn *S++;\n}\ninline int read(){\n\tint x=0, f=1; char ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=gc();}\n\treturn x*f;\n}\nint main(){\n\tn=read(); sum=read();\n\top=1; cl=0; sx=sy=0;\n\tfor(int i=1; i<=n; i++){\n\t\ty=read(); x=read();\n\t\tsx+=x; sy+=x*y;\n\t\twhile(sx>sum){\n\t\t\tif(sx-d[op].x<sum){sy-=(sx-sum)*d[op].y; d[op].x-=sx-sum; sx=sum;}\n\t\t\telse{sx-=d[op].x; sy-=d[op].x*d[op].y; op++;}\n\t\t}\n\t\tprintf(\"%.10f\\n\", sy/sum);\n\t\twhile(op<=cl&&y<d[cl].y){y=(x*y+d[cl].x*d[cl].y)/(x+d[cl].x); x+=d[cl].x; cl--;}\n\t\td[++cl].x=x; d[cl].y=y;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ld, ld> pld;\n\ndeque <pld> D;\nll n, k;\nld x, y;\n\nint main()\n{\n\tll i, t, v;\n\tld x1, x2, y1, y2;\n\t\n\tscanf(\"%lld%lld\", &n, &k);\n\t\n\tD.emplace_back(0, 0);\n\t\n\tfor(i=0; i<n; i++){\n\t\tscanf(\"%lld%lld\", &t, &v);\n\t\tx += v; y += (ld)t * v / k;\n\t\tfor(; D.size() > 1; D.pop_front()){\n\t\t\ttie(x2, y2) = D[1];\n\t\t\tif(x - k < x2) break;\n        }\n\t\t\n\t\tif(i){\n\t\t\ttie(x1, y1) = D[0]; D.pop_front();\n\t\t\ttie(x2, y2) = D[0];\n\t\t\ty1 = (y1 * (x2 - x + k) + y2 * (x - k - x1)) / (x2 - x1);\n\t\t\tx1 = x - k; D.emplace_front(x1, y1);\n\t\t\t\n\t\t\tprintf(\"%.20lf\\n\", (double)(y - y1));\n        }\n\t\telse printf(\"%.20lf\\n\", (double)y);\n\t\t\n\t\tfor(; D.size() > 1; D.pop_back()){\n\t\t\ttie(x1, y1) = D.back();\n\t\t\ttie(x2, y2) = D[D.size() - 2];\n\t\t\tif(x * y1 + x1 * y2 + x2 * y < y * x1 + y1 * x2 + y2 * x){\n\t\t\t\tbreak;\n            }\n        }\n\t\t\n\t\tD.emplace_back(x, y);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * d.cc: F: Dam\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 500000;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef long double ld;\n\n/* global variables */\n\nld tjs[MAX_N + 1];\nint vjs[MAX_N + 1];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  ll l;\n  scanf(\"%d%lld\", &n, &l);\n\n  ld tvsum = 0;\n  ll vsum = 0;\n  int j0 = 0, j1 = 0;\n\n  for (int i = 0; i < n; i++) {\n    ld ti;\n    ll vi;\n    scanf(\"%Lf%lld\", &ti, &vi);\n\n    for (ll rv = vi; j0 < j1 && rv > 0;) {\n      if (vjs[j0] <= rv) {\n\ttvsum -= tjs[j0] * vjs[j0];\n\tvsum -= vjs[j0];\n\trv -= vjs[j0];\n\tj0++;\n      }\n      else {\n\ttvsum -= tjs[j0] * rv;\n\tvsum -= rv;\n\trv = 0;\n      }\n    }\n\n    tvsum += ti * vi;\n    vsum += vi;\n\n    if (j0 >= j1 || tjs[j1 - 1] > ti) {\n      tjs[0] = tvsum / vsum, vjs[0] = vsum;\n      j0 = 0, j1 = 1;\n    }\n    else if (tjs[j1 - 1] == ti) {\n      vjs[j1 - 1] += vi;\n    }\n    else {\n      tjs[j1] = ti, vjs[j1] = vi;\n      j1++;\n    }\n\n    printf(\"%.10Lf\\n\", tvsum / l);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntemplate<class I>void gi(I&x){\n\tstatic char c;\n\tfor(c=getchar();c<'0'||c>'9';c=getchar());\n\tfor(x=0;c<='9'&&c>='0';c=getchar())x=x*10+(c&15);\n}\n\nconst int N=500005;\ntypedef long long ll;\nconst double eps=1e-10;\n\nstruct node{\n\tdouble E,V;\n\tnode(double e=0,double v=0){E=e,V=v;}\n\tdouble T(){return E/V;}\n\tinline node friend operator+(const node&a,const node&b){return node(a.E+b.E,a.V+b.V);}\n\tinline node to(double V){return node(T()*V,V);}\n};\ndeque<node> Q;\ndouble E,V;int n,L;\ninline node pop_front(){node t=Q.front();Q.pop_front();E-=t.E;V-=t.V;return t;}\ninline node pop_back(){node t=Q.back();Q.pop_back();E-=t.E;V-=t.V;return t;}\ninline void push_front(node t){E+=t.E;V+=t.V;Q.push_front(t);}\ninline void push_back(node t){E+=t.E;V+=t.V;Q.push_back(t);}\ninline void print(){printf(\"%.10lf\\n\",E/V);}\n\ninline void extend(int te,int vo){\n\tdouble K=L-vo;\n\twhile(V>K+eps){\n\t\tnode t=pop_back();\n\t\tif(V<K)push_back(t.to(K-V));\n\t}\n\tnode x=node((ll)te*vo,vo);\n\twhile(Q.size()){\n\t\tnode t=pop_front();\n\t\tif(t.T()<x.T()){push_front(t);break;}\n\t\tx=x+t;\n\t}\n\tpush_front(x);\n}\n\nint main(){\n\tgi(n),gi(L);\n\tfor(int i=1,x,y;i<=n;i++)gi(x),gi(y),extend(x,y),print();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=500005;\ntypedef pair<double,int> P;\n#define fi first\n#define se second\nint n,L;\nP Q[max_n];\nint head,tail;\nint main(){\n    scanf(\"%d%d\",&n,&L);\n    head=1,tail=0;\n    double ans=0;\n    for(int i=1;i<=n;i++){\n        double t;int v;scanf(\"%lf%d\",&t,&v);\n        int x=v;\n        while(tail>=head){\n            P& p=Q[head];\n            if(p.se<=x){\n                ans-=p.se*p.fi;\n                x-=p.se;\n                head++;\n            }\n            else{\n                p.se-=x;\n                ans-=x*p.fi;\n                x=0;\n                break;\n            }\n        }\n        ans+=v*t;\n        while(head<=tail&&Q[tail].fi>t){\n            t=(Q[tail].fi*Q[tail].se+t*v)/(v+Q[tail].se);\n            v+=Q[tail].se;\n            tail--;\n        }\n        Q[++tail]=P(t,v);\n        printf(\"%.10f\\n\",ans/L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=min(num + 500ll,i);j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[800005],righ[800005];\nlong double bai[800005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tfor(j=0;j<bainum;j++){\n\t\t\t\tif(lef[j] <= b && b <= righ[j]){\n\t\t\t\t\ttable[b] *= bai[j];\n\t\t\t\t}\n\t\t\t\tif(lef[j] == b){\n\t\t\t\t\tlef[j]++;\n\t\t\t\t}else{\n\t\t\t\t\tlef[bainum] = lef[j];\n\t\t\t\t\trigh[bainum] = b-1;\n\t\t\t\t\tbainum++;\n\t\t\t\t\tlef[j] = b+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai[bainum] = (long double)(l - y[i]) / (long double)l;\n\t\t\tlef[bainum] = num;\n\t\t\trigh[bainum] = i;\n\t\t\tbainum++;\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-8;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%lf\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = 500005;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    RD(n); RF(L); DB S=0,V=0;\n    DO(n){\n        DB t, v; RF(t), RF(v);\n        S+=(double)t*v; DB vv = v;\n        while (v && head<tail) {\n            if (v>=q[head][0]) {\n                v-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=v; S-=v*q[head][1];\n                break;\n            }\n        }\n        V = L;\n        \n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nstruct W{double v,t;W(double _v=0,double _t=0):v(_v),t(_t){}}a[N],q[N];\ninline bool operator <(W x,W y){return x.t<y.t;}\ninline W operator +(W x,W y){return W(x.v+y.v,(x.t*x.v+y.t*y.v)/(x.v+y.v));}\nint main()\n{\tint n,L,h=1,t=0; double sum1=0,sum2=0; cin>>n>>L;\n\tfor(rint i=1;i<=n;i++) scanf(\"%lf%lf\",&a[i].t,&a[i].v);\n\tfor(rint i=1;i<=n;i++)\n\t{\tq[++t]=a[i]; sum1+=a[i].v*a[i].t; sum2+=a[i].v;\n\t\tfor(;sum2>L;h++)\n\t\tif(h+1<t&&q[h].t>=q[h+1].t) q[h+1]=q[h+1]+q[h];\n\t\telse\n\t\t{\tif(sum2-q[h].v<L)\n\t\t\t{q[h].v-=sum2-L,sum1-=q[h].t*(sum2-L),sum2-=sum2-L;break;}\n\t\t\telse sum1-=q[h].v*q[h].t,sum2-=q[h].v;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",sum1/sum2);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define db double\n#define eps 1e-8\nstruct point{db x,y;};\npoint operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\npoint operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\ndb operator *(point a,point b){return a.x*b.y-b.x*a.y;}\npoint operator *(point a,db x){return (point){a.x*x,a.y*x};}\npoint operator /(point a,db x){return (point){a.x/x,a.y/x};}\nbool a_onleft(point a,point b){return a*b<-eps;}\n\ndeque<point> q;\nint n,L;\npoint o;\nint main(){\n\tscanf(\"%d%d\",&n,&L);\n\to=(point){0,0};\n\tq.push_back((point){0,0});\n\tpoint add=(point){0,0};\n\tfor(int i=1,t,v;i<=n;i++){\n\t\tscanf(\"%d%d\",&t,&v);\n\t\tpoint p=(point){v,v*1LL*t};\n\t\tadd=add+p;\n\t\t\n\t\tdb end=L-add.x;\n\t\twhile(q.size()>=2&&q[q.size()-2].x>end) q.pop_back();\n\t\tif(q[q.size()-1].x>end){\n\t\t\tint sz=q.size();\n\t\t\tpoint p=(q[sz-1]-q[sz-2])/(q[sz-1].x-q[sz-2].x)*(end-q[sz-2].x)+q[sz-2];\n\t\t\tq[sz-1]=p;\n\t\t}\n\t\t\n\t\tpoint ins=o;\n\t\twhile(q.size()>=2&&a_onleft(q[1]+add-ins,q[0]+add-ins)) q.pop_front();\n\t\tq.push_front(ins-add);\n\t\t\n\t\tpoint ans=q[q.size()-1]+add;\n\t\tprintf(\"%.10lf\\n\",ans.y/ans.x);\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Love and Freedom.\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define ll long long\n#define db double\n#define inf 20021225\n#define N 1000010\nusing namespace std;\nint read()\n{\n\tint s=0,t=1; char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')\tt=-1; ch=getchar();}\n\twhile(ch>='0' && ch<='9')\ts=s*10+ch-'0',ch=getchar();\n\treturn s*t;\n}\nstruct node{int l; db t;}w[N];\nint t[N],v[N],n,L,sum; db T;\nint main()\n{\n\tn=read(),L=read(); int l=1,r=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tt[i]=read(),v[i]=read();\n\t\twhile(sum+v[i]>L)\n\t\t{\n\t\t\tint tmp=min(w[l].l,sum+v[i]-L);\n\t\t\tsum-=tmp; T-=w[l].t*tmp; w[l].l-=tmp;\n\t\t\tif(!w[l].l)\tl++;\n\t\t}\n\t\tw[++r]=(node){v[i],(db)t[i]};\n\t\tT+=(db)v[i]*t[i]; sum+=v[i];\n\t\twhile(l<r&&w[r].t<w[r-1].t)\n\t\t{\n\t\t\tw[r-1].t=(w[r-1].l*w[r-1].t+w[r].l*w[r].t)/(w[r-1].l+w[r].l);\n\t\t\tw[r-1].l+=w[r].l; r--;\n\t\t}\n\t\tprintf(\"%lf\\n\",T/sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.01.2020 03:51:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(17);\n  int n, l;\n  cin >> n >> l;\n  vector<pair<double, double>> a;\n  double res = 0;\n  int i = 0;\n  for (int it = 0; it < n; it++) {\n    double t, v;\n    cin >> t >> v;\n    double rm = (it == 0 ? 0 : v);\n    while (i < (int) a.size()) {\n      if (rm > a[i].second) {\n        rm -= a[i].second;\n        res -= a[i].first * a[i].second;\n        ++i;\n      } else {\n        a[i].second -= rm;\n        res -= a[i].first * rm;\n        break;\n      }\n    }\n    res += t * v;\n    while (!a.empty() && a.back().first > t) {\n      t = (t * v + a.back().first * a.back().second) / (v + a.back().second);\n      v += a.back().second;\n      a.pop_back();\n    }\n    a.emplace_back(t, v);\n    cout << res / l << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing lint = long long;\nusing plint = pair<double, lint>;\n\nint N;\nlint L;\n\narray<plint, 500000> deq;\nint s = 0;\nint t = -1;\n\ndouble Qsum = 0;\nlint Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        lint nuku = min(Vnow - L, deq[s].second);\n        deq[s].second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq[s].first;\n        if (deq[s].second == 0) s++;\n    }\n}\n\nvoid add(double tadd, lint vadd)\n{\n    if (deq[t].first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        t++; deq[t] = plint(tadd, vadd);\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq[t].second + vadd >= L)\n        {\n            Qsum = deq[t].first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            s = 0, t = -1;\n            t++; deq[t] = plint(Qsum / L, L);\n        }\n        else\n        {\n            double Qaddnew = deq[t].first * deq[t].second + tadd * vadd;\n            lint vaddnew = deq[t].second + vadd;\n            Qsum -= deq[t].first * deq[t].second;\n            Vnow -= deq[t].second;\n            t--;\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\narray<double, 500000> res;\n\narray<double, 500000> temps;\narray<lint, 500000> vs;\n\nint main()\n{\n    cin >> N >> L;\n    // scanf(\"%d\", &N);\n    // scanf(\"%lld\", &L);\n    REP(i, N) cin >> temps[i] >> vs[i];\n    REP(i, N)\n    {\n        // double tmp;\n        // lint v;\n        // scanf(\"%lf %lld\", &tmp, &v);\n\n        if (i == 0)\n        {\n            t++; deq[t] = plint(temps[i], vs[i]);\n            Qsum = temps[i] * vs[i];\n            Vnow = vs[i];\n        }\n        else add(temps[i], vs[i]);\n\n        res[i] = Qsum / L;\n    }\n    REP(i, N) printf(\"%.7f\\n\", res[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0;\n    LL subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        for (int i = 1; i < (int)q.size(); ++i) {\n            int v = q[0];\n            int u = q[i];\n            if ((sumtv[u] - subtv) / (sumv[u] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                forn(_, i) q.pop_front();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || q >= (int)V.size() || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t\ts -= d * x;\n\t\t\t\tV.pop_back();\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define regsiter register\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint vol;\nlong long temp;\nstruct heap\n{\n\tint pr;\n\tint cnt;\n}h[111111];\nint tot;\nbool operator <(const heap &x,const heap &y)\n{\n\treturn x.pr>y.pr;\n}\nvoid PUSH(double pr,int cnt)\n{\n\th[++tot]=(heap){pr,cnt};\n\tstd::push_heap(h+1,h+tot+1);\n}\nvoid POP()\n{\n\tstd::pop_heap(h+1,h+tot+1);\n\t--tot;\n}\nint main()\n{\n\tint n=io::F(),L=io::F();\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tint t=io::F();\n\t\tint v=io::F();\n\t\twhile(vol+v>L)\n\t\t{\n\t\t\tif(vol+v-h[1].cnt>=L)\n\t\t\t{\n\t\t\t\tvol-=h[1].cnt;\n\t\t\t\ttemp-=h[1].cnt*h[1].pr;\n\t\t\t\tPOP();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ttemp-=(vol+v-L)*h[1].pr;\n\t\t\t\th[1].cnt-=vol+v-L;\n\t\t\t\tvol=L-v;\n\t\t\t}\n\t\t}\n\t\ttemp+=t*v;\n\t\tvol+=v;\n\t\tPUSH(t,v);\n\t\tprintf(\"%.9lf\\n\",temp/(double)L);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        ll tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            ll t=T[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first;\n               ll v1=dp[0].second;\n               ll tmp=min(vv+v-L, v1);\n               tt=tt-t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", (double)tt/vv);\n            int ans=dp.size();\n            ll c1=t*v, c2=v;\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[500005],righ[500005];\nlong double bai[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tfor(j=0;j<bainum;j++){\n\t\t\t\tif(lef[j] <= b && b <= righ[j]){\n\t\t\t\t\ttable[b] *= bai[j];\n\t\t\t\t}\n\t\t\t\tif(lef[j] == b){\n\t\t\t\t\tlef[j]++;\n\t\t\t\t}else{\n\t\t\t\t\tassert(0 == 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai[bainum] = (long double)(l - y[i]) / (long double)l;\n\t\t\tlef[bainum] = num;\n\t\t\trigh[bainum] = i;\n\t\t\tbainum++;\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double EPS=1e-8;\n\nint N,L;\n\nsigned main(){\n    cin>>N>>L;\n\n    deque<pair<double,double>>deq;\n    double T=0.0,V=0.0;\n    rep(i,N){\n        int t,v;\n        cin>>t>>v;\n\n        while(V>L-v){\n            double tmp=min(V-L+v,deq.front().se);\n            T*=V;\n            T-=deq.front().fi*tmp;\n            V-=tmp;\n            T/=V;\n            deq.front().se-=tmp;\n            if(deq.front().se<EPS)deq.pop_front();\n        }\n\n        deq.push_back({t,v});\n        tie(T,V)=pair<double,double>((T*V+t*v)/(V+v),V+v);\n        while(deq.size()>=2&&deq[deq.size()-2].fi>=deq[deq.size()-1].fi){\n            pint p=deq.back();\n            deq.pop_back();\n            pint q=deq.back();\n            deq.pop_back();\n            deq.push_back({(p.fi*p.se+q.fi*q.se)/(p.se+q.se),p.se+q.se});\n        }\n\n        printf(\"%.20f\\n\",T);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\n\nstruct Pos{\n\tld x,y;\n\tPos operator+(const Pos&rhs)const{\n\t\treturn Pos{x+rhs.x,y+rhs.y};\n\t}\n\tPos operator-(const Pos&rhs)const{\n\t\treturn Pos{x-rhs.x,y-rhs.y};\n\t}\n\tPos operator*(const ld v)const{\n\t\treturn Pos{x*v,y*v};\n\t}\n};\nld Cross(const Pos&l,const Pos&r){\n\treturn l.x*r.y-l.y*r.x;\n}\nsigned main(){\n\tint n=read(),l=read();\n\tvector<Pos> ps(n+2);\n\tps[0]=Pos{-1,0};\n\tps[1]=Pos{0,0};\n\tint i=0,j=2;\n\tREP(_,n){\n\t\tld ti=read(),v=read();\n\t\tld x=ps[j-1].x+v,y=ps[j-1].y-v*ti;\n\t\tPos w{x,y};\n\t\twhile(ps[i].x<x-l)i++;\n\t\t{\n\t\t\tld s=x-l-ps[i-1].x,t=ps[i].x-(x-l),d=ld(1)/(ps[i].x-ps[i-1].x);\n\t\t\tps[i-1]=(ps[i]*s+ps[i-1]*t)*d;\n\t\t\tprintf(\"%.10lf\\n\",double((ps[i-1].y-y)/l));\n\t\t\ti--;\n\t\t}\n\t\twhile(j-i>=2)\n\t\t\tif(Cross(w-ps[j-1],ps[j-2]-ps[j-1])>0)j--;\n\t\t\telse break;\n\t\tps[j++]=w;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  double sum = 0;\n  deque<pair<double, double>> Q;\n  for (int i = 0; i < n; ++i) {\n    double T, V;\n    scanf(\"%lf%lf\", &T, &V);\n    double rem = V;\n    while (Q.size() && rem > 0) {\n      if (Q.front().first > rem) {\n        Q.front().first -= rem;\n        sum -= rem * Q.front().second;\n        break;\n      } else {\n        rem -= Q.front().first;\n        sum -= Q.front().first * Q.front().second;\n        Q.pop_front();\n      }\n    }\n    while (Q.size() && Q.back().second > T) {\n      double V2 = Q.back().first, T2 = Q.back().second;\n      Q.pop_back();\n      sum -= V2 * T2;\n      T = (V2 * T2 + V * T) / (V2 + V);\n      V += V2;\n    }\n    Q.push_back({V, T});\n    sum += V * T;\n    printf(\"%.10f\\n\", sum / m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\n#include <random>\n#include <regex>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define reach(i,a)\tfor(auto i:a)\n#define rep(i,n)\tfor(int i=0;i<(int)n;i++)\n#define REP(i,n)\tfor(int i=0;i<=(int)n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<(int)n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=(int)n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define pb\tpush_back\n#define fst\tfirst\n#define scn second\nint bitcnt(ll x) {\n\tx = ((x & 0xAAAAAAAAAAAAAAAA) >> 1) + (x & 0x5555555555555555);\n\tx = ((x & 0xCCCCCCCCCCCCCCCC) >> 2) + (x & 0x3333333333333333);\n\tx = ((x & 0xF0F0F0F0F0F0F0F0) >> 4) + (x & 0x0F0F0F0F0F0F0F0F);\n\tx = ((x & 0xFF00FF00FF00FF00) >> 8) + (x & 0x00FF00FF00FF00FF);\n\tx = ((x & 0xFFFF0000FFFF0000) >> 16) + (x & 0x0000FFFF0000FFFF);\n\tx = ((x & 0xFFFFFFFF00000000) >> 32) + (x & 0x00000000FFFFFFFF);\n\treturn x;\n}\nint bitcnt(int x) {\n\tx = ((x & 0xAAAAAAAA) >> 1) + (x & 0x55555555);\n\tx = ((x & 0xCCCCCCCC) >> 2) + (x & 0x33333333);\n\tx = ((x & 0xF0F0F0F0) >> 4) + (x & 0x0F0F0F0F);\n\tx = ((x & 0xFF00FF00) >> 8) + (x & 0x00FF00FF);\n\tx = ((x & 0xFFFF0000) >> 16) + (x & 0x0000FFFF);\n\treturn x;\n}\nll gcd(ll a, ll b) {\n\treturn a%b == 0 ? b : gcd(b, a%b);\n}\n#define debug(x)\tcout<<\"case #\" << x << \": \" << endl\n#define DEBUG 0\nconst ll inf = 1e18;\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\n\nint main() {\n\tint n;\tll l;\tcin >> n >> l;\n\tdeque<pair<ld, ld>> dq;\n\tld fullt = 0, fullv = 0;\n\trep(i, n) {\n\t\tld t, v;\tcin >> t >> v;\n\t\twhile (!dq.empty() && dq.front().first > t) {\n\t\t\tld tv = v + dq.front().second;\n\t\t\tld tt = (t*v + dq.front().first*dq.front().second) / tv;\n\t\t\tif (tv - l > eps) {\n\t\t\t\tld use = l - v;\n\t\t\t\ttt = (t*v + dq.front().first*use) / l;\n\t\t\t\ttv = l;\n\t\t\t}\n\t\t\tfullt -= dq.front().first*dq.front().second;\n\t\t\tfullv -= dq.front().second;\n\t\t\tdq.pop_front();\tt = tt;\tv = tv;\n\t\t}\n\t\tdq.push_front(mp(t, v));\n\t\tfullt += t*v;\n\t\tfullv += v;\n\t\tld rett = fullt, retv = fullv;\n\t\twhile (retv - l > eps) {\n\t\t\tif (fullv - dq.back().second < l) {\n\t\t\t\tld remv = retv - l;\n\t\t\t\trett -= remv*dq.back().first;\n\t\t\t\tretv = l;\n\t\t\t\tpair<ld,ld> tmp = dq.back();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tpair<ld, ld> tmp = dq.back();\tdq.pop_back();\n\t\t\t\trett = fullt -= tmp.first*tmp.second;\n\t\t\t\tretv = fullv -= tmp.second;\n\t\t\t}\n\t\t}\n\t\tprintf(\"ans:%.15Lf\\n\", (ld)rett / l + eps);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define ivoid inline void\n#define iint inline int\n#define endll '\\n'\n#define ll long long\nusing namespace std;\nconst int N=5e5+5;\nconst int inf=0x3f3f3f3f;\nint n,k,top,bot;\n\niint rad()\n{\n\tint x=0,f=1;char c;\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\treturn x*f;\n}\n\nstruct Water{int v;double t;}sta[N],now;\nint sumv;\ndouble sumq;\n\nsigned main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"water.out\",\"w\",stdout);\n\tn=rad();k=rad();\n\tfor(rint i=1;i<=n;i++){\n\t\tnow.t=rad();now.v=rad();\n\t\twhile(sumv+now.v>k){\n\t\t\tint out=min(sumv+now.v-k,sta[bot].v);\n\t\t\tsta[bot].v-=out;\n\t\t\tsumv-=out;\n\t\t\tsumq-=out*sta[bot].t;\n\t\t\tif(!sta[bot].v)bot++;\n\t\t}\n\t\tsta[++top]=now;\n\t\tsumv+=now.v,sumq+=1ll*now.v*now.t;\n\t\twhile(bot<top&&sta[top].t<sta[top-1].t){\n\t\t\tsta[top-1].t=(sta[top].t*sta[top].v+sta[top-1].t*sta[top-1].v)/(sta[top].v+sta[top-1].v);\n\t\t\tsta[top-1].v=sta[top-1].v+sta[top].v;\n\t\t\ttop--;\n\t\t}\n\t\tprintf(\"%.8lf\\n\",(double)sumq/k);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\nstatic const int MAXN = 5e5 + 4;\n\nint n, l;\nint t[MAXN], v[MAXN];\n\nint qhead, qtail;\nstd::pair<double, double> q[MAXN];\nstd::pair<double, double> offset;\n\ndouble eval_linear(std::pair<double, double> p, std::pair<double, double> q, double x)\n{\n    double ratio = (x - p.first) / (q.first - p.first);\n    return p.second * (1.0 - ratio) + q.second * ratio;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &l);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &t[i], &v[i]);\n\n    qhead = MAXN - 2, qtail = MAXN;\n    q[MAXN - 2] = std::make_pair(0, 0);\n    q[MAXN - 1] = std::make_pair(v[0], (double)v[0] * t[0]);\n    offset = std::make_pair(0, 0);\n    printf(\"%.8lf\\n\", (double)t[0]);\n\n    for (int i = 1; i < n; ++i) {\n        offset.first += v[i];\n        q[qtail - 1] = std::make_pair(l - offset.first, eval_linear(q[qtail - 2], q[qtail - 1], l - offset.first));\n        offset.second += (double)v[i] * t[i];\n        while (qtail > qhead + 1 && q[qtail - 2].first + offset.first > l) --qtail;\n        int lo = qhead, hi = qtail, mid;\n        while (lo < hi - 1) {\n            mid = (lo + hi) >> 1;\n            if ((q[mid].second + offset.second) / (q[mid].first + offset.first)\n                >= (q[mid - 1].second + offset.second) / (q[mid - 1].first + offset.first)) lo = mid;\n            else hi = mid;\n        }\n        qhead = lo;\n        q[--qhead] = std::make_pair(-offset.first, -offset.second);\n        printf(\"%.8lf\\n\", (q[qtail - 1].second + offset.second) / l);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int,int>;\nusing lli = long long;\nusing ld = long double;\nusing pdd = pair<ld, ld>;\n\nconst int MAXN=500000;\nconst ld EPS=1e-10;\nint n,L,tem[MAXN],lit[MAXN];\npdd conv[MAXN+2];\n\nint ccw(pdd a,pdd b) {\n\tld val = a.fi*b.se - b.fi*a.se;\n\tif(val > EPS) return 1;\n\telse if(val < -EPS) return -1;\n\telse return 0;\n}\nint ccw(pdd p,pdd a,pdd b) {\n\treturn ccw(pdd(a.fi-p.fi,a.se-p.se), pdd(b.fi-p.fi,b.se-p.se));\n}\nint main() {\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=0;i<n;i++) scanf(\"%d%d\",tem+i,lit+i);\n\n\tint l=0,r=1;\n\tconv[0] = {-1,0}; conv[1] = {0, 0};\n\tfor(int i=0;i<n;i++) {\n\t\tld x = conv[r-1].fi + lit[i], y = conv[r-1].se + 1ll*tem[i]*lit[i];\n\t\tpdd newp(x,y);\n\t\twhile(conv[l].fi < x - L) l++;\n\t\tif(l!=0 && conv[l].fi > x-L+EPS) {\n\t\t\tld prop = (x-L - conv[l-1].fi) / (conv[l].fi - conv[l-1].fi), y = conv[l-1].se + (conv[l].se - conv[l-1].se)*prop;\n\t\t\tconv[--l] = pdd(x-L, y);\n\t\t}\n\t\tprintf(\"%.10Lf\\n\",(y - conv[l].se)/(x - conv[l].fi));\n\t\t\n\t\twhile(r-l>1 && ccw(conv[r-1], newp, conv[r-2])<=0) r--;\n\t\tconv[r++] = newp;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[800005],righ[800005];\nlong double bai[800005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tfor(j=0;j<bainum;j++){\n\t\t\t\tassert(bainum <= 800005);\n\t\t\t\tif(lef[j] <= b && b <= righ[j]){\n\t\t\t\t\ttable[b] *= bai[j];\n\t\t\t\t\tif(lef[j] == b){\n\t\t\t\t\t\tlef[j]++;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlef[bainum] = lef[j];\n\t\t\t\t\t\trigh[bainum] = b-1;\n\t\t\t\t\t\tbainum++;\n\t\t\t\t\t\tlef[j] = b+1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai[bainum] = (long double)(l - y[i]) / (long double)l;\n\t\t\tlef[bainum] = num;\n\t\t\trigh[bainum] = i;\n\t\t\tbainum++;\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int64_t, double> P;\n\nint main(){\n    int N, L;\n    cin >> N >> L;\n\n    deque<P> que;\n    double heat = 0;\n    int volume = 0;\n\n    for(int i=0; i<N; i++){\n        double t;\n        int v;\n        cin >> t >> v;\n        heat += t*v;\n        volume += v;\n\n        while(volume > L){\n            auto p = que.front();\n            if(p.second <= volume-L){\n                heat -= p.first * p.second;\n                volume -= p.second;\n                que.pop_front();\n            }else{\n                heat -= p.first * (volume-L);\n                que.front().second -= volume-L;\n                volume = L;\n            }\n        }\n\n        while(que.size() > 0){\n            auto p = que.back();\n            if(p.first < t){\n                break;\n            }else{\n                t = (p.first*p.second + t*v) / (p.second + v);\n                v += p.second;\n                que.pop_back();\n            }\n        }\n        \n        que.push_back({t, v});\n        double ans = heat / L;\n        cout << fixed << setprecision(10) << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n\n    #ifndef ONLINE_JUDGE\n        freopen(\"data.in\",\"r\",stdin);\n        freopen(\"data.out\",\"w\",stdout);\n    #endif\n\n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n \nconst int maxn=5e5+10;\n \nint n,L,H,T;\n \nstruct Point{\n\tLL x;\n\tdouble y;\n\tPoint() {}\n\tPoint(LL x,double y):x(x),y(y) {}\n\tPoint operator + (const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator - (const Point &p) const {return Point(x-p.x,y-p.y);}\n};\n \ndouble Cross(Point A,Point B) {return A.x*B.y-A.y*B.x;}\n \nPoint P[maxn];\n \nPoint GetPoint(Point A,Point B,LL x)\n{\n\tdouble t=((double)x-A.x)/(B.x-A.x);\n\treturn Point(x,A.y+t*(B.y-A.y));\n}\n \nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tH=T=1;\n\tP[1]=Point(0,0);\n\twhile (n--)\n\t{\n\t\tPoint p;\n\t\tscanf(\"%lf%lld\",&p.y,&p.x);\n\t\tp.y*=p.x;\n\t\tT++;\n\t\tP[T]=P[T-1]-p;\n\t\twhile (H!=T&&P[H+1].x-P[T].x>=L) H++;\n\t\tif (P[H].x-P[T].x>L)\n\t\t\tP[H]=GetPoint(P[H],P[H+1],P[T].x+L);\n\t\twhile (H+1<T&&Cross(P[T-1]-P[T],P[T-2]-P[T])>=0) P[T-1]=P[T],T--;\n\t\tprintf(\"%.10lf\\n\",((double)P[H].y-P[T].y)/L);\n\t}\n}\n///err"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int n, l, i;\n    double t = 0, v = 0;\n    deque <pair<double, double> > d;\n    \n    scanf(\"%d %d\", &n, &l);\n    \n    for (i = 0; i < n; i++) {\n        double tx, vx;\n        \n        scanf(\"%lf %lf\", &tx, &vx);\n        \n        if (l == vx) {\n            d.clear();\n            t = 0;\n            v = 0;\n        }\n        \n        while (v + vx > l && d.size() > 0) {\n            double t1 = d.front().first;\n            double v1 = d.front().second;\n            double v2 = min(v1, v + vx - l);\n            \n            t = (t * v - t1 * v2) / (v - v2);\n            v = v - v2;\n            \n            if (v - v1 + vx > l) {\n                d.pop_front();\n            } else {\n                d.front().second -= v2;\n                break;\n            }\n        }\n        \n        t = (t * v + tx * vx) / (v + vx);\n        v = v + vx;\n        \n        printf(\"%.12lf\\n\", t);\n        \n        while (d.size() > 0) {\n            double t1 = d.back().first;\n            double v1 = d.back().second;\n            \n            if (t1 < tx) break;\n            \n            tx = (tx * vx + t1 * v1) / (vx + v1);\n            vx = vx + v1;\n            \n            d.pop_back();\n        }\n        \n        d.push_back(make_pair(tx, vx));\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\ndouble sumsTV[500011];\ndouble sumsV[500011];\n\ndouble evalH(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + H[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\ndouble evalT(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + T[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\n\nint qu[500011];\nint *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    REP (i, N) {\n\tsumsTV[i+1] = sumsTV[i] + (double)T[i] * V[i];\n\tsumsV[i+1] = sumsV[i] + (double)V[i];\n    }\n\n    H[0] = T[0];\n    *head = 0; // {0};\n\n    int pos = 0;\n    for (int i=1; i<N; i++) {\n\twhile (sumsV[i+1] - sumsV[*head+1] >= L) head++;\n\n\tint *nxt_head = head;\n\tfor (int j=0; j<20 && j<=(tail-head); j++) {\n\t    double d = evalH(*(head+j), i);\n\t    if (H[i] <= d) {\n\t\tH[i] = d;\n\t\tnxt_head = head+j;\n\t    }\n\t}\n\thead = nxt_head;\n \n\twhile (sumsV[i+1] - sumsV[pos+1] >= L) pos++;\n\tamax(H[i], evalT(pos, i));\n\n//\twhile (head <= tail && H[*tail] <= H[i]) tail--;\n\ttail++;\n\t*tail = i;\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <ctime>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define RepG(i, x) for (int i = head[x]; i; i = edge[i].next)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double D;\nconst int N = 500010;\nstruct W{ D t; LL v;} q[N];\nD t[N];\nLL v[N];\nint main()\n{\n\tint n, l;\n\tscanf(\"%d%d\", &n, &l);\n\tRep(i, n) scanf(\"%lf%lld\", &t[i], &v[i]);\n\t\n\tint he = 1, ta = 0;\n\tLL sv = 0; D st = 0;\n\tRep(i, n) {\n\t\tq[++ ta].t = t[i], q[ta].v = v[i];\n\t\tst = (st * sv + t[i] * v[i]) / (sv + v[i]), sv += v[i];\n\t\twhile (he <= ta && sv - q[he].v >= l) {\n\t\t\tst = (st * sv - q[he].t * q[he].v) / (sv - q[he].v);\n\t\t\tsv -= q[he].v, he ++;\n\t\t}\n\t\tif (sv > l) st = (st * sv - q[he].t * (sv - l)) / l, q[he].v -= sv - l, sv = l;\n\t\tprintf(\"%.7lf\\n\", st);\n\t\t\n\t\twhile (he <= ta - 1 && q[ta - 1].t > q[ta].t) {\n\t\t\tq[ta - 1].t = (q[ta - 1].t * q[ta - 1].v + q[ta].t * q[ta].v) / (q[ta - 1].v + q[ta].v);\n\t\t\tq[ta - 1].v += q[ta].v, ta --;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<double, ll> pairDI;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nll N, L;\nvector<ll> t, v;\nvector<pairDI> A;\nvector<ll> B;\n\nint main(int argc, char *argv[])\n{\n    scanf(\"%lld%lld\", &N, &L);\n\n    t.resize(N);\n    v.resize(N);\n    A.resize(N);\n    B.resize(N);\n\n    scanf(\"%lld%lld\", &t[0], &v[0]);\n\n    A[0] = make_pair(t[0], v[0]);\n    B[0] = 0;\n    printf(\"%.7f\\n\", A[0].first);\n\n    FOR1(i,1,N) {\n        scanf(\"%lld%lld\", &t[i], &v[i]);\n        if (A[i-1].first < t[i]) {\n            A[i] = make_pair(t[i], v[i]);\n            B[i] = A[i-1].second;\n        }\n        else if (A[i-1].first == t[i]) {\n            A[i] = make_pair(t[i], min(A[i-1].second + v[i], L));\n            B[i] = 0;\n        }\n        else {\n            ll vol = min(L, A[i-1].second + v[i]);\n            double tmp = (t[i] * v[i] + A[i-1].first * (vol - v[i])) / vol;\n            for (int j = i-2; vol < L && A[j].first >= tmp; j--) {\n                tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                    / (vol + min(L-vol, B[j+1]));\n                vol += min(L-vol, B[j+1]);\n            }\n            A[i] = make_pair(tmp, vol);\n            B[i] = 0;\n        }\n\n        ll vol = A[i].second;\n        double tmp = A[i].first;\n        for (int j = i-1; vol < L; j--) {\n            tmp = (tmp * vol + A[j].first * min(L-vol, B[j+1]))\n                / (vol + min(L-vol, B[j+1]));\n            vol += min(L-vol, B[j+1]);\n        }\n\n        printf(\"%.7f\\n\", tmp);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(num,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/(long double)l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nconst double eps = 1e-8;\nstruct Element{\n    double x,y;\n};\nElement queue[500005];\nElement a[500005];\n\ndouble min(double a,double b){\n    return a>b?b:a;\n}\n\ndouble abs(double u){ return u>0?u:-u; }\n\nint main(){\n    int n; double l;\n    scanf(\"%d%lf\",&n,&l);\n    for(int i = 1; i <= n; i++){\n        double t,v;\n        scanf(\"%lf%lf\",&t,&v);\n        a[i].x = v, a[i].y = t*v;\n    }\n    int h = 1, t = 0;\n    double xSum = 0, ySum = 0;\n    for(int i = 1; i <= n; i++){\n        Element cur = a[i];\n        xSum += cur.x, ySum += cur.y;\n        while(xSum-l>eps){\n            Element& cur = queue[h];\n            double minusX = min(xSum-l,cur.x);\n            double minusY = minusX/cur.x*cur.y;\n            xSum -= minusX, cur.x -= minusX;\n            ySum -= minusY, cur.y -= minusY;\n            if(cur.x<eps) h++;\n        }\n        while(t!=0 && (cur.y/cur.x)<(queue[t].y/queue[t].x)){\n            cur.y += queue[t].y, cur.x += queue[t].x;\n            t--;\n        }\n        queue[++t] = cur;\n        printf(\"%.9f\\n\",ySum/xSum);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=5e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\",\"r\",stdin);\n\tfreopen(\"out\",\"w\",stdout);\n#endif\n}\nint n,L;\nvoid input()\n{\t\n\tn=read<int>(),L=read<int>();\n}\ndouble tmp[N],ans;\nll now,V[N];\nint l=1,r;\n#define sum(x,y) (V[y]-V[x-1])\nvoid work()\n{\n\tint t,v;\n\tll nexv,vv;\n\tFor(i,1,n)\n\t{\n\t\tt=read<int>(),v=read<int>();\n\t\ttmp[++r]=t,V[r]=V[r-1]+v;\n\t\tnow+=v;ans+=1ll*t*v;\n\t\tfor(;r>1&&tmp[r-1]>=tmp[r];r--)\n\t\t{\n\t\t\tnexv=min((ll)L,sum(r-1,r));\t\n\t\t\tvv=nexv-sum(r,r);\n\t\t\tif(r>l)ans-=tmp[r-1]*(sum(r-1,r-1)-vv);\n\t\t\t//cerr<<vv<<endl;\n\t\t\t//cerr<<tmp[r-1]<<endl;\n\t\t\t//cerr<<tmp[r]<<' '<<sum(r,r)<<' '<<vv<<endl;\n\t\t\ttmp[r-1]=(tmp[r]*sum(r,r)+tmp[r-1]*vv)/(1.0*nexv);\n\t\t\t//cerr<<tmp[r-1]<<endl;\n\t\t\tV[r-1]=nexv+V[r-2];\n\t\t}\n\t\t//For(j,1,r)printf(\"%.7lf %lld\\n\",tmp[j],V[j]-V[j-1]);\n\t\t//cerr<<r<<endl;\n\t\tcmin(l,r);\n\t\tfor(;l<r&&sum(l+1,r)>=L;l++)ans-=tmp[l]*sum(l,l);\n\t\t//cerr<<l<<' '<<r<<endl;\n\t\t//cerr<<ans<<endl;\n\t\tprintf(\"%.7lf\\n\",(ans-(sum(l,r)-L)*tmp[l])/(1.0*L));\n\t}\n}\nint main()\n{\n\n//\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define ll long long\nusing namespace std;\nconst int N=5e5+5;\nint n,m,i,h,t,qv[N];\ndouble ans;\ndouble qt[N];\nint read(){\n\tchar c=getchar();int k=0;for (;c<48||c>57;c=getchar());\n\tfor (;c>47&&c<58;c=getchar()) k=(k<<3)+(k<<1)+c-48;return k;\n}\nint main(){\n\tn=read();m=read();h=1;\n\tfor (i=1;i<=n;i++){\n\t\tdouble tem=read();int v=read(),nv=v;\n\t\tfor (;h<=t&&qv[h]<=nv;h++)\n\t\t\tans-=qv[h]*qt[h],nv-=qv[h];\n\t\tif (nv) ans-=nv*qt[h],qv[h]-=nv;\n\t\tans+=v*tem;\n\t\tfor (;h<=t&&qt[t]>tem;t--)\n\t\t\ttem=(v*tem+qv[t]*qt[t])/(v+qv[t]),v+=qv[t];\n\t\tqv[++t]=v;qt[t]=tem;\n\t\tprintf(\"%.7lf\\n\",ans/m);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tassert(bai > 1e-9);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tassert(bai > 1e-9);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(b,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#define MAXN 500010\nusing namespace std;\n\nconst double eps=1e-5;\n\nint n,sizew;\ndouble f[MAXN],g[MAXN];\ndouble v[MAXN],s[MAXN],V;\n\nbool cmp(int x,int y){\n\tif(fabs(f[x]-f[y])<eps) return g[x]<g[y];\n\treturn f[x]<f[y]; \n}\n\ndouble calcK(int x,int y){\n\treturn (g[y]-g[x])/(f[y]-f[x]);\n}\n\ndouble calc(int x,int y){\n\treturn (f[x]*(V-v[y]+v[x])+s[y]-s[x])/V;\n}\n\nstruct node{\n\tvector<int> pt0,pt;\n\n\tvoid build(int l,int r){\n\t\tfor(int i=l;i<=r;i++) pt0.push_back(i);\n\t\tsort(pt0.begin(),pt0.end(),cmp);\n\t\tint len=pt0.size();\n\t\tfor(int i=0;i<len;i++)\n\t\t\tif(i==len-1 || fabs(f[pt0[i]]-f[pt0[i+1]])>eps){\n\t\t\t\twhile(pt.size()>1 && calcK(pt[pt.size()-2],pt[pt.size()-1])<calcK(pt[pt.size()-1],pt0[i])) pt.pop_back();\n\t\t\t\tpt.push_back(pt0[i]);\n\t\t\t}\n\t}\n\n\tdouble calcMax(int x){\n\t\tif(pt.size()==1 || calcK(pt[0],pt[1])<v[x]) return calc(pt[0],x);\n\t\tint l=0,r=pt.size()-2;\n\t\twhile(l<r){\n\t\t\tint mid=(l+r+1)>>1;\n\t\t\tif(calcK(pt[mid],pt[mid+1])>v[x]) l=mid;\n\t\t\telse r=mid-1;\n\t\t}\n\t\treturn calc(pt[l+1],x);\n\t}\n}a[MAXN<<2];\n\nbool tag[MAXN<<2];\n\ndouble calcMax(int x,int l,int r,int cl,int cr,int y){\n\tif(l<=cl && cr<=r){\n\t\tif(!tag[x]){\n\t\t\ttag[x]=1;\n\t\t\ta[x].build(cl,cr);\n\t\t}\n\t\treturn a[x].calcMax(y);\n\t}\n\tint mid=(cl+cr)>>1;\n\tif(r<=mid) return calcMax(x<<1,l,r,cl,mid,y);\n\tif(l>mid) return calcMax(x<<1|1,l,r,mid+1,cr,y);\n\treturn max(calcMax(x<<1,l,r,cl,mid,y),calcMax(x<<1|1,l,r,mid+1,cr,y));\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%lf\",&n,&V);\n\tfor(sizew=1;sizew<=n;sizew<<=1);\n\tfor(int i=1;i<=n;i++){\n\t\tdouble temp;\n\t\tscanf(\"%lf%lf\",&temp,v+i);\n\t\ts[i]=s[i-1]+temp*v[i];\n\t\tv[i]+=v[i-1];\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint l=0,r=i-1;\n\t\twhile(l<r){\n\t\t\tint mid=(l+r)>>1;\n\t\t\tif(V-v[i]+v[mid]>-eps) r=mid;\n\t\t\telse l=mid+1;\n\t\t}\n\t\tf[i]=calcMax(1,l,i-1,0,sizew-1,i);\n\t\tg[i]=f[i]*V+f[i]*v[i]-s[i];\n\t\tprintf(\"%.10lf\\n\",f[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\ntypedef struct{\n\tdouble a;\n\tdouble b;\n\tint l,r;\n}eda;\n\neda node(double a,double b,int l,int r){\n\teda v;\n\tv.a=a;\n\tv.b=b;\n\tv.l=l;\n\tv.r=r;\n\treturn v;\n}\n\ndeque<eda> de;\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tint l;\n \tcin>>n>>l;\n \t\n \tdouble te;\n \tint y;\n \tcin>>te>>y;\n //\tcout<<te<<endl;\n \tprintf(\"%.10lf\\n\",te);\n \t\tde.pb(node(te,0,l,0));\n \tint hos=0;\n \tdouble cd=0;\n \tdouble ad=0;\n \tfor(int i=1;i<n;i++){\n \t\tcin>>te;\n \t\tint vo;\n \t\tcin>>vo;\n \t\thos+=vo;\n \t\twhile(de.size()>0&&de.front().r+hos>l)de.pop_front();\n \t\tde.front().l=l-hos;\n \t\tcd+=te*vo;\n \t\tad+=(double) vo;\n \t\tif(de.back().b+cd-de.back().a*ad>=0){\n \t\t\tint b=-cd+te*ad;\n \t\t\tde.pb(node(te,b,de.back().r,de.back().r-vo));\n \t\t}\n \t\telse{\n \t\t\tint k2=de.back().r-vo;\n \t\t\tint laspos;\n \t\t\tdouble val;\n \t\t\twhile(de.size()>0&&de.back().b+cd-de.back().a*ad<0){\n \t\t\t\tlaspos=de.back().l;\n \t\t\t\tval=(de.back().a*(laspos+hos)+de.back().b+cd-ad*de.front().a)/((double) (laspos+hos));\n \t\t\t\tde.pop_back();\n \t\t\t}\n \t\t\tde.pb(node(val,-cd+val*ad,laspos,k2));\n \t\t}\n \t//\tcout<<endl;\n \t//\tfor(auto it=de.begin();it!=de.end();it++){\n \t//\t\teda w=*it;\n \t//\t\tcout<<w.l+hos<<\" \"<<w.r+hos<<\" \"<<w.a<<\" \"<<w.b+cd-ad*w.a<<endl;\n \t//\t}\n \t//\tcout<<endl;\n \t\tdouble ans;\n \t\tans=(de.front().a*(l)+(de.front().b+cd-ad*de.front().a))/((double) (l));\n \t\tprintf(\"%.10lf\\n\",ans);\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define MAXN 500010\nusing namespace std;\n\nconst double eps=1e-5;\n\nint n;\ndouble f[MAXN];\ndouble v[MAXN],a[MAXN],s[MAXN],V;\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"F.in\",\"r\",stdin);\n#endif\n\tscanf(\"%d%lf\",&n,&V);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lf%lf\",a+i,v+i);\n\t\ts[i]=s[i-1]+a[i]*v[i];\n\t\tv[i]+=v[i-1];\n\t}\n\tf[0]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=0;\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(v[i]-v[j]<V+eps)\n\t\t\t\tf[i]=max(f[i],(f[j]*(V-v[i]+v[j])+s[i]-s[j])/V);\n\t\tprintf(\"%.10lf\\n\",f[i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 5005\n#define INF 16843009\n#define LL long long\n#define LD long double\n#define len(l,r) (r-l+1)\n#define P int(1e9+7)\nusing namespace std;\n \nint N,L,Q;\nLD A,B;\nLD t[MAXN], v[MAXN], dp[MAXN][MAXN];\n\nLD mix(LD v1, LD t1, LD v2, LD t2){\n\treturn (v1*t1 + v2*t2)/(v1 + v2);\n}\n\n\nint main(){\n\t\n//\tfreopen(\"4.in\", \"r\", stdin);\n//\tfreopen(\"4.out\", \"w\", stdout);\n\t\n\tcin>>N>>L;\n//\tcin>>Q;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>t[i]>>v[i];\n\t}\n\t\n\tfor(int j=0;j<=L;j++) dp[1][j] = t[1];\n\t\n\tfor(int i=2;i<=N;i++){\n\t\tfor(int j=0;j<=L;j++){\n\t\t\tfor(int k=max((LD)0,j-v[i]);k<=L-v[i];k++){\n\t\t\t\tdp[i][j] = max(dp[i][j], mix(k,dp[i-1][k],v[i],t[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=N;i++){\n\t\tprintf(\"%.6Lf\\n\", dp[i][L]);\n\t}\n\n//\tfor(int i=1;i<=Q;i++){\n//\t\tint x;\n//\t\tcin>>x;\n//\t\t\n//\t\tprintf(\"%.2lf\\n\", dp[x][L]);\n//\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ll> P;\n\nconst ld EPS = 1e-10;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tld sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tld t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\t\tsum += t * v;\n\n\t\tif (dq.empty() || dq.back().first + EPS <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(12) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double, ll> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n;\n\tll L;\n\tcin >> n >> L;\n\tdouble sum = 0;\n\tdeque<P> dq;\n\tfor (int i = 0; i < n; i++) {\n\t\tdouble t;\n\t\tll v;\n\t\tcin >> t >> v;\n\t\tsum += t * v;\n\t\tll over = v;\n\t\twhile (!dq.empty()) {\n\t\t\tll tmp = min(over, dq.front().second);\n\t\t\tsum -= dq.front().first * tmp;\n\t\t\tdq.front().second -= tmp;\n\t\t\tover -= tmp;\n\t\t\tif (dq.front().second == 0) dq.pop_front();\n\t\t\tif (over == 0) break;\n\t\t}\n\n\t\tif (dq.empty() || dq.back().first <= t) dq.push_back(P(t, v));\n\t\telse {\n\t\t\tdq.back().first = (dq.back().first * dq.back().second + t * v) / (dq.back().second + v);\n\t\t\tdq.back().second += v;\n\t\t}\n\n\t\tcout << fixed << setprecision(10) << sum / L << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mo 1000000007\n#define pi 3.1415926535898\n#define eps 1e-9 \nusing namespace std;\nlong long read(){\n    long long xx=0,flagg=1;\n    char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')\n        ch=getchar();\n    if(ch=='-'){\n        flagg=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n        xx=xx*10+ch-'0';\n        ch=getchar();\n    }\n    return xx*flagg;\n}\nvoid pus(long long xx,long long flagg){\n    if(xx<0){\n        putchar('-');\n        xx=-xx;\n    }\n    if(xx>=10)\n        pus(xx/10,0);\n    putchar(xx%10+'0');\n    if(flagg==1)\n        putchar(' ');\n    if(flagg==2)\n        putchar('\\n');\n    return;\n}\nlong long n,i,head,tail;\ndouble l,t[500005],v[500005],tt,vv,z,now;\nint main(){\n\t//freopen(\"camp.in\",\"r\",stdin);\n\t//freopen(\"camp.out\",\"w\",stdout);\n\tn=read();l=read();\n\thead=1;tail=1;\n\tt[1]=read();v[1]=read();\n\tnow=t[1]*v[1];\n\tprintf(\"%.7lf\\n\",t[1]);\n\tfor(i=2;i<=n;i++){\n\t\ttt=read();vv=read();\n\t\tz=vv;\n\t\tnow+=tt*vv;\n\t\twhile(z>eps){\n\t\t\tif(v[head]<z){\n\t\t\t\tz-=v[head];\n\t\t\t\tnow-=v[head]*t[head];\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnow-=z*t[head];\n\t\t\t\tv[head]-=z;\n\t\t\t\tz=0.0;\n\t\t\t}\n\t\t}\n\t\twhile(t[tail]>tt&&tail>=head){\n\t\t\ttt=(tt*vv+t[tail]*v[tail])/(v[tail]+vv);\n\t\t\tvv=v[tail]+vv;\n\t\t\ttail--;\n\t\t}\n\t\ttail++;\n\t\tv[tail]=vv;\n\t\tt[tail]=tt;\n\t\tprintf(\"%.7lf\\n\",now/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(ll x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(ll x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 500010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,L,bot,top;\n\ndouble tot;\n\ndouble temperature[maxn],volume[maxn];\n\nvoid Work(){\n\tREP(i,2,n){\n\t\tdouble x,y,z;\n\t\tscanf(\"%lf%lf\",&x,&y);z=y;\n\t\twhile(volume[top]<=z){\n\t\t\ttot-=temperature[top]*volume[top];\n\t\t\tz-=volume[top];\n\t\t\ttop++;\n\t\t}\n\t\ttot-=z*temperature[top];volume[top]-=z;\n\t\ttot+=x*y;\n\t\twhile(top<=bot&&temperature[bot]>x){\n\t\t\tx=(x*y+temperature[bot]*volume[bot])/(y+=volume[bot]);\n\t\t\tbot--;\n\t\t}\n\t\tbot++;\n\t\ttemperature[bot]=x;volume[bot]=y;\n\t\tprintf(\"%.10lf\\n\",(double)tot/L);\n\t}\n}\n\nvoid Init(){\n\tread(n,L); \n\tscanf(\"%lf%lf\",&temperature[1],&volume[1]);\n\ttop=bot=1;\n\ttot=temperature[1]*volume[1];\n\tprintf(\"%.10lf\\n\",temperature[1]);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\nusing namespace std; void _main(); int main(){cin.tie(0);ios::sync_with_stdio(0);_main();}\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\ndeque<pair<double, double>> que; // pair<V,VT>\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    int N;\n    double L; cin >> N >> L;\n    double Vma = 0, VTma = 0;\n    rep(i, 0, N) {\n        double T, V; cin >> T >> V;\n\n        if (i) {\n            double d = V;\n            while (0 < d) {\n                auto p = que.back(); que.pop_back();\n                if (p.first <= d) {\n                    d -= p.first;\n                    Vma -= p.first, VTma -= p.second;\n                } else {\n                    Vma -= d, VTma -= p.second * d / p.first;\n                    que.push_back({ p.first - d, p.second - p.second * d / p.first });\n                    d = 0;\n                }\n            }\n        }\n\n        Vma += V;\n        VTma += T * V;\n        printf(\"%.10f\\n\", VTma / Vma);\n        que.push_front({ V, T * V });\n\n        while (1 < que.size()) {\n            auto p1 = que.front(); que.pop_front();\n            auto p2 = que.front(); que.pop_front();\n            if (p1.second / p1.first <= p2.second / p2.first)\n                que.push_front({ p1.first + p2.first, p1.second + p2.second });\n            else {\n                que.push_front(p2);\n                que.push_front(p1);\n                break;\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 5e5 + 10;\n\nint n, m, fnt, rar, s, x[maxn];\ndouble ans, y[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\twhile(fnt < rar && s - x[fnt] >= m - v) {\n\t\t\tans -= y[fnt];\n\t\t\ts -= x[fnt++];\n\t\t}\n\t\tif(s > m - v) {\n\t\t\tans -= y[fnt];\n\t\t\ty[fnt] -= (s - m + v) * y[fnt] / x[fnt];\n\t\t\tans += y[fnt];\n\t\t\tx[fnt] -= (s - m + v);\n\t\t}\n\t\ts = m;\n\t\tdouble k = 1. * t * v;\n\t\tans += k;\n\t\twhile(fnt < rar && y[rar - 1] * v >= k * x[rar - 1]) {\n\t\t\tv += x[--rar];\n\t\t\tk += y[rar];\n\t\t}\n\t\tx[rar] = v;\n\t\ty[rar++] = k;\n\t\tprintf(\"%.12f\\n\", ans / m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint N, H = 1000000, T = 1000000;\nlong long L, tagx;\nlong double tagy;\nstruct point\n{\n\tlong long x;\n\tlong double y;\n\tpoint() : x(), y()\n\t{\n\t}\n\tpoint(long long _x, long double _y) : x(_x - tagx), y(_y - tagy)\n\t{\n\t}\n\tinline long long gx()\n\t{\n\t\treturn x + tagx;\n\t}\n\tinline long double gy()\n\t{\n\t\treturn y + tagy;\n\t}\n}\nq[2000001];\nvoid move(long long dx, long double dy)\n{\n\ttagx += dx;\n\ttagy += dy;\n\twhile (H < T && q[T - 1].gx() >= L)\n\t\tT--;\n\tif (q[T].gx() > L)\n\t{\n\t\tpoint newT(L, (q[T - 1].gy() * (q[T].gx() - L) + q[T].gy() * (L - q[T - 1].gx())) / (q[T].gx() - q[T - 1].gx()));\n\t\tq[T] = newT;\n\t}\n}\nvoid flush()\n{\n\tif (q[H].gx() == 0)\n\t\tH++;\n\twhile (H < T && q[H].gy() * q[H + 1].gx() < q[H + 1].gy() * q[H].gx())\n\t\tH++;\n\tq[--H] = { 0, 0 };\n}\nvoid ans()\n{\n\tprintf(\"%.7Lf\\n\", q[T].gy() / q[T].gx());\n}\nint main()\n{\n\tscanf(\"%d%lld\", &N, &L);\n\tfor (int i = 1; i <= N; i++)\n\t{\n\t\tlong double t;\n\t\tlong long v;\n\t\tscanf(\"%Lf%lld\", &t, &v);\n\t\tmove(v, t * v);\n\t\tflush();\n\t\tans();\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001], sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0, subv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        printf(\"%.12f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                Double need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    subtv = sumtv[v];\n                    subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define f(i, x, n) for(int i = x; i < (int)(n); ++i)\n\nstruct T{\n\tint v;\n\tdouble t;\n\tT (int a = 0, double b = 0.0):v(a), t(b) {}\n\tT operator +(T o){\n\t\tif (v + o.v == 0)return T();\n\t\treturn T(v + o.v, (v * t + o.v * o.t) / (v + o.v));\n\t}\n};\n\nint main(){\n\tint n, l;\n\tscanf(\"%d%d\", &n, &l);\n\tT c(l), ext;\n\tdeque<T> ex;\n\tf(i, 0, n){\n\t\tint in1, in2;\n\t\tscanf(\"%d%d\", &in1, &in2);\n\t\tT nt(in2, in1);\n\t\tint need = nt.v;\n\t\twhile (need && !ex.empty()){\n\t\t\tint d = min(need, ex.back().v);\n\t\t\tneed -= d;\n\t\t\text.t = (ext.t * ext.v - d * ex.back().t) / (ext.v - d);\n\t\t\text.v -= d;\n\t\t\tif ((ex.back().v -= d) == 0)ex.pop_back();\n\t\t}\n\t\tc.v -= need;\n\t\tif (nt.t > c.t){\n\t\t\tif (c.v)ex.push_front(c);\n\t\t\text = ext + c;\n\t\t\tc = nt;\n\t\t}else c = c + nt;\n\t\tprintf(\"%.7lf\\n\", (c + ext).t);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 5e5 + 10;\nint n, L;\nlong double t[maxn], sta[maxn], presta[maxn];\nint v[maxn], sva[maxn];\nlong long presva[maxn];\nint m;\nint main()\n{\n\tcin >> n >> L;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint T;\n\t\tcin >> T >> v[i];\n\t\tt[i] = 1ll * T * v[i];\n\t}\n\tlong double st = 0;\n\tint sv = 0;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tif(st * v[i] < t[i] * sv)\n\t\t{\n\t\t\t++m;\n\t\t\tsta[m] = st;\n\t\t\tsva[m] = sv;\n\t\t\tpresta[m] = presta[m - 1] + sta[m];\n\t\t\tpresva[m] = presva[m - 1] + sva[m];\n\t\t\t\n\t\t\tst = t[i];\n\t\t\tsv = v[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(sv + v[i] <= L)\n\t\t\t{\n\t\t\t\tst += t[i];\n\t\t\t\tsv += v[i];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tst = st * (L - v[i]) / sv + t[i];\n\t\t\t\tsv = L;\n\t\t\t}\n\t\t}\n\t\tif(sv == L)\n\t\t{\n\t\t\tdouble ans = st / L;\n\t\t\tprintf(\"%.7f\\n\", ans);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlong long lim = presva[m] - (L - sv);\n\t\t\tint x = lower_bound(presva + 1, presva + m + 1, lim) - presva;\n\t\t\tdouble ret = presta[m] - presta[x] + (sta[x] * (presva[x] - lim) / sva[x]);\n\t\t\tdouble ans = (st + ret) / L;\n\t\t\tprintf(\"%.7f\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n \nconst int maxn=5e5+10;\n \nint n,L,H,T;\n \nstruct Point{\n\tLL x;\n\tdouble y;\n\tPoint() {}\n\tPoint(LL x,double y):x(x),y(y) {}\n\tPoint operator + (const Point &p) const {return Point(x+p.x,y+p.y);}\n\tPoint operator - (const Point &p) const {return Point(x-p.x,y-p.y);}\n};\n \ndouble Cross(Point A,Point B) {return A.x*B.y-A.y*B.x;}\n \nPoint P[maxn];\n \nPoint GetPoint(Point A,Point B,LL x)\n{\n\tdouble t=((double)x-A.x)/(B.x-A.x);\n\treturn Point(x,A.y+t*(B.y-A.y));\n}\n \nint main()\n{\n#ifdef h10\n\tfreopen(\"F.in\",\"r\",stdin);\n\tfreopen(\"F.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tH=T=1;\n\tP[1]=Point(0,0);\n\twhile (n--)\n\t{\n\t\tPoint p;\n\t\tscanf(\"%lf%lld\",&p.y,&p.x);\n\t\tp.y*=p.x;\n\t\tT++;\n\t\tP[T]=P[T-1]-p;\n\t\twhile (H!=T&&P[H+1].x-P[T].x>=L) H++;\n\t\tif (P[H].x-P[T].x>L)\n\t\t\tP[H]=GetPoint(P[H],P[H+1],P[T].x+L);\n\t\twhile (H+1<T&&Cross(P[T-1]-P[T],P[T-2]-P[T])>=0) P[T-1]=P[T],T--;\n\t\tprintf(\"%.10lf\\n\",((double)P[H].y-P[T].y)/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define LF double\n#define LL long long\n#define fo(i,j,k) for(int i=j;i<=k;i++)\n#define fd(i,j,k) for(int i=j;i>=k;i--)\n#define fr(i,j) for(int i=beg[j];i;i=nex[i])\nusing namespace std;\nint const mn=15e5+3;\nint n,l,v[mn];\nLF t[mn];\nint main(){\n\tscanf(\"%d%d\",&n,&l);\n\tint he=1,ti=0,totv=0;LF tv=0;\n\tfo(i,1,n){\n\t\tti++;\n\t\tscanf(\"%lf%d\",&t[ti],&v[ti]);\n\t\ttotv+=v[ti];tv+=t[ti]*v[ti];\n\t\tfor(;(he<ti)&&(t[ti]<=t[ti-1]);ti--)if(v[ti]+v[ti-1]<=l){\n\t\t\t\tt[ti-1]=(t[ti]*v[ti]+t[ti-1]*v[ti-1])/(v[ti]+v[ti-1]);\n\t\t\t\tv[ti-1]+=v[ti];\n\t\t\t}else{\n\t\t\t\tv[ti-1]=l-v[ti];\n\t\t\t\tt[ti-1]=(t[ti]*v[ti]+t[ti-1]*v[ti-1])/(v[ti]+v[ti-1]);\n\t\t\t\tv[ti-1]=l;\n\t\t\t\ttotv=l;tv=l*t[ti-1];\n\t\t\t\the=ti-1;\n\t\t\t}\n\t\tfor(;(he<ti)&&(totv-v[he]>=l);he++)totv-=v[he],tv-=t[he]*v[he];\n\t\tprintf(\"%.10lf\\n\",(tv-(totv-l)*t[he])/l);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nusing namespace std;\nint n,m,l=1,r,tot;\ndouble sum,now,a[1000010],b[1000010],ans[1000010];\nstruct abc{\n\tdouble x,y;\n}q[500010];\ninline int read(){\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch<'0'||ch>'9') {\n        if(ch=='-')f=-1;\n        ch=getchar();\n    }\n    while(ch>='0'&&ch<='9'){\n         x=(x<<3)+(x<<1)+ch-48;\n         ch=getchar();\n    }\n    return x*f;\n}\nsigned main(){\n    n=read(),m=read();\n    for(register int i=1;i<=n;i++) a[i]=read(),b[i]=read();\n\tans[1]=a[1];\n    for(register int i=1;i<=n;i++){\n        sum+=a[i]*b[i];\n\t\tnow+=b[i];\n        r++;\n\t\tq[r].x=a[i];\n\t\tq[r].y=b[i];\n        while(l<=r){\n            if(now<=m) break;\n            if(now-q[l].y<m){\n                sum-=q[l].y*q[l].x;\n                q[l].y-=now-m;\n                sum+=q[l].y*q[l].x;\n                now=m;\n                break;\n            }else{\n            \tnow-=q[l].y;\n\t\t\t\tsum-=q[l].y*q[l].x;\n\t\t\t\tl++;\n            } \n        }\n        ans[i]=sum/m;\n        while(l<r&&q[r].x<q[r-1].x){\n            tot=q[r-1].y+q[r].y;\n            sum-=q[r].x*q[r].y-q[r-1].x*q[r-1].y;\n\t\t\tnow-=q[r].y-q[r-1].y;\n            q[r-1].x=(q[r].x*q[r].y+q[r-1].x*q[r-1].y)/tot;\n            q[r-1].y=tot;\n            sum+=q[r-1].x*q[r-1].y;\n\t\t\tnow+=q[r-1].y;\n            r--;\n        }\n    }\n    for(register int i=1;i<=n;i++) printf(\"%.7lf\\n\",ans[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\nstatic const int MAXN = 5e5 + 4;\n#define double long double\n\nint n, l;\nint t[MAXN], v[MAXN];\n\nint qhead, qtail;\nstd::pair<double, double> q[MAXN];\nstd::pair<double, double> offset;\n\ndouble eval_linear(std::pair<double, double> p, std::pair<double, double> q, double x)\n{\n    double ratio = (x - p.first) / (q.first - p.first);\n    return p.second * (1.0 - ratio) + q.second * ratio;\n}\n\nint main()\n{\n    scanf(\"%d%d\", &n, &l);\n    for (int i = 0; i < n; ++i) scanf(\"%d%d\", &t[i], &v[i]);\n\n    qhead = MAXN - 2, qtail = MAXN;\n    q[MAXN - 2] = std::make_pair(0, 0);\n    q[MAXN - 1] = std::make_pair(v[0], (double)v[0] * t[0]);\n    offset = std::make_pair(0, 0);\n    printf(\"%.8Lf\\n\", (double)t[0]);\n\n    for (int i = 1; i < n; ++i) {\n        offset.first += v[i];\n        q[qtail - 1] = std::make_pair(l - offset.first, eval_linear(q[qtail - 2], q[qtail - 1], l - offset.first));\n        offset.second += (double)v[i] * t[i];\n        while (qtail > qhead + 1 && q[qtail - 2].first + offset.first > l) --qtail;\n        int lo = qhead, hi = qtail, mid;\n        while (lo < hi - 1) {\n            mid = (lo + hi) >> 1;\n            if ((q[mid].second + offset.second) / (q[mid].first + offset.first)\n                >= (q[mid - 1].second + offset.second) / (q[mid - 1].first + offset.first)) lo = mid;\n            else hi = mid;\n        }\n        qhead = lo;\n        q[--qhead] = std::make_pair(-offset.first, -offset.second);\n        printf(\"%.8Lf\\n\", (q[qtail - 1].second + offset.second) / l);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1*d1.front().second;\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    totv-=d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=(long double)1*v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=(long double)1*v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=(long double)1*d1.back().first*d1.back().second;\n                double tempp = (long double)1*tempv*tempt;\n                tempp+=(long double)1*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1*tempp)/((long double)1*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 500010\n#define ll long long\nusing namespace std;\nstruct data{int x; double y;}d[N];\nint n, op, cl, sum, x, sx;\ndouble y, sy;\ninline char gc(){\n\tstatic char now[1<<16], *S, *T;\n\tif(S==T){T=(S=now)+fread(now, 1, 1<<16, stdin); if(S==T)return EOF;}\n\treturn *S++;\n}\ninline int read(){\n\tint x=0, f=1; char ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=gc();}\n\treturn x*f;\n}\nint main(){\n\tn=read(); sum=read();\n\top=1; cl=0; sx=sy=0;\n\tfor(int i=1; i<=n; i++){\n\t\ty=read(); x=read(); y*=x;\n\t\tsx+=x; sy+=y;\n\t\twhile(sx>sum){\n\t\t\tif(sx-d[op].x<sum){sy-=d[op].y; d[op].y-=d[op].y/d[op].x*(sx-sum); d[op].x-=sx-sum; sx=sum; sy+=d[op].y;}\n\t\t\telse{sx-=d[op].x; sy-=d[op].y; op++;}\n\t\t}\n\t\tprintf(\"%.10f\\n\", sy/sum);\n\t\twhile(y/x<d[cl].y/d[cl].x){\n\t\t\ty+=d[cl].y; x+=d[cl].x; cl--;\n\t\t}\n\t\td[++cl].x=x; d[cl].y=y;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\ndouble sumsTV[500011];\ndouble sumsV[500011];\n\ndouble evalH(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + H[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\ndouble evalT(int l, int i) {\n    return (sumsTV[i+1] - sumsTV[l+1] + T[l]*(L - sumsV[i+1] + sumsV[l+1])) / L;\n}\n\nint qu[500011];\nint *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    REP (i, N) {\n\tsumsTV[i+1] = sumsTV[i] + (double)T[i] * V[i];\n\tsumsV[i+1] = sumsV[i] + V[i];\n    }\n\n    H[0] = T[0];\n\n    int pos = 0;\n    for (int i=1; i<N; i++) {\n\twhile (sumsV[i+1] - sumsV[*head+1] >= L) head++;\n\twhile (head < tail && evalH(*head, i) <= evalH(*(head+1), i)) head++;\n\tif (head <= tail) amax(H[i], evalH(*head, i));\n\n\twhile (sumsV[i+1] - sumsV[pos+1] >= L) pos++;\n\tamax(H[i], evalT(pos, i));\n\n\twhile (head <= tail && H[*tail] <= H[i]) tail--;\n\ttail++;\n\t*tail = i;\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  LL n, l;\n  deque<pair<LL, double>> cal;\n  vector<LL> t, v;\n  Solver(LL n) : n(n), t(n), v(n){};\n  double temperature(int a, int b) {\n    return (cal[b].second - cal[a].second) / (double)(cal[b].first - cal[a].first);\n  }\n  void solve() {\n    cin >> l;\n    for (int i = 0; i < n; ++i) {\n      cin >> t[i] >> v[i];\n    }\n    cal.emplace_back(0, 0);\n    for (int i = 0; i < n; ++i) {\n      // increse\n      cal.emplace_front(cal[0].first - v[i], cal[0].second - t[i] * v[i]);\n      //answer\n      DBG(cal)\n      printf(\"%.9lf\\n\", temperature(0, cal.size() - 1));\n      //mix\n      while (cal.size() >= 3 && temperature(0, 1) < temperature(1, 2) - 1e-10) {\n        cal.erase(cal.begin() + 1);\n      }\n      if (i == n - 1) break;\n      //decrease\n      LL upperBound = l - v[i + 1];\n      while (1) {\n        auto tmp = cal[cal.size() - 1];\n        cal.pop_back();\n        if (cal.back().first < cal[0].first + upperBound) {\n          cal.emplace_back(cal[0].first + upperBound, cal.back().second + (tmp.second - cal.back().second) / (tmp.first - cal.back().first) * (cal[0].first + upperBound - cal.back().first));\n          break;\n        } else if (cal.back().first == cal[0].first + upperBound) {\n          break;\n        }\n      }\n      DBG(cal)\n    }\n  }\n};\n\n}  // namespace Problem\n\nint main() {\n  //std::cin.tie(0);\n  //std::ios_base::sync_with_stdio(false);\n  std::cout << std::fixed << std::setprecision(9);\n  long long n = 0;\n  scanf(\"%lld\", &n);\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,L; cin >> N >> L;\n\tvector<pair<double,int>> W;\n\trepp(i,0,N){\n\t\tdouble t; int v; cin >> t >> v;\n\t\twhile(!W.empty() && (*W.rbegin()).first >= t && v < L){\n\t\t\tt = ((*W.rbegin()).first * min(L-v,(*W.rbegin()).second) + t * v) / min(L,(*W.rbegin()).second+v);\n\t\t\tv = min(L,v+(*W.rbegin()).second);\n\t\t\tW.pop_back();\n\t\t}\n\t\tW.push_back(make_pair(t,v));\n\t\tint z = L;\n\t\tdouble ans = 0.0;\n\t\tfor(auto it = W.rbegin() ; z > 0 ; ++it){\n\t\t\tans += (*it).first * min(z,(*it).second);\n\t\t\tz -= (*it).second;\n\t\t}\n\t\tcout << fixed << setprecision(12) << ans/L << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size())  \n#define rep(i, n) for(int i=0;i<n;i++)  \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 18;\nconst ll MOD = 1000000007;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\npdd operator - (pdd a, pdd b) {\n\treturn pdd(a.first - b.first, a.second - b.second);\n}\ndb ccw(pdd a, pdd b) {\n\treturn a.first*b.second - a.second*b.first;\n}\n\nvector <pdd> Vch;\nint main() {\n\tint N, L, i, j;\n\tscanf(\"%d %d\", &N, &L);\n\n\tint st = 0;\n\tdb s1 = 0, s2 = 0;\n\tVch.emplace_back(s1, s2);\n\tfor (i = 1; i <= N; i++) {\n\t\tll T, V;\n\t\tscanf(\"%lld %lld\", &T, &V);\n\t\ts1 -= T*V, s2 -= V;\n\n\t\tdb mx = s2 + L;\n\t\twhile (st + 1 < Vch.size()) {\n\t\t\tif (Vch[st + 1].second < mx) break;\n\t\t\tst++;\n\t\t}\n\t\tif (st + 1 != Vch.size()) {\n\t\t\tdb x = (Vch[st + 1].first - Vch[st].first) / (Vch[st + 1].second - Vch[st].second);\n\t\t\tVch[st].first = Vch[st + 1].first + x * (mx - Vch[st + 1].second);\n\t\t\tVch[st].second = mx;\n\t\t}\n\t\twhile (Vch.size() > st + 1) {\n\t\t\tpdd u1 = Vch[Vch.size() - 2];\n\t\t\tpdd u2 = Vch.back();\n\t\t\tpdd u3 = pdd(s1, s2);\n\t\t\tif (ccw(u1 - u3, u2 - u3) < 0) break;\n\t\t\tVch.pop_back();\n\t\t}\n\t\tVch.emplace_back(s1, s2);\n\n\t\tprintf(\"%.20lf\\n\", (Vch[st].first - s1) / (Vch[st].second - s2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)(a);i<=(sign)(b);++i)\n#define Fordown(i,a,b) for(register sign i=(sign)(a);i>=(sign)(b);--i)\nconst int N=5e5+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in\",\"r\",stdin);\n\tfreopen(\"out\",\"w\",stdout);\n#endif\n}\nint n,L;\nvoid input()\n{\t\n\tn=read<int>(),L=read<int>();\n}\ndouble tmp[N],ans;\nll now,V[N];\nint l=1,r;\n#define sum(x,y) (V[y]-V[x-1])\nvoid work()\n{\n\tint t,v;\n\tll nexv,vv;\n\tFor(i,1,n)\n\t{\n\t\tt=read<int>(),v=read<int>();\n\t\ttmp[++r]=t,V[r]=V[r-1]+v;\n\t\tnow+=v;ans+=1ll*t*v;\n\t\tfor(;r>1&&tmp[r-1]>=tmp[r];r--)\n\t\t{\n\t\t\tnexv=min((ll)L,sum(r-1,r));\t\n\t\t\tvv=nexv-sum(r,r);\n\t\t\tans-=tmp[r-1]*(sum(r-1,r-1)-vv);\n\t\t\tV[r-1]=nexv+V[r-2];\n\t\t\ttmp[r-1]=(tmp[r]*sum(r,r)+tmp[r-1]*vv)/(1.0*nexv);\n\t\t}\n\t\t//For(j,1,r)printf(\"%.7lf %lld\\n\",tmp[j],V[j]-V[j-1]);\n\t\t//cerr<<r<<endl;\n\t\tcmin(l,r);\n\t\tfor(;l<r&&sum(l+1,r)>=L;l++)ans-=tmp[l]*sum(l,l);\n\t\tprintf(\"%.7lf\\n\",(ans-(sum(l,r)-L)*tmp[l])/(1.0*L));\n\t}\n}\nint main()\n{\n\t//file();\n\tinput();\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=d1.front().second;\n                    totprod-=d1.front().first*d1.front().second;\n                    totv-=d1.front().first;\n                    d1.pop_front();\n                }else{\n                    totprod-=d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=d1.back().first*d1.back().second;\n                double tempp = tempv*tempt;\n                tempp+=d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = tempp/tempv;\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        totprod+=tempt*tempv;\n       // cout<<totprod<<endl;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<double,double>> v;\nvector<pair<int,int>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tint l=as[j].second;\n\t\t\tif(l!=-1){\n\t\t\t\tint val=as[j].first*l;\n\t\t\t\tif(need>l){\n\t\t\t\t\tans+=val;\n\t\t\t\t\tneed-=l;\n\t\t\t\t\ti-=99;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tlong long val=0;\n\t\t\tint totall=0;\n\t\t\tfor(int z=vcnt-101;z<vcnt-1;z++){\n\t\t\t\ttotall+=v[z].second;\n\t\t\t}\n\t\t\tif(totall>=l){\n\t\t\t\tas.push_back({-1,-1});\n\t\t\t}\n\t\t\tfor(int z=vcnt-101;z<vcnt-1;z++){\n\t\t\t\tval+=v[z].first*v[z].second;\n\t\t\t}\n\t\t\tas.push_back({(long double)val/totall,totall});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tint ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,(double)ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b)/(b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef double db;\nconst int N=500500;\nint i,j,k,n,l,r,L,v,t,V,ch;\nint a[N];\ndb T,b[N];\nvoid R(int &x) {\n\tx=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint main() {\n\tR(n);R(L);\n\tl=1;r=0;\n\tfor (i=1;i<=n;i++) {\n\t\tR(t);R(v);\n\t\twhile (V+v>L) {\n\t\t\tif (V-a[l]+v>=L) {\n\t\t\t\tV-=a[l];\n\t\t\t\tT-=b[l];\n\t\t\t\tl++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint tv=V+v-L;\n\t\t\t\tdb tt=b[l]/(1.0*a[l])*tv;\n\t\t\t\ta[l]-=tv;\n\t\t\t\tb[l]-=tt;\n\t\t\t\tV-=tv;\n\t\t\t\tT-=tt;\n\t\t\t}\n\t\t}\n\t\tV+=v;\n\t\tT+=1.0*t*v;\n\t\tif (l>r || 1.0*t*a[r]>b[r]) {\n\t\t\tr++;\n\t\t\ta[r]=v;\n\t\t\tb[r]=1.0*t*v;\n\t\t}\n\t\telse {\n\t\t\ta[r]+=v;\n\t\t\tb[r]+=1.0*t*v;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",T/(1.0*V));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n\nusing namespace std;\n\ntemplate<typename S,typename T>auto&operator<<(ostream&o,pair<S,T>p){return o<<\"{\"<<p.fi<<\",\"<<p.se<<\"}\";}\ntemplate<typename T>auto&operator<<(ostream&o,set<T>s){for(auto&e:s)o<<e<<\" \";return o;}\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,priority_queue<S,T,U>q){while(!q.empty())o<<q.top()<<\" \",q.pop();return o;}\ntemplate<typename K,typename T>auto&operator<<(ostream&o,map<K,T>&m){for(auto&e:m)o<<e<<\" \";return o;}\ntemplate<typename T>auto&operator<<(ostream&o,deque<T>v){for(auto&e:v)o<<e<<\" \";return o;}\nvoid ashow(){cout<<endl;}template<typename T,typename...A>void ashow(T t,A...a){cout<<t<<\" \";ashow(a...);}\ntemplate<typename S,typename T,typename U>\nstruct TRI{S fi;T se;U th;TRI(){}TRI(S f,T s,U t):fi(f),se(s),th(t){}};\ntemplate<typename S,typename T,typename U>\nauto&operator<<(ostream&o,TRI<S,T,U>&t){return o<<\"{\"<<t.fi<<\",\"<<t.se<<\",\"<<t.th<<\"}\";}\n\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef TRI<int, int, int> tri;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef vector<P> vp;\ntypedef vector<double> vd;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n// 温度, 量\ndeque<pdd> deq;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll n, L;\n    cin >> n >> L;\n    double nw = 0;\n    ll t, v;\n    cin >> t >> v;\n    deq.pb(pdd(t, v));\n    printf(\"%.12lf\\n\", (nw += t*v)/L);\n    rep(i,n-1){\n        ll t, v;\n        cin >> t >> v;\n        double sm = 0;\n        while(true){\n            pdd& p = deq.front();\n            if(sm + p.se < v){\n                sm += p.se;\n                nw -= p.fi*p.se;\n                deq.pop_front();\n            }else{\n                nw -= p.fi*(v-sm);\n                p.se -= v-sm;\n                break;\n            }\n        }\n        double made = t*v, ryo = v;\n        while(true){\n            pdd& p = deq.back();\n            if(p.fi*ryo < made){\n                deq.pb(pdd(made/ryo,ryo));\n                break;\n            }else{\n                made += p.fi*p.se;\n                ryo += p.se;\n                deq.pop_back();\n                if(deq.empty()){\n                    deq.pb(pdd(made/ryo,ryo));\n                    break;\n                }\n            }\n        }\n        printf(\"%.12lf\\n\", (nw += t*v)/L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#define SIZE 500005\n#define EPS 1e-10\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <double,int> P;\n\nP st[SIZE];\n\nint main()\n{\n\tint n,L;\n\tscanf(\"%d %d\",&n,&L);\n\tint s=0,sz=0;\n\tdouble sum=0.0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint t,v;\n\t\tscanf(\"%d %d\",&t,&v);\n\t\tif(i>0)\n\t\t{\n\t\t\tint zan=v;\n\t\t\twhile(zan>0)\n\t\t\t{\n\t\t\t\tif(st[s].second>zan)\n\t\t\t\t{\n\t\t\t\t\tst[s].second-=zan;\n\t\t\t\t\tsum-=st[s].first*(double) zan;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsum-=st[s].first*(double) st[s].second;\n\t\t\t\t\tzan-=st[s].second;\n\t\t\t\t\ts++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsum+=(double) t*(double) v;\n\t\tP p=P(t,v);\n\t\twhile(sz>s&&st[sz-1].first+EPS>p.first)\n\t\t{\n\t\t\tP q=st[--sz];\n\t\t\tP r=P((q.first*(double) q.second+p.first*(double) p.second)/(double) (p.second+q.second),p.second+q.second);\n\t\t\tp=r;\n\t\t}\n\t\t//printf(\"%f %d\\n\",p.first,p.second);\n\t\tst[sz++]=p;\n\t\tprintf(\"%.10f\\n\",sum/(double) L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\ntypedef pair<ld,ll> P;\n#define fr first\n#define sc second\n\nint main(){\n\tstatic ll n,l;\n\tstatic ll t[500010],v[500010];\n\tscanf(\"%lld%lld\",&n,&l);\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tscanf(\"%lld%lld\",&t[i],&v[i]);\n\t}\n\t\n\tint k = 0;\n\tvector<P> vec;\n\tll ret = 0;\n\tfor(int i = 0 ; i < n ; i ++){\n\t\tll V = v[i];\n\t\tif(i>0){\n\t\t\twhile(V > 0){\n\t\t\t\tll x = min(V,vec[k].sc);\n\t\t\t\tret -= vec[k].fr*x;\n\t\t\t\tvec[k].sc -= x;\n\t\t\t\tV -= x;\n\t\t\t\tif(vec[k].sc == 0)k ++;\n\t\t\t}\n\t\t}\n\t\tP q = P((ld)t[i],(ld)v[i]);\n\t\tret += t[i]*v[i];\n\t\twhile(vec.size() > k){\n\t\t\tP p = vec[vec.size()-1];\n\t\t\tif(p.fr < q.fr)break;\n\t\t\telse {\n\t\t\t\tvec.pop_back();\n\t\t\t\tq.fr = (q.fr*q.sc+p.fr*p.sc)/(q.sc+p.sc);\n\t\t\t\tq.sc += p.sc;\n\t\t\t}\n\t\t}\n\t\tvec.push_back(q);\n\t\t/*if(i>0){\n\t\t\twhile(v[i] > 0){\n\t\t\t\tll x = min(v[i],vec[k].sc);\n\t\t\t\tret -= vec[k].fr*x;\n\t\t\t\tvec[k].sc -= x;\n\t\t\t\tv[i] -= x;\n\t\t\t\tif(vec[k].sc == 0)k ++;\n\t\t\t}\n\t\t}*/\n\t\t/*for(int i = 0 ; i < vec.size() ; i ++){\n\t\t\tcout << vec[i].fr << \" \" << vec[i].sc << endl;\n\t\t}\n\t\tcout << k << \" \" << ret << endl;*/\n\t\tprintf(\"%.12f\\n\",(double)((ld)ret/(ld)l));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, L;\nint T[500011], V[500011];\ndouble H[500011];\n\npair<double, int> qu[500011], *head = qu, *tail = qu;\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &L);\n    REP (i, N) scanf(\"%d%d\", T+i, V+i);\n\n    H[0] = T[0];\n    double sum = (double)T[0]*L;\n\n    *head = make_pair(T[0], L);\n    for (int i=1; i<N; i++) {\n\tint rest = V[i];\n\twhile (rest) {\n\t    if (rest >= head->second) {\n\t\trest -= head->second;\n\t\tsum -= head->first * head->second;\n\t\thead++;\n\t    } else {\n\t\tsum -= head->first * rest;\n\t\thead->second -= rest;\n\t\trest = 0;\n\t    }\n\t}\n\n\tsum += (double)T[i] * V[i];\n\tH[i] = sum / L;\n\ttail++;\n\t*tail = make_pair(T[i], V[i]);\n\twhile (head < tail && (tail-1)->first >= tail->first) {\n\t    tail--;\n\t    double nu = tail->first * tail->second + (tail+1)->first * (tail+1)->second;\n\t    double de = tail->second + (tail+1)->second;\n\t    *tail = make_pair(nu/de, de);\n\t}\n    }\n\n    REP (i, N) printf(\"%.12f\\n\", H[i]);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 500005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n    \tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct Point {\n    double x,y;\n    Point(double _x = 0,double _y = 0) {\n        x = _x;y = _y;\n    }\n    friend Point operator + (const Point &a,const Point &b) {\n        return Point(a.x + b.x,a.y + b.y);\n    }\n    friend Point operator - (const Point &a,const Point &b) {\n        return Point(a.x - b.x,a.y - b.y);\n    }\n    friend double operator * (const Point &a,const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n}que[MAXN];\nint N,ql,qr;\ndouble L,sum;\nvoid Solve() {\n    read(N);scanf(\"%lf\",&L);\n    double t,v;\n    for(int i = 1 ; i <= N ; ++i) {\n        scanf(\"%lf%lf\",&t,&v);\n        que[++qr] = Point(v,t * v);\n        sum += t * v;\n        double dec = 0;\n        if(i != 1) {\n            while(1) {\n                if(dec >= v) break;\n                if(que[ql].x <= v - dec) {\n                    dec += que[ql].x;\n                    sum -= que[ql].y;\n                    ++ql;\n                }\n                else {\n                    sum -= que[ql].y;\n                    que[ql].y -= que[ql].y / que[ql].x * (v - dec);\n                    que[ql].x -= v - dec;\n                    sum += que[ql].y;\n                    break;\n                }\n            }\n        }\n        printf(\"%.7lf\\n\",sum / L);\n        while(ql <= qr - 1) {\n            if(que[qr] * que[qr - 1] >= -1e-8) {\n                que[qr - 1] = que[qr] + que[qr - 1];\n                --qr;\n            }\n            else break;\n        }\n    }\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define eps (1e-8)\n\nint n, l;\nstd::deque<std::pair<int, double> >dq;\n\ndouble det(std::pair<int, double> p, std::pair<int, double> q){\n\treturn p.first * q.second - p.second * q.first;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &l);\n\tdouble sum = 0;\n\tfor(int i = 1, v, t; i <= n; ++ i){\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tint now = l;\n\t\twhile(!dq.empty() && now - dq.back().first + v >= l){\n\t\t\tnow -= dq.back().first;\n\t\t\tsum -= dq.back().second;\n\t\t\tdq.pop_back();\n\t\t}\n\t\tif(dq.empty()){\n\t\t\tdq.push_front({v, 1ll * t * v});\n\t\t\tsum = 1ll * t * v;\n\t\t\tprintf(\"%.10lf\\n\", 1.0 * t);\n\t\t\tcontinue;\n\t\t}\n\t\tint x = dq.back().first;\n\t\tdouble y = dq.back().second;\n\t\tstd::pair<int, double> p = {x - (now + v - l), y / x * (x - (now + v - l))};\n\t\t\n\t\tsum += p.second - y + 1ll * t * v;\n\t\tdq.pop_back();\n\t\tdq.push_back(p);\n\t\tprintf(\"%.10lf\\n\", sum / l);\n\t\t\n\t\tp = {v, 1ll * t * v};\n\t\twhile(!dq.empty() && det(p, dq.front()) > eps){\n\t\t\tp = {p.first + dq.front().first, p.second + dq.front().second};\n\t\t\tdq.pop_front();\n\t\t}\n\t\tdq.push_front(p);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define pD pair <double, double>\n#define fr first\n#define sc second\n#define mp make_pair\n\nint n, l;\ndeque <pD> Q;\nint main()\n{\n    scanf(\"%d%d\", &n, &l);\n    double x = 0, y = 0;\n    for (int i = 1; i <= n; ++ i)\n    {\n        double t, v;\n        scanf(\"%lf%lf\", &t, &v);\n        if (i == 1)\n        {\n            Q.push_back(mp(0, 0));\n            Q.push_back(mp(v, t * v));\n        }\n        else\n        {\n            x -= v;\n            y -= 1.0 * t * v;\n            while (Q.size() >= 2)\n            {\n                pD b = Q.back(); Q.pop_back(); pD a = Q.back();\n                if (a.fr - x > l) continue;\n                Q.push_back(mp(x + l, a.sc + (x + l - a.fr) * (b.sc - a.sc) / (b.fr - a.fr)));\n                break;\n            }\n            while (Q.size() >= 2)\n            {\n                pD a = Q.front(); Q.pop_front(); pD b = Q.front();\n                if ((a.sc - y) * (b.fr - x) < (b.sc - y) * (a.fr - x)) continue;\n                Q.push_front(a);\n                break;\n            }\n            Q.push_front(mp(x, y));\n        }\n        printf(\"%.10lf\\n\", (Q.back().sc - y) / (Q.back().fr - x));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "     #include <bits/stdc++.h>\n\n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-10)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n/*\n                                            class Point{\n                                            \tpublic:\n                                            \tdouble x,y;\n                                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                            \tdouble absv() {return sqrt(norm());}\n                                            \tdouble norm() {return x*x+y*y;}\n                                            \tbool operator < (const Point &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const Point &p) const{\n                                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                            \t}\n                                            };\n                                            typedef Point Vector;\n                                     #define pl pair<int,pas>\n                                            struct Segment{\n                                            Point p1,p2;\n                                            };\n                                             double dot(Vector a,Vector b){\n                                            \treturn a.x*b.x+a.y*b.y;\n                                            }\n                                            double cross(Vector a,Vector b){\n                                            \treturn a.x*b.y-a.y*b.x;\n                                            }\n                                        \n                bool parareru(Point a,Point b,Point c,Point d){\n                //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                \treturn abs(cross(a-b,d-c))<EPS;\n                }\n                double distance_ls_p(Point a, Point b, Point c) {\n                  if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                  if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                  return abs(cross(b-a, c-a)) / (b-a).absv();\n                }\n                bool is_intersected_ls(Segment a,Segment b) {\n                \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                //\t\tcout<<\"sss\"<<endl;\n                \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                \t\treturn false;\n                \t}\n                  else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                }\n                 \n                double segment_dis(Segment a,Segment b){\n                \tif(is_intersected_ls(a,b))return 0;\n                \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                \treturn r;\n                }\n                Point intersection_ls(Segment a, Segment b) {\n                  Point ba = b.p2-b.p1;\n                  double d1 = abs(cross(ba, a.p1-b.p1));\n                  double d2 = abs(cross(ba, a.p2-b.p1));\n                  double t = d1 / (d1 + d2);\n                 \n                  return a.p1 + (a.p2-a.p1) * t;\n                }\n */                \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                                double distans(double x1,double y1,double x2,double y2){\n                                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                \treturn sqrt(rr);\n                                \t\n                                }\n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n    double bekid(double w,int r){\n    \tif(r==0) return 1.0;\n    \tif(r==1) return w;\n    \tif(r%2) return bekid(w,r-1)*w;\n    \tdouble f=bekid(w,r/2);\n    \treturn f*f;\n    }\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n                \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                \t\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n    \n                                     //----------------kokomade tenpure------------\n\ntypedef struct{\n\tdouble a;\n\tdouble b;\n\tint l,r;\n}eda;\n\neda node(double a,double b,int l,int r){\n\teda v;\n\tv.a=a;\n\tv.b=b;\n\tv.l=l;\n\tv.r=r;\n\treturn v;\n}\n\ndeque<eda> de;\n signed main(){\n\n    \t       cin.tie(0);\n   \t\t\tios::sync_with_stdio(false);\nint n;\n \tint l;\n \tcin>>n>>l;\n \t\n \tdouble te;\n \tint y;\n \tcin>>te>>y;\n //\tcout<<te<<endl;\n \tprintf(\"%.10lf\\n\",te);\n \t\tde.pb(node(te,0,l,0));\n \tint hos=0;\n \tdouble cd=0;\n \tdouble ad=0;\n \tfor(int i=1;i<n;i++){\n \t\tcin>>te;\n \t\tint vo;\n \t\tcin>>vo;\n \t\thos+=vo;\n \t\twhile(de.size()>0&&de.front().r+hos>=l)de.pop_front();\n \t\tassert(de.size()>0);\n \t\tde.front().l=l-hos;\n \t\tcd+=(double)te*vo;\n \t\tad+=(double) vo;\n \t\tif(de.back().b+cd-de.back().a*ad>=0){\n \t\t\tint b=-cd+te*ad;\n \t\t\tde.pb(node(te,b,de.back().r,de.back().r-vo));\n \t\t}\n \t\telse{\n \t\t\tint k2=de.back().r-vo;\n \t\t\tint laspos;\n \t\t\tdouble val;\n \t\t\twhile(de.size()>0&&de.back().b+cd-de.back().a*ad<0){\n \t\t\t\tlaspos=de.back().l;\n \t\t\t\tval=(de.back().a*((double)laspos+hos)+de.back().b+cd-ad*de.front().a)/((double) (laspos+hos));\n \t\t\t\tde.pop_back();\n \t\t\t}\n \t\t\tde.pb(node(val,-cd+val*ad,laspos,k2));\n \t\t}\n \t\t/*\n \t\tcout<<endl;\n \t\tfor(auto it=de.begin();it!=de.end();it++){\n \t\t\teda w=*it;\n \t\t\tcout<<w.l+hos<<\" \"<<w.r+hos<<\" \"<<w.a<<\" \"<<w.b+cd-ad*w.a<<endl;\n \t\t}\n \t\tcout<<endl;\n \t\t*/\n \t\tdouble ans;\n \t\tans=(de.front().a*(l)+(de.front().b+cd-ad*de.front().a))/((double) (l));\n \t\tprintf(\"%.10lf\\n\",ans);\n \t}\n \treturn 0;\n  }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=int(a),nn=int(b);i<=nn;++i)\n#define vep(i,a,b) for(int i=int(a),nn=int(b);i>=nn;--i)\n#define xep(i,b) for(int i=0,nn=int(b);i<nn;++i)\n#define x first\n#define y second\n#define mp make_pair\n\ntypedef double ff;\ntypedef pair<int,ff> two;\n\nconst int N = 500100;\n\ntwo q[N];\n\nint hd, tl, n, L;\nff sm;\n\ninline void in(int &x) {\n  \tchar c=getchar(); int f=1;\n\tfor (;c<'0'||c>'9';c=getchar()) f=(c=='-'?-1:f);\n\tfor (x=0; c>='0'&&c<='9';c=getchar()) x=x*10+c-48;\n\tx *= f;\n}\nint main() {\n  \tin(n), in(L);\n\thd = tl = 0, q[tl++]=mp(L, 0);\n\n\tint v, vv, tt, c; ff t;\n\trep(i, 1, n) {\n\t  \tin(tt), in(v), vv=v, t=tt;\n\t\twhile (hd < tl && vv) {\n\t\t  \tc = min(q[hd].x, vv);\n\t\t\tq[hd].x -= c, sm-=q[hd].y*c,vv -= c;\n\t\t\tif (!q[hd].x) ++hd;\n\t\t}\n\t\tsm += (ff)v*t;\n\t\twhile (hd < tl && q[tl-1].y>=t) {\n\t\t \t--tl, t=((ff)v*t+(ff)q[tl].x*q[tl].y)/(v+q[tl].x);\n\t\t\tv += q[tl].x;\n\t\t}\n\t\tq[tl++] = mp(v,t);\n\t\tprintf(\"%.10lf\\n\", sm/L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\nusing llf = long double;\nusing pi = pair<llf, llf>;\nconst llf eps = 1e-9;\n\ndeque<pi> dq;\nint n, l;\nllf dap;\n\nint main(){\n\tscanf(\"%d %d\",&n,&l);\n\tfor(int i=0; i<n; i++){\n\t\tint t, v; \n\t\tscanf(\"%d %d\",&t,&v);\n\t\tif(i > 0){\n\t\t\tllf l = v;\n\t\t\twhile(dq.size() && l > eps){\n\t\t\t\tauto w = dq.back();\n\t\t\t\tdq.pop_back();\n\t\t\t\tauto dx = min(l, w.second);\n\t\t\t\tdap -= w.first;\n\t\t\t\tw.first -= (w.first / w.second) * dx;\n\t\t\t\tdap += w.first;\n\t\t\t\tw.second -= dx;\n\t\t\t\tl -= dx;\n\t\t\t\tif(w.second > eps){\n\t\t\t\t\tdq.push_back(w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdap += 1ll * t * v;\n\t\tllf sum = 1ll * t * v;\n\t\tllf len = v;\n\t\twhile(dq.size() && sum / len < dq[0].first / dq[0].second){\n\t\t\tsum += dq[0].first;\n\t\t\tlen += dq[0].second;\n\t\t\tdq.pop_front();\n\t\t}\n\t\tdq.emplace_front(sum, len);\n\t\tprintf(\"%.10Lf\\n\", dap / l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#define LL long long\n#define M 500020\nusing namespace std;\nLL read(){\n    LL nm=0,fh=1; char cw=getchar();\n    for(;!isdigit(cw);cw=getchar()) if(cw=='-') fh=-fh;\n    for(;isdigit(cw);cw=getchar()) nm=nm*10+(cw-'0');\n    return nm*fh;\n}\nLL n,m,q[M],hd,tl,num[M],now,V;\ndouble ans=0.0,maxn,tot,T[M];\ndouble calc(LL x){return (1.0*num[x])*T[x];}\nint main(){\n    n=read(),m=read(),maxn=m*1.0,hd=1;\n    for(LL i=1;i<=n;i++){\n        T[i]=read()*1.0,num[i]=read(),q[++tl]=i,ans+=calc(i),V+=num[i];\n        for(bool fg=false;hd<tl&&T[q[tl]]<=T[q[tl-1]];fg=false){\n            ans-=calc(q[tl])+calc(q[tl-1]);\n            if(num[q[tl]]+num[q[tl-1]]>m) num[q[tl-1]]=m-num[q[tl]],fg=true;\n            T[q[tl-1]]=(calc(q[tl-1])+calc(q[tl]))/((num[q[tl-1]]+num[q[tl]])*1.0);\n            num[q[tl-1]]+=num[q[tl]],tl--;\n            if(fg) hd=tl,ans=calc(q[tl]),V=m;\n            else  ans+=calc(q[tl]);\n        }\n        while(V>m){\n            if(V-num[q[hd]]>=m) ans-=calc(q[hd]),V-=num[q[hd]],hd++;\n            else ans-=calc(q[hd]),num[q[hd]]-=V-m,ans+=calc(q[hd]),V=m;\n        }\n        printf(\"%.10f\\n\",ans/maxn);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ef emplace_front\n#define sz(V) ((int)(V).size())\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ld, ld> pdd;\nld operator * (const pdd &a, const pdd &b) { return a.first*b.second - b.first*a.second; }\nld ccw(const pdd &a, const pdd &b, const pdd &c) { return a*b + b*c + c*a; }\n\ndeque<pdd> CH;\n\nld DX, DY;\nll L;\nint N;\n\nint main() {\n\tios::sync_with_stdio(false);\n\n\tcin >> N >> L;\n\tCH.ef(0, 0);\n\tfor(ld v, t; N--;) {\n\t\tcin >> t >> v;\n\t\tDX += v; DY += v*t;\n\t\tfor(; 1 < sz(CH) && CH[sz(CH)-2].first + DX > L; CH.pop_back());\n\t\tif(1 < sz(CH) && CH.back().first + DX > L) {\n\t\t\tld sx, sy, ex, ey;\n\t\t\ttie(sx, sy) = CH[sz(CH)-2];\n\t\t\ttie(ex, ey) = CH.back();\n\t\t\tCH.back().first = L - DX;\n\t\t\tCH.back().second = sy + (ey-sy)/(ex-sx)*(L-sx-DX);\n\t\t}\n\t\tfor(; 1 < sz(CH) && ccw({-DX, -DY}, CH[0], CH[1]) >= 0; CH.pop_front());\n\t\tCH.ef(-DX, -DY);\n\t\tprintf(\"%.20Lf\\n\", (CH.back().second + DY) / L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<double,double>> v;\nvector<pair<double,double>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tdouble l=as[j].second;\n\t\t\tdouble val=as[j].first*l;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tint val=0,l=0;\n\t\t\tfor(int i=vcnt-101;i<vcnt-1;i++){\n\t\t\t\tval+=v[i].first;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tdouble ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b)/(b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[800005],righ[800005];\nlong double bai[800005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tfor(j=0;j<bainum;j++){\n\t\t\t\tassert(bainum <= 800005);\n\t\t\t\tif(lef[j] <= b && b <= righ[j]){\n\t\t\t\t\ttable[b] *= bai[j];\n\t\t\t\t\tif(lef[j] == b){\n\t\t\t\t\t\tlef[j]++;\n\t\t\t\t\t\tif(lef[j] > righ[j]){\n\t\t\t\t\t\t\tlef[j] = lef[bainum-1];\n\t\t\t\t\t\t\trigh[j] = righ[bainum-1];\n\t\t\t\t\t\t\tbainum--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tassert(0 == 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai[bainum] = (long double)(l - y[i]) / (long double)l;\n\t\t\tlef[bainum] = num;\n\t\t\trigh[bainum] = i;\n\t\t\tbainum++;\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntemplate<typename A, typename B> inline bool chmax(A &a, B b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<typename A, typename B> inline bool chmin(A &a, B b) { if (a>b) { a=b; return 1; } return 0; }\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<int, pii> pip;\ntypedef pair<pll, pll> P;\nconst ll INF = 1ll<<29;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-9;\nconst bool debug = 0;\n//---------------------------------//\n\nll N, L;\ndouble t[512345];\nll v[512345];\n\nint main() {\n\tcin >> N >> L;\n\tREP(i, N) scanf(\"%lf %lld\", t + i, v + i);\n\t\n\tdeque<pair<double, ll> > deq;\n\tdouble sump = 0, sumv = 0;\n\t\n\tREP(i, N) {\n\t\tsump += t[i] * v[i];\n\t\tsumv += v[i];\n\t\t\n\t\twhile (!deq.empty() && deq.back().fi > t[i]) {\n\t\t\tdouble tt = deq.back().fi;\n\t\t\tll vv = deq.back().se;\n\t\t\t\n\t\t\tt[i] = (tt * vv + t[i] * v[i]) / (vv + v[i]);\n\t\t\tv[i] = vv + v[i];\n\t\t\tdeq.pop_back();\n\t\t}\n\t\tdeq.push_back(make_pair(t[i], v[i]));\n\t\t\n\t\tprintf(\"%.15lf\\n\", sump / L);\n\t\t\n\t\tif (i < N - 1) {\n\t\t\tll diff = v[i + 1] + sumv - L;\n\t\t\twhile (!deq.empty() && diff > 0) {\n\t\t\t\tdouble tt = deq.front().fi;\n\t\t\t\tll vv = deq.front().se;\n\t\t\t\tdeq.pop_front();\n\t\t\t\t\n\t\t\t\tif (diff < vv) {\n\t\t\t\t\tvv -= diff;\n\t\t\t\t\tsump -= diff * tt;\n\t\t\t\t\tsumv -= diff;\n\t\t\t\t\tdeq.push_front(make_pair(tt, vv));\n\t\t\t\t\tdiff = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsump -= vv * tt;\n\t\t\t\t\tsumv -= vv;\n\t\t\t\t\tdiff -= vv;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint main(){\n\tint N,L; cin >> N >> L;\n\tdeque<pair<double,int>> W;\n\tdouble ans = 0.0;\n\tint c = 0;\n\trepp(i,0,N){\n\t\tdouble t; int v; cin >> t >> v;\n\t\twhile(!W.empty() && W.back().first >= t && v < L){\n\t\t\tt = (W.back().first * min(L-v,W.back().second) + t * v) / min(L,W.back().second+v);\n\t\t\tv = min(L,v+W.back().second);\n\t\t\tans -= W.back().first * W.back().second;\n\t\t\tc -= W.back().second;\n\t\t\tW.pop_back();\n\t\t}\n\t\tW.push_back(make_pair(t,v));\n\t\tans += t*v;\n\t\tc += v;\n\t\twhile(c > L){\n\t\t\tauto p = W.front(); W.pop_front();\n\t\t\tint z = c-L;\n\t\t\tans -= p.first*min(z,p.second);\n\t\t\tc = max(L,c-p.second);\n\t\t\tp.second -= z;\n\t\t\tif(p.second > 0) W.push_front(p);\n\t\t}\n\t\tcout << fixed << setprecision(12) << ans/L << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\ninline int read(){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){if(ch=='-') f=-1;ch=getchar();}\n    while(isdigit(ch)){x=(x<<3)+(x<<1)+(ch^48);ch=getchar();}\n    return x*f;\n}\nconst int N=5e5+10;\nint n,l,v[N],t[N];\nstruct node{\n\tint v;\n\tdouble t;\n}q[N];\nint L=1,R=0,sum=0;\ndouble ans;\nsigned main(){\n\tn=read(),l=read();\n\tfor(int i=1;i<=n;i++){\n\t\tt[i]=read();v[i]=read();\n\t\twhile(sum+v[i]>l){\n\t\t\tint p=min(sum+v[i]-l,q[L].v);\n\t\t\tsum-=p;\n\t\t\tq[L].v-=p;\n\t\t\tans-=p*q[L].t;\n\t\t\tif(!q[L].v)L++;\n\t\t}\n\t\tq[++R]=(node){v[i],t[i]};\n\t\tsum+=v[i];ans+=v[i]*t[i];\n\t\twhile(L<R&&q[R].t<q[R-1].t){\n\t\t\tq[R-1].t=(q[R].t*q[R].v+q[R-1].t*q[R-1].v)/(q[R].v+q[R-1].v);\n\t\t\tR--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",ans/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"data.in\",\"r\",stdin);\n   // freopen(\"data.out\",\"w\",stdout);\n#endif\n    \n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            //if (q[tail-1][1]>q[tail-2][1]) break;\n            if (S/L>q[tail-2][1]) break;\n            \n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n         q[tail-1][1]=S/L;\n       // cout << \" : \" << q[tail-1][1] << \" \" << S/L << endl;\n        //assert(q[tail-1][1] == S/L);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint T,maxl,L,l=1,r,tmp;\n\nstruct node{\n\tdouble t;\n\tint v;\n}s[500010];\n\nsigned main(){\n\tscanf(\"%lld%lld\",&T,&maxl);\n\twhile(T--){\n\t\tint t,v;\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\twhile(L+v>maxl){\n\t\t\tint out=min(s[l].v,L+v-maxl);\n\t\t\ts[l].v-=out;L-=out;\n\t\t\ttmp-=out*s[l].t;\n\t\t\tif(!s[l].v) ++l;\n\t\t}\n\t\ts[++r]=(node){t,v};\n\t\ttmp+=t*v;L+=v;\n\t\twhile(l<r&&s[r-1].t>s[r].t){\n\t\t\ts[r-1].t=(double)(s[r-1].t*s[r-1].v+s[r].t*s[r].v)/(s[r-1].v+s[r].v);\n\t\t\ts[r-1].v+=s[r].v;--r;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",(double)tmp/maxl);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    int n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n        double tempt =t;\n        if(i>1){\n            \n            \n            while(tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1.0*d1.front().second;\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=tempv;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=(long double)1.0*v*t;\n       printf(\"%.12lf\\n\",1.0*totprod/L);\n       // cout<<setprecision(20)<<totprod/L<<endl;\n       \n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=(long double)1.0*v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>t){\n                totprod-=(long double)1.0*d1.back().first*d1.back().second;\n                double tempp = (long double)1.0*tempv*tempt;\n                tempp+=(long double)1.0*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1.0*tempp)/((long double)1.0*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1.0*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INFS (1LL<<28)\n#define DEKAI 1000000007\n//#define MOD 1000000007\n#define lp(i,n) for(int i=0;i<n;i++)\n#define lps(i,n) for(int i=1;i<=n;i++)\n#define all(c) begin(c), end(c)\n\n//#define int long long \n\nnamespace {\n\t#define __DECLARE__(C)    \\\n\t    template <typename T> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T> &);\n\n\t#define __DECLAREM__(C)               \\\n\t    template <typename T, typename U> \\\n\t    std::ostream &operator<<(std::ostream &, const C<T, U> &);\n\n\t__DECLARE__(std::vector)\n\t__DECLARE__(std::deque)\n\t__DECLARE__(std::set)\n\t__DECLARE__(std::stack)\n\t__DECLARE__(std::queue)\n\t__DECLARE__(std::priority_queue)\n\t__DECLARE__(std::unordered_set)\n\t__DECLAREM__(std::map)\n\t__DECLAREM__(std::unordered_map)\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &, const std::pair<T, U> &);\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &, const std::tuple<T...> &);\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &, const std::array<T, N> &);\n\n\ttemplate <typename Tuple, std::size_t N>\n\tstruct __TuplePrinter__ {\n\t    static void print(std::ostream &os, const Tuple &t) {\n\t        __TuplePrinter__<Tuple, N - 1>::print(os, t);\n\t        os << \", \" << std::get<N - 1>(t);\n\t    }\n\t};\n\n\ttemplate <typename Tuple>\n\tstruct __TuplePrinter__<Tuple, 1> {\n\t    static void print(std::ostream &os, const Tuple &t) { os << std::get<0>(t); }\n\t};\n\n\ttemplate <typename... T>\n\tstd::ostream &operator<<(std::ostream &os, const std::tuple<T...> &t) {\n\t    os << '(';\n\t    __TuplePrinter__<decltype(t), sizeof...(T)>::print(os, t);\n\t    os << ')';\n\t    return os;\n\t}\n\n\ttemplate <typename T, typename U>\n\tstd::ostream &operator<<(std::ostream &os, const std::pair<T, U> &v) {\n\t    return os << '(' << v.first << \", \" << v.second << ')';\n\t}\n\n\t#define __INNER__                             \\\n\t    os << '[';                                \\\n\t    for (auto it = begin(c); it != end(c);) { \\\n\t        os << *it;                            \\\n\t        os << (++it != end(c) ? \", \" : \"\");   \\\n\t    }                                         \\\n\t    return os << ']';\n\n\ttemplate <typename T, std::size_t N>\n\tstd::ostream &operator<<(std::ostream &os, const std::array<T, N> &c) {\n\t    __INNER__\n\t}\n\n\t#define __DEFINE__(C)                                           \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        __INNER__                                               \\\n\t    }\n\n\t#define __DEFINEM__(C)                                             \\\n\t    template <typename T, typename U>                              \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T, U> &c) { \\\n\t        __INNER__                                                  \\\n\t    }\n\n\t#define __DEFINEW__(C, M1, M2)                                  \\\n\t    template <typename T>                                       \\\n\t    std::ostream &operator<<(std::ostream &os, const C<T> &c) { \\\n\t        std::deque<T> v;                                        \\\n\t        for (auto d = c; !d.empty(); d.pop()) v.M1(d.M2());     \\\n\t        return os << v;                                         \\\n\t    }\n\n\t__DEFINE__(std::vector)\n\t__DEFINE__(std::deque)\n\t__DEFINE__(std::set)\n\t__DEFINEW__(std::stack, push_front, top)\n\t__DEFINEW__(std::queue, push_back, front)\n\t__DEFINEW__(std::priority_queue, push_front, top)\n\t__DEFINE__(std::unordered_set)\n\t__DEFINEM__(std::map)\n\t__DEFINEM__(std::unordered_map)\n}\n\n#define pii pair<int,int>\n#define ll long long\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n\n// modint \ntemplate <signed M, unsigned T>\nstruct mod_int {\n    constexpr static signed MODULO = M;\n    constexpr static unsigned TABLE_SIZE = T;\n\n    signed x;\n\n    mod_int() : x(0) {}\n\n    mod_int(long long y) : x(static_cast<signed>(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO)) {}\n\n    mod_int(int y) : x(y >= 0 ? y % MODULO : MODULO - (-y) % MODULO) {}\n\n    mod_int &operator+=(const mod_int &rhs) {\n        if ((x += rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator-=(const mod_int &rhs) {\n        if ((x += MODULO - rhs.x) >= MODULO) x -= MODULO;\n        return *this;\n    }\n\n    mod_int &operator*=(const mod_int &rhs) {\n        x = static_cast<signed>(1LL * x * rhs.x % MODULO);\n        return *this;\n    }\n\n    mod_int &operator/=(const mod_int &rhs) {\n        x = static_cast<signed>((1LL * x * rhs.inv().x) % MODULO);\n        return *this;\n    }\n\n    mod_int operator-() const { return mod_int(-x); }\n\n    mod_int operator+(const mod_int &rhs) const { return mod_int(*this) += rhs; }\n\n    mod_int operator-(const mod_int &rhs) const { return mod_int(*this) -= rhs; }\n\n    mod_int operator*(const mod_int &rhs) const { return mod_int(*this) *= rhs; }\n\n    mod_int operator/(const mod_int &rhs) const { return mod_int(*this) /= rhs; }\n\n    bool operator<(const mod_int &rhs) const { return x < rhs.x; }\n\n    mod_int inv() const {\n        assert(x != 0);\n        if (x <= static_cast<signed>(TABLE_SIZE)) {\n            if (_inv[1].x == 0) prepare();\n            return _inv[x];\n        } else {\n            signed a = x, b = MODULO, u = 1, v = 0, t;\n            while (b) {\n                t = a / b;\n                a -= t * b;\n                std::swap(a, b);\n                u -= t * v;\n                std::swap(u, v);\n            }\n            return mod_int(u);\n        }\n    }\n\n    mod_int pow(long long t) const {\n        assert(!(x == 0 && t == 0));\n        mod_int e = *this, res = mod_int(1);\n        for (; t; e *= e, t >>= 1)\n            if (t & 1) res *= e;\n        return res;\n    }\n\n    mod_int fact() {\n        if (_fact[0].x == 0) prepare();\n        return _fact[x];\n    }\n\n    mod_int inv_fact() {\n        if (_fact[0].x == 0) prepare();\n        return _inv_fact[x];\n    }\n\n    mod_int choose(mod_int y) {\n        assert(y.x <= x);\n        return this->fact() * y.inv_fact() * mod_int(x - y.x).inv_fact();\n    }\n\n    static mod_int _inv[TABLE_SIZE + 1];\n\n    static mod_int _fact[TABLE_SIZE + 1];\n\n    static mod_int _inv_fact[TABLE_SIZE + 1];\n\n    static void prepare() {\n        _inv[1] = 1;\n        for (int i = 2; i <= (int)TABLE_SIZE; ++i) {\n            _inv[i] = 1LL * _inv[MODULO % i].x * (MODULO - MODULO / i) % MODULO;\n        }\n        _fact[0] = 1;\n        for (unsigned i = 1; i <= TABLE_SIZE; ++i) {\n            _fact[i] = _fact[i - 1] * int(i);\n        }\n        _inv_fact[TABLE_SIZE] = _fact[TABLE_SIZE].inv();\n        for (int i = (int)TABLE_SIZE - 1; i >= 0; --i) {\n            _inv_fact[i] = _inv_fact[i + 1] * (i + 1);\n        }\n    }\n};\n\ntemplate <int M, unsigned F>\nstd::ostream &operator<<(std::ostream &os, const mod_int<M, F> &rhs) {\n    return os << rhs.x;\n}\n\ntemplate <int M, unsigned F>\nstd::istream &operator>>(std::istream &is, mod_int<M, F> &rhs) {\n    long long s;\n    is >> s;\n    rhs = mod_int<M, F>(s);\n    return is;\n}\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nmod_int<M, F> mod_int<M, F>::_inv_fact[TABLE_SIZE + 1];\n\ntemplate <int M, unsigned F>\nbool operator==(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return lhs.x == rhs.x;\n}\n\ntemplate <int M, unsigned F>\nbool operator!=(const mod_int<M, F> &lhs, const mod_int<M, F> &rhs) {\n    return !(lhs == rhs);\n}\n\nconst int MF = 1000010;\nconst int MOD = 1000000007;\n\nusing mint = mod_int<MOD, MF>;\n\nmint binom(int n, int r) { return (r < 0 || r > n || n < 0) ? 0 : mint(n).choose(r); }\n\nmint fact(int n) { return mint(n).fact(); }\n\nmint inv_fact(int n) { return mint(n).inv_fact(); }\n// above\n\n#define int long long\n#define double long double \nvector<pair<double,double>> v;\nvector<pair<double,double>> as;\n\ndouble getval(int need){\n\tif(need==0)return 0;\n\tdouble ans=0;\n\tfor(int i=v.size()-1;i>=0;i--){/*\n\t\tif(i%100==0&&i!=0){\n\t\t\tint j=i/100;\n\t\t\tdouble l=as[j].second;\n\t\t\tdouble val=as[j].first*l;\n\t\t\tif(need>l){\n\t\t\t\tans+=val;\n\t\t\t\tneed-=l;\n\t\t\t\ti-=99;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}*/\n\t\tdouble l=v[i].second;\n\t\tdouble val=v[i].first*l;\n\t\tif(need<=l){\n\t\t\tans+=val*need/l;\n\t\t\treturn ans;\n\t\t}\n\t\telse{\n\t\t\tans+=val;\n\t\t\tneed-=l;\n\t\t}\n\t}\n\tassert(false);\n}\n\nsigned main(){\n\tcout<<fixed<<setprecision(10);\n\tdouble n,l;\n\tcin>>n>>l;\n\tint befg=-1,vcnt=102;\n\tlp(i,n){\n\t\tif(v.size()==vcnt){\n\t\t\tint val=0,l=0;\n\t\t\tfor(int i=vcnt-101;i<vcnt-1;i++){\n\t\t\t\tval+=v[i].first;\n\t\t\t\tl+=v[i].second;\n\t\t\t}\n\t\t\tas.push_back({val,l});\n\t\t\tvcnt+=100;\n\t\t}\n\t\tdouble a,b;\n\t\tcin>>a>>b;\n\t\tdouble x=a*b+getval(l-b);\n\t\tcout<<x/l<<endl;\n\t\tif(befg>a){\n\t\t\tint z=v.size()-1;\n\t\t\tdouble ls=v[z].second;\n\t\t\tdouble val=v[z].first*ls;\n\t\t\tdouble lbs=min(l-b,ls);\n\t\t\tdouble remv=a*b+val*(lbs)/ls;\n\t\t\tv[z]={(remv)/(lbs+b),lbs+b};\n\t\t}\n\t\telse{\n\t\t\tv.push_back({(a*b)/(b),b});\n\t\t}\n\t\tbefg=a;\n\t\t//cout<<v<<endl;\n\t}\n\treturn 0;\n}  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long i64;\ntypedef long double ld;\nld xa,ya,xm;\nstruct pos{\n\tld x,y;\n\tld operator*(const pos&w)const{return (x+xa)*(w.y+ya)-(y+ya)*(w.x+xa);}\n}ps[500007];\nint l=500000,r=500000,n,mx;\nint main(){\n\tscanf(\"%d%d\",&n,&mx);\n\txm=mx;\n\tfor(int i=1,x,y;i<=n;++i){\n\t\tscanf(\"%d%d\",&y,&x);\n\t\txa+=x,ya+=(ld)x*y;\n\t\tps[l-1]=(pos){-xa,-ya};\n\t\tif(i>1){\n\t\t\twhile(ps[r].x+xa>xm)--r;\n\t\t\tld yd=ps[r+1].y-ps[r].y,k=(xm-xa-ps[r].x)/(ps[r+1].x-ps[r].x);\n\t\t\tyd=yd*k+ps[r].y;\n\t\t\tps[++r]=(pos){xm-xa,yd};\n\t\t}\n\t\twhile(l<r&&ps[l]*ps[l+1]>0)++l;\n\t\tps[--l]=(pos){-xa,-ya};\n\t\tprintf(\"%.8Lf\\n\",(ps[r].y+ya)/(ps[r].x+xa));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\nint N,L;\nll ad = 0;\ndeque<pair<pl,ld>> cur; // x-coordinates, slope\nld fin = 0;\n\npair<pl,ld> back() {\n    auto a = cur.back(); a.f.f += ad, a.f.s += ad;\n    return a;\n}\n\nvoid pb(pair<pl,ld> p) {\n    p.f.f -= ad, p.f.s -= ad;\n    cur.pb(p);\n}\n\nvoid push_front(pair<pl,ld> p) {\n    p.f.f -= ad, p.f.s -= ad;\n    cur.push_front(p);\n}\n\nvoid process(ll T, ll V) {\n    ad += T; fin += T*V;\n    while (sz(cur)) {\n        auto a = back();\n        if (L <= a.f.f) {\n            fin -= (a.f.s-a.f.f)*a.s;\n            cur.pop_back();\n        } else {\n            fin -= (a.f.s-L)*a.s; a.f.s = L;\n            cur.pop_back(); pb(a);\n            break;\n        }\n    }\n    ll x = T; ld y = T*V;\n    while (sz(cur) && y/x <= cur.front().s) {\n        x += cur.front().f.s-cur.front().f.f;\n        y += cur.front().s*(cur.front().f.s-cur.front().f.f);\n        cur.pop_front();\n    }\n    push_front({{0,x},y/x});\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N,L);\n    cur.pb({{0,L},0});\n    cout << fixed << setprecision(10);\n    F0R(i,N) {\n        int T,V; re(T,V); swap(T,V);\n        process(T,V);\n        pr(fin/L);\n    }\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(25)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[2000005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b - 1;\n\t\t}else{\n\t\t\tbai(0,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/(long double)l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=i;j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 500200;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\ntypedef double db;\nstruct T {\n\tdb a, b;\n\tinline void operator += (const T & y) { a += y.a, b += y.b; }\n\tinline void operator -= (const T & y) { a -= y.a, b -= y.b; }\n\tinline int operator < (const T & y) const { return a / b < y.a / y.b; }\n} stack[maxn], ps[maxn];\ndb pre_b[maxn];\nint n, L;\nint top;\ninline void ins(T x) {\n\tfor(;top && x < stack[top];) x += stack[top--];\n\tstack[++top] = x, pre_b[top] = pre_b[top - 1] + x.b;\n\tps[top] = ps[top - 1], ps[top] += x;\n}\ninline db lol(db x){ return x == x ? x : 0; }\ninline db get() {\n\tint x = std::upper_bound(pre_b + 1, pre_b + top + 1, pre_b[top] - L) - pre_b;\n\tT ans = ps[top]; ans -= ps[x];\n\treturn (ans.a + (L - ans.b) / stack[x].b * stack[x].a) / L;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n >> L;\n\trep(i, 1, n) {\n\t\tint t, v;\n\t\tcin >> t >> v;\n\t\tins((T){ (db) t * v, (db) v });\n\t\tprintf(\"%.7lf\\n\", get());\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nint n; DB L, S;\ndeque<pair<DB, DB>> W;\n\nvoid pop_front(DB t, DB l){\n    S += t*l;\n    while (!W.empty()) {\n        if (sgn(l, W.front().se) > 0) {\n            l-=W.front().se; S -= W.front().fi*W.front().se;\n            W.pop_front();\n        } else {\n            W.front().se-=l; S -= W.front().fi*l;\n            break;\n        }\n    }\n}\n\nint main(){\n    \n#ifndef ONLINE_JUDGE\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"/users/minakokojima/ACM-Training/Workspace/out.txt\", \"w\", stdout);\n#endif\n    \n    RD(n, L);\n    DO(n){\n        DB t, l; RF(t, l); pop_front(t, l); OT(S/L);\n        while (!W.empty() && sgn(W.back().fi, t) >= 0){\n            DB ll = l + W.back().se;\n            t = (l*t + W.back().fi*W.back().se) / ll;\n            l = ll; W.pop_back();\n        }\n        W.PB(MP(t, l));\n        //ECH(it, W) cout << it->fi << \" \" << it->se << \")\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 500005\nusing namespace std;\ninline int read(){\n\tint sum = 0, t = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9'){ if(ch == '-') t = -1; ch = getchar(); }\n\twhile(ch >= '0' && ch <= '9'){ sum = sum * 10 + ch - '0'; ch = getchar(); }\n\treturn sum * t;\n}\n\nint n, L;\ndouble t[N], v[N];\nint q[N], h, b;\n\nint main(){\n\tn = read(), L = read();\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%lf%lf\", t + i, v + i), t[i] *= v[i];\n\th = 1; b = 0;\n\tdouble Sv = 0, St = 0;\n\tfor(int j, i = 1; i <= n; i++){\n\t\tdouble left = L - v[i];\n\t\tfor(j = q[h]; h <= b && Sv > left ; j = q[++h]){\n\t\t\tSv -= v[j];\n\t\t\tSt -= t[j];\n\t\t\tif(Sv < left){\n\t\t\t\tdouble c = (left - Sv) / v[j];\n\t\t\t\tSv += (v[j] *= c);\n\t\t\t\tSt += (t[j] *= c);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10lf\\n\", (St + t[i]) / L);\n\t\tdouble t0 = t[i], v0 = v[i];\n\t\tfor(j = q[b]; h <= b && t[j] / v[j] >= t0 / v0; j = q[--b]){\n\t\t\tt0 += t[j];\n\t\t\tv0 += v[j];\n\t\t}\n\t\tq[++b] = i;\n\t\tSt += t[i]; t[i] = t0;\n\t\tSv += v[i]; v[i] = v0;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\n//typedef pair<int, int> P;\n\nint main()\n{\n    int n; double L, s=0;\n  cin>>n>>L;\n  using P=pair<double, double>;\n  deque<P> deq;\n  for(int i=0; i<n; i++){\n    double t, v; cin>>t>>v;\n    double v1=v;\n    while(!deq.empty()){\n      P &p=deq.front();\n      if(p.second>v1){\n        p.second-=v1;\n        s-=p.first*v1;\n        break;\n      }else{\n        v1-=p.second;\n        s-=p.first*p.second;\n        deq.pop_front();\n      }\n    }\n    while(!deq.empty()){\n      P p=deq.back();\n      if(p.first<t) break;\n      double v2=v+p.second;\n      t=(p.first*p.second+v*t)/v2;\n      v=v2;\n      s-=p.first*p.second;\n      deq.pop_back();\n    }\n    s+=t*v;\n    deq.push_back({t, v});\n    printf(\"%.7lf\\n\", s/L);\n  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 500005\n#define ll long long\n#define pdl pair<double,ll>\n#define endl '\\n'\nusing namespace std;\npdl deq[maxn];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,L;\n\tcin >> n >> L;\n\tint l = 0 , r = 0;\n\tll sum_t = 0 , sum_v = 0;\n\tfor(int i=1,t,v;i<=n;i++) {\n\t\tcin >> t >> v;\n\t\twhile(l + 1 < r && deq[l+1].second + sum_v + v >= L)\tl++;\n\t\tif(l < r && deq[l].second + sum_v + v > L) {\n\t\t\tdouble T = deq[l].first + sum_t - (l + 1 < r ? deq[l+1].first + sum_t : 0);\n\t\t\tint V = deq[l].second + sum_v - (l + 1 < r ? deq[l+1].second + sum_v : 0);\n\t\t\tint sub_V = deq[l].second + sum_v - (L - v);\n\t\t\tdouble base = T / V;\n\t\t\tdeq[l].first -= base * sub_V;\n\t\t\tdeq[l].second -= sub_V;\n\t\t}\n\t\tdeq[r++] = pdl{-sum_t,-sum_v};\n\t\tsum_t += (ll)t * v;\t\tsum_v += v;\n\t\tcout << fixed << setprecision(7) << (deq[l].first + sum_t) / (deq[l].second + sum_v) << endl;\n\t\twhile(l < r - 1 && (deq[r-2].first + sum_t) / (deq[r-2].second + sum_v) > (deq[r-1].first + sum_t) / (deq[r-1].second + sum_v))\tr--;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, double> pairID;\n#define FOR(i,n) for(int i=0; i<int(n); i++)\n#define FOR1(i,m,n) for(int i=int(m); i<int(n); i++)\n\nint N, L;\ndeque<pairID> A;\n\nint main(int argc, char *argv[])\n{\n    int t, v;\n    double total_heat;\n\n    scanf(\"%d%d\", &N, &L);\n    scanf(\"%d%d\", &t, &v);\n    \n    A.push_front(make_pair(v, t));\n    total_heat = (double)v * t;\n    printf(\"%.7f\\n\", total_heat / L);\n    \n    FOR1(i,1,N) {\n        pairID back;\n        int vol;\n\n        scanf(\"%d%d\", &t, &v);\n        total_heat += (double)v * t;\n        \n        vol = v;\n        while (vol >= 0) {\n            back = A.back();\n            A.pop_back();\n            vol -= back.first;\n            total_heat -= back.first * back.second;\n        }\n        A.push_back(make_pair(-vol, back.second));\n        total_heat += -vol * back.second;\n\n        double heat = v * t;\n        vol = v;\n        pairID front;\n        while(true && A.size() > 0) {\n            front = A.front();\n            if (heat / vol > front.second) {\n                A.push_front(make_pair(vol, heat / vol));\n                break;\n            }\n            heat += front.first * front.second;\n            vol += front.first;\n            A.pop_front();\n        }\n\n        printf(\"%.7f\\n\", total_heat / L);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//written by syzs\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e5+25;\nlong long l,r,tott,tem[N],vol[N],n,L,sum;\nstruct dsa{\n\tlong long v;\n\tdouble t;\n} a[N];\nint main(){\n\tcin>>n>>L;\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld\",&tem[i],&vol[i]);\n\tfor(int i=1;i<=n;i++){\n\t\twhile(sum+vol[i]>L){//当水溢出时，优先把单调队列的前几份水排空 \n\t        int rea=min(sum+vol[i]-L,a[l].v);\n\t        a[l].v-=rea;\n\t        sum-=rea;\n\t        tott-=rea*a[l].t;\n\t        if(!a[l].v) l++;\n\t\t}\n\t\tsum+=vol[i];\n\t\ttott+=vol[i]*tem[i];\n\t\ta[++r].v=vol[i];\n\t\ta[r].t=tem[i];\n\t\twhile(l<r&&a[r].t<a[r-1].t){//考虑混合 \n\t\t\ta[r-1].t=(a[r].t*a[r].v+a[r-1].t*a[r-1].v)/(a[r-1].v+a[r].v);\n\t\t\ta[r-1].v=a[r-1].v+a[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.10lf\\n\",(double)tott/L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-6;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,1,1,1,0},DY[8]={1,0,-1,-1,-1,0,1,1};\n\nint n;\ndouble l;\n\nint main(){\n\tcout<<syosu(9);\n\tcin>>n>>l;\n\tdeque<pdd> deq;\n\tdouble sx=0,sy=0,t,v;\n\tcin>>t>>v;\n\tdeq.push_back({0,0});\n\tcout<<t<<endl;\n\tsx+=v;\n\tsy+=t*v;\n\tdeq.push_front({-sx,-sy});\n\tfor(int i=1;i<n;i++){\n\t\tcin>>t>>v;\n\t\tsx+=v;\n\t\tsy+=t*v;\n\t\tpdd p;\n\t\tdouble L=l-sx;\n\t\twhile(deq.back().first-eps>L){\n\t\t\tp=deq.back();\n\t\t\tdeq.pop_back();\n\t\t}\n\t\tpdd tmp=deq.back();\n\t\tdouble lx=tmp.first,ly=tmp.second,rx=p.first,ry=p.second;\n\t\tdeq.push_back({L,(ry-ly)*(L-lx)/(rx-lx)+ly});\n\t\tcout<<(deq.back().second+sy)/l<<endl;\n\t\twhile(deq.size()>1){\n\t\t\ttmp=deq.front();\n\t\t\tdeq.pop_front();\n\t\t\tp=deq.front();\n\t\t\tlx=tmp.first,ly=tmp.second,rx=p.first,ry=p.second;\n\t\t\tif((ly+sy)/(lx+sx)>(ry+sy)/(rx+sx)-eps){\n\t\t\t\tdeq.push_front(tmp);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdeq.push_front({-sx,-sy});\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing std::min;\nusing std::max;\nusing std::pair; \nusing std::make_pair; \n\ntypedef long long LL;\nconst int N=5e5+10;\n\nint n,l,t[N];\nLL v[N];\ndouble sum[N],f[N];\n\nvoid Init() {\n\tscanf(\"%d%d\",&n,&l);\n\tfor (int i=1;i<=n;++i) scanf(\"%d%lld\",&t[i],&v[i]);\n}\n\npair<int,double>que[N];\nvoid Solve() {\n\tint nowv=0; double sum=0;\n\tint h=1,ti=0;\n\tfor (int i=1;i<=n;++i) {\n\t\tnowv+=v[i]; sum+=1.0*v[i]*t[i]/l;\n\t\twhile (h<=ti && nowv>l) {\n\t\t\tint del=min(nowv-l,que[h].first);\n\t\t\tnowv-=del; sum-=1.0*que[h].second*del/l;\n\t\t\tif (que[h].first==del) ++h;else que[h].first-=del; \n\t\t}\n\t\tprintf(\"%.7f\\n\",sum);\n\t\tint _v=v[i];double _t=t[i];\n\t\twhile (h<=ti && que[ti].second>=_t) {\n\t\t\t_t=(que[ti].first*que[ti].second+_v*_t)/(_v+que[ti].first);\n\t\t\t_v=que[ti].first+_v;\n\t\t\t--ti; \n\t\t}\n\t\tque[++ti]=make_pair(_v,_t); \n\t}\n}\n\nint main() {\n\tInit();\n\tSolve();\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nlong long n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tlong long v;\n} q[N];\ndouble t;\nlong long v;\nlong long head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%lld%lld\",&n,&l);\n\tscanf(\"%lf%lld\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=1ll*q[1].t*q[1].v;\n\tfor(long long i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%lld\",&t,&v);\n\t\tlong long cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=1ll*q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=1ll*q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=1ll*t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttail++;\n\t\t\tsum+=1ll*t*v;\n\t\t\tq[tail].t=sum/l;\n\t\t\tq[tail].v=l;\n\t\t\thead=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<deque>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef double Real;\n\nlong long ts[500500];\nlong long vs[500500];\nReal vals[500500];\nint N;\nlong long L;\n\nvoid input(){\n\tscanf(\"%d%lld\", &N, &L);\n\tfor(int i = 0; i < N; ++i){\n\t\tscanf(\"%lld%lld\", ts + i, vs + i);\n\t}\n}\n\ntypedef pair<long long, Real> P;\n\ndeque<P> deq;\n\nReal ans[500500];\n\nbool check(P p1, P p2, P p3){\n\tReal dx1 = p2.first - p1.first;\n\tReal dy1 = p2.second - p1.second;\n\tReal dx2 = p3.first - p1.first;\n\tReal dy2 = p3.second - p1.second;\n\treturn (dx1 * dy2 - dx2 * dy1 >= 0);\n}\n\nReal f(Real x, Real y, Real a, Real b){\n\t//printf(\"%f %f %f %f\\n\", x, y, a, b);\n\treturn x + (y - x) * (a / (a + b));\n}\n\nvoid solve(){\n\tfor(int i = 0; i < N; ++i){\n\t\tvals[i] = (Real)ts[i] * vs[i];\n//\t\tprintf(\"%f\\n\", vals[i]);\n\t}\n\tans[0] = ts[0];\n\tdeq.push_front(P(0, 0));\n\tdeq.push_back(P(L, vals[0]));\n\tfor(int i = 1; i < N; ++i){\n\t\tif(vs[i] == L){\n\t\t\tP fi = deq[0];\n\t\t\tP nfi = P(fi.first - vs[i], fi.second - vals[i]);\n\t\t\twhile(deq.size() >= 2){\n\t\t\t\tdeq.pop_back();\n\t\t\t}\n\t\t\tdeq.push_front(nfi);\n\t\t\tans[i] = ts[i];\n\t\t\tcontinue;\n\t\t}\n\t\tlong long ub = deq[0].first + L - vs[i];\n\t\twhile(deq.back().first > ub){\n\t\t\tP tmp = deq.back();\n\t\t\tdeq.pop_back();\n\t\t\tif(deq.back().first > ub){\n\t\t\t\tcontinue;\n\t\t\t}else if(deq.back().first == ub){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tReal nxt = f(deq.back().second, tmp.second, ub - deq.back().first, tmp.first - ub);\n\t\t\t\tdeq.push_back(P(ub, nxt));\n//\t\t\t\tprintf(\"%f\\n\", nxt);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tP fi = deq[0];\n\t\tP nfi = P(fi.first - vs[i], fi.second - vals[i]);\n\t\twhile(deq.size() >= 2){\n\t\t\tif(check(nfi, deq[0], deq[1])){\n\t\t\t\tdeq.pop_front();\n\t\t\t}else{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdeq.push_front(nfi);\n\t\tReal val = deq.back().second - deq[0].second;\n\t\tans[i] = val / L;\n\t}\n}\n\nint main(){\n\tinput();\n\tsolve();\n\tfor(int i = 0; i < N; ++i){\n\t\tprintf(\"%.12f\\n\", ans[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<bitset>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<complex>\n#include<iostream>\n#include<algorithm>\n#define ll long long \nusing namespace std;\n\nconst int maxn = 510000;\n\nint n,L;\nstruct node{double x,y;}a[maxn<<1]; int head,tail;\n\ndouble multi(node x,node y,node z)\n{\n\tx.x-=z.x; x.y-=z.y;\n\ty.x-=z.x; y.y-=z.y;\n\treturn x.x*y.y-x.y*y.x;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&L); n--;\n\ta[head=maxn]=(node){0.0,0.0};\n\tll x,y;\n\ttail=head+1; scanf(\"%lld%lld\",&y,&x);\n\tprintf(\"%lf\\n\",(double)y); a[tail].y=(double)x*y; a[tail].x=x;\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld\",&y,&x); y*=x;\n\t\tnode now=(node){a[head].x-(double)x,a[head].y-(double)y};\n\t\twhile(head+1<=tail&&a[tail-1].x-now.x>=L) tail--;\n\t\tif(head!=tail)\n\t\t{\n\t\t\tdouble pt=(a[tail].y-a[tail-1].y)/(a[tail].x-a[tail-1].x);\n\t\t\tif(a[tail].x-now.x>L)\n\t\t\t{\n\t\t\t\ta[tail].y=a[tail-1].y+(L-(a[tail-1].x-now.x))*pt;\n\t\t\t\ta[tail].x=now.x+L;\n\t\t\t}\n\t\t}\n\t\twhile(head+1<=tail&&multi(a[head],a[head+1],now)>=0) head++;\n\t\ta[--head]=now;\n\t\tdouble kk=a[tail].y-now.y;\n\t\tprintf(\"%lf\\n\",kk/(double)L);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define HEAP(...) priority_queue<__VA_ARGS__ >\n#define heap(...) priority_queue<__VA_ARGS__,vector<__VA_ARGS__ >,greater<__VA_ARGS__ > > \n#define pii pair<int,int> \n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout)\n#define SZ(x) ((int)x.size())\nusing namespace std;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\nconst int BufferSize=1<<16;\nchar buffer[BufferSize],*Bufferhead,*Buffertail;\nbool Terminal;\ninline char Getchar(){\n\tif(Bufferhead==Buffertail){\n\t\tint l=fread(buffer,1,BufferSize,stdin);\n\t\tif(!l){Terminal=1;return 0;}\n\t\tBuffertail=(Bufferhead=buffer)+l;\n\t}\n\treturn *Bufferhead++;\n}\ntemplate<class T>inline bool read(T &x){\n\tx=0;char c=Getchar(),rev=0;\n\twhile(c<'0'||c>'9'){rev|=c=='-';c=Getchar();if(Terminal)return 0;}\n\twhile(c>='0'&&c<='9') x=x*10+c-'0',c=Getchar();\n\tif(c=='.'){\n\t\tc=Getchar();double t=0.1;\n\t\twhile(c>='0'&&c<='9') x=x+(c-'0')*t,c=Getchar(),t=t/10;\n\t}\n\tx=rev?-x:x;\n\treturn 1;\n}\ntemplate<class T1,class T2> inline bool read(T1 &x,T2 &y){return read(x)&read(y);}\ntemplate<class T1,class T2,class T3> inline bool read(T1 &x,T2 &y,T3 &z){return read(x)&read(y)&read(z);}\ntemplate<class T1,class T2,class T3,class T4> inline bool read(T1 &x,T2 &y,T3 &z,T4 &w){return read(x)&read(y)&read(z)&read(w);}\ninline bool reads(char *x){\n\tchar c=Getchar();\n\twhile(c<33||c>126){c=Getchar();if(Terminal)return 0;}\n\twhile(c>=33&&c<=126) (*x++)=c,c=Getchar();\n\t*x=0;return 1;\n}\ntemplate<class T>inline void print(T x,const char c='\\n'){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[20];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\n//--------------------------------head---------------------------------------------\n\nconst double eps=1e-12;\nconst int inf=0x3f3f3f3f;\nconst int N=500005,M=100005,mod=1e9+7;\ntemplate<class T,class S> inline void ch(T &x,const S y){x=(x+y)%mod;}\ninline int exp(int x,int y,const int mod=::mod){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nstruct node{double x,y;}now,q[N];\nint n,L,head=500001,tail=500000;\n\ninline node operator + (const node &a,const node &b){return (node){a.x+b.x,a.y+b.y};}\ninline node operator - (const node &a,const node &b){return (node){a.x-b.x,a.y-b.y};}\ninline node operator * (const node &a,const double &b){return (node){a.x*b,a.y*b};}\n\nint main(){\n#ifdef rqgao2014\n\tassert(freopen(\"input.txt\",\"r\",stdin));\n#endif\n\tscanf(\"%d%d\",&n,&L);\n\tfor(int i=1;i<=n;i++){\n\t\tnode p;scanf(\"%lf%lf\",&p.y,&p.x);\n\t\tp.y*=p.x;now=now+p;\n\t\twhile(head<=tail&&now.x>L+eps)\n\t\t\tif(now.x-q[tail].x>L+eps) now=now-q[tail],tail--; else{\n\t\t\t\tnow=now-q[tail];\n\t\t\t\tq[tail]=q[tail]*((L-now.x)/q[tail].x);\n\t\t\t\tnow=now+q[tail];\n\t\t\t\tbreak;\n\t\t\t}\n\t\tprintf(\"%.9f\\n\",now.y/now.x);\n\t\twhile(head<=tail&&p.y/p.x<q[head].y/q[head].x) p=p+q[head],head++;\n\t\tq[--head]=p;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing lint = long long;\nusing plint = pair<double, lint>;\n\nint N;\nlint L;\n\narray<plint, 500000> deq;\nint s = 0;\nint t = -1;\n\ndouble Qsum = 0;\nlint Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        lint nuku = min(Vnow - L, deq[s].second);\n        deq[s].second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq[s].first;\n        if (deq[s].second == 0) s++;\n    }\n}\n\nvoid add(double tadd, lint vadd)\n{\n    if (deq[t].first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        t++; deq[t] = plint(tadd, vadd);\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq[t].second + vadd >= L)\n        {\n            Qsum = deq[t].first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            s = 0, t = -1;\n            t++; deq[t] = plint(Qsum / L, L);\n        }\n        else\n        {\n            double Qaddnew = deq[t].first * deq[t].second + tadd * vadd;\n            lint vaddnew = deq[t].second + vadd;\n            Qsum -= deq[t].first * deq[t].second;\n            Vnow -= deq[t].second;\n            t--;\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\narray<double, 500000> res;\n\nint main()\n{\n    cin.tie(0); ios::sync_with_stdio(0);\n    cin >> N >> L;\n    REP(i, N)\n    {\n        double tmp;\n        lint v;\n        cin >> tmp >> v;\n\n        if (i == 0)\n        {\n            t++; deq[t] = plint(tmp, v);\n            Qsum = tmp * v;\n            Vnow = v;\n        }\n        else add(tmp, v);\n\n        res[i] = Qsum / L;\n    }\n    REP(i, N) cout << setprecision(12) << res[i] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <algorithm>\n#include <vector>\n#include <deque> \nusing namespace std;\n\nint main()\n{\n    // 整数の入力\n    long long  N,V,L,i,j;\n    double T;\n    double totalQ;\n    cin >> N >> L;\n    deque<int> VList;\n    deque<double> TList;\n\n    cin >> T >> V;\n    TList.push_front(T);\n    VList.push_front(V);\n    totalQ = T*V;\n    cout << fixed << T << endl;\n    for (i=1;i<N;i++){\n        cin >> T >> V;\n        int tempV = V;\n        while (tempV> 0){\n            if (tempV > VList.back()){\n                tempV = tempV- VList.back();\n                totalQ = totalQ - VList.back() * TList.back();\n                VList.pop_back();\n                TList.pop_back();\n            }else{\n                VList.back() = VList.back() - tempV;\n                totalQ = totalQ - tempV * TList.back();\n                tempV = 0;\n            }\n        }\n\n        if (VList.size() == 0){\n            TList.push_front(T);\n            VList.push_front(V);\n            totalQ = T*V;\n        }else{\n            totalQ += T*V;\n            while (T <= TList[0]){\n                T = (T*V+TList[0]*VList[0])/(V+VList[0]);\n                V = V+VList[0];\n                TList.pop_front();\n                VList.pop_front();\n            }\n            TList.push_front(T);\n            VList.push_front(V);\n        }\n\n        cout << fixed << totalQ/L << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<cassert>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"data.in\",\"r\",stdin);\n   // freopen(\"data.out\",\"w\",stdout);\n#endif\n    \n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n        assert(q[tail-1][1] == S/L);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fr first\n#define sc second\n#define mk make_pair\n\nusing namespace std;\n\nint n;\ndouble t, v, l;\ndeque<pair<double, double> > dq;\n\nint main()\n{\n    cin >> n >> l;\n    for(int i = 1; i <= n; i++)\n    {\n        double a, b;\n        cin >> a >> b;\n        if(b == l)\n        {\n            t = v = 0;\n            dq.clear();\n        }\n        while(v + b > l && dq.size() != 0)\n        {\n            double t1 = dq.front().fr;\n            double v1 = min(dq.front().sc, v + b - l);\n\n            t = (t * v - t1 * v1) / (v - v1);\n            v = v - v1;\n\n            if(v1 == dq.front().sc)\n                dq.pop_front();\n            else\n            {\n                dq.front().sc -= v1;\n                break;\n            }\n        }\n\n        t = (t * v + a * b) / (v + b);\n        v = v + b;\n\n        cout << fixed << setprecision(6) << t << endl;\n\n        while( dq.size() != 0)\n        {\n            //cout << \"&\";\n            double t1 = dq.back().fr;\n            double v1 = dq.back().sc;\n\n            if(t1 < a)\n                break;\n\n            a = (a * b + t1 * v1) / (v1 + b);\n            b = v1 + b;\n            dq.pop_back();\n        }\n        dq.push_back(mk(a, b));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\nconst int N = 5e5 + 5;\ntypedef long long ll; \nusing namespace std;\n\nint n, l, r;\nll lim, v[N], m, t[N]; \ndouble Q; \nstruct node\n{\n\tll v; double t;\n\tnode(ll x = 0, double y = 0) { v = x, t = y; }\n} q[N]; \n\ntemplate < typename T >\ninline T read()\n{\n\tT x = 0, w = 1; char c = getchar();\n\twhile(c < '0' || c > '9') { if(c == '-') w = -1; c = getchar(); }\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn x * w; \n}\n\nint main()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"cpp.in\", \"r\", stdin); \n#endif\n\tn = read <int> (), m = read <int> (); \n\tfor(int i = 1; i <= n; i++) t[i] = read <ll> (), v[i] = read <ll> (); \n\tl = 1, r = 0; ll mn; \n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\twhile(lim + v[i] > m)\n\t\t{\n\t\t\tmn = min(lim + v[i] - m, q[l].v), lim -= mn; \n\t\t\tq[l].v -= mn, Q -= q[l].t * mn;\n\t\t\tif(!q[l].v) l++; \n\t\t}\n\t\tq[++r] = node(v[i], t[i]), Q += 1.0 * t[i] * v[i], lim += v[i]; \n\t\twhile(l < r && q[r].t < q[r - 1].t)\n\t\t{\n\t\t\tq[r - 1].t = (q[r - 1].t * q[r - 1].v + q[r].t * q[r].v) / (q[r - 1].v + q[r].v);\n\t\t\tq[r - 1].v += q[r].v, r--; \n\t\t}\n\t\tprintf(\"%.6lf\\n\", Q / m); \n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 500005\nusing namespace std;\nint n,l;\nstruct point{\n\tdouble x,y;\n\tpoint(){}\n\tpoint(double x,double y):x(x),y(y){}\n\tfriend point operator+(const point &a,const point &b)  {return point(a.x+b.x,a.y+b.y);}\n\tfriend point operator-(const point &a,const point &b)  {return point(a.x-b.x,a.y-b.y);}\n\tfriend double dot(const point &a,const point &b)  {return a.x*b.x+a.y*b.y;}\n\tfriend double cross(const point &a,const point &b)  {return a.x*b.y-a.y*b.x;}\n}p[N],Q[N];\nint main(){\n\tint x,y,L=0,R=0;\n\tscanf(\"%d%d\",&n,&l);\n\tpoint O=point(0,0);\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&y,&x);\n\t\tp[i]=point(O.x-x,O.y-(1.0*x*y)),O=p[i];\n\t\twhile(L<R&&Q[L+1].x-p[i].x>=l)  L++;\n\t\tif(L!=R&&Q[L].x-p[i].x>l){\n\t\t\tdouble slope=(Q[L].y-Q[L+1].y)/(Q[L].x-Q[L+1].x);\n\t\t\tQ[L]=point(p[i].x+l,Q[L+1].y+(l-(Q[L+1].x-p[i].x))*slope);\n\t\t}\n\t\twhile(L<R&&cross(Q[R]-p[i],Q[R-1]-p[i])>=0)  R--;\n\t\tQ[++R]=p[i];\n\t\tprintf(\"%lf\\n\",(Q[L].y-p[i].y)/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<queue>\nusing namespace std;\nvoid read(int &x){\n\tchar ch;bool ok;\n\tfor(ok=0,ch=getchar();!isdigit(ch);ch=getchar())if(ch=='-')ok=1;\n\tfor(x=0;isdigit(ch);x=x*10+ch-'0',ch=getchar());if(ok)x=-x;\n}\n#define rg register\nconst int maxn=5e5+10;\nint n,m;\nlong double sum,now,a[maxn],b[maxn],ans[maxn];\nstruct oo{long double a,b;}q[maxn];\nint main(){\n\tread(n),read(m);\n\tfor(rg int i=1,x,y;i<=n;i++)read(x),read(y),a[i]=x,b[i]=y;\n\tint l=1,r=0;ans[1]=a[1];\n\tfor(rg int i=1;i<=n;i++){\n\t\tsum=sum+a[i]*b[i],now=now+b[i];\n\t\tq[++r]=(oo){a[i],b[i]};\n\t\twhile(l<=r){\n\t\t\tif(now<=m)break;\n\t\t\tif(now-q[l].b<m){\n\t    \t\tsum=sum-q[l].b*q[l].a;\n\t\t\t\tq[l].b=q[l].b-(now-m);\n\t\t\t\tsum=sum+q[l].b*q[l].a;\n\t\t\t\tnow=m;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse now-=q[l].b,sum-=q[l].b*q[l].a,l++;\n\t\t}\n\t\t//printf(\"%d %.6lf %.0lf\\n\",l,sum,now);\n\t\tans[i]=sum/m;\n\t\twhile(l<=r&&q[r].a<q[r-1].a){\n\t\t\tlong double tot=q[r-1].b+q[r].b;\n\t\t\tsum=sum-q[r].a*q[r].b-q[r-1].a*q[r-1].b,now=now-q[r].b-q[r-1].b;\n\t\t    q[r-1].a=(q[r].a*q[r].b+q[r-1].a*(tot-q[r].b))/tot;\n\t\t\tq[r-1].b=tot;\n\t\t\tsum=sum+q[r-1].a*q[r-1].b,now=now+q[r-1].b;\n\t\t    r--;\n\t\t}\n\t}\n\tfor(rg int i=1;i<=n;i++)printf(\"%.6Lf\\n\",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\nlong double sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttail++;\n\t\t\tsum+=t*v;\n\t\t\tq[tail].t=sum/l;\n\t\t\tq[tail].v=l;\n\t\t\thead=tail;\n\t\t}\n\t\tprintf(\"%.7Lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,a,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\ttable[b] -= min((long double)a,table[b]);\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1.0*d1.front().second;\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1.0*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=(long double)1.0*v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=(long double)1.0*v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>t){\n                totprod-=(long double)1.0*d1.back().first*d1.back().second;\n                double tempp = (long double)1.0*tempv*tempt;\n                tempp+=(long double)1.0*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1.0*tempp)/((long double)1.0*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1.0*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n This code has been written by MinakoKojima, feel free to ask me question. Blog: http://www.shuizilong.com/house\n Template Date: 2015.10.12\n Note: ...\n */\n\n#pragma comment(linker, \"/STACK:36777216\")\n//#pragma GCC optimize (\"O2\")\n#define LOCAL\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <numeric>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctime>\n#include <list>\n#include <set>\n#include <map>\n\n//#include <tr1/unordered_set>\n//#include <tr1/unordered_map>\n//#include <array>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0;i<n;++i)\n#define FOR(i, a, b) for (int i=a;i<b;++i)\n#define DWN(i, b, a) for (int i=b-1;i>=a;--i)\n#define REP_1(i, n) for (int i=1;i<=n;++i)\n#define FOR_1(i, a, b) for (int i=a;i<=b;++i)\n#define DWN_1(i, b, a) for (int i=b;i>=a;--i)\n#define REP_C(i, n) for (int n____=n,i=0;i<n____;++i)\n#define FOR_C(i, a, b) for (int b____=b,i=a;i<b____;++i)\n#define DWN_C(i, b, a) for (int a____=a,i=b-1;i>=a____;--i)\n#define REP_N(i, n) for (i=0;i<n;++i)\n#define FOR_N(i, a, b) for (i=a;i<b;++i)\n#define DWN_N(i, b, a) for (i=b-1;i>=a;--i)\n#define REP_1_C(i, n) for (int n____=n,i=1;i<=n____;++i)\n#define FOR_1_C(i, a, b) for (int b____=b,i=a;i<=b____;++i)\n#define DWN_1_C(i, b, a) for (int a____=a,i=b;i>=a____;--i)\n#define REP_1_N(i, n) for (i=1;i<=n;++i)\n#define FOR_1_N(i, a, b) for (i=a;i<=b;++i)\n#define DWN_1_N(i, b, a) for (i=b;i>=a;--i)\n#define REP_C_N(i, n) for (int n____=(i=0,n);i<n____;++i)\n#define FOR_C_N(i, a, b) for (int b____=(i=0,b);i<b____;++i)\n#define DWN_C_N(i, b, a) for (int a____=(i=b-1,a);i>=a____;--i)\n#define REP_1_C_N(i, n) for (int n____=(i=1,n);i<=n____;++i)\n#define FOR_1_C_N(i, a, b) for (int b____=(i=a,b);i<=b____;++i)\n#define DWN_1_C_N(i, b, a) for (int a____=(i=b,a);i>=a____;--i)\n\n#define ECH(it, A) for (__typeof((A).begin()) it=(A).begin(); it != (A).end(); ++it)\n#define rECH(it, A) for (__typeof((A).rbegin()) it=(A).rbegin(); it != (A).rend(); ++it)\n#define REP_S(i, str) for (char*i=str;*i;++i)\n#define REP_L(i, hd, suc) for (int i=hd;i;i=suc[i])\n#define REP_G(i, u) REP_L(i,hd[u],suc)\n#define REP_SS(x, s) for (int x=s;x;x=(x-1)&s)\n#define DO(n) for ( int ____n = n; ____n-->0; )\n#define REP_2(i, j, n, m) REP(i, n) REP(j, m)\n#define REP_2_1(i, j, n, m) REP_1(i, n) REP_1(j, m)\n#define REP_3(i, j, k, n, m, l) REP(i, n) REP(j, m) REP(k, l)\n#define REP_3_1(i, j, k, n, m, l) REP_1(i, n) REP_1(j, m) REP_1(k, l)\n#define REP_4(i, j, k, ii, n, m, l, nn) REP(i, n) REP(j, m) REP(k, l) REP(ii, nn)\n#define REP_4_1(i, j, k, ii, n, m, l, nn) REP_1(i, n) REP_1(j, m) REP_1(k, l) REP_1(ii, nn)\n\n#define ALL(A) A.begin(), A.end()\n#define LLA(A) A.rbegin(), A.rend()\n#define CPY(A, B) memcpy(A, B, sizeof(A))\n#define INS(A, P, B) A.insert(A.begin() + P, B)\n#define ERS(A, P) A.erase(A.begin() + P)\n#define LBD(A, x) (lower_bound(ALL(A), x) - A.begin())\n#define UBD(A, x) (upper_bound(ALL(A), x) - A.begin())\n#define CTN(T, x) (T.find(x) != T.end())\n#define SZ(A) int((A).size())\n#define PB push_back\n#define MP(A, B) make_pair(A, B)\n#define PTT pair<T, T>\n#define Ts *this\n#define rTs return Ts\n#define fi first\n#define se second\n#define re real()\n#define im imag()\n\n#define Rush for(int ____T=RD(); ____T--;)\n#define Display(A, n, m) {                      \\\nREP(i, n){\t\t                            \\\nREP(j, m-1) cout << A[i][j] << \" \";     \\\ncout << A[i][m-1] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n#define Display_1(A, n, m) {                    \\\nREP_1(i, n){\t\t                        \\\nREP_1(j, m-1) cout << A[i][j] << \" \";   \\\ncout << A[i][m] << endl;\t\t        \\\n}\t\t\t\t\t\t                    \\\n}\n\ntypedef long long LL;\n//typedef long double DB;\ntypedef double DB;\ntypedef unsigned uint;\ntypedef unsigned long long uLL;\n\ntypedef vector<int> VI;\ntypedef vector<char> VC;\ntypedef vector<string> VS;\ntypedef vector<LL> VL;\ntypedef vector<DB> VF;\ntypedef set<int> SI;\ntypedef set<string> SS;\ntypedef map<int, int> MII;\ntypedef map<string, int> MSI;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef vector<PII> VII;\ntypedef vector<VI> VVI;\ntypedef vector<VII> VVII;\n\ntemplate<class T> inline T& RD(T &);\ntemplate<class T> inline void OT(const T &);\n//inline int RD(){int x; return RD(x);}\ninline LL RD(){LL x; return RD(x);}\ninline DB& RF(DB &);\ninline DB RF(){DB x; return RF(x);}\ninline char* RS(char *s);\ninline char& RC(char &c);\ninline char RC();\ninline char& RC(char &c){scanf(\" %c\", &c); return c;}\ninline char RC(){char c; return RC(c);}\n//inline char& RC(char &c){c = getchar(); return c;}\n//inline char RC(){return getchar();}\n\ntemplate<class T> inline T& RDD(T &);\ninline LL RDD(){LL x; return RDD(x);}\n\ntemplate<class T0, class T1> inline T0& RD(T0 &x0, T1 &x1){RD(x0), RD(x1); return x0;}\ntemplate<class T0, class T1, class T2> inline T0& RD(T0 &x0, T1 &x1, T2 &x2){RD(x0), RD(x1), RD(x2); return x0;}\ntemplate<class T0, class T1, class T2, class T3> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3){RD(x0), RD(x1), RD(x2), RD(x3); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5); return x0;}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline T0& RD(T0 &x0, T1 &x1, T2 &x2, T3 &x3, T4 &x4, T5 &x5, T6 &x6){RD(x0), RD(x1), RD(x2), RD(x3), RD(x4), RD(x5), RD(x6); return x0;}\ntemplate<class T0, class T1> inline void OT(const T0 &x0, const T1 &x1){OT(x0), OT(x1);}\ntemplate<class T0, class T1, class T2> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2){OT(x0), OT(x1), OT(x2);}\ntemplate<class T0, class T1, class T2, class T3> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3){OT(x0), OT(x1), OT(x2), OT(x3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void OT(const T0 &x0, const T1 &x1, const T2 &x2, const T3 &x3, const T4 &x4, const T5 &x5, const T6 &x6){OT(x0), OT(x1), OT(x2), OT(x3), OT(x4), OT(x5), OT(x6);}\ninline char& RC(char &a, char &b){RC(a), RC(b); return a;}\ninline char& RC(char &a, char &b, char &c){RC(a), RC(b), RC(c); return a;}\ninline char& RC(char &a, char &b, char &c, char &d){RC(a), RC(b), RC(c), RC(d); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e){RC(a), RC(b), RC(c), RC(d), RC(e); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f); return a;}\ninline char& RC(char &a, char &b, char &c, char &d, char &e, char &f, char &g){RC(a), RC(b), RC(c), RC(d), RC(e), RC(f), RC(g); return a;}\ninline DB& RF(DB &a, DB &b){RF(a), RF(b); return a;}\ninline DB& RF(DB &a, DB &b, DB &c){RF(a), RF(b), RF(c); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d){RF(a), RF(b), RF(c), RF(d); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e){RF(a), RF(b), RF(c), RF(d), RF(e); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f); return a;}\ninline DB& RF(DB &a, DB &b, DB &c, DB &d, DB &e, DB &f, DB &g){RF(a), RF(b), RF(c), RF(d), RF(e), RF(f), RF(g); return a;}\ninline void RS(char *s1, char *s2){RS(s1), RS(s2);}\ninline void RS(char *s1, char *s2, char *s3){RS(s1), RS(s2), RS(s3);}\ntemplate<class T0,class T1>inline T0& RDD(T0&a, T1&b){RDD(a),RDD(b); return a;}\ntemplate<class T0,class T1,class T2>inline T1& RDD(T0&a, T1&b, T2&c){RDD(a),RDD(b),RDD(c); return a;}\n\ntemplate<class T> inline void RST(T &A){memset(A, 0, sizeof(A));}\ntemplate<class T> inline void FLC(T &A, int x){memset(A, x, sizeof(A));}\ntemplate<class T> inline void CLR(T &A){A.clear();}\n\ntemplate<class T0, class T1> inline void RST(T0 &A0, T1 &A1){RST(A0), RST(A1);}\ntemplate<class T0, class T1, class T2> inline void RST(T0 &A0, T1 &A1, T2 &A2){RST(A0), RST(A1), RST(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3){RST(A0), RST(A1), RST(A2), RST(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void RST(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){RST(A0), RST(A1), RST(A2), RST(A3), RST(A4), RST(A5), RST(A6);}\ntemplate<class T0, class T1> inline void FLC(T0 &A0, T1 &A1, int x){FLC(A0, x), FLC(A1, x);}\ntemplate<class T0, class T1, class T2> inline void FLC(T0 &A0, T1 &A1, T2 &A2, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x);}\ntemplate<class T0, class T1, class T2, class T3> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void FLC(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6, int x){FLC(A0, x), FLC(A1, x), FLC(A2, x), FLC(A3, x), FLC(A4, x), FLC(A5, x), FLC(A6, x);}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, less<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(priority_queue<T, vector<T>, greater<T> > &Q){while (!Q.empty()) Q.pop();}\ntemplate<class T> inline void CLR(stack<T> &S){while (!S.empty()) S.pop();}\ntemplate<class T> inline void CLR(queue<T> &Q){while (!Q.empty()) Q.pop();}\n\ntemplate<class T0, class T1> inline void CLR(T0 &A0, T1 &A1){CLR(A0), CLR(A1);}\ntemplate<class T0, class T1, class T2> inline void CLR(T0 &A0, T1 &A1, T2 &A2){CLR(A0), CLR(A1), CLR(A2);}\ntemplate<class T0, class T1, class T2, class T3> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3){CLR(A0), CLR(A1), CLR(A2), CLR(A3);}\ntemplate<class T0, class T1, class T2, class T3, class T4> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5);}\ntemplate<class T0, class T1, class T2, class T3, class T4, class T5, class T6> inline void CLR(T0 &A0, T1 &A1, T2 &A2, T3 &A3, T4 &A4, T5 &A5, T6 &A6){CLR(A0), CLR(A1), CLR(A2), CLR(A3), CLR(A4), CLR(A5), CLR(A6);}\ntemplate<class T> inline void CLR(T &A, int n){REP(i, n) CLR(A[i]);}\n\ntemplate<class T> inline bool EPT(T &a){return a.empty();}\ntemplate<class T> inline T& SRT(T &A){sort(ALL(A)); return A;}\ntemplate<class T, class C> inline T& SRT(T &A, C cmp){sort(ALL(A), cmp); return A;}\ntemplate<class T> inline T& RVS(T &A){reverse(ALL(A)); return A;}\ntemplate<class T> inline T& UNQQ(T &A){A.resize(unique(ALL(A))-A.begin());return A;}\ntemplate<class T> inline T& UNQ(T &A){SRT(A);return UNQQ(A);}\ntemplate<class T, class C> inline T& UNQ(T &A, C cmp){SRT(A, cmp);return UNQQ(A);}\n\n\n//}\n\n/** Constant List .. **/ //{\n\nconst int MOD = int(1e9) + 7;\nconst int INF = 0x3f3f3f3f;\nconst LL INFF = 0x3f3f3f3f3f3f3f3fLL;\nconst DB EPS = 1e-9;\nconst DB OO = 1e20;\nconst DB PI = acos(-1.0); //M_PI;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\n//}\n\n/** Add On .. **/ //{\n// <<= '0. Nichi Joo ., //{\n\ntemplate<class T> inline bool checkMin(T &a,const T b){return b < a ? a = b, 1 : 0;}\ntemplate<class T> inline bool checkMax(T &a,const T b){return a < b ? a = b, 1 : 0;}\ntemplate <class T, class C> inline bool checkUpd(T& a, const T b, C c){return c(b,a) ? a = b, 1 : 0;}\ntemplate<class T> inline T min(T a, T b, T c){return min(min(a, b), c);}\ntemplate<class T> inline T max(T a, T b, T c){return max(max(a, b), c);}\ntemplate<class T> inline T min(T a, T b, T c, T d){return min(min(a, b), min(c, d));}\ntemplate<class T> inline T max(T a, T b, T c, T d){return max(max(a, b), max(c, d));}\ntemplate<class T> inline T min(T a, T b, T c, T d, T e){return min(min(min(a,b),min(c,d)),e);}\ntemplate<class T> inline T max(T a, T b, T c, T d, T e){return max(max(max(a,b),max(c,d)),e);}\ntemplate<class T> inline T sqr(T a){return a*a;}\ntemplate<class T> inline T cub(T a){return a*a*a;}\ntemplate<class T> inline T ceil(T x, T y){return (x - 1) / y + 1;}\ntemplate<class T> T abs(T x){return x>0?x:-x;}\ninline int sgn(DB x){return x < -EPS ? -1 : x > EPS;}\ninline int sgn(DB x, DB y){return sgn(x - y);}\n\ninline DB cos(DB a, DB b, DB c){return (sqr(a)+sqr(b)-sqr(c))/(2*a*b);}\ninline DB cot(DB x){return 1./tan(x);};\ninline DB sec(DB x){return 1./cos(x);};\ninline DB csc(DB x){return 1./sin(x);};\n\n//}\n// <<= '1. Bitwise Operation ., //{\nnamespace BO{\n    \n    inline bool _1(int x, int i){return bool(x&1<<i);}\n    inline bool _1(LL x, int i){return bool(x&1LL<<i);}\n    inline LL _1(int i){return 1LL<<i;}\n    inline LL _U(int i){return _1(i) - 1;};\n    \n    inline int reverse_bits(int x){\n        x = ((x >> 1) & 0x55555555) | ((x << 1) & 0xaaaaaaaa);\n        x = ((x >> 2) & 0x33333333) | ((x << 2) & 0xcccccccc);\n        x = ((x >> 4) & 0x0f0f0f0f) | ((x << 4) & 0xf0f0f0f0);\n        x = ((x >> 8) & 0x00ff00ff) | ((x << 8) & 0xff00ff00);\n        x = ((x >>16) & 0x0000ffff) | ((x <<16) & 0xffff0000);\n        return x;\n    }\n    \n    inline LL reverse_bits(LL x){\n        x = ((x >> 1) & 0x5555555555555555LL) | ((x << 1) & 0xaaaaaaaaaaaaaaaaLL);\n        x = ((x >> 2) & 0x3333333333333333LL) | ((x << 2) & 0xccccccccccccccccLL);\n        x = ((x >> 4) & 0x0f0f0f0f0f0f0f0fLL) | ((x << 4) & 0xf0f0f0f0f0f0f0f0LL);\n        x = ((x >> 8) & 0x00ff00ff00ff00ffLL) | ((x << 8) & 0xff00ff00ff00ff00LL);\n        x = ((x >>16) & 0x0000ffff0000ffffLL) | ((x <<16) & 0xffff0000ffff0000LL);\n        x = ((x >>32) & 0x00000000ffffffffLL) | ((x <<32) & 0xffffffff00000000LL);\n        return x;\n    }\n    \n    template<class T> inline bool odd(T x){return x&1;}\n    template<class T> inline bool even(T x){return !odd(x);}\n    template<class T> inline T low_bit(T x) {return x & -x;}\n    template<class T> inline T high_bit(T x) {T p = low_bit(x);while (p != x) x -= p, p = low_bit(x);return p;}\n    template<class T> inline T cover_bit(T x){T p = 1; while (p < x) p <<= 1;return p;}\n    template<class T> inline int cover_idx(T x){int p = 0; while (_1(p) < x ) ++p; return p;}\n    \n    inline int clz(int x){return __builtin_clz(x);}\n    inline int clz(LL x){return __builtin_clzll(x);}\n    inline int ctz(int x){return __builtin_ctz(x);}\n    inline int ctz(LL x){return __builtin_ctzll(x);}\n    inline int lg2(int x){return !x ? -1 : 31 - clz(x);}\n    inline int lg2(LL x){return !x ? -1 : 63 - clz(x);}\n    inline int low_idx(int x){return !x ? -1 : ctz(x);}\n    inline int low_idx(LL x){return !x ? -1 : ctz(x);}\n    inline int high_idx(int x){return lg2(x);}\n    inline int high_idx(LL x){return lg2(x);}\n    inline int parity(int x){return __builtin_parity(x);}\n    inline int parity(LL x){return __builtin_parityll(x);}\n    inline int count_bits(int x){return __builtin_popcount(x);}\n    inline int count_bits(LL x){return __builtin_popcountll(x);}\n    \n} using namespace BO;//}\n\n\n// <<= '2. Number Theory .,//{\nnamespace NT{\n#define gcd __gcd\n    inline LL lcm(LL a, LL b){return a*b/gcd(a,b);}\n    \n    inline void INC(int &a, int b){a += b; if (a >= MOD) a -= MOD;}\n    inline int sum(int a, int b){a += b; if (a >= MOD) a -= MOD; return a;}\n    \n    /* 模数两倍刚好超 int 时。\n     inline int sum(uint a, int b){a += b; a %= MOD;if (a < 0) a += MOD; return a;}\n     inline void INC(int &a, int b){a = sum(a, b);}\n     */\n    \n    inline void DEC(int &a, int b){a -= b; if (a < 0) a += MOD;}\n    inline int dff(int a, int b){a -= b; if (a < 0) a  += MOD; return a;}\n    inline void MUL(int &a, int b){a = (LL)a * b % MOD;}\n    //inline int pdt(int a, int b){return (LL)a * b % MOD;}\n    inline int pdt(int x,int y) {\n        int ret; __asm__ __volatile__ (\"\\tmull %%ebx\\n\\tdivl %%ecx\\n\":\"=d\"(ret):\"a\"(x),\"b\"(y),\"c\"(MOD));\n        return ret;\n    }\n    \n    \n    inline int gcd(int m, int n, int &x, int &y){\n        \n        x = 1, y = 0; int xx = 0, yy = 1, q;\n        \n        while (1){\n            q = m / n, m %= n;\n            if (!m){x = xx, y = yy; return n;}\n            DEC(x, pdt(q, xx)), DEC(y, pdt(q, yy));\n            q = n / m, n %= m;\n            if (!n) return m;\n            DEC(xx, pdt(q, x)), DEC(yy, pdt(q, y));\n        }\n    }\n    \n    inline int sum(int a, int b, int c){return sum(a, sum(b, c));}\n    inline int sum(int a, int b, int c, int d){return sum(sum(a, b), sum(c, d));}\n    inline int pdt(int a, int b, int c){return pdt(a, pdt(b, c));}\n    inline int pdt(int a, int b, int c, int d){return pdt(pdt(a, b), pdt(c, d));}\n    \n    inline int pow(int a, LL b){\n        int c(1); while (b){\n            if (b&1) MUL(c, a);\n            MUL(a, a), b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, LL b){\n        T c(1); while (b){\n            if (b&1) c *= a;\n            a *= a, b >>= 1;\n        }\n        return c;\n    }\n    \n    template<class T> inline T pow(T a, int b){\n        return pow(a, (LL)b);\n    }\n    \n    inline int _I(int b){\n        int a = MOD, x1 = 0, x2 = 1, q; while (1){\n            q = a / b, a %= b;\n            if (!a) return x2;\n            DEC(x1, pdt(q, x2));\n            \n            q = b / a, b %= a;\n            if (!b) return x1;\n            DEC(x2, pdt(q, x1));\n        }\n    }\n    \n    inline void DIV(int &a, int b){MUL(a, _I(b));}\n    inline int qtt(int a, int b){return pdt(a, _I(b));}\n    \n    struct Int{\n        int val;\n        \n        operator int() const{return val;}\n        \n        Int(int _val = 0):val(_val){\n            val %= MOD; if (val < 0) val += MOD;\n        }\n        Int(LL _val):val(_val){\n            _val %= MOD; if (_val < 0) _val += MOD;\n            val = _val;\n        }\n        \n        Int& operator +=(const int& rhs){INC(val, rhs);rTs;}\n        Int operator +(const int& rhs) const{return sum(val, rhs);}\n        Int& operator -=(const int& rhs){DEC(val, rhs);rTs;}\n        Int operator -(const int& rhs) const{return dff(val, rhs);}\n        Int& operator *=(const int& rhs){MUL(val, rhs);rTs;}\n        Int operator *(const int& rhs) const{return pdt(val, rhs);}\n        Int& operator /=(const int& rhs){DIV(val, rhs);rTs;}\n        Int operator /(const int& rhs) const{return qtt(val, rhs);}\n        Int operator-()const{return MOD-*this;}\n    };\n    \n} using namespace NT;//}\n\n\n//}\n\n\n\n/** I/O Accelerator Interface .. **/ //{\n#define g (c=getchar())\n#define d isdigit(g)\n#define p x=x*10+c-'0'\n#define n x=x*10+'0'-c\n#define pp l/=10,p\n#define nn l/=10,n\ntemplate<class T> inline T& RD(T &x){\n    char c;while(!d);x=c-'0';while(d)p;\n    return x;\n}\ntemplate<class T> inline T& RDD(T &x){\n    char c;while(g,c!='-'&&!isdigit(c));\n    if (c=='-'){x='0'-g;while(d)n;}\n    else{x=c-'0';while(d)p;}\n    return x;\n}\ninline DB& RF(DB &x){\n    //scanf(\"%lf\", &x);\n    char c;while(g,c!='-'&&c!='.'&&!isdigit(c));\n    if(c=='-')if(g=='.'){x=0;DB l=1;while(d)nn;x*=l;}\n    else{x='0'-c;while(d)n;if(c=='.'){DB l=1;while(d)nn;x*=l;}}\n    else if(c=='.'){x=0;DB l=1;while(d)pp;x*=l;}\n    else{x=c-'0';while(d)p;if(c=='.'){DB l=1;while(d)pp;x*=l;}}\n    return x;\n}\n#undef nn\n#undef pp\n#undef n\n#undef p\n#undef d\n#undef g\ninline char* RS(char *s){\n    //gets(s);\n    scanf(\"%s\", s);\n    return s;\n}\n\nLL last_ans; int Case; template<class T> inline void OT(const T &x){\n    //printf(\"Case #%d: \", ++Case);\n    //printf(\"%lld\\n\", x);\n    //printf(\"%I64d\\n\", x);\n    printf(\"%.9f\\n\", x);\n    //printf(\"%d\\n\", x);\n    //cout << x << endl;\n    //last_ans = x;\n}\n\n\n//}/* .................................................................................................................................. */\n\nconst int N = int(1e2) + 9;\nint n, L;\nDB V;\n// 1 2 4 6\nvector<pair<DB, DB> > W;\nint w0;\n// degree, V\n\n\nvoid pop(DB l){\n    DB ll = L;\n    while (sgn(l)){\n        DB d = min(l, W[w0].se);\n        if (!sgn(ll- d)){\n            V = 0;\n        }\n        else {\n            \n            V = ((V*ll) - d*W[w0].fi) / (ll-d);\n        }\n        l -= d; W[w0].se -= d;\n        if (!sgn(W[w0].se)) w0++;\n        ll -= d;\n    }\n}\n\nvoid push(DB v, DB l){\n    V = ((L-l)*V + l*v) / L;\n}\n\n// 4 5\n// 2 3\n\n// 0 > 0\n\nvoid gao(){\n    DB v, l; RD(v, l); V = v;\n    OT(v); W.PB(MP(v, l)); w0 = 0;\n    \n    FOR(i, 1, n){\n        RF(v, l); pop(l); push(v, l);\n        \n        DB r = l;\n        while (W.size() > w0 && W.rbegin()->fi > V){\n            r += W.rbegin()->se;\n            W.pop_back();\n        }\n        if (sgn(r)){\n//            cout << V << \" \" << r << endl;\n            W.push_back(MP(V, r));\n        }\n        \n        \n       // cout << W.size() << \" \";\n        \n        \n        OT(V);\n        \n        //int p = lower_bound(W.begin() + w0, W.end(), V) - W.begin();\n        //DB ss = p > w0 ? S[p-1]-s0 : 0;\n        \n    }\n}\nint main(){\n    \n#ifndef ONLINE_JUDGE\n   // freopen(\"/users/minakokojima/Documents/ACM-Training/Workspace/in.txt\", \"r\", stdin);\n    //freopen(\"out.txt\", \"w\", stdout);\n#endif\n    RD(n, L);\n    gao();\n    /*REP(i, n){\n        LL t, v; RD(v, t);\n        if (i){\n            DB tt = t, ll = L;\n            \n            while (sgn(tt)){\n                pair<DB, DB> z = Q.top(); Q.pop();\n                DB d = min(tt, z.se);\n                \n                cout << z.fi << \" \" << z.se << endl;\n                \n                // ((ll-d)*vv' + d*z.fi) / ll = vv\n                \n                vv = ((vv*ll) - d*-z.fi) / (ll-d);\n\n                \n                tt -= d, z.se -= d;\n                if (sgn(z.se)){\n                    Q.push(MP(z.fi, z.se));\n                }\n                ll -= d;\n            }\n            vv = ((L-t)*vv + t*v) / L;\n        }\n        else{\n            vv = v;\n        }\n        Q.push(MP(-v, t));\n        OT(vv);\n    }*/\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 500009\nusing namespace std;\n \nint n,m,q[N];\nstruct node{ double x,y,z; }a[N];\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tint i,k,head=1,tail=0; double now=0,ans=0;\n\tfor (i=1; i<=n; i++){\n\t\tscanf(\"%lf%lf\",&a[i].x,&a[i].y);\n\t\tans+=a[i].x*a[i].y;\n\t\ta[i].z=now=now+a[i].y;\n\t\tfor (; head<=tail && a[k=q[head]].z<=now-m; head++)\n\t\t\tans-=a[k].x*a[k].y;\n\t\tans-=a[k].x*a[k].y;\n\t\ta[k].y=a[k].z-(now-m);\n\t\tans+=a[k].x*a[k].y;\n\t\tfor (; head<=tail && a[k=q[tail]].x>a[i].x; tail--){\n\t\t\ta[i].x=(a[i].x*a[i].y+a[k].x*a[k].y)/(a[i].y+a[k].y);\n\t\t\ta[i].y+=a[k].y;\n\t\t}\n\t\tq[++tail]=i;\n\t\tprintf(\"%.10f\\n\",ans/m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cerr << #a << \" = \" << a << endl;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nconst int N = 500*1000+7;\n\nLL T[N];\nLL V[N];\nLL sumU[N];\nLL sumD[N];\ndouble ans[N];\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tint n, L;\n\tcin >> n >> L;\n\n\tFOR(i,0,n)\n\t{\n\t\tcin >> T[i] >> V[i];\n\t\tsumD[i] = V[i];\n\t\tsumU[i] = V[i]*(LL)T[i];\n\t\tif(i)\n\t\t{\n\t\t\tsumD[i] += sumD[i-1];\n\t\t\tsumU[i] += sumU[i-1];\n\t\t\tans[i] = (ans[i-1]*(L-V[i]) + T[i]*1.0*V[i]) / L;\n\t\t\tint pos = lower_bound(sumD, sumD+i, sumD[i]-L) - sumD;\n\t\t\tLL sum2 = sumD[i] - sumD[pos];\n\t\t\tLL sum1 = sumU[i] - sumU[pos] + T[pos]*(LL)(L - sum2);\n\t\t\tans[i] = max(ans[i], sum1*1.0/L);\n\t\t}\n\t\telse\n\t\t\tans[i] = T[i];\n\n\t\tcout << fixed << setprecision(8) << ans[i] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nlong double segtree[1200005];\nll segn;\n \nvoid seginit(ll n_){\n    segn = 1;\n    while(segn < n_)segn *= 2;\n    for(int i=0;i<2*segn-1;i++)segtree[i] = 1;\n}\nvoid bai(ll a,ll b,ll k,ll l,ll r,long double times){\n\t//a以上b未満の範囲に、timesの値を更新する\n    if(r <= a || b <= l){\n\t//ノードがa以上b未満の範囲と重ならない場合\n\treturn;\n    }\n    if(a <= l && r <= b){\n\t//ノードがa以上b未満の範囲にすっぽり含まれる場合\n        segtree[k] *= times;\n        return;\n    }else{\n        //以上のどちらでもない場合\n        bai(a,b,k * 2 + 1,l ,(l + r) / 2,times);\n        bai(a,b,k *+ 2 + 2,(l + r )/2 ,r,times);\n        return;\n    }\n}\nlong double query(ll a,ll k,ll l,ll r){\n    //aを含む部分についてのクエリ\n\t//k番目のノードの範囲がl以上r未満\n    if(r <= a || a <  l){\n\t//aを含まない場合\n\t//不適\n        return 1.0f;\n    }\n    if(a == l && r == a + 1){\n\t//aを含み、それ以上分割できない範囲の場合\n        return segtree[k];\n    }else{\n\t//aを含む、ある程度長い範囲の場合\n\t//最大値を返すことに注意\n        long double one = query(a,k * 2 + 1,l ,(l + r) / 2);\n        long double two = query(a,k *+ 2 + 2,(l + r )/2 ,r);\n        long double three = segtree[k];\n\t\tone *= two * three;\n        return one;\n    }\n}\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tseginit(n + 10);\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]*bai);\n\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tlong double bai = query(b,0,0,segn);\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b] * bai);\n\t\t\t\t\ttable[b] -= min((long double)c / bai,table[b]);\n\t\t\t\t}\n\t\t\t\tif(a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai(num,i+1,0,0,segn,(long double)(l - y[i]) / (long double)l);\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct point\n{\n\tdouble x,y;\n\tfriend point operator -(point a,point b){return (point){a.x-b.x,a.y-b.y};}\n\tfriend point operator +(point a,point b){return (point){a.x+b.x,a.y+b.y};}\n\tfriend double operator *(point a,point b){return a.x*b.y-a.y*b.x;}\n}a[2000010];\npoint gp(point p,point q,double x)\n{\n\treturn (point){x,(p.y*(q.x-x)+q.y*(x-p.x))/(q.x-p.x)};\n}\nint main()\n{\n\tint n,l,head=1,tail=1;a[1]=(point){0.0,0.0};\n\tscanf(\"%d%d\",&n,&l);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tpoint p;scanf(\"%lf%lf\",&p.y,&p.x);p.y*=p.x;\n\t\thead++;a[head]=a[head-1]-p;\n\t\twhile ((head!=tail)&&(a[tail+1].x-a[head].x>l)) tail++;\n\t\tif (a[tail].x-a[head].x>l)\n\t\t{\n\t\t\ta[tail]=gp(a[tail],a[tail+1],a[head].x+l);\n\t\t\twhile ((tail+1<head)&&((a[tail]-a[tail+2])*(a[tail+1]-a[tail+2])<0)) {a[tail+1]=a[tail];tail++;}\n\t\t}\n\t\tprintf(\"%.10lf\\n\",(a[tail].y-a[head].y)/l);\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nlong double ans[500005];\nlong double ans1,ans0;\nlong double table[500005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tfor(j=num;j<=min(num + 300ll,i);j++){\n\t\t\t\ttable[j] *= (long double)(l - y[i]) / (long double)l;\n\t\t\t}\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b ; ++ i) \nconst int N = 5e5 + 5 ;\nconst double eps = 1e-12 ;\nusing namespace std ;\n\nint n, L ;\nstruct poi {\n\tlong double x, y ;\n} st[N], delta ;\n\nlong double cross(poi p0, poi p1, poi p2) {\n\treturn (p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y) ;\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &L) ;\n\tint he = 1, ta = 1 ; poi u = {0.0, 0.0} ; st[1] = u ;\n\trep(i, 1, n) {\n\t\tscanf(\"%Lf%Lf\", &u.y, &u.x), u.y *= u.x ;\n\t\tdelta.x += u.x, delta.y += u.y ;\n\t\tu.x = - delta.x, u.y = - delta.y ;\n\t\tfor ( ; he < ta && st[he + 1].x + delta.x > L ; ++ he) ;\n\t\tif (he == ta) st[he + 1] = u ; \n\t\tst[he].y = st[he + 1].y + (st[he].y - st[he + 1].y) * (1.0 * L - st[he + 1].x - delta.x) / (st[he].x - st[he + 1].x) ;\n\t\tst[he].x = 1.0 * L - delta.x ;\n\t\tfor ( ; he < ta && cross(u, st[ta], st[ta - 1]) > 0 ; -- ta) ;\n\t\tst[++ ta] = u ;\n\t\tprintf(\"%.10Lf\\n\", (st[he].y + delta.y) / L) ;\n\t}\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define ivoid inline void\n#define iint inline int\n#define endll '\\n'\n#define ll long long\nusing namespace std;\nconst int N=1e6+5;\nconst int M=3e3+5;\nconst int inf=0x3f3f3f3f;\nint n,k,top,bot;\n\niint rad()\n{\n\tint x=0,f=1;char c;\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\treturn x*f;\n}\nstruct Water{int v;double t;}sta[N],now;\nint sumv;\ndouble sumq;\n\nsigned main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"water.out\",\"w\",stdout);\n\tn=rad();k=rad();\n\tfor(rint i=1;i<=n;i++){\n\t\tnow.t=rad();now.v=rad();\n\t\twhile(sumv+now.v>k){\n\t\t\tint out=min(sumv+now.v-k,sta[bot].v);\n\t\t\tsta[bot].v-=out;\n\t\t\tsumv-=out;\n\t\t\tsumq-=out*sta[bot].t;\n\t\t\tif(!sta[bot].v)bot++;\n\t\t}\n\t\tsta[++top]=now;\n\t\tsumv+=now.v,sumq+=1ll*now.v*now.t;\n\t\twhile(bot<top&&sta[top].t<sta[top-1].t){\n\t\t\tsta[top].t=(sta[top].t*sta[top].v+sta[top-1].t*sta[top-1].v)/(sta[top].v+sta[top-1].v);\n\t\t\tsta[top].v=sta[top-1].v+sta[top].v;\n\t\t\ttop--;\n\t\t}\n\t\tprintf(\"%.8lf\\n\",(double)sumq/k);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing db = long double;\nconst int N = 5e5L + 11;\n\nll t[N], v[N];\nll sum[N];\ndb sum_tv[N];\n\ndb dp_t[N];\nll dp_v[N];\ndb ans[N];\n\nbool drop[N];\nint pre[N];\n\nint main() {\n\tint n; ll l;\n\tcin >> n >> l;\n\tfor(int i = 1; i <= n; i ++)\n\t\tscanf(\"%lld%lld\", t + i, v + i);\n\tfor(int i = 1; i <= n; i ++)\n\t\tsum_tv[i] = t[i] * v[i] + sum_tv[i - 1];\n\tpartial_sum(v, v + N, sum);\n\tdp_t[1] = t[1]; dp_v[1] = l; pre[1] = -1;\n\n\tint last_drop = -1;\n\tfor(int i = 2; i <= n; i ++) {\n\t\tif(dp_t[i - 1] < t[i]) {\n\t\t\tdrop[i] = 1;\n\t\t\tpre[i] = last_drop;\n\t\t\tlast_drop = i;\n\t\t\tdp_t[i] = t[i];\n\t\t\tdp_v[i] = v[i];\n\t\t} else {\n\t\t\tll old = min(dp_v[i - 1], l - v[i]);\n\t\t\tdp_t[i] = (old * dp_t[i - 1] + v[i] * dp_t[i]) / (old + v[i]);\n\t\t\tdp_v[i] = old + v[i];\n\t\t\tpre[i] = pre[i - 1];\n\t\t}\n\t\t//cout << i << ' ' << dp_v[i] << '\\n';\n\t}\n\n\tint p = n;\n\tll s = 0;\n\tans[1] = t[1];\n\tfor(int i = n; i > 1; i --) {\n\t\twhile(p == i || dp_v[p] + sum[i] - sum[p] < l)\n\t\t\tp --;\n\t\t//cout << i << ' ' << p << '\\n';\n\t\tdb v2 = sum[i] - sum[p], v1 = l - v2;\n\t\t//cout << v1 << ' ' << v2 << '\\n';\n\t\tans[i] = (v1 * dp_t[p] + sum_tv[i] - sum_tv[p]) / (v1 + v2);\n\t}\n\t/*\n\tfor(int i = 1; i <= n; i ++)\n\t\tcout << ans[i] << '\\n';\n\t\t*/\n\tfor(int i = 1; i <= n; i ++)\n\t\tprintf(\"%.8f\\n\", (double)ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#include<assert.h>\n#include<chrono>\n#include<random>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\n#define SZ(x) ((int)x.size())\nusing namespace std;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\ntemplate<typename T>inline void chkmin(T &x,T y){x=x<y?x:y;}\ntemplate<typename T>inline void chkmax(T &x,T y){x=x>y?x:y;}\nconst int MAXN=500005;\nstruct node\n{\n\tdouble t,v;node(){}\n\tnode(double _t,double _v){t=_t;v=_v;}\n\tfriend node operator +(node n1,node n2){return node((n1.t*n1.v+n2.t*n2.v)/(n1.v+n2.v),n1.v+n2.v);}\n}li[MAXN];int hd,tl;\nint n,L,T[MAXN],V[MAXN];\nint main()\n{\n\tn=read();L=read();\n\tfor(int i=1;i<=n;i++)T[i]=read(),V[i]=read();\n\tdouble sum=0,SIZ=0;hd=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnode temp=node(0,0);\n\t\twhile(hd<=tl&&SIZ-temp.v+V[i]>L)temp=temp+li[hd++];\n\t\tsum-=temp.t*(SIZ+V[i]-L);temp.v-=(SIZ+V[i]-L);SIZ=L-V[i];\n\t\tif(temp.v)li[--hd]=temp;\n\t\ttemp=node(T[i],V[i]);sum+=1.0*T[i]*V[i];SIZ=L;\n\t\twhile(hd<=tl&&li[tl].t>=temp.t)temp=temp+li[tl--];\n\t\tli[++tl]=temp;\n\t\tprintf(\"%.6lf\\n\",sum/L);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<double , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nint N,L;\nvector<P2> V;\n\ndouble water(double t1 , int v1 , double t2 , int v2){\n\treturn (t1*v1+t2*v2) / (v1+v2);\n}\n\nint main(){\n\tint v;\n\tdouble t;\n\tscanf(\"%d%d%lf%d\" , &N , &L , &t , &v);\n\tdouble d = t;\n\tint x = v;\n\tdouble s = 0;\n\tint p = 0;\n\tint q = 0;\n\tprintf(\"%.9f\\n\" , d);\n\trepp(i,1,N){\n\t\tscanf(\"%lf%d\" , &t , &v);\n\t\tif(d<t){\n\t\t\tV.PB(MP(d,x));\n\t\t\ts += d * x;\n\t\t\tp += x;\n\t\t\td = t;\n\t\t\tx = v;\n\t\t} else {\n\t\t\twhile(1){\n\t\t\t\tint y = min(L-v,x);\n\t\t\t\td = water(d,y,t,v);\n\t\t\t\tx = y + v;\n\t\t\t\tif(x == L || V[(int)V.size()-1].first < d) break;\n\t\t\t\tt = d;\n\t\t\t\tv = x;\n\t\t\t\td = V[(int)V.size()-1].first;\n\t\t\t\tx = V[(int)V.size()-1].second;\n\t\t\t\tV.pop_back();\n\t\t\t}\n\t\t}\n\t\tint w = p+x-L;\n\t\twhile(w>0){\n\t\t\tif(V[q].second <= w){\n\t\t\t\ts -= V[q].first * V[q].second;\n\t\t\t\tp -= V[q].second;\n\t\t\t\tw -= V[q].second;\n\t\t\t\t++q;\n\t\t\t} else {\n\t\t\t\ts -= V[q].first * w;\n\t\t\t\tV[q].second -= w;\n\t\t\t\tp -= w;\n\t\t\t\tw = 0;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%f %f %d \" , s , d , x);\n\t\tprintf(\"%.9f\\n\" , (s + d * x) / L);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define double long double\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\nusing Pdi = pair<double, int>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\n\n\nsigned main(){\n\n    int N; cin >> N;\n    double L; cin >> L;\n    vector<int> t(N), v(N);\n    vector<double> ans(N, 0.0);\n    REP(i, N) cin >> t[i] >> v[i];\n\n    deque<Pdi> dq;\n    double S = 0.0;\n    int V = 0;\n    REP(i, N){\n        int L0 = L - v[i];\n        while(V > L0){\n            double t2 = dq.front().f;\n            int v2 = dq.front().s;\n            dq.pop_front();\n            if(v2 > V - L0){\n                v2 -= V - L0;\n                S -= t2 * (V - L0);\n                V = L0;\n                dq.push_front(Pii(t2, v2));\n            }else{\n                S -= t2 * v2;\n                V -= v2;\n            }\n        }\n\n        V += v[i];\n        S += t[i] * v[i];\n        double t0 = t[i];\n        int v0 = v[i];\n        while(SZ(dq) > 0 && dq.back().f > t0){\n            double t1 = dq.back().f;\n            int v1 = dq.back().s;\n            dq.pop_back();\n            t0 = (t0 * v0 + t1 * v1) / (v0 + v1);\n            v0 = v0 + v1;\n        }\n        dq.push_back(Pdi(t0, v0));\n        \n        ans[i] = S / L;\n    }\n\n    Out(ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            ll t=T[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first;\n               ll v1=dp[0].second;\n               double tmp=min(vv+v-L, (double)v1);\n               tt=tt-(double)t1/v1*tmp;\n               vv-=tmp;\n               if(tmp==(double)v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-(double)t1/v1*tmp;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt=tt+t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    break;\n                }\n                else{\n                    tt=t2+t*v;\n                    vv=v2+v;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(tt, vv));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int rd() {\n\tchar ch=getchar(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=getchar();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=getchar();}\n\treturn i*f;\n}\ndeque < pair<double,double> > q;\nconst double eps=1e-9;\ninline int sgn(double x) {return (x>eps)-(x<-eps);}\nint n,L;\ndouble sum_v;\nint main() {\n\tn=rd(), L=rd();\n\tfor(int i=1;i<=n;i++) {\n\t\tdouble V=rd(), t=rd(); V*=t;\n\t\tif(i==1) {printf(\"%.7f\\n\",V/t); q.push_back(make_pair(V,t)); sum_v=V; continue;}\n\t\tdouble rs=t;\n\t\twhile(q.size() && q.front().first<rs) rs-=q.front().first, sum_v-=q.front().first, q.pop_front();\n\t\tif(q.size() && sgn(rs)>0) {\n\t\t\tdouble vi=rs*(q.front().first/q.front().second);\n\t\t\tq.front().first-=vi; sum_v-=vi; q.front().second-=rs;\n\t\t}\n\t\tsum_v+=V; printf(\"%.7f\\n\",sum_v/L);\n\t\twhile(q.size() && (q.back().first/q.back().second)>(V/t)) {\n\t\t\tV+=q.back().first, t+=q.back().second, q.pop_back();\n\t\t} q.push_back(make_pair(V,t));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nint main() {\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  double sum = 0;\n  deque<pair<double, double>> Q;\n  for (int i = 0; i < n; ++i) {\n    double T, V;\n    scanf(\"%lf%lf\", &T, &V);\n    if (i > 0) {\n      double rem = V;\n      while (rem > 0) {\n        if (Q.front().first > rem)  {\n          Q.front().first -= rem;\n          sum -= rem * Q.front().second;\n          break;\n        } else {\n          rem -= Q.front().first;\n          sum -= Q.front().first * Q.front().second;\n          Q.pop_front();\n        }\n      }\n    }\n    // trace(i);\n    // for (auto& it : Q) {\n    //   trace(it.first, it.second);\n    // }\n    while (Q.size() && Q.back().second > T) {\n      auto [V2, T2] = Q.back();\n      Q.pop_back();\n      sum -= V2 * T2;\n      T = (V2 * T2 + V * T) / (V2 + V);\n      V += V2;\n    }\n    Q.push_back({V, T});\n    sum += V * T;\n    printf(\"%.10f\\n\", sum / m);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <complex>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define mp(a,b)\tmake_pair(a,b)\n#define fst\tfirst\n#define scn second\nconst ll mod = 1e9 + 7;\nconst ld eps = 1e-9;\n\nint main() {\n\tll n, l;\tcin >> n >> l;\n\tdeque<pair<ld,ll> > dq;\n\tld t;\tll v;\tcin >> t >> v;\n\tdq.push_back(mp(t, v));\n\tld ret = t*v;\n\tprintf(\"%.15Lf\\n\", ret / l);\n\tsrep(i,1,n){\n\t\tcin >> t >> v;\n\t\tll left = v;\n\t\twhile (left) {\n\t\t\tpll front = dq.front();\tdq.pop_front();\n\t\t\tll rm = min(front.scn, left);\n\t\t\tfront.scn -= rm;\tleft -= rm;\n\t\t\tret -= rm*front.fst + eps;\n\t\t\tif (front.scn > 0)\tdq.push_front(front);\n\t\t}\n\t\twhile (!dq.empty() && dq.back().fst >= t) {\n\t\t\tt = (dq.back().fst*dq.back().scn + t*v) / (dq.back().scn + v);\n\t\t\tv += dq.back().scn;\n\t\t\tret -= dq.back().fst*dq.back().scn + eps;\n\t\t\tdq.pop_back();\n\t\t}\n\t\tret += t*v + eps;\n\t\tdq.push_back(mp(t, v));\n\t\tprintf(\"%.15Lf\\n\", ret / l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAXN 5005\n#define INF 16843009\n#define LL long long\n#define LD long double\n#define len(l,r) (r-l+1)\n#define P int(1e9+7)\nusing namespace std;\n \nint N,L,Q;\nLD A,B;\nLD t[MAXN], v[MAXN], dp[MAXN][MAXN];\n\nLD mix(LD v1, LD t1, LD v2, LD t2){\n\treturn (v1*t1 + v2*t2)/(v1 + v2);\n}\n\n\nint main(){\n\t\n//\tfreopen(\"4.in\", \"r\", stdin);\n//\tfreopen(\"4.out\", \"w\", stdout);\n\t\n\tcin>>N>>L;\n//\tcin>>Q;\n\tfor(int i=1;i<=N;i++){\n\t\tcin>>t[i]>>v[i];\n\t}\n\t\n\tfor(int j=0;j<=L;j++) dp[1][j] = t[1];\n\t\n\tfor(int i=2;i<=N;i++){\n\t\tfor(int j=0;j<=L;j++){\n\t\t\tfor(int k=max((LD)0,j-v[i]);k<=L-v[i];k++){\n\t\t\t\tdp[i][j] = max(dp[i][j], mix(k,dp[i-1][k],v[i],t[i]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=N;i++){\n\t\tprintf(\"%.6f\\n\", dp[i][L]);\n\t}\n\n//\tfor(int i=1;i<=Q;i++){\n//\t\tint x;\n//\t\tcin>>x;\n//\t\t\n//\t\tprintf(\"%.2lf\\n\", dp[x][L]);\n//\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nint N,L;\nstruct Point{long long x;double y;}Q[500010];\nint main(){\n\tscanf(\"%d%d\",&N,&L);\n\tPoint*H=Q,*T=Q;\n\tfor(int i=N;i--;){\n\t\tint t,v;\n\t\tscanf(\"%d%d\",&t,&v);\n\t\twhile(H->x-T->x>L-v){\n\t\t\tif(H[1].x-T->x>L-v)++H;\n\t\t\telse H->y=H[1].y+(H->y-H[1].y)*(T->x+L-v-H[1].x)/(H->x-H[1].x),H->x=T->x+L-v;\n\t\t}\n\t\tPoint p=(Point){T->x-v,T->y-1ll*t*v};\n\t\twhile(H<T&&(p.y-T->y)*(T->x-T[-1].x)<=(T->y-T[-1].y)*(p.x-T->x))--T;\n\t\t*++T=p;\n\t\tprintf(\"%.12lf\\n\",(H->y-T->y)/L);\n\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef long double Double;\n\nint n, l;\nint t[500000], v[500000];\nDouble sumtv[500001];\nLL sumv[500001];\ndeque<int> q;\n\nint main() {\n    scanf(\"%d%d\", &n, &l);\n    forn(i, n) scanf(\"%d%d\", t + i, v + i);\n    Double subtv = 0, remtv = 0;\n    LL subv = 0, remv = 0;\n    forn(i, n) {\n        sumtv[i + 1] = sumtv[i] + (LL)t[i] * v[i];\n        sumv[i + 1] = sumv[i] + v[i];\n        while (!q.empty()) {\n            int v = q.back();\n            if ((sumtv[i + 1] - subtv) / (sumv[i + 1] - subv) <= (sumtv[v] - subtv) / (sumv[v] - subv)) {\n                q.pop_back();\n            } else {\n                break;\n            }\n        }\n        if (q.empty()) {\n            remtv = subtv;\n            remv = subv;\n        }\n        printf(\"%.15f\\n\", double((sumtv[i + 1] - subtv) / l));\n        q.push_back(i + 1);\n        if (i != n - 1) {\n            while (!q.empty()) {\n                subtv = remtv;\n                subv = remv;\n                LL need = sumv[i + 1] + v[i + 1] - (subv + l);\n                int v = q.front();\n//                cerr << v << \"!\";\n                if (sumv[v] - subv > need) {\n                    subtv += (sumtv[v] - subtv) / (sumv[v] - subv) * need;\n                    subv += need;\n                    break;\n                } else {\n                    remtv = subtv = sumtv[v];\n                    remv = subv = sumv[v];\n                    q.pop_front();\n                }\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cerr << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U> void chmin(T& t, const U& u) { if (t > u) t = u; }\ntemplate<class T, class U> void chmax(T& t, const U& u) { if (t < u) t = u; }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nint main() {\n\tint N, L;\n\tscanf(\"%d %d\", &N, &L);\n\n\tdeque<pair<int, double>> deq;\n\n\tint sum = 0.0;\n\tdouble hsum = 0.0;\n\n\trep(i, N) {\n\t\tint t, v;\n\t\tscanf(\"%d %d\", &t, &v);\n\t\tdeq.push_front(mp(v, (double)t * v));\n\t\tsum += v;\n\t\thsum += (double)t * v;\n\n\t\tdouble ans = -1.0;\n\n\t\twhile (sum >= L) {\n\t\t\tauto p = deq.back();\n\t\t\tdeq.pop_back();\n\n\t\t\tsum -= p.fi;\n\t\t\thsum -= p.se;\n\n\t\t\tif (sum < L) {\n\t\t\t\tint d = L - sum;\n\t\t\t\tdouble nx = p.se * d / p.fi;\n\t\t\t\tsum += d;\n\t\t\t\thsum += nx;\n\t\t\t\tans = hsum / L;\n\t\t\t\tdeq.eb(d, nx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.10f\\n\", ans);\n\t\t\n\t\twhile (deq.size() >= 2) {\n\t\t\tint sz = deq.size();\n\t\t\tauto p = deq[0], q = deq[1];\n\t\t\tif (p.se / p.fi < q.se / q.fi) {\n\t\t\t\tdeq.pop_front(); deq.pop_front();\n\t\t\t\tauto t = mp(p.fi + q.fi, p.se + q.se);\n\t\t\t\tdeq.push_front(t);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twhile (sum > L) {\n\t\t\tauto p = deq.back(); deq.pop_back();\n\t\t\tsum -= p.fi;\n\t\t\thsum -= p.se;\n\t\t\tif (sum < L) {\n\t\t\t\tint d = L - sum;\n\t\t\t\tdouble nx = p.se / p.fi * d;\n\t\t\t\tdeq.eb(d, nx);\n\t\t\t\tsum += d;\n\t\t\t\thsum += nx;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<queue>\n#include<cmath>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define rep(i,a,b) for (int i=a; i<=b; i++)\n#define per(i,a,b) for (int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long LL;\n\ninline int read() {\n    int x=0,f=1; char ch=getchar();\n    while (!(ch>='0'&&ch<='9')) {if (ch=='-')f=-1;ch=getchar();}\n    while (ch>='0'&&ch<='9') {x=x*10+(ch-'0'); ch=getchar();}\n    return x*f;\n}\n\nconst int N = 500005;\nconst double eps = 1e-8;\n\nint n,head=0,tail=0;\ndouble L,q[N][2];\n\nint main() {\n\n \n\n    n=read(); L=read();\n    double S=0,V=0;\n    rep(i,1,n) {\n        int t=read(),v=read();\n        V+=v; S+=(double)t*v;\n        while (V>L&&head<tail) {\n            if (V-L>=q[head][0]) {\n                V-=q[head][0]; S-=q[head][0]*q[head][1];\n                head++;\n            } else {\n                q[head][0]-=V-L; S-=(V-L)*q[head][1]; V=L;\n                break;\n            }\n        }\n        q[tail][0]=v; q[tail++][1]=t;\n        printf(\"%lf\\n\",S/L);\n        while (tail-head>=2) {\n            if (q[tail-1][1]>q[tail-2][1]) break;\n            q[tail-2][1]=(q[tail-2][0]*q[tail-2][1]+q[tail-1][0]*q[tail-1][1])/(q[tail-2][0]+q[tail-1][0]);\n            q[tail-2][0]+=q[tail-1][0];\n            tail--;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing lint = long long;\nusing plint = pair<double, lint>;\n\nint N;\nlint L;\n\ndeque<plint> deq;\ndouble Qsum = 0;\nlint Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        lint nuku = min(Vnow - L, deq.front().second);\n        deq.front().second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq.front().first;\n        if (deq.front().second == 0) deq.pop_front();\n    }\n}\n\nvoid add(double tadd, lint vadd)\n{\n    if (deq.back().first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        deq.push_back(plint(tadd, vadd));\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq.back().second + vadd >= L)\n        {\n            Qsum = deq.back().first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            deq.clear();\n            deq.push_back(plint(Qsum / L, L));\n        }\n        else\n        {\n            double Qaddnew = deq.back().first * deq.back().second + tadd * vadd;\n            lint vaddnew = deq.back().second + vadd;\n            Qsum -= deq.back().first * deq.back().second;\n            Vnow -= deq.back().second;\n            deq.pop_back();\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\nvoid print()\n{\n    cout << setprecision(12) << Qsum / L << endl;\n}\nint main()\n{\n    cin >> N >> L;\n    REP(_, N)\n    {\n        double t;\n        lint v;\n        cin >> t >> v;\n        if (_ == 0)\n        {\n            deq.push_back(plint(t, v));\n            Qsum = t * v;\n            Vnow = v;\n            print();\n        }\n        else\n        {\n            add(t, v);\n            print();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define db double\n#define myp pair<ll,ll>\nusing namespace std;\nconst int N=5e5+10;\nint n,l;\nmyp q[N]; //pair<v,v*t> 比较时不会产生精度误差 \nint head,tail;\nint main(){\n\tll v,t,temp_v=0,temp=0;\n\tdb now_t;\n\tscanf(\"%d%d\",&n,&l);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld\",&t,&v);\n\t\tq[head++]=make_pair(v,v*t);\n\t\ttemp_v+=v,temp+=v*t;\n\t\twhile(temp_v>l){\n\t\t\tif(temp_v-q[tail].first>=l) temp_v-=q[tail].first,temp-=q[tail].second,tail++;\n\t\t\telse now_t=db(q[tail].second)/q[tail].first,q[tail].first-=temp_v-l,temp_v=l,temp=(temp-q[tail].second+now_t*q[tail].first+0.5),q[tail].second=(now_t*q[tail].first+0.5);\n\t\t}\n\t\twhile(head-2>=tail&&db(q[head-1].second)/q[head-1].first<db(q[head-2].second)/q[head-2].first) q[head-2].first+=q[head-1].first,q[head-2].second+=q[head-1].second,head--;\n\t\tprintf(\"%.10lf\\n\",db(temp)/temp_v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.01.2020 03:51:26       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(17);\n  int n, l;\n  cin >> n >> l;\n  vector<pair<long double, long double>> a;\n  long double res = 0;\n  int i = 0;\n  for (int it = 0; it < n; it++) {\n    long double t, v;\n    cin >> t >> v;\n    long double rm = (it == 0 ? 0 : v);\n    while (i < (int) a.size()) {\n      if (rm > a[i].second) {\n        rm -= a[i].second;\n        res -= a[i].first * a[i].second;\n        ++i;\n      } else {\n        a[i].second -= rm;\n        res -= a[i].first * rm;\n        break;\n      }\n    }\n    res += t * v;\n    while (i < (int) a.size() && a.back().first > t) {\n      t = (t * v + a.back().first * a.back().second) / (v + a.back().second);\n      v += a.back().second;\n      a.pop_back();\n    }\n    a.emplace_back(t, v);\n    cout << res / l << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll read(){\n\tll x=0,f=1; char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1; ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=getchar();}\n\treturn x*f;\n}\nll d[1000005];\ndouble t[1000005];\nint main(){\n\tint n=read(),m=read();\n\tint l=1,r=0,dq=0;\n\tdouble zl=0;\n\tfor (int i=1;i<=n;i++){\n\t\tll T=read(),V=read();\n\t\td[++r]=V; t[r]=(double)T*V;\n\t\tzl+=t[r]; dq+=d[r];\n\t\tfor (;t[r]/d[r]<t[r-1]/d[r-1]&&l<r;r--)\n\t\t\tif (d[r-1]+d[r]<=m) t[r-1]+=t[r],d[r-1]+=d[r];\n\t\t\telse{\n\t\t\t\tt[r-1]=t[r]+(t[r-1]/d[r-1])*(m-d[r]);\n\t\t\t\tdq=d[r-1]=m; zl=t[r-1]; --r; l=r;\n\t\t\t    break;\n\t\t\t}\n\t\tfor (;dq>m;l++){\n\t\t\tif (dq-d[l]>=m) dq-=d[l],zl-=t[l];\n\t\t\telse {\n\t\t\t\tdouble k=t[l]/d[l];\n\t\t\t\tzl-=k*(dq-m);\n\t\t\t\tt[l]-=k*(dq-m);\n\t\t\t\td[l]-=dq-m;\n\t\t\t\tdq=m; break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.7lf\\n\",zl/m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(!isdigit(ch)){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch)) re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nstruct node{\n\tdouble v,t;\n}a[500010];\nnode q[500010];int n,L,head,tail;\ndouble tot=0,totv=0;\nint main(){\n\tn=read();L=read();int i;ll lim;\n\tfor(i=1;i<=n;i++) a[i].t=read(),a[i].v=read();\n\ttot+=(a[1].v*a[1].t);totv+=a[1].v;\n\tq[tail++]=(node){a[1].v,a[1].t};\n//\tcout<<\"first \"<<tot<<' '<<totv<<'\\n';\n\tprintf(\"%.10lf\\n\",tot/totv);\n\tfor(i=2;i<=n;i++){\n\t\tlim=a[i].v;\n\t\twhile(head<tail&&lim>=q[head].v){\n\t\t\tlim-=q[head].v;\n\t\t\ttot-=q[head].v*q[head].t;\n\t\t\ttotv-=q[head].v;\n\t\t\thead++;\n\t\t}\n\t\tq[head].v-=lim;\n\t\ttot-=lim*q[head].t;\n\t\ttotv-=lim;\n//\t\tcout<<\"after dec \"<<i<<' '<<tot<<' '<<totv<<' '<<lim<<' '<<q[head].t<<'\\n';\n\t\tq[tail]=(node){a[i].v,a[i].t};\n\t\ttot+=a[i].v*a[i].t;\n\t\ttotv+=a[i].v;\n//\t\tcout<<\"after add \"<<i<<' '<<tot<<' '<<totv<<'\\n';\n\t\twhile(head<tail&&q[tail].t<q[tail-1].t) \n\t\t\tq[tail-1]=(node){q[tail].v+q[tail-1].v,(q[tail].t*q[tail].v+q[tail-1].t*q[tail-1].v)/(q[tail].v+q[tail-1].v)},tail--;\n\t\tprintf(\"%.10lf\\n\",tot/totv);\n\t\ttail++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N=5e5+5;\n\ntypedef long long LL;\n\ntypedef double db;\n\nint n,L,Head,Tail,q,l[N],t,v,Now;\n\ndb D[N],ans;\n\nchar c;\n\nint read()\n{\n    int x=0,sig=1;\n    for (c=getchar();c<'0' || c>'9';c=getchar()) if (c=='-') sig=-1;\n    for (;c>='0' && c<='9';c=getchar()) x=x*10+c-48;\n    return x*sig;\n}\n\nint main()\n{\n\tn=read(); L=read();\n\tt=read(); v=read();\n\tprintf(\"%.10lf\\n\",(db)t);\n\tl[Head=Tail=1]=v; D[1]=t;\n\tans=(db)t*L; Now=L;\n\tfor (int i=2;i<=n;i++)\n\t{\n\t\tt=read(); v=read();\n\t\tNow+=v;\n\t\tfor (;Now>L;)\n\t\t{\n\t\t\tif (Now-l[Head]>=L)\n\t\t\t{\n\t\t\t\tNow-=l[Head];\n\t\t\t\tans-=l[Head]*D[Head];\n\t\t\t\tHead++;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tans-=D[Head]*(Now-L);\n\t\t\t\tl[Head]-=Now-L;\n\t\t\t\tNow=L;\n\t\t\t}\n\t\t}\n\t\tl[++Tail]=v; D[Tail]=t; ans+=(db)t*v;\n\t\tfor (;Head<Tail && D[Tail]<=D[Tail-1];Tail--)\n\t\t{\n\t\t\tans-=D[Tail-1]*l[Tail-1]+D[Tail]*l[Tail];\n\t\t\tD[Tail-1]=(D[Tail-1]*l[Tail-1]+D[Tail]*l[Tail])/(l[Tail]+l[Tail-1]);\n\t\t\tl[Tail-1]+=l[Tail];\n\t\t\tans+=D[Tail-1]*l[Tail-1];\n\t\t}\n\t\tprintf(\"%.10lf\\n\",ans/L);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define t first\n#define v second\n#define wrap make_pair\nusing namespace std;\ntypedef double db;\ntypedef pair<db,int> pint;\ntypedef const pint& cpr;\ntypedef long long ll;\nconst int siz=5e5+1;\n\nint n,L;\nll Vsum;\ndb Esum;\npint a[siz];\ndeque<pint> q;\n\ninline\ndb mix(cpr a,cpr b){return (a.t*a.v+b.t*b.v)/(a.v+b.v);}\n\nint main()\n{\n#ifdef DEBUG\n    freopen(\"AT2402.in\",\"r\",stdin);\n#endif\n    scanf(\"%d%d\",&n,&L);\n    for(int i=1,y;i<=n;i++){\n        db x;\n        scanf(\"%lf%d\",&x,&y);\n        a[i]=wrap(x,y);\n        while(a[i].v+Vsum>L){\n            pint now=q.front();\n            q.pop_front();\n            int pour=min(a[i].v+Vsum-L,(ll)now.v);\n            Vsum-=pour;\n            Esum-=pour*now.t;\n            now=wrap(now.t,now.v-pour);\n            if(now.v!=0)\n                q.push_front(now);\n        }\n        q.push_back(a[i]);\n        while(q.size()>1&&q[q.size()-2].t>q.back().t){\n            pint b=q.back();\n            q.pop_back();\n            pint c=q.back();\n            q.pop_back();\n            q.push_back(wrap(mix(b,c),b.v+c.v));\n        }\n        Esum+=a[i].t*a[i].v;\n        Vsum+=a[i].v;\n        printf(\"%.7f\\n\",Esum/L);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=1ll*q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=1ll*q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=1ll*q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=1ll*t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq[tail].t=(1ll*q[tail].t*q[tail].v+1ll*t*v)/(q[tail].v+v);\n\t\t\tq[tail].v+=v;\n\t\t\tsum+=1ll*t*v;\n\t\t\t//tail++;\n\t\t\t//sum+=1ll*t*v;\n\t\t\t//q[tail].t=sum/l;\n\t\t\t//q[tail].v=l;\n\t\t\t//head=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const deque<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const deque<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n    template<typename C, typename T, typename OP> vector<T> prefixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0R (i, sz(v)) r[i+1] = op(r[i], v[i]); return r;\n    }\n    template<typename C, typename T, typename OP> vector<T> suffixes(const C& v, T id, OP op) {\n        vector<T> r(sz(v)+1, id); F0Rd (i, sz(v)) r[i] = op(v[i], r[i+1]); return r;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        cout << fixed << setprecision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\n// point {{{\ntemplate<typename T> struct point {\n    T x, y;\n    point() : x(0), y(0) {}\n    point(T _x, T _y) : x(_x), y(_y) {}\n    friend istream& operator >> (istream& i, point& p) { return i >> p.x >> p.y; }\n    friend ostream& operator << (ostream& o, const point& p) {\n        return o << \"(\" << p.x << \", \" << p.y << \")\";\n    }\n\n    T norm() const { return x * x + y * y; }\n    double len() const { return sqrt(norm()); }\n    double ang() const { return atan2(y, x); }\n    point<T> conj() const { return { x, -y }; }\n\n    point& operator += (const point& o) { x += o.x; y += o.y; return *this; }\n    point& operator -= (const point& o) { x -= o.x; y -= o.y; return *this; }\n    point& operator *= (const T& c) { x *= c; y *= c; return *this; }\n    point& operator /= (const T& c) { x /= c; y /= c; return *this; }\n    friend point operator + (const point& a, const point& b) { return point(a) += b; }\n    friend point operator - (const point& a, const point& b) { return point(a) -= b; }\n    friend point operator * (const point& a, const T& c) { return point(a) *= c; }\n    friend point operator * (const T& c, const point& a) { return point(a) *= c; }\n    friend point operator / (const point& a, const T& c) { return point(a) /= c; }\n\n    bool operator == (const point& o) const { return x == o.x && y == o.y; }\n    bool operator != (const point& o) const { return x != o.x || y != o.y; }\n    bool operator < (const point& o) const { return (x != o.x) ? x < o.x : y < o.y; }\n    bool operator > (const point& o) const { return (x != o.x) ? x > o.x : y > o.y; }\n    bool operator <= (const point& o) const { return !(*this > o); }\n\n    friend T dot(const point& a, const point& b) { return a.x * b.x + a.y * b.y; }\n    friend T cross(const point& a, const point& b) { return a.x * b.y - a.y * b.x; }\n    friend T cross(const point& p, const point& a, const point& b) { return cross(a - p, b - p); }\n\n    friend point<T> operator * (const point& a, const point& b) {\n        return { a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x };\n    }\n    friend point<T> operator / (const point& a, const point& b) {\n        return a * b.conj() / b.norm();\n    }\n\n    point dir() const { return point(*this) / len(); }\n    point rotate(const double& ang) const { return *this * point(cos(ang), sin(ang)); }\n\n    T dist(const point& a) const { return (a - *this).len(); }\n    T dist(const point& a, const point& b) {\n        return abs(cross(*this, a, b)) / a.dist(b);\n    }\n    point reflect(const point& a, const point& b) const {\n        return a + ((*this - a) / (b - a)).conj() * (b - a);\n    }\n    point foot(const point& a, const point& b) const {\n        return (*this + this->reflect(a, b)) / 2;\n    }\n    friend point extension(const point& a, const point& b, const point& c, const point& d) {\n        T x = cross(a, b, c), y = cross(a, b, d);\n        return (d * x - c * y) / (x - y);\n    }\n\n    friend vector<point> seg_intersect(point a, point b, point c, point d) {\n        if (a > b) swap(a, b);\n        if (c > d) swap(c, d);\n\n        T a1 = cross(a, b, c), a2 = cross(a, b, d);\n        if (a1 > a2) swap(a1, a2);\n        if (!(a1 <= 0 && a2 >= 0)) return {};\n\n        if (a1 == 0 && a2 == 0) {\n            if (cross(a, c, d) != 0) return {};\n            point<T> x1 = max(a, c), x2 = min(b, d);\n            if (x1 > x2) return {};\n            if (x1 == x2) return { x1 };\n            return { x1, x2 };\n        }\n\n        point<T> z = extension(a, b, c, d);\n        if (a <= z && z <= b) return { z };\n        return {};\n    }\n\n    using polygon = vector<point<T>>;\n    friend ostream& operator << (ostream& o, const polygon& poly) {\n        o << \"{\";\n        for (auto pt : poly) o << \" \" << pt;\n        return o << \" }\";\n    }\n\n    string classify(const polygon& p) const {\n        bool ans = 0;\n        for (int i = 0; i < p.size(); i++) {\n            point<T> a = p[i], b = p[(i + 1) % p.size()];\n            if (cross(a, b, *this) == 0 && min(a, b) <= *this && *this <= max(a, b))\n                return \"on\";\n            if (a.y > b.y) swap(a, b);\n            if (a.y <= y && y < b.y && cross(*this, a, b) > 0) ans ^= 1;\n        }\n        return ans ? \"in\" : \"out\";\n    }\n\n    friend polygon convex_hull(const vector<point>& pts) {\n        point pivot = *min_element(all(pts));\n        auto sorted = pts;\n        sort(all(sorted), [&pivot](const point& p, const point& q) {\n            T cp = cross(pivot, p, q);\n            if (cp != 0) return cp > 0;\n            return pivot.dist(p) < pivot.dist(q);\n        });\n\n        int j = 0;\n        polygon res(pts.size());\n        for (const point& p : sorted) {\n            while (j > 1 && cross(res[j - 2], res[j - 1], p) <= 0)\n                j--;\n            res[j++] = p;\n        }\n        res.erase(res.begin() + j, res.end());\n        return res;\n    }\n\n    // twice the signed area\n    friend T area(const polygon& p) {\n        T a = 0;\n        for (int i = 0; i < sz(p); i++)\n            a += cross(p[i], p[i+1 < sz(p) ? i+1 : 0]);\n        return a;\n    }\n};\n// }}}\n\nint main() {\n    setIO();\n\n    using pt = point<double>;\n\n    int N, L; re(N, L);\n\n    pt tot{0,0};\n    deque<pt> tank;\n\n    F0R (i, N) {\n        int temp, vol; re(temp, vol);\n        ll heat = temp * ll(vol);\n\n        tot += pt{vol, heat};\n        tank.emplace_front(vol, heat);\n\n        while (tot.x > L) {\n            if (tot.x - tank.back().x < L) {\n                pt rem = tank.back() / tank.back().x * (tot.x - L);\n                tot -= rem;\n                tank.back() -= rem;\n                break;\n            } else {\n                tot -= tank.back();\n                tank.pop_back();\n            }\n        }\n\n        ps(double(tot.y)/tot.x);\n\n        while (sz(tank) >= 2 && cross(*tank.begin(), *next(tank.begin())) >= 0) {\n            pt sum = *tank.begin() + *next(tank.begin());\n            F0R (_, 2) tank.pop_front();\n            tank.push_front(sum);\n        }\n    }\n\n    // did you check N=1? did you mix up N,M?\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 5e5 + 100;\n\nint n, fnt, rar;\ndouble L, tagx, tagy, x[maxn], y[maxn];\n\nint main() {\n\tscanf(\"%d%lf\", &n, &L);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tif(fnt == rar) {\n\t\t\tprintf(\"%.12f\\n\", 1. * t);\n\t\t\tx[rar] = v;\n\t\t\ty[rar++] = 1. * v * t;\n\t\t\tx[rar] = 0;\n\t\t\ty[rar++] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile(x[fnt + 1] + tagx + v >= L) {\n\t\t\t++fnt;\n\t\t}\n//\t\tprintf(\"\\t%d %d\\n\", fnt, rar);\n//\t\tprintf(\"\\t%lld %lld\\n\", x[fnt] + tagx, y[fnt] + tagy);\n\t\tdouble k = (y[fnt] - y[fnt + 1]) / (x[fnt] - x[fnt + 1]);\n//\t\tassert(k * (x[fnt] - x[fnt + 1]) == y[fnt] - y[fnt + 1]);\n\t\tx[fnt] = L - v - tagx;\n\t\ty[fnt] = k * (x[fnt] - x[fnt + 1]) + y[fnt + 1];\n//\t\tprintf(\"\\t%lld %lld\\n\", x[fnt] + tagx, y[fnt] + tagy);\n\t\ttagy += v * t;\n\t\ttagx += v;\n\t\tprintf(\"%.12f\\n\", (y[fnt] + tagy) / L);\n\t\twhile(rar - 1 != fnt) {\n\t\t\tdouble k1 = (y[rar - 1] + tagy) / (x[rar - 1] + tagx);\n\t\t\tdouble k2 = (y[rar - 2] + tagy) / (x[rar - 2] + tagx);\n\t\t\tif(k1 <= k2) {\n\t\t\t\t--rar;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx[rar] = -tagx;\n\t\ty[rar++] = -tagy;\n\t\t/*\n\t\tfor (int j = fnt; j < rar; ++j) {\n\t\t\tprintf(\"(%lld, %lld)\\t\", x[j] + tagx, y[j] + tagy);\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=1ll*q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=1ll*q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=1ll*q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=1ll*t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq[tail].t=(1ll*q[tail].t*q[tail].v+1ll*t*v)/(q[tail].v+v);\n\t\t\tq[tail].v+=v;\n\t\t\tsum+=1ll*t*v;\n\t\t\twhile(head<tail&&q[tail-1].t>q[tail].t)\n\t\t\t{\n\t\t\t\ttail--;\n\t\t\t\tq[tail].t=(1ll*q[tail].t*q[tail].v+1ll*q[tail+1].t*q[tail+1].v)/(q[tail].v+q[tail+1].v);\n\t\t\t\tq[tail].v+=q[tail+1].v;\n\t\t\t}\n\t\t\t//tail++;\n\t\t\t//sum+=1ll*t*v;\n\t\t\t//q[tail].t=sum/l;\n\t\t\t//q[tail].v=l;\n\t\t\t//head=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int maxn = 5e5 + 100;\n\nint n, fnt, rar, L;\nlong long tagx, tagy, x[maxn];\ndouble y[maxn];\n\nint main() {\n\tscanf(\"%d%d\", &n, &L);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint t, v;\n\t\tscanf(\"%d%d\", &t, &v);\n\t\tif(fnt == rar) {\n\t\t\tprintf(\"%.12f\\n\", 1. * t);\n\t\t\tx[rar] = v;\n\t\t\ty[rar++] = 1. * v * t;\n\t\t\tx[rar] = 0;\n\t\t\ty[rar++] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile(x[fnt + 1] + tagx + v >= L) {\n\t\t\t++fnt;\n\t\t}\n\t\tdouble k = (y[fnt] - y[fnt + 1]) / (x[fnt] - x[fnt + 1]);\n//\t\tassert(k * (x[fnt] - x[fnt + 1]) == y[fnt] - y[fnt + 1]);\n\t\tx[fnt] = L - v - tagx;\n\t\ty[fnt] = k * (x[fnt] - x[fnt + 1]) + y[fnt + 1];\n//\t\tprintf(\"\\t%lld %lld\\n\", x[fnt] + tagx, y[fnt] + tagy);\n\t\ttagy += v * t;\n\t\ttagx += v;\n\t\tprintf(\"%.12f\\n\", (y[fnt] + tagy) / (1. * L));\n\t\twhile(rar - 1 != fnt) {\n\t\t\tdouble k1 = (y[rar - 1] + tagy) / (1. * x[rar - 1] + tagx);\n\t\t\tdouble k2 = (y[rar - 2] + tagy) / (1. * x[rar - 2] + tagx);\n\t\t\tif(k1 <= k2) {\n\t\t\t\t--rar;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tx[rar] = -tagx;\n\t\ty[rar++] = -tagy;\n\t\t/*\n\t\tfor (int j = fnt; j < rar; ++j) {\n\t\t\tprintf(\"(%lld, %lld)\\t\", x[j] + tagx, y[j] + tagy);\n\t\t}\n\t\tputs(\"\");\n\t\t*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 5e5 + 10;\npair<ll, double> q[MAXN];\n#define dec ruiuiehrrefrf\nint n, maxv, t, v, l = 1, r = 0;\nll dec, sum = 0;\ndouble tem = 0;\n\nint main()\n{\n\tscanf(\"%d%d\", &n, &maxv);\n\tfor (int i = 1; i <= n; i++)\n\t{\n\t\tscanf(\"%d%d\", &t, &v);\n\t\twhile (sum + v > maxv)\n\t\t{\n\t\t\tdec = min(q[l].first, sum + v - maxv);\n\t\t\tq[l].first -= dec;\n\t\t\tsum -= dec;\n\t\t\ttem -= q[l].second * dec;\n\t\t\tif (!q[l].first) l++;\n\t\t}\n\t\tsum += v;\n\t\ttem += 1ll * t * v;\n\t\tq[++r] = make_pair(v, t);\n\t\tfor (; l < r && q[r].second < q[r - 1].second; --r)\n\t\t{\n\t\t\tq[r - 1].second = (q[r].second * q[r].first + q[r - 1].second * q[r - 1].first) / (q[r].first + q[r - 1].first);\n\t\t\tq[r - 1].first += q[r].first;\n\t\t}\n\t\tprintf(\"%.7f\\n\", tem / maxv);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef double db;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\ntypedef pair<ld,ld> pa;\nconst int N=1e6+5,M=1e7+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint L,n;\npa q[N],p[N];\npa merge(pa a,pa b){return pa((a.w1*a.w2+b.w1*b.w2)/(a.w2+b.w2),a.w2+b.w2);}\n#define QQ(a) (a.w1*a.w2)\nint main(){\n\tread(n,L);\n\tint h=5e5,t=h;\n\trep(i,1,n){\n\t\tll x,y;read(x,y);p[i]=pa(x,y);\n\t}\t\n\tq[h]=p[1];\n\tprintf(\"%.8lf\\n\",(db)p[1].w1);\n\tdb all=p[1].w2,Q=QQ(p[1]);\n\trep(i,2,n){\n\t\tall+=p[i].w2;\n\t\twhile(h<t&&all-q[t].w2>L){\n\t\t\tall-=q[t].w2;\n\t\t\tQ-=QQ(q[t]);\n\t\t\tt--;\n\t\t}\n\t\tif(all>L){\n\t\t\tQ-=QQ(q[t]);\n\t\t\tq[t].w2-=all-L,all=L;\n\t\t\tQ+=QQ(q[t]);\n\t\t}\n\t\t\n\t\tif(q[h].w1>p[i].w1){\n\t\t\tQ-=QQ(q[h]);\n\t\t\tq[h]=merge(q[h],p[i]);\n\t\t\tQ+=QQ(q[h]);\n\t\t}else{\n\t\t\th--;\n\t\t\tq[h]=p[i];\n\t\t\tQ+=QQ(q[h]);\n\t\t}\n\t\t\n\t\tprintf(\"%.8lf\\n\",(db)(Q/all));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 500000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npair<double,double> q[MN+5];\nint n,L,t[MN+5],v[MN+5],top,tail;\ndouble X[MN+5],Y[MN+5];\ninline double C(pair<double,double> a,pair<double,double> b){return(a.second-b.second)/(a.first-b.first);}\ninline double CY(int res,double Y,double X){return (q[res+1].second+Y+(X+L-q[res+1].first)/(q[res].first-q[res+1].first)*(q[res].second-q[res+1].second))/L;}\nint main()\n{\n\tn=read();L=read();q[top=tail=1]=make_pair(0.,0.);\n\tfor(int i=1;i<=n;++i) t[i]=read(),v[i]=read(),X[i]=X[i-1]+v[i],Y[i]=Y[i-1]+1LL*t[i]*v[i];\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tpair<double,double> s=make_pair(-X[i],-Y[i]); \n\t\twhile(tail<top&&q[tail+1].first>=s.first+L) ++tail;\n\t\tq[++top]=s;double yy=CY(tail,Y[i],s.first);\n\t//\tcout<<q[tail+1].second+Y[i]<<\" \"<<q[tail].first<<\" \"<<q[tail].second<<\" \"<<q[tail+1].first<<\" \"<<q[tail+1].second<<endl;\n\t\tprintf(\"%.10lf\\n\",yy);--top;q[tail]=make_pair(s.first+L,-Y[i]+yy*L);\n\t\twhile(top>tail&&C(s,q[top])<C(q[top],q[top-1])) --top;\n\t\tq[++top]=s;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define fup(i,a,b) for(int i=a;i<=b;i++)\n#define ll long long\ninline int read()\n{\n    int X=0,w=1; char ch=0;\n    while(ch<'0' || ch>'9') {if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0' && ch<='9') X=(X<<3)+(X<<1)+ch-'0',ch=getchar();\n    return X*w;\n}\nstruct dl{ int v,t; }d[500005];\nint n,l,v,t,len; double ans;\ninline void insert(int t,int v)\n{\n\tlen++; int wz = len;\n\td[len].v = v; d[len].t = t;\n\twhile(wz>1&&d[wz].t<d[wz-1].t){ swap(d[wz],d[wz-1]); wz--; }\n}\ninline ll get(int v)\n{\n\tint wz = len; ll ret = 0;\n\twhile(v&&wz)\n\t{\n\t\tif(v>=d[wz].v) ret = ret+1LL*d[wz].v*d[wz].t,v -= d[wz].v;\n\t\t\telse ret = ret+1LL*d[wz].t*v, v = 0;\n\t\twz--;\n\t}\n\treturn ret;\n}\nint main()\n{\n\t//freopen(\"E:\\\\inout\\\\cs.in\",\"r\",stdin);\n\tn = read(); l = read();\n\tfup(i,1,n)\n\t{\n\t\tt = read(); v = read();\n\t\tif(1.0*t>=ans){ ans = (ans*(l-v)+1LL*t*v)/l; }\n\t\telse{ ll sum = get(l-v); ans = 1.0*(sum+1LL*t*v)/l; }\n\t\tinsert(t,v); printf(\"%.7lf\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t500005\n#define EPS\t1e-8\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nstruct point {double x, y; };\npoint operator + (point a, point b) {return (point) {a.x + b.x, a.y + b.y}; }\npoint operator - (point a, point b) {return (point) {a.x - b.x, a.y - b.y}; }\npoint operator * (point a, double b) {return (point) {a.x * b, a.y * b}; }\ndouble operator * (point a, point b) {return a.x * b.y - a.y * b.x; }\nbool equal(double a, double b) {return fabs(a - b) <= EPS; }\npoint q[MAXN];\npoint get(point a, point b, double x) {\n\tpoint tmp = (b - a) * (1 / (b.x - a.x));\n\treturn a + tmp * (x - a.x);\n}\nint main() {\n\tint l = 1, r = 1, n, L;\n\tq[1] = (point) {0, 0};\n\tread(n), read(L);\n\tfor (int i = 1; i <= n; i++) {\n\t\tpoint p; read(p.y), read(p.x);\n\t\tp.y *= p.x; p = p + q[r];\n\t\tq[++r] = p;\n\t\twhile (p.x - q[l].x > L + EPS) l++;\n\t\tif (!equal(p.x - q[l].x, L)) q[l - 1] = get(q[l], q[l - 1], p.x - L), l--;\n\t\twhile (r - l >= 2 && (q[r] - q[r - 1]) * (q[r] - q[r - 2]) > EPS) q[r - 1] = q[r], r--;\n\t\tprintf(\"%.10lf\\n\", (q[r].y - q[l].y) / L);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;//first parameter used to save t*v\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        double tt=0.0, vv=0.0;\n        for(int i=0;i<N;i++){\n            ll t=T[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first;\n               ll v1=dp[0].second;\n               double tmp=min(vv+v-L, (double)v1);\n               tt=tt-(double)t1/v1*tmp;\n               vv-=tmp;\n               if(tmp==(double)v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-(double)t1/v1*tmp;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt=tt+t*v;\n            vv=L;\n            printf(\"%.7lf\\n\", tt/vv);\n            int ans=dp.size();\n            ll c1=t*v, c2=v;\n            while(ans){\n                ll t2=dp[ans-1].first;\n                ll v2=dp[ans-1].second;\n                if(t2/v2<t){\n                    c1=t*v;\n                    c2=v;\n                    break;\n                }\n                else{\n                    c1=t2+t*v;\n                    c2=v2+v;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\nusing namespace std;\nconst int N=5e5+5;\nstruct data\n{\n\tdouble t;\n\tlong long v;\n}q[N],p;\nint l=1,r=0;\ninline int read()\n{\n    int X=0,w=0; char ch=0;\n    while(!isdigit(ch)) w|=ch=='-',ch=getchar();\n    while(isdigit(ch)) X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n    return w?-X:X;\n}\nint main()\n{\n\tint n=read();\n\tlong long L=read(),L0=L;\n\tdouble now=0;\n\twhile(n--)\n\t{\n\t\tp.t=read(),p.v=read();\n\t\twhile(p.v>L)\n\t\t\tif(q[l].v+L<=p.v)\n\t\t\t{\n\t\t\t\tnow-=q[l].v*q[l].t;\n\t\t\t\tL+=q[l++].v;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tlong long x=p.v-L;\n\t\t\t\tnow-=x*q[l].t;\n\t\t\t\tL+=x;\n\t\t\t\tq[l].v-=x;\n\t\t\t}\n\t\tL-=p.v;\n\t\tnow+=p.v*p.t;\n\t\tq[++r]=p;\n\t\twhile(l<r && q[r-1].t>=q[r].t)\n\t\t{\n\t\t\tq[r-1].t=(q[r-1].t*q[r-1].v+q[r].t*q[r].v)/(q[r-1].v*1.0+q[r].v);\n\t\t\tq[r-1].v+=q[r].v;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",now*1.0/(L0-L));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For( i, j, k ) for( int i = j; i <= k; ++i )\nusing std::cin;\nusing std::cout;\nusing std::pair;\nconst int N = 5e5 + 5;\nint n, L, t[ N ], v[ N ], hd = 1, tl = 0;\npair < int, double > q[ N ];\nint main( )\n{\n std::ios::sync_with_stdio( false );\n cout.tie( 0 );\n cin >> n >> L;\n For( i, 1, n )\n  cin >> t[ i ] >> v[ i ];\n long long cur = 0;\n int sum = 0;\n cout.setf( std::ios::fixed );\n cout << std::setprecision( 7 );\n For( i, 1, n )\n {\n  while( v[ i ] + sum > L )\n  {\n   int po = std::min( q[ hd ].first, v[ i ] + sum - L );\n   sum -= po;\n   q[ hd ].first -= po;\n   cur -= 1LL * po * q[ hd ].second;\n   if( !q[ hd ].first )\n    ++hd;\n  }\n  q[ ++tl ] = std::make_pair( v[ i ], t[ i ] );\n  sum = L;\n  cur += 1LL * v[ i ] * t[ i ];\n  while( hd < tl && q[ tl - 1 ].second > q[ tl ].second )\n  {\n   q[ tl - 1 ].second = ( q[ tl - 1 ].second * q[ tl - 1 ].first + q[ tl ].second * q[ tl ].first ) / ( q[ tl ].first + q[ tl - 1 ].first );\n   q[ tl - 1 ].first += q[ tl ].first;\n   tl--;\n  }\n  cout << ( double ) cur / L << '\\n';\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define N 500010\n#define ll long long\nusing namespace std;\nstruct data{int x; double y;}d[N];\nint n, op, cl, sum, x, sx;\ndouble y, sy;\ninline char gc(){\n\tstatic char now[1<<16], *S, *T;\n\tif(S==T){T=(S=now)+fread(now, 1, 1<<16, stdin); if(S==T)return EOF;}\n\treturn *S++;\n}\ninline int read(){\n\tint x=0, f=1; char ch=gc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1; ch=gc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0'; ch=gc();}\n\treturn x*f;\n}\nint main(){\n\tn=read(); sum=read();\n\top=1; cl=0; sx=sy=0;\n\tfor(int i=1; i<=n; i++){\n\t\ty=read(); x=read(); y*=x;\n\t\tsx+=x; sy+=y;\n\t\twhile(sx>sum){\n\t\t\tif(sx-d[op].x<sum){sy-=d[op].y; d[op].y-=d[op].y/d[op].x*(sx-sum); d[op].x-=sx-sum; sx=sum; sy+=d[op].y;}\n\t\t\telse{sx-=d[op].x; sy-=d[op].y; op++;}\n\t\t}\n\t\tprintf(\"%.10f\\n\", sy/sum);\n\t\twhile(op<=cl&&y/x<d[cl].y/d[cl].x){\n\t\t\ty+=d[cl].y; x+=d[cl].x; cl--;\n\t\t}\n\t\td[++cl].x=x; d[cl].y=y;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<double, double> P;\ndouble t[500000], v[500000];\nint main() {\n\tll N, L;\n\tcin >> N >> L;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> t[i] >> v[i];\n\t}\n\tprintf(\"%.15lf\\n\", t[0]);\n\tdouble sumT = t[0] * v[0];\n\tdeque<P> Q;\n\tQ.emplace_back(t[0], v[0]);\n\tfor (int i = 1; i < N; i++) {\n\t\tdouble sumV = L;\n\t\twhile (sumV > L - v[i]) {\n\t\t\tif (Q.front().second < sumV - (L - v[i])) {\n\t\t\t\tsumV -= Q.front().second;\n\t\t\t\tsumT -= Q.front().first*Q.front().second;\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tQ.front().second -= sumV - (L - v[i]);\n\t\t\t\tsumT -= Q.front().first*(sumV - (L - v[i]));\n\t\t\t\tsumV = L - v[i];\n\t\t\t}\n\t\t}\n\t\tsumT += t[i] * v[i];\n\t\tif (Q.back().first < t[i]) {\n\t\t\tQ.emplace_back(t[i], v[i]);\n\t\t}\n\t\telse {\n\t\t\tP now = P(t[i], v[i]);\n\t\t\twhile (!Q.empty() && Q.back().first >= now.first) {\n\t\t\t\tdouble sum_t = Q.back().first*Q.back().second + now.first + now.second;\n\t\t\t\tdouble sum_v = Q.back().second + now.second;\n\t\t\t\tnow = P(sum_t / sum_v, sum_v);\n\t\t\t\tQ.pop_back();\n\t\t\t}\n\t\t\tQ.push_back(now);\n\t\t}\n\t\tprintf(\"%.15lf\\n\", sumT / L);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=500005;\n#define pii pair<double,int>\n#define fi first\n#define se second\n#define mp make_pair\nint n,L,y;\ndouble x;\npii Q[N];\nsigned main(){\n\tscanf(\"%d%d\",&n,&L);\n\tdouble ans=0;\n\tint l=1,r=1;\n\tscanf(\"%lf%d\",&x,&y);\n\tQ[1]=mp(x,y);\n\tans=x*y;\n\tprintf(\"%.10lf\\n\",x);\n\tn--;\n\twhile (n--){\n\t\tscanf(\"%lf%d\",&x,&y);\n\t\tint p=y;\n\t\twhile (p){\n\t\t\tint c=min(p,Q[l].se);\n\t\t\tQ[l].se-=c;p-=c;ans-=c*Q[l].fi;\n\t\t\tif (!Q[l].se)l++;\n\t\t}\n\t\tans+=x*y;\n\t\twhile (l<=r&&Q[r].fi>=x){\n\t\t\tx=(x*y+Q[r].fi*Q[r].se)/(y+Q[r].se);\n\t\t\ty+=Q[r].se;\n\t\t\tr--;\n\t\t}\n\t\tr++;Q[r]=mp(x,y);\n\t\tprintf(\"%.10lf\\n\",ans/L);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define N 501000\n#define db double\nusing namespace std;\nint n,m,l;\ndb d[N][2];\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tdb V=0,T=0;\n\tint he=0,ta=0;\n\tfo(i,1,n)\n\t{\n\t\tint x,y;scanf(\"%d%d\",&x,&y);\n\t\twhile(V+y>l)\n\t\t{\n\t\t\tdb jy=min(d[he][1],V+y-l);\n\t\t\td[he][1]-=jy;\n\t\t\tT-=jy*d[he][0];\n\t\t\tV-=jy;\n\t\t\tif(d[he][1]==0) he++;\n\t\t}\n\t\tV+=y;T+=x*y;\n\t\tfor(d[++ta][0]=x,d[ta][1]=y;he<ta&&d[ta][0]<d[ta-1][0];ta--)\n\t\t{\n\t\t\td[ta-1][0]=(d[ta-1][0]*d[ta-1][1]+d[ta][0]*d[ta][1])/(d[ta-1][1]+d[ta][1]);\n\t\t\td[ta-1][1]+=d[ta][1];\n\t\t}\n\t\tprintf(\"%lf\\n\",T/l);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\n\nusing lint = long long;\nusing plint = pair<double, lint>;\n\nint N;\nlint L;\n\n// deque<plint> deq;\n\narray<plint, 500000> deq;\nint s = 0;\nint t = -1;\n\ndouble Qsum = 0;\nlint Vnow = 0;\n\nvoid trim()\n{\n    while (Vnow > L)\n    {\n        lint nuku = min(Vnow - L, deq[s].second);\n        deq[s].second -= nuku;\n        Vnow -= nuku;\n        Qsum -= nuku * deq[s].first;\n        if (deq[s].second == 0) s++;\n    }\n}\n\nvoid add(double tadd, lint vadd)\n{\n    if (deq[t].first < tadd) // 追加するほうが高温の場合、先頭から余剰分を抜いていく\n    {\n        t++; deq[t] = plint(tadd, vadd);\n        Qsum += tadd * vadd;\n        Vnow += vadd;\n        trim();\n    }\n    else // 低温の場合、うしろとくっつけていく\n    {\n        if (deq[t].second + vadd >= L)\n        {\n            Qsum = deq[t].first * (L - vadd) + tadd * vadd;\n            Vnow = L;\n            s = 0, t = -1;\n            t++; deq[t] = plint(Qsum / L, L);\n        }\n        else\n        {\n            double Qaddnew = deq[t].first * deq[t].second + tadd * vadd;\n            lint vaddnew = deq[t].second + vadd;\n            Qsum -= deq[t].first * deq[t].second;\n            Vnow -= deq[t].second;\n            t--;\n            add(Qaddnew / vaddnew, vaddnew);\n        }\n    }\n}\n\nvoid print()\n{\n    cout << setprecision(12) << Qsum / L << endl;\n}\nint main()\n{\n    cin.tie(0); ios::sync_with_stdio(0);\n    cin >> N >> L;\n    REP(_, N)\n    {\n        double tmp;\n        lint v;\n        cin >> tmp >> v;\n        if (_ == 0)\n        {\n            t++; deq[t] = plint(tmp, v);\n            Qsum = tmp * v;\n            Vnow = v;\n            print();\n        }\n        else\n        {\n            add(tmp, v);\n            print();\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=(long double)1.0*d1.front().second;\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    totv-=d1.front().second;\n                    d1.pop_front();\n                }else{\n                    totprod-=(long double)1.0*d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=(long double)1.0*d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            \n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        \n       // cout<<totprod<<endl;\n       totprod+=(long double)1.0*v*t;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n      totprod-=(long double)1.0*v*t;\n       tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=(long double)1.0*d1.back().first*d1.back().second;\n                double tempp = (long double)1.0*tempv*tempt;\n                tempp+=(long double)1.0*d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = ((long double)1.0*tempp)/((long double)1.0*tempv);\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n            totprod+=(long double)1.0*tempt*tempv;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\ndeque<pair<double,double>> d1;\ndouble totprod,totv;\nint main(){\n    double n,L;\n    cin>>n>>L;\n    for(double i=1;i<=n;i++){\n        double t,v;\n        cin>>t>>v;\n        double tempv =v;\n            double tempt =t;\n        if(i>1){\n            \n            \n            while(d1.size() && tempv){\n                \n                if(d1.front().second<=tempv){\n                    \n                    tempv-=d1.front().second;\n                    totprod-=d1.front().first*d1.front().second;\n                    totv-=d1.front().first;\n                    d1.pop_front();\n                }else{\n                    totprod-=d1.front().first*d1.front().second;\n                    d1.front().second-=tempv;\n                    totprod+=d1.front().first*d1.front().second;\n                   // cout<<123<<\" \"<<totprod<<endl;\n                    //totv-=tempv;\n                    tempv = 0;\n                    break;\n                }\n            }\n            tempv = v;\n          //  cout<<1234<<\" \"<<v<<endl;\n            while(d1.size() && d1.back().first>=t){\n                totprod-=d1.back().first*d1.back().second;\n                double tempp = tempv*tempt;\n                tempp+=d1.back().first*d1.back().second;\n               // cout<<123<<\" \"<<totprod<<endl;\n                tempv+=d1.back().second;\n                tempt = tempp/tempv;\n                //cout<<1234<<\" \"<<tempt<<\" \"<<tempv<<endl;\n                d1.pop_back();\n            }\n           // cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<endl;\n         //   cout<<123<<\" \"<<totprod<<\" \"<<tempt*tempv<<\" \"<<d1.back().first<<endl;\n        }\n        totprod+=tempt*tempv;\n       // cout<<totprod<<endl;\n        cout<<setprecision(20)<<totprod/L<<endl;\n       // cout<<tempv<<\" \"<<tempt<<endl;\n        d1.push_back(make_pair(tempt,tempv));\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 500005\n#define pdi pair<double,int>\n#define endl '\\n'\nusing namespace std;\npdi deq[maxn];\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,L;\n\tcin >> n >> L;\n\tint l = 0 , r = 0;\n\tdouble sum_t = 0 ;\n\tint sum_v = 0;\n\tfor(int i=1;i<=n;i++) {\n\t\tdouble t;\n\t\tint v;\n\t\tcin >> t >> v;\n\t\tt *= v;\n\t\tsum_t += t;\t\tsum_v += v;\n\t\twhile(sum_v > L) {\n\t\t\tif(sum_v - deq[l].second < L) {\n\t\t\t\tint delta = sum_v - L;\n\t\t\t\tsum_t -= deq[l].first * delta / deq[l].second;\n\t\t\t\tsum_v -= delta;\n\t\t\t\tdeq[l].first  -= deq[l].first * delta / deq[l].second;\n\t\t\t\tdeq[l].second -= delta;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum_t -= deq[l].first;\n\t\t\t\tsum_v -= deq[l].second;\n\t\t\t\tl++;\n\t\t\t}\n\t\t}\n\t\twhile(l < r && deq[r-1].first/deq[r-1].second > t/v) {\n\t\t\tt += deq[r-1].first;\n\t\t\tv += deq[r-1].second;\n\t\t\tr--;\n\t\t}\n\t\tdeq[r++] = pdi{t,v};\n\t\tcout << fixed << setprecision(7) << sum_t / sum_v << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long double ld;\ntypedef pair<ld, ld> pld;\n\n#define fi first\n#define se second\n\nconst int MAXN = 500005;\n\nint T[MAXN], V[MAXN];\ndeque<pld> d;\n\nint main() {\n\tios::sync_with_stdio(false); cin.tie(0);\n\tint N, L;\n\n\tcin >> N >> L;\n\tfor(int i = 0; i < N; i++) cin >> T[i] >> V[i];\n\n\tcout << fixed;\n\tcout.precision(20);\n\tpld ep = make_pair(0.0L, 0.0L);\n\tfor(int i = 0; i < N; i++) {\n\t\td.push_front(make_pair(V[i], (ld) V[i] * T[i]));\n\t\tep.fi = L;\n\t\tep.se += (ld) V[i] * T[i];\n\t\tcout << ep.se / ep.fi << \"\\n\";\n\t\tif(i == N - 1) break;\n\t\twhile(d.size() > 1 && d[0].se / d[0].fi < d[1].se / d[1].fi) {\n\t\t\td[1].fi += d[0].fi;\n\t\t\td[1].se += d[0].se;\n\t\t\td.pop_front();\n\t\t}\n\t\twhile(!d.empty() && ep.fi - d.back().fi > L - V[i + 1]) d.pop_back();\n\t\tif(!d.empty()) {\n\t\t\tld sed = d.back().se * (ep.fi - L + V[i + 1]) / d.back().fi;\n\t\t\td.back().fi -= ep.fi - L + V[i + 1];\n\t\t\tep.se -= sed;\n\t\t\td.back().se -= sed;\n\t\t\tep.fi = L - V[i + 1];\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fod(i,a,b) for(int i=a;i>=b;i--)\n#define JS(q,w) ((d[q][0]*d[q][1]+d[w][0]*d[w][1])/(d[q][0]+d[w][0]))\n#define SM(q) (d[q][0]*d[q][1])\nusing namespace std;\ntypedef double db;\nconst int N=500500;\nint read(int &n)\n{\n\tchar ch=' ';int q=0,w=1;\n\tfor(;(ch!='-')&&((ch<'0')||(ch>'9'));ch=getchar());\n\tif(ch=='-')w=-1,ch=getchar();\n\tfor(;ch>='0' && ch<='9';ch=getchar())q=q*10+ch-48;n=q*w;return n;\n}\nint m,n;\ndb ans;\ndb d[N][2];//v t\nint main()\n{\n\tint q,w;\n\tread(n),read(m);\n\tint l=1,r=0,all=0;\n\tfo(i,1,n)\n\t{\n\t\tread(q),read(w);\n\t\td[++r][0]=w,d[r][1]=q;ans+=SM(r);\n\t\tall+=w;\n\t\tfor(;l<r&&d[r-1][1]>=d[r][1];--r)\n\t\t\tif(d[r-1][0]+d[r][0]<=m)\n\t\t\t{\n\t\t\t\tans-=SM(r)+SM(r-1);\n\t\t\t\td[r-1][1]=JS(r-1,r),d[r-1][0]+=d[r][0];\n\t\t\t\tans+=SM(r-1);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tl=--r;\n\t\t\t\td[r][0]=m-d[r+1][0];\n\t\t\t\td[r][1]=JS(r,r+1);\n\t\t\t\td[r][0]=m;all=m;\n\t\t\t\tans=SM(r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(;all>m;++l)if(all-d[l][0]>=m)ans-=SM(l),all-=d[l][0];\n\t\telse\n\t\t{\n\t\t\tans-=SM(l);\n\t\t\td[l][0]-=(all-m);\n\t\t\tans+=SM(l);all=m;\n\t\t\tbreak;\n\t\t}\t\n\t\tprintf(\"%.10lf\\n\",ans/m);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nint n,l;\n#define N 500005\nstruct W\n{\n\tdouble t;\n\tint v;\n} q[N];\ndouble t;\nint v;\nint head=1,tail=0;\ndouble sum;\nint main()\n{\n\tscanf(\"%d%d\",&n,&l);\n\tscanf(\"%lf%d\",&q[1].t,&q[1].v);tail++;\n\tprintf(\"%.7lf\\n\",q[1].t);\n\tsum=1ll*q[1].t*q[1].v;\n\tfor(int i=2;i<=n;i++)\n\t{\n\t\tscanf(\"%lf%d\",&t,&v);\n\t\tint cnt=v;\n\t\twhile(head<=tail&&cnt)\n\t\t{\n\t\t\tif(cnt>=q[head].v)\n\t\t\t{\n\t\t\t\tcnt-=q[head].v;\n\t\t\t\tsum-=1ll*q[head].t*q[head].v;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tq[head].v-=cnt;\n\t\t\t\tsum-=1ll*q[head].t*cnt;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(q[tail].t<=t)\n\t\t{\n\t\t\ttail++;\n\t\t\tq[tail].t=t;\n\t\t\tq[tail].v=v;\n\t\t\tsum+=1ll*t*v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttail++;\n\t\t\tsum+=1ll*t*v;\n\t\t\tq[tail].t=sum/l;\n\t\t\tq[tail].v=l;\n\t\t\thead=tail;\n\t\t}\n\t\tprintf(\"%.7lf\\n\",sum/l);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nstruct data\n{\n\tdouble t, v; \n} que[500005]; \nint main()\n{\n\t// freopen(\"ARC072-F.in\", \"r\", stdin); \n\tint n, lim, he = 1, ta = 0; \n\tdouble sum_v = 0, sum_t = 0; \n\tscanf(\"%d%d\", &n, &lim); \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdata x; \n\t\tscanf(\"%lf%lf\", &x.t, &x.v); \n\t\tsum_v += x.v; \n\t\tsum_t += x.v * x.t; \n\t\twhile (lim < sum_v)\n\t\t{\n\t\t\tif (sum_v - lim >= que[he].v)\n\t\t\t{\n\t\t\t\tsum_t -= que[he].v * que[he].t;\n\t\t\t\tsum_v -= que[he++].v; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsum_t -= que[he].t * (sum_v - lim); \n\t\t\t\tque[he].v -= sum_v - lim; \n\t\t\t\tsum_v = lim; \n\t\t\t}\n\t\t}\n\t\tprintf(\"%.8lf\\n\", sum_t / sum_v);\n\t\twhile (he <= ta && que[ta].t >= x.t)\n\t\t{\n\t\t\tx.t = (que[ta].t * que[ta].v + x.t * x.v) / (que[ta].v + x.v); \n\t\t\tx.v += que[ta].v; \n\t\t\tta--; \n\t\t}\n\t\tque[++ta] = x; \n\t}\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rint register int\n#define ivoid inline void\n#define iint inline int\n#define endll '\\n'\n#define ll long long\nusing namespace std;\nconst int N=1e6+5;\nconst int M=3e3+5;\nconst int inf=0x3f3f3f3f;\nint n,k,top,bot;\n\niint rad()\n{\n\tint x=0,f=1;char c;\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=(x<<3)+(x<<1)+c-'0',c=getchar();\n\treturn x*f;\n}\nstruct Water{int v;double t;}sta[N],now;\nint sumv;\ndouble sumq;\n\nsigned main()\n{\n//\tfreopen(\"1.in\",\"r\",stdin);\n//\tfreopen(\"water.out\",\"w\",stdout);\n\tn=rad();k=rad();\n\tfor(rint i=1;i<=n;i++){\n\t\tnow.t=rad();now.v=rad();\n\t\twhile(sumv+now.v>k){\n\t\t\tint out=min(sumv+now.v-k,sta[bot].v);\n\t\t\tsta[bot].v-=out;\n\t\t\tsumv-=out;\n\t\t\tsumq-=out*sta[bot].t;\n\t\t\tif(!sta[bot].v)bot++;\n\t\t}\n\t\tsta[++top]=now;\n\t\tsumv+=now.v,sumq+=1ll*now.v*now.t;\n\t\twhile(bot<top&&sta[top].t<sta[top-1].t){\n\t\t\tsta[top-1].t=(sta[top].t*sta[top].v+sta[top-1].t*sta[top-1].v)/(sta[top].v+sta[top-1].v);\n\t\t\tsta[top-1].v=sta[top-1].v+sta[top].v;\n\t\t\ttop--;\n\t\t}\n\t\tprintf(\"%.8lf\\n\",(double)sumq/k);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FR first\n#define SE second\nusing namespace std;\n\nconst int S=(1<<20)+5;\nchar buf[S],*H,*T;\ninline char Get()\n{\n    if(H==T) T=(H=buf)+fread(buf,1,S,stdin);\n    if(H==T) return -1;return *H++;\n}\ninline int read()\n{\n    int x=0;char c=Get();\n    while(!isdigit(c)) c=Get();\n    while(isdigit(c)) x=x*10+c-'0',c=Get();\n    return x;\n}\nchar obuf[S],*oS=obuf,*oT=oS+S-1,c,qu[55];int qr;\ninline void flush(){fwrite(obuf,1,oS-obuf,stdout);oS=obuf;}\ninline void putc(char x){*oS++ =x;if(oS==oT) flush();}\ninline void printd(int d,double x)\n{\n    long long t=(long long)floor(x),f=t;\n    while(t) qu[++qr]=t%10,t/=10;\n    while(qr) putc(qu[qr--]+'0');\n    putc('.');x-=f;\n    while(d--)\n    {\n        double y=x*10;x*=10;\n        int c=(int)floor(y);\n        putc(c+'0');x-=floor(y);\n    }\n}\n\ntypedef long long LL;\ntypedef pair<LL,double> pld;\nconst int N=500010;\nLL t[N],v[N];\npld q[N];\nint l=1,r=0;\n\nint main()\n{\n    int n=read(),L=read();\n    for(int i=1;i<=n;i++)\n        t[i]=read(),v[i]=read();\n    int sum=0;double cur=0;\n    for(int i=1;i<=n;i++)\n    {\n        while(v[i]+sum>L)\n        {\n            int pour=min(v[i]+sum-L,q[l].FR);\n            sum-=pour;\n            q[l].FR-=pour;\n            cur-=q[l].SE*pour;\n            if(!q[l].FR) l++;\n        }\n        q[++r]=pld(v[i],t[i]);\n        sum+=v[i];cur+=1ll*t[i]*v[i];\n        while(l<r&&q[r].SE<q[r-1].SE)\n        {\n            q[r-1].SE=(q[r-1].SE*q[r-1].FR+q[r].SE*q[r].FR)/(q[r-1].FR+q[r].FR);\n            q[r-1].FR+=q[r].FR;r--;\n        }\n        printd(7,cur/L);putc('\\n');\n    }\n    flush();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,m;\ndouble x[500010],p;\nint y[500010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l,r,w;\n\tscanf(\"%d%d\",&n,&m);\n\tl=1;\n\tr=0;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   if(i>1)\n\t     {\n\t\t  w=k;\n\t\t  while(w)\n\t\t    if(y[l]<=w)\n\t\t      {\n\t\t\t   w-=y[l];\n\t\t\t   p-=x[l]*y[l];\n\t\t\t   l++;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t   y[l]-=w;\n\t\t\t   p-=x[l]*w;\n\t\t\t   w=0;\n\t\t\t  }\n\t\t }\n\t   x[++r]=j;\n\t   y[r]=k;\n\t   p+=(L)j*k;\n\t   while(r>l && x[r]<x[r-1])\n\t     {\n\t\t  x[r-1]=(x[r]*y[r]+x[r-1]*y[r-1])/(y[r]+y[r-1]);\n\t\t  y[r-1]+=y[r];\n\t\t  r--;\n\t\t }\n\t   printf(\"%.10lf\\n\",p/m);\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EPS 1e-8\n#define MAX_N 500000\n#define fir first\n#define sec second\nusing namespace std;\ntypedef double dnt;\ntypedef pair<dnt,dnt> pnt;\ntemplate <class T> inline void read(T &x) {\n\tx = 0; int c = getchar(), f = 1;\n\tfor (; !isdigit(c); c = getchar()) if (c == 45) f = -1;\n\tfor (; isdigit(c); c = getchar()) (x *= 10) += f*(c-'0');\n}\nint n, l, r; dnt C, T, V;\npnt que[MAX_N+5], tot, mrg;\npnt operator + (const pnt &x, const pnt &y)\n\t{return pnt(x.fir+y.fir, x.sec+y.sec);}\npnt operator - (const pnt &x, const pnt &y)\n\t{return pnt(x.fir-y.fir, x.sec-y.sec);}\ndnt operator * (const pnt &x, const pnt &y)\n\t{return x.fir*y.sec-x.sec*y.fir;}\nint main() {\n\tread(n), read(C), read(T), read(V);\n\tprintf(\"%.7lf\\n\", T);\n\ttot = que[r] = pnt(V, T*V);\n\tfor (int i = 1; i < n; i++) {\n\t\tread(T), read(V); dnt lft = V;\n\t\twhile (que[l].fir < lft-EPS)\n\t\t\tlft -= que[l].fir, tot = tot-que[l++];\n\t\ttot = tot-que[l];\n\t\tque[l].sec /= que[l].fir;\n\t\tque[l].fir -= lft;\n\t\tque[l].sec *= que[l].fir;\n\t\ttot = tot+que[l];\n\t\tmrg = pnt(V, T*V);\n\t\t/*\n\t\twhile (l <= r && que[r]*mrg < -EPS)\n\t\t\ttot = tot-que[r], mrg = mrg+que[r--];\n\t\tif (mrg.fir > C+EPS)\n\t\t\tmrg.sec /= mrg.fir, \n\t\t\tmrg.fir = C, \n\t\t\tmrg.sec *= mrg.fir;\n\t\ttot = tot+mrg, que[++r] = mrg;\n\t\t*/\n\t\twhile (l <= r && que[r]*mrg < -EPS)\n\t\t\tmrg = mrg+que[r--];\n\t\ttot = tot+pnt(V, T*V), que[++r] = mrg;\n\t\tprintf(\"%.7lf\\n\", tot.sec/tot.fir);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\nusing LD = long double;\n\nint main(void)\n{\n\tLL N, L;\n\tcin >> N >> L;\n\tvector<LD>temp;//温度\n\tvector<pair<LD,LL>>vec;//入力\n\tcout.precision(15);\n\tfor (int i = 0; i < N; ++i)\n\t{\n\t\tLL t, v;\n\t\tcin >> t >> v;\n\t\tLD cand = \n\t\t\t(temp.size() == 0 ? 0 : temp.back()) * (L - v)\n\t\t\t+ t * v;\n\t\tcand /= L;\n\t\tvec.push_back({ t,v });\n\t\tLL vol = v;\n\t\tLD plus = t;\n\t\t//candが良くなる間はずっと圧縮し続ける\n\t\tfor (;;)\n\t\t{\n\t\t\tif (temp.empty())break;\n\t\t\tplus = plus * vol + vec[vec.size() - 2].first * vec[vec.size() - 2].second;\n\t\t\tvol += vec[vec.size() - 2].second;\n\t\t\tplus /= vol;\n\t\t\tif (vol > L)break;\n\t\t\tLD test = temp[temp.size() - 2] * (L - vol) + plus * vol;\n\t\t\ttest /= L;\n\t\t\tif (cand < test)\n\t\t\t{\n\t\t\t\tcand = test;\n\t\t\t\ttemp.pop_back();\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.pop_back();\n\t\t\t\tvec.push_back({ plus,vol });\n\t\t\t}\n\t\t}\n\t\ttemp.push_back(cand);\n\t\tcout << cand << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\nstruct point{\n\tint x; ld y;\n\tbool operator <(const point b)const{\n\t\treturn y*b.x<b.y*x;\n\t}\n}q[500005];\nint head,tail;\nint main(){\n\tint n,l;\n\tscanf(\"%d%d\",&n,&l);\n\tld allt=0;int allv=0;\n\tint head=0,tail=-1;\n\tfor(int i=1;i<=n;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tpoint v=(point){y,(ld)x*y};\n\t\tallt+=v.y; allv+=v.x;\n\t\twhile(allv>l){\n\t\t//\tprintf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\t\tif(allv-q[head].x>=l){\n\t\t\t\tallt-=q[head].y;\n\t\t\t\tallv-=q[head].x;\n\t\t\t\thead++;\n\t\t\t}\n\t\t\tld v=q[head].y*(allv-l)/q[head].x;\n\t\t\tq[head].x-=allv-l;\n\t\t\tallv=l;\n\t\t\tq[head].y-=v;\n\t\t\tallt-=v;\n\t\t}\n\t\t//printf(\"%d %.6lf\\n\",allv,(double)allt);\n\t\tprintf(\"%.7lf\\n\",(double)(allt/allv));\n\t\twhile(tail>=head&&v<q[tail]){\n\t\t\tv.y+=q[tail].y;\n\t\t\tv.x+=q[tail].x;\n\t\t\ttail--;\n\t\t}\n\t\tq[++tail]=v;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef pair<int,int> pa;\ntypedef long double ld;\n#define w1 first\n#define w2 second\n#define ls (x<<1)\n#define rs (x<<1|1)\n#define pb push_back\n#define mp make_pair\n#define mid ((l+r)>>1)\n#define SZ(x) ((x).size())\n#define All(x) (x).begin(),(x).end()\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nint power(int x,int k,int p){int res=1;for(;k;k>>=1,x=1ll*x*x%p)if(k&1)res=1ll*res*x%p;return res;}\nconst int maxn=5e5+5;\nint n,L;\nld ans;\nld allx,ally,x[maxn],y[maxn];\npair<ld,ld>p[maxn],q[maxn];\nint main(){\n\tread(n);read(L);\n\trep(i,1,n){\n\t\tint t,v;read(t),read(v);\n\t\tx[i]=v,y[i]=1ll*t*v;\n\t}\n\tint h=0,t=0;\n\trep(i,1,n){\n\t\tallx+=x[i];\n\t\tally+=y[i];\n\t\twhile(allx>L){\n\t\t\tif(q[h].w1<=allx-L){\n\t\t\t\tally-=q[h].w2;\n\t\t\t\tallx-=q[h].w1;\n\t\t\t\th++;\n\t\t\t}else{\n\t\t\t\tally-=1ll*(allx-L)*(q[h].w2/q[h].w1);\n\t\t\t\tq[h].w2-=(allx-L)*(q[h].w2/q[h].w1);\n\t\t\t\tq[h].w1-=allx-L;\n\t\t\t\tallx=L;\n\t\t\t}\n\t\t}\n\t\twhile(h<t&&q[t-1].w2/q[t-1].w1>y[i]/x[i]){\n\t\t\tx[i]+=q[t-1].w1;\n\t\t\ty[i]+=q[t-1].w2;\n\t\t\tt--;\n\t\t}\n\t\tq[t++]=mp(x[i],y[i]);\n\t\tprintf(\"%.10f\\n\",double(ally/allx));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#include <climits>\n#include <bitset>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <limits>\n#include <string>\n#include <cmath>\n#include <set>\n#include <map>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nlong long int INF = 3e18;\nlong long int mod = 4294967296;\ndouble Pi = 3.1415926535897932384626;\n\nvector<ll> G[500005];\nvector<P> tree[500010];\npriority_queue <ll> pql;\npriority_queue <P> pqp;\n//big priority queue\npriority_queue <ll,vector<ll>,greater<ll> > pqls;\npriority_queue <P,vector<P>,greater<P> > pqps;\n//small priority queue\n//top pop\n\nint dx[8]={1,0,-1,0,1,1,-1,-1};\nint dy[8]={0,1,0,-1,1,-1,-1,1};\nchar dir[] = \"DRUL\";\n//ll bit[500005];\n//↓,→,↑,←\n\n\n#define p(x) cout<<x<<endl;\n#define el cout<<endl;\n#define pe(x) cout<<x<<\" \";\n#define ps(x) cout<<fixed<<setprecision(15)<<x<<endl;\n#define pu(x) cout<<x;\n#define re(i,n) for(i=0;i<n;i++);\n#define pb push_back\n#define lb lower_bound\n#define ub upper_bound\n#define deba(x) cout<< #x << \" = \" << x <<endl\n\n\nll rui(ll abc,ll bed){\n    //abcのbed乗を計算する\n    if(bed==0){return 1;}\n    else{\n        ll ced = rui(abc,bed/2);\n        ced *= ced;\n        ced %= mod;\n        if(bed%2==1){ced*=abc; ced%=mod;}\n        return ced;\n    }\n}\nll gcd(ll number1,ll number2){\n    if(number1 > number2){\n        swap(number1,number2);\n    }\n    if(number1 == 0 || number1 == number2){\n        return number2;\n    }else{\n        return gcd(number2 % number1,number1);\n    }\n}\nvoid YES(bool condition){\n    if(condition){\n        p(\"YES\");\n    }else{\n        p(\"NO\");\n    }\n    return;\n}\nvoid Yes(bool condition){\n    if(condition){\n        p(\"Yes\");\n    }else{\n        p(\"No\");\n    }\n    return;\n}\n\nll n,m,num,sum,b,c,d,e,f,g,h,i,j,k,w,ok,ng,l,r;\nlong double a;\nll x[500005],y[500005],z[500005];\nll bainum;\nll lef[800005],righ[800005];\nlong double bai[800005];\nlong double ans[800005];\nlong double ans1,ans0;\nlong double table[800005];\nbool flag,dame;\n\nint main(){\n    cin >> n >> l;\n\tfor(i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tans[0] = x[0] * y[0];\n\tans[1] = y[1] * x[1] + (l - y[1]) * x[0];\n\ttable[0] = l - y[1];\n\ttable[1] = y[1];\n\tnum = 0;\n\tfor(i=2;i<n;i++){\n\t\t//ans[i]を求める\n\t\t//ans0 := 圧縮\n\t\ttable[i] = y[i];\n\t\tans0 = y[i] * x[i];\n\t\tans0 += ans[i-1] * (l - y[i]) / l;\n\n\t\tans1 = y[i] * x[i];\n\t\tans1 += ans[i-1];\n\t\ta = y[i];\n\t\tb = num;\n\t\twhile(a > 0){\n\t\t\tfor(j=0;j<bainum;j++){\n\t\t\t\tif(lef[j] <= b && b <= righ[j]){\n\t\t\t\t\ttable[b] *= bai[j];\n\t\t\t\t}\n\t\t\t\tif(lef[j] == b){\n\t\t\t\t\tlef[j]++;\n\t\t\t\t}else{\n\t\t\t\t\tlef[bainum] = lef[j];\n\t\t\t\t\trigh[bainum] = b-1;\n\t\t\t\t\tbainum++;\n\t\t\t\t\tlef[bainum] = b+1;\n\t\t\t\t\trigh[bainum] = righ[j];\n\t\t\t\t\tbainum++;\n\t\t\t\t\tlef[j] = 0;\n\t\t\t\t\trigh[j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(table[b] > 0){\n\t\t\t\tans1 -= x[b] * min((long double)a,table[b]);\n\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t}\n\t\t\tb++;\n\t\t}\n\t\tif(ans1 > ans0){\n\t\t\tans[i] = ans1;\n\t\t\ta = y[i];\n\t\t\tb = num;\n\t\t\twhile(a > 0){\n\t\t\t\tif(table[b] > 0){\n\t\t\t\t\tlong double c = a;\n\t\t\t\t\ta -= min((long double)a,table[b]);\n\t\t\t\t\ttable[b] -= min((long double)c,table[b]);\n\t\t\t\t}\n\t\t\t\tif(table[b] == 0 && a > 0)b++;\n\t\t\t}\n\t\t\tnum = b;\n\t\t}else{\n\t\t\tbai[bainum] = (long double)(l - y[i]) / (long double)l;\n\t\t\tlef[bainum] = num;\n\t\t\trigh[bainum] = i;\n\t\t\tbainum++;\n\t\t\tans[i] = ans0;\n\t\t}\n\t}\t\n\tfor(i=0;i<n;i++)ps(ans[i]/l);\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\nimport Data.Ord\nimport Text.Printf\nmain = getLine >>= main' . fmap read . words\n    where\n        main' [n, l] = replicateM n getLine >>= mapM_ (printf \"%.7f\\n\") . solve l 0 [] . fmap ((\\[t, v] -> (read t, read v)) . words)\n\n\nsolve :: Int -> Double -> [(Double, Int)] -> [(Double, Int)] -> [Double]\nsolve r p ys (x@(t, v) : xs)\n    | p <= t = inc : solve r t (insertBy (flip (comparing fst)) x ys) xs\n    | otherwise = inc : solve r inc [(inc, r)] xs\n    where\n\n        inc = tv / fromIntegral r\n        tv = calc (r - v) (t * fromIntegral v) ys\n\nsolve _ _ _ _ = []\n\ncalc :: Int -> Double -> [(Double, Int)] -> Double\ncalc r acc ((t, v) : xs)\n    | r >= v = calc (r - v) (acc + t * fromIntegral v) xs\n    | otherwise = acc + fromIntegral r * t\ncalc _ acc _ = acc\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Text.Printf\nmain = getLine >>= main' . fmap read . words\n    where\n        main' [n, l] = replicateM n getLine >>= mapM_ (printf \"%.7f\\n\") . solve l 0 0 [] . fmap ((\\[t, v] -> (read t, read v)) . words)\n\n\nsolve :: Int -> Double -> Double -> [(Double, Int)] -> [(Double, Int)] -> [Double]\nsolve r p s ys (x@(t, v) : xs)\n    | p <= t = inc : solve r t tv (insert x ys) xs\n    | otherwise = inc : solve r inc tv [(inc, r)] xs\n    where\n        inc = tv / fromIntegral r\n        tv = calc s v ys + (t * fromIntegral v)\n\nsolve _ _ _ _ _ = []\n\ncalc :: Double -> Int -> [(Double, Int)] -> Double\ncalc acc n ((t, v) : xs)\n    | n > v = calc (acc - t * fromIntegral v) (n - v) xs\n    | otherwise = acc - t * fromIntegral n\ncalc acc _ _ = acc\n\ninsert :: (Double, Int) -> [(Double, Int)] -> [(Double, Int)]\ninsert (xt, xv) (y@(yt, yv) : zs)\n    | xt <= yt = y : zs\n    | xv >= yv = insert (xt, xv - yv) zs\n    | otherwise = (yt, yv - xv) : insert (xt, xv) zs\ninsert x _ = [x]\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\nimport Data.Ord\nimport Text.Printf\nmain = getLine >>= main' . fmap read . words\n    where\n        main' [n, l] = replicateM n getLine >>= mapM_ (printf \"%.7f\\n\") . solve l [] . fmap ((\\[t, v] -> (read t, read v)) . words)\n\nsolve :: Int -> [(Int, Int)] -> [(Int, Int)] -> [Double]\nsolve l ys (x@(t, v) : xs) = fromIntegral tv / fromIntegral l : solve l (insertBy (flip compare) x ys) xs\n    where\n        tv = calc (l - v) (t * v) ys\n\n        calc r acc ((xt, xv) : xtvs)\n            | r >= xv = calc (r - xv) (acc + xt * xv) xtvs\n            | otherwise = acc + r * xt\n        calc _ acc _ = acc\n\nsolve _ _ _ = []\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nvoid run(void){\n  int n,l;\n  scanf(\"%d%d\",&n,&l);\n  double *dp=(double *)calloc(2*(l+1),sizeof(double));\n  int t,v;\n  scanf(\"%d%d\",&t,&v);\n  printf(\"%.7f\\n\",(double)t);\n  int i,j;\n  for(i=0;i<=l;i++) dp[i]=t;\n  int now=0;\n  for(i=1;i<n;i++){\n    scanf(\"%d%d\",&t,&v);\n    int next=now^(l+1);\n    dp[next+l]=(dp[now+l-v]*(l-v)+(double)v*t)/l;\n    for(j=l-1;j>=v;j--){\n      double tmp=(dp[now+j-v]*(j-v)+(double)v*t)/j;\n      dp[next+j]=tmp>dp[next+j+1]?tmp:dp[next+j+1];\n    }\n    for(j=v-1;j>=0;j--) dp[next+j]=dp[next+j+1];\n    printf(\"%.7f\\n\",dp[next+l]);\n    now=next;\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thx Ebi-chan!\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 20000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1048576\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\n#ifndef M_PI\n#define M_PI 3.14159265358979323846264338327950\n#endif\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\ntypedef struct {\n\tdouble a;\n\tdouble b;\n} hwreal;\n\nsll n, m;\nsll h, w;\nsll k;\nsll q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\ndouble dmin (double x, double y) {\n\treturn (x < y) ? x : y;\n}\n\ndouble dmax (double x, double y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(sll);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleCABcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.c, r.c);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwrealcomp){\n\tDEFLR(hwreal);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\nint32_t pfracomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tCMPRET(l.a * r.b, l.b * r.a);\n\treturn 0;\n}\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nvoid sw (sll *l, sll *r) {\n\tif (*l == *r) return;\n\tsll t = *l;\n\t*l = *r;\n\t*r = t;\n}\n\null frac[N_MAX * 3], invf[N_MAX * 3];\null ncr (sll n, sll r, ull m) {\n\tif (n < 0 || r < 0 || n < r) return 0;\n\treturn frac[n] * (invf[r] * invf[n - r] % m) % m;\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\nsll c[N_MAX + 5];\nsll d[N_MAX + 5];\nsll e[N_MAX * 4];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\nchar u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\null gin[N_MAX];\n// here we go\n\ntypedef struct {\n\tdouble a;\n\tull b;\n} p;\n\np stack[N_MAX];\ndouble vt;\null beg = 0, end = 0;\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tsll *dpcell;\n\n\tprintf(\"%lld\\n\", a[0]);\n\tstack[end++] = (p){(double)a[0], b[0]};\n\tsum = k;\n\tvt = (double)a[0] * (double)b[0];\n\n\tfor (i = 1; i < n; i++) {\n\t\twhile (sum > k - b[i]) {\n\t\t\tif (sum - stack[beg].b <= k - b[i]) {\n\t\t\t\tsll sub = sum - (k - b[i]);\n\t\t\t\t\n\t\t\t\tvt -= stack[beg].a * (double)sub;\n\t\t\t\tsum -= sub;\n\t\t\t\tstack[beg].b -= sub;\n\t\t\t} else {\n\t\t\t\tvt -= stack[beg].a * (double)stack[beg].b;\n\t\t\t\tsum -= stack[beg].b;\n\n\t\t\t\tbeg++;\n\t\t\t}\n\t\t}\n\n\t\t// printf(\"[%lld %lld)\\n\", beg, end);\n\t\t// for (j = beg; j < end; j++) {\n\t\t// \tprintf(\"%.15lf * %lld\\n\", stack[j].a, stack[j].b);\n\t\t// }\n\t\t// printf(\"sum: %.15lf\\n\", vt);\n\n\t\tprintf(\"%.15lf\\n\", (vt + (double)a[i] * (double)b[i]) / (double)k);\n\n\t\tvt += (double)a[i] * (double)b[i];\n\t\tsum += b[i];\n\t\tstack[end] = (p){(double)a[i], b[i]};\n\t\tend++;\n\t\twhile (end - beg >= 2 && stack[end - 2].a > stack[end - 1].a) {\n\t\t\tstack[end - 2] = (p){\n\t\t\t\t(stack[end - 2].a * stack[end - 2].b + stack[end - 1].a * stack[end - 1].b)\n\t\t\t\t/ ((stack[end - 2].b) + (stack[end - 1].b)),\n\n\t\t\t\t((stack[end - 2].b) + (stack[end - 1].b))\n\t\t\t};\n\t\t\tend--;\n\t\t}\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15f\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"First\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\tputs(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Second\");\n\treturn 1;\n}\n\nint32_t main (int argc, char *argv[]) {\n\tint32_t i, j;\n\n\tn = 4;\n\tm = 0;\n\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\tscanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// va--;\n\t// vb--;\n\t// scanf(\"%llu%llu%llu%llu\", &ua, &ub, &uc, &ud, &ue);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%s\", u);\n\t// scanf(\"%llu\", &k);\n\t// scanf(\"%lld\", &m);\n\t// for (i = 0; i < n; i++) {\n\t// \t// scanf(\"%lld\", &a[i]);\n\t// \tscanf(\"%lld\", &d[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\t// scanf(\"%lld\", &c[i]);\n\n\t\tscanf(\"%lld\", &a[i]);\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < m; i++) {\n\t// \tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \txy[i].a--;\n\t// \txy[i].b--;\n\t// \t// scanf(\"%lld%lld\", &a[i], &b[i]);\n\t// \t// scanf(\"%lld\", &b[i]);\n\t// \t// a[i]--;\n\t// \t// b[i]--;\n\t// \t// scanf(\"%lld\", &c[i]);\n\t// \t// scanf(\"%lld\", &d[i]);\n\t// \t// scanf(\"%lld\", &e[i]);\n\t// \t// c[i]--;\n\t// \t// d[i]--;\n\t// }\n\n\t// for (i = 0; i < q; i++) {\n\t// \t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \tscanf(\"%lld\", &c[i]);\n\t// \t// xy[i].a--;\n\t// \t// xy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct water{\n  double t;\n  int v;\n} node;\n\nint readInt(void){\n  int c=getchar();\n  while(!('0'<=c && c<='9')) c=getchar();\n  int res=0;\n  while('0'<=c && c<='9'){\n    res=10*res+c-'0';\n    c=getchar();\n  }\n  return res;\n}\n\nvoid run(void){\n  int n,l;\n  scanf(\"%d%d\",&n,&l);\n  node *q=(node *)calloc(n,sizeof(node));\n  int front=0;\n  int last=0;\n  double t;\n  int v;\n  scanf(\"%lf%d\",&t,&v);\n  printf(\"%.7f\\n\",t);\n  q[last++]=(node){t,v};\n  double qtv=t*v;\n  int i;\n  for(i=1;i<n;i++){\n    node in;\n    in.t=readInt();\n    in.v=readInt();\n    int sum=0;\n    node p=q[front];\n    while(sum+p.v<=in.v){\n      qtv-=p.v*p.t;\n      sum+=p.v;\n      front++;\n      p=q[front];\n    }\n    if(sum<in.v){\n      qtv-=q[front].t*(in.v-sum);\n      q[front].v-=in.v-sum;\n    }\n    qtv+=in.t*in.v;\n    while(front<last && q[last-1].t>in.t){\n      last--;\n      p=q[last];\n      in=(node){(in.t*in.v+p.t*p.v)/(in.v+p.v),in.v+p.v};\n    }\n    q[last++]=in;\n    printf(\"%.7f\\n\",qtv/l);\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nvoid run(void){\n  int n,l;\n  scanf(\"%d%d\",&n,&l);\n  if(l>1000) exit(1);\n  double *dp=(double *)calloc(2*(l+1),sizeof(double));\n  int t,v;\n  scanf(\"%d%d\",&t,&v);\n  printf(\"%.7f\\n\",(double)t);\n  int i,j;\n  for(i=0;i<=l;i++) dp[i]=t;\n  int now=0;\n  for(i=1;i<n;i++){\n    scanf(\"%d%d\",&t,&v);\n    int next=now^(l+1);\n    dp[next+l]=(dp[now+l-v]*(l-v)+(double)v*t)/l;\n    for(j=l-1;j>=v;j--){\n      double tmp=(dp[now+j-v]*(j-v)+(double)v*t)/j;\n      dp[next+j]=tmp>dp[next+j+1]?tmp:dp[next+j+1];\n    }\n    for(j=v-1;j>=0;j--) dp[next+j]=dp[next+j+1];\n    printf(\"%.7f\\n\",dp[next+l]);\n    now=next;\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\ntypedef struct water{\n  double t;\n  int v;\n} node;\n\nvoid run(void){\n  int n,l;\n  scanf(\"%d%d\",&n,&l);\n  node *q=(node *)calloc(n,sizeof(node));\n  int front=0;\n  int last=0;\n  double t;\n  int v;\n  scanf(\"%lf%d\",&t,&v);\n  printf(\"%.7f\\n\",t);\n  q[last++]=(node){t,v};\n  double qtv=t*v;\n  int i;\n  for(i=1;i<n;i++){\n    node in;\n    scanf(\"%lf%d\",&in.t,&in.v);\n    int sum=0;\n    node p=q[front];\n    while(sum+p.v<=in.v){\n      qtv-=p.v*p.t;\n      sum+=p.v;\n      front++;\n      p=q[front];\n    }\n    if(sum<in.v){\n      qtv-=q[front].t*(in.v-sum);\n      q[front].v-=in.v-sum;\n    }\n    qtv+=in.t*in.v;\n    while(front<last && q[last-1].t>in.t){\n      last--;\n      p=q[last];\n      in=(node){(in.t*in.v+p.t*p.v)/(in.v+p.v),in.v+p.v};\n    }\n    q[last++]=in;\n    printf(\"%.7f\\n\",qtv/l);\n  }\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define N\t500000\n\ndouble xx[N + 1], yy[N + 1];\n\ndouble cross2(double x1, double y1, double x2, double y2) {\n\treturn x1 * y2 - x2 * y1;\n}\n\ndouble cross(int i, int j, int k) {\n\treturn cross2(xx[j] - xx[i], yy[j] - yy[i], xx[k] - xx[i], yy[k] - yy[i]);\n}\n\nint main() {\n\tstatic int qu[N + 1];\n\tint n, i, l, head, cnt;\n\n\tscanf(\"%d%d\", &n, &l);\n\thead = cnt = 0;\n\txx[0] = 0, yy[0] = 0, qu[head + cnt++] = 0;\n\tfor (i = 1; i <= n; i++) {\n\t\tint t, v;\n\n\t\tscanf(\"%d%d\", &t, &v);\n\t\txx[i] = xx[i - 1] - v;\n\t\tyy[i] = yy[i - 1] - (long long) v * t;\n\t\tif (i > 1) {\n\t\t\twhile (cnt > 1 && xx[qu[head + 1]] - xx[i] >= l)\n\t\t\t\thead++, cnt--;\n\t\t\tyy[qu[head]] -= (xx[qu[head]] - xx[i] - l) * (yy[qu[head + 1]] - yy[qu[head]]) / (xx[qu[head + 1]] - xx[qu[head]]);\n\t\t\txx[qu[head]] = xx[i] + l;\n\t\t}\n\t\tprintf(\"%f\\n\", (yy[qu[head]] - yy[i]) / l);\n\t\twhile (cnt > 1 && cross(qu[head + cnt - 2], qu[head + cnt - 1], i) <= 0)\n\t\t\tcnt--;\n\t\tqu[head + cnt++] = i;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble totSalt = 0;\n\t\tdouble totV = 0;\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tArrayDeque<double[]> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t\tdouble nextSalt = t[i] * v[i];\n\t\t\tdouble nextV = v[i];\n\t\t\tlong sum = 0;\n\t\t\twhile (nextV > sum && i != 0) {\n\t\t\t\tdouble[] state = dq.pollLast();\n\t\t\t\tif (nextV - (sum + state[1]) >= 0) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tsum += state[1];\n\t\t\t\t} else {\n\t\t\t\t\tdouble r = (state[1] - (nextV - sum)) / state[1];\n\t\t\t\t\tsum += (1 - r) * state[1];\n\t\t\t\t\ttotSalt -= (1 - r) * state[0];\n\t\t\t\t\ttotV -= (1 - r) * state[1];\n\t\t\t\t\tstate[0] *= r;\n\t\t\t\t\tstate[1] *= r;\n\t\t\t\t\tdq.addLast(state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!dq.isEmpty()) {\n\t\t\t\tdouble[] state = dq.peekFirst();\n\t\t\t\tif (state[0] / state[1] >= nextSalt / nextV) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tnextSalt += state[0];\n\t\t\t\t\tnextV += state[1];\n\t\t\t\t\tdq.pollFirst();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdq.addFirst(new double[] { nextSalt, nextV });\n\t\t\ttotSalt += nextSalt;\n\t\t\ttotV += nextV;\n\t\t\tif(i%1000==0)System.gc();\n\t\t\tpw.println(String.format(\"%.20f\", totSalt / totV));\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\t\tthrow new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble totSalt = 0;\n\t\tdouble totV = 0;\n\t\tArrayDeque<double[]> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdouble t = sc.nextDouble();\n\t\t\tdouble v = sc.nextDouble();\n\t\t\tdouble nextSalt = t * v;\n\t\t\tdouble nextV = v;\n\t\t\tlong sum = 0;\n\t\t\twhile (nextV > sum && i != 0) {\n\t\t\t\tdouble[] state = dq.pollLast();\n\t\t\t\tif (nextV - (sum + state[1]) >= 0) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tsum += state[1];\n\t\t\t\t} else {\n\t\t\t\t\tdouble r = (state[1] - (nextV - sum)) / state[1];\n\t\t\t\t\tsum += (1 - r) * state[1];\n\t\t\t\t\ttotSalt -= (1 - r) * state[0];\n\t\t\t\t\ttotV -= (1 - r) * state[1];\n\t\t\t\t\tstate[0] *= r;\n\t\t\t\t\tstate[1] *= r;\n\t\t\t\t\tdq.addLast(state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!dq.isEmpty()) {\n\t\t\t\tdouble[] state = dq.peekFirst();\n\t\t\t\tif (state[0] / state[1] >= nextSalt / nextV) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tnextSalt += state[0];\n\t\t\t\t\tnextV += state[1];\n\t\t\t\t\tdq.pollFirst();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdq.addFirst(new double[] { nextSalt, nextV });\n\t\t\ttotSalt += nextSalt;\n\t\t\ttotV += nextV;\n\t\t\tif (i % 1000 == 0)\n\t\t\t\tSystem.gc();\n\t\t\tpw.println(String.format(\"%.20f\", totSalt / totV));\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\t\tthrow new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tlong L = sc.nextLong();\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t}\n\t\tclass T {\n\t\t\tdouble water;\n\t\t\tdouble salt;\n\n\t\t\tpublic T(double water, double salt) {\n\t\t\t\tthis.water = water;\n\t\t\t\tthis.salt = salt;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<T> deque = new ArrayDeque<>();\n\t\tdeque.addLast(new T(0, 0));\n\t\tdeque.addLast(new T(v[0], t[0] * v[0]));\n\t\tT p = new T(0, 0);\n\t\tpw.println(t[0]);\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tp.water += v[i];\n\t\t\tp.salt += t[i] * v[i];\n\t\t\tdeque.addFirst(new T(-p.water, -p.water * p.salt));\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t2 = deque.pollLast();\n\t\t\t\tT t1 = deque.pollLast();\n\t\t\t\tif (t1.water + p.water > L && t2.water + p.water > L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (t1.water + p.water == L) {\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t1.water + p.water < L && L < t2.water + p.water) {\n\t\t\t\t\tdouble r1 = (t2.water + p.water - L) / (t2.water - t1.water);\n\t\t\t\t\tdouble r2 = (L - (t1.water + p.water)) / (t2.water - t1.water);\n\t\t\t\t\tT tLast = new T(r1 * (t1.water + p.water) + r2 * (t2.water + p.water),\n\t\t\t\t\t\t\tr1 * (t1.salt + p.salt) + r2 * (t2.salt + p.salt));\n\t\t\t\t\ttLast.water -= p.water;\n\t\t\t\t\ttLast.salt -= p.salt;\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tdeque.addLast(tLast);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeque.pollFirst();\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t1 = deque.pollFirst();\n\t\t\t\tT t2 = deque.pollFirst();\n\t\t\t\tif ((t1.salt + p.salt) / (t1.water + p.water) > (t2.salt + p.salt) / (t2.water + p.water)) {\n\t\t\t\t\tdeque.addFirst(t2);\n\t\t\t\t\tdeque.addFirst(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdeque.addFirst(t2);\n\t\t\t}\n\t\t\tdeque.addFirst(new T(-p.water, -p.salt));\n\t\t\tif (deque.size() < 2)\n\t\t\t\tthrow new AssertionError();\n\t\t\tpw.println((deque.peekLast().salt + p.salt) / (deque.peekLast().water + p.water));\n\t\t}\n\t\tpw.close();\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tlong L = sc.nextLong();\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t}\n\t\tclass T {\n\t\t\tdouble water;\n\t\t\tdouble salt;\n\n\t\t\tpublic T(double water, double salt) {\n\t\t\t\tthis.water = water;\n\t\t\t\tthis.salt = salt;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<T> deque = new ArrayDeque<>();\n\t\tdeque.addLast(new T(0, 0));\n\t\tdeque.addLast(new T(v[0], t[0] * v[0]));\n\t\tT p = new T(0, 0);\n\t\tpw.println(t[0]);\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tp.water += v[i];\n\t\t\tp.salt += t[i] * v[i];\n\t\t\tdeque.addFirst(new T(-p.water, -p.water * p.salt));\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t2 = deque.pollLast();\n\t\t\t\tT t1 = deque.pollLast();\n\t\t\t\tif (t1.water + p.water > L && t2.water + p.water > L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (t1.water + p.water == L) {\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t1.water + p.water < L && L < t2.water + p.water) {\n\t\t\t\t\tdouble r1 = (t2.water + p.water - L) / (t2.water - t1.water);\n\t\t\t\t\tdouble r2 = (L - (t1.water + p.water)) / (t2.water - t1.water);\n\t\t\t\t\tT tLast = new T(r1 * (t1.water + p.water) + r2 * (t2.water + p.water),\n\t\t\t\t\t\t\tr1 * (t1.salt + p.salt) + r2 * (t2.salt + p.salt));\n\t\t\t\t\ttLast.water -= p.water;\n\t\t\t\t\ttLast.salt -= p.salt;\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tdeque.addLast(tLast);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeque.pollFirst();\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t1 = deque.pollFirst();\n\t\t\t\tT t2 = deque.pollFirst();\n\t\t\t\tif ((t1.salt + p.salt) / (t1.water + p.water) > (t2.salt + p.salt) / (t2.water + p.water)) {\n\t\t\t\t\tdeque.addFirst(t2);\n\t\t\t\t\tdeque.addFirst(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdeque.addFirst(t2);\n\t\t\t}\n\t\t\tdeque.addFirst(new T(-p.water, -p.salt));\n\t\t\tpw.println((deque.peekFirst().salt + p.salt) / (deque.peekFirst().water + p.water));\n\t\t\tif (deque.size() < 2)\n\t\t\t\tthrow new AssertionError();\n\t\t\tpw.println((deque.peekLast().salt + p.salt) / (deque.peekLast().water + p.water));\n\t\t}\n\t\tpw.close();\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tDeque<double[]> q = new ArrayDeque<>();\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && q.size() > 0){\n\t\t\t\tdouble[] cur = q.pollFirst();\n\t\t\t\tif(V - cur[1] <= L){\n\t\t\t\t\tS -= cur[0] * (V - L);\n\t\t\t\t\tcur[1] = L - (V-cur[1]);\n\t\t\t\t\tq.addFirst(cur);\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= cur[1];\n\t\t\t\t\tS -= (double)cur[0] * cur[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(q.size() > 0 && ts[i] < q.peekLast()[0]){\n\t\t\t\t// fullmix\n\t\t\t\tq.clear();\n\t\t\t\tq.addLast(new double[]{S / V, V});\n\t\t\t}else{\n\t\t\t\tq.addLast(new double[]{ts[i], vs[i]});\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tDeque<double[]> q = new ArrayDeque<>();\n\t\tlong V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && q.size() > 0){\n\t\t\t\tdouble[] cur = q.pollFirst();\n\t\t\t\tif(V - cur[1] <= L){\n\t\t\t\t\tS -= cur[0] * (double)(V - L);\n\t\t\t\t\tcur[1] = L - (V-cur[1]);\n\t\t\t\t\tq.addFirst(cur);\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= cur[1];\n\t\t\t\t\tS -= (double)cur[0] * cur[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(q.size() > 0 && ts[i] < q.peekLast()[0]){\n\t\t\t\t// fullmix\n\t\t\t\tq.clear();\n\t\t\t\tq.addLast(new double[]{S / V, V});\n\t\t\t}else{\n\t\t\t\tq.addLast(new double[]{ts[i], vs[i]});\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tDeque<double[]> q = new ArrayDeque<>();\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && q.size() > 0){\n\t\t\t\tdouble[] cur = q.pollFirst();\n\t\t\t\tif(V - cur[1] <= L){\n\t\t\t\t\tS -= cur[0] * (double)(V - L);\n\t\t\t\t\tcur[1] = L - (V-cur[1]);\n\t\t\t\t\tq.addFirst(cur);\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= cur[1];\n\t\t\t\t\tS -= (double)cur[0] * cur[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t\t\n\t\t\tq.addLast(new double[]{ts[i], vs[i]});\n\t\t\touter:\n\t\t\twhile(true){\n\t\t\t\tif(q.size() >= 2){\n\t\t\t\t\tdouble[] last = q.pollLast();\n\t\t\t\t\tdouble[] last2 = q.pollLast();\n\t\t\t\t\tif(last2[0] < last[0]){\n\t\t\t\t\t\tq.addLast(last2);\n\t\t\t\t\t\tq.addLast(last);\n\t\t\t\t\t\tbreak outer;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlast[0] = (last[0]*last[1]+last2[0]*last2[1]) / (last[1]+last2[1]);\n\t\t\t\t\t\tlast[1] += last2[1];\n\t\t\t\t\t\tq.addLast(last);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tint tail = 0, head = 0;\n\t\t\n\t\tdouble[] qtv = new double[n];\n\t\tdouble[] qv = new double[n];\n\t\t\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && tail < head){\n\t\t\t\tint ind = tail++;\n\t\t\t\tif(V - qv[ind] <= L){\n\t\t\t\t\tS -= qtv[ind] * (double)(V - L);\n\t\t\t\t\tqv[ind] = L - (V-qv[ind]);\n\t\t\t\t\t--tail;\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= qv[ind];\n\t\t\t\t\tS -= (double)qtv[ind] * qv[ind];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t\t\n\t\t\tqtv[head] = ts[i];\n\t\t\tqv[head] = vs[i];\n\t\t\thead++;\n\t\t\twhile(head - tail >= 2){\n\t\t\t\tint l1 = head-1, l2 = head-2;\n\t\t\t\tif(qtv[l2] < qtv[l1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tqtv[l2] = (qtv[l1]*qv[l1]+qtv[l2]*qv[l2])/(qv[l1]+qv[l2]);\n\t\t\t\t\tqv[l2] += qv[l1];\n\t\t\t\t\thead--;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\n\npublic class Main {\n    static long __startTime = System.currentTimeMillis();\n\n    static class Water {\n        double temp;\n        long volume;\n\n\n        public Water(double t, long v) {\n            temp = t;\n            volume = v;\n        }\n\n        public void mergeInto(Water w) {\n            double total = w.temp * w.volume + temp * volume;\n            w.volume += volume;\n            w.temp = total / w.volume;\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long L = in.nextInt();\n        Water[] waters = new Water[n];\n        for (int i = 0; i < n ; i++) {\n            waters[i] = new Water(in.nextInt(), in.nextInt());\n        }\n\n\n        Deque<Water> deq = new ArrayDeque<>();\n        deq.push(new Water(0, 0));\n\n        long total = 0;\n        double amount = 0;\n\n        for (int i = 0; i < n ; i++) {\n            while (total + waters[i].volume > L) {\n                long needToTrash = total + waters[i].volume - L;\n                Water cold = deq.peekFirst();\n\n                long canTrash = Math.min(needToTrash, cold.volume);\n                total -= canTrash;\n                amount -= canTrash * cold.temp;\n                cold.volume -= canTrash;\n                if (cold.volume == 0) {\n                    deq.pollFirst();\n                }\n            }\n\n            total += waters[i].volume;\n            amount += waters[i].volume * waters[i].temp;\n            out.println(String.format(\"%.12f\", amount / total));\n\n            Water wantToPush = waters[i];\n            while (true) {\n                Water last = deq.peekLast();\n                if (last == null || last.temp <= wantToPush.temp) {\n                    deq.addLast(wantToPush);\n                    break;\n                } else {\n                    wantToPush.mergeInto(last);\n                    wantToPush = deq.pollLast();\n                }\n            }\n        }\n        out.flush();\n    }\n\n    private static void printTime(String label) {\n        debug(label, System.currentTimeMillis() - __startTime);\n    }\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tDeque<double[]> q = new ArrayDeque<>();\n\t\tlong V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && q.size() > 0){\n\t\t\t\tdouble[] cur = q.pollFirst();\n\t\t\t\tif(V - cur[1] <= L){\n\t\t\t\t\tdouble ds = cur[0] / cur[1] * (double)(V - L);\n\t\t\t\t\tS -= ds;\n\t\t\t\t\tcur[0] -= ds;\n\t\t\t\t\tcur[1] = L - (V-cur[1]);\n\t\t\t\t\tq.addFirst(cur);\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= cur[1];\n\t\t\t\t\tS -= cur[0];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(q.size() > 0 && ts[i] < q.peekLast()[0]/q.peekLast()[1]){\n\t\t\t\t// fullmix\n\t\t\t\tq.clear();\n\t\t\t\tq.addLast(new double[]{S, V});\n\t\t\t}else{\n\t\t\t\tq.addLast(new double[]{(double)ts[i]*vs[i], vs[i]});\n\t\t\t}\n\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n \npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n \n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble totSalt = 0;\n\t\tdouble totV = 0;\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tArrayDeque<double[]> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t\tdouble nextSalt = t[i] * v[i];\n\t\t\tdouble nextV = v[i];\n\t\t\tlong sum = 0;\n\t\t\twhile (nextV > sum && i != 0) {\n\t\t\t\tdouble[] state = dq.pollLast();\n\t\t\t\tif (nextV - (sum + state[1]) >= 0) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tsum += state[1];\n\t\t\t\t} else {\n\t\t\t\t\tdouble r = (state[1] - (nextV - sum)) / state[1];\n\t\t\t\t\tsum += (1 - r) * state[1];\n\t\t\t\t\ttotSalt -= (1 - r) * state[0];\n\t\t\t\t\ttotV -= (1 - r) * state[1];\n\t\t\t\t\tstate[0] *= r;\n\t\t\t\t\tstate[1] *= r;\n\t\t\t\t\tdq.addLast(state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!dq.isEmpty()) {\n\t\t\t\tdouble[] state = dq.peekFirst();\n\t\t\t\tif (state[0] / state[1] >= nextSalt / nextV) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tnextSalt += state[0];\n\t\t\t\t\tnextV += state[1];\n\t\t\t\t\tdq.pollFirst();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdq.addFirst(new double[] { nextSalt, nextV });\n\t\t\ttotSalt += nextSalt;\n\t\t\ttotV += nextV;\n\t\t\tif(i%10000==0)System.gc();\n\t\t\tpw.println(String.format(\"%.20f\", totSalt / totV));\n\t\t}\n\t\tpw.close();\n\t}\n \n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n \n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n \n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\t\tthrow new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static String dtos(double x) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(x < 0){\n\t\t\tsb.append('-');\n\t\t\tx = -x;\n\t\t}\n\t\tx += 5e-11;\n//\t\tif(x < 0){ x = 0; }\n\t\tsb.append((long)x);\n\t\tsb.append(\".\");\n\t\tx -= (long)x;\n\t\tfor(int i = 0;i < 10;i++){\n\t\t\tx *= 10;\n\t\t\tsb.append((int)x);\n\t\t\tx -= (int)x;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint tail = 0, head = 0;\n\t\t\n\t\tdouble[] qtv = new double[n];\n\t\tdouble[] qv = new double[n];\n\t\t\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint t = ni(), v = ni();\n\t\t\tV += v;\n\t\t\tS += (double)t * v;\n\t\t\twhile(V > L && tail < head){\n\t\t\t\tint ind = tail++;\n\t\t\t\tif(V - qv[ind] <= L){\n\t\t\t\t\tS -= qtv[ind] * (double)(V - L);\n\t\t\t\t\tqv[ind] = L - (V-qv[ind]);\n\t\t\t\t\t--tail;\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= qv[ind];\n\t\t\t\t\tS -= (double)qtv[ind] * qv[ind];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(dtos(S/L));\n//\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t\t\n\t\t\tqtv[head] = t;\n\t\t\tqv[head] = v;\n\t\t\thead++;\n\t\t\twhile(head - tail >= 2){\n\t\t\t\tint l1 = head-1, l2 = head-2;\n\t\t\t\tif(qtv[l2] < qtv[l1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tqtv[l2] = (qtv[l1]*qv[l1]+qtv[l2]*qv[l2])/(qv[l1]+qv[l2]);\n\t\t\t\t\tqv[l2] += qv[l1];\n\t\t\t\t\thead--;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n \npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n \n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble totSalt = 0;\n\t\tdouble totV = 0;\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tArrayDeque<double[]> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t\tdouble nextSalt = t[i] * v[i];\n\t\t\tdouble nextV = v[i];\n\t\t\tlong sum = 0;\n\t\t\twhile (nextV > sum && i != 0) {\n\t\t\t\tdouble[] state = dq.pollLast();\n\t\t\t\tif (nextV - (sum + state[1]) >= 0) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tsum += state[1];\n\t\t\t\t} else {\n\t\t\t\t\tdouble r = (state[1] - (nextV - sum)) / state[1];\n\t\t\t\t\tsum += (1 - r) * state[1];\n\t\t\t\t\ttotSalt -= (1 - r) * state[0];\n\t\t\t\t\ttotV -= (1 - r) * state[1];\n\t\t\t\t\tstate[0] *= r;\n\t\t\t\t\tstate[1] *= r;\n\t\t\t\t\tdq.addLast(state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!dq.isEmpty()) {\n\t\t\t\tdouble[] state = dq.peekFirst();\n\t\t\t\tif (state[0] / state[1] >= nextSalt / nextV) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tnextSalt += state[0];\n\t\t\t\t\tnextV += state[1];\n\t\t\t\t\tdq.pollFirst();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdq.addFirst(new double[] { nextSalt, nextV });\n\t\t\ttotSalt += nextSalt;\n\t\t\ttotV += nextV;\n\t\t\tif(i%20000==0)System.gc();\n\t\t\tpw.println(String.format(\"%.20f\", totSalt / totV));\n\t\t}\n\t\tpw.close();\n\t}\n \n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n \n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n \n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n \n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n \n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n \n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t\treturn hasNextByte();\n\t\t}\n \n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n \n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n \n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\t\tthrow new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n \n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tlong L = sc.nextLong();\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t}\n\t\tclass T {\n\t\t\tdouble water;\n\t\t\tdouble salt;\n\n\t\t\tpublic T(double water, double salt) {\n\t\t\t\tthis.water = water;\n\t\t\t\tthis.salt = salt;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<Double> dequeW = new ArrayDeque<>();\n\t\tArrayDeque<Double> dequeS = new ArrayDeque<>();\n\t\tdequeS.add(0d);\n\t\tdequeW.add(0d);\n\t\tdequeS.addLast(t[0] * v[0]);\n\t\tdequeW.addLast(v[0]);\n\t\tT p = new T(0, 0);\n\t\tpw.println(t[0]);\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tp.water += v[i];\n\t\t\tp.salt += t[i] * v[i];\n\t\t\tdequeW.addFirst(-p.water);\n\t\t\tdequeS.addFirst(-p.water * p.salt);\n\n\t\t\twhile (dequeS.size() >= 2) {\n\t\t\t\tdouble t2w = dequeW.pollLast();\n\t\t\t\tdouble t2s = dequeS.pollLast();\n\t\t\t\tdouble t1w = dequeW.pollLast();\n\t\t\t\tdouble t1s = dequeS.pollLast();\n\t\t\t\tif (t1w + p.water > L && t2w + p.water > L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (t1w + p.water == L) {\n\t\t\t\t\tdequeW.addLast(t1w);\n\t\t\t\t\tdequeS.addLast(t1s);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t1w + p.water < L && L < t2w + p.water) {\n\t\t\t\t\tdouble r1 = (t2w + p.water - L) / (t2w - t1w);\n\t\t\t\t\tdouble r2 = (L - (t1w + p.water)) / (t2w - t1w);\n\t\t\t\t\tdouble tLasts = r1 * (t1s + p.salt) + r2 * (t2s + p.salt);\n\t\t\t\t\tdouble tLastw = r1 * (t1w + p.water) + r2 * (t2w + p.water);\n\n\t\t\t\t\ttLastw -= p.water;\n\t\t\t\t\ttLasts -= p.salt;\n\t\t\t\t\tdequeS.addLast(t1s);\n\t\t\t\t\tdequeW.addLast(t1w);\n\n\t\t\t\t\tdequeS.addLast(tLasts);\n\t\t\t\t\tdequeW.addLast(tLastw);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdequeS.pollFirst();\n\t\t\tdequeW.pollFirst();\n\n\t\t\twhile (dequeS.size() >= 2) {\n\t\t\t\tdouble t1s = dequeS.pollFirst();\n\t\t\t\tdouble t1w = dequeW.pollFirst();\n\t\t\t\tdouble t2s = dequeS.pollFirst();\n\t\t\t\tdouble t2w = dequeW.pollFirst();\n\t\t\t\tif ((t1s + p.salt) / (t1w + p.water) > (t2s + p.salt) / (t2w + p.water)) {\n\t\t\t\t\tdequeS.addFirst(t2s);\n\t\t\t\t\tdequeW.addFirst(t2w);\n\t\t\t\t\tdequeS.addFirst(t1s);\n\t\t\t\t\tdequeW.addFirst(t1w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdequeS.addFirst(t2s);\n\t\t\t\tdequeW.addFirst(t2w);\n\t\t\t}\n\t\t\tdequeS.addFirst(-p.salt);\n\t\t\tdequeW.addFirst(-p.water);\n\n\t\t\tpw.println((dequeS.peekLast() + p.salt) / (dequeW.peekLast() + p.water));\n\t\t}\n\t\tpw.close();\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble totSalt = 0;\n\t\tdouble totV = 0;\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tArrayDeque<double[]> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t\tdouble nextSalt = t[i] * v[i];\n\t\t\tdouble nextV = v[i];\n\t\t\tlong sum = 0;\n\t\t\twhile (nextV > sum && i != 0) {\n\t\t\t\tdouble[] state = dq.pollLast();\n\t\t\t\tif (nextV - (sum + state[1]) >= 0) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tsum += state[1];\n\t\t\t\t} else {\n\t\t\t\t\tdouble r = (state[1] - (nextV - sum)) / state[1];\n\t\t\t\t\tsum += (1 - r) * state[1];\n\t\t\t\t\ttotSalt -= (1 - r) * state[0];\n\t\t\t\t\ttotV -= (1 - r) * state[1];\n\t\t\t\t\tstate[0] *= r;\n\t\t\t\t\tstate[1] *= r;\n\t\t\t\t\tdq.addLast(state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!dq.isEmpty()) {\n\t\t\t\tdouble[] state = dq.peekFirst();\n\t\t\t\tif (state[0] / state[1] >= nextSalt / nextV) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tnextSalt += state[0];\n\t\t\t\t\tnextV += state[1];\n\t\t\t\t\tdq.pollFirst();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdq.addFirst(new double[] { nextSalt, nextV });\n\t\t\ttotSalt += nextSalt;\n\t\t\ttotV += nextV;\n\t\t\tpw.println(String.format(\"%.20f\", totSalt / totV));\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tclass Scanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tlong nl = nextLong();\n\t\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\t\tthrow new NumberFormatException();\n\t\t\treturn (int) nl;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tlong L = sc.nextLong();\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t}\n\t\tclass T {\n\t\t\tdouble water;\n\t\t\tdouble salt;\n\n\t\t\tpublic T(double water, double salt) {\n\t\t\t\tthis.water = water;\n\t\t\t\tthis.salt = salt;\n\t\t\t}\n\t\t}\n\n\t\tdouble[] ans = new double[N];\n\t\tArrayDeque<T> deque = new ArrayDeque<>();\n\t\tdeque.addLast(new T(0, 0));\n\t\tdeque.addLast(new T(v[0], t[0] * v[0]));\n\t\tT p = new T(0, 0);\n\t\tans[0] = t[0];\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tp.water += v[i];\n\t\t\tp.salt += t[i] * v[i];\n\t\t\tdeque.addFirst(new T(-p.water, -p.water * p.salt));\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t2 = deque.pollLast();\n\t\t\t\tT t1 = deque.pollLast();\n\t\t\t\tif (t1.water + p.water > L && t2.water + p.water > L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (t1.water + p.water == L) {\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t1.water + p.water < L && L < t2.water + p.water) {\n\t\t\t\t\tdouble r1 = (t2.water + p.water - L) / (t2.water - t1.water);\n\t\t\t\t\tdouble r2 = (L - (t1.water + p.water)) / (t2.water - t1.water);\n\t\t\t\t\tT tLast = new T(r1 * (t1.water + p.water) + r2 * (t2.water + p.water),\n\t\t\t\t\t\t\tr1 * (t1.salt + p.salt) + r2 * (t2.salt + p.salt));\n\t\t\t\t\ttLast.water -= p.water;\n\t\t\t\t\ttLast.salt -= p.salt;\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tdeque.addLast(tLast);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeque.pollFirst();\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t1 = deque.pollFirst();\n\t\t\t\tT t2 = deque.pollFirst();\n\t\t\t\tif ((t1.salt + p.salt) / (t1.water + p.water) > (t2.salt + p.salt) / (t2.water + p.water)) {\n\t\t\t\t\tdeque.addFirst(t2);\n\t\t\t\t\tdeque.addFirst(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdeque.addFirst(t2);\n\t\t\t}\n\t\t\tdeque.addFirst(new T(-p.water, -p.salt));\n\t\t\tans[i] = (deque.peekFirst().salt + p.salt) / (deque.peekFirst().water + p.water);\n\t\t\tif (deque.size() < 2)\n\t\t\t\tthrow new AssertionError();\n\t\t\tans[i] = (deque.peekLast().salt + p.salt) / (deque.peekLast().water + p.water);\n\t\t}\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tpw.println(ans[i]);\n\t\t}\n\t\tpw.close();\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tlong L = sc.nextLong();\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t}\n\t\tclass T {\n\t\t\tdouble water;\n\t\t\tdouble salt;\n\n\t\t\tpublic T(double water, double salt) {\n\t\t\t\tthis.water = water;\n\t\t\t\tthis.salt = salt;\n\t\t\t}\n\t\t}\n\n\t\tdouble[] ans = new double[N];\n\t\tArrayDeque<T> deque = new ArrayDeque<>();\n\t\tdeque.addLast(new T(0, 0));\n\t\tdeque.addLast(new T(v[0], t[0] * v[0]));\n\t\tT p = new T(0, 0);\n\t\tans[0] = t[0];\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tp.water += v[i];\n\t\t\tp.salt += t[i] * v[i];\n\t\t\tdeque.addFirst(new T(-p.water, -p.water * p.salt));\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t2 = deque.pollLast();\n\t\t\t\tT t1 = deque.pollLast();\n\t\t\t\tif (t1.water + p.water > L && t2.water + p.water > L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (t1.water + p.water == L) {\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t1.water + p.water < L && L < t2.water + p.water) {\n\t\t\t\t\tdouble r1 = (t2.water + p.water - L) / (t2.water - t1.water);\n\t\t\t\t\tdouble r2 = (L - (t1.water + p.water)) / (t2.water - t1.water);\n\t\t\t\t\tT tLast = new T(r1 * (t1.water + p.water) + r2 * (t2.water + p.water),\n\t\t\t\t\t\t\tr1 * (t1.salt + p.salt) + r2 * (t2.salt + p.salt));\n\t\t\t\t\ttLast.water -= p.water;\n\t\t\t\t\ttLast.salt -= p.salt;\n\t\t\t\t\tdeque.addLast(t1);\n\t\t\t\t\tdeque.addLast(tLast);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeque.pollFirst();\n\t\t\twhile (deque.size() >= 2) {\n\t\t\t\tT t1 = deque.pollFirst();\n\t\t\t\tT t2 = deque.pollFirst();\n\t\t\t\tif ((t1.salt + p.salt) / (t1.water + p.water) > (t2.salt + p.salt) / (t2.water + p.water)) {\n\t\t\t\t\tdeque.addFirst(t2);\n\t\t\t\t\tdeque.addFirst(t1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdeque.addFirst(t2);\n\t\t\t}\n\t\t\tdeque.addFirst(new T(-p.water, -p.salt));\n\t\t\tans[i] = (deque.peekFirst().salt + p.salt) / (deque.peekFirst().water + p.water);\n\t\t\tif (deque.size() < 2)\n\t\t\t\tthrow new AssertionError();\n\t\t\tans[i] = (deque.peekLast().salt + p.salt) / (deque.peekLast().water + p.water);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tSystem.out.println(ans[i]);\n\t\t}\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tlong L = sc.nextLong();\n\t\tclass T {\n\t\t\tdouble water;\n\t\t\tdouble salt;\n\n\t\t\tpublic T(double water, double salt) {\n\t\t\t\tthis.water = water;\n\t\t\t\tthis.salt = salt;\n\t\t\t}\n\t\t}\n\n\t\tArrayDeque<Double> dequeW = new ArrayDeque<>();\n\t\tArrayDeque<Double> dequeS = new ArrayDeque<>();\n\t\tdequeS.add(0d);\n\t\tdequeW.add(0d);\n\t\tdouble t0 = sc.nextDouble();\n\t\tdouble v0 = sc.nextDouble();\n\t\tdequeS.addLast(t0 * v0);\n\t\tdequeW.addLast(v0);\n\t\tT p = new T(0, 0);\n\t\tpw.println(t0);\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tdouble ti = sc.nextDouble();\n\t\t\tdouble vi = sc.nextDouble();\n\n\t\t\tp.water += vi;\n\t\t\tp.salt += ti * vi;\n\t\t\tdequeW.addFirst(-p.water);\n\t\t\tdequeS.addFirst(-p.water * p.salt);\n\n\t\t\twhile (dequeS.size() >= 2) {\n\t\t\t\tdouble t2w = dequeW.pollLast();\n\t\t\t\tdouble t2s = dequeS.pollLast();\n\t\t\t\tdouble t1w = dequeW.pollLast();\n\t\t\t\tdouble t1s = dequeS.pollLast();\n\t\t\t\tif (t1w + p.water > L && t2w + p.water > L)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (t1w + p.water == L) {\n\t\t\t\t\tdequeW.addLast(t1w);\n\t\t\t\t\tdequeS.addLast(t1s);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (t1w + p.water < L && L < t2w + p.water) {\n\t\t\t\t\tdouble r1 = (t2w + p.water - L) / (t2w - t1w);\n\t\t\t\t\tdouble r2 = (L - (t1w + p.water)) / (t2w - t1w);\n\t\t\t\t\tdouble tLasts = r1 * (t1s + p.salt) + r2 * (t2s + p.salt);\n\t\t\t\t\tdouble tLastw = r1 * (t1w + p.water) + r2 * (t2w + p.water);\n\n\t\t\t\t\ttLastw -= p.water;\n\t\t\t\t\ttLasts -= p.salt;\n\t\t\t\t\tdequeS.addLast(t1s);\n\t\t\t\t\tdequeW.addLast(t1w);\n\n\t\t\t\t\tdequeS.addLast(tLasts);\n\t\t\t\t\tdequeW.addLast(tLastw);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdequeS.pollFirst();\n\t\t\tdequeW.pollFirst();\n\n\t\t\twhile (dequeS.size() >= 2) {\n\t\t\t\tdouble t1s = dequeS.pollFirst();\n\t\t\t\tdouble t1w = dequeW.pollFirst();\n\t\t\t\tdouble t2s = dequeS.pollFirst();\n\t\t\t\tdouble t2w = dequeW.pollFirst();\n\t\t\t\tif ((t1s + p.salt) / (t1w + p.water) > (t2s + p.salt) / (t2w + p.water)) {\n\t\t\t\t\tdequeS.addFirst(t2s);\n\t\t\t\t\tdequeW.addFirst(t2w);\n\t\t\t\t\tdequeS.addFirst(t1s);\n\t\t\t\t\tdequeW.addFirst(t1w);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tdequeS.addFirst(t2s);\n\t\t\t\tdequeW.addFirst(t2w);\n\t\t\t}\n\t\t\tdequeS.addFirst(-p.salt);\n\t\t\tdequeW.addFirst(-p.water);\n\n\t\t\tpw.println((dequeS.peekLast() + p.salt) / (dequeW.peekLast() + p.water));\n\t\t}\n\t\tpw.close();\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.nextInt();\n\t\tint L = sc.nextInt();\n\t\tdouble totSalt = 0;\n\t\tdouble totV = 0;\n\t\tdouble[] t = new double[N];\n\t\tdouble[] v = new double[N];\n\t\tArrayDeque<double[]> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tt[i] = sc.nextDouble();\n\t\t\tv[i] = sc.nextDouble();\n\t\t\tdouble nextSalt = t[i] * v[i];\n\t\t\tdouble nextV = v[i];\n\t\t\tlong sum = 0;\n\t\t\twhile (nextV > sum && i != 0) {\n\t\t\t\tdouble[] state = dq.pollLast();\n\t\t\t\tif (nextV - (sum + state[1]) >= 0) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tsum += state[1];\n\t\t\t\t} else {\n\t\t\t\t\tdouble r = (state[1] - (nextV - sum)) / state[1];\n\t\t\t\t\tsum += (1 - r) * state[1];\n\t\t\t\t\ttotSalt -= (1 - r) * state[0];\n\t\t\t\t\ttotV -= (1 - r) * state[1];\n\t\t\t\t\tstate[0] *= r;\n\t\t\t\t\tstate[1] *= r;\n\t\t\t\t\tdq.addLast(state);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!dq.isEmpty()) {\n\t\t\t\tdouble[] state = dq.peekFirst();\n\t\t\t\tif (state[0] / state[1] >= nextSalt / nextV) {\n\t\t\t\t\ttotSalt -= state[0];\n\t\t\t\t\ttotV -= state[1];\n\t\t\t\t\tnextSalt += state[0];\n\t\t\t\t\tnextV += state[1];\n\t\t\t\t\tdq.pollFirst();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdq.addFirst(new double[] { nextSalt, nextV });\n\t\t\ttotSalt += nextSalt;\n\t\t\ttotV += nextV;\n\t\t\tpw.println(String.format(\"%.20f\", totSalt / totV));\n\t\t}\n\t\tpw.close();\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static String dtos(double x, int n) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(x < 0){\n\t\t\tsb.append('-');\n\t\t\tx = -x;\n\t\t}\n\t\tx += Math.pow(10, -n)/2;\n//\t\tif(x < 0){ x = 0; }\n\t\tsb.append((long)x);\n\t\tsb.append(\".\");\n\t\tx -= (long)x;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tx *= 10;\n\t\t\tsb.append((int)x);\n\t\t\tx -= (int)x;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tint tail = 0, head = 0;\n\t\t\n\t\tdouble[] qtv = new double[n];\n\t\tdouble[] qv = new double[n];\n\t\t\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && tail < head){\n\t\t\t\tint ind = tail++;\n\t\t\t\tif(V - qv[ind] <= L){\n\t\t\t\t\tS -= qtv[ind] * (double)(V - L);\n\t\t\t\t\tqv[ind] = L - (V-qv[ind]);\n\t\t\t\t\t--tail;\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= qv[ind];\n\t\t\t\t\tS -= (double)qtv[ind] * qv[ind];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(dtos(S/L, 10));\n//\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t\t\n\t\t\tqtv[head] = ts[i];\n\t\t\tqv[head] = vs[i];\n\t\t\thead++;\n\t\t\twhile(head - tail >= 2){\n\t\t\t\tint l1 = head-1, l2 = head-2;\n\t\t\t\tif(qtv[l2] < qtv[l1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tqtv[l2] = (qtv[l1]*qv[l1]+qtv[l2]*qv[l2])/(qv[l1]+qv[l2]);\n\t\t\t\t\tqv[l2] += qv[l1];\n\t\t\t\t\thead--;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tint tail = 0, head = 0;\n\t\t\n\t\tdouble[][] q = new double[n][];\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && tail < head){\n\t\t\t\tdouble[] cur = q[tail++];\n\t\t\t\tif(V - cur[1] <= L){\n\t\t\t\t\tS -= cur[0] * (double)(V - L);\n\t\t\t\t\tcur[1] = L - (V-cur[1]);\n\t\t\t\t\tq[--tail] = cur;\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= cur[1];\n\t\t\t\t\tS -= (double)cur[0] * cur[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t\t\n\t\t\tq[head++] = new double[]{ts[i], vs[i]};\n\t\t\touter:\n\t\t\twhile(head - tail >= 2){\n\t\t\t\tdouble[] last = q[head-1];\n\t\t\t\tdouble[] last2 = q[head-2];\n\t\t\t\tif(last2[0] < last[0]){\n\t\t\t\t\tbreak outer;\n\t\t\t\t}else{\n\t\t\t\t\tlast2[0] = (last[0]*last[1]+last2[0]*last2[1]) / (last[1]+last2[1]);\n\t\t\t\t\tlast2[1] += last[1];\n\t\t\t\t\thead--;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tpublic static String dtos(double x) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tif(x < 0){\n\t\t\tsb.append('-');\n\t\t\tx = -x;\n\t\t}\n\t\tx += 5e-11;\n//\t\tif(x < 0){ x = 0; }\n\t\tsb.append((long)x);\n\t\tsb.append(\".\");\n\t\tx -= (long)x;\n\t\tfor(int i = 0;i < 10;i++){\n\t\t\tx *= 10;\n\t\t\tsb.append((int)x);\n\t\t\tx -= (int)x;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tint tail = 0, head = 0;\n\t\t\n\t\tdouble[] qtv = new double[n];\n\t\tdouble[] qv = new double[n];\n\t\t\n\t\tdouble V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && tail < head){\n\t\t\t\tint ind = tail++;\n\t\t\t\tif(V - qv[ind] <= L){\n\t\t\t\t\tS -= qtv[ind] * (double)(V - L);\n\t\t\t\t\tqv[ind] = L - (V-qv[ind]);\n\t\t\t\t\t--tail;\n\t\t\t\t\tV = L;\n\t\t\t\t}else{\n\t\t\t\t\tV -= qv[ind];\n\t\t\t\t\tS -= (double)qtv[ind] * qv[ind];\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(dtos(S/L));\n//\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t\t\n\t\t\tqtv[head] = ts[i];\n\t\t\tqv[head] = vs[i];\n\t\t\thead++;\n\t\t\twhile(head - tail >= 2){\n\t\t\t\tint l1 = head-1, l2 = head-2;\n\t\t\t\tif(qtv[l2] < qtv[l1]){\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tqtv[l2] = (qtv[l1]*qv[l1]+qtv[l2]*qv[l2])/(qv[l1]+qv[l2]);\n\t\t\t\t\tqv[l2] += qv[l1];\n\t\t\t\t\thead--;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t}\n\t}\n\t\n\t\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\tint l = io.nextInt();\n\t\t\tSplayTreeIndex tree = new SplayTreeIndex();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint t = io.nextInt();\n\t\t\t\tint v = io.nextInt();\n\t\t\t\ttree.insert(t, v);\n\t\t\t\tint less = (int)tree.root.tv - l;\n\t\t\t\twhile (less > 0) {\n\t\t\t\t\tSplayTreeIndex.Node[] nodes = tree.separate(1, tree.getCount(tree.root) - 1);\n\t\t\t\t\tif (nodes[0].tv < less) {\n\t\t\t\t\t\tnodes[0].tv -= less;\n\t\t\t\t\t\ttree.root = tree.merge(nodes[0], nodes[1]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tless -= nodes[0].tv;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tio.out.printf(\"%.10f\\n\", tree.root.tv);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class SplayTreeIndex {\n\t\tNode root;\n\n\t\tstatic int getCount(Node n) { return n == null ? 0 : n.count; }\n\t\tstatic Node getLeft(Node n) { return n == null ? null : n.getLeft(); }\n\t\tstatic Node getRight(Node n) { return n == null ? null : n.getRight(); }\n\n\t\t// insert index value\n\t\tvoid insert(int t, int v) {\n\t\t\tinsert(new Node(t, v, null));\n\t\t}\n\t\tvoid insert(Node insertNode) {\n\t\t\tif(root == null) { root = insertNode; return; }\n\t\t\tNode node = root;\n\t\t\twhile(node != null) {\n\t\t\t\tnode.pushDown();\n\t\t\t\tif(node.t > insertNode.t) {\n\t\t\t\t\tif (node.left == null) { Node.linkLeft(insertNode, node); break; }\n\t\t\t\t\tnode = node.left;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (node.right == null) { Node.linkRight(insertNode, node); break; }\n\t\t\t\t\tnode = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\troot = insertNode.splay();\n\t\t}\n\n\t\t// index subtree node\n\t\tNode find(Node node, int index) {\n\t\t\twhile(node != null) {\n\t\t\t\tnode.pushDown();\n\t\t\t\tif(getCount(node.getLeft()) > index) { node = node.getLeft(); }\n\t\t\t\telse if(getCount(node.getLeft()) == index) { return root = node.splay(); }\n\t\t\t\telse { index -= getCount(node.getLeft()) + 1; node = node.getRight(); }\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\tNode find(int index) {\n\t\t\treturn find(root, index);\n\t\t}\n\n\t\t// remove index\n\t\tvoid remove(final int index) {\n\t\t\tif(index < 0 || getCount(root) <= index) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\n\t\t\tfinal Node node = find(index);\n\t\t\tfinal Node nl = Node.cut(node.getLeft());\n\t\t\tfinal Node nr = Node.cut(node.getRight());\n\n\t\t\troot = Node.merge(nl, nr);\n\t\t}\n\n\t\tfinal Node[] sep = new Node[3];\n\n\t\t// separate [0,l),[l,r],(r,..)\n\t\tNode[] separate(int l, int r) {\n\t\t\tfinal Node left = Node.cut(getLeft(find(l)));\n\t\t\tfinal Node mid = find(r - l);\n\t\t\tfinal Node right = Node.cut(getRight(mid));\n\n\t\t\tsep[0] = left;\n\t\t\tsep[1] = mid;\n\t\t\tsep[2] = right;\n\n\t\t\treturn sep;\n\t\t}\n\t\t\n\t\t// cut from SplayTree [0, i)\n\t\tNode cut(int i) {\n\t\t\treturn Node.cut(getLeft(find(i)));\n\t\t}\n\t\t\n\t\t// [l, r] -> [i, i + r - l]\n\t\t// [l1, r1] <-> [l2, r2], r1 < l2\n\t\tvoid swap(int l1, int r1, int l2, int r2) {\n\t\t\tNode left2 = Node.cut(getLeft(find(l2)));\n\t\t\tfinal Node mid2 = find(r2 - l2);\n\t\t\tNode right2 = Node.cut(getRight(mid2));\n\n\t\t\troot = left2;\n\t\t\tNode left1 = Node.cut(getLeft(find(l1)));\n\t\t\tfinal Node mid1 = find(r1 - l1);\n\t\t\tNode right1 = Node.cut(getRight(mid1));\n\n\t\t\troot = merge(left1, mid2, right1, mid1, right2);\n\t\t}\n\t\t\n\t\tNode merge(Node... nodes) {\n\t\t\tNode res = null;\n\t\t\tfor(Node n : nodes) res = Node.merge(res, n);\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\t// sum [l,r]\n\t\tdouble temp() {\n\t\t\treturn root.tt;\n\t\t}\n\n\t\tstatic class Node {\n\t\t\tint t, v, count;\n\t\t\tdouble tt, tv;\n\t\t\tNode left, right, parent;\n\n\t\t\tvoid update() {\n\t\t\t\tcount = 1;\n\t\t\t\ttt = t;\n\t\t\t\ttv = v;\n\t\t\t\tif(getLeft() != null) {\n\t\t\t\t\tcount += left.count;\n\t\t\t\t\ttt = (tt * left.tv + left.tt * tv) / (tv + left.tv);\n\t\t\t\t\ttv += left.tv;\n\t\t\t\t}\n\t\t\t\tif(getRight() != null) {\n\t\t\t\t\tcount += right.count;\n\t\t\t\t\ttt = (tt * right.tv + right.tt * tv) / (tv + right.tv);\n\t\t\t\t\ttv += right.tv;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// eval lazy value\n\t\t\tNode pushDown() {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tNode getLeft() { pushDown(); return left; }\n\t\t\tNode getRight() { pushDown(); return right; }\n\n\t\t\t// merge two node. left, right\n\t\t\tstatic Node merge(final Node nl, final Node nr) {\n\t\t\t\tif(nl == null) return nr;\n\t\t\t\tif(nr == null) return nl;\n\t\t\t\tnl.splay();\n\t\t\t\tnr.splay();\n\t\t\t\tfinal Node leftMaxNode = nl.maxNode();\n\t\t\t\tNode.linkRight(nr, leftMaxNode);\n\t\t\t\treturn leftMaxNode;\n\t\t\t}\n\n\t\t\t// p is parent of n. n is left child of p.\n\t\t\tstatic void linkLeft(final Node n, final Node p) {\n\t\t\t\tif(p != null) { p.pushDown(); cut(p.getLeft()); p.left = n; }\n\t\t\t\tif(n != null) { n.parent = p; }\n\t\t\t\tif(p != null) { p.update(); }\n\t\t\t}\n\n\t\t\t// p is parent of n. n is right child of p.\n\t\t\tstatic void linkRight(final Node n, final Node p) {\n\t\t\t\tif(p != null) { p.pushDown(); cut(p.getRight()); p.right = n; }\n\t\t\t\tif(n != null) { n.parent = p; }\n\t\t\t\tif(p != null) { p.update(); }\n\t\t\t}\n\n\t\t\t// cut n and parent of n.\n\t\t\tstatic Node cut(final Node n) {\n\t\t\t\tif(n == null || n.parent == null) { return n; }\n\t\t\t\tn.parent.pushDown();\n\t\t\t\tif(n.parent.left == n) {\n\t\t\t\t\tn.parent.left = null;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tn.parent.right = null;\n\t\t\t\t}\n\t\t\t\tn.parent.update();\n\t\t\t\tn.parent = null;\n\t\t\t\treturn n;\n\t\t\t}\n\n\t\t\tpublic Node(int t, int v, Node parent) {\n\t\t\t\tthis.t = t;\n\t\t\t\tthis.v = v;\n\t\t\t\tthis.parent = parent;\n\t\t\t\tupdate();\n\t\t\t}\n\n\t\t\tvoid rotateRight() {\n\t\t\t\tfinal Node x = this;\n\t\t\t\tfinal Node p = x.parent;\n\t\t\t\tfinal Node g = p.parent;\n//\t\t\t\tif(g != null) g.pushDown();\n\t\t\t\tp.pushDown();\n\t\t\t\tx.pushDown();\n\t\t\t\tp.left = x.right;\n\t\t\t\tif(x.right != null) { x.right.parent = p; }\n\t\t\t\tp.parent = x;\n\t\t\t\tx.right = p;\n\t\t\t\tx.parent = g;\n\t\t\t\tp.update();\n\t\t\t\tx.update();\n\t\t\t\tif(g != null) {\n\t\t\t\t\tif(g.left == p) g.left = x;\n\t\t\t\t\telse if(g.right == p) g.right = x;\n//\t\t\t\t\tg.update();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvoid rotateLeft() {\n\t\t\t\tfinal Node x = this;\n\t\t\t\tfinal Node p = x.parent;\n\t\t\t\tfinal Node g = p.parent;\n//\t\t\t\tif(g != null) g.pushDown();\n\t\t\t\tp.pushDown();\n\t\t\t\tx.pushDown();\n\t\t\t\tp.right = x.left;\n\t\t\t\tif(x.left != null) { x.left.parent = p; }\n\t\t\t\tp.parent = x;\n\t\t\t\tx.left = p;\n\t\t\t\tx.parent = g;\n\t\t\t\tp.update();\n\t\t\t\tx.update();\n\t\t\t\tif(g != null) {\n\t\t\t\t\tif(g.left == p) g.left = x;\n\t\t\t\t\telse if(g.right == p) g.right = x;\n//\t\t\t\t\tg.update();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpublic Node splay() {\n\t\t\t\tfinal Node x = this;\n\t\t\t\twhile(x.parent != null) {\n\t\t\t\t\tfinal Node p = x.parent;\n\t\t\t\t\tif(p.parent == null) {\n\t\t\t\t\t\t// zig step\n\t\t\t\t\t\tif(p.getLeft() == x) { x.rotateRight(); }\n\t\t\t\t\t\telse { x.rotateLeft(); }\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tfinal Node g = p.parent;\n\t\t\t\t\t\t// zig-zig step / zig-zag step\n\t\t\t\t\t\tif(g.getLeft() == p) {\n\t\t\t\t\t\t\tif(p.getLeft() == x) { p.rotateRight(); x.rotateRight(); }\n\t\t\t\t\t\t\telse { x.rotateLeft(); x.rotateRight(); }\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(p.getLeft() == x) { x.rotateRight(); x.rotateLeft(); }\n\t\t\t\t\t\t\telse { p.rotateLeft(); x.rotateLeft(); }\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn x;\n\t\t\t}\n\n\t\t\tNode maxNode() {\n\t\t\t\tNode n = this;\n\t\t\t\twhile(true) {\n\t\t\t\t\tn.pushDown();\n\t\t\t\t\tif(n.right == null) break;\n\t\t\t\t\tn = n.right;\n\t\t\t\t}\n\t\t\t\treturn n.splay();\n\t\t\t}\n\n\t\t\tNode minNode() {\n\t\t\t\tNode n = this;\n\t\t\t\twhile(true) {\n\t\t\t\t\tn.pushDown();\n\t\t\t\t\tif(n.left == null) break;\n\t\t\t\t\tn = n.left;\n\t\t\t\t}\n\t\t\t\treturn n.splay();\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), L = ni();\n\t\tint[] ts = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tts[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tDeque<double[]> q = new ArrayDeque<>();\n\t\tlong V = 0;\n\t\tdouble S = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tV += vs[i];\n\t\t\tS += (double)ts[i] * vs[i];\n\t\t\twhile(V > L && q.size() > 0){\n\t\t\t\tdouble[] cur = q.pollFirst();\n\t\t\t\tif(V - cur[1] <= L){\n\t\t\t\t\tS -= cur[0] * (double)(V - L);\n\t\t\t\t\tcur[1] = L - (V-cur[1]);\n\t\t\t\t\tq.addFirst(cur);\n\t\t\t\t\tV = L;\n\t\t\t\t\tbreak;\n\t\t\t\t}else{\n\t\t\t\t\tV -= cur[1];\n\t\t\t\t\tS -= (double)cur[0] * cur[1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(q.size() > 0 && ts[i] < q.peekLast()[0]){\n\t\t\t\t// fullmix\n\t\t\t\tq.clear();\n\t\t\t\tq.addLast(new double[]{S / V, V});\n\t\t\t}else{\n\t\t\t\tq.addLast(new double[]{ts[i], vs[i]});\n\t\t\t}\n//\t\t\tassert Math.abs(V-L) < 1e-9;\n\t\t\tout.printf(\"%.14f\\n\", S/L);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "C#",
    "code": "#include<bits/stdc++.h>\n#define L long long\n#define vi vector<int>\n#define pb push_back\n#define pi pair<int,int>\n#define pii pair<pi,int>\n#define aa first\n#define bb second\n#define xx aa.aa\n#define yy aa.bb\n#define zz bb\n#define mp make_pair\n#define mpp(a,b,c) mp(mp(a,b),c)\nusing namespace std;\nint n,m;\ndouble x[500010],p;\nint y[500010];\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j,k,l,r,w;\n\tscanf(\"%d%d\",&n,&m);\n\tl=1;\n\tr=0;\n\tfor(i=1;i<=n;i++)\n\t  {\n\t   scanf(\"%d%d\",&j,&k);\n\t   if(i>1)\n\t     {\n\t\t  w=k;\n\t\t  while(w)\n\t\t    if(y[l]<=w)\n\t\t      {\n\t\t\t   w-=y[l];\n\t\t\t   p-=x[l]*y[l];\n\t\t\t   l++;\n\t\t\t  }\n\t\t\telse\n\t\t\t  {\n\t\t\t   y[l]-=w;\n\t\t\t   p-=x[l]*w;\n\t\t\t   w=0;\n\t\t\t  }\n\t\t }\n\t   x[++r]=j;\n\t   y[r]=k;\n\t   p+=(L)j*k;\n\t   while(r>l && x[r]<x[r-1])\n\t     {\n\t\t  x[r-1]=(x[r]*y[r]+x[r-1]*y[r-1])/(y[r]+y[r-1]);\n\t\t  y[r-1]+=y[r];\n\t\t  r--;\n\t\t }\n\t   printf(\"%.10lf\\n\",p/m);\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\n//using System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var L = rl;\n            var deq = new Deque<X>();\n            double sum = 0;\n            for (int _ = 0; _ < n; _++)\n            {\n                var x = new X(ri, ri);\n                sum += x.temp * x.vol;\n                if (deq.Count == 0) { deq.PushBack(x); }\n                else\n                {\n                    //水を捨てておく\n                    {\n                        var v = x.vol;\n                        while (v > 0)\n                        {\n                            var p = deq.PopFront(); sum -= p.temp * p.vol;\n                            var mi = Math.Min(v, p.vol);\n                            p.vol -= mi; v -= mi;\n                            if (p.vol > 0)\n                            {\n                                deq.PushFront(p); sum += p.temp * p.vol;\n                            }\n                        }\n                    }\n                    while (deq.Count > 0 && deq[deq.Count - 1].temp >= x.temp)\n                    {\n                        var p = deq.PopBack();\n                        var nv = x.vol + p.vol;\n                        x = new X((x.temp * x.vol + p.temp * p.vol) / nv, nv);\n                    }\n                    deq.PushBack(x);\n\n                }\n                Console.WriteLine(\"{0:0.000000000000}\", 1.0 * sum / L);\n            }\n        }\n\n        class X {\n            public double temp, vol;\n            public X(double T, double V) {\n                this.temp = T; vol = V;\n            }\n        }\n        const long INF = 5L << 60;\n        static int[] dx = { -1, 0, 1, 0 };\n        static int[] dy = { 0, 1, 0, -1 };\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n\n#region Deque<T>\n\npublic class Deque<T> {\n    T[] buf;\n    int offset, cnt;\n    public int Count { get { return cnt; } }\n    public Deque(int capacity) { buf = new T[capacity]; }\n    public Deque() : this(8) { }\n    public T this[int index] {\n        get { return buf[getIndex(index)]; }\n        set { buf[getIndex(index)] = value; }\n    }\n    int getIndex(int index) {\n        if (index >= cnt) throw new ArgumentOutOfRangeException(\"out of range\");\n        var ret = index + offset;\n        if (ret >= buf.Length)\n            ret -= buf.Length;\n        return ret;\n    }\n    public void PushFront(T item) {\n        if (cnt == buf.Length) extend();\n        if (--offset < 0) offset += buf.Length;\n        buf[offset] = item;\n        ++cnt;\n    }\n    public T PopFront() {\n        if (cnt == 0) throw new ArgumentOutOfRangeException(\"collection is empty\");\n        --cnt;\n        var ret = buf[offset++];\n        if (offset >= buf.Length) offset -= buf.Length;\n        return ret;\n    }\n    public void PushBack(T item) {\n        if (cnt == buf.Length) extend();\n        var id = cnt++ + offset;\n        if (id >= buf.Length) id -= buf.Length;\n        buf[id] = item;\n    }\n    public T PopBack() {\n        if (cnt == 0)\n            throw new ArgumentOutOfRangeException(\"collection is empty\");\n        var ret = buf[getIndex(cnt - 1)]; cnt--;\n        return ret;\n    }\n    public void Insert(T item, int index) {\n        if (index > cnt) throw new ArgumentOutOfRangeException();\n        PushFront(item);\n        for (int i = 0; i < index; i++)\n            this[i] = this[i + 1];\n        this[index] = item;\n    }\n    public T RemoveAt(int index) {\n        if (index < 0 || index >= cnt) throw new ArgumentOutOfRangeException();\n        var ret = this[index];\n        for (int i = index; i > 0; i--)\n            this[i] = this[i - 1];\n        PopFront();\n        return ret;\n    }\n    public bool Any() { return cnt > 0; }\n    void extend() {\n        T[] next = new T[buf.Length * 2];\n        if (offset > buf.Length - cnt)\n        {\n            var len = buf.Length - offset;\n            Array.Copy(buf, offset, next, 0, len);\n            Array.Copy(buf, 0, next, len, cnt - len);\n        }\n        else Array.Copy(buf, offset, next, 0, cnt);\n        buf = next;\n        offset = 0;\n    }\n    public T[] Items {\n        get {\n            var a = new T[cnt];\n            for (int i = 0; i < cnt; i++)\n                a[i] = this[i];\n            return a;\n        }\n    }\n}\n\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int N = int.Parse(str[0]);\n        long L = int.Parse(str[1]);\n        str = Console.ReadLine().Split(' ');\n        DPfunction D = new DPfunction(L,N,int.Parse(str[0]));\n        for(int i=1;i<N;i++){\n            sb.Append(D.Get()/L+\"\\n\");\n            str = Console.ReadLine().Split(' ');\n            D.Set(int.Parse(str[0]),int.Parse(str[1]));\n        }\n        sb.Append(D.Get()/L+\"\\n\");\n    }\n    class DPfunction{\n        double L;\n        double TS;\n        double VS;\n        int p,q;\n        double[] T;\n        double[] V;\n        public DPfunction(long L0,int N,long t){\n            L = L0;\n            TS = 0;\n            VS = 0;\n            T = new double[N+1];\n            V = new double[N+1];\n            p = N-1;\n            q = N;\n            T[N] = t*L;\n            V[N] = L;\n        }\n        public double Get(){\n            return T[q]+TS;\n        }\n        public void Set(long t,long v){\n            while(V[q-1] + VS + v > L){\n                q--;\n            }\n            T[q] = ((V[q] - L + VS + v)*T[q-1] + (L - VS - v - V[q-1])*T[q])/(V[q] - V[q-1]);\n            V[q] = L - VS - v;\n            TS += t*v;\n            VS += v;\n            p--;\n            while(p+1 < q){\n                if(((V[p+2] - V[p+1])*(-TS) + (V[p+1] + VS)*(T[p+2]))/(V[p+2] + VS) > T[p+1]){\n                    p++;\n                }\n                else{\n                    break;\n                }\n            }\n            T[p] = -TS;\n            V[p] = -VS;\n        }\n    }\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\nimport std.container.util;\n// import dkh.container.deque;\n\nimport std.typecons;\n\nvoid main() {\n    auto sc = new Scanner(stdin);\n    int n; long L;\n    sc.read(n, L);\n    alias D = Tuple!(long, double);\n    Deque!D que = make!(Deque!D);\n    D off;\n    D norm(D d) {\n        return D(d[0] + off[0], d[1] + off[1]);\n    }\n    D rnorm(D d) {\n        return D(d[0] - off[0], d[1] - off[1]);\n    }\n    foreach (i; 0..n) {\n        double t; long v;\n        sc.read(t, v); t *= v;\n        if (i == n-1) sc.read!true;\n        if (v == L) {\n            que.clear();\n            off = D(0, 0);\n            que.insertBack(D(0, 0));\n            que.insertBack(D(v, t));\n        } else {\n            off[0] += v; off[1] += t;\n            while (L <= norm(que[$-2])[0]) que.removeBack;\n            auto l = norm(que[$-2]), r = norm(que[$-1]);\n            double z = l[1] + (r[1] - l[1]) * (L - l[0]) / (r[0] - l[0]);\n            que.removeBack;\n            que.insertBack(rnorm(D(L, z)));\n            while (que.length >= 2) {\n                auto a = norm(que[0]), b = norm(que[1]);\n                if (a[1] * b[0] > b[1] * a[0]) {\n                    break;\n                }\n                que.removeFront;\n            }\n            que.insertFront(rnorm(D(0, 0)));\n        }\n        auto res = norm(que.back);\n        writefln(\"%.12f\", res[1]/res[0]);\n//        writeln(que[].map!norm);\n    }\n    return;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/deque.d */\n// module dkh.container.deque;\n\nstruct DequePayload(T) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint start, len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        if (start + i < cap) return _data[start + i];\n        else return _data[start + i - cap];\n    }\n    ref inout(T) front() inout { return this[0]; }\n    ref inout(T) back() inout { return this[$-1]; }\n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import std.algorithm : max;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        T* newData = cast(T*)GC.malloc(newCap * T.sizeof);\n        foreach (i; 0..length) {\n            newData[i] = this[i];\n        }\n        _data = newData; start = 0; cap = newCap.to!uint;\n    }\n    void clear() {\n        start = len = 0;\n    }\n    import std.algorithm : max;\n    void insertFront(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        if (start == 0) start += cap;\n        start--; len++;\n        this[0] = item;\n    }\n    void insertBack(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        len++;\n        this[len-1] = item;\n    }\n    void removeFront() {\n        assert(!empty, \"Deque.removeFront: Deque is empty\");\n        start++; len--;\n        if (start == cap) start = 0;\n    }\n    void removeBack() {\n        assert(!empty, \"Deque.removeBack: Deque is empty\");        \n        len--;\n    }\n}\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    alias Payload = DequePayload!T;\n    Payload* _p;\n    \n    static if (!mayNull) @disable this();\n\n     \n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        _p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        _p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    private this(Payload* p) { _p = p; }\n    static Deque make() { return Deque(new Payload()); }\n    \n    private bool havePayload() const { return (!mayNull || _p); }    \n    @property bool empty() const { return (!havePayload || _p.empty); }  \n    @property size_t length() const { return (havePayload ? _p.length : 0); }  \n    alias opDollar = length;  \n\n    ref inout(T) opIndex(size_t i) inout {\n        assert(!empty, \"Deque.opIndex: Deque is empty\");\n        return (*_p)[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void clear() { if (_p) _p.clear(); }  \n\n     \n    void insertFront(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertFront(item);\n    }\n    void insertBack(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertBack(item);\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    alias stableInsertBack = insertBack;  \n\n     \n    void removeFront() {\n        assert(!mayNull || _p, \"Deque.removeFront: Deque is empty\");\n        _p.removeFront();\n    }\n    void removeBack() {\n        assert(!mayNull || _p, \"Deque.removeBack: Deque is empty\");\n        _p.removeBack();\n    }  \n    alias stableRemoveBack = removeBack;  \n\n     \n    alias Range = RangeT!(DequePayload!T);\n    alias ConstRange = RangeT!(const DequePayload!T);  \n    alias ImmutableRange = RangeT!(immutable DequePayload!T);  \n\n    size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n        assert(start <= end && end <= length);\n        return [start, end];\n    }  \n    Range opIndex(size_t[2] rng) { return Range(_p, rng[0], rng[1]); }  \n    ConstRange opIndex(size_t[2] rng) const { return ConstRange(_p, rng[0], rng[1]); }  \n    ImmutableRange opIndex(size_t[2] rng) immutable { return ImmutableRange(_p, rng[0], rng[1]); }  \n    auto opIndex() inout { return this[0..$]; }  \n\n    static struct RangeT(QualifiedPayload) {\n        alias A = QualifiedPayload;\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t l, r;\n\n        @property bool empty() const { return r <= l; }\n        @property size_t length() const { return r - l; }\n        alias opDollar = length;\n\n        @property auto save() { return this; }\n        \n        ref inout(E) opIndex(size_t i) inout {\n            version(assert) if (empty) throw new RangeError();\n            return (*p)[l+i];\n        }\n        @property ref inout(E) front() inout { return this[0]; }\n        @property ref inout(E) back() inout { return this[$-1]; }\n\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            l++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            r--;\n        }\n        \n        size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n            assert(start <= end && end <= length);\n            return [start, end];\n        }\n        auto opIndex(size_t[2] rng) { return RangeT(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) const { return RangeT!(const A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) immutable { return RangeT!(immutable A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex() inout { return this[0..$]; }\n    } \n}\n\n \n \n\n \n\n \n\n \n\n \n\n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\nimport std.container.util;\n// import dkh.container.deque;\n\nimport std.typecons;\n\nvoid main() {\n    auto sc = new Scanner(stdin);\n    int n; long L;\n    sc.read(n, L);\n    alias D = Tuple!(long, double);\n    Deque!D que = make!(Deque!D);\n    D off;\n    D norm(D d) {\n        return D(d[0] + off[0], d[1] + off[1]);\n    }\n    D rnorm(D d) {\n        return D(d[0] - off[0], d[1] - off[1]);\n    }\n    foreach (i; 0..n) {\n        double t; long v;\n        sc.read(t, v); t *= v;\n        if (v == L) {\n            que.clear();\n            off = D(0, 0);\n            que.insertBack(D(0, 0));\n            que.insertBack(D(v, t));\n        } else {\n            off[0] += v; off[1] += t;\n            while (L <= norm(que[$-2])[0]) que.removeBack;\n            auto l = norm(que[$-2]), r = norm(que[$-1]);\n            double z = l[1] + (r[1] - l[1]) * (L - l[0]) / (r[0] - l[0]);\n            que.removeBack;\n            que.insertBack(rnorm(D(L, z)));\n            while (que.length >= 2) {\n                auto a = norm(que[0]), b = norm(que[1]);\n                if (a[1] * b[0] > b[1] * a[0]) {\n                    break;\n                }\n                que.removeFront;\n            }\n            que.insertFront(rnorm(D(0, 0)));\n        }\n        auto res = norm(que.back);\n        writefln(\"%.20f\", res[1]/res[0]);\n//        writeln(que[].map!norm);\n    }\n    return;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/deque.d */\n// module dkh.container.deque;\n\nstruct DequePayload(T) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint start, len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        if (start + i < cap) return _data[start + i];\n        else return _data[start + i - cap];\n    }\n    ref inout(T) front() inout { return this[0]; }\n    ref inout(T) back() inout { return this[$-1]; }\n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import std.algorithm : max;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        T* newData = cast(T*)GC.malloc(newCap * T.sizeof);\n        foreach (i; 0..length) {\n            newData[i] = this[i];\n        }\n        _data = newData; start = 0; cap = newCap.to!uint;\n    }\n    void clear() {\n        start = len = 0;\n    }\n    import std.algorithm : max;\n    void insertFront(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        if (start == 0) start += cap;\n        start--; len++;\n        this[0] = item;\n    }\n    void insertBack(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        len++;\n        this[len-1] = item;\n    }\n    void removeFront() {\n        assert(!empty, \"Deque.removeFront: Deque is empty\");\n        start++; len--;\n        if (start == cap) start = 0;\n    }\n    void removeBack() {\n        assert(!empty, \"Deque.removeBack: Deque is empty\");        \n        len--;\n    }\n}\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    alias Payload = DequePayload!T;\n    Payload* _p;\n    \n    static if (!mayNull) @disable this();\n\n     \n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        _p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        _p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    private this(Payload* p) { _p = p; }\n    static Deque make() { return Deque(new Payload()); }\n    \n    private bool havePayload() const { return (!mayNull || _p); }    \n    @property bool empty() const { return (!havePayload || _p.empty); }  \n    @property size_t length() const { return (havePayload ? _p.length : 0); }  \n    alias opDollar = length;  \n\n    ref inout(T) opIndex(size_t i) inout {\n        assert(!empty, \"Deque.opIndex: Deque is empty\");\n        return (*_p)[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void clear() { if (_p) _p.clear(); }  \n\n     \n    void insertFront(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertFront(item);\n    }\n    void insertBack(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertBack(item);\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    alias stableInsertBack = insertBack;  \n\n     \n    void removeFront() {\n        assert(!mayNull || _p, \"Deque.removeFront: Deque is empty\");\n        _p.removeFront();\n    }\n    void removeBack() {\n        assert(!mayNull || _p, \"Deque.removeBack: Deque is empty\");\n        _p.removeBack();\n    }  \n    alias stableRemoveBack = removeBack;  \n\n     \n    alias Range = RangeT!(DequePayload!T);\n    alias ConstRange = RangeT!(const DequePayload!T);  \n    alias ImmutableRange = RangeT!(immutable DequePayload!T);  \n\n    size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n        assert(start <= end && end <= length);\n        return [start, end];\n    }  \n    Range opIndex(size_t[2] rng) { return Range(_p, rng[0], rng[1]); }  \n    ConstRange opIndex(size_t[2] rng) const { return ConstRange(_p, rng[0], rng[1]); }  \n    ImmutableRange opIndex(size_t[2] rng) immutable { return ImmutableRange(_p, rng[0], rng[1]); }  \n    auto opIndex() inout { return this[0..$]; }  \n\n    static struct RangeT(QualifiedPayload) {\n        alias A = QualifiedPayload;\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t l, r;\n\n        @property bool empty() const { return r <= l; }\n        @property size_t length() const { return r - l; }\n        alias opDollar = length;\n\n        @property auto save() { return this; }\n        \n        ref inout(E) opIndex(size_t i) inout {\n            version(assert) if (empty) throw new RangeError();\n            return (*p)[l+i];\n        }\n        @property ref inout(E) front() inout { return this[0]; }\n        @property ref inout(E) back() inout { return this[$-1]; }\n\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            l++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            r--;\n        }\n        \n        size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n            assert(start <= end && end <= length);\n            return [start, end];\n        }\n        auto opIndex(size_t[2] rng) { return RangeT(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) const { return RangeT!(const A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) immutable { return RangeT!(immutable A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex() inout { return this[0..$]; }\n    } \n}\n\n \n \n\n \n\n \n\n \n\n \n\n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop;\n\nvoid main() {\n    auto s = readln.split.map!(to!long);\n    auto N = s[0].to!int;\n    auto L = s[1];\n    auto TV = N.iota.map!(_ => readln.split.map!(to!long).array).array;\n\n    long[] PL = [0];\n    real[] PC = [0];\n    \n    foreach (i; 0..N) {\n        auto t = TV[i][0];\n        auto v = TV[i][1];\n        long cap = v;\n        real tmp = t;\n        \n        for (int j = i; cap < L; --j) {\n            long x = min(L - cap, PL[j]);\n            tmp = (cap * tmp + x * PC[j]) / (cap + x);\n            cap += x;\n        }\n\n        writefln(\"%.9f\", tmp);\n\n        if (t >= PC.back) {\n            PL ~= v;\n            PC ~= t;\n        } else {\n            long x = min(L - v, PL.back);\n            PC ~= (v * t + x * PC.back) / (v + x);\n            PL ~= v + x;\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\nimport std.container.util;\n// import dkh.container.deque;\n\nimport std.typecons;\n\nvoid main() {\n    auto sc = new Scanner(stdin);\n    int n; long L;\n    sc.read(n, L);\n    alias D = Tuple!(long, double);\n    Deque!D que = make!(Deque!D);\n    D off;\n    D norm(D d) {\n        return D(d[0] + off[0], d[1] + off[1]);\n    }\n    D rnorm(D d) {\n        return D(d[0] - off[0], d[1] - off[1]);\n    }\n    foreach (i; 0..n) {\n        double t; long v;\n        sc.read(t, v); t *= v;\n        if (v == L) {\n            que.clear();\n            off = D(0, 0);\n            que.insertBack(D(0, 0));\n            que.insertBack(D(v, t));\n        } else {\n            off[0] += v; off[1] += t;\n            while (L <= norm(que[$-2])[0]) que.removeBack;\n            auto l = norm(que[$-2]), r = norm(que[$-1]);\n            double z = l[1] + (r[1] - l[1]) * (L - l[0]) / (r[0] - l[0]);\n            que.removeBack;\n            que.insertBack(rnorm(D(L, z)));\n            while (que.length >= 2) {\n                auto a = norm(que[0]), b = norm(que[1]);\n                if (a[1] / a[0] > b[1] / b[0]) {\n                    break;\n                }\n                que.removeFront;\n            }\n            que.insertFront(rnorm(D(0, 0)));\n        }\n        auto res = norm(que.back);\n        writefln(\"%.20f\", res[1]/res[0]);\n//        writeln(que[].map!norm);\n    }\n    return;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/deque.d */\n// module dkh.container.deque;\n\nstruct DequePayload(T) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint start, len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        if (start + i < cap) return _data[start + i];\n        else return _data[start + i - cap];\n    }\n    ref inout(T) front() inout { return this[0]; }\n    ref inout(T) back() inout { return this[$-1]; }\n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import std.algorithm : max;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        T* newData = cast(T*)GC.malloc(newCap * T.sizeof);\n        foreach (i; 0..length) {\n            newData[i] = this[i];\n        }\n        _data = newData; start = 0; cap = newCap.to!uint;\n    }\n    void clear() {\n        start = len = 0;\n    }\n    import std.algorithm : max;\n    void insertFront(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        if (start == 0) start += cap;\n        start--; len++;\n        this[0] = item;\n    }\n    void insertBack(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        len++;\n        this[len-1] = item;\n    }\n    void removeFront() {\n        assert(!empty, \"Deque.removeFront: Deque is empty\");\n        start++; len--;\n        if (start == cap) start = 0;\n    }\n    void removeBack() {\n        assert(!empty, \"Deque.removeBack: Deque is empty\");        \n        len--;\n    }\n}\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    alias Payload = DequePayload!T;\n    Payload* _p;\n    \n    static if (!mayNull) @disable this();\n\n     \n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        _p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        _p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    private this(Payload* p) { _p = p; }\n    static Deque make() { return Deque(new Payload()); }\n    \n    private bool havePayload() const { return (!mayNull || _p); }    \n    @property bool empty() const { return (!havePayload || _p.empty); }  \n    @property size_t length() const { return (havePayload ? _p.length : 0); }  \n    alias opDollar = length;  \n\n    ref inout(T) opIndex(size_t i) inout {\n        assert(!empty, \"Deque.opIndex: Deque is empty\");\n        return (*_p)[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void clear() { if (_p) _p.clear(); }  \n\n     \n    void insertFront(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertFront(item);\n    }\n    void insertBack(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertBack(item);\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    alias stableInsertBack = insertBack;  \n\n     \n    void removeFront() {\n        assert(!mayNull || _p, \"Deque.removeFront: Deque is empty\");\n        _p.removeFront();\n    }\n    void removeBack() {\n        assert(!mayNull || _p, \"Deque.removeBack: Deque is empty\");\n        _p.removeBack();\n    }  \n    alias stableRemoveBack = removeBack;  \n\n     \n    alias Range = RangeT!(DequePayload!T);\n    alias ConstRange = RangeT!(const DequePayload!T);  \n    alias ImmutableRange = RangeT!(immutable DequePayload!T);  \n\n    size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n        assert(start <= end && end <= length);\n        return [start, end];\n    }  \n    Range opIndex(size_t[2] rng) { return Range(_p, rng[0], rng[1]); }  \n    ConstRange opIndex(size_t[2] rng) const { return ConstRange(_p, rng[0], rng[1]); }  \n    ImmutableRange opIndex(size_t[2] rng) immutable { return ImmutableRange(_p, rng[0], rng[1]); }  \n    auto opIndex() inout { return this[0..$]; }  \n\n    static struct RangeT(QualifiedPayload) {\n        alias A = QualifiedPayload;\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t l, r;\n\n        @property bool empty() const { return r <= l; }\n        @property size_t length() const { return r - l; }\n        alias opDollar = length;\n\n        @property auto save() { return this; }\n        \n        ref inout(E) opIndex(size_t i) inout {\n            version(assert) if (empty) throw new RangeError();\n            return (*p)[l+i];\n        }\n        @property ref inout(E) front() inout { return this[0]; }\n        @property ref inout(E) back() inout { return this[$-1]; }\n\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            l++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            r--;\n        }\n        \n        size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n            assert(start <= end && end <= length);\n            return [start, end];\n        }\n        auto opIndex(size_t[2] rng) { return RangeT(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) const { return RangeT!(const A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) immutable { return RangeT!(immutable A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex() inout { return this[0..$]; }\n    } \n}\n\n \n \n\n \n\n \n\n \n\n \n\n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\nimport std.container.util;\n// import dkh.container.deque;\n\nimport std.typecons;\n\nvoid main() {\n    auto sc = new Scanner(stdin);\n    int n; long L;\n    sc.read(n, L);\n    alias D = Tuple!(long, double);\n    Deque!D que = make!(Deque!D);\n    D off;\n    D norm(D d) {\n        return D(d[0] + off[0], d[1] + off[1]);\n    }\n    D rnorm(D d) {\n        return D(d[0] - off[0], d[1] - off[1]);\n    }\n    foreach (i; 0..n) {\n        double t; long v;\n        sc.read(t, v); t *= v;\n        if (i == n-1) sc.read!true;\n        if (v == L) {\n            que.clear();\n            off = D(0, 0);\n            que.insertBack(D(0, 0));\n            que.insertBack(D(v, t));\n        } else {\n            off[0] += v; off[1] += t;\n            while (L <= norm(que[$-2])[0]) que.removeBack;\n            auto l = norm(que[$-2]), r = norm(que[$-1]);\n            double z = l[1] + (r[1] - l[1]) * (L - l[0]) / (r[0] - l[0]);\n            que.removeBack;\n            que.insertBack(rnorm(D(L, z)));\n            while (que.length >= 2) {\n                auto a = norm(que[0]), b = norm(que[1]);\n                if (a[1] * b[0] > b[1] * a[0]) {\n                    break;\n                }\n                que.removeFront;\n            }\n            que.insertFront(rnorm(D(0, 0)));\n        }\n        auto res = norm(que.back);\n        writefln(\"%.20f\", res[1]/res[0]);\n//        writeln(que[].map!norm);\n    }\n    return;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/deque.d */\n// module dkh.container.deque;\n\nstruct DequePayload(T) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint start, len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        if (start + i < cap) return _data[start + i];\n        else return _data[start + i - cap];\n    }\n    ref inout(T) front() inout { return this[0]; }\n    ref inout(T) back() inout { return this[$-1]; }\n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import std.algorithm : max;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        T* newData = cast(T*)GC.malloc(newCap * T.sizeof);\n        foreach (i; 0..length) {\n            newData[i] = this[i];\n        }\n        _data = newData; start = 0; cap = newCap.to!uint;\n    }\n    void clear() {\n        start = len = 0;\n    }\n    import std.algorithm : max;\n    void insertFront(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        if (start == 0) start += cap;\n        start--; len++;\n        this[0] = item;\n    }\n    void insertBack(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        len++;\n        this[len-1] = item;\n    }\n    void removeFront() {\n        assert(!empty, \"Deque.removeFront: Deque is empty\");\n        start++; len--;\n        if (start == cap) start = 0;\n    }\n    void removeBack() {\n        assert(!empty, \"Deque.removeBack: Deque is empty\");        \n        len--;\n    }\n}\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    alias Payload = DequePayload!T;\n    Payload* _p;\n    \n    static if (!mayNull) @disable this();\n\n     \n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        _p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        _p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    private this(Payload* p) { _p = p; }\n    static Deque make() { return Deque(new Payload()); }\n    \n    private bool havePayload() const { return (!mayNull || _p); }    \n    @property bool empty() const { return (!havePayload || _p.empty); }  \n    @property size_t length() const { return (havePayload ? _p.length : 0); }  \n    alias opDollar = length;  \n\n    ref inout(T) opIndex(size_t i) inout {\n        assert(!empty, \"Deque.opIndex: Deque is empty\");\n        return (*_p)[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void clear() { if (_p) _p.clear(); }  \n\n     \n    void insertFront(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertFront(item);\n    }\n    void insertBack(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertBack(item);\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    alias stableInsertBack = insertBack;  \n\n     \n    void removeFront() {\n        assert(!mayNull || _p, \"Deque.removeFront: Deque is empty\");\n        _p.removeFront();\n    }\n    void removeBack() {\n        assert(!mayNull || _p, \"Deque.removeBack: Deque is empty\");\n        _p.removeBack();\n    }  \n    alias stableRemoveBack = removeBack;  \n\n     \n    alias Range = RangeT!(DequePayload!T);\n    alias ConstRange = RangeT!(const DequePayload!T);  \n    alias ImmutableRange = RangeT!(immutable DequePayload!T);  \n\n    size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n        assert(start <= end && end <= length);\n        return [start, end];\n    }  \n    Range opIndex(size_t[2] rng) { return Range(_p, rng[0], rng[1]); }  \n    ConstRange opIndex(size_t[2] rng) const { return ConstRange(_p, rng[0], rng[1]); }  \n    ImmutableRange opIndex(size_t[2] rng) immutable { return ImmutableRange(_p, rng[0], rng[1]); }  \n    auto opIndex() inout { return this[0..$]; }  \n\n    static struct RangeT(QualifiedPayload) {\n        alias A = QualifiedPayload;\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t l, r;\n\n        @property bool empty() const { return r <= l; }\n        @property size_t length() const { return r - l; }\n        alias opDollar = length;\n\n        @property auto save() { return this; }\n        \n        ref inout(E) opIndex(size_t i) inout {\n            version(assert) if (empty) throw new RangeError();\n            return (*p)[l+i];\n        }\n        @property ref inout(E) front() inout { return this[0]; }\n        @property ref inout(E) back() inout { return this[$-1]; }\n\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            l++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            r--;\n        }\n        \n        size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n            assert(start <= end && end <= length);\n            return [start, end];\n        }\n        auto opIndex(size_t[2] rng) { return RangeT(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) const { return RangeT!(const A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) immutable { return RangeT!(immutable A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex() inout { return this[0..$]; }\n    } \n}\n\n \n \n\n \n\n \n\n \n\n \n\n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dunkelheit\" version=\">=0.9.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dkh.foundation, dkh.scanner;\n\nimport std.container.util;\n// import dkh.container.deque;\n\nimport std.typecons;\n\nvoid main() {\n    auto sc = new Scanner(stdin);\n    int n; long L;\n    sc.read(n, L);\n    alias D = Tuple!(long, double);\n    Deque!(D, false) que = Deque!(D, false).make();//make!(Deque!(D, false))();\n    D off;\n    D norm(D d) {\n        return D(d[0] + off[0], d[1] + off[1]);\n    }\n    D rnorm(D d) {\n        return D(d[0] - off[0], d[1] - off[1]);\n    }\n    foreach (i; 0..n) {\n        double t; long v;\n        sc.read(t, v); t *= v;\n        if (i == n-1) sc.read!true;\n        if (v == L) {\n            que.clear();\n            off = D(0, 0);\n            que.insertBack(D(0, 0));\n            que.insertBack(D(v, t));\n        } else {\n            off[0] += v; off[1] += t;\n            while (L <= norm(que[$-2])[0]) que.removeBack;\n            auto l = norm(que[$-2]), r = norm(que[$-1]);\n            double z = l[1] + (r[1] - l[1]) * (L - l[0]) / (r[0] - l[0]);\n            que.removeBack;\n            que.insertBack(rnorm(D(L, z)));\n            while (que.length >= 2) {\n                auto a = norm(que[0]), b = norm(que[1]);\n                if (a[1] * b[0] > b[1] * a[0]) {\n                    break;\n                }\n                que.removeFront;\n            }\n            que.insertFront(rnorm(D(0, 0)));\n        }\n        auto res = norm(que.back);\n        writefln(\"%.12f\", res[1]/res[0]);\n//        writeln(que[].map!norm);\n    }\n    return;\n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/stackpayload.d */\n// module dkh.container.stackpayload;\n\n \nstruct StackPayload(T, size_t MINCAP = 4) if (MINCAP >= 1) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n     \n    inout(T)[] data() inout { return (_data) ? _data[0..len] : null; }\n    \n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        return _data[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import core.stdc.string : memcpy;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        void* newData = GC.malloc(newCap * T.sizeof);\n        cap = newCap.to!uint;\n        if (len) memcpy(newData, _data, len * T.sizeof);\n        _data = cast(T*)(newData);\n    }  \n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }  \n     \n    void clear() {\n        len = 0;\n    }\n\n    void insertBack(T item) {\n        import std.algorithm : max;\n        if (len == cap) reserve(max(cap * 2, MINCAP));\n        _data[len++] = item;\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    void removeBack() {\n        assert(!empty, \"StackPayload.removeBack: Stack is empty\");\n        len--;\n    }  \n}\n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/foundation.d */\n \n// module dkh.foundation;\n\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/scanner.d */\n// module dkh.scanner;\n\n// import dkh.container.stackpayload;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                StackPayload!E buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n\n    int unsafeRead(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n    void read(bool enforceEOF = false, T, Args...)(ref T x, auto ref Args args) {\n        import std.exception;\n        enforce(readSingle(x));\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            read!enforceEOF(args);\n        }\n    }\n    void read(bool enforceEOF = false, Args...)(auto ref Args args) {\n        import std.exception;\n        static if (args.length == 0) {\n            enforce(enforceEOF == false || !succ());\n        } else {\n            enforce(readSingle(args[0]));\n            read!enforceEOF(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dunkelheit/source/dkh/container/deque.d */\n// module dkh.container.deque;\n\nstruct DequePayload(T) {\n    import core.exception : RangeError;\n\n    private T* _data;\n    private uint start, len, cap;\n\n    @property bool empty() const { return len == 0; }\n    @property size_t length() const { return len; }\n    alias opDollar = length;\n\n    ref inout(T) opIndex(size_t i) inout {\n        version(assert) if (len <= i) throw new RangeError();\n        if (start + i < cap) return _data[start + i];\n        else return _data[start + i - cap];\n    }\n    ref inout(T) front() inout { return this[0]; }\n    ref inout(T) back() inout { return this[$-1]; }\n\n    void reserve(size_t newCap) {\n        import core.memory : GC;\n        import std.algorithm : max;\n        import std.conv : to;\n        if (newCap <= cap) return;\n        T* newData = cast(T*)GC.malloc(newCap * T.sizeof);\n        foreach (i; 0..length) {\n            newData[i] = this[i];\n        }\n        _data = newData; start = 0; cap = newCap.to!uint;\n    }\n    void clear() {\n        start = len = 0;\n    }\n    import std.algorithm : max;\n    void insertFront(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        if (start == 0) start += cap;\n        start--; len++;\n        this[0] = item;\n    }\n    void insertBack(T item) {\n        if (len == cap) reserve(max(cap * 2, 4));\n        len++;\n        this[len-1] = item;\n    }\n    void removeFront() {\n        assert(!empty, \"Deque.removeFront: Deque is empty\");\n        start++; len--;\n        if (start == cap) start = 0;\n    }\n    void removeBack() {\n        assert(!empty, \"Deque.removeBack: Deque is empty\");        \n        len--;\n    }\n}\n\n \nstruct Deque(T, bool mayNull = true) {\n    import core.exception : RangeError;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    alias Payload = DequePayload!T;\n    Payload* _p;\n    \n    static if (!mayNull) @disable this();\n\n     \n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {\n        _p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n     \n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {\n        _p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    private this(Payload* p) { _p = p; }\n    static Deque make() { return Deque(new Payload()); }\n    \n    private bool havePayload() const { return (!mayNull || _p); }    \n    @property bool empty() const { return (!havePayload || _p.empty); }  \n    @property size_t length() const { return (havePayload ? _p.length : 0); }  \n    alias opDollar = length;  \n\n    ref inout(T) opIndex(size_t i) inout {\n        assert(!empty, \"Deque.opIndex: Deque is empty\");\n        return (*_p)[i];\n    }  \n    ref inout(T) front() inout { return this[0]; }  \n    ref inout(T) back() inout { return this[$-1]; }  \n\n    void clear() { if (_p) _p.clear(); }  \n\n     \n    void insertFront(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertFront(item);\n    }\n    void insertBack(T item) {\n        if (mayNull && !_p) _p = new Payload();\n        _p.insertBack(item);\n    }  \n    alias opOpAssign(string op : \"~\") = insertBack;  \n    alias stableInsertBack = insertBack;  \n\n     \n    void removeFront() {\n        assert(!mayNull || _p, \"Deque.removeFront: Deque is empty\");\n        _p.removeFront();\n    }\n    void removeBack() {\n        assert(!mayNull || _p, \"Deque.removeBack: Deque is empty\");\n        _p.removeBack();\n    }  \n    alias stableRemoveBack = removeBack;  \n\n     \n    alias Range = RangeT!(DequePayload!T);\n    alias ConstRange = RangeT!(const DequePayload!T);  \n    alias ImmutableRange = RangeT!(immutable DequePayload!T);  \n\n    size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n        assert(start <= end && end <= length);\n        return [start, end];\n    }  \n    Range opIndex(size_t[2] rng) { return Range(_p, rng[0], rng[1]); }  \n    ConstRange opIndex(size_t[2] rng) const { return ConstRange(_p, rng[0], rng[1]); }  \n    ImmutableRange opIndex(size_t[2] rng) immutable { return ImmutableRange(_p, rng[0], rng[1]); }  \n    auto opIndex() inout { return this[0..$]; }  \n\n    static struct RangeT(QualifiedPayload) {\n        alias A = QualifiedPayload;\n        import std.traits : CopyTypeQualifiers;\n        alias E = CopyTypeQualifiers!(A, T);\n        A *p;\n        size_t l, r;\n\n        @property bool empty() const { return r <= l; }\n        @property size_t length() const { return r - l; }\n        alias opDollar = length;\n\n        @property auto save() { return this; }\n        \n        ref inout(E) opIndex(size_t i) inout {\n            version(assert) if (empty) throw new RangeError();\n            return (*p)[l+i];\n        }\n        @property ref inout(E) front() inout { return this[0]; }\n        @property ref inout(E) back() inout { return this[$-1]; }\n\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            l++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            r--;\n        }\n        \n        size_t[2] opSlice(size_t dim : 0)(size_t start, size_t end) const {\n            assert(start <= end && end <= length);\n            return [start, end];\n        }\n        auto opIndex(size_t[2] rng) { return RangeT(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) const { return RangeT!(const A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex(size_t[2] rng) immutable { return RangeT!(immutable A)(p, l+rng[0], l+rng[1]); }\n        auto opIndex() inout { return this[0..$]; }\n    } \n}\n\n \n \n\n \n\n \n\n \n\n \n\n \n\n \n\n/*\nThis source code generated by dunkelheit and include dunkelheit's source code.\ndunkelheit's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dunkelheit)\ndunkelheit's License: MIT License(https://github.com/yosupo06/dunkelheit/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Python",
    "code": "# F\nfrom collections import deque\n\nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que[-1]\n            if t_ <= t:\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n                que.pop()\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "from queue import PriorityQueue\n\nq = PriorityQueue()\n\nN, L = list(map(int,input().split()))\nres = \"\"\nt, v = list(map(int,input().split()))\nres += str(t)\ntemp = float(t*v)\nres += \"\\n\"\nmintemp = temp/v\n\nfor i in range(N-1):\n\tt, v = list(map(int,input().split()))\n\tsute = 0\n\ttemp += t*v\n\ttemp -= mintemp*v\n\tmintemp = min(mintemp, temp/L)\n\tres += str(temp/L)\n\tres += \"\\n\"\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN, L = map(int,input().split())\n\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nprint(t)\nene = t*v\n\nfor que in [map(int,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tprint(ene/L)\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# 各日に対して、関数：残量 -> 最適な熱量 を持つことを考える\n# これは折れ線。傾きが増加する部分 → マージしてまとめる\n# 常に、傾きの減少列の形で持つことになる\n\nfrom collections import deque\n\nN,L = map(int,readline().split())\nm = map(int,read().split())\nTV = zip(m,m)\n\nanswer = []\nINF = 10 ** 18\n\n# 1日目\nt,v = next(TV)\nanswer.append(t)\nqT = deque([t])\nqV = deque([v])\nsum_q = t * v # 今持っている総熱量\n\nfor t,v in TV:\n    qT.appendleft(t); qV.appendleft(v)\n    sum_q += t * v\n    # 右側からvだけ捨てる\n    rest = v\n    while qV[-1] <= rest:\n        x = qV.pop()\n        rest -= x\n        sum_q -= x * qT.pop()\n    qV[-1] -= rest\n    sum_q -= rest * qT[-1]\n    # 左側から傾きの増大部分をマージ\n    while len(qT) >= 2:\n        t0 = qT[0]; t1 = qT[1]\n        if t0 > t1:\n            break\n        qT.popleft()\n        v0 = qV.popleft(); v1 = qV[0]\n        t2 = (t0 * v0 + t1 * v1) / (v0 + v1)\n        qT[0] = t2; qV[0] += v0\n    answer.append(sum_q/L)\n\nprint('\\n'.join(map(str,answer)))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(float,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += str(ene/L) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(float,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += \"{0:.6f}\".format(ene/L) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport numpy as np\n\nN,L = list(map(int,input().split()))\nL = np.float32(L)\n\n########################################\n\nres = \"\"\n\nt1,v1 = map(np.float64,input().split())\n\nd = deque( [(t1,v1)] )\nnetsuryou = t1*v1\n\nres += str(t1) + \"\\n\"\n\nfor t,v in [ map(np.float64,input().split()) for _ in range(N-1) ]:\n\t\n\tnetsuryou += t*v\n\n\t#右端からvリットル減らす\n\tl = v\n\twhile(l > 0):\n\t\tmigihasi_t,migihasi_v = d.pop()\n\t\tif migihasi_v > l:\n\t\t\tnetsuryou -= migihasi_t*l\n\t\t\td.append( ( migihasi_t,migihasi_v-l ) )\n\t\t\tbreak\n\t\telse:\n\t\t\tl = l - migihasi_v\n\t\t\tnetsuryou -= migihasi_t*migihasi_v\n\n\t#答えを表示\n\tres += str(netsuryou / L) + \"\\n\"\n\n\t#左のほうが温度が低ければ2つを合成\n\tnew_t,new_v = t,v\n\twhile(True):\n\n\t\tif len(d) == 0:\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\thidarihasi_t,hidarihasi_v = d.popleft()\n\n\t\t#条件を満たすならループを抜ける\n\t\tif new_t >= hidarihasi_t:\n\t\t\td.appendleft( (hidarihasi_t,hidarihasi_v) )\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\tnew_v = new_v + hidarihasi_v\n\t\tnew_t = (new_t*new_v + hidarihasi_t*hidarihasi_v) / new_v\n\nprint (res)\n"
  },
  {
    "language": "Python",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <vector>\n#include <cstring>\n#include <deque>\nusing namespace std;\ntypedef long long ll;\nint main()\n{\n    //freopen(\"input.in\", \"r\", stdin);\n    ll N, L;\n    while(cin>>N>>L){\n        deque<pair<ll, ll>> dp;\n        vector<ll> T(N, 0), V(N, 0);\n        for(int i=0;i<N;i++){\n            cin>>T[i]>>V[i];\n        }\n        ll tt=0, vv=0;\n        for(int i=0;i<N;i++){\n            ll t=T[i]*V[i], v=V[i];\n            while(vv+v>L){\n               ll t1=dp[0].first, v1=dp[0].second;\n               ll tmp=min(vv+v-L, v1);\n               tt=tt-t1*tmp/v1;\n               vv-=tmp;\n               if(tmp==v1){\n                   dp.pop_front();\n               }\n               else{\n                   dp[0].first=t1-t1*tmp/v1;\n                   dp[0].second=v1-tmp;\n               }\n            }\n\n            tt+=t;\n            vv=L;\n            printf(\"%.7lf\\n\", (double)tt/vv);\n            int ans=dp.size();\n            ll c1=t;\n            ll c2=v;\n            while(ans){\n                ll t2=dp[ans-1].first, v2=dp[ans-1].second;\n                if(t2/v2<c1/c2){\n                    break;\n                }\n                else{\n                    c1+=t2;\n                    c2+=v2;\n                    dp.pop_back();\n                }\n                ans=dp.size();\n            }\n            dp.push_back(make_pair(c1, c2));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "temp=input().split()\nN=int(temp[0])\nL=int(temp[1])\nt=[]\nv=[]\nthrow=0#amount of throw water\nindex=0\n\nfor I in range(N):\n\ttemp=input().split()\n\tt+=[int(temp[0])]\n\tv+=[int(temp[1])]\n\t\n\tif I==0:\n\t\tprint(t[0])\n\t\tcontinue\n\t\n\tthrow=v[I]\n\twhile True:\n\t\tcoldTemp=min(t[:-1])\n\t\tcoldIndex=t.index(coldTemp)\n\t\tif throw<v[coldIndex]:\n\t\t\tv[coldIndex]-=throw\n\t\t\tbreak\n\t\telse:\n\t\t\tthrow-=v[coldIndex]\n\t\t\tdel v[coldIndex]\n\t\t\tdel t[coldIndex]\n\t\t\t\n\tans=0\n\tfor i in range(len(t)):\n\t\tans+=t[i]*v[i]\n\tprint(ans/L)\n\t"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(float,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += \"{0:.6f}\".format(ene/L) + \"\\n\"\n\nif N < 100:\n\tprint(res)\nelse:\n\tprint(100)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que[-1]\n            if t_ <= t:\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n                que.pop()\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "N, L = list(map(int,input().split()))\nres = \"\"\nt, v = map(int,input().split())\nprint(t)\ntemp = float(t*v)\nmintemp = temp/v\n\nfor i in range(N-1):\n\tt, v = map(int,input().split())\n\tsute = 0\n\ttemp += t*v\n\ttemp -= mintemp*v\n\tmintemp = min(mintemp, temp/L)\n\tprint(temp/L)\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN,L = list(map(int,input().split()))\n\nList = []\n########################################\n\n\nt1,v1 = map(int,input().split())\n\nd = deque( [(t1,v1)] )\nnetsuryou = t1*v1\n\nprint (t1)\n\nfor t,v in [ map(int,input().split()) for _ in range(N-1) ]:\n\t\n\tnetsuryou += t*v\n\n\t#右端からvリットル減らす\n\tl = v\n\twhile(l > 0):\n\t\tmigihasi_t,migihasi_v = d.pop()\n\t\tif migihasi_v > l:\n\t\t\tnetsuryou -= migihasi_t*l\n\t\t\td.append( ( migihasi_t,migihasi_v-l ) )\n\t\t\tbreak\n\t\telse:\n\t\t\tl = l - migihasi_v\n\t\t\tnetsuryou -= migihasi_t*migihasi_v\n\n\t#答えを表示\n\tprint (netsuryou / L)\n\n\t#左のほうが温度が低ければ2つを合成\n\tnew_t,new_v = t,v\n\twhile(True):\n\n\t\tif len(d) == 0:\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\thidarihasi_t,hidarihasi_v = d.popleft()\n\n\t\t#条件を満たすならループを抜ける\n\t\tif new_t >= hidarihasi_t:\n\t\t\td.appendleft( (hidarihasi_t,hidarihasi_v) )\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\tnew_v = new_v + hidarihasi_v\n\t\tnew_t = (new_t*new_v + hidarihasi_t*hidarihasi_v) / new_v\n\t\t\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN, L = map( int, input().split() )\nT = []\nV = []\nfor i in range( N ):\n  t, v = map( int, input().split() )\n  T.append( t )\n  V.append( v )\n\ndq = deque()\nct, cv = 0.0, 0.0\nfor i in range( N ):\n  while cv + V[ i ] > L:\n    ft, fv = dq[ 0 ]\n    take = min( cv + V[ i ] - L, fv )\n    ct, cv = ( ct * cv - ft * take ) / ( cv - take ), cv - take\n    if take == fv:\n      dq.popleft()\n    else:\n      dq[ 0 ] = [ ft, fv - take ]\n  ct, cv = ( ct * cv + T[ i ] * V[ i ] ) / L, L\n  print( \"%.7f\" % ct )\n  while len( dq ):\n    bt, bv = dq[ len( dq ) - 1 ]\n    if bt < T[ i ]: break\n    T[ i ], V[ i ] = ( T[ i ] * V[ i ] + bt * bv ) / ( V[ i ] + bv ), V[ i ] + bv\n    dq.pop()\n  dq.append( [ T[ i ], V[ i ] ] )"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN, L = map( int, input().split() )\nT = []\nV = []\nfor i in range( N ):\n  t, v = map( int, input().split() )\n  T.append( t )\n  V.append( v )\n\ndq = deque()\nct, cv = 0.0, 0.0\nfor i in range( N ):\n  while cv + V[ i ] > L:\n    ft, fv = dq[ 0 ]\n    take = min( cv + V[ i ] - L, fv )\n    ct, cv = ( ct * cv - ft * take ) / ( cv - take ), cv - take\n    if take == fv:\n      dq.popleft()\n    else:\n      dq[ 0 ] = [ ft, fv - take ]\n  ct, cv = ( ct * cv + T[ i ] * V[ i ] ) / L, L\n  print( \"%.7f\" % ct )\n  while len( dq ):\n    bt, bv = dq[ len( dq ) - 1 ]\n    if bt < T[ i ]: break\n    T[ i ], V[ i ] = ( T[ i ] * V[ i ] + bt * bv ) / ( V[ i ] + bv ), V[ i ] + bv\n    dq.pop()\n  dq.append( [ T[ i ], V[ i ] ] )\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(float,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += \"{0:.6f}\".format(ene) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que.pop()\n            if t_ <= t:\n                que.append([t_, v_])\n                que.append([t, v])\n                break\n            elif v + v_ > L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n                if v == L:\n                    que = deque([[t, v]])\n                    v_now = L\n                    vt_now = t*L\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(int,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += str(ene/L) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.deque([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que[-1]\n            if t_ <= t:\n                que.append([t, v])\n                break\n            elif v + v_ > L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n                if v == L:\n                    que = deque([[t, v]])\n                    v_now = L\n                    vt_now = t*L\n                else:\n                    que.pop()\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "N, L = list(map(int,input().split()))\nres = \"\"\nt, v = map(int,input().split())\nprint(t)\ntemp = float(t*v)\nmintemp = temp/v\n\nfor i in range(N-1):\n\tt, v = map(int,input().split())\n\tsute = 0\n\ttemp += t*v\n\ttemp -= mintemp*v\n\tmintemp = min(mintemp, temp/L)\n\tprint(temp/L)\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(int,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += str(ene/L) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "N, L = list(map(int,input().split()))\nt, v = map(int,input().split())\nprint(t)\n\n\nfor i in range(N-1):\n\tt, v = map(int,input().split())\n\n\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que.pop()\n            if t_ <= t:\n                que.append([t_, v_])\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = v*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n\nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que.pop()\n            if t_ <= t:\n                que.append([t_, v_])\n                que.append([t, v])\n                break\n            elif v + v_ > L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n    VV = 0\n    TT = 0\n    for i in range(len(que)-1, -1, -1):\n        t, v = que[i]\n        if VV + v >= L:\n            TT = ((L - VV) * t + VV * TT) / L\n            VV = L\n            break\n        else:\n            TT = (t*v + TT*VV) / (v + VV)\n            VV += v\n            \n            \n    TT_list.append(TT)\n\nfor i in range(N):\n    print(TT_list[i])"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(float,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += \"{0:.7f}\".format(ene) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN,L = list(map(int,input().split()))\n\nList = []\n########################################\n\nres = \"\"\n\nt1,v1 = map(int,input().split())\n\nd = deque( [(t1,v1)] )\nnetsuryou = t1*v1\n\nres += str(t1) + \"\\n\"\n\nfor t,v in [ map(int,input().split()) for _ in range(N-1) ]:\n\t\n\tnetsuryou += t*v\n\n\t#右端からvリットル減らす\n\tl = v\n\twhile(l > 0):\n\t\tmigihasi_t,migihasi_v = d.pop()\n\t\tif migihasi_v > l:\n\t\t\tnetsuryou -= migihasi_t*l\n\t\t\td.append( ( migihasi_t,migihasi_v-l ) )\n\t\t\tbreak\n\t\telse:\n\t\t\tl = l - migihasi_v\n\t\t\tnetsuryou -= migihasi_t*migihasi_v\n\n\t#答えを表示\n\tres += str(netsuryou / L) + \"\\n\"\n\n\t#左のほうが温度が低ければ2つを合成\n\tnew_t,new_v = t,v\n\twhile(True):\n\n\t\tif len(d) == 0:\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\thidarihasi_t,hidarihasi_v = d.popleft()\n\n\t\t#条件を満たすならループを抜ける\n\t\tif new_t >= hidarihasi_t:\n\t\t\td.appendleft( (hidarihasi_t,hidarihasi_v) )\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\tnew_v = new_v + hidarihasi_v\n\t\tnew_t = (new_t*new_v + hidarihasi_t*hidarihasi_v) / new_v\n\nprint (res)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(int,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += \"{0:.7f}\".format(ene/L) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "N, L = list(map(int,input().split()))\nres = \"\"\nt, v = list(map(int,input().split()))\nres += str(t)\ntemp = float(t*v)\nres += \"\\n\"\nmintemp = temp/v\n\nfor i in range(N-1):\n\tt, v = list(map(int,input().split()))\n\tsute = 0\n\ttemp += t*v\n\ttemp -= mintemp*v\n\tmintemp = min(mintemp, temp/L)\n\tres += str(temp/L)\n\tres += \"\\n\"\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que.pop()\n            if t_ <= t:\n                que.append([t_, v_])\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([t, v])\n                v_now = L\n                vt_now = v*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "# なんだか釈然としていないが解説の通りに\nfrom collections import deque\nimport sys\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\nclass water:\n    def __init__(self, t, v):\n        self.v = v\n        self.tv = v * t\n\n    def __le__(self, other):\n        return self.v * other.tv - self.tv * other.v >= 0\n\n    def __isub__(self, other):\n        t = self.tv / self.v\n        self.v -= other\n        self.tv = t * self.v\n        return self\n\n    def __iadd__(self, other):\n        self.v+=other.v\n        self.tv+=other.tv\n        return self\n\ndef main():\n    n, l = MI()\n    dam = deque()\n    t, v = MI()\n    print(t)\n    dam.append(water(t, v))\n    # stvはtvの合計（vがlのときのvt）\n    stv = t * v\n    for _ in range(n-1):\n        t, v = MI()\n        # 朝に水をもらう\n        dam.appendleft(water(t, v))\n        over = v\n        stv += t * v\n        # 増えた分の水を古い方から捨てる\n        # ベクトルごと削除できるもの\n        while dam[-1].v <= over:\n            w = dam.pop()\n            over -= w.v\n            stv -= w.tv\n        # 最後のはみ出しているベクトルは縮める\n        stv -= dam[-1].tv  # 一度合計から取り出して\n        dam[-1] -= over  # 縮めて\n        stv += dam[-1].tv  # 元に戻す\n        # その日の水温を出力\n        print(stv / l)\n        # グラフの左側が凹んでいたらベクトルを合成して凸に直す\n        while len(dam)>1 and dam[0] <= dam[1]:\n            w = dam.popleft()\n            dam[0] += w\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# F\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que[-1]\n            if t_ <= t:\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n                que.pop()\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# 各日に対して、関数：残量 -> 最適な熱量 を持つことを考える\n# これは折れ線。傾きが増加する部分 → マージしてまとめる\n# 常に、傾きの減少列の形で持つことになる\n\nfrom collections import deque\n\nN,L = map(int,readline().split())\nm = map(int,read().split())\nTV = zip(m,m)\n\nanswer = []\nINF = 10 ** 18\n\n# 1日目\nt,v = next(TV)\nanswer.append(t)\nqT = deque([t])\nqV = deque([v])\nsum_q = t * v # 今持っている総熱量\n\nfor t,v in TV:\n    qT.appendleft(t); qV.appendleft(v)\n    sum_q += t * v\n    # 右側からvだけ捨てる\n    rest = v\n    while qV[-1] <= rest:\n        x = qV.pop()\n        rest -= x\n        sum_q -= x * qT.pop()\n    qV[-1] -= rest\n    sum_q -= rest * qT[-1]\n    # 左側から傾きの増大部分をマージ\n    while len(qT) >= 2:\n        t0 = qT[0]; t1 = qT[1]\n        if t0 > t1:\n            break\n        qT.popleft()\n        v0 = qV.popleft(); v1 = qV[0]\n        t2 = (t0 * v0 + t1 * v1) / (v0 + v1)\n        qT[0] = t2; qV[0] += v0\n    answer.append(sum_q/L)\n\nprint('\\n'.join(map(str,answer)))"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que.pop()\n            if t_ <= t:\n                que.append([t_, v_])\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que = deque([[t, v]])\n                v_now = L\n                vt_now = t*L\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# 各日に対して、関数：残量 -> 最適な熱量 を持つことを考える\n# これは折れ線。傾きが増加する部分 → マージしてまとめる\n# 常に、傾きの減少列の形で持つことになる\n\nfrom collections import deque\n\nN,L = map(int,readline().split())\nm = map(int,read().split())\nTV = zip(m,m)\n\nanswer = []\nINF = 10 ** 18\n\n# 1日目\nt,v = next(TV)\nprint(t)\nqT = deque([t])\nqV = deque([v])\nsum_q = t * v # 今持っている総熱量\n\nfor t,v in TV:\n    qT.appendleft(t); qV.appendleft(v)\n    sum_q += t * v\n    # 右側からvだけ捨てる\n    rest = v\n    while qV[-1] <= rest:\n        x = qV.pop()\n        rest -= x\n        sum_q -= x * qT.pop()\n    qV[-1] -= rest\n    sum_q -= rest * qT[-1]\n    # 左側から傾きの増大部分をマージ\n    while len(qT) >= 2:\n        t0 = qT[0]; t1 = qT[1]\n        if t0 > t1:\n            break\n        qT.popleft()\n        v0 = qV.popleft(); v1 = qV[0]\n        t2 = (t0 * v0 + t1 * v1) / (v0 + v1)\n        qT[0] = t2; qV[0] += v0\n    print(sum_q/L)"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport array, bisect, collections, heapq, itertools, math, random, re, string, sys, time\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 20\nMOD = 10 ** 9 + 7\n \n \ndef II(): return int(input())\ndef ILI(): return list(map(int, input().split()))\ndef IAI(LINE): return [ILI() for __ in range(LINE)]\ndef IDI(): return {key: value for key, value in ILI()}\n \n \ndef solve(N, L, waters):\n    now_v = 0\n    now_t = 0\n    ans = []\n    for water in waters:\n        if water[0] > now_t:\n            now_v = water[1]\n            now_t = water[0]\n            ans.append(now_t)\n        elif water[0] == now_t:\n            if now_v + water[1] >= L:\n                now_v = L\n                ans.append(now_t)\n            else:\n                now_v += water[1]\n                ans.append(now_t)\n        elif water[0] < now_t:\n            if now_v + water[1] >= L:\n                now_v = L\n                now_t = (now_t * (L - water[1]) + (water[0] * water[1])) / L\n                ans.append(now_t)\n            else:\n                now_t = (now_t * now_v + water[0] * water[1]) / L                \n                now_v += water[1]\n                ans.append(now_t)\n    \n    return ans\n\n \ndef main():\n    N, L = ILI()\n    waters = IAI(N)\n    ans = solve(N, L, waters)\n    for i in ans:\n        print(i)\n \n \nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "from queue import PriorityQueue\n\nq = PriorityQueue()\n\nN, L = list(map(int,input().split()))\nres = \"\"\nt, v = list(map(int,input().split()))\nres += str(t)\ntemp = float(t*v)\nres += \"\\n\"\nq.put([t,v])\n\nfor i in range(N-1):\n\tt, v = list(map(int,input().split()))\n\tsute = 0\n\ttemp += (t*v)\n\twhile sute < v:\n\t\ts = q.get()\n\t\tif s[1] > v-sute:\n\t\t\ttemp -= s[0]*(v-sute)\n\t\t\ts[1] -= v-sute\n\t\t\tsute = v\n\t\t\tq.put(s)\n\t\telse:\n\t\t\ttemp -= s[0]*s[1]\n\t\t\tsute += s[1]\n\tq.put([temp/L,L])\n\tres += str(temp/L)\n\tres += \"\\n\"\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "N, L = list(map(int,input().split()))\nt, v = map(int,input().split())\nprint(t)\n\n\nfor i in range(N-1):\n\tt, v = map(int,input().split())\n\tprint(v)\n\n\n"
  },
  {
    "language": "Python",
    "code": "N, L = list(map(int,input().split()))\nt, v = map(int,input().split())\nprint(t)\nres = \"\"\n\nfor i in range(N-1):\n\tt, v = map(int,input().split())\n\tres += str(t)+\"\\n\"\n\nprint(res)\n\n"
  },
  {
    "language": "Python",
    "code": "# F\nimport numpy as np\nfrom collections import deque\n \nTT_list = []\n# input\nN, L = map(int, input().split())\nT = 0.0\nvt_now = 0.0\nv_now = 0\nque = deque()\n\nfor i in range(N):\n    ti, v = map(int, input().split())\n    t = float(ti)\n    v_now += v\n    vt_now += v*t\n    # add\n    if v == L:\n        que.append([t, v])\n    else:\n        while v < L and len(que) > 0:\n            t_, v_ = que.pop()\n            if t_ <= t:\n                que.append([t_, v_])\n                que.append([t, v])\n                break\n            elif v + v_ >= L:\n                v_ = v + v_ - L\n                t = ((L - v) * t_ + v * t) / L\n                v = L\n                que.append([t_, v_])\n                que.append([t, v])\n                # break\n            else:\n                t = (t*v + t_*v_) / (v + v_)\n                v = v + v_\n    # minus\n    while v_now > L:\n        if que[0][1] <= v_now - L:\n            v_now -= que[0][1]\n            vt_now -= que[0][1]*que[0][0]\n            que.popleft()\n        else:\n            que[0][1] -= v_now - L\n            vt_now -= (v_now - L)*que[0][0]\n            v_now = L\n            \n    TT_list.append(vt_now / L)\n\nfor i in range(N):\n    print(TT_list[i])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport numpy as np\n\nN,L = list(map(int,input().split()))\nL = np.float32(L)\n\n########################################\n\nres = \"\"\n\nt1,v1 = map(np.float32,input().split())\n\nd = deque( [(t1,v1)] )\nnetsuryou = t1*v1\n\nres += str(t1) + \"\\n\"\n\nfor t,v in [ map(np.float32,input().split()) for _ in range(N-1) ]:\n\t\n\tnetsuryou += t*v\n\n\t#右端からvリットル減らす\n\tl = v\n\twhile(l > 0):\n\t\tmigihasi_t,migihasi_v = d.pop()\n\t\tif migihasi_v > l:\n\t\t\tnetsuryou -= migihasi_t*l\n\t\t\td.append( ( migihasi_t,migihasi_v-l ) )\n\t\t\tbreak\n\t\telse:\n\t\t\tl = l - migihasi_v\n\t\t\tnetsuryou -= migihasi_t*migihasi_v\n\n\t#答えを表示\n\tres += str(netsuryou / L) + \"\\n\"\n\n\t#左のほうが温度が低ければ2つを合成\n\tnew_t,new_v = t,v\n\twhile(True):\n\n\t\tif len(d) == 0:\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\thidarihasi_t,hidarihasi_v = d.popleft()\n\n\t\t#条件を満たすならループを抜ける\n\t\tif new_t >= hidarihasi_t:\n\t\t\td.appendleft( (hidarihasi_t,hidarihasi_v) )\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\tnew_v = new_v + hidarihasi_v\n\t\tnew_t = (new_t*new_v + hidarihasi_t*hidarihasi_v) / new_v\n\nprint (res)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN, L = map( int, input().split() )\nT = []\nV = []\nfor i in range( N ):\n  t, v = map( int, input().split() )\n  T.append( t )\n  V.append( v )\n\ndq = deque()\nct, cv = 0.0, 0.0\nfor i in range( N ):\n  while cv + V[ i ] > L:\n    ft, fv = dq[ 0 ]\n    take = min( cv + V[ i ] - L, fv )\n    ct, cv = ( ct * cv - ft * take ) / ( cv - take ), cv - take\n    if take == fv:\n      dq.popleft()\n    else:\n      dq[ 0 ] = [ ft, fv - take ]\n  ct, cv = ( ct * cv + T[ i ] * V[ i ] ) / L, L\n  print( \"%.7f\" % ct )\n  while len( dq ):\n    bt, bv = dq[ len( dq ) - 1 ]\n    if bt < T[ i ]: break\n    T[ i ], V[ i ] = ( T[ i ] * V[ i ] + bt * bv ) / ( V[ i ] + bv ), V[ i ] + bv\n    dq.pop()\n  dq.append( [ T[ i ], V[ i ] ] )"
  },
  {
    "language": "Python",
    "code": "# なんだか釈然としていないが解説の通りに\nfrom collections import deque\nimport sys\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\nclass water:\n    def __init__(self, t, v):\n        self.v = v\n        self.tv = v * t\n\n    def __le__(self, other):\n        return self.v * other.tv - self.tv * other.v >= 0\n\n    def __isub__(self, other):\n        t = self.tv / self.v\n        self.v -= other\n        self.tv = t * self.v\n        return self\n\n    def __iadd__(self, other):\n        self.v+=other.v\n        self.tv+=other.tv\n        return self\n\ndef main():\n    n, l = MI()\n    dam = deque()\n    t, v = MI()\n    print(t)\n    dam.append(water(t, v))\n    # stvはtvの合計（vがlのときのvt）\n    stv = t * v\n    for _ in range(n-1):\n        t, v = MI()\n        # 朝に水をもらう\n        dam.appendleft(water(t, v))\n        over = v\n        stv += t * v\n        # 増えた分の水を古い方から捨てる\n        # ベクトルごと削除できるもの\n        while dam[-1].v <= over:\n            w = dam.pop()\n            over -= w.v\n            stv -= w.tv\n        # 最後のはみ出しているベクトルは縮める\n        stv -= dam[-1].tv  # 一度合計から取り出して\n        dam[-1] -= over  # 縮めて\n        stv += dam[-1].tv  # 元に戻す\n        # その日の水温を出力\n        print(stv / l)\n        # グラフの左側が凹んでいたらベクトルを合成して凸に直す\n        while len(dam)>1 and dam[0] <= dam[1]:\n            w = dam.popleft()\n            dam[0] += w\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN,L = list(map(int,input().split()))\n\nList = []\n########################################\n\nresult = \"\"\n\nt1,v1 = map(int,input().split())\n\nd = deque( [(t1,v1)] )\nnetsuryou = t1*v1\n\nres += str(t1) + \"\\n\"\n\nfor t,v in [ map(int,input().split()) for _ in range(N-1) ]:\n\t\n\tnetsuryou += t*v\n\n\t#右端からvリットル減らす\n\tl = v\n\twhile(l > 0):\n\t\tmigihasi_t,migihasi_v = d.pop()\n\t\tif migihasi_v > l:\n\t\t\tnetsuryou -= migihasi_t*l\n\t\t\td.append( ( migihasi_t,migihasi_v-l ) )\n\t\t\tbreak\n\t\telse:\n\t\t\tl = l - migihasi_v\n\t\t\tnetsuryou -= migihasi_t*migihasi_v\n\n\t#答えを表示\n\tres += str(netsuryou / L) + \"\\n\"\n\n\t#左のほうが温度が低ければ2つを合成\n\tnew_t,new_v = t,v\n\twhile(True):\n\n\t\tif len(d) == 0:\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\thidarihasi_t,hidarihasi_v = d.popleft()\n\n\t\t#条件を満たすならループを抜ける\n\t\tif new_t >= hidarihasi_t:\n\t\t\td.appendleft( (hidarihasi_t,hidarihasi_v) )\n\t\t\td.appendleft( (new_t,new_v) )\n\t\t\tbreak\n\n\t\tnew_v = new_v + hidarihasi_v\n\t\tnew_t = (new_t*new_v + hidarihasi_t*hidarihasi_v) / new_v\n\nprint (res)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nN, L = map(int,input().split())\nq = deque()\nt, v = map(int,input().split())\nq.append((t,v))\nres = \"\"\nres += str(t) + \"\\n\"\nene = t*v\n\nfor que in [map(int,input().split()) for _ in range(N-1)]:\n\tt, v = que\n\trest = v\n\tene += t*v\n\twhile rest > 0:\n\t\tt_, v_ = q.pop()\n\t\tif v_ > rest:\n\t\t\tq.append((t_, v_-rest))\n\t\t\tene -= rest*t_\n\t\t\tbreak\n\t\telse:\n\t\t\trest -= v_\n\t\t\tene -= v_*t_\n\twhile len(q) and t < q[0][0]:\n\t\tt_, v_ = q.popleft()\n\t\tt = (t*v+t_*v_)/(v+v_)\n\t\tv = v+v_\n\tq.appendleft((t,v))\n\t\n\tres += str(ene/L) + \"\\n\"\n\nprint(res)\n\n\n\n\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nfn main() {\n    let (n, l): (usize, usize) = read();\n    let tv: Vec<(f64, usize)> = readn(n);\n\n\n    let mut deq: VecDeque<(f64, usize)> = VecDeque::new();\n    let mut sum = 0;\n    let mut total_value = 0.0;\n    for i in 0..n {\n        while sum + tv[i].1 > l {\n            let (t, v) = deq.pop_front().unwrap();\n            let trash = min(v, sum + tv[i].1 - l);\n            sum -= trash;\n            total_value -= trash as f64 * t;\n            if v - trash >= 1 {\n                deq.push_front((t, v - trash));\n                break\n            }\n        }\n        deq.push_back((tv[i].0, tv[i].1));\n        sum += tv[i].1;\n        total_value += tv[i].0 * tv[i].1 as f64;\n\n        println!(\"{:.12}\", total_value / l as f64);\n\n        while deq.len() >= 2 {\n            let (t0, v0) = deq.pop_back().unwrap();\n            let (t1, v1) = deq.pop_back().unwrap();\n            if t1 <= t0 {\n                deq.push_back((t1, v1));\n                deq.push_back((t0, v0));\n                break\n            }\n            let vf0 = v0 as f64;\n            let vf1 = v1 as f64;\n            deq.push_back(((t0 * vf0 + t1 * vf1) / (vf0 + vf1), v0 + v1));\n        }\n    }\n}"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn get_line() -> String {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().to_string()\n}\n\nfn main() {\n    let nl: Vec<_> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n    let mut q = VecDeque::new();\n    let mut sum = 0f64;\n    let mut nv = 0f64;\n\n    for _ in 0..nl[0] {\n        let tv: Vec<f64> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n        while let Some((t, v)) = q.pop_front() {\n            let mv = if v < nv + tv[1] - nl[1] as f64 {\n                v\n            }\n            else {\n                nv + tv[1] - nl[1] as f64\n            };\n\n            sum = sum * nv - t * mv;\n            nv -= mv;\n            sum /= nv;\n\n            if v > mv {\n                q.push_front((t, v - mv));\n                break;\n            }\n        }\n\n        sum = sum * nv + tv[0] * tv[1];\n        nv += tv[1];\n        sum /= nv;\n\n        println!(\"{:.7}\", sum);\n\n        let mut next = (tv[0], tv[1]);\n        if let Some(&(prev, _)) = q.back() {\n            if prev > tv[0] {\n                if let Some((t, v)) = q.pop_back() {\n                    next = ((t * v + tv[0] * tv[1]) / (v + tv[1]), v + tv[1]);\n                }\n            }\n        }\n\n        q.push_back(next);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        l: f64,\n        tv: [(f64, f64); n],\n    }\n    // Let x be the sum of v for all entry (v, _, _).\n    // An entry (v, p, acc) means\n    // (x - v, acc - p) and (x, acc) are connected by a segment.\n    // We are to find max_y{(f(x) - f(x - y)) / y}.\n    let mut pool: Vec<(f64, f64, f64)> = Vec::new();\n    // Sentinel. l liter of water with temperature -1.0\n    pool.push((l, -1.0, -l));\n    // The pointer is at pool[cur].0 + pos\n    // This pointer should always be at x - l, where x is described above.\n    let mut cur = 0;\n    let mut pos = 0.0;\n    for (t, v) in tv {\n        let mut last = pool[pool.len() - 1].2;\n        pool.push((v, t * v, last + t * v));\n        // Advances pointer by v\n        let mut rem = v;\n        while rem > 0.0 {\n            if pool[cur].0 - pos < rem {\n                rem -= pool[cur].0 - pos;\n                cur += 1;\n                pos = 0.0;\n            } else {\n                pos += rem;\n                break;\n            }\n        }\n        assert!(pos <= pool[cur].0 + 1e-9);\n        // Greedy chmax\n        while pool.len() >= 2 {\n            let (v1, p1, acc1) = pool[pool.len() - 1];\n            if v1 >= l { break; }\n            let (v2, p2, _acc2) = pool[pool.len() - 2];\n            if p2 / v2 > p1 / v1 {\n                pool.pop();\n                pool.pop();\n                if v1 + v2 >= l {\n                    pool.clear();\n                    let newp = p1 + p2 / v2 * (l - v1);\n                    pool.push((l, newp, newp));\n                    // x = l. Pointer's position is reset to 0.0.\n                    cur = 0;\n                    pos = 0.0;\n                } else {\n                    pool.push((v1 + v2, p1 + p2, acc1));\n                    if cur == pool.len() {\n                        cur -= 1;\n                        pos += pool[cur].0;\n                    }\n                }\n            } else { break; }\n        }\n        let (v, p, acc) = pool[cur];\n        let acclast = pool.last().unwrap().2;\n        puts!(\"{:.15}\\n\", (acclast - acc + (p / v) * (v - pos)) / l);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn get_line() -> String {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().to_string()\n}\n\nfn main() {\n    let nl: Vec<_> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n    let mut q = VecDeque::new();\n    let mut sum = 0f64;\n\n    for _ in 0..nl[0] {\n        let tv: Vec<f64> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n        let mut nv = tv[1];\n        while let Some((t, v)) = q.pop_front() {\n            let mv = if v < nv {\n                v\n            }\n            else {\n                nv\n            };\n\n            sum -= t * mv;\n\n            if v >= nv {\n                q.push_front((t, v - nv));\n                break;\n            }\n            else {\n                nv -= v;\n            }\n        }\n\n        sum += tv[0] * tv[1];\n        println!(\"{:.7}\", sum / nl[1] as f64);\n\n        let mut nt = tv[0];\n        let mut nv = tv[1];\n        while let Some(&(t, v)) = q.back() {\n            if t < nt {\n                break;\n            }\n\n            nt = (nt * nv + t * v) / (nv + v);\n            nv += v;\n            q.pop_back();\n        }\n\n        q.push_back((nt, nv));\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn get_line() -> String {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().to_string()\n}\n\nfn main() {\n    let nl: Vec<_> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n    let mut q = VecDeque::new();\n    let mut prev = 0f64;\n    let mut sum = 0f64;\n\n    for _ in 0..nl[0] {\n        let tv: Vec<f64> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n        let mut nv = tv[1];\n\n        sum += tv[0] * tv[1];\n        while let Some((t, v)) = q.pop_front() {\n            if nv >= v {\n                sum -= t * v;\n                nv -= v;\n            }\n            else {\n                sum -= t * nv;\n                q.push_front((t, v - nv));\n\n                break;\n            }\n        }\n\n        let res = sum / nl[1] as f64;\n\n        println!(\"{:.7}\", res);\n\n        prev = if prev <= tv[0] {\n            q.push_back((tv[0], tv[1]));\n\n            tv[0]\n        }\n        else {\n            let (nt, nv) = if let Some((t, v)) = q.pop_back() {\n                ((t * v + tv[0] * tv[1]) / (v + tv[1]), v + tv[1])\n            }\n            else {\n                (tv[0], tv[1])\n            };\n\n            q.push_back((nt, nv));\n\n            nt\n        };\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\nuse std::io::*;\nuse std::str::FromStr;\n\n#[allow(dead_code)]\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\nfn main() {\n    let n = read::<usize>();\n    let l = read::<i64>();\n    let mut tseq = vec![0.0; n];\n    let mut vseq = vec![0; n];\n    for i in 0..n {\n        tseq[i] = read::<f64>();\n        vseq[i] = read::<i64>();\n    }\n    let mut anss = vec![0.0; n];\n    anss[0] = tseq[0];\n    let mut deq = VecDeque::<(f64, i64)>::new();\n    deq.push_back((tseq[0], vseq[0]));\n    let mut total_t = tseq[0] * vseq[0] as f64;\n    for i in 1..n {\n        let mut rest = vseq[i];\n        while rest > 0 {\n            if deq[0].1 <= rest {\n                total_t -= deq[0].0 * deq[0].1 as f64;\n                rest -= deq[0].1;\n                deq.pop_front();\n            } else {\n                total_t -= deq[0].0 * rest as f64;\n                deq[0].1 -= rest;\n                rest = 0;\n            }\n        }\n        let mut t = tseq[i];\n        let mut v = vseq[i];\n        total_t += t * v as f64;\n        while deq.len() > 0 && deq.back().unwrap().0 > t {\n            let (pt, pv) = deq.pop_back().unwrap();\n            t = (pt * pv as f64 + t * v as f64) / (pv + v) as f64;\n            v = pv + v;\n        }\n        deq.push_back((t, v));\n        anss[i] = total_t / l as f64;\n    }\n    for i in 0..n {\n        println!(\"{:.8}\", anss[i]);\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::*;\n\ntype Deq = std::collections::VecDeque<(i64, f64)>;\n\nstruct Solver {\n    deq: Deq,\n    tv: f64,\n    v: i64,\n    up: i64,\n    iu: f64,\n}\n\nimpl Solver {\n    fn new(up: i64) -> Self {\n        Solver {\n            deq: Deq::new(),\n            tv: 0f64,\n            v: 0,\n            up: up,\n            iu: 1.0 / up as f64,\n        }\n    }\n    fn push(&mut self, t: i64, v: i64) {\n        while self.v + v > self.up {\n            let po = self.deq.front_mut().unwrap();\n            if v + v - po.0 >= self.up {\n                self.tv -= po.0 as f64 * po.1;\n                self.v -= po.0;\n                self.deq.pop_front();\n            } else {\n                let sub = po.0 - (self.up - (self.v - po.0) - v);\n                self.tv -= sub as f64 * po.1;\n                self.v -= sub;\n                po.0 -= sub;\n                break;\n            }\n        }\n        let mut t = t as f64;\n        let mut v = v;\n        self.tv += t * v as f64;\n        self.v += v;\n        while self.deq.back().map_or(false, |p| p.1 > t) {\n            let (a, b) = self.deq.pop_back().unwrap();\n            t = (t * v as f64 + b * a as f64) / (v + a) as f64;\n            v += a;\n        }\n        self.deq.push_back((v, t));\n    }\n    fn find(&self) -> f64 {\n        self.tv * self.iu\n    }\n}\n\n#[fastout]\nfn run() {\n    input! {\n        n: usize,\n        w: i64,\n        p: [(i64, i64); n],\n    }\n    let mut solver = Solver::new(w);\n    for (t, v) in p {\n        solver.push(t, v);\n        let ans = solver.find();\n        println!(\"{:.7}\", ans);\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn get_line() -> String {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().to_string()\n}\n\nfn main() {\n    let nl: Vec<usize> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n    let mut p = 0f64;\n    let mut sum = 0f64;\n    let mut q: VecDeque<(f64, f64)> = VecDeque::new();\n\n    for _ in 0..nl[0] {\n        let tv: Vec<f64> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n        sum = calc(sum, tv[1], &mut q) + tv[0] * tv[1];\n\n        let res = sum / nl[1] as f64;\n\n        println!(\"{:.7}\", res);\n\n        p = if p <= tv[0] {\n            if q.is_empty() {\n                q.push_back((tv[0], tv[1]));\n            }\n            else {\n                for i in 0..q.len() {\n                    let i = q.len() - i - 1;\n                    if let Some(&(t, _)) = q.get(i) {\n                        if t < tv[0] {\n                            q.insert(i + 1, (tv[0], tv[1]));\n                            break;\n                        }\n                    }\n                }\n            }\n\n            tv[0]\n        }\n        else {\n            q.clear();\n            q.push_back((res, nl[1] as f64));\n\n            res\n        };\n    }\n}\n\nfn calc(acc_: f64, n_: f64, q: &mut VecDeque<(f64, f64)>) -> f64 {\n    let mut acc = acc_;\n    let mut n = n_;\n    while let Some((t, v)) = q.pop_front() {\n        if n >= v {\n            acc -= t * v;\n            n -= v;\n        }\n        else {\n            acc -= t * n;\n            q.push_front((t, v - n));\n\n            break;\n        }\n    }\n\n    acc\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize,\n        l: f64,\n        tv: [(f64, f64); n],\n    }\n    let mut pool: Vec<(f64, f64, f64)> = Vec::new();\n    let mut cur = 0;\n    let mut pos = -1.0;\n    for (t, v) in tv {\n        let mut last = if pool.len() == 0 { 0.0 } else { pool[pool.len() - 1].2 };\n        pool.push((v, t * v, last + t * v));\n        if pos < 0.0 {\n            pos = 0.0;\n        } else {\n            // progress by v\n            let mut rem = v;\n            while rem > 0.0 {\n                if pool[cur].0 - pos < rem {\n                    rem -= pool[cur].0 - pos;\n                    cur += 1;\n                    pos = 0.0;\n                } else {\n                    pos += rem;\n                    break;\n                }\n            }\n            assert!(pos <= pool[cur].0 + 1e-9);\n        }\n        while pool.len() >= 2 {\n            let (v1, p1, acc1) = pool[pool.len() - 1];\n            if v1 >= l { break; }\n            let (v2, p2, _acc2) = pool[pool.len() - 2];\n            if p2 / v2 > p1 / v1 {\n                pool.pop();\n                pool.pop();\n                if v1 + v2 >= l {\n                    pool.clear();\n                    let pv = p1 + p2 / v2 * (l - v1);\n                    pool.push((l, pv, pv));\n                    cur = 0;\n                    pos = 0.0;\n                } else {\n                    pool.push((v1 + v2, p1 + p2, acc1));\n                    if cur == pool.len() {\n                        cur -= 1;\n                        pos += pool[cur].0;\n                    }\n                }\n            } else { break; }\n        }\n        let (v, p, acc) = pool[cur];\n        let (_, _, acclast) = pool[pool.len() - 1];\n        puts!(\"{:.15}\\n\", (acclast - acc + (p / v) * (v - pos)) / l);\n    }\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::collections::VecDeque;\n\nfn get_line() -> String {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).ok();\n    s.trim().to_string()\n}\n\nfn main() {\n    let nl: Vec<usize> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n    let mut p = 0f64;\n    let mut sum = 0f64;\n    let mut q: VecDeque<(f64, f64)> = VecDeque::new();\n\n    for _ in 0..nl[0] {\n        let tv: Vec<f64> = get_line().split(' ').map(|x| x.parse().unwrap()).collect();\n\n        sum = calc(sum, tv[1], &mut q) + tv[0] * tv[1];\n\n        let res = sum / nl[1] as f64;\n\n        println!(\"{:.7}\", res);\n\n        p = if p <= tv[0] {\n            q.push_back((tv[0], tv[1]));\n\n            tv[0]\n        }\n        else {\n            q.clear();\n            q.push_back((res, nl[1] as f64));\n\n            res\n        };\n    }\n}\n\nfn calc(acc_: f64, n_: f64, q: &mut VecDeque<(f64, f64)>) -> f64 {\n    let mut acc = acc_;\n    let mut n = n_;\n    while let Some((t, v)) = q.pop_front() {\n        if n > v {\n            acc -= t * v;\n            n -= v;\n        }\n        else {\n            acc -= t * n;\n            q.push_front((t, v - n));\n            break;\n        }\n    }\n\n    acc\n}\n"
  },
  {
    "language": "Rust",
    "code": "use proconio::*;\n\ntype Deq = std::collections::VecDeque<(i64, f64)>;\n\nstruct Solver {\n    deq: Deq,\n    tv: f64,\n    v: i64,\n    up: i64,\n    iu: f64,\n}\n\nimpl Solver {\n    fn new(up: i64) -> Self {\n        Solver {\n            deq: Deq::new(),\n            tv: 0f64,\n            v: 0,\n            up: up,\n            iu: 1.0 / up as f64,\n        }\n    }\n    fn push(&mut self, t: i64, v: i64) {\n        while self.v + v > self.up {\n            let po = self.deq.front_mut().unwrap();\n            if self.v + v - po.0 >= self.up {\n                self.tv -= po.0 as f64 * po.1;\n                self.v -= po.0;\n                self.deq.pop_front();\n            } else {\n                let sub = po.0 - (self.up - (self.v - po.0) - v);\n                self.tv -= sub as f64 * po.1;\n                self.v -= sub;\n                po.0 -= sub;\n                break;\n            }\n        }\n        let mut t = t as f64;\n        let mut v = v;\n        self.tv += t * v as f64;\n        self.v += v;\n        while self.deq.back().map_or(false, |p| p.1 > t) {\n            let (a, b) = self.deq.pop_back().unwrap();\n            t = (t * v as f64 + b * a as f64) / (v + a) as f64;\n            v += a;\n        }\n        self.deq.push_back((v, t));\n    }\n    fn find(&self) -> f64 {\n        self.tv * self.iu\n    }\n}\n\n#[fastout]\nfn run() {\n    input! {\n        n: usize,\n        w: i64,\n        p: [(i64, i64); n],\n    }\n    let mut solver = Solver::new(w);\n    for (t, v) in p {\n        solver.push(t, v);\n        let ans = solver.find();\n        println!(\"{:.7}\", ans);\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(unused_imports, unused_variables, dead_code)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\ntrait InputValue {\n    fn parse(s: &str) -> Self;\n}\n\nfn read<T: InputValue>() -> T {\n    let mut buf = String::new();\n    let _ = stdin().read_line(&mut buf);\n    T::parse(&buf.trim())\n}\n\nfn readnc<T: InputValue>() -> Vec<T> {\n    let mut vec = vec![];\n    let line: String = read();\n    for token in line.split_whitespace() {\n        vec.push(T::parse(token));\n    }\n    vec\n}\n\nfn readn<T: InputValue>(n: usize) -> Vec<T> {\n    let mut vec = vec![];\n    for _ in 0..n {\n        vec.push(read());\n    }\n    vec\n}\n\nmacro_rules! parse_single_value {\n    ($($t:ty),*) => {\n        $(\n            impl InputValue for $t {\n                fn parse(s: &str) -> $t { s.parse().unwrap() }\n            }\n        )*\n\t}\n}\nparse_single_value!(i32, i64, f32, f64, usize, String);\n\nmacro_rules! parse_tuple {\n\t($($t:ident),*) => {\n\t\timpl<$($t),*> InputValue for ($($t),*) where $($t: InputValue),* {\n\t\t\tfn parse(s: &str) -> ($($t),*) {\n\t\t\t\tlet mut tokens = s.split_whitespace();\n\t\t\t\tlet t = ($($t::parse(tokens.next().unwrap())),*);\n\t\t\t\tt\n\t\t\t}\n\t\t}\n\t}\n}\nparse_tuple!(A, B);\nparse_tuple!(A, B, C);\n\n// ===\n\nfn main() {\n    let (n, l): (usize, usize) = read();\n    let tv: Vec<(f64, usize)> = readn(n);\n\n\n    let mut deq: VecDeque<(f64, usize)> = VecDeque::new();\n    let mut sum = 0;\n    let mut total_value = 0.0;\n    for i in 0..n {\n        while sum + tv[i].1 > l {\n            let (t, v) = deq.pop_front().unwrap();\n            let trash = min(v, sum + tv[i].1 - l);\n            sum -= trash;\n            total_value -= trash as f64 * t;\n            if v - trash >= 1 {\n                deq.push_front((t, v - trash));\n                break\n            }\n        }\n        deq.push_back((tv[i].0, tv[i].1));\n        sum += tv[i].1;\n        total_value += tv[i].0 * tv[i].1 as f64;\n\n        println!(\"{:.12}\", total_value / l);\n\n        while deq.len() >= 2 {\n            let (t0, v0) = deq.pop_back().unwrap();\n            let (t1, v1) = deq.pop_back().unwrap();\n            if t1 <= t0 {\n                deq.push_back((t1, v1));\n                deq.push_back((t0, v0));\n                break\n            }\n            let vf0 = v0 as f64;\n            let vf1 = v1 as f64;\n            deq.push_back(((t0 * vf0 + t1 * vf1) / (vf0 + vf1), v0 + v1));\n        }\n    }\n}"
  }
]