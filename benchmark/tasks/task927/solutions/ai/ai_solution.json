[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <float.h>\n#include <math.h>\n\n#define EPSILON 1e-6\n\ntypedef struct {\n    int volume;\n    double temperature;\n} WaterInput;\n\ndouble maximize_temperature(int L, WaterInput* inputs, int n) {\n    double low = -DBL_MAX, high = DBL_MAX;\n    \n    for (int day = 0; day < n; day++) {\n        double curr_vol = inputs[day].volume;\n        double curr_temp = inputs[day].temperature;\n        \n        double low_discharge = 0, high_discharge = curr_vol;\n        \n        while (high_discharge - low_discharge > EPSILON) {\n            double mid_discharge = (low_discharge + high_discharge) / 2.0;\n            double remaining_vol = curr_vol - mid_discharge;\n            \n            if (remaining_vol + mid_discharge <= L) {\n                double avg_temp = (curr_vol * curr_temp - mid_discharge * curr_temp) / remaining_vol;\n                \n                if (avg_temp > low) {\n                    low = avg_temp;\n                }\n                \n                low_discharge = mid_discharge;\n            } else {\n                high_discharge = mid_discharge;\n            }\n        }\n    }\n    \n    return low;\n}\n\nint main() {\n    int L, n;\n    scanf(\"%d %d\", &L, &n);\n    \n    WaterInput* inputs = malloc(n * sizeof(WaterInput));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %lf\", &inputs[i].volume, &inputs[i].temperature);\n    }\n    \n    double result = maximize_temperature(L, inputs, n);\n    \n    printf(\"%.6f\\n\", result);\n    \n    free(inputs);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double volume;\n    double temperature;\n} Water;\n\nint main() {\n    int N;\n    double L;\n    scanf(\"%d %lf\", &N, &L);\n    \n    double *V = (double *)malloc(N * sizeof(double));\n    double *T = (double *)malloc(N * sizeof(double));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf %lf\", &V[i], &T[i]);\n    }\n    \n    Water *dam = (Water *)malloc(N * sizeof(Water));\n    int size = 0;\n    \n    for (int day = 0; day < N; day++) {\n        double incoming_vol = V[day];\n        double incoming_temp = T[day];\n        \n        // Add incoming water to the dam\n        Water new_water = {incoming_vol, incoming_temp};\n        dam[size++] = new_water;\n        \n        // Merge segments to maintain non-increasing temperature order\n        while (size >= 2 && dam[size-1].temperature > dam[size-2].temperature) {\n            Water last = dam[size-1];\n            Water prev = dam[size-2];\n            \n            double total_vol = last.volume + prev.volume;\n            double mixed_temp = (last.volume * last.temperature + prev.volume * prev.temperature) / total_vol;\n            \n            dam[size-2].volume = total_vol;\n            dam[size-2].temperature = mixed_temp;\n            size--;\n        }\n        \n        // Calculate total volume\n        double total_vol = 0.0;\n        for (int i = 0; i < size; i++) {\n            total_vol += dam[i].volume;\n        }\n        \n        // Discharge excess water from the start (coldest part)\n        double excess = total_vol - L;\n        if (excess > 0) {\n            int i = 0;\n            while (excess > 0 && i < size) {\n                if (dam[i].volume <= excess) {\n                    excess -= dam[i].volume;\n                    i++;\n                } else {\n                    dam[i].volume -= excess;\n                    excess = 0;\n                }\n            }\n            \n            // Shift remaining segments\n            for (int j = 0; j < size - i; j++) {\n                dam[j] = dam[j + i];\n            }\n            size -= i;\n        }\n        \n        // Calculate average temperature\n        double total_heat = 0.0;\n        double current_vol = 0.0;\n        for (int i = 0; i < size; i++) {\n            total_heat += dam[i].volume * dam[i].temperature;\n            current_vol += dam[i].volume;\n        }\n        double avg_temp = total_heat / current_vol;\n        \n        printf(\"%.7lf\\n\", avg_temp);\n    }\n    \n    free(V);\n    free(T);\n    free(dam);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:22:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n    vector<int> v(N), t(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> v[i] >> t[i];\n    }\n\n    vector<double> max_temp(N);\n    vector<double> current_vol;\n    vector<double> current_temp;\n\n    for (int day = 0; day < N; ++day) {\n        // Add today's water\n        current_vol.push_back(v[day]);\n        current_temp.push_back(t[day]);\n\n        // Merge from the end to keep temperatures non-increasing\n        while (current_vol.size() >= 2 && current_temp.back() <= current_temp[current_temp.size() - 2]) {\n            int last = current_vol.size() - 1;\n            double merged_vol = current_vol[last] + current_vol[last - 1];\n            double merged_temp = (current_vol[last] * current_temp[last] + current_vol[last - 1] * current_temp[last - 1]) / merged_vol;\n            current_vol[last - 1] = merged_vol;\n            current_temp[last - 1] = merged_temp;\n            current_vol.pop_back();\n            current_temp.pop_back();\n        }\n\n        // Calculate total volume\n        double total_vol = 0;\n        for (double vol : current_vol) {\n            total_vol += vol;\n        }\n\n        // Discharge excess water from the beginning (coldest)\n        double remaining = L;\n        double weighted_sum = 0;\n        for (int i = 0; i < current_vol.size(); ++i) {\n            if (current_vol[i] <= remaining) {\n                weighted_sum += current_vol[i] * current_temp[i];\n                remaining -= current_vol[i];\n            } else {\n                weighted_sum += remaining * current_temp[i];\n                remaining = 0;\n                break;\n            }\n        }\n        max_temp[day] = weighted_sum / L;\n\n        // Update current_vol and current_temp for the next day (after discharge)\n        remaining = L;\n        vector<double> new_vol, new_temp;\n        for (int i = 0; i < current_vol.size(); ++i) {\n            if (current_vol[i] <= remaining) {\n                new_vol.push_back(current_vol[i]);\n                new_temp.push_back(current_temp[i]);\n                remaining -= current_vol[i];\n            } else {\n                if (remaining > 0) {\n                    new_vol.push_back(remaining);\n                    new_temp.push_back(current_temp[i]);\n                    remaining = 0;\n                }\n                break;\n            }\n        }\n        current_vol = new_vol;\n        current_temp = new_temp;\n    }\n\n    cout << fixed << setprecision(10);\n    for (double temp : max_temp) {\n        cout << temp << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DamTemperature {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int L = scanner.nextInt();\n        int[] a = new int[N];\n        int[] t = new int[N];\n        for (int i = 0; i < N; i++) {\n            a[i] = scanner.nextInt();\n            t[i] = scanner.nextInt();\n        }\n\n        List<Double> res = new ArrayList<>();\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        long sumVolume = 0;\n        long sumTempVolume = 0;\n\n        for (int i = 0; i < N; i++) {\n            maxHeap.add(t[i]);\n            sumVolume += a[i];\n            sumTempVolume += (long) t[i] * a[i];\n\n            while (sumVolume > L) {\n                int maxT = maxHeap.poll();\n                long diff = sumVolume - L;\n                sumVolume -= diff;\n                sumTempVolume -= (long) maxT * diff;\n            }\n\n            double avgTemp = (double) sumTempVolume / L;\n            res.add(avgTemp);\n        }\n\n        for (double temp : res) {\n            System.out.printf(\"%.6f\\n\", temp);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:23:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class DamManagement {\n    public static void solve(InputReader in, PrintWriter out) {\n        int n = in.nextInt();  // number of days\n        int L = in.nextInt();  // dam capacity\n        \n        double[] inflow = new double[n];\n        double[] temp = new double[n];\n        \n        for (int i = 0; i < n; i++) {\n            inflow[i] = in.nextDouble();\n            temp[i] = in.nextDouble();\n        }\n        \n        double[] maxTemp = new double[n];\n        \n        for (int i = 0; i < n; i++) {\n            double totalVolume = inflow[i];\n            double totalHeat = inflow[i] * temp[i];\n            \n            // Try discharging different amounts to maximize temperature\n            for (double discharge = 0; discharge <= L; discharge++) {\n                double remainingVolume = totalVolume - discharge;\n                \n                if (remainingVolume < 0 || remainingVolume > L) continue;\n                \n                double remainingHeat = totalHeat - discharge * \n                    (totalHeat / totalVolume);\n                \n                double currentTemp = remainingHeat / remainingVolume;\n                \n                maxTemp[i] = Math.max(maxTemp[i], currentTemp);\n            }\n        }\n        \n        // Output results with precision limit\n        for (double t : maxTemp) {\n            out.printf(\"%.6f\\n\", t);\n        }\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        solve(in, out);\n        out.close();\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:23:43"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N, L;\n    cin >> N >> L;\n\n    vector<int> inflow_volume(N);\n    vector<int> inflow_temp(N);\n\n    for (int i = 0; i < N; i++) {\n        cin >> inflow_volume[i] >> inflow_temp[i];\n    }\n\n    vector<double> max_temps(N);\n\n    for (int day = 0; day < N; day++) {\n        double max_temp = 0.0;\n\n        for (int discharge = 0; discharge <= L; discharge++) {\n            int remain_volume = L - discharge;\n            if (remain_volume < inflow_volume[day]) continue;\n\n            double temp = (remain_volume > 0) ? \n                ((remain_volume - inflow_volume[day]) * \n                (day > 0 ? max_temps[day-1] : 0.0) + \n                inflow_volume[day] * inflow_temp[day]) / remain_volume : \n                inflow_temp[day];\n\n            max_temp = max(max_temp, temp);\n        }\n\n        max_temps[day] = max_temp;\n    }\n\n    cout << fixed << setprecision(6);\n    for (double temp : max_temps) {\n        cout << temp << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_temperature_in_dam(daily_inflows, L):\n    results = []\n    current_water_volume = 0.0\n    current_weighted_temp_sum = 0.0\n\n    for inflow_volume, inflow_temp in daily_inflows:\n        # Update dam state each morning with inflow\n        current_water_volume += inflow_volume\n        current_weighted_temp_sum += inflow_volume * inflow_temp\n        \n        # Calculate final temperature and adjust volume to L at noon\n        if current_water_volume > L:\n            # Discharge water\n            excess_volume = current_water_volume - L\n            # Compute discharge weighted temperature\n            discharge_temp_sum = (current_weighted_temp_sum - L * inflow_temp) / (current_water_volume - L)\n            current_weighted_temp_sum -= excess_volume * discharge_temp_sum\n            current_water_volume = L\n        \n        # New temperature at noon\n        noon_temperature = current_weighted_temp_sum / current_water_volume\n        results.append(noon_temperature)\n\n    return results\n\n# Example usage\ndaily_inflows = [(100, 15.0), (150, 20.0), (200, 25.0), (50, 30.0)]\nL = 250\nprint(max_temperature_in_dam(daily_inflows, L))",
    "timestamp": "2025-08-13 15:03:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class DamManagement {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        double capacity = scanner.nextDouble();\n        int days = scanner.nextInt();\n\n        double[] inflowVolume = new double[days];\n        double[] inflowTemperature = new double[days];\n\n        for (int i = 0; i < days; i++) {\n            inflowVolume[i] = scanner.nextDouble();\n            inflowTemperature[i] = scanner.nextDouble();\n        }\n\n        double currentVolume = 0.0;\n        double currentTemperature = 0.0;\n\n        for (int i = 0; i < days; i++) {\n            double dailyInflow = inflowVolume[i];\n            double dailyTemp = inflowTemperature[i];\n\n            double newVolume = currentVolume + dailyInflow;\n\n            double mixedTemperature = (currentVolume * currentTemperature + dailyInflow * dailyTemp) / newVolume;\n\n            if (newVolume > capacity) {\n                double excessVolume = newVolume - capacity;\n                double excessFraction = excessVolume / newVolume;\n\n                mixedTemperature = mixedTemperature * (1 - excessFraction) \n                    + dailyTemp * excessFraction;\n                newVolume = capacity;\n            }\n\n            currentVolume = newVolume;\n            currentTemperature = mixedTemperature;\n\n            System.out.printf(\"%.6f\\n\", currentTemperature);\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 15:03:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\n#define MAX_DAYS 1000\n\nstruct Water {\n    double volume;\n    double temperature;\n};\n\nint main() {\n    int n; // number of days\n    double L; // capacity of the dam\n    struct Water inflow[MAX_DAYS];\n    \n    // Read the dam capacity L and number of days n\n    scanf(\"%lf %d\", &L, &n);\n    \n    // Read the inflow data for each day\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &inflow[i].volume, &inflow[i].temperature);\n    }\n\n    double current_volume = 0.0;\n    double current_temperature = 0.0;\n\n    // Simulate each day\n    for (int i = 0; i < n; i++) {\n        current_volume += inflow[i].volume;\n        \n        // Calculate new temperature\n        double new_temperature = (current_temperature * current_volume +\n                                  inflow[i].temperature * inflow[i].volume) /\n                                 (current_volume + inflow[i].volume);\n        \n        // If overflowing, adjust discharge\n        if (current_volume > L) {\n            current_volume -= (current_volume - L);\n        }\n        \n        current_temperature = new_temperature;\n        \n        // Calculate maximum temperature for exactly L liters at noon\n        double max_temperature = (current_temperature * current_volume +\n                                  (L - current_volume) * inflow[i].temperature) / L;\n                                  \n        printf(\"%.6lf\\n\", max_temperature);\n        \n        // Set current volume to L liters for the next day's calculation\n        current_volume = L;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:03:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\nusing namespace std;\n\nstruct Water {\n    double volume;\n    double temperature;\n};\n\nint main() {\n    int n; // number of days\n    double L; // capacity of the dam\n    cin >> n >> L;\n\n    vector<Water> inflow(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> inflow[i].volume >> inflow[i].temperature;\n    }\n    \n    vector<double> maxTemps(n, 0.0);\n    double currentVolume = 0.0;\n    double currentTemperature = 0.0;\n\n    for (int day = 0; day < n; ++day) {\n        double morningVolume = inflow[day].volume;\n        double morningTemperature = inflow[day].temperature;\n        \n        // Update current volume and temperature with morning inflow\n        currentVolume += morningVolume;\n        currentTemperature = \n            (currentTemperature * (currentVolume - morningVolume) + morningTemperature * morningVolume) \n            / currentVolume;\n\n        // Calculate discharge to have exactly L liters at noon\n        double dischargeAmount = currentVolume - L;\n        if (dischargeAmount > 0) {\n            currentVolume -= dischargeAmount;\n            // No need to change current temperature as it's same water\n        }\n            \n        // Register the maximum temperature at noon\n        maxTemps[day] = currentTemperature;\n    }\n\n    for (double temp : maxTemps) {\n        cout << fixed << setprecision(6) << temp << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:03:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_temperature(L, flows):\n    result = []\n    current_volume = 0\n    current_temp = 0\n\n    for volume, temp in flows:\n        # Add new water to the dam\n        if current_volume > 0:\n            current_temp = (current_volume * current_temp + volume * temp) / (current_volume + volume)\n            current_volume += volume\n        else:\n            current_volume = volume\n            current_temp = temp\n\n        # If dam is overfull, optimize discharge\n        if current_volume > L:\n            max_temp = float('-inf')\n            for discharge in range(current_volume - L + 1):\n                # Calculate temperature after discharge\n                remaining_volume = current_volume - discharge\n                if remaining_volume == L:\n                    remaining_temp = (current_volume * current_temp - discharge * current_temp) / remaining_volume\n                    max_temp = max(max_temp, remaining_temp)\n\n            result.append(round(max_temp, 6))\n            current_volume = L\n            current_temp = max_temp\n        else:\n            result.append(round(current_temp, 6))\n\n    return result",
    "timestamp": "2025-08-13 15:03:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    N, L = map(int, data[idx:idx+2])\n    idx +=2\n    A = list(map(int, data[idx:idx+N]))\n    idx +=N\n    T = list(map(int, data[idx:idx+N]))\n    \n    res = []\n    total_volume = 0\n    total_heat = 0.0\n    min_heap = []\n    \n    for i in range(N):\n        a = A[i]\n        t = T[i]\n        # Add current day's water\n        total_volume += a\n        total_heat += a * t\n        heapq.heappush(min_heap, (t, a))\n        \n        # Remove coldest water until total_volume <= L\n        while total_volume > L:\n            coldest_t, coldest_a = heapq.heappop(min_heap)\n            remove = min(coldest_a, total_volume - L)\n            total_volume -= remove\n            total_heat -= remove * coldest_t\n            if coldest_a > remove:\n                heapq.heappush(min_heap, (coldest_t, coldest_a - remove))\n        \n        # Calculate average temperature\n        avg_temp = total_heat / L\n        res.append(avg_temp)\n    \n    print('\\n'.join(map(lambda x: \"{0:.6f}\".format(x), res)))\n\nsolve()",
    "timestamp": "2025-08-13 15:03:28"
  }
]