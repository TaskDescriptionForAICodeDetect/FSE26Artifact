[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAX_N 100\n#define MAX_M 100\n\nint board[MAX_N + 2][MAX_M + 2];\nint tempBoard[MAX_N + 2][MAX_M + 2];\n\nvoid resetBoard(int N, int M) {\n    for (int i = 0; i <= N + 1; i++) {\n        for (int j = 0; j <= M + 1; j++) {\n            board[i][j] = (i == 0 || i == N + 1 || j == 0 || j == M + 1) ? 1 : 0;\n        }\n    }\n}\n\nvoid movePersons(int N, int M, char *A, char *B, char *C, char *D) {\n    int dx[4] = {0, 1, 0, -1};\n    int dy[4] = {1, 0, -1, 0};\n    char *dirs[4] = {A, B, C, D};\n    \n    for (int k = 0; k < 4; k++) {\n        int x = 0, y = 0;\n        int dir = k;\n        \n        switch(k) {\n            case 0: x = 1; break;\n            case 1: y = M + 1; break;\n            case 2: x = N + 1; break;\n            case 3: y = 1; break;\n        }\n        \n        for (int i = 0; dirs[k][i]; i++) {\n            int nx = x + dx[dir];\n            int ny = y + dy[dir];\n            \n            if (board[nx][ny] == 1) {\n                switch(dirs[k][i]) {\n                    case 'L': dir = (dir - 1 + 4) % 4; break;\n                    case 'R': dir = (dir + 1) % 4; break;\n                }\n            } else {\n                board[nx][ny] = 1;\n                x = nx;\n                y = ny;\n            }\n        }\n    }\n}\n\nint countDifferentStates(int N, int M) {\n    int states = 1;\n    \n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            if (board[i][j] != tempBoard[i][j]) {\n                states = (states * 2) % MOD;\n                break;\n            }\n        }\n    }\n    \n    return states;\n}\n\nint main() {\n    int N, M;\n    char A[MAX_M + 1], B[MAX_M + 1], C[MAX_M + 1], D[MAX_M + 1];\n    \n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%s %s %s %s\", A, B, C, D);\n    \n    resetBoard(N, M);\n    memcpy(tempBoard, board, sizeof(board));\n    \n    movePersons(N, M, A, B, C, D);\n    \n    int result = countDifferentStates(N, M);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#define MOD 998244353\n\nint N, M;\nchar A[200002], B[200002], C[200002], D[200002];\nint dp[2][2][2][2];\n\nvoid solve() {\n    scanf(\"%d %d\", &N, &M);\n    scanf(\"%s %s %s %s\", A, B, C, D);\n\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0] = 1;\n\n    for (int i = 0; i <= N + 1; ++i) {\n        for (int j = 0; j <= M + 1; ++j) {\n            int new_dp[2][2][2][2];\n            memset(new_dp, 0, sizeof(new_dp));\n            for (int a = 0; a < 2; ++a) {\n                for (int b = 0; b < 2; ++b) {\n                    for (int c = 0; c < 2; ++c) {\n                        for (int d = 0; d < 2; ++d) {\n                            if (!dp[a][b][c][d]) continue;\n                            int current = dp[a][b][c][d];\n                            if (i == 0 || i == N + 1 || j == 0 || j == M + 1) {\n                                // Edge squares are black, no change\n                                new_dp[a][b][c][d] = (new_dp[a][b][c][d] + current) % MOD;\n                            } else {\n                                int new_a = a, new_b = b, new_c = c, new_d = d;\n                                if (i == 1 && A[j-1] == 'R') new_a = 1;\n                                if (i == N && B[j-1] == 'L') new_b = 1;\n                                if (j == 1 && C[i-1] == 'D') new_c = 1;\n                                if (j == M && D[i-1] == 'U') new_d = 1;\n                                if (new_a || new_b || new_c || new_d) {\n                                    new_dp[new_a][new_b][new_c][new_d] = (new_dp[new_a][new_b][new_c][new_d] + current) % MOD;\n                                } else {\n                                    new_dp[a][b][c][d] = (new_dp[a][b][c][d] + current) % MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            memcpy(dp, new_dp, sizeof(dp));\n        }\n    }\n\n    int result = 0;\n    for (int a = 0; a < 2; ++a) {\n        for (int b = 0; b < 2; ++b) {\n            for (int c = 0; c < 2; ++c) {\n                for (int d = 0; d < 2; ++d) {\n                    result = (result + dp[a][b][c][d]) % MOD;\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", result);\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    string A, B, C, D;\n    cin >> N >> M >> A >> B >> C >> D;\n\n    vector<vector<int>> dp(N + 1, vector<int>(M + 1, 0));\n    dp[0][0] = 1;\n\n    for (int i = 0; i <= N; ++i) {\n        for (int j = 0; j <= M; ++j) {\n            if (i == 0 && j == 0) continue;\n            int res = 0;\n            if (i > 0) {\n                char c = (j == 0) ? B[i - 1] : (j == M) ? D[i - 1] : '?';\n                if (c != 'R') res = (res + dp[i - 1][j]) % MOD;\n            }\n            if (j > 0) {\n                char c = (i == 0) ? A[j - 1] : (i == N) ? C[j - 1] : '?';\n                if (c != 'D') res = (res + dp[i][j - 1]) % MOD;\n            }\n            dp[i][j] = res;\n        }\n    }\n\n    cout << dp[N][M] << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:15:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        String A = sc.next();\n        String B = sc.next();\n        String C = sc.next();\n        String D = sc.next();\n\n        int[][][][] dp = new int[N + 1][M + 1][2][2];\n        dp[0][0][0][0] = 1;\n\n        for (int i = 0; i <= N; i++) {\n            for (int j = 0; j <= M; j++) {\n                for (int s = 0; s < 2; s++) {\n                    for (int t = 0; t < 2; t++) {\n                        if (dp[i][j][s][t] == 0) continue;\n                        if (i < N) {\n                            int newS = s;\n                            if (j == 0 && A.charAt(i) == '<') newS = 1;\n                            if (j == M && B.charAt(i) == '>') newS = 1;\n                            dp[i + 1][j][newS][t] = (dp[i + 1][j][newS][t] + dp[i][j][s][t]) % MOD;\n                        }\n                        if (j < M) {\n                            int newT = t;\n                            if (i == 0 && C.charAt(j) == '^') newT = 1;\n                            if (i == N && D.charAt(j) == 'v') newT = 1;\n                            dp[i][j + 1][s][newT] = (dp[i][j + 1][s][newT] + dp[i][j][s][t]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        int res = 0;\n        for (int s = 0; s < 2; s++) {\n            for (int t = 0; t < 2; t++) {\n                res = (res + dp[N][M][s][t]) % MOD;\n            }\n        }\n        System.out.println(res);\n    }\n}",
    "timestamp": "2025-08-05 23:16:00"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class RingoArt {\n    static final int MOD = 998244353;\n    static int N, M;\n    static char[][] board;\n    static int[] dx = {0, 1, 0, -1};\n    static int[] dy = {1, 0, -1, 0};\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        \n        String[] inputs = new String[4];\n        for (int i = 0; i < 4; i++) {\n            inputs[i] = br.readLine();\n        }\n        \n        int result = solve(inputs);\n        System.out.println(result);\n    }\n    \n    static int solve(String[] inputs) {\n        Set<String> uniqueStates = new HashSet<>();\n        \n        for (int mask = 0; mask < (1 << 4); mask++) {\n            board = new char[N+2][M+2];\n            for (int i = 0; i <= N+1; i++) {\n                for (int j = 0; j <= M+1; j++) {\n                    board[i][j] = (i == 0 || i == N+1 || j == 0 || j == M+1) ? 'B' : 'W';\n                }\n            }\n            \n            for (int i = 0; i < 4; i++) {\n                if ((mask & (1 << i)) != 0) {\n                    paint(inputs[i], i);\n                }\n            }\n            \n            uniqueStates.add(boardToString());\n        }\n        \n        return uniqueStates.size() % MOD;\n    }\n    \n    static void paint(String input, int dir) {\n        int[] start = getStartPosition(dir);\n        int x = start[0], y = start[1];\n        \n        for (char c : input.toCharArray()) {\n            int steps = c - '0';\n            for (int i = 0; i < steps; i++) {\n                x += dx[dir];\n                y += dy[dir];\n                \n                if (x < 1 || x > N || y < 1 || y > M) break;\n                if (board[x][y] == 'B') break;\n                board[x][y] = 'P';\n            }\n        }\n    }\n    \n    static int[] getStartPosition(int dir) {\n        switch (dir) {\n            case 0: return new int[]{0, 1};\n            case 1: return new int[]{1, 0};\n            case 2: return new int[]{N+1, M};\n            default: return new int[]{N, M+1};\n        }\n    }\n    \n    static String boardToString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= M; j++) {\n                sb.append(board[i][j]);\n            }\n        }\n        return sb.toString();\n    }\n}",
    "timestamp": "2025-08-05 23:16:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAX_N = 52;\n\nint n, m;\nint board[MAX_N][MAX_N];\nvector<pair<int, int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nvoid simulate(int x, int y, int dx, int dy) {\n    while (board[x][y] == 0) {\n        board[x][y] = 1;\n        x += dx;\n        y += dy;\n    }\n}\n\nint solve(string A, string B, string C, string D) {\n    int result = 0;\n    \n    for (int state = 0; state < (1 << 4); state++) {\n        memset(board, 0, sizeof(board));\n        \n        // Paint black border\n        for (int i = 0; i < n + 2; i++) {\n            board[i][0] = board[i][m + 1] = 2;\n            board[0][i] = board[n + 1][i] = 2;\n        }\n        \n        // Place people and paint\n        if (state & 1) simulate(1, 1, dirs[0].first, dirs[0].second);\n        if (state & 2) simulate(1, m, dirs[1].first, dirs[1].second);\n        if (state & 4) simulate(n, 1, dirs[2].first, dirs[2].second);\n        if (state & 8) simulate(n, m, dirs[3].first, dirs[3].second);\n        \n        bool unique = true;\n        for (int prev = 0; prev < state; prev++) {\n            bool match = true;\n            for (int i = 0; i < n + 2; i++) {\n                for (int j = 0; j < m + 2; j++) {\n                    if (board[i][j] != ((state >> prev) & 1 ? board[i][j] : 0)) {\n                        match = false;\n                        break;\n                    }\n                }\n                if (!match) break;\n            }\n            if (match) {\n                unique = false;\n                break;\n            }\n        }\n        \n        if (unique) result++;\n    }\n    \n    return result % MOD;\n}\n\nint main() {\n    cin >> n >> m;\n    string A, B, C, D;\n    cin >> A >> B >> C >> D;\n    \n    cout << solve(A, B, C, D) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:16:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_final_states(N, M, A, B, C, D):\n    MOD = 998244353\n    \n    # Function to simulate painting based on a given starting side string\n    def simulate(arr, N, M, is_horizontal):\n        painted_set = set()\n        for i, ch in enumerate(arr):\n            # Calculate initial position based on direction\n            if is_horizontal:\n                y, x = (0, i + 1) if ch == '>' else (N + 1, i + 1)\n            else:\n                y, x = (i + 1, 0) if ch == 'v' else (i + 1, M + 1)\n\n            # Move and paint white squares until a non-white square is encountered\n            while 0 <= y < N + 2 and 0 <= x < M + 2 and (y, x) not in painted_set:\n                painted_set.add((y, x))\n                if is_horizontal:\n                    x += 1 if ch == '>' else -1\n                else:\n                    y += 1 if ch == 'v' else -1\n        \n        return painted_set\n\n    # Simulate movements from each side\n    top_painted = simulate(A, N, M, True)\n    bottom_painted = simulate(B, N, M, True)\n    left_painted = simulate(C, N, M, False)\n    right_painted = simulate(D, N, M, False)\n\n    # Combine all painted sets\n    all_painted = top_painted | bottom_painted | left_painted | right_painted\n\n    # Calculate number of different final painted states\n    total_states = 1 << len(all_painted)  # 2^number_of_painted_squares\n\n    return total_states % MOD\n\n# Example usage:\nprint(calculate_final_states(N=1, M=1, A='>', B='<', C='v', D='^'))",
    "timestamp": "2025-08-13 14:15:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class ModernArt {\n\n    static int mod = 998244353;\n\n    public static int numberOfFinalPaintedStates(int N, int M, String A, String B, String C, String D) {\n        Set<Long> uniqueStates = new HashSet<>();\n\n        int[][] board = new int[N + 2][M + 2];\n        for (int i = 0; i < N + 2; i++) {\n            board[i][0] = 1;\n            board[i][M + 1] = 1;\n        }\n        for (int j = 0; j < M + 2; j++) {\n            board[0][j] = 1;\n            board[N + 1][j] = 1;\n        }\n\n        placePeople(A, board, 0, 1, 0, N + 2, 1, 0); // Top edge\n        placePeople(B, board, N + 1, M, 0, N + 2, -1, 0); // Bottom edge\n        placePeople(C, board, 1, 0, 0, M + 2, 0, 1); // Left edge\n        placePeople(D, board, M + 1, N, 0, M + 2, 0, -1); // Right edge\n\n        return uniqueStates.size();\n    }\n\n    private static void placePeople(String input, int[][] board, int startRow, int startCol, int edgeX,\n            int edgeY, int dx, int dy) {\n        for (char direction : input.toCharArray()) {\n            int x = startRow;\n            int y = startCol;\n            while (board[x + dx][y + dy] == 0) {\n                x += dx;\n                y += dy;\n                board[x][y] = 1;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        int N = 3, M = 4;\n        String A = \"RDLU\";\n        String B = \"UDLR\";\n        String C = \"LU\";\n        String D = \"RD\";\n\n        System.out.println(numberOfFinalPaintedStates(N, M, A, B, C, D));\n    }\n}",
    "timestamp": "2025-08-13 14:16:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n\nint N, M;\nchar **board;\n\nvoid moveAndPaint(char *commands, int startRow, int startCol, int dr, int dc) {\n    for (int i = 0; i < strlen(commands); i++) {\n        char dir = commands[i];\n        while (board[startRow][startCol] == 'W') {\n            board[startRow][startCol] = 'P'; // Paint the square\n            switch (dir) {\n                case 'L': startCol += dc; break;\n                case 'R': startCol -= dc; break;\n                case 'U': startRow -= dr; break;\n                case 'D': startRow += dr; break;\n            }\n        }\n    }\n}\n\nlong long hashBoard() {\n    long long hash = 0;\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= M; j++) {\n            hash = (hash * 31 + board[i][j]) % MOD;\n        }\n    }\n    return hash;\n}\n\nint main() {\n    scanf(\"%d%d\", &N, &M);\n    \n    board = (char**)malloc((N + 2) * sizeof(char*));\n    for (int i = 0; i < N + 2; i++) {\n        board[i] = (char*)malloc((M + 2) * sizeof(char));\n        for (int j = 0; j < M + 2; j++) {\n            board[i][j] = (i == 0 || i == N + 1 || j == 0 || j == M + 1) ? 'B' : 'W';\n        }\n    }\n    \n    char A[1001], B[1001], C[1001], D[1001];\n    scanf(\"%s%s%s%s\", A, B, C, D);\n    \n    moveAndPaint(A, 1, 1, 0, 1); // Top edge\n    moveAndPaint(B, N, 1, 0, 1); // Bottom edge\n    moveAndPaint(C, 1, 1, 1, 0); // Left edge\n    moveAndPaint(D, 1, M, 1, 0); // Right edge\n    \n    printf(\"%lld\\n\", hashBoard());\n    \n    for (int i = 0; i < N + 2; i++) free(board[i]);\n    free(board);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:16:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function finalPaintedStates(N, M, A, B, C, D) {\n    const MOD = 998244353;\n    \n    // Function to simulate the movement and painting on the board\n    function simulatePainting(board, dir, x, y, index) {\n        const directions = { 'N': [-1, 0], 'E': [0, 1], 'S': [1, 0], 'W': [0, -1] };\n        const move = directions[dir];\n        while (x >= 1 && y >= 1 && x <= N && y <= M && board[x][y] === 'W') {\n            board[x][y] = index;\n            x += move[0];\n            y += move[1];\n        }\n    }\n\n    // Initialize the board with white squares\n    let board = Array.from({ length: N+2 }, () => Array(M+2).fill('W'));\n\n    // Paint the edges black\n    for (let i = 0; i < N+2; i++) {\n        board[i][0] = 'B';\n        board[i][M+1] = 'B';\n    }\n    for (let j = 0; j < M+2; j++) {\n        board[0][j] = 'B';\n        board[N+1][j] = 'B';\n    }\n    \n    // Simulate based on inputs A, B, C, D\n    for (let i = 0; i < A.length; i++) simulatePainting(board, A[i], 1, i+1, 'A'+i);\n    for (let i = 0; i < B.length; i++) simulatePainting(board, B[i], i+1, M, 'B'+i);\n    for (let i = 0; i < C.length; i++) simulatePainting(board, C[i], N, M-i, 'C'+i);\n    for (let i = 0; i < D.length; i++) simulatePainting(board, D[i], N-i, 1, 'D'+i);\n\n    // Set to store unique board states\n    const states = new Set();\n\n    // Function to convert board into a string representation\n    function boardToString() {\n        return board.map(row => row.join('')).join('');\n    }\n\n    // Recursive function to generate all possible states\n    function generateStates(x, y, currentBoard) {\n        if (x > N) {\n            states.add(boardToString());\n            return;\n        }\n        if (y > M) {\n            generateStates(x + 1, 1, currentBoard);\n            return;\n        }\n        if (currentBoard[x][y] === 'W') {\n            generateStates(x, y + 1, currentBoard);\n        } else {\n            const savedValue = currentBoard[x][y];\n            currentBoard[x][y] = 'W';\n            generateStates(x, y + 1, currentBoard);\n            currentBoard[x][y] = savedValue;\n            generateStates(x, y + 1, currentBoard);\n        }\n    }\n    \n    // Copy board and start generating states\n    let initialBoard = board.map(row => row.slice());\n    generateStates(1, 1, initialBoard);\n\n    return states.size % MOD;\n}",
    "timestamp": "2025-08-13 14:16:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, M, A, B, C, D):\n    MOD = 998244353\n    \n    def paint_board(initial_board):\n        board = [row[:] for row in initial_board]\n        \n        # Top row\n        for j, ch in enumerate(A):\n            if ch == '1':\n                x, y = 0, j+1\n                while board[x][y] == 0:\n                    board[x][y] = 1\n                    x += 1\n        \n        # Right column\n        for i, ch in enumerate(B):\n            if ch == '1':\n                x, y = i+1, M+1\n                while board[x][y] == 0:\n                    board[x][y] = 1\n                    y -= 1\n        \n        # Bottom row\n        for j, ch in enumerate(C):\n            if ch == '1':\n                x, y = N+1, M+1-j\n                while board[x][y] == 0:\n                    board[x][y] = 1\n                    x -= 1\n        \n        # Left column\n        for i, ch in enumerate(D):\n            if ch == '1':\n                x, y = N+1-i, 0\n                while board[x][y] == 0:\n                    board[x][y] = 1\n                    y += 1\n        \n        return board\n    \n    def board_to_state(board):\n        return tuple(tuple(row[1:-1]) for row in board[1:-1])\n    \n    def generate_initial_board(N, M):\n        board = [[0] * (M+2) for _ in range(N+2)]\n        \n        # Paint edges black\n        for j in range(M+2):\n            board[0][j] = board[N+1][j] = 1\n        for i in range(N+2):\n            board[i][0] = board[i][M+1] = 1\n        \n        return board\n    \n    initial_board = generate_initial_board(N, M)\n    states = set()\n    \n    # Try all possible arrangements on the edges\n    def generate_arrangements(current_str, length, depth, current_list):\n        if depth == length:\n            current_list.append(current_str)\n            return current_list\n        \n        current_list = generate_arrangements(current_str + '0', length, depth+1, current_list)\n        current_list = generate_arrangements(current_str + '1', length, depth+1, current_list)\n        \n        return current_list\n    \n    arrangements_A = generate_arrangements('', M, 0, [])\n    arrangements_B = generate_arrangements('', N, 0, [])\n    arrangements_C = generate_arrangements('', M, 0, [])\n    arrangements_D = generate_arrangements('', N, 0, [])\n    \n    for a in arrangements_A:\n        for b in arrangements_B:\n            for c in arrangements_C:\n                for d in arrangements_D:\n                    board = [row[:] for row in initial_board]\n                    board_copy = paint_board(board)\n                    states.add(board_to_state(board_copy))\n    \n    return len(states) % MOD\n\n# Example usage\nN, M = map(int, input().split())\nA = input().strip()\nB = input().strip()\nC = input().strip()\nD = input().strip()\n\nresult = solve(N, M, A, B, C, D)\nprint(result)",
    "timestamp": "2025-08-13 14:16:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, M, A, B, C, D) {\n    const MOD = 998244353;\n    const board = Array.from({ length: N + 2 }, () => Array(M + 2).fill(0));\n    \n    // Mark black squares on edges\n    for (let i = 0; i < N + 2; i++) {\n        board[i][0] = 1;\n        board[i][M + 1] = 1;\n    }\n    for (let j = 0; j < M + 2; j++) {\n        board[0][j] = 1;\n        board[N + 1][j] = 1;\n    }\n    \n    const dx = [0, 1, 0, -1];\n    const dy = [1, 0, -1, 0];\n    \n    function paint(startX, startY, dir) {\n        let x = startX, y = startY;\n        while (board[x][y] === 0) {\n            board[x][y] = 2;\n            x += dx[dir];\n            y += dy[dir];\n        }\n    }\n    \n    // Parse and apply paint paths\n    const paths = [\n        A.split('').map(Number),\n        B.split('').map(Number),\n        C.split('').map(Number),\n        D.split('').map(Number)\n    ];\n    \n    paint(0, 1, 0);\n    paint(1, M + 1, 1);\n    paint(N + 1, M, 2);\n    paint(N, 0, 3);\n    \n    let states = 1;\n    for (let i = 1; i <= N; i++) {\n        for (let j = 1; j <= M; j++) {\n            if (board[i][j] === 0) {\n                states = (states * 2) % MOD;\n            }\n        }\n    }\n    \n    return states;\n}",
    "timestamp": "2025-08-13 14:16:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 998244353\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    A = sys.stdin.readline().strip()\n    B = sys.stdin.readline().strip()\n    C = sys.stdin.readline().strip()\n    D = sys.stdin.readline().strip()\n    \n    # The grid is (N+2) x (M+2), with edges black and inner white\n    # The inner grid is N rows (1..N) x M columns (1..M)\n    \n    # The problem reduces to counting the number of possible sets of painted cells\n    # Each cell (i,j) in the inner grid is painted if it is reachable by any of the people\n    \n    # The people are:\n    # A: left edge, row i (1..N), direction right\n    # B: right edge, row i (1..N), direction left\n    # C: top edge, column j (1..M), direction down\n    # D: bottom edge, column j (1..M), direction up\n    \n    # The painted cells are the union of:\n    # For A: if A[i-1] is 'R', then row i is fully painted\n    # For B: if B[i-1] is 'L', then row i is fully painted\n    # For C: if C[j-1] is 'D', then column j is fully painted\n    # For D: if D[j-1] is 'U', then column j is fully painted\n    # Additionally, for cells not in any fully painted row or column, they are painted if:\n    # - there's a 'R' in A up to their row, or 'L' in B up to their row, or\n    # - there's a 'D' in C up to their column, or 'U' in D up to their column\n    \n    # So the problem can be broken down into:\n    # 1. Count the number of ways to choose fully painted rows and columns\n    # 2. For the remaining cells, count the number of ways they can be painted based on the remaining constraints\n    \n    # Let's first precompute for rows and columns:\n    # row_mask[i] = whether row i is fully painted (A[i-1] == 'R' or B[i-1] == 'L')\n    # col_mask[j] = whether column j is fully painted (C[j-1] == 'D' or D[j-1] == 'U')\n    \n    row_mask = [False] * (N + 2)\n    col_mask = [False] * (M + 2)\n    \n    for i in range(1, N+1):\n        a = A[i-1]\n        b = B[i-1]\n        if a == 'R' or b == 'L':\n            row_mask[i] = True\n    \n    for j in range(1, M+1):\n        c = C[j-1]\n        d = D[j-1]\n        if c == 'D' or d == 'U':\n            col_mask[j] = True\n    \n    # Now, for rows not in row_mask and columns not in col_mask, we need to consider the remaining conditions\n    # For a cell (i,j) not in any fully painted row or column:\n    # It is painted if:\n    # - there exists k <= i where A[k-1] == 'R' or B[k-1] == 'L' (but row k is not fully painted)\n    # - or there exists l <= j where C[l-1] == 'D' or D[l-1] == 'U' (but column l is not fully painted)\n    \n    # So, for such cells, the condition is:\n    # painted if (exists a row <= i with A or B active) OR (exists a column <= j with C or D active)\n    \n    # Let's compute for rows:\n    # row_active[i] = whether there exists k <= i where A[k-1] == 'R' or B[k-1] == 'L' but row k is not fully painted\n    row_active = [False] * (N + 2)\n    has_row_active = False\n    for i in range(1, N+1):\n        if row_mask[i]:\n            row_active[i] = False\n        else:\n            if A[i-1] == 'R' or B[i-1] == 'L':\n                row_active[i] = True\n        if row_active[i]:\n            has_row_active = True\n        row_active[i] |= row_active[i-1]\n    \n    # Similarly for columns:\n    col_active = [False] * (M + 2)\n    has_col_active = False\n    for j in range(1, M+1):\n        if col_mask[j]:\n            col_active[j] = False\n        else:\n            if C[j-1] == 'D' or D[j-1] == 'U':\n                col_active[j] = True\n        if col_active[j]:\n            has_col_active = True\n        col_active[j] |= col_active[j-1]\n    \n    # Now, the number of free cells is the number of cells (i,j) where:\n    # not row_mask[i] and not col_mask[j]\n    # For these cells, they are painted if row_active[i] or col_active[j]\n    \n    # The total number of possible configurations is 2^K, where K is the number of cells that are not forced to be painted\n    # The forced cells are:\n    # - cells in fully painted rows or columns\n    # - cells where row_active[i] or col_active[j] is true\n    \n    # So, the free cells are those where not row_mask[i], not col_mask[j], and not row_active[i], and not col_active[j]\n    \n    K = 0\n    for i in range(1, N+1):\n        if row_mask[i]:\n            continue\n        for j in range(1, M+1):\n            if col_mask[j]:\n                continue\n            if not row_active[i] and not col_active[j]:\n                K += 1\n    \n    ans = pow(2, K, MOD)\n    print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 14:17:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve(N, M, A, B, C, D) {\n    const total = (N + 2) * (M + 2);\n    const edges = [];\n    \n    // Process each direction\n    const processDirection = (str, dx, dy) => {\n        for (let i = 0; i < str.length; i++) {\n            const c = str[i];\n            let x, y;\n            if (dx === 0 && dy === 1) { // Right\n                x = 0;\n                y = i + 1;\n            } else if (dx === 0 && dy === -1) { // Left\n                x = N + 1;\n                y = M - i;\n            } else if (dx === 1 && dy === 0) { // Down\n                x = i + 1;\n                y = 0;\n            } else if (dx === -1 && dy === 0) { // Up\n                x = N - i;\n                y = M + 1;\n            }\n            edges.push({ x, y, dx, dy, char: c });\n        }\n    };\n    \n    processDirection(A, 0, 1);   // Right (top edge)\n    processDirection(B, 0, -1);  // Left (bottom edge)\n    processDirection(C, 1, 0);   // Down (left edge)\n    processDirection(D, -1, 0);  // Up (right edge)\n    \n    const grid = Array.from({ length: N + 2 }, () => Array(M + 2).fill(0));\n    // Mark edges as black (1)\n    for (let i = 0; i < N + 2; i++) {\n        grid[i][0] = 1;\n        grid[i][M + 1] = 1;\n    }\n    for (let j = 0; j < M + 2; j++) {\n        grid[0][j] = 1;\n        grid[N + 1][j] = 1;\n    }\n    \n    const visited = new Set();\n    const queue = [];\n    \n    for (const person of edges) {\n        const { x, y, dx, dy, char } = person;\n        if (char === 'X') {\n            grid[x][y] = 1;\n            queue.push({ x, y, dx, dy });\n        }\n    }\n    \n    while (queue.length > 0) {\n        const { x, y, dx, dy } = queue.shift();\n        const nx = x + dx;\n        const ny = y + dy;\n        if (nx >= 1 && nx <= N && ny >= 1 && ny <= M && grid[nx][ny] === 0) {\n            grid[nx][ny] = 1;\n            queue.push({ x: nx, y: ny, dx, dy });\n        }\n    }\n    \n    let whiteCount = 0;\n    for (let i = 1; i <= N; i++) {\n        for (let j = 1; j <= M; j++) {\n            if (grid[i][j] === 0) {\n                whiteCount++;\n            }\n        }\n    }\n    \n    const pow2 = Array(whiteCount + 1).fill(1);\n    for (let i = 1; i <= whiteCount; i++) {\n        pow2[i] = (pow2[i - 1] * 2) % MOD;\n    }\n    \n    return pow2[whiteCount];\n}\n\n// Sample usage:\n// const N = 2, M = 2;\n// const A = \"X.\", B = \"X.\", C = \"..\", D = \"..\";\n// console.log(solve(N, M, A, B, C, D));",
    "timestamp": "2025-08-13 14:17:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    string A, B, C, D;\n    cin >> A >> B >> C >> D;\n\n    set<string> paintedStates;\n\n    // Initialize board\n    vector<vector<char>> board(N + 2, vector<char>(M + 2, 'B'));\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= M; ++j) {\n            board[i][j] = 'W';\n        }\n    }\n\n    // Lambda to simulate painting from a direction\n    auto paintFrom = [&](int r, int c, int dr, int dc) {\n        vector<vector<char>> state = board;\n        while (state[r][c] == 'W') {\n            state[r][c] = 'P';\n            r += dr;\n            c += dc;\n        }\n        // Serialize state\n        string serialized;\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= M; ++j) {\n                serialized += state[i][j];\n            }\n        }\n        paintedStates.insert(serialized);\n    };\n\n    // Run for each position and direction based on strings A, B, C, D\n    for (int i = 0; i < N; ++i) {\n        // From top (string A)\n        if (A[i] == 'R') paintFrom(0, i + 1, 1, 0);\n        if (A[i] == 'L') paintFrom(0, i + 1, -1, 0);\n    }\n    for (int i = 0; i < M; ++i) {\n        // From bottom (string B)\n        if (B[i] == 'R') paintFrom(N + 1, i + 1, -1, 0);\n        if (B[i] == 'L') paintFrom(N + 1, i + 1, 1, 0);\n    }\n    for (int i = 0; i < M; ++i) {\n        // From left (string C)\n        if (C[i] == 'D') paintFrom(i + 1, 0, 0, 1);\n        if (C[i] == 'U') paintFrom(i + 1, 0, 0, -1);\n    }\n    for (int i = 0; i < N; ++i) {\n        // From right (string D)\n        if (D[i] == 'D') paintFrom(i + 1, M + 1, 0, -1);\n        if (D[i] == 'U') paintFrom(i + 1, M + 1, 0, 1);\n    }\n\n    // Output the number of unique painted states modulo MOD\n    cout << paintedStates.size() % MOD << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:42:59"
  }
]