[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nMint f(int a, int b, int c) {\n    if (a == 0 && b == 0) return 1;\n    if (c == 0) return 0;\n    Mint ret = nCk(a+b+c, c) - nCk(a+b+c-1, c);\n    return ret;\n}\n\nint N, M;\nchar L[100011], R[100011], U[100011], D[100011];\n\n\nMint calc() {\n    int lcnt = count(L, L+N, '1');\n    int rcnt = count(R, R+N, '1');\n\n    if (lcnt == 0 && rcnt == 0) return 0;\n    int ucnt = count(U, U+M, '1');\n    int dcnt = count(D, D+M, '1');\n\n    int lup = 0, rup = 0;\n    Mint ans = 0;\n    Mint way = 0;\n    REP (i, N) {\n\tint line = 0;\n\tif (L[i] == '1') { lcnt--; line++; }\n\tif (R[i] == '1') { rcnt--; line++; }\n\tif (line) {\n\t    way += f(lup, rup, ucnt);\n\t    way *= line;\n\t    ans += f(lcnt, rcnt, dcnt) * way;\n\t}\n\tif (L[i] == '1') { lup++; }\n\tif (R[i] == '1') { rup++; }\n    }\n    return ans;\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d\", &N, &M);\n    scanf(\"%s\", L);\n    scanf(\"%s\", R);\n    scanf(\"%s\", U);\n    scanf(\"%s\", D);\n\n    Mint ans1 = calc();\n    REP (i, 100011) {\n\tswap(L[i], U[i]);\n\tswap(R[i], D[i]);\n    }\n    swap(N, M);\n    Mint ans2 = calc();\n\n    Mint ans = ans1 + ans2;\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\ninline void pls(int&A,int B){A=A+B<p?A+B:A+B-p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,all=0;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=1;i<=m;++i)r+=C[i]-'0'+D[i]-'0';\n\tint tmp=1,val;all=r;\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')tmp=2ll*tmp%p;\n\t\tif(right+r){\n\t\t\tval=Com(right+r-1,r);\n\t\t\tans=(ans+(ll)tmp*val)%p;\n\t\t}\n\t\tif(left+l){\n\t\t\tval=Com(left+l-1,l);\n\t\t\tpls(tmp,val);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int, T mod = 1'000'000'007, typename U = long long>\nstruct umod{\n        T val;\n        umod(): val(0){}\n        umod(U x){ x %= mod; if(x < 0) x += mod; val = x;}\n        umod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\tumod& operator *= (umod oth){ val = ((U)val) * oth.val % mod; return *this; }\n\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n        umod& operator ^= (U oth){ return *this = pwr(*this, oth); }\n\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n        umod operator ^ (U oth) const { return umod(*this) ^= oth; }\n\tbool operator < (umod oth) const { return val < oth.val; }\n\tbool operator > (umod oth) const { return val > oth.val; }\n\tbool operator <= (umod oth) const { return val <= oth.val; }\n\tbool operator >= (umod oth) const { return val >= oth.val; }\n\tbool operator == (umod oth) const { return val == oth.val; }\n\tbool operator != (umod oth) const { return val != oth.val; }\n        umod pwr(umod a, U b) const { umod r = 1; for(; b; a *= a, b >>= 1) if(b&1) r *= a; return r; }\n        umod inverse() const {\n\t\tU a = val, b = mod, u = 1, v = 0;\n\t\twhile(b){\n\t\t\tU t = a/b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tif(u < 0)\n\t\t\tu += mod;\n\t\treturn u;\n        }\n};\nusing U = umod<int, 998244353>;\ntemplate<typename U>\nstruct NCR {\n        vector<U> fact, ifact;\n        NCR(int size){\n                fact.resize(size + 1); ifact.resize(size + 1);\n                fact[0] = 1;\n                for(int i = 1; i <= size; i++) fact[i] = fact[i - 1] * i;\n                ifact[size] = fact[size].inverse();\n                for(int i = size - 1; i >= 0; i--) ifact[i] = ifact[i + 1] * (i + 1);\n        }\n        U coef(int n, int r){\n                if(n < r) return 1;\n                return fact[n] * ifact[r] * ifact[n - r];\n        }\n};\nconst int maxn = 500500;\nU pref[maxn], suff[maxn], p2[maxn];\nint main(){\n\tNCR<U> ncr(maxn);\n\tint n, m; cin >> n >> m;\n\tstring a, b, c, d; cin >> a >> b >> c >> d;\n\tU ans = 0;\n\tfor(int r = 0; r < 2; r++){\n\t\t{\n\t\t\tint y = count(c.begin(), c.end(), '1');\n\t\t\tint x = 0, z = 0;\n\t\t\tpref[0] = 1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx += a[i] == '1';\n\t\t\t\tz += b[i] == '1';\n\t\t\t\tpref[i + 1] = ncr.coef(x + y + z - 1, x + z);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint y = count(d.begin(), d.end(), '1');\n\t\t\tint x = 0, z = 0;\n\t\t\tsuff[n] = 1;\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\tx += a[i] == '1';\n\t\t\t\tz += b[i] == '1';\n\t\t\t\tsuff[i] = ncr.coef(x + y + z - 1, x + z);\n\t\t\t}\n\t\t}\n\t\tp2[n] = 1;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tp2[i] = p2[i + 1];\n\t\t\tif(a[i] == '1' && b[i] == '1'){\n\t\t\t\tp2[i] *= 2;\n\t\t\t}\n\t\t}\n\t\tU sum = 0;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tif(a[i] == '1' || b[i] == '1'){\n\t\t\t\tsum += suff[i + 1] * p2[i + 1].inverse();\n\t\t\t\tans += pref[i] * sum * p2[i];\n\t\t\t}\n\t\t}\n\t\tswap(a, c);\n\t\tswap(b, d);\n\t\tswap(n, m);\n\t}\n\tcout << ans.val << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=4e5+7;\nconst LL mod=998244353;\nconst LL inv2=499122177;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,m;\nchar s[5][N];\nLL fac[N],ifac[N];\ninline void Add(LL &x,LL y){x=x+y<mod?x+y:x+y-mod;}\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,1)ifac[i-1]=ifac[i]*i%mod;\n}\ninline LL C(int n,int k)\n{\n\tif(n==k)return 1;\n\treturn fac[n]*ifac[k]%mod*ifac[n-k]%mod;\n}\ninline LL Solve()\n{\n\tint L=0,R=0,Sl=0,Sr=0;\n\tFor(i,1,n)Sl+=s[1][i-1]-'0',Sr+=s[2][i-1]-'0';\n\tFor(i,1,m)R+=s[3][i-1]-'0'+s[4][i-1]-'0';\n\tLL now=0,ans=0;\n\tFor(i,1,m)\n\t{\n\t\tint type=s[3][i-1]-'0'+s[4][i-1]-'0';\n\t\tif(type)\n\t\t{\n\t\t\tAdd(now,!Sl?(!L?1:0):C(Sl+L-1,L));\n\t\t\tL+=type,R-=type;\n\t\t\ttype==2?Add(now,now):(void)1;\n\t\t\tAdd(ans,now*(!Sr?(!R?1:0):C(Sr+R-1,R))%mod);\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\tfile();\n\tread(n),read(m);\n\tinit((n+m)*2);\n\tFor(i,1,4)scanf(\"%s\",s[i]);\n\tLL ans=0;\n\tAdd(ans,Solve());\n\tswap(n,m);\n\tswap(s[1],s[3]);\n\tswap(s[2],s[4]);\n\tAdd(ans,Solve());\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define lb(x) ((x)&(-(x)))\n#define xx first\n#define yy second\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int> \n#define dalao 998244353\n#define inf 0x3f3f3f3f\n#define N 100010\nusing namespace std;\ntypedef long long ll;\nint n,m,K,x,y,fac[N<<2]={1},inv[N<<2],l[N],r[N],ans;\nchar a[N],b[N],c[N],d[N],s[N];\ninline int poww(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%dalao)if(b&1)r=1ll*r*a%dalao;return r;}\ninline int C(int a,int b){return a<b||b<0?0:1ll*fac[a]*inv[b]%dalao*inv[a-b]%dalao;}\ninline void upd(int& a,int b){a=a+b>=dalao?a+b-dalao:a+b;}\nint main(){\n\tscanf(\"%d%d%s%s%s%s\",&n,&m,a+1,b+1,c+1,d+1),K=max(n,m);\n\tfor(int i=1;i<=(K<<2);i++)fac[i]=1ll*fac[i-1]*i%dalao;\n\tinv[K<<2]=poww(fac[K<<2],dalao-2);\n\tfor(int i=(K<<2)-1;~i;i--)inv[i]=1ll*inv[i+1]*(i+1)%dalao;\n//\t---------------------------------------------\n\tK=0;\n\tfor(int i=1;i<=m;i++)if(d[i]-48+c[i]-48>0)s[++K]=d[i]-48+c[i]-48;\n\tfor(int i=1;i<=n;i++)x+=a[i]-48;\n\tfor(int i=1;i<=K;i++){\n\t\tif(x==0&&y==0)l[i]=1;\n\t\telse if(x)l[i]=C(x+y-1,x-1);\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<x<<\" \"<<y<<endl;\n\t\ty+=s[i];\n\t}\n\tx=y=0;\n\tfor(int i=1;i<=n;i++)x+=b[i]-48;\n\tfor(int i=K;i;i--){\n\t\tif(x==0&&y==0)r[i]=1;\n\t\telse if(x)r[i]=C(x+y-1,x-1);\n\t\ty+=s[i];\n\t}\n\tx=0;\n\tfor(int i=1;i<=K;i++){\n\t\tupd(x,l[i]);\n\t\tif(s[i]==2)upd(x,x);\n\t\tupd(ans,1ll*r[i]*x%dalao);\n\t}\n//\t---------------------------------------------\n\tK=x=y=0;\n\tfor(int i=1;i<=n;i++)if(a[i]-48+b[i]-48>0)s[++K]=a[i]-48+b[i]-48;\n\tfor(int i=1;i<=m;i++)x+=c[i]-48;\n\tfor(int i=1;i<=K;i++){\n\t\tif(x==0&&y==0)l[i]=1;\n\t\telse if(x)l[i]=C(x+y-1,x-1);\n\t\telse l[i]=0;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<x<<\" \"<<y<<endl;\n\t\ty+=s[i];\n\t}\n\tx=y=0;\n\tfor(int i=1;i<=m;i++)x+=d[i]-48;\n\tfor(int i=K;i;i--){\n\t\tif(x==0&&y==0)r[i]=1;\n\t\telse if(x)r[i]=C(x+y-1,x-1);\n\t\telse r[i]=0;\n\t\ty+=s[i];\n\t}\n\tx=0;\n\tfor(int i=1;i<=K;i++){\n\t\tupd(x,l[i]);\n\t\tif(s[i]==2)upd(x,x);\n\t\tupd(ans,1ll*r[i]*x%dalao);\n\t}\n//\t---------------------------------------------\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int, T mod = 1'000'000'007, typename U = long long>\nstruct umod{\n        T val;\n        umod(): val(0){}\n        umod(U x){ x %= mod; if(x < 0) x += mod; val = x;}\n        umod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\tumod& operator *= (umod oth){ val = ((U)val) * oth.val % mod; return *this; }\n\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n        umod& operator ^= (U oth){ return *this = pwr(*this, oth); }\n\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n        umod operator ^ (U oth) const { return umod(*this) ^= oth; }\n\tbool operator < (umod oth) const { return val < oth.val; }\n\tbool operator > (umod oth) const { return val > oth.val; }\n\tbool operator <= (umod oth) const { return val <= oth.val; }\n\tbool operator >= (umod oth) const { return val >= oth.val; }\n\tbool operator == (umod oth) const { return val == oth.val; }\n\tbool operator != (umod oth) const { return val != oth.val; }\n        umod pwr(umod a, U b) const { umod r = 1; for(; b; a *= a, b >>= 1) if(b&1) r *= a; return r; }\n        umod inverse() const {\n\t\tU a = val, b = mod, u = 1, v = 0;\n\t\twhile(b){\n\t\t\tU t = a/b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tif(u < 0)\n\t\t\tu += mod;\n\t\treturn u;\n        }\n};\nusing U = umod<int, 998244353>;\ntemplate<typename U>\nstruct NCR {\n        vector<U> fact, ifact;\n        NCR(int size){\n                fact.resize(size + 1); ifact.resize(size + 1);\n                fact[0] = 1;\n                for(int i = 1; i <= size; i++) fact[i] = fact[i - 1] * i;\n                ifact[size] = fact[size].inverse();\n                for(int i = size - 1; i >= 0; i--) ifact[i] = ifact[i + 1] * (i + 1);\n        }\n        U coef(int n, int r){\n                if(n < r) return 0;\n                return fact[n] * ifact[r] * ifact[n - r];\n        }\n};\nconst int maxn = 500500;\nU pref[maxn], suff[maxn], p2[maxn];\nint main(){\n\tNCR<U> ncr(maxn);\n\tint n, m; cin >> n >> m;\n\tstring a, b, c, d; cin >> a >> b >> c >> d;\n\tU ans = 0;\n\tfor(int r = 0; r < 2; r++){\n\t\t{\n\t\t\tint y = count(c.begin(), c.end(), '1');\n\t\t\tint x = 0, z = 0;\n\t\t\tpref[0] = 1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx += a[i] == '1';\n\t\t\t\tz += b[i] == '1';\n\t\t\t\tpref[i + 1] = ncr.coef(x + y + z - 1, x + z);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint y = count(d.begin(), d.end(), '1');\n\t\t\tint x = 0, z = 0;\n\t\t\tsuff[n] = 1;\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\tx += a[i] == '1';\n\t\t\t\tz += b[i] == '1';\n\t\t\t\tsuff[i] = ncr.coef(x + y + z - 1, x + z);\n\t\t\t}\n\t\t}\n\t\tp2[n] = 1;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tp2[i] = p2[i + 1];\n\t\t\tif(a[i] == '1' && b[i] == '1'){\n\t\t\t\tp2[i] *= 2;\n\t\t\t}\n\t\t}\n\t\tU sum = 0;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tif(a[i] == '1' || b[i] == '1'){\n\t\t\t\tsum += suff[i + 1] * p2[i + 1].inverse();\n\t\t\t\tans += pref[i] * sum * p2[i];\n\t\t\t}\n\t\t}\n\t\tswap(a, c);\n\t\tswap(b, d);\n\t\tswap(n, m);\n\t}\n\tcout << ans.val << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =998244353;\nvector<cat> fac, inv, inv_fac;\n\ncat pw(cat a, cat e) {\n\tif(e <= 0) return 1;\n\tcat x =pw(a,e/2);\n\tx =(x*x)%mod;\n\tif(e&1) return (x*a)%mod;\n\treturn x;\n}\n\ncat getC(int N, int K) {\n\tif(N < 0 || K < 0 || K > N) return 0;\n\tcat ret =(inv_fac[K]*inv_fac[N-K])%mod;\n\tret =(ret*fac[N])%mod;\n\treturn ret;\n}\n\ncat count(int up, int dn, int n) {\n\tif(n == 0) return (up+dn == 0);\n\treturn getC(up+dn+n-1,n-1);\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint MX =500010;\n\tfac.resize(MX,1);\n\tinv.resize(MX,1);\n\tinv_fac.resize(MX+1,1);\n\tfor(int i =1; i < MX; i++) {\n\t\tfac[i] =(i*fac[i-1])%mod;\n\t\tinv[i] =pw(i,mod-2);\n\t\tinv_fac[i] =(inv[i]*inv_fac[i-1])%mod;\n\t}\n\n\tint N,M;\n\tstring A,B,C,D;\n\tcin >> N >> M >> A >> B >> C >> D;\n\tcat ans =0;\n\tbool zero =1;\n\tfor(int k =0; k < 2; k++) {\n\t\tswap(N,M);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\n\t\tint nL =0, nR =0;\n\t\tfor(int i =0; i < M; i++) if(C[i] == '1') nL++;\n\t\tfor(int i =0; i < M; i++) if(D[i] == '1') nR++;\n\t\tvector<cat> cL(N,0), cR(N,0);\n\t\tint up =0, dn =0;\n\t\tfor(int i =0; i < N; i++) {\n\t\t\tcL[i] =count(up,dn,nL);\n\t\t\tif(A[i] == '1') up++;\n\t\t\tif(B[i] == '1') dn++;\n\t\t}\n\t\tup =dn =0;\n\t\tfor(int i =N-1; i >= 0; i--) {\n\t\t\tcR[i] =count(up,dn,nR);\n\t\t\tif(A[i] == '1') up++;\n\t\t\tif(B[i] == '1') dn++;\n\t\t}\n\n\t\tcat akt =0;\n\t\tfor(int i =N-1; i >= 0; i--) {\n\t\t\tif(A[i] == '1' || B[i] == '1') akt +=cR[i];\n\t\t\tif(A[i] == '1' && B[i] == '1') akt *=2;\n\t\t\takt %=mod;\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tans =(ans+akt*cL[i])%mod;\n\t\t\t\tzero =0;\n\t\t\t}\n\t\t}\n\n\t}\n\tif(zero) ans++;\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\n//const ll mod=1e9+7;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\tif(n<0) return 1;\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nstring A,B,C,D;\n\nbool Check(string s){\n\tint N=s.size();\n\treturn s==string(N,'0');\n}\n\nvl ff(){\n\tvl a(m+1);\n\ta[0]++;\n\tif(!Check(A)){\n\t\tint S=0,t=0;\n\t\tfor(int i=0;i<n;i++) S+=A[i]-'0';\n\t\tfor(int i=0;i<m;i++){\n\t\t\tt+=C[i]-'0'+D[i]-'0';\n\t\t\ta[i+1]=nCk(S+t-1,t);\n\t\t}\n\t}\n\tswap(A,B);\n\treverse(C.begin(),C.end());\n\treverse(D.begin(),D.end());\n\treturn a;\n}\n\nll f(){\n\tll res=0,t=0;\n\tvl a=ff(),b=ff();\n\tfor(int i=0;i<m;i++) if(C[i]=='1'||D[i]=='1'){\n\t\tt=(C[i]-'0'+D[i]-'0')*(a[i]+t)%mod;\n\t\t(res+=t*b[m-1-i])%=mod;\n\t}\n\tswap(A,C);swap(B,D);swap(n,m);\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>m>>A>>B>>C>>D;\n\tInit();\n\tcout<<(f()+f()+(Check(A)&&Check(B)&&Check(C)&&Check(D)?1:0))%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Sergey Kopeliovich (burunduk30@gmail.com)\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n\ntypedef long long ll;\n\n// const int N = 1e3 + 3;\nconst int MOD = 998244353;\ninline void add( int &a, int b ) { if ((a += b) >= MOD) a -= MOD; }\ninline void sub( int &a, int b ) { if ((a -= b) < 0) a += MOD; }\ninline int mul( int a, int b ) { return (ll)a * b % MOD; }\n// int Pow( int x, ll n ) {\n// \tif (n == 1)\treturn x;\n// \tint y = Pow(x, n / 2);\n// \treturn (n & 1) ? mul(mul(y, y), x) : mul(y, y);\n// }\n\nconst int N = 2e5 + 3;\nint inv[N];\n\n// int Inv( int a ) { return Pow(a, MOD - 2); }\nint Div( int a, int b ) { return mul(a, inv[b]); }\n\n// int C[N][N];\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++) \n\t\tinv[i] = ((ll)(MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n\t// C[0][0] = 1;\n\t// forn(i, N - 1)\n\t// \tforn(j, N - 1)\n\t// \t\tadd(C[i + 1][j], C[i][j]), add(C[i + 1][j + 1], C[i][j]);\n\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tint t1, t2;\n\tcin >> t1 >> t2;\n\tstring sa, sb, sc, sd;\n\tcin >> sa >> sb >> sc >> sd;\n\tauto ok = [&]( char c ) {\n\t\treturn c == '1';\n\t};\n\tauto get = [&]( string &s ) {\n\t\treturn count_if(s.begin(), s.end(), ok);\n\t};\n\tint res = 0;\n\tforn(_, 2) {\n\t\tint n = sa.size(), m = sc.size();\n\t\tint na = get(sa), nb = get(sb);\n\t\tbool was = 0;\n\t\tvector<int> F1(n), F2(n);\n\t\tforn(__, 2) {\n\t\t\tint cnt_a = 0, cnt_b = 0;\n\t\t\tint nc = get(sc), cc = 1;//, CC = 1;\n\t\t\tforn(i, n) {\n\t\t\t\tif (ok(sa[i]) || ok(sb[i])) {\n\t\t\t\t\tint f1 = 0;\n\t\t\t\t\tif (cnt_a + cnt_b == 0) {\n\t\t\t\t\t\tf1 = 1;\n\t\t\t\t\t} else if (cnt_a == 0) {\n\t\t\t\t\t\tf1 = cc;//C[cnt_b + nc - 1][nc - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tint A = cnt_a - 1, B = cnt_b, c = nc - 1;\n\t\t\t\t\t\tint tmp = cc;//CC;//C[cnt_b + nc - 1][cnt_b];\n\t\t\t\t\t\tforn(x, nc) {\n\t\t\t\t\t\t\tadd(f1, tmp);\n\t\t\t\t\t\t\ttmp = mul(tmp, A + x + 1);\n\t\t\t\t\t\t\ttmp = Div(tmp, x + 1);\n\t\t\t\t\t\t\ttmp = Div(tmp, B + c - x);\n\t\t\t\t\t\t\ttmp = mul(tmp, c - x);\n\t\t\t\t\t\t\t// add(f1, mul(C[A + x][A], C[B + (c - x)][B]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tF1[i] = f1;\n\t\t\t\t\tcnt_a += ok(sa[i]), cnt_b += ok(sb[i]);\n\t\t\t\t\tif (ok(sb[i])) {\n\t\t\t\t\t\tcc = mul(cc, cnt_b + nc - 1);\n\t\t\t\t\t\tcc = Div(cc, cnt_b);\n\t\t\t\t\t\t// CC = mul(CC, cnt_b + nc - )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(sc, sd), swap(F1, F2);\n\t\t\treverse(sa.begin(), sa.end());\n\t\t\treverse(sb.begin(), sb.end());\n\t\t}\n\t\treverse(F2.begin(), F2.end());\n\t\tint last = -1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tadd(F2[i], F2[i + 1]);\n\t\t\tif (ok(sa[i + 1]) + ok(sb[i + 1]) == 2)\n\t\t\t\tadd(F2[i], F2[i + 1]);\n\t\t}\n\t\tforn(i, n)\n\t\t\tif (ok(sa[i]) || ok(sb[i]))\n\t\t\t\tadd(res, mul(mul(F1[i], F2[i]), ok(sa[i]) + ok(sb[i])));\n\t\tswap(sa, sc), swap(sb, sd);\n\t}\n\tprintf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 301010;\nconst int MOD = 998244353;\nconst int INV = (MOD + 1) >> 1;\ntypedef long long ll;\n\nchar S[N];\nint fac[N << 2], inv[N << 2];\nint v[N][2], h[N][2];\nint pre[N], suf[N], p2[N];\nint n, m, lim, ans;\n\ninline void Mod(int &x) {\n\twhile (x >= MOD) x -= MOD;\n}\ninline int Pow(int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = (ll)c * a % MOD;\n\t\tb >>= 1; a = (ll)a * a % MOD;\n\t}\n\treturn c;\n}\ninline int Inv(int x) {\n\treturn Pow(x, MOD - 2);\n}\ninline int C(int n, int m) {\n\treturn (ll)fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\ninline int Calc(int X, int Y, int Z) {\n\tif (X == 0) return (Y + Z) ? 0: 1;\n\treturn C(X + Y + Z - 1, X - 1);\n}\ninline void Solve(void) {\n\tstatic int x, y, z;\n\tmemset(p2, 0, sizeof p2);\n\tmemset(suf, 0, sizeof suf);\n\tx = y = z = 0;\n\tfor (int i = 1; i <= n; i++) x += h[i][1];\n\tp2[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tMod(p2[i] = p2[i - 1] << (v[i][0] & v[i][1]));\n\tfor (int i = m; i; i--) {\n\t\tif (!v[i][0] && !v[i][1]) {\n\t\t\tsuf[i] = suf[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\tMod(suf[i] = suf[i + 1] + (ll)Calc(x, y, z) * p2[i] % MOD);\n\t\ty += v[i][0]; z += v[i][1];\n\t}\n\tx = y = z = 0;\n\tfor (int i = 1; i <= n; i++) x += h[i][0];\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!v[i][0] && !v[i][1]) continue;\n\t\tpre[i] = (ll)Calc(x, y, z) * Inv(p2[i - 1]) % MOD;\n\t\tMod(ans += (ll)pre[i] * suf[i] % MOD);\n\t\ty += v[i][0]; z += v[i][1];\n\t}\n}\n\n\nint main(void) {\n\tscanf(\"%d%d\\n\", &n, &m);\n\tlim = max(n, m) << 2;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= lim; i++)\n\t\tinv[i] = (ll)(MOD - MOD / i) * inv[MOD % i] % MOD;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= lim; i++) {\n\t\tfac[i] = (ll)fac[i - 1] * i % MOD;\n\t\tinv[i] = (ll)inv[i - 1] * inv[i] % MOD;\n\t}\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= n; i++) h[i][0] = S[i - 1] - '0';\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= n; i++) h[i][1] = S[i - 1] - '0';\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= m; i++) v[i][0] = S[i - 1] - '0';\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= m; i++) v[i][1] = S[i - 1] - '0';\n\tSolve(); lim >>= 2;\n\tfor (int i = 1; i <= lim; i++) {\n\t\tswap(h[i][0], v[i][0]);\n\t\tswap(h[i][1], v[i][1]);\n\t}\n\tswap(n, m); Solve();\n\tcout << max(ans, 1) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint a[100011][2],b[100011][2];\nlong long MOD=998244353;\nlong long fa[300011];\nlong long invfa[300011];\nlong long two[200011];\n\n\nint p[100011];\nint ppos[100011];\nint q[100011];\nint sp[100011];\nint sa[100011][2];\n\n\n//******************************\n//返回d=gcd(a,b);和对应于等式ax+by=d中的x,y\nlong long extend_gcd(long long a,long long b,long long &x,long long &y)\n{\n if(a==0&&b==0) return -1;//无最大公约数\n if(b==0){x=1;y=0;return a;}\n long long d=extend_gcd(b,a%b,y,x);\n y-=a/b*x;\n return d;\n}\n//*********求逆元素*******************\n//ax = 1(mod n)\nlong long mod_reverse(long long a,long long n)\n{\n long long x,y;\n long long d=extend_gcd(a,n,x,y);\n if(d==1) return (x%n+n)%n;\n else return -1;\n}\n\nlong long inv(long long a)\n{\n    return mod_reverse(a,MOD);\n}\n\n/* \nlong long exgcd(long long a,long long b,long long &x,long long &y)  \n{  \n    if(b==0)\n    {  \n        x=1;\n        y=0;\n        return a;\n    }\n    int r=exgcd(b,a%b,x,y);\n    long long t=y;\n    y=x-(a/b)*y;\n    x=t;\n    return r;\n}  \nlong long inv(long long a)  \n{  \n    long long x,y;  \n    long long r=exgcd(a,MOD,x,y);  \n    if(r==1) return (x%MOD+MOD)%MOD;  \n    return -1;  \n}\n*/\n\nlong long C(int n,int k)\n{\n    long long ans=fa[n]*invfa[k]%MOD*invfa[n-k]%MOD;\n    return ans;\n}\n\n\nlong long calc(long long x,long long y,long long z)\n{\n    if(x==0)\n    {\n        if(y==0 && z==0)return 1;\n        return 0;\n    }\n    \n    long long ans=(C(x+y+z,x)-C(x+y+z-1,x)+MOD)%MOD;\n    \n    \n    //cout<<\"calc\"<<' '<<x<<' '<<y<<' '<<z<<\"   \"<<ans<<endl;\n    \n    return ans;\n}\n\nlong long gao(int a[][2],int b[][2],int n,int m)\n{\n    int i,j,k;\n    int mm1,mm2;\n    mm1=mm2=0;\n    for(i=1;i<=m;i++)\n    {\n        mm1+=(b[i][0]==1);\n        mm2+=(b[i][1]==1);\n        \n        //cout<<b[i][0]<<' '<<b[i][1]<<endl;\n    }\n    \n    \n    \n    long long ans=0;\n    sa[0][0]=a[0][1]=0;\n    for(i=1;i<=n;i++)\n    {\n        sa[i][0]=sa[i-1][0]+a[i][0];\n        sa[i][1]=sa[i-1][1]+a[i][1];\n    }\n    \n    int nn=0;\n    for(i=1;i<=n;i++)\n    {\n        if(a[i][0]==1 && a[i][1]==1)\n        {\n            p[++nn]=2;\n            ppos[nn]=i;\n        }\n        else if(a[i][0]==1 || a[i][1]==1)\n        {\n            p[++nn]=1;\n            ppos[nn]=i;\n        }\n    }\n    sp[0]=0;\n    for(i=1;i<=nn;i++)\n    {\n        sp[i]=sp[i-1]+(p[i]==2);\n    }\n    \n    \n    long long tmp=0;\n    long long lans=1;\n    long long rans;\n    int ll,rr;\n    ll=1;\n    \n    \n    //cout<<mm1<<' '<<mm2<<\" mmm\"<<endl;\n    for(rr=1;rr<=nn;rr++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[rr]][0],sa[n][1]-sa[ppos[rr]][1]);\n        tmp=(tmp+lans*rans%MOD*two[sp[rr]-sp[ll-1]]%MOD)%MOD;\n    }\n    //cout<<\"tmp0\"<<tmp<<endl;\n    \n    ans=(ans+tmp)%MOD;\n    for(ll=2;ll<=nn;ll++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[ll-1]][0],sa[n][1]-sa[ppos[ll-1]][1]);\n        tmp=(tmp-lans*rans%MOD*two[sp[ll-1]-sp[ll-2]]%MOD+MOD)%MOD;\n        //cout<<tmp<<\"  &&&\"<<endl;\n        tmp=tmp*inv(lans)%MOD;\n        lans=calc(mm1,sa[ppos[ll]-1][0],sa[ppos[ll]-1][1]);\n        tmp=tmp*lans%MOD;\n        if(p[ll-1]==2)\n        {\n            tmp=tmp*inv(2)%MOD;\n        }\n        \n        //cout<<\"tmp\"<<tmp<<endl;\n        \n        ans=(ans+tmp)%MOD;\n    }\n    \n    \n    return ans;\n}\n\n\nint main()\n{\n    int i,j,k;\n    char c;\n    fa[0]=1;\n    invfa[0]=1;\n    for(i=1;i<=300000;i++)\n    {\n        fa[i]=(fa[i-1]*i)%MOD;\n        invfa[i]=inv(fa[i]);\n    }\n    two[0]=1;\n    for(i=1;i<=300000;i++)\n    {\n        two[i]=(two[i-1]*2)%MOD;\n    }\n    \n    \n    scanf(\"%d %d\",&n,&m);\n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=n;i++)\n    {\n        \n            scanf(\" %c\",&c);\n            a[i][j]=c-'0';\n    }\n    }\n    \n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=m;i++)\n    {\n            scanf(\" %c\",&c);\n            b[i][j]=c-'0';\n    }\n    }\n    \n    long long ans=0;\n    ans+=gao(a,b,n,m);\n    ans+=gao(b,a,m,n);\n    ans%=MOD;\n    cout<<(ans+MOD)%MOD<<endl;\n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\n//const ll mod=1e9+7;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=1000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\tif(n<0) return 1;\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nstring A,B,C,D;\n\nbool Check(string s){\n\tint N=s.size();\n\treturn s==string(N,'0');\n}\n\nvl ff(){\n\tvl a(m+1);\n\ta[0]++;\n\tif(!Check(A)){\n\t\tint S=0,t=0;\n\t\tfor(int i=0;i<n;i++) S+=A[i]-'0';\n\t\tfor(int i=0;i<m;i++){\n\t\t\tt+=C[i]-'0'+D[i]-'0';\n\t\t\ta[i+1]=nCk(S+t-1,t);\n\t\t}\n\t}\n\tswap(A,B);\n\treverse(C.begin(),C.end());\n\treverse(D.begin(),D.end());\n\treturn a;\n}\n\nll f(){\n\tll res=0,t=0;\n\tvl a=ff(),b=ff();\n\tfor(int i=0;i<m;i++) if(C[i]=='1'||D[i]=='1'){\n\t\tt=(C[i]-'0'+D[i]-'0')*(a[i]+t)%mod;\n\t\t(res+=t*b[m-1-i])%=mod;\n\t}\n\tswap(A,C);swap(B,D);swap(n,m);\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>m>>A>>B>>C>>D;\n\tInit();\n\tcout<<(f()+f()+(Check(A)&&Check(B)&&Check(C)&&Check(D)?1:0))%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n ***\n Idea:\n */\n\n#include <memory.h>\n#include <ctime>\n#include <random>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<long> vl;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<long, long> ll;\n\nconst long MOD = 998244353;\n\nclass ModernPainting{\n    long X1, X2, M, nTwo;\n    string top,bot;\n    vl posi, nega, invs;\n    inline long mPlus(long x,long y){ return (x+y)%MOD; }\n    void refMPlus(long &x, long y){\n        x += y;\n        if(x >= MOD) x %= MOD;\n    }\n    inline double mTimes(long x,long y){ return (x*y)%MOD; }\n    void refMTimes(long &x,long y){\n        x *= y;\n        if(x >= MOD) x%=MOD;\n    }\n    long mPower(long n,long k){  // compute n^k (mod MOD)\n        long ans = 1;\n        while(k){\n            if(1&k) refMTimes(ans, n);\n            refMTimes(n, n);\n            k >>= 1;\n        }\n        return ans;\n    }\n    long mInverse(long n){\n        return mPower(n, MOD-2);\n    }\n    void init(){\n        assert(M>0);\n        posi = nega = vl(M+1, 1);\n        invs = vl(2*M+1, 1);\n        nTwo = 0;\n        for(int i=0;i<M;++i) if(top[i]==bot[i]) ++nTwo;\n        for(int i=2;i<=2*M;++i) invs[i] = mInverse(i);\n        if(X1){\n            long Y = 0, Z = 0;\n            for(int i=1;i<=M;++i){\n                long Y1 = Y + (top[i-1]=='1'), Z1 = Z + (bot[i-1]=='1');\n                if(top[i-1]==bot[i-1]){\n                    long fac = mTimes(mTimes(Y1+Z1+X1-1, Y1+Z1+X1-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    posi[i] = mTimes(posi[i-1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X1-1, invs[Y1+Z1]);\n                    posi[i] = mTimes(posi[i-1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        if(X2){\n            long Y = 0, Z = 0;\n            for(long i=M-1;i>=0;--i){\n                long Y1 = Y + (top[i]=='1'), Z1 = Z + (bot[i]=='1');\n                if(top[i]==bot[i]){\n                    long fac = mTimes(mTimes(Y1+Z1+X2-1, Y1+Z1+X2-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    nega[i] = mTimes(nega[i+1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X2-1, invs[Y1+Z1]);\n                    nega[i] = mTimes(nega[i+1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        for(long i=M-1;i>=0;--i) refMPlus(nega[i], nega[i+1]);\n    }\n    long compCnt(){\n        if(!X2) return (long)1;\n        if(!X1) return nega[1];\n        long ans = 0;\n        for(int i=0;i<M;++i) refMPlus(ans, mTimes(posi[i], nega[i+1]));\n        return ans;\n    }\npublic:\n    long solve(string t, string b,long x1, long x2){\n        X1 = x1;\n        X2 = x2;\n        \n        if(X1>X2) {\n            swap(X1, X2);\n            swap(t,b);\n            reverse(t.begin(),t.end());\n            reverse(b.begin(),b.end());\n        }\n        top.clear();\n        bot.clear();\n        for(int i=0;i<(int)b.size();++i) if(b[i]=='1'||t[i]=='1'){\n            top += t[i];\n            bot += b[i];\n        }\n        M = (int)top.size();\n        if(!M) return (long)0;\n        init();\n        return mTimes(mPower(2, nTwo), compCnt());\n    }\n};\n\nint main(){\n    int n,m,cnt = 0;\n    string A,B,C,D;\n    cin>>n>>m>>A>>B>>C>>D;\n    long X1 = 0, X2 = 0, ans = 0;\n    for(int i=0;i<m;++i){\n        X1 += (C[i] == '1');\n        X2 += (D[i] == '1');\n    }\n    cnt += (int)X1 + (int)X2;\n    ans += ModernPainting().solve(B, A, X1, X2);\n    X1 = X2 = 0;\n    for(int i=0;i<n;++i){\n        X1 += (A[i] == '1');\n        X2 += (B[i] == '1');\n    }\n    ans += ModernPainting().solve(C, D, X1, X2);\n    cnt += (int)X1 + (int)X2;\n    if(!cnt) cout<<1<<endl;\n    else cout<<(ans%MOD)<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint po(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) { return po(x, mod - 2); }\n\nint fact[400010], invf[400010];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    if(k < 0) return 1;\n    return comb(n + k - 1, k);\n}\n\nint N, M;\nstring A, B, C, D;\n\nvector<int> Col;\nvector<int> Ldp, Rdp, Rpsum, pmul;\n\nint solve() {\n    Col.clear();\n    for(int i = 0; i < M; i++) {\n        if(C[i] == '1' && D[i] == '1') Col.push_back(3);\n        else if(C[i] == '1') Col.push_back(1);\n        else if(D[i] == '1') Col.push_back(2);\n    }\n\n    if(Col.size() == 0) return 0;\n\n    int a = 0;\n    for(int i = 0; i < N; i++) if(A[i] == '1') a++;\n    int x = 0, y = 0;\n    Ldp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = 0; i < Col.size(); i++) {\n            if(x == 0 && y == 0) Ldp[i] = 1;\n            else Ldp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Ldp[0] = 1;\n\n    a = 0;\n    for(int i = 0; i < N; i++) if(B[i] == '1') a++;\n    x = 0, y = 0;\n    Rdp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = (int)Col.size() - 1; i >= 0; i--) {\n            if(x == 0 && y == 0) Rdp[i] = 1;\n            else Rdp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Rdp.back() = 1;\n\n    pmul = vector<int>(Col.size());\n    for(int i = 0; i < Col.size(); i++) {\n        pmul[i] = (Col[i] == 3? 2 : 1);\n        if(i) pmul[i] = 1LL * pmul[i] * pmul[i - 1] % mod;\n    }\n\n    Rpsum = vector<int>(Col.size());\n    for(int i = (int)Col.size() - 1; i >= 0; i--) {\n        Rpsum[i] = 1LL * Rdp[i] * pmul[i] % mod;\n        if(i != (int)Col.size() - 1) {\n            Rpsum[i] += Rpsum[i + 1];\n            Rpsum[i] %= mod;\n        }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < Col.size(); i++) {\n        ret += 1LL * Ldp[i] * (Col[i] == 3? 2 : 1) % mod * (Rdp[i] + 1LL * (i == Col.size() - 1? 0 : Rpsum[i + 1]) * inv(pmul[i]) % mod) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 200010; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 200010; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> M >> A >> B >> C >> D;\n\n    int ans = 0;\n    ans += solve();\n    ans %= mod;\n    swap(N, M);\n    swap(A, C);\n    swap(B, D);\n    ans += solve();\n    ans %= mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 100001;\nconst int MOD = 998244353;\n\nint fact[N * 3], inv_fact[N * 3];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint solve(int n, int m, char* a, char* b, char* c, char* d)\n{\n    static int ways[2][N];\n    memset(ways, 0, sizeof(ways));\n    for (int _ = 0; _ < 2; ++ _) {\n        int C = 0;\n        for (int j = 0; j < m; ++ j) {\n            C += c[j] == '1';\n        }\n        int A = 0;\n        int B = 0;\n        for (int i = 0; i < n; ++ i) {\n            if (a[i] == '0' && b[i] == '0') {\n                continue;\n            }\n            if (C) {\n                ways[_][i] = (long long)fact[A + B + C - 1] * inv_fact[A + B] % MOD * inv_fact[C - 1] % MOD;\n            } else if (!A && !B) {\n                ways[_][i] = 1;\n            }\n            A += a[i] == '1';\n            B += b[i] == '1';\n        }\n        std::reverse(a, a + n);\n        std::reverse(b, b + n);\n        std::swap(a, b);\n        std::swap(c, d);\n    }\n    std::reverse(ways[1], ways[1] + n);\n    int result = 0;\n    int prefix = 0;\n    for (int i = 0; i < n; ++ i) {\n        update(prefix, ways[0][i]);\n        if (a[i] == '1' && b[i] == '1') {\n            prefix = 2LL * prefix % MOD;\n        }\n        update(result, (long long)prefix * ways[1][i] % MOD);\n    }\n    return result;\n}\n\nint main()\n{\n    inv_fact[1] = 1;\n    for (int i = 2; i < N * 3; ++ i) {\n        inv_fact[i] = (long long)(MOD - MOD / i) * inv_fact[MOD % i] % MOD;\n    }\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < N * 3; ++ i) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n        inv_fact[i] = (long long)inv_fact[i - 1] * inv_fact[i] % MOD;\n    }\n    int n, m;\n    static char a[N], b[N], c[N], d[N];\n    while (scanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d) == 6) {\n        int result = solve(n, m, a, b, c, d);\n        update(result, solve(m, n, c, d, a, b));\n        printf(\"%d\\n\", std::max(result, 1));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 400009\n#define ll long long\n#define mod 998244353\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\nusing namespace std;\n\nint m,n,a[N],b[N],fac[N],inv[N]; char A[N],B[N],C[N],D[N];\nint solve(int m,int n,char *A,char *B,char *C,char *D){\n\tint i,x,y;\n\tmemset(a,0,sizeof(a)); memset(b,0,sizeof(b));\n\ta[0]=b[n+1]=1;\n\tfor (i=1,y=0; i<=m; i++) if (A[i]=='1') y++;\n\tfor (i=1,x=0; i<=n; i++){\n\t\tif (C[i]=='1') x++;\n\t\tif (D[i]=='1') x++;\n\t\ta[i]=cbn(x+y,x);\n\t\tif (x) a[i]=(a[i]-cbn(x+y-1,x-1)+mod)%mod;\n\t\t//cout<<i<<' '<<a[i]<<endl;\n\t}\n\tfor (i=1,y=0; i<=m; i++) if (B[i]=='1') y++;\n\tfor (i=n,x=0; i; i--){\n\t\tif (C[i]=='1') x++;\n\t\tif (D[i]=='1') x++;\n\t\tb[i]=cbn(x+y,x);\n\t\tif (x>0) b[i]=(b[i]-cbn(x+y-1,x-1)+mod)%mod;\n\t\t//cout<<i<<' '<<b[i]<<endl;\n\t}\n\tint tmp;\n\tfor (i=0,tmp=1; i<=n; i++){\n\t\tif (i>0 && C[i]=='1' && D[i]=='1') tmp=(ll)tmp*(mod+1>>1)%mod;\n\t\ta[i]=(ll)a[i]*tmp%mod;\n\t\tif (i<=n && C[i+1]=='0' && D[i+1]=='0') a[i]=0;\n\t}\n\tfor (i=1; i<=n; i++) a[i]=(a[i]+a[i-1])%mod;\n\tfor (i=tmp=1; i<=n+1; i++){\n\t\tb[i]=(ll)b[i]*tmp%mod;\n\t\tif (i<=n && C[i]=='1' && D[i]=='1') tmp=tmp*2%mod;\n\t\tif (i>1 && C[i-1]=='0' && D[i-1]=='0') b[i]=0;\n\t}\n\tint ans=0;\n\tfor (i=1; i<=n; i++) ans=(ans+(ll)b[i+1]*a[i-1])%mod;\n\t//cout<<ans<<endl;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tint i;\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (i=1; i<=(m+n<<1); i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<=(m+n<<1); i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<=(m+n<<1); i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tprintf(\"%d\\n\",(solve(m,n,A,B,C,D)+solve(n,m,C,D,A,B))%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Sergey Kopeliovich (burunduk30@gmail.com)\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\nvoid add( int &a, int b ) { if ((a += b) >= MOD) a -= MOD; }\nint mul( int a, int b ) { return (ll)a * b % MOD; }\n\nconst int N = 2e6 + 3;\nint inv[N];\n\nstruct C {\n\tint n, k, r;\n\tC() {}\n\tC( int n, int k, int r = 1 ) : n(n), k(k), r(r) { }\n\tvoid dn() {\n\t\tr = mul(r, ++n);\n\t\tr = mul(r, inv[n - k]);\n\t}\n\tvoid dk() {\n\t\tr = mul(r, n - k++);\n\t\tr = mul(r, inv[k]);\n\t}\n};\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++) \n\t\tinv[i] = ((ll)(MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tint tmp1, tmp2;\n\tstring sa, sb, sc, sd;\n\tcin >> tmp1 >> tmp2 >> sa >> sb >> sc >> sd;\n\tauto ok = [&]( char c ) {\n\t\treturn c == '1';\n\t};\n\tauto get = [&]( string &s ) {\n\t\treturn count_if(s.begin(), s.end(), ok);\n\t};\n\n\tint res = 0;\n\tforn(_, 2) {\n\t\tint n = sa.size(), m = sc.size();\n\t\tint na = get(sa), nb = get(sb);\n\t\tvector<int> F1(n), F2(n);\n\t\tforn(__, 2) {\n\t\t\tint cnt_a = 0, cnt_b = 0, nc = get(sc);\n\t\t\tC c2(cnt_a + cnt_b + nc - 1, nc - 1);\n\t\t\tforn(i, n) {\n\t\t\t\tif (ok(sa[i]) || ok(sb[i])) {\n\t\t\t\t\tF1[i] = c2.r;\n\t\t\t\t\tif (ok(sa[i])) c2.dn(), cnt_a++;\n\t\t\t\t\tif (ok(sb[i])) c2.dn(), cnt_b++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(sc, sd), swap(F1, F2);\n\t\t\treverse(sa.begin(), sa.end());\n\t\t\treverse(sb.begin(), sb.end());\n\t\t}\n\t\treverse(F2.begin(), F2.end());\n\t\tint last = -1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tadd(F2[i], F2[i + 1]);\n\t\t\tif (ok(sa[i + 1]) + ok(sb[i + 1]) == 2)\n\t\t\t\tadd(F2[i], F2[i + 1]);\n\t\t}\n\t\tforn(i, n)\n\t\t\tif (ok(sa[i]) || ok(sb[i]))\n\t\t\t\tadd(res, mul(mul(F1[i], F2[i]), ok(sa[i]) + ok(sb[i])));\n\t\tswap(sa, sc), swap(sb, sd);\n\t}\n\tprintf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint a[100011][2],b[100011][2];\nlong long MOD=998244353;\nlong long fa[300011];\nlong long invfa[300011];\nlong long two[300011];\n\n\nint p[100011];\nint ppos[100011];\nint q[100011];\nint sp[100011];\nint sa[100011][2];\n\n\n//******************************\n//返回d=gcd(a,b);和对应于等式ax+by=d中的x,y\nlong long extend_gcd(long long a,long long b,long long &x,long long &y)\n{\n if(a==0&&b==0) return -1;//无最大公约数\n if(b==0){x=1;y=0;return a;}\n long long d=extend_gcd(b,a%b,y,x);\n y-=a/b*x;\n return d;\n}\n//*********求逆元素*******************\n//ax = 1(mod n)\nlong long mod_reverse(long long a,long long n)\n{\n long long x,y;\n long long d=extend_gcd(a,n,x,y);\n if(d==1) return (x%n+n)%n;\n else return -1;\n}\n\nlong long inv(long long a)\n{\n    return mod_reverse(a,MOD);\n}\n\n/* \nlong long exgcd(long long a,long long b,long long &x,long long &y)  \n{  \n    if(b==0)\n    {  \n        x=1;\n        y=0;\n        return a;\n    }\n    int r=exgcd(b,a%b,x,y);\n    long long t=y;\n    y=x-(a/b)*y;\n    x=t;\n    return r;\n}  \nlong long inv(long long a)  \n{  \n    long long x,y;  \n    long long r=exgcd(a,MOD,x,y);  \n    if(r==1) return (x%MOD+MOD)%MOD;  \n    return -1;  \n}\n*/\n\nlong long C(int n,int k)\n{\n    long long ans=fa[n]*invfa[k]%MOD*invfa[n-k]%MOD;\n    return ans;\n}\n\n\nlong long calc(long long x,long long y,long long z)\n{\n    if(x==0)\n    {\n        if(y==0 && z==0)return 1;\n        return 0;\n    }\n    \n    long long ans=(C(x+y+z,x)-C(x+y+z-1,x)+MOD)%MOD;\n    \n    \n    //cout<<\"calc\"<<' '<<x<<' '<<y<<' '<<z<<\"   \"<<ans<<endl;\n    \n    return ans;\n}\n\nlong long gao(int a[][2],int b[][2],int n,int m)\n{\n    int i,j,k;\n    int mm1,mm2;\n    mm1=mm2=0;\n    for(i=1;i<=m;i++)\n    {\n        mm1+=(b[i][0]==1);\n        mm2+=(b[i][1]==1);\n        \n        //cout<<b[i][0]<<' '<<b[i][1]<<endl;\n    }\n    \n    \n    \n    long long ans=0;\n    sa[0][0]=a[0][1]=0;\n    for(i=1;i<=n;i++)\n    {\n        sa[i][0]=sa[i-1][0]+a[i][0];\n        sa[i][1]=sa[i-1][1]+a[i][1];\n    }\n    \n    int nn=0;\n    for(i=1;i<=n;i++)\n    {\n        if(a[i][0]==1 && a[i][1]==1)\n        {\n            p[++nn]=2;\n            ppos[nn]=i;\n        }\n        else if(a[i][0]==1 || a[i][1]==1)\n        {\n            p[++nn]=1;\n            ppos[nn]=i;\n        }\n    }\n    sp[0]=0;\n    for(i=1;i<=nn;i++)\n    {\n        sp[i]=sp[i-1]+(p[i]==2);\n    }\n    \n    \n    long long tmp=0;\n    long long lans=1;\n    long long rans;\n    int ll,rr;\n    ll=1;\n    \n    \n    //cout<<mm1<<' '<<mm2<<\" mmm\"<<endl;\n    for(rr=1;rr<=nn;rr++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[rr]][0],sa[n][1]-sa[ppos[rr]][1]);\n        tmp=(tmp+lans*rans%MOD*two[sp[rr]-sp[ll-1]]%MOD)%MOD;\n    }\n    //cout<<\"tmp0\"<<tmp<<endl;\n    \n    ans=(ans+tmp)%MOD;\n    for(ll=2;ll<=nn;ll++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[ll-1]][0],sa[n][1]-sa[ppos[ll-1]][1]);\n        tmp=(tmp-lans*rans%MOD*two[sp[ll-1]-sp[ll-2]]%MOD+MOD)%MOD;\n        //cout<<tmp<<\"  &&&\"<<endl;\n        tmp=tmp*inv(lans)%MOD;\n        lans=calc(mm1,sa[ppos[ll]-1][0],sa[ppos[ll]-1][1]);\n        tmp=tmp*lans%MOD;\n        if(p[ll-1]==2)\n        {\n            tmp=tmp*inv(2)%MOD;\n        }\n        \n        //cout<<\"tmp\"<<tmp<<endl;\n        \n        ans=(ans+tmp)%MOD;\n    }\n    \n    \n    return ans;\n}\n\n\nint main()\n{\n    int i,j,k;\n    char c;\n    fa[0]=1;\n    invfa[0]=1;\n    for(i=1;i<=300000;i++)\n    {\n        fa[i]=(fa[i-1]*i)%MOD;\n        invfa[i]=inv(fa[i]);\n    }\n    two[0]=1;\n    for(i=1;i<=300000;i++)\n    {\n        two[i]=(two[i-1]*2)%MOD;\n    }\n    \n    \n    scanf(\"%d %d\",&n,&m);\n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=n;i++)\n    {\n        \n            scanf(\" %c\",&c);\n            a[i][j]=c-'0';\n    }\n    }\n    \n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=m;i++)\n    {\n            scanf(\" %c\",&c);\n            b[i][j]=c-'0';\n    }\n    }\n    \n    long long ans=0;\n    ans+=gao(a,b,n,m);\n    ans+=gao(b,a,m,n);\n    ans%=MOD;\n    cout<<(ans+MOD)%MOD<<endl;\n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define MOD 998244353\nLL powmod(LL a, LL n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a*powmod(a,n-1)) % MOD;\n\tLL c = powmod(a, n/2);\n\treturn (c*c) % MOD;\n}\nLL inv(LL a){\n\treturn powmod(a, MOD-2);\n}\nLL fact[1100000];\nLL invfact[1100000];\nLL p2[1100000];\nLL i2[1100000];\nLL ncr(LL n, LL r){\n\tif(r < 0 || n < 0) return 0;\n\tif(n < r) return 0;\n\tLL a = fact[n];\n\ta = (a * invfact[r]) % MOD;\n\ta = (a * invfact[n-r]) % MOD;\n\treturn a;\n}\nLL finalans = 0;\nLL solve2(LL a, LL b, LL c){\n\tif(b == 0){\n\t\tif(a == 0 && c == 0){\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(a == 0) return ncr(b-1+c,b-1);\n\tif(c == 0) return ncr(b-1+a,b-1);\n\treturn ncr(a-1+b+c-1+1,b-1);\n}\n\nvoid solve(string a, string b, string c, string d){\n\tLL na = 0;\n\tLL nb = 0;\n\tfor(int i = 0; i < a.size(); i++) na += a[i] - '0';\n\tfor(int i = 0; i < b.size(); i++) nb += b[i] - '0';\n\tLL lc = 0;\n\tLL rc = 0;\n\tLL ld = 0;\n\tLL rd = 0;\n\tLL l2 = 0;\n\tLL r2 = 0;\n\tfor(int i = 0; i < c.size(); i++) rc += c[i] - '0';\n\tfor(int i = 0; i < d.size(); i++) rd += d[i] - '0';\n\tfor(int i = 0; i < c.size(); i++){\n\t\tif(c[i] == '1' && d[i] == '1'){\n\t\t\tr2++;\n\t\t}\n\t}\n\n\n\tLL lsols = 0;\n\tLL ans = 0;\n\tfor(int i = 0; i < c.size(); i++){\n\t\trc -= (c[i] - '0');\n\t\trd -= (d[i] - '0');\n\t\tif(c[i] == '1' && d[i] == '1'){\n\t\t\tr2--;\n\t\t}\n\t\tif(c[i] == '0' && d[i] == '0') continue;\n\t\tLL rsol = solve2(rc, nb, rd);\n\t\trsol *= inv(p2[r2]);\n\t\trsol %= MOD;\n\n\t\tLL lsol = solve2(lc, na, ld);\n\t\tlsol *= inv(p2[l2]);\n\t\tlsol %= MOD;\n\t\tlsols = (lsols + lsol) % MOD;\n\n\t\tans += rsol * lsols;\n\t\tans %= MOD;\n\n\t\tlc += (c[i] - '0');\n\t\tld += (d[i] - '0');\n\t\tif(c[i] == '1' && d[i] == '1'){\n\t\t\tl2++;\n\t\t}\t\t\n\t}\n\tans *= p2[l2];\n\tans %= MOD;\n\t//cout << ans << endl;\n\tfinalans += ans;\n\tfinalans %= MOD;\n}\nint main(){\n\tfact[0] = 1;\n\tinvfact[0] = 1;\n\tp2[0] = 1;\n\tLL inv2 = inv(2);\n\tfor(LL i = 1; i < 1100000; i++){\n\t\tfact[i] = (i*fact[i-1]) % MOD;\n\t\tinvfact[i] = inv(fact[i]);\n\t\tp2[i] = (2*p2[i-1]) % MOD;\n\t\ti2[i] = (inv2*i2[i-1]) % MOD;\n\t}\n\n\tLL n, m;\n\tcin >> n >> m;\n\tstring a, b, c, d;\n\tcin >> a >> b >> c >> d;\n\tint n0 = 0;\n\tfor(int i = 0; i < a.size(); i++) n0 += a[i] - '0';\n\tfor(int i = 0; i < b.size(); i++) n0 += b[i] - '0';\n\tfor(int i = 0; i < c.size(); i++) n0 += c[i] - '0';\n\tfor(int i = 0; i < d.size(); i++) n0 += d[i] - '0';\n\tif(n0 == 0){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsolve(a,b,c,d);\n\tsolve(c,d,a,b);\n\tcout << finalans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nint fact[300001],ifact[300001];\nint ncr(int n,int r)\n{\n\treturn (ll)fact[n]*ifact[n-r]%MOD*ifact[r]%MOD;\n}\n\nvector<mint> calc(const vi& ls,const vi& ts,const vi& bs)\n{\n\tvi js=ts; js.insert(js.end(),all(bs));\n\tsort(all(js)); js.erase(unique(all(js)),end(js));\n\n\tvector<mint> cs;\n\tint ln=ls.size();\n\tfor(int j:js){\n\t\tint tn=lower_bound(all(ts),j)-begin(ts),bn=lower_bound(all(bs),j)-begin(bs);\n\t\tif(ln==0){\n\t\t\tif(tn+bn==0)\n\t\t\t\tcs.push_back(1);\n\t\t\telse\n\t\t\t\tcs.push_back(0);\n\t\t}\n\t\telse{\n\t\t\tcs.push_back(ncr(ln-1+tn+bn,tn+bn));\n\t\t}\n\t}\n\treturn cs;\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfact[0]=ifact[0]=1;\n\trepi(i,1,300001){\n\t\tfact[i]=(ll)fact[i-1]*i%MOD;\n\t\tifact[i]=mint(fact[i]).inv().val;\n\t}\n\n\tfor(int h,w;cin>>h>>w&&h|w;){\n\t\tstring a,b,c,d; cin>>a>>b>>c>>d;\n\n\t\tif(a==string(h,'0')&&b==string(h,'0')&&c==string(w,'0')&&d==string(w,'0')){\n\t\t\tcout<<1<<endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tmint res;\n\t\trep(_,2){\n\t\t\tvi ls,rs,ts,bs;\n\t\t\trep(i,h) if(a[i]=='1') ls.push_back(i);\n\t\t\trep(i,h) if(b[i]=='1') rs.push_back(i);\n\t\t\trep(i,w) if(c[i]=='1') ts.push_back(i);\n\t\t\trep(i,w) if(d[i]=='1') bs.push_back(i);\n\n\t\t\tvi js=ts; js.insert(js.end(),all(bs));\n\t\t\tsort(all(js)); js.erase(unique(all(js)),end(js));\n\n\t\t\tvi two(w+1);\n\t\t\trep(i,w) two[i+1]=two[i]+(c[i]=='1'&&d[i]=='1');\n\n\t\t\tvector<mint> dpl(js.size());\n\t\t\t{\n\t\t\t\tvector<mint> cs=calc(ls,ts,bs);\n\t\t\t\tmint prev=0;\n\t\t\t\trep(i,js.size()){\n\t\t\t\t\tint j=js[i];\n\t\t\t\t\tdpl[i]=prev+cs[i]*mint(2).pow(two[w]-two[j]);\n\t\t\t\t\tprev=dpl[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvi ts2(rbegin(ts),rend(ts)),bs2(rbegin(bs),rend(bs));\n\t\t\t\tfor(int& j:ts2) j=w-1-j;\n\t\t\t\tfor(int& j:bs2) j=w-1-j;\n\t\t\t\tvector<mint> cs=calc(rs,ts2,bs2);\n\t\t\t\treverse(all(cs));\n\t\t\t\trep(i,js.size()){\n\t\t\t\t\tint j=js[i];\n\t\t\t\t\tres+=dpl[i]*cs[i]/mint(2).pow(two[w]-two[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttie(h,w,a,b,c,d)=mt(w,h,c,d,a,b);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nvoid pob(vector<int>& res){\n  string z;\n  cin >> z; \n  R(i,SZ(z)){\n    if(z[i] == '1'){\n      res.PB(1);\n    }else\n      res.PB(0);\n  }\n}\n\nint jed(vector<int>& x){\n  int res = 0;\n  for(int el:x){\n    res += el;\n  }\n  return res;\n}\n\nconst int P = 998244353;\nconst int MAX = 4e5 + 10;\nint sil[MAX],od[MAX];\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    a = a * a % P;\n    w/=2;\n  }\n  return r;\n}\nint dwu(int a,int b){\n // debug(a,b, sil[a], od[b], od[a-b]);\n  return sil[a] * od[b] % P * od[a-b] % P;\n}\n\nvector<int> licz2(vector<int>&a,vector<int>& b,int x){\n  //TODO x = 0\n  int n = SZ(a);\n  vector<int> res;\n  int il = 0;\n//   bool cza = 0;\n//   bool czb = 0;\n  bool cz = 0;\n  R(i,n){\n    if(a[i] == 0 && b[i] == 0)\n      res.PB(0);\n    else{\n      if(x == 0){\n        if(!cz){\n          res.PB(1);\n        }else\n          res.PB(0);\n        cz = 1;\n      }else\n        res.PB(dwu(x + il - 1, x-1));\n    }\n//     if(a[i])cza = 1;\n//     if(b[i])czb = 1;\n    il += a[i];\n    il += b[i];\n  }\n  return res;\n}\n\nint licz(vector<int> a,vector<int> b,int x1,int x2){\n  int n = SZ(a);\n  vector<int> res1 = licz2(a,b,x1);\n  reverse(ALL(a));\n  reverse(ALL(b));\n  reverse(ALL(res1));\n  vector<int> res2 = licz2(a,b,x2);\n  debug(a,b,x1,x2,res1,res2);\n  int pom = 0;\n  int res = 0;\n  R(i,n){\n    pom += res2[i];\n    if(a[i] && b[i])pom *= 2;\n    pom %= P;\n    res += pom * res1[i];\n  }\n  return res;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  R(i,MAX-1){\n    sil[i+1] = sil[i] * (i + 1) % P;\n  }\n  R(i,MAX){\n    od[i] = pot(sil[i], P-2);\n  }\n  \n  \n  int n,m;\n  vector<int> a,b,c,d;\n  cin >> n >> m;\n  pob(a);\n  pob(b);\n  pob(c);\n  pob(d);\n  int res = licz(a,b,jed(c),jed(d));\n  res += licz(c,d,jed(a),jed(b));\n  cout << res % P << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint a[100011][2],b[100011][2];\nlong long MOD=998244353;\nlong long fa[200011];\nlong long invfa[200011];\nlong long two[200011];\n\n\nint p[100011];\nint ppos[100011];\nint q[100011];\nint sp[100011];\nint sa[100011][2];\n\n\n//******************************\n//返回d=gcd(a,b);和对应于等式ax+by=d中的x,y\nlong long extend_gcd(long long a,long long b,long long &x,long long &y)\n{\n if(a==0&&b==0) return -1;//无最大公约数\n if(b==0){x=1;y=0;return a;}\n long long d=extend_gcd(b,a%b,y,x);\n y-=a/b*x;\n return d;\n}\n//*********求逆元素*******************\n//ax = 1(mod n)\nlong long mod_reverse(long long a,long long n)\n{\n long long x,y;\n long long d=extend_gcd(a,n,x,y);\n if(d==1) return (x%n+n)%n;\n else return -1;\n}\n\nlong long inv(long long a)\n{\n    return mod_reverse(a,MOD);\n}\n\n/* \nlong long exgcd(long long a,long long b,long long &x,long long &y)  \n{  \n    if(b==0)\n    {  \n        x=1;\n        y=0;\n        return a;\n    }\n    int r=exgcd(b,a%b,x,y);\n    long long t=y;\n    y=x-(a/b)*y;\n    x=t;\n    return r;\n}  \nlong long inv(long long a)  \n{  \n    long long x,y;  \n    long long r=exgcd(a,MOD,x,y);  \n    if(r==1) return (x%MOD+MOD)%MOD;  \n    return -1;  \n}\n*/\n\nlong long C(int n,int k)\n{\n    long long ans=fa[n]*invfa[k]%MOD*invfa[n-k]%MOD;\n    return ans;\n}\n\n\nlong long calc(long long x,long long y,long long z)\n{\n    if(x==0)\n    {\n        if(y==0 && z==0)return 1;\n        return 0;\n    }\n    \n    long long ans=(C(x+y+z,x)-C(x+y+z-1,x)+MOD)%MOD;\n    \n    \n    //cout<<\"calc\"<<' '<<x<<' '<<y<<' '<<z<<\"   \"<<ans<<endl;\n    \n    return ans;\n}\n\nlong long gao(int a[][2],int b[][2],int n,int m)\n{\n    int i,j,k;\n    int mm1,mm2;\n    mm1=mm2=0;\n    for(i=1;i<=m;i++)\n    {\n        mm1+=(b[i][0]==1);\n        mm2+=(b[i][1]==1);\n        \n        //cout<<b[i][0]<<' '<<b[i][1]<<endl;\n    }\n    \n    \n    \n    long long ans=0;\n    sa[0][0]=a[0][1]=0;\n    for(i=1;i<=n;i++)\n    {\n        sa[i][0]=sa[i-1][0]+a[i][0];\n        sa[i][1]=sa[i-1][1]+a[i][1];\n    }\n    \n    int nn=0;\n    for(i=1;i<=n;i++)\n    {\n        if(a[i][0]==1 && a[i][1]==1)\n        {\n            p[++nn]=2;\n            ppos[nn]=i;\n        }\n        else if(a[i][0]==1 || a[i][1]==1)\n        {\n            p[++nn]=1;\n            ppos[nn]=i;\n        }\n    }\n    sp[0]=0;\n    for(i=1;i<=nn;i++)\n    {\n        sp[i]=sp[i-1]+(p[i]==2);\n    }\n    \n    \n    long long tmp=0;\n    long long lans=1;\n    long long rans;\n    int ll,rr;\n    ll=1;\n    \n    \n    //cout<<mm1<<' '<<mm2<<\" mmm\"<<endl;\n    for(rr=1;rr<=nn;rr++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[rr]][0],sa[n][1]-sa[ppos[rr]][1]);\n        tmp=(tmp+lans*rans%MOD*two[sp[rr]-sp[ll-1]]%MOD)%MOD;\n    }\n    //cout<<\"tmp0\"<<tmp<<endl;\n    \n    ans=(ans+tmp)%MOD;\n    for(ll=2;ll<=nn;ll++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[ll-1]][0],sa[n][1]-sa[ppos[ll-1]][1]);\n        tmp=(tmp-lans*rans%MOD*two[sp[ll-1]-sp[ll-2]]%MOD+MOD)%MOD;\n        //cout<<tmp<<\"  &&&\"<<endl;\n        tmp=tmp*inv(lans)%MOD;\n        lans=calc(mm1,sa[ppos[ll]-1][0],sa[ppos[ll]-1][1]);\n        tmp=tmp*lans%MOD;\n        if(p[ll-1]==2)\n        {\n            tmp=tmp*inv(2)%MOD;\n        }\n        \n        //cout<<\"tmp\"<<tmp<<endl;\n        \n        ans=(ans+tmp)%MOD;\n    }\n    \n    \n    return ans;\n}\n\n\nint main()\n{\n    int i,j,k;\n    char c;\n    fa[0]=1;\n    invfa[0]=1;\n    for(i=1;i<=200000;i++)\n    {\n        fa[i]=(fa[i-1]*i)%MOD;\n        invfa[i]=inv(fa[i]);\n    }\n    two[0]=1;\n    for(i=1;i<=200000;i++)\n    {\n        two[i]=(two[i-1]*2)%MOD;\n    }\n    \n    \n    scanf(\"%d %d\",&n,&m);\n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=n;i++)\n    {\n        \n            scanf(\" %c\",&c);\n            a[i][j]=c-'0';\n    }\n    }\n    \n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=m;i++)\n    {\n            scanf(\" %c\",&c);\n            b[i][j]=c-'0';\n    }\n    }\n    \n    long long ans=0;\n    ans+=gao(a,b,n,m);\n    ans+=gao(b,a,m,n);\n    ans%=MOD;\n    cout<<(ans+MOD)%MOD<<endl;\n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 301010;\nconst int MOD = 998244353;\nconst int INV = (MOD + 1) >> 1;\ntypedef long long ll;\n\nchar S[N];\nint fac[N << 2], inv[N << 2];\nint v[N][2], h[N][2];\nint pre[N], suf[N], p2[N];\nint n, m, lim, ans;\n\ninline void Mod(int &x) {\n\twhile (x >= MOD) x -= MOD;\n}\ninline int Pow(int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = (ll)c * a % MOD;\n\t\tb >>= 1; a = (ll)a * a % MOD;\n\t}\n\treturn c;\n}\ninline int Inv(int x) {\n\treturn Pow(x, MOD - 2);\n}\ninline int C(int n, int m) {\n\treturn (ll)fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\ninline int Calc(int X, int Y, int Z) {\n\tif (X == 0) return (Y + Z) ? 0: 1;\n\treturn C(X + Y + Z - 1, X - 1);\n}\ninline void Solve(void) {\n\tstatic int x, y, z;\n\tmemset(p2, 0, sizeof p2);\n\tmemset(suf, 0, sizeof suf);\n\tx = y = z = 0;\n\tfor (int i = 1; i <= n; i++) x += h[i][1];\n\tp2[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tMod(p2[i] = p2[i - 1] << (v[i][0] & v[i][1]));\n\tfor (int i = m; i; i--) {\n\t\tif (!v[i][0] && !v[i][1]) {\n\t\t\tsuf[i] = suf[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\tMod(suf[i] = suf[i + 1] + (ll)Calc(x, y, z) * p2[i] % MOD);\n\t\ty += v[i][0]; z += v[i][1];\n\t}\n\tx = y = z = 0;\n\tfor (int i = 1; i <= n; i++) x += h[i][0];\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!v[i][0] && !v[i][1]) continue;\n\t\tpre[i] = (ll)Calc(x, y, z) * Inv(p2[i - 1]) % MOD;\n\t\tMod(ans += (ll)pre[i] * suf[i] % MOD);\n\t\ty += v[i][0]; z += v[i][1];\n\t}\n}\n\n\nint main(void) {\n\tscanf(\"%d%d\\n\", &n, &m);\n\tlim = max(n, m) << 2;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= lim; i++)\n\t\tinv[i] = (ll)(MOD - MOD / i) * inv[MOD % i] % MOD;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= lim; i++) {\n\t\tfac[i] = (ll)fac[i - 1] * i % MOD;\n\t\tinv[i] = (ll)inv[i - 1] * inv[i] % MOD;\n\t}\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= n; i++) h[i][0] = S[i - 1] - '0';\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= n; i++) h[i][1] = S[i - 1] - '0';\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= m; i++) v[i][0] = S[i - 1] - '0';\n\tscanf(\"%s\\n\", S);\n\tfor (int i = 1; i <= m; i++) v[i][1] = S[i - 1] - '0';\n\tSolve(); lim >>= 2;\n\tfor (int i = 1; i <= lim; i++) {\n\t\tswap(h[i][0], v[i][0]);\n\t\tswap(h[i][1], v[i][1]);\n\t}\n\tswap(n, m); Solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpre=(pre+val)%p;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tbool died=true;\n\tfor(int i=1;i<=n;++i)\n\t\tif(A[i]=='1' or B[i]=='1' or C[i]=='1' or D[i]=='1')\n\t\t\t{died=false;break;}\n\tif(died){puts(\"1\");return 0;}\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 400005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool wflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') wflag = true;\n\t}\n\tbool hflag = false;\n\tfor(int i = 1; i <= h; i++){\n\t\tif(l[i] == '1' || r[i] == '1') hflag = true;\n\t}\n\tif(!wflag && !hflag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = 0;\n\tif(wflag) ans += calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tif(hflag) ans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define int long long\nconst int N=1e5+10,M=3e5+10,p=998244353,inv2=(p+1)>>1;\nint n,m,v[N];\nchar l[N],r[N],u[N],d[N];\nint fac[M],inv[M];\ninline int C(int x,int y){\n\treturn fac[x]*inv[x-y]%p*inv[y]%p;\n}\ninline int solve(int n,int m,char *l,char *r,char *u,char *d){\n\tmemset(v,0,sizeof v);\n\tint ln=count(l+1,l+n+1,'1');\n\tint rn=count(r+1,r+n+1,'1');\n\tint un=0,dn=0,qu1=1,qu2=1;\n\tfor (int i=1;i<=m;++i){//calc [1,i]\n\t\tif (u[i]=='0'&&d[i]=='0') {v[i]=v[i-1];continue;}\n\t\tif (ln==0) v[i]=(un==0&&dn==0); else v[i]=C(ln+un+dn-1,ln-1);\n\t\tv[i]=(v[i]*qu1+v[i-1])%p;\n\t\tif (u[i]=='1'&&d[i]=='1') qu1=qu1*inv2%p,qu2=qu2*2%p;\n\t\tun+=u[i]=='1';\n\t\tdn+=d[i]=='1';\n\t}\n\tint ans=0;\n\tun=dn=0;\n\tfor (int i=m;i;--i){\n\t\tif (u[i]=='0'&&d[i]=='0') continue;\n\t\tif (rn==0) ans=(ans+(un==0&&dn==0)*v[i]*qu2)%p; else ans=(ans+C(rn+un+dn-1,rn-1)*v[i]%p*qu2)%p;\n\t\tif (u[i]=='1'&&d[i]=='1') qu2=qu2*inv2%p;\n\t\tun+=u[i]=='1';\n\t\tdn+=d[i]=='1';\n\t}\n\treturn ans;\n}\nmain(){\n\tfac[0]=1;for (int i=1;i<M;++i) fac[i]=fac[i-1]*i%p;\n\tinv[0]=inv[1]=1;for (int i=2;i<M;++i) inv[i]=inv[p%i]*(p-p/i)%p;\n\tfor (int i=2;i<M;++i) inv[i]=inv[i]*inv[i-1]%p;\n\tscanf(\"%lld%lld%s%s%s%s\",&n,&m,l+1,r+1,u+1,d+1);\n\tprintf(\"%lld\",((solve(n,m,l,r,u,d)+solve(m,n,u,d,l,r))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 100001;\nconst int MOD = 998244353;\n\nint fact[N * 3], inv_fact[N * 3];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint solve(int n, int m, char* a, char* b, char* c, char* d)\n{\n    static int ways[2][N];\n    memset(ways, 0, sizeof(ways));\n    for (int _ = 0; _ < 2; ++ _) {\n        int C = 0;\n        for (int j = 0; j < m; ++ j) {\n            C += c[j] == '1';\n        }\n        int A = 0;\n        int B = 0;\n        for (int i = 0; i < n; ++ i) {\n            if (a[i] == '0' && b[i] == '0') {\n                continue;\n            }\n            if (C) {\n                ways[_][i] = (long long)fact[A + B + C - 1] * inv_fact[A + B] % MOD * inv_fact[C - 1] % MOD;\n            } else if (!A && !B) {\n                ways[_][i] = 1;\n            }\n            A += a[i] == '1';\n            B += b[i] == '1';\n        }\n        std::reverse(a, a + n);\n        std::reverse(b, b + n);\n        std::swap(c, d);\n    }\n    std::reverse(ways[1], ways[1] + n);\n    int result = 0;\n    int prefix = 0;\n    for (int i = 0; i < N; ++ i) {\n        update(prefix, ways[0][i]);\n        if (a[i] == '1' && b[i] == '1') {\n            prefix = 2LL * prefix % MOD;\n        }\n        update(result, (long long)prefix * ways[1][i] % MOD);\n    }\n    return result;\n}\n\nint main()\n{\n#ifdef LOCAL_JUDGE\n    freopen(\"E1.in\", \"r\", stdin);\n#endif\n    inv_fact[1] = 1;\n    for (int i = 2; i < N * 3; ++ i) {\n        inv_fact[i] = (long long)(MOD - MOD / i) * inv_fact[MOD % i] % MOD;\n    }\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < N * 3; ++ i) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n        inv_fact[i] = (long long)inv_fact[i - 1] * inv_fact[i] % MOD;\n    }\n    int n, m;\n    static char a[N], b[N], c[N], d[N];\n    while (scanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d) == 6) {\n        int result = solve(n, m, a, b, c, d);\n        update(result, solve(m, n, c, d, a, b));\n        printf(\"%d\\n\", result);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long fact[300009], factinv[300009], mod = 998244353;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 300000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 300000; i++) factinv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * factinv[r] % mod) * factinv[n - r] % mod;\n}\n\nlong long N, M, cnt, p1, p2, L1[100009], L2[100009]; string A, B, C, D;\n\nvoid dels() {\n\tcnt = 0; p1 = 0; p2 = 0;\n\tfor (int i = 0; i < 100009; i++) { L1[i] = 0; L2[i] = 0; }\n}\n\nlong long solve() {\n\tdels();\n\tfor (int i = 0; i < N; i++) { if (A[i] == '1' || B[i] == '1') cnt++; }\n\tfor (int i = 0; i < M; i++) { if (C[i] == '1') p1++; if (D[i] == '1') p2++; }\n\n\tint v = 0; L1[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL1[i + 1] = ncr(v + p1 - 1, p1 - 1);\n\t}\n\tv = 0; L2[N - 1] = 1;\n\tfor (int i = N - 1; i >= 1; i--) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL2[i - 1] = ncr(v + p2 - 1, p2 - 1);\n\t}\n\tlong long ret = 0, ans = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (A[i] == '1' || B[i] == '1') ret += L2[i];\n\t\tret %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ans += L1[i] * ret;\n\t\tif (A[i] == '1' || B[i] == '1') ans += L1[i] * ret;\n\t\tans %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ret *= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tinit();\n\tcin >> N >> M >> A >> B >> C >> D;\n\n\tlong long c1 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tlong long c2 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tcout << (c1 + c2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\n#define mo 998244353\n#define ll long long\nll inv[MAXN<<2],fac[MAXN<<2],n,x[MAXN],y[MAXN],z,ans,m;\nchar U[MAXN],D[MAXN],L[MAXN],R[MAXN];\ninline ll Cn(ll k,ll b)\n{\nreturn (ll)fac[k]*inv[b]%mo*inv[k-b]%mo;\n}\ninline void solve(int n,int m,char *L,char *R,char *U,char *D)\n{\n\tll tmp=0;\n\tint cl,cr,cu,cd,nowu,nowd,u,d;\n\tcl=cr=cu=cd=nowu=nowd=u=d=0;\n\tfor(int i=1;i<=n;i++) cl+=L[i]-'0',cr+=R[i]-'0';\n\tfor(int i=1;i<=m;i++) cd+=D[i]-'0',cu+=U[i]-'0';\n\tif(cl+cd==0){cout<<\"1\";exit(0);}\n\ttmp=1;\n//\tcout<<cl<<\" \"<<cr<<\" \"<<cd<<\" \"<<cu<<\" \"<<tmp<<endl;\n\tfor(int i=1;i<=m;i++){\n\t\tnowu+=(u=U[i]-'0');nowd+=(d=D[i]-'0');\n\t\tif(u||d){\n\t\t\tif(u&&d) tmp=tmp*2%mo;\n\t\t\tif(cr!=0) ans=(ans+tmp*Cn(cr+cu+cd-nowu-nowd-1,cr-1))%mo;\n\t\t\telse ans+=(cu+cd-nowu-nowd==0)%mo;\n\t\t\tif(cl!=0) tmp=(tmp+Cn(cl+nowu+nowd-1,cl-1))%mo;\n\t\t\telse tmp+=(nowu+nowd==0);\n//\t\t\tcout<<ans<<\" \"<<tmp<<endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfac[0]=1;inv[1]=inv[0]=1;\n\tfor(int i=1;i<=3*MAXN;i++) fac[i]=fac[i-1]*i%mo;\n\tfor(int i=2;i<=3*MAXN;i++) inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=3*MAXN;i++) inv[i]=(ll)inv[i]*inv[i-1]%mo;\n//\tfor(int i=1;i<=n+m<<1;i++) cout<<inv[i]<<endl;\n\tscanf(\"%s%s%s%s\",L+1,R+1,U+1,D+1);\n\tsolve(n,m,L,R,U,D);\n\tsolve(m,n,U,D,L,R);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#define MOD 998244353\ntypedef long long ll; \ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll fact[300005], inv[300005], dp[300005], ans; \ninline ll C(int n, int m)\n{\n\tif (n == -1 && m == -1)\n\t\treturn 1; \n\tif (n < m || m < 0)\n\t\treturn 0; \n\treturn fact[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\ninline void work(int n, int m, char *a, char *b, char *c, char *d)\n{\n\tint x = 0, y = 0, z = 0, w = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tx += a[i] == '1';\n\t\ty += b[i] == '1';\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tz += c[i] == '1';\n\t\tw += d[i] == '1';\n\t}\n\tif (!x && !y && !z && !w)\n\t{\n\t\tputs(\"1\");\n\t\texit(0);\n\t}\n\tz = w = 0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tdp[i] = i ? dp[i - 1] : 0;\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t\t(dp[i] += C(z + w + x - 1, x - 1)) %= MOD;\n\t\tif (c[i] == '1' && d[i] == '1')\n\t\t\t(dp[i] <<= 1) %= MOD;\n\t\tz += c[i] == '1';\n\t\tw += d[i] == '1';\n\t}\n\tz = w = 0;\n\tfor (int i = m - 1; i >= 0; i--)\n\t{\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t\t(ans += dp[i] * C(z + w + y - 1, y - 1)) %= MOD;\n\t\tz += c[i] == '1';\n\t\tw += d[i] == '1';\n\t}\n}\nchar a[300005], b[300005], c[300005], d[300005]; \nint main()\n{\n\t// freopen(\"CF17-QA-E.in\", \"r\", stdin);\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= 3e5; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinv[i] = quick_pow(fact[i], MOD - 2);\n\t}\n\tint n, m;\n\tscanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d);\n\twork(n, m, a, b, c, d);\n\twork(m, n, c, d, a, b);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst long N = 300005, mod = 998244353;\nlong a[N], b[N], c[N], d[N], suma, sumb, sumd, sumc, inv[N], fac[N], n, m;\nchar s[N];\nlong qow(long a, long b)\n{\n\tlong ans = 1;\n\tfor (; b; b >>= 1)\n\t{\n\t\tif (b & 1)\n\t\t\tans = ans * a % mod;\n\t\ta = a * a % mod;\n\t}\n\treturn ans;\n}\nlong C(long x, long y)\n{\n\treturn fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\nlong solve(long n, long m, long *a, long *b, long *c, long *d, long cna, long cnb, long cnc, long cnd)\n{\n\tlong ans = 0, cur = 0, leu = 0, led = 0;\n\tfor (long i = 1; i <= n; i++)\n\t\tif (a[i] || b[i])\n\t\t{\n\t\t\t(cur += (cnc ? C(leu + led + cnc - 1, cnc - 1) : (leu + led == 0))) %= mod;\n\t\t\tif (a[i] && b[i])\n\t\t\t\tcur = cur * 2 % mod;\n\t\t\tif (a[i])\n\t\t\t{\n\t\t\t\tleu++;\n\t\t\t\tcna--;\n\t\t\t}\n\t\t\tif (b[i])\n\t\t\t{\n\t\t\t\tled++;\n\t\t\t\tcnb--;\n\t\t\t}\n\t\t\t(ans += (cnd ? cur * C(cna + cnb + cnd - 1, cnd - 1) : (cna + cnb == 0))) %= mod;\n\t\t}\n\treturn ans;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tcin >> n >> m;\n\tfac[0] = 1;\n\tfor (long i = 1; i < 300001; i++)\n\t\tfac[i] = fac[i - 1] * i % mod;\n\tinv[N - 5] = qow(fac[N - 5], mod - 2);\n\tfor (long i = N - 6; ~i; i--)\n\t\tinv[i] = inv[i + 1] * (i + 1) % mod;\n\tcin >> s + 1;\n\tfor (long i = 1; i <= n; i++)\n\t\tsuma += (a[i] = s[i] == '1');\n\tcin >> s + 1;\n\tfor (long i = 1; i <= n; i++)\n\t\tsumb += (b[i] = s[i] == '1');\n\tcin >> s + 1;\n\tfor (long i = 1; i <= m; i++)\n\t\tsumc += (c[i] = s[i] == '1');\n\tcin >> s + 1;\n\tfor (long i = 1; i <= m; i++)\n\t\tsumd += (d[i] = s[i] == '1');\n\tif ((suma | sumb | sumc | sumd) == 0)\n\t\tcout << 1;\n\telse\n\t\tcout << (solve(n, m, a, b, c, d, suma, sumb, sumc, sumd) + solve(m, n, c, d, a, b, sumc, sumd, suma, sumb)) % mod, 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=998244353;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint calc(int L,int u,int d){\n    if(L==0){\n        return u==0&&d==0;\n    }\n\n    return nCk(L-1+u+d,u+d);\n}\n\nint solve(string A,string B,int L,int R){\n    int ret=0;\n\n    int sum=0;\n    int u=0,d=0;\n\n    int U=count(all(A),'1');\n    int D=count(all(B),'1');\n\n    for(int i=0;i<A.size();i++){\n        if(A[i]=='0'&&B[i]=='0')continue;\n        add(sum,calc(L,u,d));\n        if(A[i]=='1'&&B[i]=='1')sum=sum*2%mod;\n        u+=A[i]=='1';\n        d+=B[i]=='1';\n        add(ret,sum*calc(R,U-u,D-d)%mod);\n    }\n    return ret;\n}\n\nsigned main(){\n    int N,M;\n    string A,B,C,D;\n    cin>>N>>M>>A>>B>>C>>D;\n\n    int ans=0;\n    add(ans,solve(A,B,count(all(C),'1'),count(all(D),'1')));\n    add(ans,solve(C,D,count(all(A),'1'),count(all(B),'1')));\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\n//initfact();\nconst uint mod=998244353;\n//const uint mod=1000000007;\n//uint mod=1;\nstruct mint{\n\tuint v;\n\tmint(ll vv=0){s(vv%mod+mod);}\n\tmint& s(uint vv){\n\t\tv=vv<mod?vv:vv-mod;\n\t\treturn *this;\n\t}\n\tmint operator-()const{return mint()-*this;}\n\tmint& operator+=(const mint&rhs){return s(v+rhs.v);}\n\tmint&operator-=(const mint&rhs){return s(v+mod-rhs.v);}\n\tmint&operator*=(const mint&rhs){\n\t\tv=ull(v)*rhs.v%mod;\n\t\treturn *this;\n\t}\n\tmint&operator/=(const mint&rhs){return *this*=rhs.inv();}\n\tmint operator+(const mint&rhs)const{return mint(*this)+=rhs;}\n\tmint operator-(const mint&rhs)const{return mint(*this)-=rhs;}\n\tmint operator*(const mint&rhs)const{return mint(*this)*=rhs;}\n\tmint operator/(const mint&rhs)const{return mint(*this)/=rhs;}\n\tmint pow(int n)const{\n\t\tmint res(1),x(*this);\n\t\twhile(n){\n\t\t\tif(n&1)res*=x;\n\t\t\tx*=x;\n\t\t\tn>>=1;\n\t\t}\n\t\treturn res;\n\t}\n\tmint inv()const{return pow(mod-2);}\n\t/*mint inv()const{\n\t\tint x,y;\n\t\tint g=extgcd(v,mod,x,y);\n\t\tassert(g==1);\n\t\tif(x<0)x+=mod;\n\t\treturn mint(x);\n\t}*/\n\tfriend ostream& operator<<(ostream&os,const mint&m){\n\t\treturn os<<m.v;\n\t}\n\tbool operator<(const mint&r)const{return v<r.v;}\n\tbool operator==(const mint&r)const{return v==r.v;}\n};\n\nconst int vmax=(1<<21)+10;\nmint fact[vmax],finv[vmax],invs[vmax];\nvoid initfact(){\n\tfact[0]=1;\n\trng(i,1,vmax){\n\t\tfact[i]=fact[i-1]*i;\n\t}\n\tfinv[vmax-1]=fact[vmax-1].inv();\n\tfor(int i=vmax-2;i>=0;i--){\n\t\tfinv[i]=finv[i+1]*(i+1);\n\t}\n\tfor(int i=vmax-1;i>=1;i--){\n\t\tinvs[i]=finv[i]*fact[i-1];\n\t}\n}\nmint choose(int n,int k){\n\treturn fact[n]*finv[n-k]*finv[k];\n}\nmint binom(int a,int b){\n\treturn fact[a+b]*finv[a]*finv[b];\n}\nmint catalan(int n){\n\treturn binom(n,n)-(n-1>=0?binom(n-1,n+1):0);\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tinitfact();\n\t\n\tauto waf=[&](int a,int b,int c){\n\t\tif(a==0){\n\t\t\tif(b==0&&c==0)return mint(1);\n\t\t\treturn mint(0);\n\t\t}\n\t\treturn binom(a-1,b+c);\n\t};\n\t\n\tint n,m;cin>>n>>m;\n\tstring a,b,c,d;cin>>a>>b>>c>>d;\n\t\n\t\n\tmint ans;\n\tbool none=true;\n\trep(_,2){\n\t\tint left=count(all(a),'1');\n\t\tint right=count(all(b),'1');\n\t\t\n\t\tif(left||right)none=false;\n\t\t\n\t\tvc<mint> way[2];\n\t\trep(k,2){\n\t\t\tway[k].resize(m);\n\t\t\tint up=0,lw=0;\n\t\t\trep(i,m)if(c[i]=='1'||d[i]=='1'){\n\t\t\t\tway[k][i]=waf(left,up,lw);\n\t\t\t\tup+=c[i]-'0';\n\t\t\t\tlw+=d[i]-'0';\n\t\t\t}\n\t\t\treverse(all(c));\n\t\t\treverse(all(d));\n\t\t\tswap(left,right);\n\t\t}\n\t\treverse(all(way[1]));\n\t\tdmp(way[0]);\n\t\tdmp(way[1]);\n\t\t\n\t\tmint cur=0;\n\t\trep(i,m)if(c[i]=='1'||d[i]=='1'){\n\t\t\tcur+=way[0][i];\n\t\t\tint w=c[i]-'0'+d[i]-'0';\n\t\t\tcur*=w;\n\t\t\tans+=cur*way[1][i];\n\t\t}\n\t\t\n\t\tswap(a,c);\n\t\tswap(b,d);\n\t\tswap(n,m);\n\t}\n\t\n\tif(none)ans=1;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = (1e5 + 10) * 3, P = 998244353;\ninline void pp(int &x,int d){if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b){return ll(a)*b%P;}\nint fac[N] = {1} , ifac[N] , pw[N] = {1} , ipw[N] = {1};\nint inv(int x){return x == 1 ? 1 : P-ll(P/x)*inv(P%x)%P;}\ninline int comb(int a,int b){return mul(fac[a],mul(ifac[b],ifac[a-b]));}\nint n , m , lsum[N];\nstring A , B , C , D;\n\nint solve(){\n    int left = 0;\n    for(auto ch : A) left += ch == '1';\n    int base = 0 , up = 0 , down = 0;\n    rep(i,0,m) {\n        lsum[i] = i ? lsum[i-1] : 0;\n        if(C[i] == '1' || D[i] == '1') {\n            if(left == 0) pp(lsum[i] , mul(ipw[base] , up == 0 && down == 0));\n            else pp(lsum[i] , mul(ipw[base] , comb(left + up + down - 1 , left - 1)));\n        }\n        up += C[i] == '1';\n        down += D[i] == '1';\n        if(C[i] == '1' && D[i] == '1') base++;\n    }\n    int right = 0;\n    for(auto ch : B) right += ch == '1';\n    base = 0 , up = 0 , down = 0;\n    int res = 0;\n    per(i,0,m) {\n        int tmp = 0;\n        if(right == 0) tmp = mul(ipw[base] , up == 0 && down == 0);\n        else tmp = mul(ipw[base] , comb(right + up + down - 1 , right - 1));\n        up += C[i] == '1';\n        down += D[i] == '1';\n        if(C[i] == '1' || D[i] == '1') pp(res , mul(lsum[i] , tmp));\n        if(C[i] == '1' && D[i] == '1') base++;\n    }\n    return mul(res , pw[base]);\n}\n\nint main(){\n    rep(i,1,N) fac[i] = mul(fac[i-1] , i);\n    ifac[N-1] = inv(fac[N-1]);\n    per(i,1,N) ifac[i-1] = mul(ifac[i] , i);\n    int inv2 = inv(2);\n    rep(i,1,N) pw[i] = mul(pw[i-1] , 2);\n    rep(i,1,N) ipw[i] = mul(ipw[i-1] , inv2);\n    cin >> n >> m;\n    cin >> A >> B >> C >> D;\n    int ans = solve();\n    swap(n , m);\n    swap(A , C);\n    swap(B , D);\n    pp(ans , solve());\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate <class T>\nT inverse(T a, T m) {\n    T u=0,v=1;\n    while(a!=0){\n        T t=m/a;\n        m-=t*a;std::swap(a,m);\n        u-=t*v;std::swap(u,v);\n    }\n    assert(m==1);\n    return u;\n}\ntemplate <class T>\nclass modular {\n    public:\n        int value;\n        constexpr modular() = default;\n        constexpr modular(const modular&) = default;\n        constexpr modular(modular&&) = default;\n        modular& operator=(const modular&) = default;\n        modular& operator=(modular&&) = default;\n        template <class U>modular (const U& x) {value = normalize(x);}\n\n        template <class U>\n            static int normalize(const U& x) {\n                int v=static_cast<int>(-mod()<=x&&x<mod()?x:x%mod());\n                if(v<0)v+=mod();\n                return v;\n            }\n\n        template <class U> explicit operator U()const{return static_cast<U>(value);}\n        constexpr static auto mod(){return T::value;}\n\n        auto&operator+=(const modular&other) {if((value+=other.value)>=mod())value-=mod();return *this;}\n        auto&operator-=(const modular& other){if ((value-=other.value)<0)value+=mod();return *this;}\n        template <class U>auto& operator+=(const U& other){return*this+=modular(other);}\n        template <class U>auto& operator-=(const U& other){return*this-=modular(other);}\n        auto operator-()const{return modular(-value);}\n        auto&operator++(){return*this+=1;}\n        auto&operator--(){return*this-=1;}\n        auto operator++(int){modular result(*this);operator++();return result;}\n        auto operator--(int){modular result(*this);operator--();return result;}\n\n        template <class U = T>\n            auto&operator*=(const modular&rhs){value=normalize(static_cast<std::int64_t>(value)*static_cast<std::int64_t>(rhs.value));return *this;}\n        auto&operator/=(const modular&rhs){return*this*=modular(inverse(rhs.value, mod()));}\n};\ntemplate<class T>struct is_modular:std::false_type{};\ntemplate<class T>struct is_modular <modular<T>>:std::true_type{};\ntemplate<class T>constexpr bool is_modular_v=is_modular<T>::value;\ntemplate<class T> bool operator==(const modular<T>& lhs, const modular<T>& rhs){return lhs.value==rhs.value;}\ntemplate<class T,class U>bool operator==(const modular<T>& lhs, U rhs){return lhs==modular<T>(rhs);}\ntemplate<class T,class U>bool operator==(U lhs, const modular<T>& rhs){return modular<T>(lhs)==rhs;}\ntemplate<class T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs){return !(lhs == rhs);}\ntemplate<class T,class U> bool operator!=(const modular<T>& lhs, U rhs){return !(lhs==rhs);}\ntemplate<class T,class U> bool operator!=(U lhs, const modular<T>& rhs){return !(lhs==rhs);}\ntemplate<class T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T,class U> modular<T> operator+(const modular<T>& lhs, U rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T,class U> modular<T> operator+(U lhs, const modular<T>& rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T,class U> modular<T> operator-(const modular<T>& lhs, U rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T,class U> modular<T> operator-(U lhs, const modular<T>& rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T,class U> modular<T> operator*(const modular<T>& lhs, U rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T,class U> modular<T> operator*(U lhs, const modular<T>& rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U> modular<T> operator/(const modular<T>& lhs, U rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U> modular<T> operator/(U lhs, const modular<T>& rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U>\nmodular<T> power (const modular<T>& a, U b) {\n    assert(b>=0);\n    modular<T>x=a,ret=1;\n    for (;b>0;b/=2){\n        if(b%2==1)ret*=x;\n        x*=x;\n    }\n    return ret;\n}\ntemplate <class T>std::string to_string(const modular<T>& a) {\n    return std::to_string(a.value);\n}\ntemplate <class T>auto operator<<\n(std::ostream& os, const T& a)->std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a.value;\n}\ntemplate <class T>auto operator>>\n(std::istream& is, T& a)-> std::enable_if_t<is_modular_v<T>, std::istream&> {\n    long long x;is>>x;\n    a=T(x);\n    return is;\n}\n\n// using mod_type = int;\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 998'244'353;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\n\nint N;\nstd::vector<mint>fact,finv;\nvoid init(int n){\n    N=n;\n    fact.resize(n+1);\n    finv.resize(n+1);\n    fact.at(0)=1;\n    for(int i=1;i<=n;i++)fact.at(i)=fact.at(i-1)*i;\n    finv.at(n)=1/fact.at(n);\n    for(int i=n;i>=1;i--)finv.at(i-1)=finv.at(i)*i;\n    assert(finv.at(0)==1);\n}\nmint binom(int n,int k){\n    assert(0<=n);\n    if(k<0||n<k)return 0;\n    return fact.at(n)*finv.at(k)*finv.at(n-k);\n}\n\nint main(){\n    int h,w;std::cin>>h>>w;\n    init(2*(h+w)+1);\n    std::string sa,sb,sc,sd;std::cin>>sa>>sb>>sc>>sd;\n    int A=std::count(sa.begin(),sa.end(),'1');\n    int B=std::count(sb.begin(),sb.end(),'1');\n    int C=std::count(sc.begin(),sc.end(),'1');\n    int D=std::count(sd.begin(),sd.end(),'1');\n    mint ans=0;\n    auto cal=[&](int a, int c, int d)->mint{\n        if(a==0)return c==0&&d==0;\n        return binom(a-1+c+d,a-1);\n    };\n    for(int ngtkana=0;ngtkana<2;ngtkana++){\n        // 縦に貫いている中で最も左のものがこれであるときの、\n        // それ以右の場合の数です。\n        // そこに c も d もいない場合は累積和の伝播のためだけに使います。\n        std::vector<mint>right(w+1);\n        int c=0,d=0;\n        for(int j=w-1;j>=0;j--){\n            right.at(j)=right.at(j+1);\n            if(sc.at(j)=='1'||sd.at(j)=='1')\n                right.at(j)+=cal(B,c,d);\n            if(sc.at(j)=='1'&&sd.at(j)=='1')right.at(j)*=2;\n            c+=sc.at(j)=='1';\n            d+=sd.at(j)=='1';\n        }\n\n        // 縦に貫いている中で最も左がこれであるときの、\n        // それよりも左の場合の数と、畳み込んでいきます。\n        c=0,d=0;\n        for(int j=0;j<w;j++){\n            if(sc.at(j)=='1'||sd.at(j)=='1'){\n                ans+=cal(A,c,d)*right.at(j);\n            }\n            c+=sc.at(j)=='1';\n            d+=sd.at(j)=='1';\n        }\n        std::swap(sa,sc);\n        std::swap(sb,sd);\n        std::swap(A,C);\n        std::swap(B,D);\n        std::swap(h,w);\n    }\n    std::cout<<ans<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpre=(pre+val)%p;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tbool died=true;\n\tfor(int i=1;i<=n;++i)\n\t\tif(A[i]=='1' or B[i]=='1' or C[i]=='1' or D[i]=='1')\n\t\t\t{died=false;break;}\n\tif(died){puts(\"1\");return 0;}\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=400005,mod=998244353;\nint fac[N],rev[N],f[N],pre[N],t[N],p2[N],ip2[N],n,m,ans;\nchar A[N],B[N],C[N],D[N];\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1)res=(ll)res*x%mod;\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;\n\trep(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\trev[n]=power(fac[n],mod-2);\n\tper(i,n,1) rev[i-1]=(ll)rev[i]*i%mod;\n\tp2[0]=1,ip2[0]=1;\n\trep(i,1,n) p2[i]=2*p2[i-1]%mod;\n\trep(i,1,n) ip2[i]=(ll)(mod/2+1)*ip2[i-1]%mod;\n}\nint Co(int n,int m){\n\treturn n==-1&&m==-1?1:(m<0||m>n?0:(ll)fac[n]*rev[m]%mod*rev[n-m]%mod);\n}\n\nvoid solve(int n,int m){\n\tint ca=0,cb=0;\n\trep(i,1,n) ca+=A[i]-'0',cb+=B[i]-'0';\n\trep(i,1,m) t[i]=t[i-1]+(C[i]=='1'&&D[i]=='1');\n\tint cnt=0;\n\trep(i,1,m){\n\t\tcnt+=(C[i-1]=='1');\n\t\tcnt+=(D[i-1]=='1');\n\t\tpre[i]=pre[i-1];\n\t\tif(C[i]=='1'||D[i]=='1'){\n\t\t\tf[i]=Co(ca+cnt-1,ca-1)*(1+t[i]-t[i-1])%mod;\n\t\t\tpre[i]=(pre[i]+(ll)f[i]*ip2[t[i]])%mod;\n\t\t}\n\t}\n\tcnt=0;\n\tper(i,m,1){\n\t\tcnt+=(C[i+1]=='1');\n\t\tcnt+=(D[i+1]=='1');\n\t\tif(C[i]=='1'||D[i]=='1'){\n\t\t\tint owo=Co(cb+cnt-1,cb-1); \n\t\t\tans=(ans+(ll)owo*f[i])%mod;\n\t\t\tans=(ans+(ll)owo*pre[i-1]%mod*p2[t[i]])%mod;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit(400000);\n\tread(n),read(m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tsolve(n,m);\n\tswap(A,C),swap(B,D);\n\tsolve(m,n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100010;\nconst int MOD = 998244353;\nint _w;\n\nint n, m, up[MAXN], down[MAXN], left[MAXN], right[MAXN];\n\nnamespace NT {\n\tint fac[MAXN*3], ifac[MAXN*3];\n\tint fpow( int a, int b ) {\n\t\tint c = 1;\n\t\twhile(b) {\n\t\t\tif( b & 1 ) c = int((ll)c * a % MOD);\n\t\t\ta = int((ll)a * a % MOD);\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn c;\n\t}\n\tint inv( int a ) {\n\t\treturn fpow(a, MOD-2);\n\t}\n\tvoid prelude() {\n\t\tfac[0] = 1;\n\t\tfor( int i = 1; i < MAXN*3; ++i )\n\t\t\tfac[i] = int((ll)fac[i-1] * i % MOD);\n\t\tifac[MAXN*3-1] = inv(fac[MAXN*3-1]);\n\t\tfor( int i = MAXN*3-1; i > 0; --i )\n\t\t\tifac[i-1] = int((ll)ifac[i] * i % MOD);\n\t}\n\tint C( int n, int m ) {\n\t\treturn int((ll)fac[n] * ifac[m] % MOD * ifac[n-m] % MOD);\n\t}\n}\nusing NT::C;\n\nint calc( int a, int b, int c ) {\n\treturn a ? C(a+b+c-1, a-1) : (b+c ? 0 : 1);\n}\n\nint solven() {\n\tint ltot = 0, rtot = 0, utot = 0, dtot = 0, uc = 0, dc = 0;\n\tfor( int i = 1; i <= n; ++i )\n\t\tltot += left[i], rtot += right[i];\n\tfor( int i = 1; i <= m; ++i )\n\t\tutot += up[i], dtot += down[i];\n\t// printf( \"ltot = %d, rtot = %d, utot = %d, dtot = %d\\n\", ltot, rtot, utot, dtot );\n\tint ans = 0, sl = 1;\n\tfor( int R = 1; R <= m; ++R ) {\n\t\tif( !up[R] && !down[R] ) continue;\n\t\tif( up[R] && down[R] ) sl = (sl<<1) % MOD;\n\t\tans = int(ans + (ll)sl * calc(rtot, utot-uc-up[R], dtot-dc-down[R]) % MOD) % MOD;\n\t\tuc += up[R], dc += down[R];\n\t\tsl = (sl + calc(ltot, uc, dc)) % MOD;\n\t}\n\t// printf( \"solven = %d\\n\", ans );\n\treturn ans;\n}\n\nint solvem() {\n\tint utot = 0, dtot = 0, ltot = 0, rtot = 0, lc = 0, rc = 0;\n\tfor( int i = 1; i <= m; ++i )\n\t\tutot += up[i], dtot += down[i];\n\tfor( int i = 1; i <= n; ++i )\n\t\tltot += left[i], rtot += right[i];\n\tint ans = 0, su = 1;\n\tfor( int D = 1; D <= n; ++D ) {\n\t\tif( !left[D] && !right[D] ) continue;\n\t\tif( left[D] && right[D] ) su = (su<<1) % MOD;\n\t\tans = int(ans + (ll)su * calc(dtot, ltot-lc-left[D], rtot-rc-right[D]) % MOD) % MOD;\n\t\tlc += left[D], rc += right[D];\n\t\tsu = (su + calc(utot, lc, rc)) % MOD;\n\t}\n\t// printf( \"solvem = %d\\n\", ans );\n\treturn ans;\n}\n\nint main() {\n\tNT::prelude();\n\t_w = scanf( \"%d%d\", &n, &m );\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tleft[i] = ch - '0';\n\t}\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tright[i] = ch - '0';\n\t}\n\tfor( int i = 1; i <= m; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tup[i] = ch - '0';\n\t}\n\tfor( int i = 1; i <= m; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tdown[i] = ch - '0';\n\t}\n\tprintf( \"%d\\n\", max((solven() + solvem()) % MOD, 1) );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 100010;\nconst LL mod = 998244353;\nLL fct[MC*3];\nLL inv[MC*3];\nint N,M;\nbool A[MC] , B[MC] , C[MC] , D[MC];\nint cA,cB,cC,cD;\n\nvoid build(){\n\tfct[0] = 1;\n\trepp(i,1,MC*3) fct[i] = fct[i-1] * i % mod;\n\tLL z = fct[MC*3-1];\n\tinv[MC*3-1] = 1;\n\tfor(int i = mod-2 ; i > 0 ; i >>= 1){\n\t\tif(i%2) (inv[MC*3-1] *= z) %= mod;\n\t\tz = z * z % mod;\n\t}\n\trepm(i,MC*3-1,0) inv[i-1] = inv[i] * i % mod;\n}\n\nLL comb(int x , int y){\n\treturn fct[x+y] * inv[x] % mod * inv[y] % mod;\n}\n\nLL solve(){\n\tint w = cA , x = cB , y = 0 , z = 0;\n\tLL rv = 0 , tmp = 0;\n\trepp(i,0,N){\n\t\tif(A[i]||B[i]){\n\t\t\t(tmp += (cC?comb(y+z,cC-1):(y+z==0))) %= mod;\n\t\t\tif(A[i]&&B[i]) (tmp *= 2) %= mod;\n\t\t\tif(A[i]){--w; ++y;}\n\t\t\tif(B[i]){--x; ++z;}\n\t\t\t(rv += tmp * (cD?comb(w+x,cD-1):(w+x==0))) %= mod;\n\t\t}\n\t}\n\treturn rv;\n}\n\nint main(){\n\tbuild();\n\tscanf(\"%d%d\" , &N , &M);\n\trepp(i,0,N){\n\t\tchar z;\n\t\tscanf(\" %c\" , &z);\n\t\tA[i] = z == '1';\n\t\tif(A[i]) ++cA;\n\t}\n\trepp(i,0,N){\n\t\tchar z;\n\t\tscanf(\" %c\" , &z);\n\t\tB[i] = z == '1';\n\t\tif(B[i]) ++cB;\n\t}\n\trepp(i,0,M){\n\t\tchar z;\n\t\tscanf(\" %c\" , &z);\n\t\tC[i] = z == '1';\n\t\tif(C[i]) ++cC;\n\t}\n\trepp(i,0,M){\n\t\tchar z;\n\t\tscanf(\" %c\" , &z);\n\t\tD[i] = z == '1';\n\t\tif(D[i]) ++cD;\n\t}\n\tif(cA + cB + cC + cD == 0) return (printf(\"1\\n\"),0);\n\tLL ans = solve();\n\tswap(A,C);\n\tswap(B,D);\n\tswap(N,M);\n\tswap(cA,cC);\n\tswap(cB,cD);\n\tprintf(\"%lld\\n\" , (ans + solve()) % mod);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long fact[300009], factinv[300009], mod = 998244353;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 300000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 300000; i++) factinv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * factinv[r] % mod) * factinv[n - r] % mod;\n}\n\nlong long N, M, cnt, p1, p2, L1[100009], L2[100009]; string A, B, C, D;\n\nvoid dels() {\n\tcnt = 0; p1 = 0; p2 = 0;\n\tfor (int i = 0; i < 100009; i++) { L1[i] = 0; L2[i] = 0; }\n}\n\nlong long solve() {\n\tdels();\n\tfor (int i = 0; i < N; i++) { if (A[i] == '1' || B[i] == '1') cnt++; }\n\tfor (int i = 0; i < M; i++) { if (C[i] == '1') p1++; if (D[i] == '1') p2++; }\n\n\tint v = 0; L1[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL1[i + 1] = ncr(v + p1 - 1, p1 - 1);\n\t\tbool flag = false; if (v == 0) flag = true;\n\t\tif (flag == true && p1 == 0) L1[i + 1] = 1;\n\t}\n\tv = 0; L2[N - 1] = 1;\n\tfor (int i = N - 1; i >= 1; i--) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL2[i - 1] = ncr(v + p2 - 1, p2 - 1);\n\t\tbool flag = false; if (v == 0) flag = true;\n\t\tif (flag == true && p2 == 0) L2[i - 1] = 1;\n\t}\n\tlong long ret = 0, ans = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (A[i] == '1' || B[i] == '1') ret += L2[i];\n\t\tret %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ans += L1[i] * ret;\n\t\tif (A[i] == '1' || B[i] == '1') ans += L1[i] * ret;\n\t\tans %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ret *= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tinit();\n\tcin >> N >> M >> A >> B >> C >> D;\n\tint rem = 0;\n\tfor (int i = 0; i < N; i++) { rem += (A[i] - '0'); rem += (B[i] - '0'); }\n\tfor (int i = 0; i < M; i++) { rem += (C[i] - '0'); rem += (D[i] - '0'); }\n\tif (rem == 0) {\n\t\tcout << \"1\" << endl;\n\t\treturn 0;\n\t}\n\n\tlong long c1 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tlong long c2 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tcout << (c1 + c2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=998244353;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nll fac[500111],ifac[500111];\nll kissme(ll x,ll k){return k==0?1:kissme(x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n,m;\nchar sa[100111],sb[100111],sc[100111],sd[100111];\nll pre[100111],suf[100111],pre2[100111];\nll C(ll x,ll y){return x<y?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tint cntc=0;\n\tint cntd=0;\n\tfor(int i=1;i<=m;i++)cntc+=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)cntd+=sd[i]=='1';\n\tint cnta=0,cntb=0;;\n\tpre[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntc==0&&cnta==0&&cntb==0)pre[i]=1;\n\t\telse pre[i]=C(cntc+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n\tcnta=cntb=0;\n\tsuf[n+1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntd==0&&cnta==0&&cntb==0)pre[i]=1;\n\t\telse suf[i]=C(cntd+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n//\tfor(int i=0;i<=n+1;i++)cerr<<pre[i]<<\" \";cerr<<endl;\n//\tfor(int i=0;i<=n+1;i++)cerr<<suf[i]<<\" \";cerr<<endl;\n\t\n\tll ret=0;\n\tmemset(pre2,0,sizeof(pre2));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(sa[i]-'0'+sb[i]-'0'==1)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse if(sa[i]-'0'+sb[i]-'0'==2)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])*2%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse pre2[i]=pre2[i-1];\n//\t\tcerr<<pre2[i]<<\" \";\n\t}\n\treturn ret%mod;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=500005;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[500005]=kissme(fac[500005],mod-2);\n\tfor(int i=500004;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",sa+1);\n\tscanf(\"%s\",sb+1);\n\tscanf(\"%s\",sc+1);\n\tscanf(\"%s\",sd+1);\n\tll ans=0;\n\tans+=solve();\n\tswap(sa,sc);\n\tswap(sb,sd);\n\tswap(n,m);\n\tans+=solve();\n\tcout<<ans%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N_ 201000\nusing namespace std;\nint n, m;\nchar X1[N_], X2[N_], Y1[N_], Y2[N_];\nlong long U[N_], D[N_], L[N_], R[N_], F[N_], InvF[N_], UU[N_], LL[N_], res;\nlong long Mod = 998244353;\nlong long Pow(long long a, int b){\n    long long r = 1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long Comb(int a, int b){\n    if(a<b)return 0;\n    return F[a] * InvF[b]%Mod*InvF[a-b]%Mod;\n}\nlong long Calc(int a, int b, int c){\n    return (Comb(a+b+c,c) - Comb(a+b+c-1, c) + Mod) % Mod;\n}\nint main(){\n    int i;\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",X1+1);\n    scanf(\"%s\",X2+1);\n    scanf(\"%s\",Y1+1);\n    scanf(\"%s\",Y2+1);\n    F[0]=1;\n    int sum = 0;\n    for(i=1;i<=n;i++){\n        sum += X1[i]-'0';\n        sum += X2[i]-'0';\n    }\n    for(i=1;i<=m;i++){\n        sum += Y1[i]-'0';\n        sum += Y2[i]-'0';\n    }\n    if(!sum){\n        printf(\"1\\n\");\n        return 0;\n    }\n    for(i=1;i<=200000;i++)F[i]=F[i-1]*i%Mod;\n    InvF[200000] = Pow(F[200000], Mod-2);\n    for(i=200000;i>=1;i--)InvF[i-1] = InvF[i] * i % Mod;\n    int s1 = 0, s2 = 0, cc = 0;\n    for(i=1;i<=m;i++)if(Y1[i] == '1')cc++;\n    U[0] = 1;\n    for(i=1;i<=n;i++){\n        if(X1[i] == '1')s1++;\n        if(X2[i] == '1')s2++;\n        U[i] = Calc(s1,s2,cc);\n    }\n    s1 = s2 = cc = 0;\n    for(i=1;i<=m;i++)if(Y2[i] == '1')cc++;\n    D[n+1] = 1;\n    for(i=n;i>=1;i--){\n        if(X1[i] == '1')s1++;\n        if(X2[i] == '1')s2++;\n        D[i] = Calc(s1,s2,cc);\n    }\n    s1 = s2 = cc = 0;\n    for(i=1;i<=n;i++)if(X1[i] == '1')cc++;\n    L[0] = 1;\n    for(i=1;i<=m;i++){\n        if(Y1[i] == '1')s1++;\n        if(Y2[i] == '1')s2++;\n        L[i] = Calc(s1,s2,cc);\n    }\n    s1 = s2 = cc = 0;\n    R[m+1] = 1;\n    for(i=1;i<=n;i++)if(X2[i] == '1')cc++;\n    for(i=m;i>=1;i--){\n        if(Y1[i] == '1')s1++;\n        if(Y2[i] == '1')s2++;\n        R[i] = Calc(s1,s2,cc);\n    }\n    UU[0] = 1;\n    for(i=1;i<=n;i++){\n        int t = X1[i]-'0' + X2[i]-'0';\n        UU[i] = UU[i-1];\n        if(t==2) UU[i] += UU[i-1];\n        if(t) UU[i] += U[i];\n        UU[i]%=Mod;\n    }\n    LL[0] = 1;\n    for(i=1;i<=m;i++){\n        int t = Y1[i]-'0' + Y2[i]-'0';\n        LL[i] = LL[i-1];\n        if(t==2) LL[i] += LL[i-1];\n        if(t) LL[i] += L[i];\n        LL[i]%=Mod;\n    }\n    for(i=1;i<=n;i++){\n        int c = X1[i] - '0' + X2[i] - '0';\n        res = (res + UU[i-1]*D[i+1]*c) % Mod;\n    }\n //   printf(\"%lld\\n\",res);\n    for(i=1;i<=m;i++){\n        int c = Y1[i] - '0' + Y2[i] - '0';\n        res = (res + LL[i-1]*R[i+1]*c) % Mod;\n    }\n    for(i=1;i<=4;i++){\n//        printf(\"%lld %lld %lld %lld %lld %lld\\n\",U[i],D[i],L[i],R[i],UU[i],LL[i]);\n    }\n    printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int mod = 998244353;\n\nint res;\nint f[N], g[N];\nint prd[N * 3], inv[N * 3];\n\nint C(int n, int k) {\n\tif (n < k || n < 0 || k < 0) return 0;\n\treturn 1LL * prd[n] * inv[n - k] % mod * inv[k] % mod; \n}\n\nint pw(int x, int y) {\n\tif (!y) return 1;\n\tint ret = pw(x, y >> 1); ret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; return ret;\n}\n\nvoid solve(int n, int m, string a, string b, string c, string d) {\n\tint cntc, cntd;\n\tcntc = cntd = 0;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcntc += c[i] == '1', cntd += d[i] == '1';\n\t}\n\tf[1] = g[n] = 1;\n\tint cnta, cntb;\n\tcnta = cntb = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tcnta += a[i] == '1', cntb += b[i] == '1';\n\t\tf[i + 1] = C(cnta + cntb + cntc - 1, cntc - 1);\n\t}\n\tcnta = cntb = 0;\n\tfor (int i = n; i > 1; --i) {\n\t\tcnta += a[i] == '1', cntb += b[i] == '1';\n\t\tg[i - 1] = C(cnta + cntb + cntd - 1, cntd - 1);\n\t}\n\tint sum = 0, cur = 1;\n\tfor (int i = n; i >= 1; --i) {\n\t\tint cnt = 0;\n\t\tcnt += a[i] == '1', cnt += b[i] == '1';\n\t\tif (!cnt) continue;\n\t\tcur = cur * cnt % mod;\n\t\tsum = (sum + 1LL * cur * f[i]) % mod;\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tint cnt = 0;\n\t\tcnt += a[i] == '1', cnt += b[i] == '1';\n\t\tif (!cnt) continue;\n\t\tres = (res + 1LL * sum * g[i]) % mod;\n\t\tsum = (sum - 1LL * cnt * f[i]) % mod;\n\t\tif (sum < 0) sum += mod;\n\t\tsum = 1LL * sum * pw(cnt, mod - 2) % mod;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tprd[0] = inv[0] = 1;\n\tfor (int i = 1; i < 3 * N; ++i) {\n\t\tprd[i] = 1LL * i * prd[i - 1] % mod;\n\t\tinv[i] = pw(prd[i], mod - 2);\n\t}\n\tint n, m;\n\tstring a, b, c, d;\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\ta = \" \" + a, b = \" \" + b, c = \" \" + c, d = \" \" + d; \n\tsolve(n, m, a, b, c, d);\n\tsolve(m, n, c, d, a, b);\n\tcout << res; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\ntypedef long long ll;\nconst int MAXN = 100010;\nconst int MOD = 998244353;\nint _w;\n\nint n, m, up[MAXN], down[MAXN], left[MAXN], right[MAXN];\n\nnamespace NT {\n\tint fac[MAXN*3], ifac[MAXN*3];\n\tint fpow( int a, int b ) {\n\t\tint c = 1;\n\t\twhile(b) {\n\t\t\tif( b & 1 ) c = int((ll)c * a % MOD);\n\t\t\ta = int((ll)a * a % MOD);\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn c;\n\t}\n\tint inv( int a ) {\n\t\treturn fpow(a, MOD-2);\n\t}\n\tvoid prelude() {\n\t\tfac[0] = 1;\n\t\tfor( int i = 1; i < MAXN*3; ++i )\n\t\t\tfac[i] = int((ll)fac[i-1] * i % MOD);\n\t\tifac[MAXN*3-1] = inv(fac[MAXN*3-1]);\n\t\tfor( int i = MAXN*3-1; i > 0; --i )\n\t\t\tifac[i-1] = int((ll)ifac[i] * i % MOD);\n\t}\n\tint C( int n, int m ) {\n\t\treturn int((ll)fac[n] * ifac[m] % MOD * ifac[n-m] % MOD);\n\t}\n}\nusing NT::C;\n\nint calc( int a, int b, int c ) {\n\treturn a ? C(a+b+c-1, a-1) : (b+c ? 0 : 1);\n}\n\nint solven() {\n\tint ltot = 0, rtot = 0, utot = 0, dtot = 0, uc = 0, dc = 0;\n\tfor( int i = 1; i <= n; ++i )\n\t\tltot += left[i], rtot += right[i];\n\tfor( int i = 1; i <= m; ++i )\n\t\tutot += up[i], dtot += down[i];\n\t// printf( \"ltot = %d, rtot = %d, utot = %d, dtot = %d\\n\", ltot, rtot, utot, dtot );\n\tint ans = 0, sl = 1;\n\tfor( int R = 1; R <= m; ++R ) {\n\t\tif( !up[R] && !down[R] ) continue;\n\t\tif( up[R] && down[R] ) sl = (sl<<1) % MOD;\n\t\tans = int(ans + (ll)sl * calc(rtot, utot-uc-up[R], dtot-dc-down[R]) % MOD) % MOD;\n\t\tuc += up[R], dc += down[R];\n\t\tsl += calc(ltot, uc, dc);\n\t}\n\t// printf( \"solven = %d\\n\", ans );\n\treturn ans;\n}\n\nint solvem() {\n\tint utot = 0, dtot = 0, ltot = 0, rtot = 0, lc = 0, rc = 0;\n\tfor( int i = 1; i <= m; ++i )\n\t\tutot += up[i], dtot += down[i];\n\tfor( int i = 1; i <= n; ++i )\n\t\tltot += left[i], rtot += right[i];\n\tint ans = 0, su = 1;\n\tfor( int D = 1; D <= n; ++D ) {\n\t\tif( !left[D] && !right[D] ) continue;\n\t\tif( left[D] && right[D] ) su = (su<<1) % MOD;\n\t\tans = int(ans + (ll)su * calc(dtot, ltot-lc-left[D], rtot-rc-right[D]) % MOD) % MOD;\n\t\tlc += left[D], rc += right[D];\n\t\tsu += calc(utot, lc, rc);\n\t}\n\t// printf( \"solvem = %d\\n\", ans );\n\treturn ans;\n}\n\nint main() {\n\tNT::prelude();\n\t_w = scanf( \"%d%d\", &n, &m );\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tleft[i] = ch - '0';\n\t}\n\tfor( int i = 1; i <= n; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tright[i] = ch - '0';\n\t}\n\tfor( int i = 1; i <= m; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tup[i] = ch - '0';\n\t}\n\tfor( int i = 1; i <= m; ++i ) {\n\t\tchar ch;\n\t\t_w = scanf( \" %c\", &ch );\n\t\tdown[i] = ch - '0';\n\t}\n\tprintf( \"%d\\n\", max((solven() + solvem()) % MOD, 1) );\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 420000\n#define LL long long\n\nconst LL mod=998244353;\nLL n,m,ans,pw[N],f[N],g[N],fac[N],ifac[N];\nchar a[N],b[N],c[N],d[N];\nbool chk1,chk2;\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nLL C(LL x,LL y){if (y<0) return 0; return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\n\nvoid solve(LL n,LL m,char a[],char b[],char c[],char d[]){\n\tmemset(f,0,sizeof f); memset(g,0,sizeof g);\n\tLL l=0,r=0,sum=0,sum2=0,cnt=0,cnt2=0,tmp=0;\n\tfor (LL i=1;i<=m;i++){\n\t\tif (c[i]=='1') l++;\n\t\tif (d[i]=='1') r++;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\tif (a[i]=='1') sum++;\n\t\tif (b[i]=='1') sum++;\n\t\tif (a[i]=='1' && b[i]=='1') sum2++;\n\t}\n\tif (a[1]=='1'||b[1]=='1') f[0]=1;\n\tif (a[n]=='1'||b[n]=='1') tmp=g[n+1]=pw[sum2];\n\tfor (LL i=1;i<=n;i++){\n\t\tif (i>1&&(a[i-1]=='1'||b[i-1]=='1')) g[i]=C(sum-cnt+r-1,r-1)*pw[cnt2]%mod;\n\t\ttmp=(tmp+g[i])%mod;\n\t\tif (a[i]=='1') cnt++;\n\t\tif (b[i]=='1') cnt++;\n\t\tif (a[i]=='1' && b[i]=='1') cnt2++;\n\t\tif (i<n&&(a[i+1]=='1'||b[i+1]=='1')) f[i]=C(cnt+l-1,l-1)*inv(pw[cnt2])%mod;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\ttmp=(tmp-g[i]+mod)%mod;\n\t\tans=(ans+f[i-1]*tmp)%mod;\n\t}\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s%s%s%s\",a+1,b+1,c+1,d+1);\n\tfor (int i=1;i<=n;i++) chk1|=(a[i]=='1')|(b[i]=='1');\n\tfor (int i=1;i<=m;i++) chk2|=(c[i]=='1')|(d[i]=='1');\n\tif (!chk1 || !chk2){puts(\"1\"); return 0;}\n\tpw[0]=1; for (LL i=1;i<N;i++) pw[i]=pw[i-1]*2%mod;\n\tfac[0]=1; for (LL i=1;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[N-1]=inv(fac[N-1]); for (LL i=N-2;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tsolve(n,m,a,b,c,d);\n\tsolve(m,n,c,d,a,b);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int N = 100000;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 998244353;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nLL fpm(LL base, LL exp) {\n    LL res = 1;\n    for(; exp > 0; exp >>= 1) {\n        if(exp & 1) \n            res = res * base % mod;\n        base = base * base % mod;\n    }\n    return res;\n}\n\nint cnt[4];\nchar st[N + 5];\nLL fac[N + 5], inv[N + 5];\n\ninline LL C(int n, int k) {\n    return fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint n, m;\nbool a[N + 5], b[N + 5], c[N + 5], d[N + 5];\n\nLL calc() {\n    LL pre = 1, res = 0;\n    int lu = 0, ld = 0, ru = cnt[2], rd = cnt[3];\n    for(int i = 0; i < m; ++i) {\n        if(c[i]) lu ++, ru --;\n        if(d[i]) ld ++, rd --;\n        if(c[i] && d[i]) { (pre <<= 1LL) %= mod; }\n\n        if(c[i] || d[i]) { \n            res = (res + pre*(cnt[1] ? C(cnt[1]+ru+rd - 1, cnt[1] - 1) : (ru + rd == 0))) % mod;\n            pre = (pre + (cnt[0] ? C(cnt[0]+lu+ld - 1, cnt[0] - 1) : (lu + ld == 0))) % mod;\n        }\n    }\n    return res;\n}\n\nvoid Input() {\n    cin >> n >> m;\n    scanf(\"%s\", st); for(int i = 0; i < n; ++i) cnt[0] += (a[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < n; ++i) cnt[1] += (b[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < m; ++i) cnt[2] += (c[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < m; ++i) cnt[3] += (d[i] = st[i] - '0');\n}\n\nvoid Init() {\n    fac[0] = 1;\n    for(int i = 1; i <= N; ++i) fac[i] = fac[i-1] * i % mod;\n    inv[N] = fpm(fac[N], mod - 2);\n    for(int i = N; i >= 1; --i) inv[i-1] = inv[i] * i % mod;\n}\n\nvoid Solve() {\n    LL Ans = calc();\n\n    swap(n, m); swap(b, c);\n    swap(a, d); swap(a, b);\n    swap(cnt[0], cnt[3]);\n    swap(cnt[1], cnt[2]);\n    swap(cnt[0], cnt[1]);\n\n    Ans = (Ans + calc()) % mod;\n    printf(\"%lld\\n\", Ans);\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    Init();\n    Input();\n    Solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long fact[300009], factinv[300009], mod = 998244353;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 300000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 300000; i++) factinv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * factinv[r] % mod) * factinv[n - r] % mod;\n}\n\nlong long N, M, cnt, p1, p2, L1[100009], L2[100009]; string A, B, C, D;\n\nvoid dels() {\n\tcnt = 0; p1 = 0; p2 = 0;\n\tfor (int i = 0; i < 100009; i++) { L1[i] = 0; L2[i] = 0; }\n}\n\nlong long solve() {\n\tdels();\n\tfor (int i = 0; i < N; i++) { if (A[i] == '1' || B[i] == '1') cnt++; }\n\tfor (int i = 0; i < M; i++) { if (C[i] == '1') p1++; if (D[i] == '1') p2++; }\n\n\tint v = 0; L1[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL1[i + 1] = ncr(v + p1 - 1, p1 - 1);\n\t\tif (p1 == 0) L1[i + 1] = 1;\n\t}\n\tv = 0; L2[N - 1] = 1;\n\tfor (int i = N - 1; i >= 1; i--) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL2[i - 1] = ncr(v + p2 - 1, p2 - 1);\n\t\tif (p2 == 0) L2[i - 1] = 1;\n\t}\n\tlong long ret = 0, ans = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (A[i] == '1' || B[i] == '1') ret += L2[i];\n\t\tret %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ans += L1[i] * ret;\n\t\tif (A[i] == '1' || B[i] == '1') ans += L1[i] * ret;\n\t\tans %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ret *= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tinit();\n\tcin >> N >> M >> A >> B >> C >> D;\n\n\tlong long c1 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tlong long c2 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tcout << (c1 + c2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\n//const ll mod=1e9+7;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\tif(n<0) return 1;\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nstring A,B,C,D;\n\nvl ff(){\n\tvl a(m+1);\n\ta[0]++;\n\tif(A!=string(n,'0')){\n\t\tint S=0,t=0;\n\t\tfor(int i=0;i<n;i++) S+=A[i]-'0';\n\t\tfor(int i=0;i<m;i++){\n\t\t\tt+=C[i]-'0'+D[i]-'0';\n\t\t\ta[i+1]=nCk(S+t-1,t);\n\t\t}\n\t}\n\tswap(A,B);\n\treverse(C.begin(),C.end());\n\treverse(D.begin(),D.end());\n\treturn a;\n}\n\nll f(){\n\tll res=0,t=0;\n\tvl a=ff(),b=ff();\n\tfor(int i=0;i<m;i++) if(C[i]=='1'||D[i]=='1'){\n\t\tt=(C[i]-'0'+D[i]-'0')*(a[i]+t)%mod;\n\t\t(res+=t*b[m-1-i])%=mod;\n\t}\n\tswap(A,C);swap(B,D);swap(n,m);\n\treturn res;\n}\n\nint main(){\n\tios;;sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>m>>A>>B>>C>>D;\n\tInit();\n\tcout<<(f()+f())%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\n#define int long long\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,cnt=0;\nint pre[350007],inv[350007];\nchar a[Maxn],b[Maxn],c[Maxn],d[Maxn];\nbool x[Maxn],y[Maxn],z[Maxn],w[Maxn];\nlong long power(long long a,long long b)\n{\n\tlong long res=1,now=a,left=b;\n\twhile (left>0)\n\t{\n\t\tif (left%2==1) res=(1LL*res*now)%modp;\n\t\tnow=(1LL*now*now)%modp;\n\t\tleft/=2;\n\t}\n\treturn res%modp;\n}\nint calc(int x,int y)\n{\n\tif (x<y) return 0;\n\tint res=(1LL*pre[x]*inv[y])%modp;\n\tres=(1LL*res*inv[x-y])%modp;\n\treturn res;\n}\nint get(int a,int b,int c)\n{\n\tif (a==0&&b==0&&c==0) return 1;\n\telse if (b==0) return 0;\n\telse return calc(a+b+c-1,b-1);\n}\nint solve()\n{\n\tint cnt1=0,cnt2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (x[i]) ++cnt1;\n\t\tif (y[i]) ++cnt2;\n\t}\n\tint tot1=0,tot2=0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (z[i]) ++tot1;\n\t\tif (w[i]) ++tot2;\n\t}\n\tint res=0,del=0;\n\tint p=0,q=0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (z[i]==false&&w[i]==false) continue;\n\t\tdel=(del+get(p,cnt1,q))%modp;\n\t\tif (z[i]&&w[i]) del=(2LL*del)%modp;\n\t\tif (z[i]) ++q,--tot1;\n\t\tif (w[i]) ++p,--tot2;\n\t\tres=(res+1LL*del*get(tot1,cnt2,tot2)%modp)%modp;\n\t}\n\treturn res%modp;\n}\nsigned main()\n{\n\tn=read(),m=read();\n\tpre[0]=1;\n\tfor (int i=1;i<=350000;i++)\n\t\tpre[i]=(1LL*pre[i-1]*i)%modp;\n\tinv[350000]=power(pre[350000],modp-2)%modp;\n\tfor (int i=350000;i;i--)\n\t\tinv[i-1]=(1LL*inv[i]*i)%modp;\n\tscanf(\"%s\",a);\n\tscanf(\"%s\",b);\n\tscanf(\"%s\",c);\n\tscanf(\"%s\",d);\n\tmemset(x,false,sizeof(x));\n\tmemset(y,false,sizeof(y));\n\tmemset(z,false,sizeof(z));\n\tmemset(w,false,sizeof(w));\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tif (a[i]=='0') x[i+1]=false; else x[i+1]=true;\n\t\tif (b[i]=='0') y[i+1]=false; else y[i+1]=true;\n\t\tif (x[i+1]) ++cnt;\n\t\tif (y[i+1]) ++cnt;\n\t}\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (c[i]=='0') z[i+1]=false; else z[i+1]=true;\n\t\tif (d[i]=='0') w[i+1]=false; else w[i+1]=true;\n\t\tif (z[i+1]) ++cnt;\n\t\tif (w[i+1]) ++cnt;\n\t}\n\tif (cnt==0)\n\t{\n\t\tprintf(\"%d\\n\",0);\n\t\treturn 0;\n\t}\n\tint ans=solve()%modp;\n\tswap(x,z);\n\tswap(y,w);\n\tswap(n,m);\n\tans=(ans+solve())%modp;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpre=(pre+val)%p;\n\t}\n}\n\nint main(){//quiet!!!\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tbool died=true;\n\tfor(int i=1;i<=n;++i)\n\t\tif(A[i]=='1' or B[i]=='1' or C[i]=='1' or D[i]=='1')\n\t\t\t{died=false;break;}\n\tif(died){puts(\"1\");return 0;}\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nchar A[110000];\nchar B[110000];\nchar C[110000];\nchar D[110000];\nlong long U[110000];\nlong long S[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s%s%s%s\",A,B,C,D);\n\tlong long ret=0;\n\tinit_C(410000);\n\tfor(int w=0;w<2;w++){\n\t\tint l=0;\n\t\tint r=0;\n\t\tint uc=0;\n\t\tint dc=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tuc+=C[i]-'0';\n\t\t\tdc+=D[i]-'0';\n\t\t}\n\t\tfor(int i=0;i<110000;i++)U[i]=S[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tU[i]=Comb(l+r+uc-1,l+r);\n\t\t\tif(l+r==0)U[i]=1;\n\t\t\tif(A[i]=='1')l++;\n\t\t\tif(B[i]=='1')r++;\n\t\t}\n\t\tl=0;\n\t\tr=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tS[i]=Comb(l+r+dc-1,l+r);\n\t\t\tif(l+r==0)S[i]=1;\n\t\t\tif(A[a-1-i]=='1')l++;\n\t\t\tif(B[a-1-i]=='1')r++;\n\t\t}\n\t\t// for(int i=0;i<a;i++)printf(\"%d: %lld %lld\\n\",i,U[i],S[i]);\n\t\tlong long ks=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(A[i]=='1'||B[i]=='1')ks=(ks+U[i])%mod;\n\t\t\tif(A[i]=='1'&&B[i]=='1')ks=ks*2%mod;\n\t\t\tif(A[i]=='1'||B[i]=='1')ret=(ret+ks*S[a-i-1])%mod;\n\t\t\t// printf(\"%d: %lld %lld\\n\",i,ks,S[a-i-1]);\n\t\t}\n\t\tswap(a,b);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint a[100011][2],b[100011][2];\nlong long MOD=998244353;\nlong long fa[200011];\nlong long invfa[200011];\nlong long two[200011];\n\n\nint p[100011];\nint ppos[100011];\nint q[100011];\nint sp[100011];\nint sa[100011][2];\n\n\nlong long exgcd(long long a,long long b,long long &x,long long &y)  \n{  \n    if(b==0)\n    {  \n        x=1;\n        y=0;\n        return a;\n    }\n    int r=exgcd(b,a%b,x,y);\n    long long t=y;\n    y=x-(a/b)*y;\n    x=t;\n    return r;\n}  \nlong long inv(long long a)  \n{  \n    long long x,y;  \n    long long r=exgcd(a,MOD,x,y);  \n    if(r==1) return (x%MOD+MOD)%MOD;  \n    return -1;  \n}\n\n\nlong long C(int n,int k)\n{\n    long long ans=fa[n]*invfa[k]%MOD*invfa[n-k]%MOD;\n    return ans;\n}\n\n\nlong long calc(long long x,long long y,long long z)\n{\n    if(x==0)\n    {\n        if(y==0 && z==0)return 1;\n        return 0;\n    }\n    \n    long long ans=(C(x+y+z,x)-C(x+y+z-1,x)+MOD)%MOD;\n    \n    \n    //cout<<\"calc\"<<' '<<x<<' '<<y<<' '<<z<<\"   \"<<ans<<endl;\n    \n    return ans;\n}\n\nlong long gao(int a[][2],int b[][2],int n,int m)\n{\n    int i,j,k;\n    int mm1,mm2;\n    mm1=mm2=0;\n    for(i=1;i<=m;i++)\n    {\n        mm1+=(b[i][0]==1);\n        mm2+=(b[i][1]==1);\n        \n        //cout<<b[i][0]<<' '<<b[i][1]<<endl;\n    }\n    \n    \n    \n    long long ans=0;\n    sa[0][0]=a[0][1]=0;\n    for(i=1;i<=n;i++)\n    {\n        sa[i][0]=sa[i-1][0]+a[i][0];\n        sa[i][1]=sa[i-1][1]+a[i][1];\n    }\n    \n    int nn=0;\n    for(i=1;i<=n;i++)\n    {\n        if(a[i][0]==1 && a[i][1]==1)\n        {\n            p[++nn]=2;\n            ppos[nn]=i;\n        }\n        else if(a[i][0]==1 || a[i][1]==1)\n        {\n            p[++nn]=1;\n            ppos[nn]=i;\n        }\n    }\n    sp[0]=0;\n    for(i=1;i<=nn;i++)\n    {\n        sp[i]=sp[i-1]+(p[i]==2);\n    }\n    \n    \n    long long tmp=0;\n    long long lans=1;\n    long long rans;\n    int ll,rr;\n    ll=1;\n    \n    \n    //cout<<mm1<<' '<<mm2<<\" mmm\"<<endl;\n    for(rr=1;rr<=nn;rr++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[rr]][0],sa[n][1]-sa[ppos[rr]][1]);\n        tmp=(tmp+lans*rans%MOD*two[sp[rr]-sp[ll-1]]%MOD)%MOD;\n    }\n    //cout<<\"tmp0\"<<tmp<<endl;\n    \n    ans=(ans+tmp)%MOD;\n    for(ll=2;ll<=nn;ll++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[ll-1]][0],sa[n][1]-sa[ppos[ll-1]][1]);\n        tmp=(tmp-lans*rans%MOD*two[sp[ll-1]-sp[ll-2]]%MOD+MOD)%MOD;\n        //cout<<tmp<<\"  &&&\"<<endl;\n        tmp=tmp*inv(lans)%MOD;\n        lans=calc(mm1,sa[ppos[ll]-1][0],sa[ppos[ll]-1][1]);\n        tmp=tmp*lans%MOD;\n        if(p[ll-1]==2)\n        {\n            tmp=tmp*inv(2)%MOD;\n        }\n        \n        //cout<<\"tmp\"<<tmp<<endl;\n        \n        ans=(ans+tmp)%MOD;\n    }\n    \n    \n    return ans;\n}\n\n\nint main()\n{\n    int i,j,k;\n    char c;\n    fa[0]=1;\n    invfa[0]=1;\n    for(i=1;i<=200000;i++)\n    {\n        fa[i]=(fa[i-1]*i)%MOD;\n        invfa[i]=inv(fa[i]);\n    }\n    two[0]=1;\n    for(i=1;i<=200000;i++)\n    {\n        two[i]=(two[i-1]*2)%MOD;\n    }\n    \n    \n    scanf(\"%d %d\",&n,&m);\n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=n;i++)\n    {\n        \n            scanf(\" %c\",&c);\n            a[i][j]=c-'0';\n    }\n    }\n    \n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=m;i++)\n    {\n            scanf(\" %c\",&c);\n            b[i][j]=c-'0';\n    }\n    }\n    \n    long long ans=0;\n    ans+=gao(a,b,n,m);\n    ans+=gao(b,a,m,n);\n    ans%=MOD;\n    cout<<(ans+MOD)%MOD<<endl;\n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\n\n#define MOD 998244353\nLL powmod(LL a, LL n){\n\tif(n == 0) return 1;\n\tif(n % 2) return (a*powmod(a,n-1)) % MOD;\n\tLL c = powmod(a, n/2);\n\treturn (c*c) % MOD;\n}\nLL inv(LL a){\n\treturn powmod(a, MOD-2);\n}\nLL fact[1100000];\nLL invfact[1100000];\nLL p2[1100000];\nLL ncr(LL n, LL r){\n\tif(r < 0 || n < 0) return 0;\n\tif(n < r) return 0;\n\tLL a = fact[n];\n\ta = (a * invfact[r]) % MOD;\n\ta = (a * invfact[n-r]) % MOD;\n\treturn a;\n}\nLL finalans = 0;\nLL solve2(LL a, LL b, LL c){\n\tif(b == 0){\n\t\tif(a == 0 && c == 0){\n\t\t\treturn 1;\n\t\t}\n\t\treturn 0;\n\t}\n\tif(a == 0) return ncr(b-1+c,b-1);\n\tif(c == 0) return ncr(b-1+a,b-1);\n\treturn ncr(a-1+b+c-1+1,b-1);\n}\n\nvoid solve(string a, string b, string c, string d){\n\tLL na = 0;\n\tLL nb = 0;\n\tfor(int i = 0; i < a.size(); i++) na += a[i] - '0';\n\tfor(int i = 0; i < b.size(); i++) nb += b[i] - '0';\n\tLL lc = 0;\n\tLL rc = 0;\n\tLL ld = 0;\n\tLL rd = 0;\n\tLL l2 = 0;\n\tLL r2 = 0;\n\tfor(int i = 0; i < c.size(); i++) rc += c[i] - '0';\n\tfor(int i = 0; i < d.size(); i++) rd += d[i] - '0';\n\tfor(int i = 0; i < c.size(); i++){\n\t\tif(c[i] == '1' && d[i] == '1'){\n\t\t\tr2++;\n\t\t}\n\t}\n\n\n\tLL lsols = 0;\n\tLL ans = 0;\n\tfor(int i = 0; i < c.size(); i++){\n\t\trc -= (c[i] - '0');\n\t\trd -= (d[i] - '0');\n\t\tif(c[i] == '1' && d[i] == '1'){\n\t\t\tr2--;\n\t\t}\n\t\tif(c[i] == '0' && d[i] == '0') continue;\n\t\tLL rsol = solve2(rc, nb, rd);\n\t\trsol *= inv(p2[r2]);\n\t\trsol %= MOD;\n\n\t\tLL lsol = solve2(lc, na, ld);\n\t\tlsol *= inv(p2[l2]);\n\t\tlsol %= MOD;\n\t\tlsols = (lsols + lsol) % MOD;\n\n\t\tans += rsol * lsols;\n\t\tans %= MOD;\n\n\t\tlc += (c[i] - '0');\n\t\tld += (d[i] - '0');\n\t\tif(c[i] == '1' && d[i] == '1'){\n\t\t\tl2++;\n\t\t}\t\t\n\t}\n\tans *= p2[l2];\n\tans %= MOD;\n\t//cout << ans << endl;\n\tfinalans += ans;\n\tfinalans %= MOD;\n}\nint main(){\n\tfact[0] = 1;\n\tinvfact[0] = 1;\n\tp2[0] = 1;\n\tfor(LL i = 1; i < 1100000; i++){\n\t\tfact[i] = (i*fact[i-1]) % MOD;\n\t\tinvfact[i] = inv(fact[i]);\n\t\tp2[i] = (2*p2[i-1]) % MOD;\n\t}\n\n\tLL n, m;\n\tcin >> n >> m;\n\tstring a, b, c, d;\n\tcin >> a >> b >> c >> d;\n\tint n0 = 0;\n\tfor(int i = 0; i < a.size(); i++) n0 += a[i] - '0';\n\tfor(int i = 0; i < b.size(); i++) n0 += b[i] - '0';\n\tfor(int i = 0; i < c.size(); i++) n0 += c[i] - '0';\n\tfor(int i = 0; i < d.size(); i++) n0 += d[i] - '0';\n\tif(n0 == 0){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\tsolve(a,b,c,d);\n\tsolve(c,d,a,b);\n\tcout << finalans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, MOD = 998244353;\nchar A[N], B[N], C[N], D[N];\nint L[N], R[N], f[3 * N], rf[3 * N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint choose(int n, int m) {\n\treturn 1LL * f[n] * rf[n - m] % MOD * rf[m] % MOD;\n}\nint work(int n, int m, char AA[N], char BB[N], char CC[N], char DD[N]) {\n\tstatic char A[N], B[N], C[N], D[N];\n\tint nn = 0, mm = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tif (AA[i] == '1' || BB[i] == '1') {\n\t\t\tnn ++;\n\t\t\tA[nn] = AA[i];\n\t\t\tB[nn] = BB[i];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++ i) {\n\t\tif (CC[i] == '1' || DD[i] == '1') {\n\t\t\tmm ++;\n\t\t\tC[mm] = CC[i];\n\t\t\tD[mm] = DD[i];\n\t\t}\n\t}\n\tn = nn, m = mm;\n\tint rl = 0, rr = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\trl += A[i] == '1';\n\t\trr += B[i] == '1';\n\t}\n\tL[0] = 1;\n\tint x = 0, y = 0;\n\tfor (int i = 1; i <= m; ++ i) {\n\t\tx += C[i] == '1';\n\t\ty += D[i] == '1';\n\t\tL[i] = (rl == 0) ? 0 : choose(x + y + rl - 1, rl - 1);\n\t}\n\tx = y = 0;\n\tR[m + 1] = 1;\n\tfor (int i = m; i >= 1; -- i) {\n\t\tx += C[i] == '1';\n\t\ty += D[i] == '1';\n\t\tR[i] = (rr == 0) ? 0 : choose(x + y + rr - 1, rr - 1);\n\t}\n\tint ans = 0, tmp = 1;\n\tfor (int i = 1; i <= m; ++ i) {\n\t\ttmp = 1LL * tmp * (C[i] == '1' && D[i] == '1' ? 2 : 1) % MOD;\n\t\t(ans += 1LL * tmp * R[i + 1] % MOD) %= MOD;\n\t\ttmp = (tmp + L[i]) % MOD;\n\t}\n\treturn ans;\n}\nint main() {\n\tf[0] = 1;\n\tfor (int i = 1; i < 3 * N; ++ i) f[i] = 1LL * f[i - 1] * i % MOD;\n\trf[3 * N - 1] = mpow(f[3 * N - 1], MOD - 2);\n\tfor (int i = 3 * N - 2; i >= 0; -- i) rf[i] = 1LL * rf[i + 1] * (i + 1) % MOD;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s%s%s%s\", A + 1, B + 1, C + 1, D + 1);\n\tint tot = 0;\n\tfor (int i = 1; i <= n; ++ i) tot += A[i] == '1';\n\tfor (int i = 1; i <= n; ++ i) tot += B[i] == '1';\n\tfor (int i = 1; i <= m; ++ i) tot += C[i] == '1';\n\tfor (int i = 1; i <= m; ++ i) tot += D[i] == '1';\n\tif (tot == 0) return 0 * puts(\"1\");\n\tint ans = work(n, m, A, B, C, D);\n\treverse(A + 1, A + 1 + n);\n\treverse(B + 1, B + 1 + n);\n\t(ans += work(m, n, D, C, A, B)) %= MOD;\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#define MOD 998244353\n#define SIZE 500005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid init()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll Ct(int a,int b)\n{\n\tif(a==b) return 1;\n\tif(a<b) return 0;\n\tif(b<0) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nchar sA[SIZE],sB[SIZE],sC[SIZE],sD[SIZE];\nll left[SIZE],now[SIZE];\n\nll solve(string A,string B,string C,string D)\n{\n\tint s=0,t=0;\n\tfor(int i=0;i<C.size();i++)\n\t{\n\t\ts+=C[i]-'0';\n\t\tt+=D[i]-'0';\n\t}s--,t--;\n\tint sum=0;\n\tfor(int i=0;i<A.size();i++)\n\t{\n\t\tleft[i]=0;\n\t\tif(A[i]=='1')\n\t\t{\n\t\t\tleft[i]+=Ct(sum+s,s);\n\t\t\tif(left[i]>=MOD) left[i]-=MOD;\n\t\t}\n\t\tif(B[i]=='1')\n\t\t{\n\t\t\tleft[i]+=Ct(sum+s,s);\n\t\t\tif(left[i]>=MOD) left[i]-=MOD;\n\t\t}\n\t\tnow[i]=left[i];\n\t\tif(i>0)\n\t\t{\n\t\t\tif(A[i]=='1'&&B[i]=='1')\n\t\t\t{\n\t\t\t\tleft[i]+=left[i-1]*2LL;\n\t\t\t\tleft[i]%=MOD;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tleft[i]+=left[i-1];\n\t\t\t\tleft[i]%=MOD;\n\t\t\t}\n\t\t}\n\t\tsum+=A[i]-'0';\n\t\tsum+=B[i]-'0';\n\t}\n\tsum=0;\n\tll ret=0;\n\tfor(int i=A.size()-1;i>=0;i--)\n\t{\n\t\tret+=now[i]*Ct(sum+t,t)%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t\tif(A[i]=='1'&&i>0)\n\t\t{\n\t\t\tret+=left[i-1]*Ct(sum+t,t)%MOD;\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t\tif(B[i]=='1'&&i>0)\n\t\t{\n\t\t\tret+=left[i-1]*Ct(sum+t,t)%MOD;\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t\tsum+=A[i]-'0';\n\t\tsum+=B[i]-'0';\n\t}\n\treturn ret;\n}\nint main()\n{\n\tinit();\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%s\",&sA);\n\tscanf(\"%s\",&sB);\n\tscanf(\"%s\",&sC);\n\tscanf(\"%s\",&sD);\n\tstring A=sA;\n\tstring B=sB;\n\tstring C=sC;\n\tstring D=sD;\n\t//printf(\"%lld %lld\\n\",solve(A,B,C,D),solve(C,D,A,B));\n\tll ret=solve(A,B,C,D)+solve(C,D,A,B);\n\tif(ret>=MOD) ret-=MOD;\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nchar A[110000];\nchar B[110000];\nchar C[110000];\nchar D[110000];\nlong long U[110000];\nlong long S[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s%s%s%s\",A,B,C,D);\n\tint cnt=0;\n\tfor(int i=0;i<a;i++)cnt+=A[i]-'0';\n\tfor(int i=0;i<a;i++)cnt+=B[i]-'0';\n\tfor(int i=0;i<b;i++)cnt+=C[i]-'0';\n\tfor(int i=0;i<b;i++)cnt+=D[i]-'0';\n\tif(cnt==0){\n\t\tprintf(\"1\\n\");return 0;\n\t}\n\tlong long ret=0;\n\tinit_C(410000);\n\tfor(int w=0;w<2;w++){\n\t\tint l=0;\n\t\tint r=0;\n\t\tint uc=0;\n\t\tint dc=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tuc+=C[i]-'0';\n\t\t\tdc+=D[i]-'0';\n\t\t}\n\t\tfor(int i=0;i<110000;i++)U[i]=S[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tU[i]=Comb(l+r+uc-1,l+r);\n\t\t\tif(l+r==0)U[i]=1;\n\t\t\tif(A[i]=='1')l++;\n\t\t\tif(B[i]=='1')r++;\n\t\t}\n\t\tl=0;\n\t\tr=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tS[i]=Comb(l+r+dc-1,l+r);\n\t\t\tif(l+r==0)S[i]=1;\n\t\t\tif(A[a-1-i]=='1')l++;\n\t\t\tif(B[a-1-i]=='1')r++;\n\t\t}\n\t\t// for(int i=0;i<a;i++)printf(\"%d: %lld %lld\\n\",i,U[i],S[i]);\n\t\tlong long ks=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(A[i]=='1'||B[i]=='1')ks=(ks+U[i])%mod;\n\t\t\tif(A[i]=='1'&&B[i]=='1')ks=ks*2%mod;\n\t\t\tif(A[i]=='1'||B[i]=='1')ret=(ret+ks*S[a-i-1])%mod;\n\t\t\t// printf(\"%d: %lld %lld\\n\",i,ks,S[a-i-1]);\n\t\t}\n\t\tswap(a,b);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define \n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 3e5 + 100;\n\nconst int mod = 998244353;\n\nint n, m, ans;\nchar A[maxn], B[maxn], C[maxn], D[maxn];\nint fac[maxn], ifac[maxn];\nint f[maxn], g[maxn], has[maxn], pw[maxn], cnt[maxn], ipw[maxn];\n\nint Exp(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tfac[0] = 1;\n\tpw[0] = ipw[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tpw[i] = (pw[i - 1] << 1) % mod;\n\t\tipw[i] = Exp(pw[i], mod - 2);\n\t}\n\tifac[maxn - 1] = Exp(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint CC(int n, int m) {\n\treturn (m < 0 || n < m) ? 0 : 1ll * fac[n] * ifac[n - m] % mod * ifac[m] % mod;\n}\n\nvoid solve(int n, int m, char *A, char *B, char *C, char *D) {\n\tint x = 0, a = 0, b = 0;\n\tforn(i, 1, m) {\n\t\tx += (C[i] == '1');\n\t}\n\tcnt[0] = 0;\n\tforn(i, 1, n) {\n\t\tcnt[i] = cnt[i - 1] + (A[i] == '1' && B[i] == '1');\n\t}\n\tcnt[n + 1] = cnt[n];\n\tif(x) {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t\tf[i] = 1ll * f[i] * ipw[cnt[i - 1]] % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = 1;\n\t\t\t\twhile(++i <= n) {\n\t\t\t\t\tf[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tx = 0;\n\ta = 0;\n\tb = 0;\n\tforn(i, 1, m) {\n\t\tx += (D[i] == '1');\n\t}\n\tif(x) {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[i] = 0;\n\t\t\t}\n\t\t\tg[i] = 1ll * g[i] * pw[cnt[i]] % mod;\n\t\t\t(g[i] += g[i + 1]) %= mod;\n\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = pw[cnt[i]];\n\t\t\t\twhile(i) {\n\t\t\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\t\t\tg[--i] = g[i + 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tpre();\n\tscf(n, m);\n\tscanf(\"%s\", A + 1);\n\tscanf(\"%s\", B + 1);\n\tscanf(\"%s\", C + 1);\n\tscanf(\"%s\", D + 1);\n\tsolve(n, m, A, B, C, D);\n\tsolve(m, n, C, D, A, B);\n\tif(!ans) {\n\t\tfor(;;) {\n\t\t\tans += rand();\n\t\t}\n\t\tans = 1;\n\t}\n\tprintf(\"%d\\n\", (ans % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mod 998244353\n#define rep(i,x) for(int i=0;i<x;i++)\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[300005],R[300005],ans;\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<300005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<300005;i++) R[i] = modpow(F[i],mod-2);\n}\nll c(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nll sol(int n,int m,string a,string b,string cc,string d){\n\tll zan = 0,ret = 0;\n\tint A = 0,B = 0,C = 0,D = 0;\n\trep(i,n) A+=a[i]-'0',B+=b[i]-'0';\n\trep(i,m) C+=cc[i]-'0',D+=d[i]-'0';\n\tint CC = 0,DD = 0;\n\tfor(int i=m-1;i>=0;i--){\n\t\tll add = 0;\n\t\tif(CC+DD == 0 && B == 0){\n\t\t\tadd = 1;\n\t\t}\n\t\telse if(B){\n\t\t\tadd = c(B-1+CC+DD,B-1);\n\t\t}\n\t\tint cnt = cc[i]-'0' + d[i]-'0';\n\t\tC -= cc[i]-'0'; D -= d[i]-'0';\n\t\tCC += cc[i]-'0'; DD += d[i]-'0';\n\t\tif(A){\n\t\t\tret += c(A-1+C+D,A-1) * ((add+zan)%mod) % mod * cnt % mod;\n\t\t}\n\t\telse if(C+D==0){\n\t\t\tret += ((add+zan)%mod) % mod * cnt % mod;\n\t\t}\n\t\tzan = add * cnt % mod + zan * max(1,cnt) % mod;\n\t}\n\treturn ret%mod;\n}\nint n,m;\nstring a,b,cc,d;\nint main(){\n\tcin>>n>>m>>a>>b>>cc>>d;\n\tmake();\n\tans+=sol(n,m,a,b,cc,d);\n\tans+=sol(m,n,cc,d,a,b);\n\tcout<<ans%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll factorials[100001];\nll invFactorials[100001];\n\n// Calculates a^b mod n.\nll powMod(ll a, ll b, ll n) {\n  if (b == 0) return 1;\n  ll res = 1;\n  while (b > 1) {\n    if (b & 1) res = (a * res) % n;\n    a = (a * a) % n;\n    b /= 2;\n  }\n  return (a * res) % n;\n}\n\n// Calculates binomial coefficient n choose k.\nll binom(ll n, ll k) {\n  if (k > n) return 0;\n  return factorials[n] * invFactorials[k] % MOD * invFactorials[n - k] % MOD;\n}\n\n// Calculates the number of paintings with x horizontal persons, y persons from\n// the top and z persons from the bottom under the assumption that a horizontal\n// person moves first.\nll countSubs(int x, int y, int z) {\n  if (x == 0) {\n    if (y == 0 && z == 0) return 1;\n    return 0;\n  }\n  return binom(x + y + z - 1, x - 1);\n}\n\n// Counts the number of different paintings assuming that the first person moves\n// vertically. Call again with the mirrored instance to get total number.\nll solve(int n, int m, string &a, string &b, string &c, string &d) {\n  int left = 0, right = 0, bottomRight = 0, topRight = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] == '1') left++;\n    if (b[i] == '1') right++;\n  }\n  for (int i = 0; i < m; i++) {\n    if (c[i] == '1') topRight++;\n    if (d[i] == '1') bottomRight++;\n  }\n  ll result = 0, prefix = 0;\n  int bottomLeft = 0, topLeft = 0;\n  for (int i = 0; i < m; i++) {\n    if (c[i] == '0' && d[i] == '0') continue;\n    prefix += countSubs(left, bottomLeft, topLeft);\n    prefix %= MOD;\n    if (c[i] == '1' && d[i] == '1') {\n      prefix *= 2;\n      prefix %= MOD;\n    }\n    if (c[i] == '1') {\n      topLeft++;\n      topRight--;\n    }\n    if (d[i] == '1') {\n      bottomLeft++;\n      bottomRight--;\n    }\n    result += prefix * countSubs(right, bottomRight, topRight);\n    result %= MOD;\n  }\n  return result;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  // Precalculate factorials and inverse factorials.\n  factorials[0] = 1;\n  invFactorials[0] = 1;\n  for (ll i = 1; i <= 100000; i++) {\n    factorials[i] = factorials[i - 1] * i % MOD;\n    invFactorials[i] = powMod(factorials[i], MOD - 2, MOD);\n  }\n\n  ll n, m;\n  cin >> n >> m;\n  string a, b, c, d;\n  cin >> a >> b >> c >> d;\n\n  // If there are no persons at all, the answer is 1.\n  bool anyPerson = false;\n  for (int i = 0; i < n; i++) {\n    anyPerson |= a[i] == '1';\n    anyPerson |= b[i] == '1';\n  }\n  for (int i = 0; i < m; i++) {\n    anyPerson |= c[i] == '1';\n    anyPerson |= d[i] == '1';\n  }\n  if (!anyPerson) {\n    cout << \"1\" << endl;\n    return 0;\n  }\n\n  // Assume first person moves vertically. Then swap instance to consider case\n  // where first person moves horizontally.\n  ll result = (solve(n, m, a, b, c, d) + solve(m, n, c, d, a, b)) % MOD;\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define maxn 401000\nusing namespace std;\nint fac[maxn],inv[maxn],n,m,pw[maxn],pw2[maxn],f[maxn],g[maxn],s[maxn],t[maxn];\nchar A[maxn],B[maxn],C[maxn],D[maxn];\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint gC(int x,int y){\n\tif(x>y||x<0)return 0;\n\treturn 1ll*fac[y]*inv[x]%mod*inv[y-x]%mod;\n}\nint sol(int n,int m,char A[],char B[],char C[],char D[]){\n\tfor(int i=1;i<=m;++i)s[i]=(C[i]=='1'&&D[i]=='1')+s[i-1];\n\tfor(int i=1;i<=m;++i)t[i]=(C[i]=='1')+t[i-1]+(D[i]=='1');\n\tint x=0,y=0,ans=0;\n\tfor(int i=1;i<=n;++i)x+=(A[i]=='1'),y+=(B[i]=='1');\n\tmemset(f,0,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(int i=0;i<=m;++i){\n\t\tf[i]=gC(x,t[i]+x);\n\t\tif(t[i])f[i]-=gC(x,t[i]+x-1);\n\t\tf[i]=1ll*f[i]*pw[s[i]]%mod;\n\t\tif(C[i+1]=='0'&&D[i+1]=='0')f[i]=0;\n\t}\n\tfor(int i=1;i<=m+1;++i){\n\t\tg[i]=gC(y,t[m]-t[i-1]+y);\n\t\tif(g[i])g[i]-=gC(y,t[m]-t[i-1]+y-1);\n\t\tg[i]=1ll*g[i]*pw2[s[i-1]]%mod;\n\t\tif(C[i-1]=='0'&&D[i-1]=='0')g[i]=0;\n\t}\n\tfor(int i=1;i<=m;++i)f[i]=(f[i-1]+f[i])%mod;\n\tfor(int i=1;i<=m;++i)ans=(ans+1ll*f[i-1]*g[i+1])%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=2*(n+m);++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2*(n+m)]=qpow(fac[2*(n+m)],mod-2);\n\tfor(int i=2*(n+m)-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tpw[0]=pw2[0]=1;\n\tfor(int i=1;i<=max(n,m);++i)pw[i]=1ll*pw[i-1]*(mod+1)/2%mod,pw2[i]=1ll*pw2[i-1]*2%mod;\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tprintf(\"%d\",(sol(n,m,A,B,C,D)+sol(m,n,C,D,A,B))%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int N=200010;\nconst int maxn=200000;\n//const int N=20;\n//const int maxn=10;\nconst int mod=998244353;\nint a[N][2],sa[N][2],b[N][2],sb[N][2];\nint cj[N],inv[N];\nchar s[N];\nint ans;\n\nint power(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod){\n\t\tif(y&1)\tret=1ll*ret*x%mod;\n\t}\n\treturn ret;\n}\n\nint C(int n,int m){\n\treturn 1ll*cj[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint calc(int n,int m){\n\tif(n==0&&m==0)\treturn 1;\n\tif(n==0)\treturn 0;\n\tif(m==0)\treturn 1;\n\treturn C(n+m-1,m);\n}\n\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint n,m;int i,j,now;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);rep(i,1,n)\ta[i][0]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,n)\ta[i][1]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,m)\tb[i][0]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,m)\tb[i][1]=s[i]=='1';\n\trep(i,1,n)\trep(j,0,1)\tsa[i][j]=sa[i-1][j]+a[i][j];\n\trep(i,1,m)\trep(j,0,1)\tsb[i][j]=sb[i-1][j]+b[i][j];\n\trep(i,1,n)\t\n\tcj[0]=1;rep(i,1,maxn)\tcj[i]=1ll*cj[i-1]*i%mod;\n\tinv[maxn]=power(cj[maxn],mod-2);inv[0]=1;\n\tfor(i=maxn-1;i;i--)\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tnow=0;\n\trep(i,1,n){\n\t\tif(a[i][0]+a[i][1]==0)\tcontinue;\n\t\tnow=(now+calc(sb[m][0],sa[i-1][0]+sa[i-1][1]))%mod;\n\t\tans=(ans+1ll*now*(a[i][0]+a[i][1])*calc(sb[m][1],sa[n][0]+sa[n][1]-sa[i][0]-sa[i][1]))%mod;\n\t\tnow=1ll*now*(a[i][0]+a[i][1])%mod;\n\t}\n\tnow=0;\n\trep(i,1,m){\n\t\tif(b[i][0]+b[i][1]==0)\tcontinue;\n\t\tnow=(now+calc(sa[n][0],sb[i-1][0]+sb[i-1][1]))%mod;\n\t\tans=(ans+1ll*now*(b[i][0]+b[i][1])*calc(sa[n][1],sb[m][0]+sb[m][1]-sb[i][0]-sb[i][1]))%mod;\n\t\tnow=1ll*now*(b[i][0]+b[i][1])%mod;\n\t}\n\tprintf(\"%d\",ans);\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n ***\n Idea:\n */\n\n#include <memory.h>\n#include <ctime>\n#include <random>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<long> vl;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<long, long> ll;\n\nconst long MOD = 998244353;\n\nclass ModernPainting{\n    long X1, X2, M, nTwo;\n    string top,bot;\n    vl posi, nega, invs;\n    inline long mPlus(long x,long y){ return (x+y)%MOD; }\n    void refMPlus(long &x, long y){\n        x += y;\n        if(x >= MOD) x %= MOD;\n    }\n    inline double mTimes(long x,long y){ return (x*y)%MOD; }\n    void refMTimes(long &x,long y){\n        x *= y;\n        if(x >= MOD) x%=MOD;\n    }\n    long mPower(long n,long k){  // compute n^k (mod MOD)\n        long ans = 1;\n        while(k){\n            if(1&k) refMTimes(ans, n);\n            refMTimes(n, n);\n            k >>= 1;\n        }\n        return ans;\n    }\n    long mInverse(long n){\n        return mPower(n, MOD-2);\n    }\n    void init(){\n        assert(M>0);\n        posi = nega = vl(M+1, 1);\n        invs = vl(2*M+1, 1);\n        nTwo = 0;\n        for(int i=0;i<M;++i) if(top[i]==bot[i]) ++nTwo;\n        for(int i=2;i<=2*M;++i) invs[i] = mInverse(i);\n        if(X1){\n            long Y = 0, Z = 0;\n            for(int i=1;i<=M;++i){\n                long Y1 = Y + (top[i-1]=='1'), Z1 = Z + (bot[i-1]=='1');\n                if(top[i-1]==bot[i-1]){\n                    long fac = mTimes(mTimes(Y1+Z1+X1-1, Y1+Z1+X1-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    posi[i] = mTimes(posi[i-1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X1-1, invs[Y1+Z1]);\n                    posi[i] = mTimes(posi[i-1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        if(X2){\n            long Y = 0, Z = 0;\n            for(long i=M-1;i>=0;--i){\n                long Y1 = Y + (top[i]=='1'), Z1 = Z + (bot[i]=='1');\n                if(top[i]==bot[i]){\n                    long fac = mTimes(mTimes(Y1+Z1+X2-1, Y1+Z1+X2-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    nega[i] = mTimes(nega[i+1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X2-1, invs[Y1+Z1]);\n                    nega[i] = mTimes(nega[i+1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        for(long i=M-1;i>=0;--i) refMPlus(nega[i], nega[i+1]);\n    }\n    long compCnt(){\n        if(!X2) return (long)1;\n        if(!X1) return nega[1];\n        long ans = 0;\n        for(int i=0;i<M;++i) refMPlus(ans, mTimes(posi[i], nega[i+1]));\n        return ans;\n    }\npublic:\n    long solve(string t, string b,long x1, long x2){\n        X1 = x1;\n        X2 = x2;\n        \n        if(X1>X2) {\n            swap(X1, X2);\n            swap(t,b);\n            reverse(t.begin(),t.end());\n            reverse(b.begin(),b.end());\n        }\n        top.clear();\n        bot.clear();\n        for(int i=0;i<(int)b.size();++i) if(b[i]=='1'||t[i]=='1'){\n            top += t[i];\n            bot += b[i];\n        }\n        M = (int)top.size();\n        if(!M) return (long)0;\n        init();\n        return mTimes(mPower(2, nTwo), compCnt());\n    }\n};\n\nint main(){\n    int n,m;\n    string A,B,C,D;\n    cin>>n>>m>>A>>B>>C>>D;\n    long X1 = 0, X2 = 0, ans = 0;\n    for(int i=0;i<m;++i){\n        X1 += (C[i] == '1');\n        X2 += (D[i] == '1');\n    }\n    ans += ModernPainting().solve(B, A, X1, X2);\n    X1 = X2 = 0;\n    for(int i=0;i<n;++i){\n        X1 += (A[i] == '1');\n        X2 += (B[i] == '1');\n    }\n    ans += ModernPainting().solve(C, D, X1, X2);\n    cout<<(ans%MOD)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nvector<int> ipow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(b==0) return 1;\n\tif(a<b) return 0;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear(); ipow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tipow2.resize(_n+1);\n\tpow2[0]=ipow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\tipow2[i]=inverse(pow2[i]);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint l[111111];\nint r[111111];\nint u[111111];\nint d[111111];\nint prefL[111111];\nint prefR[111111];\nint prefU[111111];\nint prefD[111111];\nint prefUD[111111];\n\nint sumL(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefL[r];\n\telse return add(prefL[r],MOD-prefL[l-1]);\n}\n\nint sumR(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefR[r];\n\telse return add(prefR[r],MOD-prefR[l-1]);\n}\n\nint sumU(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefU[r];\n\telse return add(prefU[r],MOD-prefU[l-1]);\n}\n\nint sumD(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefD[r];\n\telse return add(prefD[r],MOD-prefD[l-1]);\n}\n\nint sumUD(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefUD[r];\n\telse return add(prefUD[r],MOD-prefUD[l-1]);\n}\n\nint solve(int r, int c)\n{\n\treturn choose(r+c-1,r);\n}\n\nvoid calcL(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefL[i]=(s[i]=='1');\n\t\tif(i>0) prefL[i]+=prefL[i-1];\n\t}\n}\n\nvoid calcR(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefR[i]=(s[i]=='1');\n\t\tif(i>0) prefR[i]+=prefR[i-1];\n\t}\n}\n\nvoid calcU(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefU[i]=(s[i]=='1');\n\t\tif(i>0) prefU[i]+=prefU[i-1];\n\t}\n}\n\nvoid calcD(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefD[i]=(s[i]=='1');\n\t\tif(i>0) prefD[i]+=prefD[i-1];\n\t}\n}\n\nvoid calcUD(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefUD[i]=(s[i]=='1');\n\t\tif(i>0) prefUD[i]+=prefUD[i-1];\n\t}\n}\n\nint dpl[222222];\nint dpr[222222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(533333);\n\tint n,m; cin>>n>>m;\n\tstring L,R,U,D;\n\tcin>>L;\n\tcin>>R;\n\tcin>>U;\n\tcin>>D;\n\tstring sud;\n\tfor(int i=0;i<U.length();i++) sud+=char('0'+((U[i]-'0')&(D[i]-'0')));\n\tcalcL(L); calcR(R); calcU(U); calcD(D); calcUD(sud);\n\tif(sumL(0,n-1)==0&&sumR(0,n-1)==0&&sumU(0,m-1)==0&&sumD(0,m-1)==0){cout<<1<<'\\n'; return 0;}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint ltot=sumL(0,n-1);\n\t\tint c1=sumU(0,l-1);\n\t\tint c2=sumD(0,l-1);\n\t\tif(l==0) dpl[l]=1;\n\t\telse dpl[l]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tint ltot=sumR(0,n-1);\n\t\tint c1=sumU(r+1,m-1);\n\t\tint c2=sumD(r+1,m-1);\n\t\tif(r==m-1) dpr[r]=1;\n\t\telse dpr[r]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tint ans=0;\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint r=l;\n\t\tint coeff = mult(pow2[sumUD(l+1,r-1)],((U[l]=='1')+(D[l]=='1'))*(l==r?1:((U[r]=='1')+(D[r]=='1'))));\n\t\tif(coeff==0) continue;\n\t\tint res1=dpl[l];\n\t\tint res2=dpr[r];\n\t\tans=add(ans,mult(coeff,mult(res1,res2)));\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tdpl[l]=mult(dpl[l],ipow2[prefUD[l]]);\n\t\tdpl[l]=mult(dpl[l],(U[l]=='1')+(D[l]=='1'));\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tdpr[r]=mult(dpr[r],pow2[(r>0?prefUD[r-1]:0)]);\n\t\tdpr[r]=mult(dpr[r],(U[r]=='1')+(D[r]=='1'));\n\t}\n\tint sum=0;\n\tfor(int l=0;l+1<m;l++)\n\t{\n\t\t//solve for all r>l\n\t\tsum=add(sum,dpl[l]);\n\t\tans=add(ans,mult(sum,dpr[l+1]));\n\t}\n\tswap(U,L); swap(R,D); swap(n,m);\n\tsud=\"\";\n\tfor(int i=0;i<U.length();i++) sud+=char('0'+((U[i]-'0')&(D[i]-'0')));\n\tcalcL(L); calcR(R); calcU(U); calcD(D); calcUD(sud);\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint ltot=sumL(0,n-1);\n\t\tint c1=sumU(0,l-1);\n\t\tint c2=sumD(0,l-1);\n\t\tif(l==0) dpl[l]=1;\n\t\telse dpl[l]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tint ltot=sumR(0,n-1);\n\t\tint c1=sumU(r+1,m-1);\n\t\tint c2=sumD(r+1,m-1);\n\t\tif(r==m-1) dpr[r]=1;\n\t\telse dpr[r]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint r=l;\n\t\tint coeff = mult(pow2[sumUD(l+1,r-1)],((U[l]=='1')+(D[l]=='1'))*(l==r?1:((U[r]=='1')+(D[r]=='1'))));\n\t\tif(coeff==0) continue;\n\t\tint res1=dpl[l];\n\t\tint res2=dpr[r];\n\t\tans=add(ans,mult(coeff,mult(res1,res2)));\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tdpl[l]=mult(dpl[l],ipow2[prefUD[l]]);\n\t\tdpl[l]=mult(dpl[l],(U[l]=='1')+(D[l]=='1'));\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tdpr[r]=mult(dpr[r],pow2[(r>0?prefUD[r-1]:0)]);\n\t\tdpr[r]=mult(dpr[r],(U[r]=='1')+(D[r]=='1'));\n\t}\n\tsum=0;\n\tfor(int l=0;l+1<m;l++)\n\t{\n\t\t//solve for all r>l\n\t\tsum=add(sum,dpl[l]);\n\t\tans=add(ans,mult(sum,dpr[l+1]));\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1000000010\n#define INFLL ((1LL<<62)-5)\n#define FO(i,a,b) for (int (i) = (a); (i) < (b); ++(i))\n#define OF(i,a,b) for (int (i) = (a)-1; (i) >= (b); --(i))\n#define SZ(v) int(v.size())\n\nusing namespace std;\n//PAIRS:\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n/*~~~~TEMPLATE END~~~~*/\n\n//DEBUGS:\n//#define DEBUG\n\n#ifdef DEBUG\n#define dprintf printf\n#else\n#define dprintf(...)\n#endif\n\nconst long long MOD = 998244353;\nconst ll MAX_N = 100005;\n\nll inv[MAX_N*4+5];\nll fact[MAX_N*4+5];\nll invfact[MAX_N*4+5];\n\nll minv (ll c) {\n    ll ret = 1;\n    ll cP = c;\n    FO (i,0,31) {\n        if ((MOD-2) & (1<<i)) {\n            ret = (ret*cP) % MOD;\n        }\n        cP = (cP*cP) % MOD;\n    }\n    return ret;\n}\n\nvoid precomp() {\n    FO (i,1,400010) {\n        inv[i] = minv(i);\n    }\n    fact[0] = 1;\n    FO (i,1,400010) fact[i] = (fact[i-1]*i) % MOD;\n    invfact[0] = 1;\n    FO (i,1,400010) invfact[i] = (invfact[i-1]*inv[i]) % MOD;\n}\n\nll chs(ll a, ll b) {\n    return ((fact[a] * invfact[b])%MOD * invfact[a-b])%MOD;\n}\n\nstruct solver {\n    int N, M;\n    vector<int> vAm;\n    vector<int> lV;\n    vector<int> rV;\n    solver(int __N, int _M, vector<int> &_vAm, vector<int> &_lV, vector<int> &_rV) {\n        N = __N;\n       M = _M;\n        vAm = _vAm;\n        lV = _lV;\n        rV = _rV;\n    }\n    ll solve() {\n        // rAm contains right side vals, hori must occur.\n        vector <ll> rAm;\n        ll wAm = 0;\n        for (int i : rV) wAm += i;\n        ll hAm = 0;\n        OF (i,M,0) {\n            if (wAm == 0) {\n                if (hAm > 0) rAm.pb(0);\n                else rAm.pb(1);\n            } else {\n                rAm.pb(chs(wAm+hAm-1, wAm-1));\n            }\n            hAm += vAm[i];\n        }\n        reverse(rAm.begin(), rAm.end());\n        FO (i,0,M) dprintf (\"%lld \", rAm[i]);\n        dprintf(\"\\n\");\n        // lAm contains left side vals, hori need not occur.\n        vector <ll> lAm;\n        wAm = 0;\n        for (int i : lV) wAm += i;\n        hAm = 0;\n        FO (i,0,M) {\n            if (wAm == 0) {\n                if (hAm > 0) lAm.pb(0);\n                else lAm.pb(1);\n            } else {\n                lAm.pb(chs(wAm+hAm-1, wAm-1));\n            }\n            hAm += vAm[i];\n        }\n        FO (i,0,M) dprintf (\"%lld \", lAm[i]);\n        dprintf(\"\\n\");\n        FO (i,0,M)\n            if (!vAm[i]) lAm[i] = 0;\n        FO (i,0,M) {\n            if (i) lAm[i] += lAm[i-1];\n            if (vAm[i] == 2) lAm[i] *= 2;\n            lAm[i] %= MOD;\n        }\n        ll ans = 0;\n        FO (i,0,M) {\n            if (vAm[i]) {\n                ans += (lAm[i] * rAm[i])%MOD;\n                ans %= MOD;\n            }\n        }\n        return ans;\n    }\n};\n\nint N, M;\nvector <int> a, b, c, d;\n\nint main() {\n    precomp();\n    scanf (\"%d %d\", &N, &M);\n    FO (i,0,N) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        a.pb(t);\n    }\n    FO (i,0,N) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        b.pb(t);\n    }\n    FO (i,0,M) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        c.pb(t);\n    }\n    FO (i,0,M) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        d.pb(t);\n    }\n    int s = 0;\n    FO (i,0,N) s += a[i] + b[i];\n    FO (i,0,M) s += c[i] + b[i];\n    if (!s) {\n        printf (\"1\\n\");\n        return 0;\n    }\n    ll ans = 0;\n    FO (i,0,2) {\n        vector <int> t;\n        FO (i,0,M) {\n            t.pb(c[i]+d[i]);\n        }\n        solver s(N,M,t,a,b);\n        ans += s.solve();\n        dprintf (\"ans: %lld\\n\", ans);\n\n        swap(N,M);\n        swap(a,c);\n        swap(b,d);\n    }\n    printf (\"%lld\\n\", ans % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int mod = 998244353;\n\nint res;\nint f[N], g[N];\nint prd[N * 3], inv[N * 3];\n\nint C(int n, int k) {\n\tif (k < 0) return n < 0;\n\treturn 1LL * prd[n] * inv[n - k] % mod * inv[k] % mod; \n}\n\nint pw(int x, int y) {\n\tif (!y) return 1;\n\tint ret = pw(x, y >> 1); ret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; return ret;\n}\n\nvoid solve(int n, int m, string a, string b, string c, string d) {\n\tint cntc, cntd;\n\tcntc = cntd = 0;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcntc += c[i] == '1', cntd += d[i] == '1';\n\t}\n\tf[1] = g[n] = 1;\n\tint cnta, cntb;\n\tcnta = cntb = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tcnta += a[i] == '1', cntb += b[i] == '1';\n\t\tf[i + 1] = C(cnta + cntb + cntc - 1, cntc - 1);\n\t}\n\tcnta = cntb = 0;\n\tfor (int i = n; i > 1; --i) {\n\t\tcnta += a[i] == '1', cntb += b[i] == '1';\n\t\tg[i - 1] = C(cnta + cntb + cntd - 1, cntd - 1);\n\t}\n\tint sum = 0, cur = 1;\n\tfor (int i = n; i >= 1; --i) {\n\t\tint cnt = 0;\n\t\tcnt += a[i] == '1', cnt += b[i] == '1';\n\t\tif (!cnt) continue;\n\t\tcur = cur * cnt % mod;\n\t\tsum = (sum + 1LL * cur * f[i]) % mod;\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tint cnt = 0;\n\t\tcnt += a[i] == '1', cnt += b[i] == '1';\n\t\tif (!cnt) continue;\n\t\tres = (res + 1LL * sum * g[i]) % mod;\n\t\tsum = (sum - 1LL * cnt * f[i]) % mod;\n\t\tif (sum < 0) sum += mod;\n\t\tsum = 1LL * sum * pw(cnt, mod - 2) % mod;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tprd[0] = inv[0] = 1;\n\tfor (int i = 1; i < 3 * N; ++i) {\n\t\tprd[i] = 1LL * i * prd[i - 1] % mod;\n\t\tinv[i] = pw(prd[i], mod - 2);\n\t}\n\tint n, m;\n\tstring a, b, c, d;\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\tbool have = 0;\n\ta = \" \" + a, b = \" \" + b, c = \" \" + c, d = \" \" + d; \n\tfor (int i = 1; i <= n; ++i) {\n\t\thave |= a[i] == '1' || b[i] == '1';\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\thave |= c[i] == '1' || d[i] == '1';\n\t}\n\tif (!have) {\n\t\tcout << 1; return 0;\n\t}\n\tsolve(n, m, a, b, c, d);\n\tsolve(m, n, c, d, a, b);\n\tcout << res; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool aflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') aflag = true;\n\t}\n\tif(!aflag) swap(l, u), swap(r, d), swap(h, w);\n\t\n\tbool bflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') bflag = true;\n\t}\n\tif(!aflag && !bflag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define maxn 401000\nusing namespace std;\nint fac[maxn],inv[maxn],n,m,pw[maxn],pw2[maxn],f[maxn],g[maxn],s[maxn],t[maxn];\nchar A[maxn],B[maxn],C[maxn],D[maxn];\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint gC(int x,int y){\n\tif(x>y||x<0)return 0;\n\treturn 1ll*fac[y]*inv[x]%mod*inv[y-x]%mod;\n}\nint sol(int n,int m,char A[],char B[],char C[],char D[]){\n\tfor(int i=1;i<=m;++i)s[i]=(C[i]=='1'&&D[i]=='1')+s[i-1];\n\tfor(int i=1;i<=m;++i)t[i]=(C[i]=='1')+t[i-1]+(D[i]=='1');\n\tint x=0,y=0,ans=0;\n\tfor(int i=1;i<=n;++i)x+=(A[i]=='1'),y+=(B[i]=='1');\n\tmemset(f,0,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(int i=0;i<=m;++i){\n\t\tf[i]=gC(x,t[i]+x);\n\t\tif(t[i])f[i]-=gC(x,t[i]+x-1);\n\t\tf[i]=1ll*f[i]*pw[s[i]]%mod;\n\t\tif(C[i+1]=='0'&&D[i+1]=='0')f[i]=0;\n\t}\n\tfor(int i=1;i<=m+1;++i){\n\t\tg[i]=gC(y,t[m]-t[i-1]+y);\n\t\tif(g[i])g[i]-=gC(y,t[m]-t[i-1]+y-1);\n\t\tg[i]=1ll*g[i]*pw2[s[i-1]]%mod;\n\t\tif(C[i-1]=='0'&&D[i-1]=='0')g[i]=0;\n\t}\n\tfor(int i=1;i<=m;++i)f[i]=(f[i-1]+f[i])%mod;\n\tfor(int i=1;i<=m;++i)ans=(ans+1ll*f[i-1]*g[i+1])%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=2*(n+m);++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2*(n+m)]=qpow(fac[2*(n+m)],mod-2);\n\tfor(int i=2*(n+m)-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tpw[0]=pw2[0]=1;\n\tfor(int i=1;i<=max(n,m);++i)pw[i]=1ll*pw[i-1]*(mod+1)/2%mod,pw2[i]=1ll*pw2[i-1]*2%mod;\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tfor(int i=1;i<=max(n,m);++i)if(A[i]=='1'||B[i]=='1'||C[i]=='1'||D[i]=='1')goto nxt;\n\tputs(\"1\");\n\treturn 0;\n\tnxt:;\n\tprintf(\"%d\",(sol(n,m,A,B,C,D)+sol(m,n,C,D,A,B))%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 100001;\nconst int MOD = 998244353;\n\nint fact[N * 3], inv_fact[N * 3];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint solve(int n, int m, char* a, char* b, char* c, char* d)\n{\n    static int ways[2][N];\n    memset(ways, 0, sizeof(ways));\n    for (int _ = 0; _ < 2; ++ _) {\n        int C = 0;\n        for (int j = 0; j < m; ++ j) {\n            C += c[j] == '1';\n        }\n        int A = 0;\n        int B = 0;\n        for (int i = 0; i < n; ++ i) {\n            if (a[i] == '0' && b[i] == '0') {\n                continue;\n            }\n            if (C) {\n                ways[_][i] = (long long)fact[A + B + C - 1] * inv_fact[A + B] % MOD * inv_fact[C - 1] % MOD;\n            } else if (!A && !B) {\n                ways[_][i] = 1;\n            }\n            A += a[i] == '1';\n            B += b[i] == '1';\n        }\n        std::reverse(a, a + n);\n        std::reverse(b, b + n);\n        std::swap(a, b);\n        std::swap(c, d);\n    }\n    std::reverse(ways[1], ways[1] + n);\n    int result = 0;\n    int prefix = 0;\n    for (int i = 0; i < n; ++ i) {\n        update(prefix, ways[0][i]);\n        if (a[i] == '1' && b[i] == '1') {\n            prefix = 2LL * prefix % MOD;\n        }\n        update(result, (long long)prefix * ways[1][i] % MOD);\n    }\n    return result;\n}\n\nint main()\n{\n    inv_fact[1] = 1;\n    for (int i = 2; i < N * 3; ++ i) {\n        inv_fact[i] = (long long)(MOD - MOD / i) * inv_fact[MOD % i] % MOD;\n    }\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < N * 3; ++ i) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n        inv_fact[i] = (long long)inv_fact[i - 1] * inv_fact[i] % MOD;\n    }\n    int n, m;\n    static char a[N], b[N], c[N], d[N];\n    while (scanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d) == 6) {\n        int result = solve(n, m, a, b, c, d);\n        update(result, solve(m, n, c, d, a, b));\n        printf(\"%d\\n\", result);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 4001000;\nll f[N], rf[N];\nll p2[N], rp2[N];\n\nll getC(int n, int k) {\n\tif (k < 0 || k > n) return 0;\n\treturn mult(f[n], mult(rf[k], rf[n - k]));\n}\n\nint n, m;\nchar s[N];\nint a[N], b[N], c[N], d[N];\nll L[N], R[N];\nint sum[N];\n\nll solve() {\n\tfor (int i = 0; i <= n; i++)\n\t\tsum[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum[i + 1] = sum[i];\n\t\tif (a[i] && b[i])\n\t\t\tsum[i + 1]++;\n\t}\n\tint A = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tA += c[i];\n\tint B = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tL[i] = R[i] = 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == 0 && b[i] == 0) continue;\n\t\tif (A == 0) {\n\t\t\tL[i] = (B == 0 ? 1 : 0);\n\t\t} else {\n\t\t\tL[i] = getC(A - 1 + B, B);\n\t\t}\n\t\tB += a[i] + b[i];\n\t}\n\tA = B = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tA += d[i];\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (a[i] == 0 && b[i] == 0) continue;\n\t\tif (A == 0) {\n\t\t\tR[i] = (B == 0 ? 1 : 0);\n\t\t} else {\n\t\t\tR[i] = getC(A - 1 + B, B);\n\t\t}\n\t\tB += a[i] + b[i];\n\t}\n\tll ans = 0;\n\tll curSum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcurSum = add(curSum, mult(L[i], rp2[sum[i]]));\n\t\tans = add(ans, mult(mult(curSum, R[i]), p2[sum[i + 1]]));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\trf[N - 1] = rev(f[N - 1]);\n\tfor (int i = N - 1; i > 0; i--)\n\t\trf[i - 1] = mult(rf[i], i);\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\trp2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\trp2[i] = rp2[i - 1];\n\t\tif (rp2[i] & 1) rp2[i] += MOD;\n\t\trp2[i] >>= 1;\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = (int)s[i] - '0';\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = (int)s[i] - '0';\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < m; i++)\n\t\tc[i] = (int)s[i] - '0';\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < m; i++)\n\t\td[i] = (int)s[i] - '0';\n\n\tbool allZ = true;\n\tfor (int i = 0; i < n; i++)\n\t\tallZ &= a[i] == 0 && b[i] == 0;\n\tfor (int i = 0; i < m; i++)\n\t\tallZ &= c[i] == 0 && d[i] == 0;\n\tif (allZ) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\tll ans = solve();\n\tswap(n, m);\n\tswap(a, c);\n\tswap(b, d);\n\tans = add(ans, solve());\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n ***\n Idea:\n */\n\n#include <memory.h>\n#include <ctime>\n#include <random>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<long> vl;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<long, long> ll;\n\nconst long MOD = 998244353;\n\nclass ModernPainting{\n    long X1, X2, M, nTwo;\n    string top,bot;\n    vl posi, nega, invs;\n    inline long mPlus(long x,long y){ return (x+y)%MOD; }\n    void refMPlus(long &x, long y){\n        x += y;\n        if(x >= MOD) x %= MOD;\n    }\n    inline double mTimes(long x,long y){ return (x*y)%MOD; }\n    void refMTimes(long &x,long y){\n        x *= y;\n        if(x >= MOD) x%=MOD;\n    }\n    long mPower(long n,long k){  // compute n^k (mod MOD)\n        long ans = 1;\n        while(k){\n            if(1&k) refMTimes(ans, n);\n            refMTimes(n, n);\n            k >>= 1;\n        }\n        return ans;\n    }\n    long mInverse(long n){\n        return mPower(n, MOD-2);\n    }\n    void init(){\n        assert(M>0);\n        posi = nega = vl(M+1, 1);\n        invs = vl(2*M+1, 1);\n        nTwo = 0;\n        for(int i=0;i<M;++i) if(top[i]==bot[i]) ++nTwo;\n        for(int i=2;i<=2*M;++i) invs[i] = mInverse(i);\n        if(X1){\n            long Y = 0, Z = 0;\n            for(int i=1;i<=M;++i){\n                long Y1 = Y + (top[i-1]=='1'), Z1 = Z + (bot[i-1]=='1');\n                if(top[i-1]==bot[i-1]){\n                    long fac = mTimes(mTimes(Y1+Z1+X1-1, Y1+Z1+X1-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    posi[i] = mTimes(posi[i-1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X1-1, invs[Y1+Z1]);\n                    posi[i] = mTimes(posi[i-1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        if(X2){\n            long Y = 0, Z = 0;\n            for(long i=M-1;i>=0;--i){\n                long Y1 = Y + (top[i]=='1'), Z1 = Z + (bot[i]=='1');\n                if(top[i]==bot[i]){\n                    long fac = mTimes(mTimes(Y1+Z1+X2-1, Y1+Z1+X2-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    nega[i] = mTimes(nega[i+1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X2-1, invs[Y1+Z1]);\n                    nega[i] = mTimes(nega[i+1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        for(long i=M-1;i>=0;--i) refMPlus(nega[i], nega[i+1]);\n    }\n    long compCnt(){\n        if(!X2) return (long)1;\n        if(!X1) return nega[1];\n        long ans = 0;\n        for(int i=0;i<M;++i) refMPlus(ans, mTimes(posi[i], nega[i+1]));\n        return ans;\n    }\npublic:\n    long solve(string t, string b,long x1, long x2){\n        X1 = x1;\n        X2 = x2;\n        if(X1>X2) {\n            swap(X1, X2);\n            swap(t,b);\n        }\n        top.clear();\n        bot.clear();\n        for(int i=0;i<(int)b.size();++i) if(b[i]=='1'||t[i]=='1'){\n            top += t[i];\n            bot += b[i];\n        }\n        M = (int)top.size();\n        if(!M) return (long)0;\n        init();\n        return mTimes(mPower(2, nTwo), compCnt());\n    }\n};\n\nint main(){\n    int n,m;\n    string A,B,C,D;\n    cin>>n>>m>>A>>B>>C>>D;\n    long X1 = 0, X2 = 0, ans = 0;\n    for(int i=0;i<m;++i){\n        X1 += (C[i] == '1');\n        X2 += (D[i] == '1');\n    }\n    ans += ModernPainting().solve(A, B, X1, X2);\n    X1 = X2 = 0;\n    for(int i=0;i<n;++i){\n        X1 += (A[i] == '1');\n        X2 += (B[i] == '1');\n    }\n    ans += ModernPainting().solve(C, D, X1, X2);\n    cout<<(ans%MOD)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst long long md=998244353;\nconst int maxn=200000;\nchar str1[100100],str2[100100];\nchar str3[100100],str4[100100];\nlong long fac[maxn+100],inv[maxn+100];\nlong long f[maxn+100],g[maxn+100];\nlong long C(int n,int m){\n\tif(n<=0||m==0) return 1;\n\tif(m<0||m>n) return 0;\n\treturn fac[n]*inv[m]%md*inv[n-m];\n}\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str1+1),scanf(\"%s\",str2+1);\n\tscanf(\"%s\",str3+1),scanf(\"%s\",str4+1);\n\tbool bo1=1,bo2=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(str1[i]=='1'||str2[i]=='1'){\n\t\t\tbo1=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(str3[i]=='1'||str4[i]=='1'){\n\t\t\tbo2=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(bo1||bo2){\n\t\tlong long ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(str1[i]=='1'&&str2[i]=='1')\n\t\t\t\tans=ans*2%md;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(str3[i]=='1'&&str4[i]=='1')\n\t\t\t\tans=ans*2%md;\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=maxn;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[maxn]=powd(fac[maxn],md-2);\n\tfor(int i=maxn;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str3[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str4[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=n;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tlong long ans=0,sum=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str1[i]-'0')&&(str2[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tsum=0;\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str1[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str2[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=m;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str3[i]-'0')&&(str4[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nint fact[200001],ifact[200001];\nint ncr(int n,int r)\n{\n\treturn (ll)fact[n]*ifact[n-r]%MOD*ifact[r]%MOD;\n}\n\nvector<mint> calc(const vi& ls,const vi& ts,const vi& bs)\n{\n\tvi js=ts; js.insert(js.end(),all(bs));\n\tsort(all(js)); js.erase(unique(all(js)),end(js));\n\n\tvector<mint> cs;\n\tint ln=ls.size();\n\tfor(int j:js){\n\t\tint tn=lower_bound(all(ts),j)-begin(ts),bn=lower_bound(all(bs),j)-begin(bs);\n\t\tif(ln==0){\n\t\t\tif(tn+bn==0)\n\t\t\t\tcs.push_back(1);\n\t\t\telse\n\t\t\t\tcs.push_back(0);\n\t\t}\n\t\telse{\n\t\t\tcs.push_back(ncr(ln-1+tn+bn,tn+bn));\n\t\t}\n\t}\n\treturn cs;\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfact[0]=ifact[0]=1;\n\trepi(i,1,200001){\n\t\tfact[i]=(ll)fact[i-1]*i%MOD;\n\t\tifact[i]=mint(fact[i]).inv().val;\n\t}\n\n\tfor(int h,w;cin>>h>>w&&h|w;){\n\t\tstring a,b,c,d; cin>>a>>b>>c>>d;\n\n\t\tmint res;\n\t\trep(_,2){\n\t\t\tvi ls,rs,ts,bs;\n\t\t\trep(i,h) if(a[i]=='1') ls.push_back(i);\n\t\t\trep(i,h) if(b[i]=='1') rs.push_back(i);\n\t\t\trep(i,w) if(c[i]=='1') ts.push_back(i);\n\t\t\trep(i,w) if(d[i]=='1') bs.push_back(i);\n\n\t\t\tvi js=ts; js.insert(js.end(),all(bs));\n\t\t\tsort(all(js)); js.erase(unique(all(js)),end(js));\n\n\t\t\tvi two(w+1);\n\t\t\trep(i,w) two[i+1]=two[i]+(c[i]=='1'&&d[i]=='1');\n\n\t\t\tvector<mint> dpl(js.size());\n\t\t\t{\n\t\t\t\tvector<mint> cs=calc(ls,ts,bs);\n\t\t\t\tmint prev=0;\n\t\t\t\trep(i,js.size()){\n\t\t\t\t\tint j=js[i];\n\t\t\t\t\tdpl[i]=prev+cs[i]*mint(2).pow(two[w]-two[j]);\n\t\t\t\t\tprev=dpl[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvi ts2(rbegin(ts),rend(ts)),bs2(rbegin(bs),rend(bs));\n\t\t\t\tfor(int& j:ts2) j=w-1-j;\n\t\t\t\tfor(int& j:bs2) j=w-1-j;\n\t\t\t\tvector<mint> cs=calc(rs,ts2,bs2);\n\t\t\t\treverse(all(cs));\n\t\t\t\trep(i,js.size()){\n\t\t\t\t\tint j=js[i];\n\t\t\t\t\tres+=dpl[i]*cs[i]/mint(2).pow(two[w]-two[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttie(h,w,a,b,c,d)=mt(w,h,c,d,a,b);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1000000010\n#define INFLL ((1LL<<62)-5)\n#define FO(i,a,b) for (int (i) = (a); (i) < (b); ++(i))\n#define OF(i,a,b) for (int (i) = (a)-1; (i) >= (b); --(i))\n#define SZ(v) int(v.size())\n\nusing namespace std;\n//PAIRS:\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n/*~~~~TEMPLATE END~~~~*/\n\n//DEBUGS:\n//#define DEBUG\n\n#ifdef DEBUG\n#define dprintf printf\n#else\n#define dprintf(...)\n#endif\n\nconst long long MOD = 998244353;\nconst ll MAX_N = 100005;\n\nll inv[MAX_N*4+5];\nll fact[MAX_N*4+5];\nll invfact[MAX_N*4+5];\n\nll minv (ll c) {\n    ll ret = 1;\n    ll cP = c;\n    FO (i,0,31) {\n        if ((MOD-2) & (1<<i)) {\n            ret = (ret*cP) % MOD;\n        }\n        cP = (cP*cP) % MOD;\n    }\n    return ret;\n}\n\nvoid precomp() {\n    FO (i,1,400010) {\n        inv[i] = minv(i);\n    }\n    fact[0] = 1;\n    FO (i,1,400010) fact[i] = (fact[i-1]*i) % MOD;\n    invfact[0] = 1;\n    FO (i,1,400010) invfact[i] = (invfact[i-1]*inv[i]) % MOD;\n}\n\nll chs(ll a, ll b) {\n    return ((fact[a] * invfact[b])%MOD * invfact[a-b])%MOD;\n}\n\nstruct solver {\n    int N, M;\n    vector<int> vAm;\n    vector<int> lV;\n    vector<int> rV;\n    solver(int __N, int _M, vector<int> &_vAm, vector<int> &_lV, vector<int> &_rV) {\n        N = __N;\n       M = _M;\n        vAm = _vAm;\n        lV = _lV;\n        rV = _rV;\n    }\n    ll solve() {\n        // rAm contains right side vals, hori must occur.\n        vector <ll> rAm;\n        ll wAm = 0;\n        for (int i : rV) wAm += i;\n        ll hAm = 0;\n        OF (i,M,0) {\n            if (wAm == 0) {\n                if (hAm > 0) rAm.pb(0);\n                else rAm.pb(1);\n            } else {\n                rAm.pb(chs(wAm+hAm-1, wAm-1));\n            }\n            hAm += vAm[i];\n        }\n        reverse(rAm.begin(), rAm.end());\n        FO (i,0,M) dprintf (\"%lld \", rAm[i]);\n        dprintf(\"\\n\");\n        // lAm contains left side vals, hori need not occur.\n        vector <ll> lAm;\n        wAm = 0;\n        for (int i : lV) wAm += i;\n        hAm = 0;\n        FO (i,0,M) {\n            if (wAm == 0) {\n                if (hAm > 0) lAm.pb(0);\n                else lAm.pb(1);\n            } else {\n                lAm.pb(chs(wAm+hAm-1, wAm-1));\n            }\n            hAm += vAm[i];\n        }\n        FO (i,0,M) dprintf (\"%lld \", lAm[i]);\n        dprintf(\"\\n\");\n        FO (i,0,M)\n            if (!vAm[i]) lAm[i] = 0;\n        FO (i,0,M) {\n            if (i) lAm[i] += lAm[i-1];\n            if (vAm[i] == 2) lAm[i] *= 2;\n            lAm[i] %= MOD;\n        }\n        ll ans = 0;\n        FO (i,0,M) {\n            if (vAm[i]) {\n                ans += (lAm[i] * rAm[i])%MOD;\n                ans %= MOD;\n            }\n        }\n        return ans;\n    }\n};\n\nint N, M;\nvector <int> a, b, c, d;\n\nint main() {\n    precomp();\n    scanf (\"%d %d\", &N, &M);\n    FO (i,0,N) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        a.pb(t);\n    }\n    FO (i,0,N) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        b.pb(t);\n    }\n    FO (i,0,M) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        c.pb(t);\n    }\n    FO (i,0,M) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        d.pb(t);\n    }\n    int s = 0;\n    FO (i,0,N) s += a[i] + b[i];\n    FO (i,0,M) s += c[i] + d[i];\n    if (!s) {\n        printf (\"1\\n\");\n        return 0;\n    }\n    ll ans = 0;\n    FO (i,0,2) {\n        vector <int> t;\n        FO (i,0,M) {\n            t.pb(c[i]+d[i]);\n        }\n        solver s(N,M,t,a,b);\n        ans += s.solve();\n        dprintf (\"ans: %lld\\n\", ans);\n\n        swap(N,M);\n        swap(a,c);\n        swap(b,d);\n    }\n    printf (\"%lld\\n\", ans % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 400009\n#define ll long long\n#define mod 998244353\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\nusing namespace std;\n\nint m,n,a[N],b[N],fac[N],inv[N]; char A[N],B[N],C[N],D[N];\nint solve(int m,int n,char *A,char *B,char *C,char *D){\n\tint i,x,y;\n\tmemset(a,0,sizeof(a)); memset(b,0,sizeof(b));\n\ta[0]=b[n+1]=1;\n\tfor (i=1,y=0; i<=m; i++) if (A[i]=='1') y++;\n\tfor (i=1,x=0; i<=n; i++){\n\t\tif (C[i]=='1') x++;\n\t\tif (D[i]=='1') x++;\n\t\ta[i]=cbn(x+y,x);\n\t\tif (x) a[i]=(a[i]-cbn(x+y-1,x-1)+mod)%mod;\n\t\t//cout<<i<<' '<<a[i]<<endl;\n\t}\n\tfor (i=1,y=0; i<=m; i++) if (B[i]=='1') y++;\n\tfor (i=n,x=0; i; i--){\n\t\tif (C[i]=='1') x++;\n\t\tif (D[i]=='1') x++;\n\t\tb[i]=cbn(x+y,x);\n\t\tif (x>0) b[i]=(b[i]-cbn(x+y-1,x-1)+mod)%mod;\n\t\t//cout<<i<<' '<<b[i]<<endl;\n\t}\n\tint tmp;\n\tfor (i=0,tmp=1; i<=n; i++){\n\t\tif (i>0 && C[i]=='1' && D[i]=='1') tmp=(ll)tmp*(mod+1>>1)%mod;\n\t\ta[i]=(ll)a[i]*tmp%mod;\n\t\tif (i<=n && C[i+1]=='0' && D[i+1]=='0') a[i]=0;\n\t}\n\tfor (i=1; i<=n; i++) a[i]=(a[i]+a[i-1])%mod;\n\tfor (i=tmp=1; i<=n+1; i++){\n\t\tb[i]=(ll)b[i]*tmp%mod;\n\t\tif (i<=n && C[i]=='1' && D[i]=='1') tmp=tmp*2%mod;\n\t\tif (i>1 && C[i-1]=='0' && D[i-1]=='0') b[i]=0;\n\t}\n\tint ans=0;\n\tfor (i=1; i<=n; i++) ans=(ans+(ll)b[i+1]*a[i-1])%mod;\n\t//cout<<ans<<endl;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tint i;\n\tfor (i=1; i<=m; i++) if (A[i]=='1' || B[i]=='1') break;\n\tif (i>m){\n\t\tfor (i=1; i<=n; i++) if (C[i]=='1' || D[i]=='1') break;\n\t\tif (i>n){ puts(\"1\"); return 0; }\n\t}\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (i=1; i<=(m+n<<1); i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<=(m+n<<1); i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<=(m+n<<1); i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tprintf(\"%d\\n\",(solve(m,n,A,B,C,D)+solve(n,m,C,D,A,B))%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <functional>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#define MOD 998244353\n#define SIZE 500005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nll inv[SIZE],fac[SIZE],finv[SIZE];\nvoid init()\n{\n\tfac[0]=fac[1]=1;\n\tfinv[0]=finv[1]=1;\n\tinv[1]=1;\n\tfor(int i=2;i<SIZE;i++)\n\t{\n\t\tinv[i]=MOD-inv[MOD%i]*(MOD/i)%MOD;\n\t\tfac[i]=fac[i-1]*(ll) i%MOD;\n\t\tfinv[i]=finv[i-1]*inv[i]%MOD;\n\t}\n}\nll Ct(int a,int b)\n{\n\tif(a==b) return 1;\n\tif(a<b) return 0;\n\tif(b<0) return 0;\n\treturn fac[a]*(finv[b]*finv[a-b]%MOD)%MOD;\n}\nchar sA[SIZE],sB[SIZE],sC[SIZE],sD[SIZE];\nll left[SIZE],now[SIZE];\n\nll solve(string A,string B,string C,string D)\n{\n\tint s=0,t=0;\n\tfor(int i=0;i<C.size();i++)\n\t{\n\t\ts+=C[i]-'0';\n\t\tt+=D[i]-'0';\n\t}s--,t--;\n\tint sum=0;\n\tfor(int i=0;i<A.size();i++)\n\t{\n\t\tleft[i]=0;\n\t\tif(A[i]=='1')\n\t\t{\n\t\t\tleft[i]+=Ct(sum+s,s);\n\t\t\tif(left[i]>=MOD) left[i]-=MOD;\n\t\t}\n\t\tif(B[i]=='1')\n\t\t{\n\t\t\tleft[i]+=Ct(sum+s,s);\n\t\t\tif(left[i]>=MOD) left[i]-=MOD;\n\t\t}\n\t\tnow[i]=left[i];\n\t\tif(i>0)\n\t\t{\n\t\t\tif(A[i]=='1'&&B[i]=='1')\n\t\t\t{\n\t\t\t\tleft[i]+=left[i-1]*2LL;\n\t\t\t\tleft[i]%=MOD;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tleft[i]+=left[i-1];\n\t\t\t\tleft[i]%=MOD;\n\t\t\t}\n\t\t}\n\t\tsum+=A[i]-'0';\n\t\tsum+=B[i]-'0';\n\t}\n\tsum=0;\n\tll ret=0;\n\tfor(int i=A.size()-1;i>=0;i--)\n\t{\n\t\tret+=now[i]*Ct(sum+t,t)%MOD;\n\t\tif(ret>=MOD) ret-=MOD;\n\t\tif(A[i]=='1'&&i>0)\n\t\t{\n\t\t\tret+=left[i-1]*Ct(sum+t,t)%MOD;\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t\tif(B[i]=='1'&&i>0)\n\t\t{\n\t\t\tret+=left[i-1]*Ct(sum+t,t)%MOD;\n\t\t\tif(ret>=MOD) ret-=MOD;\n\t\t}\n\t\tsum+=A[i]-'0';\n\t\tsum+=B[i]-'0';\n\t}\n\treturn ret;\n}\nint main()\n{\n\tinit();\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\tscanf(\"%s\",&sA);\n\tscanf(\"%s\",&sB);\n\tscanf(\"%s\",&sC);\n\tscanf(\"%s\",&sD);\n\tstring A=sA;\n\tstring B=sB;\n\tstring C=sC;\n\tstring D=sD;\n\tbool up=true;\n\tfor(int i=0;i<A.size();i++) if(A[i]=='1') up=false;\n\tfor(int i=0;i<B.size();i++) if(B[i]=='1') up=false;\n\tfor(int i=0;i<C.size();i++) if(C[i]=='1') up=false;\n\tfor(int i=0;i<D.size();i++) if(D[i]=='1') up=false;\n\tif(up)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t//printf(\"%lld %lld\\n\",solve(A,B,C,D),solve(C,D,A,B));\n\tll ret=solve(A,B,C,D)+solve(C,D,A,B);\n\tif(ret>=MOD) ret-=MOD;\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.09.2017 15:44:27       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int N = 800010;\n\nchar sa[N], sb[N], sc[N], sd[N];\nint fact[N], inv_fact[N];\nint ways_up[N], ways_down[N];\n\ninline int C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));\n}\n\nint main() {\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = mul(fact[i - 1], i);\n    inv_fact[i] = inv(fact[i]);\n  }\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%s\", sa);\n  scanf(\"%s\", sb);\n  scanf(\"%s\", sc);\n  scanf(\"%s\", sd);\n  vector<int> a(n), b(n), c(m), d(m);\n  for (int i = 0; i < n; i++) {\n    a[i] = sa[i] - '0';\n    b[i] = sb[i] - '0';\n  }\n  for (int i = 0; i < m; i++) {\n    c[i] = sc[i] - '0';\n    d[i] = sd[i] - '0';\n  }\n  int ans = 0;\n  for (int rot = 0; rot < 2; rot++) {\n    int sum_c = 0, sum_d = 0;\n    for (int p = 0; p < m; p++) {\n      sum_c += c[p];\n      sum_d += d[p];\n    }\n    int sum_up = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] + b[i] == 0) {\n        ways_up[i] = 0;\n      } else {\n        if (sum_c == 0 && sum_up > 0) {\n          ways_up[i] = 0;\n        } else {\n          ways_up[i] = (sum_c == 0 ? 1 : C(sum_c + sum_up - 1, sum_c - 1));\n        }\n        sum_up += a[i] + b[i];\n      }\n    }\n    int sum_down = 0;\n    for (int j = n - 1; j >= 0; j--) {\n      if (a[j] + b[j] == 0) {\n        ways_down[j] = 0;\n      } else {\n        if (sum_d == 0 && sum_down > 0) {\n          ways_down[j] = 0;\n        } else {\n          ways_down[j] = (sum_d == 0 ? 1 : C(sum_d + sum_down - 1, sum_d - 1));\n        }\n        sum_down += a[j] + b[j];\n      }\n    }\n    int sum_i = 0;\n    for (int j = 0; j < n; j++) {\n      add(sum_i, ways_up[j]);\n      sum_i = mul(sum_i, max(1, a[j] + b[j]));\n      add(ans, mul(sum_i, ways_down[j]));\n    }\n    swap(n, m);\n    swap(a, c);\n    swap(b, d);\n  }\n  int cnt_1 = 0;\n  for (int i = 0; i < n; i++) {\n    cnt_1 += a[i] + b[i];\n  }\n  for (int i = 0; i < m; i++) {\n    cnt_1 += c[i] + d[i];\n  }\n  if (cnt_1 == 0) {\n    ans = 1;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nchar A[110000];\nchar B[110000];\nchar C[110000];\nchar D[110000];\nlong long U[110000];\nlong long S[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s%s%s%s\",A,B,C,D);\n\tlong long ret=0;\n\tinit_C(310000);\n\tfor(int w=0;w<2;w++){\n\t\tint l=0;\n\t\tint r=0;\n\t\tint uc=0;\n\t\tint dc=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tuc+=C[i]-'0';\n\t\t\tdc+=D[i]-'0';\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tU[i]=Comb(l+r+uc-1,l+r);\n\t\t\tif(uc==0&&l+r==0)U[i]=1;\n\t\t\tif(A[i]=='1')l++;\n\t\t\tif(B[i]=='1')r++;\n\t\t}\n\t\tl=0;\n\t\tr=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tS[i]=Comb(l+r+dc-1,l+r);\n\t\t\tif(dc==0&&l+r==0)S[i]=1;\n\t\t\tif(A[a-1-i]=='1')l++;\n\t\t\tif(B[a-1-i]=='1')r++;\n\t\t}\n\t\t// for(int i=0;i<a;i++)printf(\"%d: %lld %lld\\n\",i,U[i],S[i]);\n\t\tlong long ks=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(A[i]=='1'||B[i]=='1')ks=(ks+U[i])%mod;\n\t\t\tif(A[i]=='1'&&B[i]=='1')ks=ks*2%mod;\n\t\t\tif(A[i]=='1'||B[i]=='1')ret=(ret+ks*S[a-i-1])%mod;\n\t\t\t// printf(\"%d: %lld %lld\\n\",i,ks,S[a-i-1]);\n\t\t}\n\t\tswap(a,b);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\n//const ll mod=1e9+7;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=200005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\tif(n<0) return 1;\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nstring A,B,C,D;\n\nvl ff(){\n\tvl a(m+1);\n\ta[0]++;\n\tif(A!=string(n,'0')){\n\t\tint S=0,t=0;\n\t\tfor(int i=0;i<n;i++) S+=A[i]-'0';\n\t\tfor(int i=0;i<m;i++){\n\t\t\tt+=C[i]-'0'+D[i]-'0';\n\t\t\ta[i+1]=nCk(S+t-1,t);\n\t\t}\n\t}\n\tswap(A,B);\n\treverse(C.begin(),C.end());\n\treverse(D.begin(),D.end());\n\treturn a;\n}\n\nll f(){\n\tll res=0,t=0;\n\tvl a=ff(),b=ff();\n\tfor(int i=0;i<m;i++) if(C[i]=='1'||D[i]=='1'){\n\t\tt=(C[i]-'0'+D[i]-'0')*(a[i]+t)%mod;\n\t\t(res+=t*b[m-1-i])%=mod;\n\t}\n\tswap(A,C);swap(B,D);swap(n,m);\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>m>>A>>B>>C>>D;\n\tInit();\n\tcout<<(f()+f())%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst long long md=998244353;\nconst int maxn=600000;\nchar str1[maxn+100],str2[maxn+100];\nchar str3[maxn+100],str4[maxn+100];\nlong long fac[maxn+100],inv[maxn+100];\nlong long f[maxn+100],g[maxn+100];\nlong long C(int n,int m){\n\tif(n<=0||m==0) return 1;\n\tif(m<0||m>n) return 0;\n\treturn fac[n]*inv[m]%md*inv[n-m];\n}\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str1+1),scanf(\"%s\",str2+1);\n\tscanf(\"%s\",str3+1),scanf(\"%s\",str4+1);\n\tbool bo1=1,bo2=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(str1[i]=='1'||str2[i]=='1'){\n\t\t\tbo1=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(str3[i]=='1'||str4[i]=='1'){\n\t\t\tbo2=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(bo1||bo2){\n\t\tlong long ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(str1[i]=='1'&&str2[i]=='1')\n\t\t\t\tans=ans*2%md;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(str3[i]=='1'&&str4[i]=='1')\n\t\t\t\tans=ans*2%md;\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=maxn;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[maxn]=powd(fac[maxn],md-2);\n\tfor(int i=maxn;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str3[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str4[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=n;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tlong long ans=0,sum=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str1[i]-'0')&&(str2[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tsum=0;\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str1[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str2[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=m;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str3[i]-'0')&&(str4[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 300005;\nconst int mod = 998244353;\n\nint n, m, cna, cnb, cnc, cnd, fac[MAXN], inv[MAXN];\nbool a[MAXN], b[MAXN], c[MAXN], d[MAXN];\nchar s[MAXN];\n\ninline int C(int x, int y)\n{\n\treturn 1LL * fac[x] * inv[y] % mod * inv[x - y] % mod;\n}\n\ninline int Solve(int n, int m, bool *a, bool *b, bool *c, bool *d, int cna, int cnb, int cnc, int cnd)\n{\n\tint leu = 0, led = 0, riu = cna, rid = cnb, cur = 0, ret = 0;\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (a[i] || b[i])\n\t\t{\n\t\t\t(cur += (cnc ? C(leu + led + cnc - 1, cnc - 1) : (leu + led == 0))) %= mod;\n\t\t\tif (a[i] && b[i])\n\t\t\t\tcur = (cur << 1) % mod;\n\t\t\tif (a[i])\n\t\t\t\tleu ++, riu --;\n\t\t\tif (b[i])\n\t\t\t\tled ++, rid --;\n\t\t\tret = (1LL * cur * (cnd ? C(riu + rid + cnd - 1, cnd - 1) : (riu + rid == 0)) + ret) % mod;\n\t\t}\n\treturn ret;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read(), fac[0] = fac[1] = inv[0] = inv[1] = 1;\n\tfor (int i = 2; i < MAXN; i ++)\n\t\tfac[i] = 1LL * fac[i - 1] * i % mod, inv[i] = 1LL * (mod - mod / i) * inv[mod % i] % mod;\n\tfor (int i = 2; i < MAXN; i ++)\n\t\tinv[i] = 1LL * inv[i - 1] * inv[i] % mod;\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\ta[i] = s[i] == '1', cna += a[i];\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\tb[i] = s[i] == '1', cnb += b[i];\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= m; i ++)\n\t\tc[i] = s[i] == '1', cnc += c[i];\n\tscanf(\"%s\", s + 1);\n\tfor (int i = 1; i <= m; i ++)\n\t\td[i] = s[i] == '1', cnd += d[i];\n\tif (!cna && !cnb && !cnc && !cnd)\n\t\treturn puts(\"1\"), 0;\n\treturn printf(\"%d\\n\", (Solve(n, m, a, b, c, d, cna, cnb, cnc, cnd) + Solve(m, n, c, d, a, b, cnc, cnd, cna, cnb)) % mod), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>\n\n#pragma warning(disable:4996)  \n#pragma comment(linker, \"/STACK:336777216\")  \nusing namespace std;\n\n#define mp make_pair  \n#define Fi first  \n#define Se second  \n#define pb(x) push_back(x)  \n#define szz(x) ((int)(x).size()) \n#define all(x) (x).begin(), (x).end()  \n#define ldb ldouble  \n\ntypedef tuple<int, int, int> t3;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <db, db> pdd;\n\nint IT_MAX = 1 << 17;\nconst ll MOD = 998244353;\nconst int INF = 0x3f3f3f3f;\nconst ll LL_INF = 0x3f3f3f3f3f3f3f3f;\nconst db PI = acos(-1);\nconst db ERR = 1e-10;\n\nll mul_inv(ll a, ll b = MOD) {\n\tll t1 = a, t2 = b, t3;\n\tll v1 = 1, v2 = 0, v3;\n\twhile (t2 != 1) {\n\t\tll x = t1 / t2;\n\t\tt3 = t1 - x*t2;\n\t\tv3 = v1 - x*v2;\n\t\tt1 = t2, t2 = t3;\n\t\tv1 = v2, v2 = v3;\n\t}\n\treturn (v2 + b) % b;\n}\nll F[300050];\nll Finv[300050];\nll Co(ll a, ll b) {\n\tif (a == -1) return 1;\n\tif (b < 0 || b > a) return 0;\n\tll rv = F[a] * Finv[b] % MOD;\n\treturn rv * Finv[a - b] % MOD;\n}\n\nchar SA[100050];\nchar SB[100050];\nchar SC[100050];\nchar SD[100050];\n\nll va[100050];\nll vb[100050];\nll getans(char* SA, char* SB, char* SC, char* SD, int N, int M) {\n\tint c1 = 0, c2 = 0, i, j;\n\tfor (i = 1; i <= M; i++) if (SC[i] == '1') c1++;\n\tfor (i = 1; i <= M; i++) if (SD[i] == '1') c2++;\n\n\tvb[N + 1] = Co(c2 - 1, 0);\n\tint s = 0;\n\tfor (i = N; i >= 1; i--) {\n\t\tif (SA[i] == '1') s++;\n\t\tif (SB[i] == '1') s++;\n\t\tvb[i] = Co(c2 + s - 1, s);\n\t}\n\tva[0] = Co(c1 - 1, 0);\n\ts = 0;\n\tll x = 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (SA[i] == '1') s++;\n\t\tif (SB[i] == '1') s++;\n\t\tif (SA[i] == '1' && SB[i] == '1') x = x * mul_inv(2) % MOD;\n\t\tva[i] = Co(c1 + s - 1, s) * x % MOD;\n\t}\n\n\tll rv = 0;\n\tll tu = va[0];\n\tx = 1;\n\tfor (i = 1; i <= N; i++) {\n\t\tif (SA[i] == '0' && SB[i] == '0') continue;\n\t\tif (SA[i] == '1' && SB[i] == '1') x = x * 2 % MOD;\n\t\trv = (rv + tu * x % MOD * vb[i + 1]) % MOD;\n\t\ttu = (tu + va[i]) % MOD;\n\t}\n\treturn rv;\n}\nint main() {\n\tint N, M, i, j;\n\tF[0] = 1;\n\tfor (i = 1; i <= 300000; i++) F[i] = F[i - 1] * i % MOD;\n\tfor (i = 0; i <= 300000; i++) Finv[i] = mul_inv(F[i]);\n\n\tscanf(\"%d %d\", &N, &M);\n\tscanf(\"%s %s %s %s\", SA+1, SB+1, SC+1, SD+1);\n\t\n\tfor (i = 1; i <= N; i++) if (SA[i] == '1' || SB[i] == '1') break;\n\tfor (j = 1; j <= M; j++) if (SC[j] == '1' || SD[j] == '1') break;\n\tif (i > N && j > M) return !printf(\"1\\n\");\n\n\tll ans = getans(SA, SB, SC, SD, N, M) + getans(SC, SD, SA, SB, M, N);\n\treturn !printf(\"%lld\\n\", ans % MOD);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define maxn 401000\nusing namespace std;\nint fac[maxn],inv[maxn],n,m,pw[maxn],pw2[maxn],f[maxn],g[maxn],s[maxn],t[maxn];\nchar A[maxn],B[maxn],C[maxn],D[maxn];\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint gC(int x,int y){\n\tif(x>y||x<0)return 0;\n\treturn 1ll*fac[y]*inv[x]%mod*inv[y-x]%mod;\n}\nint sol(int n,int m,char A[],char B[],char C[],char D[]){\n\tfor(int i=1;i<=m;++i)s[i]=(C[i]=='1'&&D[i]=='1')+s[i-1];\n\tfor(int i=1;i<=m;++i)t[i]=(C[i]=='1')+t[i-1]+(D[i]=='1');\n\tint x=0,y=0,ans=0;\n\tfor(int i=1;i<=n;++i)x+=(A[i]=='1'),y+=(B[i]=='1');\n\tmemset(f,0,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(int i=0;i<=m;++i){\n\t\tf[i]=gC(x,t[i]+x);\n\t\tif(t[i])f[i]-=gC(x,t[i]+x-1);\n\t\tf[i]=1ll*f[i]*pw[s[i]]%mod;\n\t\tif(C[i+1]=='0'&&D[i+1]=='0')f[i]=0;\n\t}\n\tfor(int i=1;i<=m+1;++i){\n\t\tg[i]=gC(y,t[m]-t[i-1]+y);\n\t\tif(g[i])g[i]-=gC(y,t[m]-t[i-1]+y-1);\n\t\tg[i]=1ll*g[i]*pw2[s[i-1]]%mod;\n\t\tif(C[i-1]=='0'&&D[i-1]=='0')g[i]=0;\n\t}\n\tfor(int i=1;i<=m;++i)f[i]=(f[i-1]+f[i])%mod;\n\tfor(int i=1;i<=m;++i)ans=(ans+1ll*f[i-1]*g[i+1])%mod;\n\treturn (ans%mod+mod)%mod;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=2*(n+m);++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2*(n+m)]=qpow(fac[2*(n+m)],mod-2);\n\tfor(int i=2*(n+m)-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tpw[0]=pw2[0]=1;\n\tfor(int i=1;i<=max(n,m);++i)pw[i]=1ll*pw[i-1]*(mod+1)/2%mod,pw2[i]=1ll*pw2[i-1]*2%mod;\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tfor(int i=1;i<=max(n,m);++i)if(A[i]=='1'||B[i]=='1'||C[i]=='1'||D[i]=='1')goto nxt;\n\tputs(\"1\");\n\treturn 0;\n\tnxt:;\n\tprintf(\"%d\",(sol(n,m,A,B,C,D)+sol(m,n,C,D,A,B))%mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long fact[300009], factinv[300009], mod = 998244353;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 300000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 300000; i++) factinv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * factinv[r] % mod) * factinv[n - r] % mod;\n}\n\nlong long N, M, cnt, p1, p2, L1[100009], L2[100009]; string A, B, C, D;\n\nvoid dels() {\n\tcnt = 0; p1 = 0; p2 = 0;\n\tfor (int i = 0; i < 100009; i++) { L1[i] = 0; L2[i] = 0; }\n}\n\nlong long solve() {\n\tdels();\n\tfor (int i = 0; i < N; i++) { if (A[i] == '1' || B[i] == '1') cnt++; }\n\tfor (int i = 0; i < M; i++) { if (C[i] == '1') p1++; if (D[i] == '1') p2++; }\n\n\tint v = 0; L1[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL1[i + 1] = ncr(v + p1 - 1, p1 - 1);\n\t\tbool flag = false; if (v == 0) flag = true;\n\t\tif (flag == true && p1 == 0) L1[i + 1] = 1;\n\t}\n\tv = 0; L2[N - 1] = 1;\n\tfor (int i = N - 1; i >= 1; i--) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL2[i - 1] = ncr(v + p2 - 1, p2 - 1);\n\t\tbool flag = false; if (v == 0) flag = true;\n\t\tif (flag == true && p2 == 0) L2[i - 1] = 1;\n\t}\n\tlong long ret = 0, ans = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (A[i] == '1' || B[i] == '1') ret += L2[i];\n\t\tret %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ans += L1[i] * ret;\n\t\tif (A[i] == '1' || B[i] == '1') ans += L1[i] * ret;\n\t\tans %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ret *= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tinit();\n\tcin >> N >> M >> A >> B >> C >> D;\n\n\tlong long c1 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tlong long c2 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tcout << (c1 + c2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 998244353\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\ninline int mul(int x , int y) { return (1LL*x*y)%MOD; }\nint modpow(int x, int k) {\n  int a = 1;\n  while(k) {\n    if (k&1)a=mul(a,x);\n    x=mul(x,x);\n    k>>=1;\n  }\n  return a;\n}\nint inv(int x) {\n  return modpow(x,MOD-2);\n}\nint fact[400001];\nint nCr(int n, int r) {\n  if (r < 0 || r > n) return 0;\n  return mul(mul(fact[n], inv(fact[r])),inv(fact[n-r]));\n}\n\nint f(int h, int u, int d) {\n  if (u == 0 && d == 0) return 1;\n  if (h == 0) return 0;\n  return nCr(u+d+h-1, h-1);\n}\n\nint L[100000];\nint R[100000];\nint solve(int H, int W, string left, string right, string top, string bottom) {\n  rep(i, W) L[i] = R[i] = 0;\n\n  int h = 0, u = 0, d = 0;\n  for (char c : right) h += c == '1';\n  for (int r=W-1; r>=0; r--) if (top[r]=='1'||bottom[r]=='1') {\n    R[r] = f(h, u, d);\n    u += top[r]=='1';\n    d += bottom[r]=='1';\n  }\n\n  h = 0, u = 0, d = 0;\n  for (char c : left) h += c == '1';\n  for (int l=0; l<W; l++) if (top[l]=='1' || bottom[l]=='1') {\n    L[l] = f(h, u, d);\n    u += top[l]=='1';\n    d += bottom[l]=='1';\n  }\n\n  int s = 0, e = 0;\n  for (int l=W-1; l>=0; l--) {\n    add(e, R[l]);\n    if (top[l]=='1'&&bottom[l]=='1') e = mul(2, e);\n    add(s, mul(e, L[l]));\n  }\n  return s;\n}\n\nint N, M;\nstring A, B, C, D;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=400000; i++) fact[i]=mul(fact[i-1],i);\n\n  cin >> N >> M >> A >> B >> C >> D;\n  int one = 0;\n  for (char c : A) one += c == '1';\n  for (char c : B) one += c == '1';\n  for (char c : C) one += c == '1';\n  for (char c : D) one += c == '1';\n  if (one == 0) {\n    cout << 1 << \"\\n\";\n    return 0;\n  }\n\n  int s = 0;\n  add(s, solve(N, M, A, B, C, D));\n  add(s, solve(M, N, C, D, B, A));\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\n#include<unordered_set>\n#include<complex>\nusing namespace std;\nconst long long mod=998244353;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nnamespace{\n\tlong long fact[C_SIZE];\n\tlong long finv[C_SIZE];\n\tlong long inv[C_SIZE];\n\tlong long Comb(int a,int b){\n\t \tif(a<b||b<0)return 0;\n\t \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n\t}\n\tvoid init_C(int n){\n\t\tfact[0]=finv[0]=inv[1]=1;\n\t\tfor(int i=2;i<n;i++){\n\t\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t\t}\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfact[i]=fact[i-1]*i%mod;\n\t\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t\t}\n\t}\n\tlong long pw(long long a,long long b){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%mod;\n\t\t\ta=a*a%mod;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tlong long pw_mod(long long a,long long b,long long M){\n\t\tif(a<0LL)return 0;\n\t\tif(b<0LL)return 0;\n\t\tlong long ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=ret*a%M;\n\t\t\ta=a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint pw_mod_int(int a,int b,int M){\n\t\tif(a<0)return 0;\n\t\tif(b<0)return 0;\n\t\tint ret=1;\n\t\twhile(b){\n\t\t\tif(b%2)ret=(long long)ret*a%M;\n\t\t\ta=(long long)a*a%M;\n\t\t\tb/=2;\n\t\t}\n\t\treturn ret;\n\t}\n\tint ABS(int a){return max(a,-a);}\n\tlong long ABS(long long a){return max(a,-a);}\n\tdouble ABS(double a){return max(a,-a);}\n\tint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n}\n// ここから編集しろ\nchar A[110000];\nchar B[110000];\nchar C[110000];\nchar D[110000];\nlong long U[110000];\nlong long S[110000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tscanf(\"%s%s%s%s\",A,B,C,D);\n\tlong long ret=0;\n\tinit_C(410000);\n\tfor(int w=0;w<2;w++){\n\t\tint l=0;\n\t\tint r=0;\n\t\tint uc=0;\n\t\tint dc=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tuc+=C[i]-'0';\n\t\t\tdc+=D[i]-'0';\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tU[i]=Comb(l+r+uc-1,l+r);\n\t\t\tif(l+r==0)U[i]=1;\n\t\t\tif(A[i]=='1')l++;\n\t\t\tif(B[i]=='1')r++;\n\t\t}\n\t\tl=0;\n\t\tr=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tS[i]=Comb(l+r+dc-1,l+r);\n\t\t\tif(l+r==0)S[i]=1;\n\t\t\tif(A[a-1-i]=='1')l++;\n\t\t\tif(B[a-1-i]=='1')r++;\n\t\t}\n\t\t// for(int i=0;i<a;i++)printf(\"%d: %lld %lld\\n\",i,U[i],S[i]);\n\t\tlong long ks=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(A[i]=='1'||B[i]=='1')ks=(ks+U[i])%mod;\n\t\t\tif(A[i]=='1'&&B[i]=='1')ks=ks*2%mod;\n\t\t\tif(A[i]=='1'||B[i]=='1')ret=(ret+ks*S[a-i-1])%mod;\n\t\t\t// printf(\"%d: %lld %lld\\n\",i,ks,S[a-i-1]);\n\t\t}\n\t\tswap(a,b);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 400009\n#define ll long long\n#define mod 998244353\n#define cbn(x,y) ((ll)fac[x]*inv[y]%mod*inv[(x)-(y)]%mod)\nusing namespace std;\n\nint m,n,a[N],b[N],fac[N],inv[N]; char A[N],B[N],C[N],D[N];\nint solve(int m,int n,char *A,char *B,char *C,char *D){\n\tint i,x,y;\n\tmemset(a,0,sizeof(a)); memset(b,0,sizeof(b));\n\ta[0]=b[n+1]=1;\n\tfor (i=1,y=0; i<=m; i++) if (A[i]=='1') y++;\n\tfor (i=1,x=0; i<=n; i++){\n\t\tif (C[i]=='1') x++;\n\t\tif (D[i]=='1') x++;\n\t\ta[i]=cbn(x+y,x);\n\t\tif (x) a[i]=(a[i]-cbn(x+y-1,x-1)+mod)%mod;\n\t\t//cout<<i<<' '<<a[i]<<endl;\n\t}\n\tfor (i=1,y=0; i<=m; i++) if (B[i]=='1') y++;\n\tfor (i=n,x=0; i; i--){\n\t\tif (C[i]=='1') x++;\n\t\tif (D[i]=='1') x++;\n\t\tb[i]=cbn(x+y,x);\n\t\tif (x>0) b[i]=(b[i]-cbn(x+y-1,x-1)+mod)%mod;\n\t\t//cout<<i<<' '<<b[i]<<endl;\n\t}\n\tint tmp;\n\tfor (i=0,tmp=1; i<=n; i++){\n\t\tif (i>0 && C[i]=='1' && D[i]=='1') tmp=(ll)tmp*(mod+1>>1)%mod;\n\t\ta[i]=(ll)a[i]*tmp%mod;\n\t\tif (i<=n && C[i+1]=='0' && D[i+1]=='0') a[i]=0;\n\t}\n\tfor (i=1; i<=n; i++) a[i]=(a[i]+a[i-1])%mod;\n\tfor (i=tmp=1; i<=n+1; i++){\n\t\tb[i]=(ll)b[i]*tmp%mod;\n\t\tif (i<=n && C[i]=='1' && D[i]=='1') tmp=tmp*2%mod;\n\t\tif (i>1 && C[i-1]=='0' && D[i-1]=='0') b[i]=0;\n\t}\n\tint ans=0;\n\tfor (i=1; i<=n; i++) ans=(ans+(ll)b[i+1]*a[i-1])%mod;\n\t//cout<<ans<<endl;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&m,&n);\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tint i;\n\tfor (i=1; i<=m; i++) if (A[i]=='1' || B[i]=='1') break;\n\tif (i>m){\n\t\tfor (i=1; i<=n; i++) if (C[i]=='1' || D[i]=='1') break;\n\t\tif (i>m){ puts(\"1\"); return 0; }\n\t}\n\tfac[0]=inv[0]=inv[1]=1;\n\tfor (i=1; i<=(m+n<<1); i++) fac[i]=(ll)fac[i-1]*i%mod;\n\tfor (i=2; i<=(m+n<<1); i++) inv[i]=mod-(ll)inv[mod%i]*(mod/i)%mod;\n\tfor (i=2; i<=(m+n<<1); i++) inv[i]=(ll)inv[i-1]*inv[i]%mod;\n\tprintf(\"%d\\n\",(solve(m,n,A,B,C,D)+solve(n,m,C,D,A,B))%mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define MAXN 100000\n#define MOD 998244353\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint fac[3*MAXN+5], efac[3*MAXN+5], N, M, T, ans; char l[MAXN+5], r[MAXN+5], u[MAXN+5], d[MAXN+5];\nint L[MAXN+5], R[MAXN+5], U[MAXN+5], D[MAXN+5], LR[MAXN+5], UD[MAXN+5], b[MAXN+5], col[MAXN+5], row[MAXN+5];\ninline int e(int s, int n=MOD-2){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\ninline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\ninline int F(int U, int D, int R){return R ? C(U+D+R-1,R-1) : !U&&!D;}\nint main()\n{\n\tN = read(), M = read(), scanf(\"%s%s%s%s\",l+1,r+1,u+1,d+1);\n\tfor(rint i = 1; i <= N; L[i] = L[i-1]+l[i]-'0', i++); for(rint i = 1; i <= N; R[i] = R[i-1]+r[i]-'0', LR[i] = LR[i-1]+(r[i]>'0'&&l[i]>'0'), i++);\n\tfor(rint j = 1; j <= M; U[j] = U[j-1]+u[j]-'0', j++); for(rint j = 1; j <= M; D[j] = D[j-1]+d[j]-'0', UD[j] = UD[j-1]+(d[j]>'0'&&u[j]>'0'), j++);\n\tif(!L[N]&&!R[N]&&!U[M]&&!D[M]) return puts(\"1\"),0; T = max(LR[N],UD[M]); b[0] = 1; for(rint i = 1; i <= T; b[i] = b[i-1]<<1, b[i]<MOD?:b[i]-=MOD, i++);\n\tT = max(L[N]+R[N]+max(U[M],D[M]),U[M]+D[M]+max(L[N],R[N])); fac[0] = 1; for(rint i = 1; i <= T; fac[i] = 1ll*i*fac[i-1]%MOD, i++);\n\tefac[T] = e(fac[T],MOD-2); for(rint i = T; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--);\n\tfor(rint i = N; i; row[i] = (row[i+1]+(L[i]>L[i-1]||R[i]>R[i-1]?1ll*b[LR[i]]*F(L[N]-L[i],R[N]-R[i],D[M]):0))%MOD, i--);\n\tfor(rint j = M; j; col[j] = (col[j+1]+(U[j]>U[j-1]||D[j]>D[j-1]?1ll*b[UD[j]]*F(U[M]-U[j],D[M]-D[j],R[N]):0))%MOD, j--);\n\tfor(rint i = N; i; ans = (ans+(L[i]>L[i-1]||R[i]>R[i-1]?1ll*F(L[i-1],R[i-1],U[M])*e(b[LR[i-1]])%MOD*row[i]:0))%MOD, i--);\n\tfor(rint j = M; j; ans = (ans+(U[j]>U[j-1]||D[j]>D[j-1]?1ll*F(U[j-1],D[j-1],L[N])*e(b[UD[j-1]])%MOD*col[j]:0))%MOD, j--); printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool wflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') wflag = true;\n\t}\n\tbool hflag = false;\n\tfor(int i = 1; i <= h; i++){\n\t\tif(l[i] == '1' || r[i] == '1') hflag = true;\n\t}\n\tif(!wflag && !hflag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = 0;\n\tif(wflag) ans += calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tif(hflag) ans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=998244353;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int N=101000;\nchar s[N];\nll fac[N*5],fnv[N*5],fl[N],fr[N];\nVI u,d,l,r;\nint n,m,val[N],az=1;\nVI readv(int n) {\n\tscanf(\"%s\",s);\n\tVI x;\n\trep(i,0,n) {\n\t\tx.pb(s[i]-'0');\n\t\tif (s[i]!='0') az=0;\n\t}\n\treturn x;\n}\nll comb(int x,int y) {\n\tassert(y>=0&&x>=y);\n\treturn fac[x]*fnv[x-y]%mod*fnv[y]%mod;\n}\nll gao(VI u,VI d,VI l,VI r) {\n\tbool emp=1;\n\tn=SZ(u); m=SZ(l);\n\trep(i,0,n) {\n\t\tif (u[i]!=0||d[i]!=0) emp=0;\n\t}\n\tif (emp) return 0;\n\tint sl=0,sr=0;\n\trep(i,0,m) {\n\t\tif (l[i]) sl++;\n\t\tif (r[i]) sr++;\n\t}\n\trep(pl,0,n) val[pl]=u[pl]+d[pl];\n\tll ret=0;\n\tint lu=0,ld=0;\n\trep(k,0,n) {\n\t\tif (sl==0) { if (lu+ld!=0) fl[k]=0; else fl[k]=1; }\n\t\telse fl[k]=comb(lu+ld+sl-1,sl-1);\n\t\tlu+=u[k], ld+=d[k];\n\t}\n\tint ru=0,rd=0;\n\tper(k,0,n) {\n\t\tif (sr==0) { if (ru+rd!=0) fr[k]=0; else fr[k]=1; }\n\t\telse fr[k]=comb(ru+rd+sr-1,sr-1);\n\t\tru+=u[k], rd+=d[k];\n\t}\n\tll tmpl=0;\n\trep(pl,0,n) if (val[pl]>=1) {\n\t\ttmpl=(tmpl+fl[pl])%mod;\n\t\tif (val[pl]==2) tmpl=tmpl*2%mod;\n\t\tret=(ret+tmpl*fr[pl])%mod;\n\t}\n/*\trep(pl,0,n) rep(pr,pl,n) if (val[pl]>=1&&val[pr]>=1) {\n\t\tll pw=0;\n\t\trep(k,pl,pr+1) pw+=max(val[k]-1,0);\n\t\tpw=powmod(2,pw);\n\t\tprintf(\"%d %d %lld\\n\",pl,pr,pw*fl[pl]*fr[pr]);\n\t\tret=(ret+pw*fl[pl]%mod*fr[pr])%mod;\n\t}*/\n\treturn ret;\n}\nint main() {\n\tfac[0]=fnv[0]=1;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,1,500001) {\n\t\tfac[i]=fac[i-1]*i%mod;\n\t\tfnv[i]=powmod(fac[i],mod-2);\n\t}\n\tu=readv(n);\n\td=readv(n);\n\tl=readv(m);\n\tr=readv(m);\n\tif (az) { puts(\"1\"); return 0;}\n\tprintf(\"%lld\\n\",(gao(u,d,l,r)+gao(l,r,u,d))%mod);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\n#define mo 998244353\n#define ll long long\nll inv[MAXN<<2],fac[MAXN<<2],n,m,ans;\nchar U[MAXN],D[MAXN],L[MAXN],R[MAXN];\ninline ll Cn(ll k,ll b){return (ll)fac[k]*inv[b]%mo*inv[k-b]%mo;}\ninline void solve(int n,int m,char *L,char *R,char *U,char *D)\n{\n\tll tmp=0;\n\tll cl,cr,cu,cd,nowu,nowd,u,d;\n\tcl=cr=cu=cd=nowu=nowd=u=d=0;\n\tfor(int i=1;i<=n;i++) cl+=L[i]-'0',cr+=R[i]-'0';\n\tfor(int i=1;i<=m;i++) cd+=D[i]-'0',cu+=U[i]-'0';\n\tif(cl+cd+cr+cu==0){cout<<\"1\";exit(0);}\n\ttmp=1;\n\tfor(int i=1;i<=m;i++){\n\t\tnowu+=(u=U[i]-'0');nowd+=(d=D[i]-'0');\n\t\tif(u||d){\n\t\t\tif(u&&d) tmp=tmp*2%mo;\n\t\t\tif(cr!=0) ans=(ans+tmp*Cn(cr+cu+cd-nowu-nowd-1,cr-1))%mo;\n\t\t\telse ans=(ans+tmp*(cu+cd-nowu-nowd==0))%mo;\n\t\t\tif(cl!=0) tmp=(tmp+Cn(cl+nowu+nowd-1,cl-1))%mo;\n\t\t\telse tmp=(tmp+(nowu+nowd==0))%mo;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfac[0]=1;inv[1]=inv[0]=1;\n\tfor(int i=1;i<=4*MAXN-10;i++) fac[i]=fac[i-1]*i%mo;\n\tfor(int i=2;i<=4*MAXN-10;i++) inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=4*MAXN-10;i++) inv[i]=(ll)inv[i]*inv[i-1]%mo;\n\tscanf(\"%s%s%s%s\",L+1,R+1,U+1,D+1);\n\tsolve(n,m,L,R,U,D);solve(m,n,U,D,L,R);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\ninline void hash(){}\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);ans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);pre=(pre+val)%p;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tbool died=true;\n\tfor(int i=1;i<=n;++i)\n\t\tif(A[i]=='1' or B[i]=='1' or C[i]=='1' or D[i]=='1')\n\t\t\t{died=false;break;}\n\tif(died){puts(\"1\");return 0;}\n\twork();swap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);work();\n\tprintf(\"%d\\n\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if defined(LOCAL)\n#define PROBLEM_NAME \"e\"\nconst double _max_double_error = 1e-9;\n#include \"testutils.h\"\n#define L(x...) (debug(x, #x))\n#else\n#define L(x, ...) (x)\n#include <bits/stdc++.h>\n#endif\n\nusing namespace std;\nusing vi = vector<int>; using vvi = vector<vi>;\nusing ii = pair<int,int>; using vii = vector<ii>;\nusing l = long long; using vl = vector<l>; using vvl = vector<vl>;\nusing ll = pair<l,l>; using vll = vector<ll>; using vvll = vector<vll>;\nusing lu = unsigned long long;\nusing vb = vector<bool>; using vvb = vector<vb>;\nusing vd = vector<double>; using vvd = vector<vd>;\nusing mll = unordered_map<l, l>;\nconst l INF = numeric_limits<l>::max();\nconst double EPS = 1e-10; static constexpr auto PI = acos(-1);\nconst l e0=1, e3=1000, e5=100000, e6=10*e5, e7=10*e6, e8=10*e7, e9=10*e8;\nconst char lf = '\\n';\n#define all(x) begin(x), end(x)\n#define F(a,b,c) for (l a = l(b); a < l(c); a++)\n#define B(a,b,c) for (l a = l(c) - 1; a >= l(b); a--)\n#define max(a,b)({__typeof__(a)__x=(a);__typeof__(b)__y=(b);__x>__y?__x:__y;})\n#define min(a,b)({__typeof__(a)__x=(a);__typeof__(b)__y=(b);__x<__y?__x:__y;})\n\nl sign(l n) {\n  if (n < 0) return -1;\n  if (n == 0) return 0;\n  return 1;\n}\n\n// conruent modulo, works for negative\nl cong(l x, l mod) {\n  return (x % mod + mod) % mod;\n}\n\n// (a * b) % mod, safe for l near max\nl mult_mod(l a, l b, l mod) {\n  l x = 0;\n  while (b) {\n    if (b % 2) x = (x + a) % mod;\n    a = (a * 2) % mod;\n    b /= 2;\n  }\n  return x;\n}\n\n// (base^power) % mod, safe for l near max\nl pow_mod(l base, l power, l mod) {\n  l r = 1;\n  while (power) {\n    if (power % 2) r = mult_mod(r, base, mod);\n    base = mult_mod(base, base, mod);\n    power /= 2;\n  }\n  return r;\n}\n\nl divup(l a, l b) { // ceil div\n  return (a + b - 1) / b;\n}\n\n// return gcd(a, b) and set x, y: a * x + b * y = gcd(a, b)\nl extended_euclid(l a, l b, l& x, l& y) {\n  if (b == 0) { x = 1; y = 0; return a; }\n  l d = extended_euclid(b, a % b, x, y);\n  l t = y;\n  y = x - (a / b) * y;\n  x = t;\n  return d;\n}\n\n// return b: a * b = 1 (mod n)\nl inverse_mod(l a, l n) {\n  l x, y;\n  l d = extended_euclid(a, n, x, y);\n  if (d != 1) return 0;\n  return cong(x, n);\n}\n\n// single combintions k from n\nl nCr(l n, l k, l mod) {\n  l a = 1;\n  for (l i = n; i > n - k; i--) a = mult_mod(a, i, mod);\n  l b = 1;\n  F(i, 1, k + 1) b = mult_mod(b, i, mod);\n  b = inverse_mod(b, mod);\n  return mult_mod(a, b, mod);\n}\n\n// precompute all combinations up to (n n)\nvvl combinations(l n, l mod) {\n  vvl c(n + 1, vl(n + 1));\n  F(i, 0, n) {\n    c[i][0] = 1;\n    F(j, 1, i + 1) {\n      c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;\n    }\n  }\n  return c;\n}\n\nconst l MAX = e5 + 10;\nconst l MOD = 998244353;\nvl fact, pow2;\n\nl c(l n, l k) {\n  // L(n, k, fact.size());\n  // assert(n < fact.size() and k < fact.size()); // TODO: local asserts with log\n  return cong(fact[n] * inverse_mod(cong(fact[k] * fact[n - k], MOD), MOD), MOD);\n}\n\nl f(l x, l y, l z) {\n  if (x == 0) {\n    if (y + z) return 0;\n    return 1;\n  }\n  return c(x + y + z - 1, x - 1);\n}\n\nl count(vl& a, vl& b, vl& c, vl& d) {\n  l n = a.size();\n  if (n == 0) return 0;\n  vl two(n + 1), acca(n + 1), accb(n + 1);\n  F(i, 0, n) {\n    two[i + 1] = two[i] + ((a[i] and b[i]) ? 1 : 0);\n    acca[i + 1] = acca[i] + a[i];\n    accb[i + 1] = accb[i] + b[i];\n  }\n  l tc = accumulate(all(c), 0);\n  l td = accumulate(all(d), 0);\n  l left = 0;\n  l z = 0;\n  l w = pow2[two[n]];\n  F(i, 0, n) {\n    left = cong(left + f(tc, acca[i], accb[i]) * inverse_mod(pow2[two[i]], MOD), MOD);\n    l right = cong(f(td, acca[n] - acca[i + 1], accb[n] - accb[i + 1]) *\n                   inverse_mod(pow2[two[n] - two[i + 1]], MOD), MOD);\n    z = cong(z + cong(w * left, MOD) * right, MOD);\n  }\n  // F(i, 0, n) F(j, i, n) {\n    // left = cong(f(tc, acca[i], accb[i]), MOD);\n    // l right = f(td, acca[n] - acca[j + 1], accb[n] - accb[j + 1]);\n    // z = cong(z + cong(pow2[two[j + 1] - two[i]] * left, MOD) * right, MOD);\n  // }\n  return z;\n}\n\nvoid solve(istream& cin, ostream& cout) {\n  l n, m; cin >> n >> m;\n  fact.resize(max(2 * n + m, 2 * m + n));\n  fact[0] = 1;\n  F(i, 1, fact.size()) fact[i] = (fact[i - 1] * i) % MOD;\n  pow2.resize(max(n, m) + 10);\n  pow2[0] = 1;\n  F(i, 1, pow2.size()) pow2[i] = (pow2[i - 1] * 2) % MOD;\n  vl a(n), b(n), c(m), d(m);\n  string s;\n  cin >> s; F(i, 0, n) a[i] = s[i] - '0';\n  cin >> s; F(i, 0, n) b[i] = s[i] - '0';\n  cin >> s; F(i, 0, m) c[i] = s[i] - '0';\n  cin >> s; F(i, 0, m) d[i] = s[i] - '0';\n  vl ca, cb, cc, cd;\n  F(i, 0, n) if (a[i] or b[i]) {\n    ca.emplace_back(a[i]);\n    cb.emplace_back(b[i]);\n  }\n  F(i, 0, m) if (c[i] or d[i]) {\n    cc.emplace_back(c[i]);\n    cd.emplace_back(d[i]);\n  }\n  if (ca.empty() and cc.empty()) {\n    cout << 1 << lf;\n    return;\n  }\n  cout << cong(count(cc, cd, ca, cb) + count(cb, ca, cc, cd), MOD) << lf;\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout << fixed << setprecision(15);\n#if defined(LOCAL)\n  // _generate_random_test = generate_random;\n  // _solve_brute = solve_brute;\n  // _player_b = player_b;\n  // _custom_solution_checker = solution_checker;\n  maybe_run_tests(cin, cout);\n#else\n  solve(cin, cout);\n#endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n#define MAX_INT 2147483647\n#define MOD 998244353\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\n\n// @author: pashka\n\nvector<long> fact;\nvector<long> inv_fact;\n\nlong mult(long a, long b) {\n    return (a * b) % MOD;\n}\n\nlong calc_c(int n, int k) {\n    return mult(mult(fact[n], inv_fact[k]), inv_fact[n - k]);\n}\n\nlong pow(long a, int pow) {\n    long res = 1;\n    while (pow > 0) {\n        if (pow & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        pow /= 2;\n    }\n    return res;\n}\n\nlong calc_g(int n, int k) {\n    if (n == 0) return 1;\n    if (k == n) return 0;\n    if (k == 0) return 1;\n    long res = calc_c(n, k);\n    res -= calc_c(n - 1, k - 1);\n    if (res < 0) res += MOD;\n    res %= MOD;\n    return res;\n}\n\nvoid calc(string &left, string &up, string &down, vector<long> &res) {\n    int n = left.size();\n    int m = up.size();\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        if (left[i] == '1') k++;\n    }\n    res[0] = 1;\n    int t = 0;\n    for (int i = 0; i < m; i++) {\n        if (up[i] == '1') t++;\n        if (down[i] == '1') t++;\n        res[i + 1] = calc_g(t + k, t);\n    }\n}\n\nlong calc(string a, string b, string c, string d) {\n    int n = a.size();\n    int m = c.size();\n    vector<long> left(m + 1);\n    vector<long> right(m + 1);\n    calc(a, c, d, left);\n    std::reverse(c.begin(), c.end());\n    std::reverse(d.begin(), d.end());\n    calc(b, c, d, right);\n    std::reverse(c.begin(), c.end());\n    std::reverse(d.begin(), d.end());\n\n    long ll = 0;\n    long res = 0;\n    for (int i = 0; i < m; i++) {\n        int t = 0;\n        if (c[i] == '1') t++;\n        if (d[i] == '1') t++;\n        if (t == 0) continue;\n        ll = t * (ll + left[i]);\n        ll %= MOD;\n        res += mult(ll, right[m - 1 - i]);\n        res %= MOD;\n//        std::cerr << i << \" \" << ll << \" \" << t << \" \" << left[i] << \" \" << right[m - 1 - i] << \" \" << res << \"\\n\";\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n\n    fact.resize(2 * (n + m) + 2);\n    inv_fact.resize(2 * (n + m) + 2);\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < fact.size(); i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv_fact[i] = pow(fact[i], MOD - 2);\n    }\n\n    string a, b, c, d;\n    cin >> a >> b >> c >> d;\n    \n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        if (a[i] == '1') k++;\n        if (b[i] == '1') k++;\n    }\n    for (int i = 0; i < m; i++) {\n        if (c[i] == '1') k++;\n        if (d[i] == '1') k++;\n    }\n    \n    if (k == 0) {\n        cout << \"1\\n\";\n        return 0;\n    }\n\n    long res = (calc(a, b, c, d) + calc(c, d, a, b)) % MOD;\n\n    cout << res;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\nusing namespace std;\ntypedef long long ll;\nll mod = 998244353;\n#define SIZE 500000\nll inv[SIZE + 1];\nll kai[SIZE + 1];\nll invkai[SIZE + 1];\nvoid invinit()\n{\n\tinv[1] = 1;\n\tfor (int i = 2; i <= SIZE; i++)\n\t{\n\t\tinv[i] = mod - (mod / i)*inv[mod%i] % mod;\n\t}\n\tkai[0] = invkai[0] = 1;\n\tfor (int i = 1; i <= SIZE; i++)\n\t{\n\t\tkai[i] = kai[i - 1] * i%mod;\n\t\tinvkai[i] = invkai[i - 1] * inv[i] % mod;\n\t}\n}\nll com(ll a, ll b)\n{\n\tif (b < 0 || a < b)return 0;\n\treturn (invkai[b] * invkai[a - b]) % mod*kai[a] % mod;\n}\nint count(string s)\n{\n\tint r = 0;\n\tfor (int i = 0; i < s.size(); i++)r += s[i] - '0';\n\treturn r;\n}\nll a1[200000], a2[200000];\nll solve(int mx, int my, string a, string b, string c, string d)\n{\n\tint s = count(a);\n\tint now = 0;\n\tbool f = true;\n\tfor (int i = 0; i < my; i++)\n\t{\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t{\n\t\t\ta1[i] = com(now + s - 1, s - 1);\n\t\t\tif (s == 0 && f)a1[i] = 1, f = false;\n\t\t}\n\t\telse a1[i] = 0;\n\t\tnow += c[i] - '0' + d[i] - '0';\n\t}\n\ts = count(b);\n\tnow = 0;\n\tf = true;\n\tfor (int i = my - 1; i >= 0; i--)\n\t{\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t{\n\t\t\ta2[i] = com(now + s - 1, s - 1);\n\t\t\tif (s == 0 && f)a2[i] = 1, f = false;\n\t\t}\n\t\telse a2[i] = 0;\n\t\tnow += c[i] - '0' + d[i] - '0';\n\t}\n\tll ret = 0;\n\tll sum = 0;\n\tfor (int i = 0; i < my; i++)\n\t{\n\t\tsum += a1[i];\n\t\tif (c[i] == '1'&&d[i] == '1')sum *= 2;\n\t\tsum %= mod;\n\t\tret += sum*a2[i];\n\t\tret %= mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tint mx, my;\n\tscanf(\"%d%d\", &mx, &my);\n\tstring a, b, c, d;\n\tcin >> a >> b >> c >> d;\n\tinvinit();\n\tif (count(a) + count(b) + count(c) + count(d) == 0)printf(\"1\\n\");\n\telse printf(\"%I64d\\n\", (solve(mx, my, a, b, c, d) + solve(my, mx, c, d, a, b)) % mod);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define N_ 301000\nusing namespace std;\nint n, m;\nchar X1[N_], X2[N_], Y1[N_], Y2[N_];\nlong long U[N_], D[N_], L[N_], R[N_], F[N_], InvF[N_], UU[N_], LL[N_], res;\nlong long Mod = 998244353;\nlong long Pow(long long a, int b){\n    long long r = 1;\n    while(b){\n        if(b&1)r=r*a%Mod;\n        a=a*a%Mod;b>>=1;\n    }\n    return r;\n}\nlong long Comb(int a, int b){\n    if(a<b)return 0;\n    return F[a] * InvF[b]%Mod*InvF[a-b]%Mod;\n}\nlong long Calc(int a, int b, int c){\n    return (Comb(a+b+c,c) - Comb(a+b+c-1, c) + Mod) % Mod;\n}\nint main(){\n    int i;\n    scanf(\"%d%d\",&n,&m);\n    scanf(\"%s\",X1+1);\n    scanf(\"%s\",X2+1);\n    scanf(\"%s\",Y1+1);\n    scanf(\"%s\",Y2+1);\n    F[0]=1;\n    int sum = 0;\n    for(i=1;i<=n;i++){\n        sum += X1[i]-'0';\n        sum += X2[i]-'0';\n    }\n    for(i=1;i<=m;i++){\n        sum += Y1[i]-'0';\n        sum += Y2[i]-'0';\n    }\n    if(!sum){\n        printf(\"1\\n\");\n        return 0;\n    }\n    for(i=1;i<=300000;i++)F[i]=F[i-1]*i%Mod;\n    InvF[300000] = Pow(F[300000], Mod-2);\n    for(i=300000;i>=1;i--)InvF[i-1] = InvF[i] * i % Mod;\n    int s1 = 0, s2 = 0, cc = 0;\n    for(i=1;i<=m;i++)if(Y1[i] == '1')cc++;\n    U[0] = 1;\n    for(i=1;i<=n;i++){\n        if(X1[i] == '1')s1++;\n        if(X2[i] == '1')s2++;\n        U[i] = Calc(s1,s2,cc);\n    }\n    s1 = s2 = cc = 0;\n    for(i=1;i<=m;i++)if(Y2[i] == '1')cc++;\n    D[n+1] = 1;\n    for(i=n;i>=1;i--){\n        if(X1[i] == '1')s1++;\n        if(X2[i] == '1')s2++;\n        D[i] = Calc(s1,s2,cc);\n    }\n    s1 = s2 = cc = 0;\n    for(i=1;i<=n;i++)if(X1[i] == '1')cc++;\n    L[0] = 1;\n    for(i=1;i<=m;i++){\n        if(Y1[i] == '1')s1++;\n        if(Y2[i] == '1')s2++;\n        L[i] = Calc(s1,s2,cc);\n    }\n    s1 = s2 = cc = 0;\n    R[m+1] = 1;\n    for(i=1;i<=n;i++)if(X2[i] == '1')cc++;\n    for(i=m;i>=1;i--){\n        if(Y1[i] == '1')s1++;\n        if(Y2[i] == '1')s2++;\n        R[i] = Calc(s1,s2,cc);\n    }\n    UU[0] = 1;\n    for(i=1;i<=n;i++){\n        int t = X1[i]-'0' + X2[i]-'0';\n        UU[i] = UU[i-1];\n        if(t==2) UU[i] += UU[i-1];\n        if(t) UU[i] += U[i];\n        UU[i]%=Mod;\n    }\n    LL[0] = 1;\n    for(i=1;i<=m;i++){\n        int t = Y1[i]-'0' + Y2[i]-'0';\n        LL[i] = LL[i-1];\n        if(t==2) LL[i] += LL[i-1];\n        if(t) LL[i] += L[i];\n        LL[i]%=Mod;\n    }\n    for(i=1;i<=n;i++){\n        int c = X1[i] - '0' + X2[i] - '0';\n        res = (res + UU[i-1]*D[i+1]*c) % Mod;\n    }\n //   printf(\"%lld\\n\",res);\n    for(i=1;i<=m;i++){\n        int c = Y1[i] - '0' + Y2[i] - '0';\n        res = (res + LL[i-1]*R[i+1]*c) % Mod;\n    }\n    for(i=1;i<=4;i++){\n//        printf(\"%lld %lld %lld %lld %lld %lld\\n\",U[i],D[i],L[i],R[i],UU[i],LL[i]);\n    }\n    printf(\"%lld\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n\nconst int N = 100001;\nconst int MOD = 998244353;\n\nint fact[N * 3], inv_fact[N * 3];\n\nvoid update(int& x, int a)\n{\n    x += a;\n    if (x >= MOD) {\n        x -= MOD;\n    }\n}\n\nint solve(int n, int m, char* a, char* b, char* c, char* d)\n{\n    static int ways[2][N];\n    memset(ways, 0, sizeof(ways));\n    for (int _ = 0; _ < 2; ++ _) {\n        int C = 0;\n        for (int j = 0; j < m; ++ j) {\n            C += c[j] == '1';\n        }\n        int A = 0;\n        int B = 0;\n        for (int i = 0; i < n; ++ i) {\n            if (a[i] == '0' && b[i] == '0') {\n                continue;\n            }\n            if (C) {\n                ways[_][i] = (long long)fact[A + B + C - 1] * inv_fact[A + B] % MOD * inv_fact[C - 1] % MOD;\n            } else if (!A && !B) {\n                ways[_][i] = 1;\n            }\n            A += a[i] == '1';\n            B += b[i] == '1';\n        }\n        std::reverse(a, a + n);\n        std::reverse(b, b + n);\n        std::swap(c, d);\n    }\n    std::reverse(ways[1], ways[1] + n);\n    int result = 0;\n    int prefix = 0;\n    for (int i = 0; i < n; ++ i) {\n        update(prefix, ways[0][i]);\n        if (a[i] == '1' && b[i] == '1') {\n            prefix = 2LL * prefix % MOD;\n        }\n        update(result, (long long)prefix * ways[1][i] % MOD);\n    }\n    return result;\n}\n\nint main()\n{\n    inv_fact[1] = 1;\n    for (int i = 2; i < N * 3; ++ i) {\n        inv_fact[i] = (long long)(MOD - MOD / i) * inv_fact[MOD % i] % MOD;\n    }\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < N * 3; ++ i) {\n        fact[i] = (long long)fact[i - 1] * i % MOD;\n        inv_fact[i] = (long long)inv_fact[i - 1] * inv_fact[i] % MOD;\n    }\n    int n, m;\n    static char a[N], b[N], c[N], d[N];\n    while (scanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d) == 6) {\n        int result = solve(n, m, a, b, c, d);\n        update(result, solve(m, n, c, d, a, b));\n        printf(\"%d\\n\", result);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int N = 300000;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 998244353;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nLL fpm(LL base, LL exp) {\n    LL res = 1;\n    for(; exp > 0; exp >>= 1) {\n        if(exp & 1) \n            res = res * base % mod;\n        base = base * base % mod;\n    }\n    return res;\n}\n\nint cnt[4];\nchar st[N + 5];\nLL fac[N + 5], inv[N + 5];\n\ninline LL C(int n, int k) {\n    return fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint n, m;\nbool a[N + 5], b[N + 5], c[N + 5], d[N + 5];\n\nLL calc() {\n    LL pre = 1, res = 0;\n    int lu = 0, ld = 0, ru = cnt[2], rd = cnt[3];\n    for(int i = 0; i < m; ++i) {\n        if(c[i]) lu ++, ru --;\n        if(d[i]) ld ++, rd --;\n        if(c[i] && d[i]) { (pre <<= 1LL) %= mod; }\n\n        if(c[i] || d[i]) { \n            res = (res + pre*(cnt[1] ? C(cnt[1]+ru+rd - 1, cnt[1] - 1) : (ru + rd == 0))) % mod;\n            pre = (pre + (cnt[0] ? C(cnt[0]+lu+ld - 1, cnt[0] - 1) : (lu + ld == 0))) % mod;\n        }\n    }\n    return res;\n}\n\nvoid Input() {\n    cin >> n >> m;\n    scanf(\"%s\", st); for(int i = 0; i < n; ++i) cnt[0] += (a[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < n; ++i) cnt[1] += (b[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < m; ++i) cnt[2] += (c[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < m; ++i) cnt[3] += (d[i] = st[i] - '0');\n}\n\nvoid Init() {\n    fac[0] = 1;\n    for(int i = 1; i <= N; ++i) fac[i] = fac[i-1] * i % mod;\n    inv[N] = fpm(fac[N], mod - 2);\n    for(int i = N; i >= 1; --i) inv[i-1] = inv[i] * i % mod;\n}\n\nvoid Solve() {\n    LL Ans = calc();\n\n    swap(n, m); swap(b, c);\n    swap(a, d); swap(a, b);\n    swap(cnt[0], cnt[3]);\n    swap(cnt[1], cnt[2]);\n    swap(cnt[0], cnt[1]);\n\n    Ans = (Ans + calc()) % mod;\n    printf(\"%lld\\n\", Ans);\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    Init();\n    Input();\n    Solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mem(a,b) memset(a,b,sizeof(a))\n#define  For(i,a,b) for(int i=a,i##E=b;i<=i##E;++i)\n#define rFor(i,a,b) for(int i=a,i##E=b;i>=i##E;--i)\ntypedef long long LL;\nusing namespace std;\nconst int N=4e5+7;\nconst LL mod=998244353;\nconst LL inv2=499122177;\ntemplate<typename T>inline bool chkmin(T &a,const T &b){return a>b?a=b,1:0;}\ntemplate<typename T>inline bool chkmax(T &a,const T &b){return a<b?a=b,1:0;}\ntemplate<typename T>inline void read(T &x)\n{\n\tx=0;int _f(0);char ch=getchar();\n\twhile(!isdigit(ch))_f|=(ch=='-'),ch=getchar();\n\twhile( isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\tx=_f?-x:x;\n}\ninline void file()\n{\n#ifdef ztzshiwo\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n}\nint n,m;\nchar s[5][N];\nLL fac[N],ifac[N];\ninline void Add(LL &x,LL y){x=x+y<mod?x+y:x+y-mod;}\ninline LL qpow(LL a,LL b)\n{\n\tLL ret=1;\n\tfor(;b;b>>=1,a=a*a%mod)\n\t\tif(b&1)ret=ret*a%mod;\n\treturn ret;\n}\ninline void init(int n)\n{\n\tfac[0]=ifac[0]=1;\n\tFor(i,1,n)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=qpow(fac[n],mod-2);\n\trFor(i,n,1)ifac[i-1]=ifac[i]*i%mod;\n}\ninline LL C(int n,int k)\n{\n\tif(n==k)return 1;\n\treturn fac[n]*ifac[k]%mod*ifac[n-k]%mod;\n}\ninline LL Solve()\n{\n\tint L=0,R=0,Sl=0,Sr=0;\n\tFor(i,1,n)Sl+=s[1][i-1]-'0',Sr+=s[2][i-1]-'0';\n\tFor(i,1,m)R+=s[3][i-1]-'0'+s[4][i-1]-'0';\n\tLL now=0,ans=0;\n\tFor(i,1,m)\n\t{\n\t\tint type=s[3][i-1]-'0'+s[4][i-1]-'0';\n\t\tif(type)\n\t\t{\n\t\t\tAdd(now,!Sl?(!L?1:0):C(Sl+L-1,L));\n\t\t\tL+=type,R-=type;\n\t\t\ttype==2?Add(now,now):(void)1;\n\t\t\tAdd(ans,now*(!Sr?(!R?1:0):C(Sr+R-1,R))%mod);\n\t\t}\n\t}\n\treturn ans;\n}\nint main()\n{\n\tfile();\n\tread(n),read(m);\n\tinit((n+m)*2);\n\tFor(i,1,4)scanf(\"%s\",s[i]);\n\tLL ans=0;\n\tAdd(ans,Solve());\n\tswap(n,m);\n\tswap(s[1],s[3]);\n\tswap(s[2],s[4]);\n\tAdd(ans,Solve());\n\tprintf(\"%lld\\n\",ans==0?1:ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 3e5 + 100;\n\nconst int mod = 998244353;\n\nint n, m, ans;\nchar A[maxn], B[maxn], C[maxn], D[maxn];\nint fac[maxn], ifac[maxn];\nint f[maxn], g[maxn], has[maxn], pw[maxn], cnt[maxn], ipw[maxn];\n\nint Exp(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tfac[0] = 1;\n\tpw[0] = ipw[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tpw[i] = (pw[i - 1] << 1) % mod;\n\t\tipw[i] = Exp(pw[i], mod - 2);\n\t}\n\tifac[maxn - 1] = Exp(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint CC(int n, int m) {\n\treturn (m < 0 || n < m) ? 0 : 1ll * fac[n] * ifac[n - m] % mod * ifac[m] % mod;\n}\n\nvoid solve(int n, int m, char *A, char *B, char *C, char *D) {\n\tint x = 0, a = 0, b = 0;\n\tforn(i, 1, m) {\n\t\tx += (C[i] == '1');\n\t}\n\tdebug(\"x = %d\\n\", x);\n\tcnt[0] = 0;\n\tforn(i, 1, n) {\n\t\tcnt[i] = cnt[i - 1] + (A[i] == '1' && B[i] == '1');\n\t}\n\tcnt[n + 1] = cnt[n];\n\tif(x) {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t\tdebug(\"f[%d] = %lld\\n\", i, f[i]);\n\t\t\tf[i] = 1ll * f[i] * ipw[cnt[i - 1]] % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = 1;\n\t\t\t\twhile(++i <= n) {\n\t\t\t\t\tf[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tx = 0;\n\ta = 0;\n\tb = 0;\n\tforn(i, 1, m) {\n\t\tx += (D[i] == '1');\n\t}\n\tdebug(\"x = %d\\n\", x);\n\tif(x) {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[i] = 0;\n\t\t\t}\n\t\t\tdebug(\"g[%d] = %lld\\n\", i, g[i]);\n\t\t\tg[i] = 1ll * g[i] * pw[cnt[i]] % mod;\n\t\t\t(g[i] += g[i + 1]) %= mod;\n\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = pw[cnt[i]];\n\t\t\t\twhile(i) {\n\t\t\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\t\t\tg[--i] = g[i + 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tdebug(\"ans = %d\\n\\n\", ans);\n\treturn;\n}\n\nint main() {\n\tpre();\n\tscf(n, m);\n\tscanf(\"%s\", A + 1);\n\tscanf(\"%s\", B + 1);\n\tscanf(\"%s\", C + 1);\n\tscanf(\"%s\", D + 1);\n\tsolve(n, m, A, B, C, D);\n\tsolve(m, n, C, D, A, B);\n\tif(!ans) {\n\t\tans = 1;\n\t}\n\tprintf(\"%d\\n\", (ans % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//my vegetable has exploded. :(\n#include<bits/stdc++.h>\n#define max(x,y) (x>y?x:y)\n#define min(x,y) (x<y?x:y)\n#define MM(x,y) memset(x,y,sizeof(x))\n#define MCPY(a,b) memcpy(a,b,sizeof(b))\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define fi first\n#define se second\nusing namespace std;\n#define nl puts(\"\")\n#define int long long\n\ninline int quickpow(int m,int n,int p){int b=1;while(n){if(n&1)b=b*m%p;n=n>>1;m=m*m%p;}return b;}\ninline int getinv(int x,int p){return quickpow(x,p-2,p);}\ninline int read(void){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){f=ch=='-'?-1:1;ch=getchar();}\n    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n    return x * f;\n}\nconst int MAXN = 4e5 + 10;\nconst int Mod = 998244353;\nconst int inv2 = getinv(2,Mod);\nint inv[MAXN],fac[MAXN],n,m,Ans;\nchar A[MAXN],B[MAXN],C[MAXN],D[MAXN];\nint a[MAXN],b[MAXN];\ninline void init(void){\n    inv[0]=inv[1]=fac[0]=1;\n    rep(i,1,4e5) fac[i] = 1LL * fac[i-1] * i % Mod;\n    inv[400000] = getinv(fac[400000],Mod);\n    per(i,4e5-1,1) inv[i] = inv[i+1] * (i+1) % Mod;\n}\n///------------------head------------------\ninline int Combine(int n,int m){return fac[n] * inv[m] % Mod * inv[n-m] % Mod;}\ninline void calc(int n,int m,char *A,char *B,char *C,char *D){\n    MM(a,0); MM(b,0);\n    a[0] = b[m+1] = 1;\n    int c1=0,c2=0,ret=0;\n    rep(i,1,n) c2 += A[i] == '1';\n    rep(i,1,m){\n        if (D[i]=='1') ++c1;\n        if (C[i]=='1') ++c1;\n        a[i] = Combine(c1+c2,c1);\n        if (c1) a[i] = (a[i] - Combine(c1+c2-1,c1-1) + Mod) % Mod;\n    }\n    c1 = 0,c2 = 0;\n    rep(i,1,n) c2 += B[i] == '1';\n    per(i,m,1){\n        if (D[i]=='1') ++c1;\n        if (C[i]=='1') ++c1;\n        b[i] = Combine(c1+c2,c1);\n        if (c1) b[i] = (b[i] - Combine(c1+c2-1,c1-1) + Mod) % Mod;\n    }\n    int t = 1;\n    rep(i,0,m) {\n        if (i > 0 && C[i] == '1' && D[i] == '1') t = t * inv2 % Mod;\n        a[i] = a[i] * t % Mod;\n        if (i <= m && C[i+1] == '0' && D[i+1] == '0') a[i] = 0;\n    }\n    rep(i,1,m) a[i]=(a[i-1]+a[i])%Mod;\n    t=1;\n    rep(i,1,m+1)\n    {\n        b[i] = b[i] * t % Mod;\n        if (i <= m && C[i] == '1' && D[i] == '1') t = t * 2 % Mod;\n        if (i > 1 && C[i-1] == '0' && D[i-1] == '0') b[i] = 0;\n    }\n    rep(i,1,m) ret = (ret + a[i-1] * b[i+1]) % Mod;\n    Ans = (Ans + ret) % Mod;\n}\nsigned main(signed argc, char *argv[])\n{\n    // freopen(\"a01.txt\",\"r\",stdin);\n    // freopen(\"my.out\",\"w\",stdout);\n    init();\n    n=read();m=read();\n    scanf(\"%s\",A+1); scanf(\"%s\",B+1); scanf(\"%s\",C+1); scanf(\"%s\",D+1);\n    int ok=0;\n    rep(i,1,n) ok|=(A[i]=='1')|(B[i]=='1');\n    rep(i,1,m) ok|=(C[i]=='1')|(D[i]=='1');\n    if (!ok) return puts(\"1\"),0;\n    calc(n,m,A,B,C,D); calc(m,n,C,D,A,B);\n    printf(\"%lld\\n\",Ans % Mod);\n    return 0;\n}\n\n/* Examples: */\n/*\n\n*/\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) do{print_vars(cout<<\"# \"<<#__VA_ARGS__<<'=',__VA_ARGS__);cout<<endl;}while(0)\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\nvoid print_vars(ostream&){}\ntemplate<typename Car,typename... Cdr>\nvoid print_vars(ostream& os,const Car& car,const Cdr&... cdr){\n\tprint_vars(os<<car<<(sizeof...(cdr)?\",\":\"\"),cdr...);\n}\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<int I,typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<int I,typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tos<<get<I>(t)<<(sizeof...(Cdr)?\",\":\"\");\n\tprint_tuple<I+1,Cdr...>(os,t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<0,Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=998244353;\nconstexpr double EPS=1e-9;\n\ntemplate<uint M>\nstruct modint{\n\tuint val;\n\tmodint(uint x=0):val((x%M+M)%M){}\n\tmodint pow(uint r)const{\n\t\tll a=val,x=1;\n\t\tfor(;r;r>>=1){\n\t\t\tif(r&1)\n\t\t\t\t(x*=a)%=M;\n\t\t\t(a*=a)%=M;\n\t\t}\n\t\treturn x;\n\t}\n\tmodint inv()const{\n\t\tll x=1;\n\t\tfor(ll a=val,b=M,u=0;b;){\n\t\t\tll t=a/b;\n\t\t\tswap(a-=b*t,b);\n\t\t\tswap(x-=u*t,u);\n\t\t}\n\t\treturn (x+M)%M;\n\t}\n\tmodint& operator=(const modint& x)&{val=x.val; return *this;}\n\tmodint& operator+=(const modint& x)&{if((val+=x.val)>=M) val-=M; return *this;}\n\tmodint& operator-=(const modint& x)&{if((val+=M-x.val)>=M) val-=M; return *this;}\n\tmodint& operator*=(const modint& x)&{val=(ll)val*x.val%M; return *this;}\n\tmodint& operator/=(const modint& x)&{val=(ll)val*x.inv().val%M; return *this;}\n};\n\ntemplate<uint M> bool operator==(const modint<M>& a,const modint<M>& b){return a.val==b.val;}\ntemplate<uint M> bool operator!=(const modint<M>& a,const modint<M>& b){return a.val!=b.val;}\ntemplate<uint M> modint<M> operator+(modint<M> a,const modint<M>& b){a+=b; return a;}\ntemplate<uint M> modint<M> operator-(modint<M> a,const modint<M>& b){a-=b; return a;}\ntemplate<uint M> modint<M> operator*(modint<M> a,const modint<M>& b){a*=b; return a;}\ntemplate<uint M> modint<M> operator/(modint<M> a,const modint<M>& b){a/=b; return a;}\ntemplate<uint M> ostream& operator<<(ostream& os,const modint<M>& x){return os<<x.val;}\n\nusing mint=modint<MOD>;\n\nint fact[300001],ifact[300001];\nint ncr(int n,int r)\n{\n\treturn (ll)fact[n]*ifact[n-r]%MOD*ifact[r]%MOD;\n}\n\nvector<mint> calc(const vi& ls,const vi& ts,const vi& bs)\n{\n\tvi js=ts; js.insert(js.end(),all(bs));\n\tsort(all(js)); js.erase(unique(all(js)),end(js));\n\n\tvector<mint> cs;\n\tint ln=ls.size();\n\tfor(int j:js){\n\t\tint tn=lower_bound(all(ts),j)-begin(ts),bn=lower_bound(all(bs),j)-begin(bs);\n\t\tif(ln==0){\n\t\t\tif(tn+bn==0)\n\t\t\t\tcs.push_back(1);\n\t\t\telse\n\t\t\t\tcs.push_back(0);\n\t\t}\n\t\telse{\n\t\t\tcs.push_back(ncr(ln-1+tn+bn,tn+bn));\n\t\t}\n\t}\n\treturn cs;\n}\n\nint main()\n{\n\t#ifndef _GLIBCXX_DEBUG\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tconstexpr char endl='\\n';\n\t#endif\n\n\tfact[0]=ifact[0]=1;\n\trepi(i,1,300001){\n\t\tfact[i]=(ll)fact[i-1]*i%MOD;\n\t\tifact[i]=mint(fact[i]).inv().val;\n\t}\n\n\tfor(int h,w;cin>>h>>w&&h|w;){\n\t\tstring a,b,c,d; cin>>a>>b>>c>>d;\n\n\t\tmint res;\n\t\trep(_,2){\n\t\t\tvi ls,rs,ts,bs;\n\t\t\trep(i,h) if(a[i]=='1') ls.push_back(i);\n\t\t\trep(i,h) if(b[i]=='1') rs.push_back(i);\n\t\t\trep(i,w) if(c[i]=='1') ts.push_back(i);\n\t\t\trep(i,w) if(d[i]=='1') bs.push_back(i);\n\n\t\t\tvi js=ts; js.insert(js.end(),all(bs));\n\t\t\tsort(all(js)); js.erase(unique(all(js)),end(js));\n\n\t\t\tvi two(w+1);\n\t\t\trep(i,w) two[i+1]=two[i]+(c[i]=='1'&&d[i]=='1');\n\n\t\t\tvector<mint> dpl(js.size());\n\t\t\t{\n\t\t\t\tvector<mint> cs=calc(ls,ts,bs);\n\t\t\t\tmint prev=0;\n\t\t\t\trep(i,js.size()){\n\t\t\t\t\tint j=js[i];\n\t\t\t\t\tdpl[i]=prev+cs[i]*mint(2).pow(two[w]-two[j]);\n\t\t\t\t\tprev=dpl[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tvi ts2(rbegin(ts),rend(ts)),bs2(rbegin(bs),rend(bs));\n\t\t\t\tfor(int& j:ts2) j=w-1-j;\n\t\t\t\tfor(int& j:bs2) j=w-1-j;\n\t\t\t\tvector<mint> cs=calc(rs,ts2,bs2);\n\t\t\t\treverse(all(cs));\n\t\t\t\trep(i,js.size()){\n\t\t\t\t\tint j=js[i];\n\t\t\t\t\tres+=dpl[i]*cs[i]/mint(2).pow(two[w]-two[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ttie(h,w,a,b,c,d)=mt(w,h,c,d,a,b);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * Sergey Kopeliovich (burunduk30@gmail.com)\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n\ntypedef long long ll;\n\nconst int MOD = 998244353;\nvoid add( int &a, int b ) { if ((a += b) >= MOD) a -= MOD; }\nint mul( int a, int b ) { return (ll)a * b % MOD; }\n\nconst int N = 2e6 + 3;\nint inv[N];\n\nstruct C {\n\tint n, k, r;\n\tC() {}\n\tC( int n, int k, int r = 1 ) : n(n), k(k), r(r) { }\n\tvoid dn() {\n\t\tr = mul(r, ++n);\n\t\tr = mul(r, inv[n - k]);\n\t}\n\tvoid dk() {\n\t\tr = mul(r, n - k++);\n\t\tr = mul(r, inv[k]);\n\t}\n};\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++) \n\t\tinv[i] = ((ll)(MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tint tmp1, tmp2;\n\tstring sa, sb, sc, sd;\n\tcin >> tmp1 >> tmp2 >> sa >> sb >> sc >> sd;\n\tauto ok = [&]( char c ) {\n\t\treturn c == '1';\n\t};\n\tauto get = [&]( string &s ) {\n\t\treturn count_if(s.begin(), s.end(), ok);\n\t};\n\n\tint res = 0;\n\tforn(_, 2) {\n\t\tint n = sa.size(), m = sc.size();\n\t\tint na = get(sa), nb = get(sb);\n\t\tvector<int> F1(n), F2(n);\n\t\tforn(__, 2) {\n\t\t\tint cnt_a = 0, cnt_b = 0, nc = get(sc);\n\t\t\tC c2(cnt_a + cnt_b + nc - 1, nc - 1);\n\t\t\tforn(i, n) {\n\t\t\t\tif (ok(sa[i]) || ok(sb[i])) {\n\t\t\t\t\tF1[i] = c2.r;\n\t\t\t\t\tif (ok(sa[i])) c2.dn(), cnt_a++;\n\t\t\t\t\tif (ok(sb[i])) c2.dn(), cnt_b++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(sc, sd), swap(F1, F2);\n\t\t\treverse(sa.begin(), sa.end());\n\t\t\treverse(sb.begin(), sb.end());\n\t\t}\n\t\treverse(F2.begin(), F2.end());\n\t\tint last = -1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tadd(F2[i], F2[i + 1]);\n\t\t\tif (ok(sa[i + 1]) + ok(sb[i + 1]) == 2)\n\t\t\t\tadd(F2[i], F2[i + 1]);\n\t\t}\n\t\tforn(i, n)\n\t\t\tif (ok(sa[i]) || ok(sb[i]))\n\t\t\t\tadd(res, mul(mul(F1[i], F2[i]), ok(sa[i]) + ok(sb[i])));\n\t\tswap(sa, sc), swap(sb, sd);\n\t}\n\tprintf(\"%d\\n\", max(res, 1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nlong long fact[300009], factinv[300009], mod = 998244353;\n\nlong long modpow(long long a, long long b, long long m) {\n\tlong long p = 1, q = a;\n\tfor (int i = 0; i < 32; i++) {\n\t\tif ((b / (1LL << i)) % 2 == 1) { p *= q; p %= m; }\n\t\tq *= q; q %= m;\n\t}\n\treturn p;\n}\n\nlong long Div(long long a, long long b, long long m) {\n\treturn (a * modpow(b, m - 2, m)) % m;\n}\n\nvoid init() {\n\tfact[0] = 1; for (int i = 1; i <= 300000; i++) fact[i] = (fact[i - 1] * i) % mod;\n\tfor (int i = 0; i <= 300000; i++) factinv[i] = Div(1, fact[i], mod);\n}\n\nlong long ncr(long long n, long long r) {\n\tif (r < 0 || n < r) return 0;\n\treturn (fact[n] * factinv[r] % mod) * factinv[n - r] % mod;\n}\n\nlong long N, M, cnt, p1, p2, L1[100009], L2[100009]; string A, B, C, D;\n\nvoid dels() {\n\tcnt = 0; p1 = 0; p2 = 0;\n\tfor (int i = 0; i < 100009; i++) { L1[i] = 0; L2[i] = 0; }\n}\n\nlong long solve() {\n\tdels();\n\tfor (int i = 0; i < N; i++) { if (A[i] == '1' || B[i] == '1') cnt++; }\n\tfor (int i = 0; i < M; i++) { if (C[i] == '1') p1++; if (D[i] == '1') p2++; }\n\n\tint v = 0; L1[0] = 1;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL1[i + 1] = ncr(v + p1 - 1, p1 - 1);\n\t\tif (p1 == 0) L1[i + 1] = 1;\n\t}\n\tv = 0; L2[N - 1] = 1;\n\tfor (int i = N - 1; i >= 1; i--) {\n\t\tif (A[i] == '1') v++;\n\t\tif (B[i] == '1') v++;\n\t\tL2[i - 1] = ncr(v + p2 - 1, p2 - 1);\n\t\tif (p2 == 0) L2[i + 1] = 1;\n\t}\n\tlong long ret = 0, ans = 0;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (A[i] == '1' || B[i] == '1') ret += L2[i];\n\t\tret %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ans += L1[i] * ret;\n\t\tif (A[i] == '1' || B[i] == '1') ans += L1[i] * ret;\n\t\tans %= mod;\n\t\tif (A[i] == '1' && B[i] == '1') ret *= 2;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tinit();\n\tcin >> N >> M >> A >> B >> C >> D;\n\n\tlong long c1 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tlong long c2 = solve(); swap(N, M); swap(A, C); swap(B, D);\n\tcout << (c1 + c2) % mod << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntemplate<unsigned int mod_>\nstruct ModInt{\n\tusing uint = unsigned int;\n\tusing ll = long long;\n\tusing ull = unsigned long long;\n\n\tconstexpr static uint mod = mod_;\n\n\tuint v;\n\tModInt():v(0){}\n\tModInt(ll v):v(normS(v%mod+mod)){}\n\texplicit operator bool() const {return v!=0;}\n\tstatic uint normS(const uint &x){return (x<mod)?x:x-mod;}\t\t// [0 , 2*mod-1] -> [0 , mod-1]\n\tstatic ModInt make(const uint &x){ModInt m; m.v=x; return m;}\n\tModInt operator+(const ModInt& b) const { return make(normS(v+b.v));}\n\tModInt operator-(const ModInt& b) const { return make(normS(v+mod-b.v));}\n\tModInt operator-() const { return make(normS(mod-v)); }\n\tModInt operator*(const ModInt& b) const { return make((ull)v*b.v%mod);}\n\tModInt operator/(const ModInt& b) const { return *this*b.inv();}\n\tModInt& operator+=(const ModInt& b){ return *this=*this+b;}\n\tModInt& operator-=(const ModInt& b){ return *this=*this-b;}\n\tModInt& operator*=(const ModInt& b){ return *this=*this*b;}\n\tModInt& operator/=(const ModInt& b){ return *this=*this/b;}\n\tll extgcd(ll a,ll b,ll &x,ll &y) const{\n\t\tll u[]={a,1,0},v[]={b,0,1};\n\t\twhile(*v){\n\t\t\tll t=*u/ *v;\n\t\t\trep(i,3) swap(u[i]-=t*v[i],v[i]);\n\t\t}\n\t\tif(u[0]<0) rep(i,3) u[i]=-u[i];\n\t\tx=u[1],y=u[2];\n\t\treturn u[0];\n\t}\n\tModInt inv() const{\n\t\tll x,y;\n\t\textgcd(v,mod,x,y);\n\t\treturn make(normS(x+mod));\n\t}\n\tbool operator==(const ModInt& b) const { return v==b.v;}\n\tbool operator!=(const ModInt& b) const { return v!=b.v;}\n\tfriend istream& operator>>(istream &o,ModInt& x){\n\t\tll tmp;\n\t\to>>tmp;\n\t\tx=ModInt(tmp);\n\t\treturn o;\n\t}\n\tfriend ostream& operator<<(ostream &o,const ModInt& x){ return o<<x.v;}\n};\nusing mint = ModInt<998244353>;\nconst int MX = 400000;\nmint fac[MX],ifac[MX];\nvoid precalc(){\n\tfac[0] = ifac[0] = 1;\n\trep1(i,MX-1) fac[i] = fac[i-1]*i;\n\trep1(i,MX-1) ifac[i] = ifac[i-1]/i;\n}\nmint C(int x,int y){\n\tif(x<y) return 0;\n\tif(x==y) return 1;\n\tif(y<0) return 0;\n\treturn fac[x]*ifac[y]*ifac[x-y];\n}\n\nint H,W;\nvector<bool> sh[2],sw[2];\nvoid input(){\n\tcin>>H>>W;\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(char c:s) sh[0].pb(c-'0');\n\t}\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(char c:s) sh[1].pb(c-'0');\n\t}\n\t{\n\t\tvector<bool> b[2];\n\t\trep(i,H){\n\t\t\tif(!sh[0][i] && !sh[1][i]) continue;\n\t\t\tb[0].pb(sh[0][i]);\n\t\t\tb[1].pb(sh[1][i]);\n\t\t}\n\t\tsh[0] = b[0], sh[1] = b[1];\n\t\tH = sh[0].size();\n\t}\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(char c:s) sw[0].pb(c-'0');\n\t}\n\t{\n\t\tstring s;\n\t\tcin>>s;\n\t\tfor(char c:s) sw[1].pb(c-'0');\n\t}\n\t{\n\t\tvector<bool> b[2];\n\t\trep(i,W){\n\t\t\tif(!sw[0][i] && !sw[1][i]) continue;\n\t\t\tb[0].pb(sw[0][i]);\n\t\t\tb[1].pb(sw[1][i]);\n\t\t}\n\t\tsw[0] = b[0], sw[1] = b[1];\n\t\tW = sw[0].size();\n\t}\n\n}\n\nconst int MN = 100010;\nmint fl[MN],fr[MN];\nvoid calcfl(mint* fl,bool flipped){\n\trep(i,MN) fl[i] = 0;\n\tint hnum = 0;\n\trep(i,H) if(sh[flipped][i]) hnum++;\n\tif(hnum == 0){\n\t\tfl[0] = 1;\n\t\treturn;\n\t}\n\tint wnum = 0;\n\trep(l,W){\n\t\tfl[l] = C(hnum+wnum-1,wnum);\n\t\trep(t,2) if(sw[t][l]) wnum++;\n\t}\n}\nmint calc(){\n\tif(W==0) return 0;\n\tcalcfl(fl,0);\n\trep(t,2) reverse(all(sw[t]));\n\tcalcfl(fr,1);\n\trep(t,2) reverse(all(sw[t]));\n\treverse(fr,fr+W);\n\tmint res = 0;\n\tmint sum = 0;\n\tfor(int l = W-1; l>=0; l--){\n\t\tsum += fr[l];\n\t\tif(sw[0][l] && sw[1][l]) sum*=2;\n\t\tres += fl[l] * sum;\n\t}\n\t// mint brute = 0;\n\t// rep(l,W) for(int r=l;r<W;r++){\n\t// \tmint tmp = fl[l]*fr[r];\n\t// \tfor(int i=l;i<=r;i++) if(sw[0][i]&&sw[1][i]) tmp*=2;\n\t// \tbrute += tmp;\n\t// }\n\t// assert(res == brute);\n\treturn res;\n}\nint main(){\n\tprecalc();\n\tinput();\n\tif(H==0&&W==0){\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\t// H == 0 ?\n\n\tmint res = calc();\n\n\tswap(H,W);\n\trep(t,2) swap(sh[t],sw[t]);\n\n\tres += calc();\n\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring A,B,C,D;\nll mo=998244353;\n\nll combi(ll N_, ll C_) {\n\tconst int NUM_=400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nll modpow(ll a, ll n=mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nll L[101010],R[101010],P[101010],RS[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>A>>B>>C>>D;\n\tFORR(c,A) c-='0';\n\tFORR(c,B) c-='0';\n\tFORR(c,C) c-='0';\n\tFORR(c,D) c-='0';\n\ts=A+B+C+D;\n\t\n\tif(count(ALL(s),1)==0) return _P(\"1\\n\");\n\tll ret=0;\n\tFOR(i,2) {\n\t\tZERO(L);\n\t\tZERO(R);\n\t\tZERO(P);\n\t\tZERO(RS);\n\t\t\n\t\tint NL=count(ALL(A),1);\n\t\tint NR=count(ALL(B),1);\n\t\tint NT=0,NB=0;\n\t\tP[0]=1;\n\t\tFOR(x,W) {\n\t\t\tif(C[x]==0 && D[x]==0) {\n\t\t\t\tL[x+1]=0;\n\t\t\t}\n\t\t\telse if(NL==0) {\n\t\t\t\tif(NT+NB==0) L[x+1]=1;\n\t\t\t\telse L[x+1]=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL[x+1] = combi(NT+NB+NL-1,NL-1);\n\t\t\t}\n\t\t\tP[x+1]=P[x];\n\t\t\tif(C[x]&&D[x]) P[x+1]=2*P[x]%mo;\n\t\t\tNT+=C[x];\n\t\t\tNB+=D[x];\n\t\t}\n\t\tNT=0,NB=0;\n\t\tfor(x=W-1;x>=0;x--) {\n\t\t\tif(C[x]==0 && D[x]==0) {\n\t\t\t\tR[x+1]=0;\n\t\t\t}\n\t\t\telse if(NR==0) {\n\t\t\t\tif(NT+NB==0) R[x+1]=1;\n\t\t\t\telse R[x+1]=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR[x+1] = combi(NT+NB+NR-1,NR-1);\n\t\t\t}\n\t\t\t(R[x+1]*=P[x+1])%=mo;\n\t\t\tRS[x+1]=RS[x+2]+R[x+1];\n\t\t\t\n\t\t\t(ret += (C[x]+D[x])*L[x+1]*RS[x+1]%mo*modpow(P[x+1]))%=mo;\n\t\t\t\n\t\t\tNT+=C[x];\n\t\t\tNB+=D[x];\n\t\t}\n\t\t\n\t\t\n\t\tswap(H,W);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int mod=998244353;\ninline void add(int &a,int b){\n    a+=b;\n    if(a>=mod)a-=mod;\n}\nint mpow(int n,int m){\n    int ret=1;\n    while(m){\n        if(m&1)ret=ret*n%mod;\n        n=n*n%mod;\n        m>>=1;\n    }\n    return ret;\n}\nconst int FACT_SIZE=1111111;\nint fact[FACT_SIZE];\nint inv[FACT_SIZE];\nstruct fact_exec{\n    fact_exec(){\n        fact[0]=1;\n        for(int i=1;i<FACT_SIZE;i++)fact[i]=fact[i-1]*i%mod;\n        inv[FACT_SIZE-1]=mpow(fact[FACT_SIZE-1],mod-2);\n        for(int i=FACT_SIZE-2;i>=0;i--)inv[i]=inv[i+1]*(i+1)%mod;\n    }\n}factexec;\nint nCk(int n,int k){\n    if(n<0|k<0||k>n)return 0;\n    return fact[n]*inv[k]%mod*inv[n-k]%mod;\n}\nint nPk(int n,int k){\n    if(n<0||k<0||k>n)return 0;\n    return fact[n]*inv[n-k]%mod;\n}\n\n\nint calc(int L,int u,int d){\n    if(L==0){\n        return u==0&&d==0;\n    }\n\n    return nCk(L-1+u+d,u+d);\n}\n\nint solve(string A,string B,int L,int R){\n    int ret=0;\n\n    int sum=0;\n    int u=0,d=0;\n\n    int U=count(all(A),'1');\n    int D=count(all(B),'1');\n\n    for(int i=0;i<A.size();i++){\n        if(A[i]=='0'&&B[i]=='0')continue;\n        add(sum,calc(L,u,d));\n        if(A[i]=='1'&&B[i]=='1')sum=sum*2%mod;\n        u+=A[i]=='1';\n        d+=B[i]=='1';\n        add(ret,sum*calc(R,U-u,D-d)%mod);\n    }\n    return ret;\n}\n\nsigned main(){\n    int N,M;\n    string A,B,C,D;\n    cin>>N>>M>>A>>B>>C>>D;\n\n    int ans=0;\n    add(ans,solve(A,B,count(all(C),'1'),count(all(D),'1')));\n    add(ans,solve(C,D,count(all(A),'1'),count(all(B),'1')));\n\n\n    if(count(all(A),'1')+count(all(B),'1')+count(all(C),'1')+count(all(D),'1')==0){\n        ans=1;\n    }\n\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 998244353;\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\nconst int MX = 360000;\n\nint n, m;\nstring a, b, c, d;\n\nll fc[MX];\nll bfc[MX];\n\nll cnk(int n, int k) {\n\tif (n < k)\n\t\treturn 0;\n\treturn fc[n] * bfc[n - k] % MOD * bfc[k] % MOD;\n}\n\nll get(int a, int b, int c) {\n\tif (b == 0) {\n\t\tif (a == 0 && c == 0)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn cnk(a + b + c - 1, a + c);\n}\n\nll solve() {\n\tll sum = 0;\n\tint cl = 0;\n\tint cr = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (a[i] == '1')\n\t\t\t++cl;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (b[i] == '1')\n\t\t\t++cr;\n\tint cd2 = 0, cu2 = 0;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (c[i] == '1')\n\t\t\t++cu2;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (d[i] == '1')\n\t\t\t++cd2;\n\tint cd = 0, cu = 0;\n\tll ans = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (c[i] == '0' && d[i] == '0')\n\t\t\tcontinue;\n\t\tsum = (sum + get(cd, cl, cu)) % MOD;\n\t\tif (c[i] == '1' && d[i] == '1')\n\t\t\tsum = (sum * 2) % MOD;\n\t\tif (c[i] == '1')\n\t\t\t++cu, --cu2;\n\t\tif (d[i] == '1')\n\t\t\t++cd, --cd2;\n\t\tans = (ans + sum * get(cu2, cr, cd2)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfc[0] = bfc[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\t\tbfc[i] = pw(fc[i], MOD - 2);\n\t}\n\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\tll ans = solve();\n\tswap(a, c);\n\tswap(b, d);\n\tswap(n, m);\n\tans = (ans + solve()) % MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\nusing namespace std;\ntypedef long long LL;\nconst int maxn=1e5+2;\nconst int maxm=4e5+2;\nconst int mod=998244353;\nint n,m,ans;\nLL inv[maxn<<2],fac[maxn<<2];\nchar lef[maxn],rig[maxn],up[maxn],down[maxn];\nLL Com(LL a,LL b){return (LL)fac[a]*inv[b]%mod*inv[a-b]%mod;}\nLL change(char ch){return ch-'0';}\nvoid solve(int n,int m,char *lef,char *rig,char *up,char *down){\n\tLL suml=0,sumr=0;\n\tfor (int i=1;i<=n;i++){\n\t\tsuml+=change(lef[i]);\n\t\tsumr+=change(rig[i]);\n\t}\n\tLL sumu=0,sumd=0;\n\tfor (int i=1;i<=m;i++){\n\t\tsumu+=change(up[i]);\n\t\tsumd+=change(down[i]);\n\t}\n\tif (!suml&&!sumr&&!sumu&&!sumd){\n\t\tprintf(\"1\");\n\t\texit(0);\n\t}\n\tLL tmp=1,nowu=0,nowd=0,u=0,d=0;\n\tfor (int i=1;i<=m;i++){\n\t\tnowu+=(u=change(up[i]));\n\t\tnowd+=(d=change(down[i]));\n\t\tif (u||d){\n\t\t\tif (u&&d) tmp=tmp*2%mod;\n\t\t\tif (sumr) ans=(ans+tmp*Com(sumr+sumu+sumd-nowu-nowd-1,sumr-1))%mod;\n\t\t\telse ans=(ans+tmp*(sumu+sumd==nowu+nowd))%mod;\n\t\t\tif (suml) tmp=(tmp+Com(suml+nowu+nowd-1,suml-1))%mod;\n\t\t\telse tmp=(tmp+(nowu+nowd==0))%mod;\n\t\t}\n\t}\n}\nvoid init(){\n\tfac[0]=1;\n\tfor (int i=1;i<=maxm;i++) fac[i]=fac[i-1]*i%mod;\n\tinv[0]=inv[1]=1;\n\tfor (int i=2;i<=maxm;i++) inv[i]=(mod-mod/i)*inv[mod%i]%mod;\n\tfor (int i=2;i<=maxm;i++) inv[i]=(LL)inv[i]*inv[i-1]%mod;\n}\nint main(){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s%s%s%s\",lef+1,rig+1,up+1,down+1);\n\tsolve(n,m,lef,rig,up,down);\n\tsolve(m,n,up,down,lef,rig);\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> void get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'; t=getchar());\n\tif(t=='-')neg=true,t=getchar();\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) get1(a),get1(b)\n#define get3(a,b,c) get1(a),get2(b,c)\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nconst int mod=998244353;\nint power(int x,int y)\n{\n\tint ret=1;\n\twhile(y)\n\t{\n\t\tif(y&1)ret=1ll*ret*x%mod;\n\t\tx=1ll*x*x%mod;y>>=1;\n\t}\n\treturn ret;\n}\n\nchar a[100111],b[100111],c[100111],d[100111];\nint n,m,fac[300111],invf[300111];\nint getv(int u,int v,int w)\n{\n\tif(u==0)return (v==0&&w==0);\n\treturn 1ll*fac[u+v+w-1]*invf[u-1]%mod*invf[v+w]%mod;\n}\n\nint pre[100111];\nint calc(char*a,char*b,int tc,int td,int n)\n{\n\tpre[0]=1;\n\t\n\tint s1=0,s2=0;\n\tfor(int i=1;i<n;i++)\n\t{\n\t\tpre[i]=pre[i-1];\n\t\ts1+=a[i]-'0';s2+=b[i]-'0';\n\t\tif(a[i]=='1'&&b[i]=='1')\n\t\t{\n\t\t\tpre[i]+=pre[i];\n\t\t\tif(pre[i]>=mod)pre[i]-=mod;\n\t\t}\n\t\tif(a[i]=='1'||b[i]=='1')\n\t\t{\n\t\t\tpre[i]+=getv(tc,s1,s2);\n\t\t\tif(pre[i]>=mod)pre[i]-=mod;\n\t\t}\n\t}\n\ts1=s2=0;\n\tint ret=0;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tint cur=0;\n\t\tif(a[i]=='1'||b[i]=='1')\n\t\t\tcur+=getv(td,s1,s2);\n\t\tif(a[i]=='1'&&b[i]=='1')\n\t\t{\n\t\t\tcur+=cur;\n\t\t\tif(cur>=mod)cur-=mod;\n\t\t}\n\t\ts1+=a[i]-'0';s2+=b[i]-'0';\n\t\tret=(ret+1ll*cur*pre[i-1])%mod;\n\t}\n\treturn ret;\n}\nint main()\n{\n\tfac[0]=1;for(int i=1;i<300111;i++)fac[i]=1ll*fac[i-1]*i%mod;\n\tinvf[300110]=power(fac[300110],mod-2);for(int i=300111-2;i>=0;i--)invf[i]=1ll*invf[i+1]*(i+1)%mod;\n\t\n\tget2(n,m);scanf(\"%s%s%s%s\",a+1,b+1,c+1,d+1);\n\tint ta=0,tb=0,tc=0,td=0;\n\tfor(int i=1;i<=n;i++)ta+=a[i]-'0',tb+=b[i]-'0';\n\tfor(int i=1;i<=m;i++)tc+=c[i]-'0',td+=d[i]-'0';\n\tif(ta+tb+tc+td==0)\n\t{\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\tint ans=calc(a,b,tc,td,n)+calc(c,d,ta,tb,m);\n\tif(ans>=mod)ans-=mod;\n\tprintendl(ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<pi, int> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 600100;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\nll pow2[MAX_N];\n\n/*\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n*/\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\tpow2[0] = 1; pow2[1] = 2;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\t}\n}\n\nll getC(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\nint N, M;\nstring A, B, C, D;\nll bitcnt[MAX_N];\nll sum[MAX_N];\n\nll solve2(int y, int z, int x) {\n\tif(x == 0) {\n\t\tif(y == 0 && z == 0) return 1;\n\t\telse return 0;\n\t}\n\telse return getC(x + y + z - 1, x - 1);\n}\n\nll solve_sub() {\n\tint ccnt = accumulate(all(C), 0) - '0' * M;\n\tint dcnt = accumulate(all(D), 0) - '0' * M;\n\tint acnt = 0, bcnt = 0;\n\tbitcnt[0] = 0;\n\trep(i, 0, N) bitcnt[i + 1] = bitcnt[i] + ((A[i] == '1' && B[i] == '1') ? 1 : 0);\n\t//debug(vi(bitcnt, bitcnt + N + 1));\n\tsum[N] = 0;\n\trer(i, N, 0) {\n\t\tif(A[i] == '0' && B[i] == '0') sum[i] = sum[i + 1];\n\t\telse {\n\t\t\tsum[i] = sum[i + 1] + solve2(acnt, bcnt, dcnt) * pow2[bitcnt[i + 1]] % mod;\n\t\t\tsum[i] %= mod;\n\t\t}\n\t\tif(A[i] == '1') acnt++;\n\t\tif(B[i] == '1') bcnt++;\n\t}\n\tacnt = 0; bcnt = 0;\n\t//debug(vi(sum, sum + N + 1));\n\tacnt = 0; bcnt = 0;\n\tll res = 0;\n\tll mul = 1;\n\trep(i, 0, N) {\n\t\tif(A[i] == '0' && B[i] == '0') continue;\n\t\tll a = solve2(acnt, bcnt, ccnt);\n\t\tADD(res, a * mul % mod * sum[i] % mod);\n\t\tif(A[i] == '1') acnt++;\n\t\tif(B[i] == '1') bcnt++;\n\t\tif(A[i] == '1' && B[i] == '1') MUL(mul, inv[2]);\n\t}\n\treturn res;\n}\n\n\n\nvoid solve() {\n\tC_init(600010);\n\tcin >> N >> M;\n\tcin >> A >> B >> C >> D;\n\tint a = accumulate(all(A), 0) - '0' * N;\n\tint b = accumulate(all(B), 0) - '0' * N;\n\tint c = accumulate(all(C), 0) - '0' * M;\n\tint d = accumulate(all(D), 0) - '0' * M;\n\tif(a == 0 && b == 0 && c == 0 && d == 0) {\n\t\tcout << 1 << \"\\n\";\n\t\treturn;\n\t}\n\tll ans = 0;\n\tif(a != 0 || b != 0) ADD(ans, solve_sub());\n\tif(c != 0 || d != 0) {\n\t\tswap(N, M);\n\t\tswap(A, C);\n\t\tswap(B, D);\n\t\tADD(ans, solve_sub());\n\t}\n\tcout << ans << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int MOD = 998244353;\n\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\nvoid smul(int &a, int b)\n{\n    a = mul(a, b);\n}\n\nconst int N = (int) 3e5 + 100;\nint fact[N], rfact[N], ri[N];\n\n\nint getC(int n, int k)\n{\n    if (k < 0 || k > n) return 0;\n    return mul(fact[n], mul(rfact[n - k], rfact[k] ) );\n}\n\nint solve(int a, int c, int d)\n{\n    if (a == 0 && c == 0 && d == 0) return 1;\n    return getC(a + c + d - 1, c + d);\n}\n\nint solve(int n, int m, char sa[], char sb[], char sc[], char sd[] )\n{\n    int a = 0, b = 0;\n    int c = 0, d = 0;\n    for (int i = 0; i < n; i++)\n    {\n        a += sa[i] - '0';\n        b += sb[i] - '0';\n    }\n    for (int i = 0; i < m; i++)\n    {\n        c += sc[i] - '0';\n        d += sd[i] - '0';\n    }\n\n    if (a == 0 && b == 0 && c == 0 && d == 0)\n    {\n        printf(\"1\\n\");\n        exit(0);\n    }\n\n    int _c = 0, _d = 0;\n\n    int ans = 0;\n    int sumDown = 0;\n    for (int i = m - 1; i >= 0; i--)\n    {\n        if (sc[i] == '0' && sd[i] == '0') continue;\n\n        c -= (sc[i] - '0');\n        d -= (sd[i] - '0');\n\n        eprintf(\"b = %d, _c = %d, _d = %d\\n\", b, _c, _d);\n        sadd(sumDown, solve(b, _c, _d) );\n        if (sc[i] == '1' && sd[i] == '1')\n            smul(sumDown, 2);\n\n        _c += (sc[i] - '0');\n        _d += (sd[i] - '0');\n    \n        int cur = solve(a, c, d);\n        eprintf(\"%d) up = %d, sumDown = %d\\n\", i, cur, sumDown);\n        \n        smul(cur, sumDown);\n\n        sadd(ans, cur);\n    }\n    return ans;\n}\n\n\nvoid init()\n{\n    fact[0] = 1;\n    rfact[0] = 1;\n    ri[1] = 1;\n\n    for (int i = 1; i < N; i++)\n    {\n        if (i >= 2) ri[i] = MOD - mul(ri[MOD % i], MOD / i);\n        fact[i] = mul(fact[i - 1], i);\n        rfact[i] = mul(rfact[i - 1], ri[i] );\n\n        if (mul(i, ri[i] ) != 1) throw;\n    }\n}\n\n\nchar a[N], b[N], c[N], d[N];\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s%s%s%s\", a, b, c, d);\n\n    int ans = 0;\n    sadd(ans, solve(n, m, a, b, c, d) );\n    sadd(ans, solve(m, n, c, d, a, b) );\n    printf(\"%d\\n\", ans);\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=400005,mod=998244353;\nint fac[N],rev[N],f[N],pre[N],t[N],p2[N],ip2[N],n,m,ans,emp=1;\nchar A[N],B[N],C[N],D[N];\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1)res=(ll)res*x%mod;\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;\n\trep(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\trev[n]=power(fac[n],mod-2);\n\tper(i,n,1) rev[i-1]=(ll)rev[i]*i%mod;\n\tp2[0]=1,ip2[0]=1;\n\trep(i,1,n) p2[i]=2*p2[i-1]%mod;\n\trep(i,1,n) ip2[i]=(ll)(mod/2+1)*ip2[i-1]%mod;\n}\nint Co(int n,int m){\n\treturn m<0||m>n?0:(ll)fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\n\nvoid solve(int n,int m){\n\tint ca=0,cb=0;\n\trep(i,1,n) ca+=A[i]-'0',cb+=B[i]-'0';\n\trep(i,1,m) t[i]=t[i-1]+(C[i]=='1'&&D[i]=='1');\n\tint cnt=0;\n\trep(i,1,m){\n\t\tcnt+=(C[i-1]=='1')+(D[i-1]=='1');\n\t\tpre[i]=pre[i-1];\n\t\tif(C[i]=='1'||D[i]=='1'){\n\t\t\tf[i]=(ca==0?cnt==0:Co(ca+cnt-1,ca-1))*(1+t[i]-t[i-1])%mod;\n\t\t\tpre[i]=(pre[i]+(ll)f[i]*ip2[t[i]])%mod;\n\t\t}\n\t}\n\tcnt=0;\n\tper(i,m,1){\n\t\tcnt+=(C[i+1]=='1')+(D[i+1]=='1');\n\t\tif(C[i]=='1'||D[i]=='1'){\n\t\t\tint owo=(cb==0?cnt==0:Co(cb+cnt-1,cb-1)); \n\t\t\tans=(ans+(ll)owo*f[i])%mod;\n\t\t\tans=(ans+(ll)owo*pre[i-1]%mod*p2[t[i]])%mod;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit(400000);\n\tread(n),read(m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\trep(i,1,n) emp&=(A[i]=='0'&&B[i]=='0');\n\trep(i,1,m) emp&=(C[i]=='0'&&D[i]=='0');\n\tif(emp) return puts(\"1\"),0;\n\tsolve(n,m);\n\tswap(A,C),swap(B,D);\n\tsolve(m,n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nvector<int> ipow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(b==0) return 1;\n\tif(a<b) return 0;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear(); ipow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tipow2.resize(_n+1);\n\tpow2[0]=ipow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\tipow2[i]=inverse(pow2[i]);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint l[111111];\nint r[111111];\nint u[111111];\nint d[111111];\nint prefL[111111];\nint prefR[111111];\nint prefU[111111];\nint prefD[111111];\nint prefUD[111111];\n\nint sumL(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefL[r];\n\telse return add(prefL[r],MOD-prefL[l-1]);\n}\n\nint sumR(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefR[r];\n\telse return add(prefR[r],MOD-prefR[l-1]);\n}\n\nint sumU(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefU[r];\n\telse return add(prefU[r],MOD-prefU[l-1]);\n}\n\nint sumD(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefD[r];\n\telse return add(prefD[r],MOD-prefD[l-1]);\n}\n\nint sumUD(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefUD[r];\n\telse return add(prefUD[r],MOD-prefUD[l-1]);\n}\n\nint solve(int r, int c)\n{\n\treturn choose(r+c-1,r);\n}\n\nvoid calcL(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefL[i]=(s[i]=='1');\n\t\tif(i>0) prefL[i]+=prefL[i-1];\n\t}\n}\n\nvoid calcR(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefR[i]=(s[i]=='1');\n\t\tif(i>0) prefR[i]+=prefR[i-1];\n\t}\n}\n\nvoid calcU(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefU[i]=(s[i]=='1');\n\t\tif(i>0) prefU[i]+=prefU[i-1];\n\t}\n}\n\nvoid calcD(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefD[i]=(s[i]=='1');\n\t\tif(i>0) prefD[i]+=prefD[i-1];\n\t}\n}\n\nvoid calcUD(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefUD[i]=(s[i]=='1');\n\t\tif(i>0) prefUD[i]+=prefUD[i-1];\n\t}\n}\n\nint dpl[222222];\nint dpr[222222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(233333);\n\tint n,m; cin>>n>>m;\n\tstring L,R,U,D;\n\tcin>>L;\n\tcin>>R;\n\tcin>>U;\n\tcin>>D;\n\tstring sud;\n\tfor(int i=0;i<U.length();i++) sud+=char('0'+((U[i]-'0')&(D[i]-'0')));\n\tcalcL(L); calcR(R); calcU(U); calcD(D); calcUD(sud);\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint ltot=sumL(0,n-1);\n\t\tint c1=sumU(0,l-1);\n\t\tint c2=sumD(0,l-1);\n\t\tif(l==0) dpl[l]=1;\n\t\telse dpl[l]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tint ltot=sumR(0,n-1);\n\t\tint c1=sumU(r+1,m-1);\n\t\tint c2=sumD(r+1,m-1);\n\t\tif(r==m-1) dpr[r]=1;\n\t\telse dpr[r]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tint ans=0;\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint r=l;\n\t\tint coeff = mult(pow2[sumUD(l+1,r-1)],((U[l]=='1')+(D[l]=='1'))*(l==r?1:((U[r]=='1')+(D[r]=='1'))));\n\t\tif(coeff==0) continue;\n\t\tint res1=dpl[l];\n\t\tint res2=dpr[r];\n\t\tans=add(ans,mult(coeff,mult(res1,res2)));\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tdpl[l]=mult(dpl[l],ipow2[prefUD[l]]);\n\t\tdpl[l]=mult(dpl[l],(U[l]=='1')+(D[l]=='1'));\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tdpr[r]=mult(dpr[r],pow2[(r>0?prefUD[r-1]:0)]);\n\t\tdpr[r]=mult(dpr[r],(U[r]=='1')+(D[r]=='1'));\n\t}\n\tint sum=0;\n\tfor(int l=0;l+1<m;l++)\n\t{\n\t\t//solve for all r>l\n\t\tsum=add(sum,dpl[l]);\n\t\tans=add(ans,mult(sum,dpr[l+1]));\n\t}\n\tswap(U,L); swap(R,D); swap(n,m);\n\tsud=\"\";\n\tfor(int i=0;i<U.length();i++) sud+=char('0'+((U[i]-'0')&(D[i]-'0')));\n\tcalcL(L); calcR(R); calcU(U); calcD(D); calcUD(sud);\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint ltot=sumL(0,n-1);\n\t\tint c1=sumU(0,l-1);\n\t\tint c2=sumD(0,l-1);\n\t\tif(l==0) dpl[l]=1;\n\t\telse dpl[l]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tint ltot=sumR(0,n-1);\n\t\tint c1=sumU(r+1,m-1);\n\t\tint c2=sumD(r+1,m-1);\n\t\tif(r==m-1) dpr[r]=1;\n\t\telse dpr[r]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint r=l;\n\t\tint coeff = mult(pow2[sumUD(l+1,r-1)],((U[l]=='1')+(D[l]=='1'))*(l==r?1:((U[r]=='1')+(D[r]=='1'))));\n\t\tif(coeff==0) continue;\n\t\tint res1=dpl[l];\n\t\tint res2=dpr[r];\n\t\tans=add(ans,mult(coeff,mult(res1,res2)));\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tdpl[l]=mult(dpl[l],ipow2[prefUD[l]]);\n\t\tdpl[l]=mult(dpl[l],(U[l]=='1')+(D[l]=='1'));\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tdpr[r]=mult(dpr[r],pow2[(r>0?prefUD[r-1]:0)]);\n\t\tdpr[r]=mult(dpr[r],(U[r]=='1')+(D[r]=='1'));\n\t}\n\tsum=0;\n\tfor(int l=0;l+1<m;l++)\n\t{\n\t\t//solve for all r>l\n\t\tsum=add(sum,dpl[l]);\n\t\tans=add(ans,mult(sum,dpr[l+1]));\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpre=(pre+val)%p;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tbool died=true;\n\tfor(int i=1;i<=n;++i)\n\t\tif(A[i]=='1' or B[i]=='1' or C[i]=='1' or D[i]=='1')\n\t\t\t{died=false;break;}\n\tif(died){puts(\"1\");return 0;}\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define I inline\n#define fi first\n#define se second\n#define R register\n#define LL long long\n#define mp make_pair\n#define reg register int\n#define pii pair<int,int>\n#define fo(i, a, b) for(reg i = a; i <= b; i++)\n#define fd(i, a, b) for(reg i = a; i >= b; i--)\n#define cr const reg&\nusing namespace std;\nconst int N = 4e5 + 1, mod = 998244353;\n\nI int _max(cr x, cr y) {return x > y ? x : y;}\nI int _min(cr x, cr y) {return x < y ? x : y;}\nI int read() {\n\treg x = 0, f = 1; char ch = getchar();\n\twhile(ch < '0' || ch > '9') {if(ch == '-') f = -1; ch = getchar();}\n\twhile(ch >= '0' && ch <= '9') x = (x << 3) + (x << 1) + (ch ^ 48), ch = getchar();\n\treturn x * f;\n}\nI void ptt(LL x) {if(x >= 10) ptt(x / 10); putchar(x % 10 + '0');}\nI void put(LL x) {x < 0 ? putchar('-'), ptt(-x) : ptt(x);}\nI void pr1(LL x) {put(x), putchar(' ');}\nI void pr2(LL x) {put(x), puts(\"\");}\n\nI int pow_mod(reg a, reg k) {reg ans = 1; for(; k; k >>= 1, a = (LL)a * a % mod) if(k & 1) ans = (LL)ans * a % mod; return ans;}\n\nchar s1[N], s2[N], s3[N], s4[N];\nint s[N], jc[N], inv[N];\n\nI int C(cr n, cr m) {\n\tif(n == m) return 1;\n\tif(n < 0 || m < 0) return 0;\n\treturn (LL)jc[n] * inv[m] % mod * inv[n - m] % mod;\n}\n\nI int solve(cr n, cr m) {\n\tfo(i, 1, m) {\n\t\treg t = 0;\n\t\tif(s3[i] == '1') t++;\n\t\tif(s4[i] == '1') t++;\n\t\ts[i] = s[i - 1] + t;\n\t} reg u1 = 0, u2 = 0;\n\tfo(i, 1, n) u1 += s1[i] == '1', u2 += s2[i] == '1';\n\treg ans = 0, sum = 0;\n\tfo(i, 1, m) {\n\t\treg t = 0;\n\t\tif(s3[i] == '1') t++;\n\t\tif(s4[i] == '1') t++;\n\t\tif(!t) continue;\n\t\tans = (ans + (LL)t * C(u1 + s[i - 1] - 1, u1 - 1) * C(u2 + s[m] - s[i] - 1, u2 - 1)) % mod;\n\t\tans = (ans + (LL)t * sum * C(u2 + s[m] - s[i] - 1, u2 - 1)) % mod;\n\t\tsum = (LL)t * (sum + C(u1 + s[i - 1] - 1, u1 - 1)) % mod;\n\t} return ans;\n}\n\nint main() {\n\treg n = read(), m = read();\n\tscanf(\"%s%s%s%s\", s1 + 1, s2 + 1, s3 + 1, s4 + 1);\n\treg L = n * 2 + 2 * m;\n\tjc[0] = 1; fo(i, 1, L) jc[i] = (LL)jc[i - 1] * i % mod;\n\tinv[L] = pow_mod(jc[L], mod - 2); fd(i, L, 1) inv[i - 1] = (LL)inv[i] * i % mod;\n\treg ans = solve(n, m);\n\tswap(s1, s3), swap(s2, s4);\n\tans = (ans + solve(m, n)) % mod;\n\tpr2(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool flag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') flag = true;\n\t}\n\tif(!flag) swap(l, u), swap(r, d), swap(h, w);\n\t\n\tflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') flag = true;\n\t}\n\tif(!flag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = 998244353;\nconst int maxn = 500100;\nll fac[maxn];\nll invfac[maxn];\nint n, m;\nstring stra, strb, strc, strd;\nll ans = 0;\n\nll c(int a, int b) {\n\tif (b > a || b < 0 || a < 0) return 0;\n\treturn fac[a] * invfac[b] % mod * invfac[a - b] % mod;\n}\n\nint cnt1(const string &str) {\n\tint a = 0;\n\tfor (int i = 0; i < (int)str.length(); i++) {\n\t\ta += str[i] == '1';\n\t}\n\treturn a;\n}\n\nvoid solve() {\n\tll rsum = 1;\n\tll la = cnt1(stra), lb = cnt1(strb), ora = la, orb = lb, lc = cnt1(strc), ld = cnt1(strd);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (stra[i] != '1' && strb[i] != '1') {\n\t\t\tcontinue;\n\t\t}\n\t\tll mul = 1;\n \t\tif (stra[i] == '1' && strb[i] == '1') {\n \t\t\tmul++;\n \t\t}\n \t\tla -= stra[i] == '1', lb -= strb[i] == '1';\n \t\trsum = rsum * mul % mod;\n \t\tans += rsum * (i == 0 ? 1 : c(la + lb + lc - 1, lc - 1));\n \t\tans %= mod;\n \t\trsum += c(ora - la + orb - lb + ld - 1, ld - 1);\n \t\trsum %= mod;\n\t}\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxn; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t}\n\tinvfac[maxn - 1] = pow(fac[maxn - 1], mod - 2, mod);\n\tfor (int i = maxn - 2; i >= 0; i--) {\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % mod;\n\t}\n\tcin >> n >> m >> stra >> strb >> strc >> strd;\n\tsolve();\n\tswap(n, m);\n\tswap(stra, strc);\n\tswap(strb, strd);\n\tsolve();\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M;\nchar A[101010], B[101010], C[101010], D[101010];\n\ni64 fact[404040], facti[404040];\n\ni64 modpow(i64 a, int p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2 == 1) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n\ni64 Comb(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fact[a] * facti[b] % MOD * facti[a - b] % MOD;\n}\n\ni64 lfs[101010], rgs[101010];\n\nint cone(char* s, char* t)\n{\n\tint ret = 0;\n\twhile (s != t) {\n\t\tif (*s == '1') ++ret;\n\t\t++s;\n\t}\n\treturn ret;\n}\n\ni64 solve(int N, int M, char* A, char* B, char* C, char* D)\n{\n\tint ca = cone(A, A + N);\n\tint cb = cone(B, B + N);\n\n\tif (ca + cb == 0) {\n\t\ti64 ret = 1;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint c = (C[i] - '0') + (D[i] - '0');\n\t\t\tret = ret * max(c, 1) % MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint a, x, y;\n\n\t// compute lfs\n\ta = ca;\n\tx = y = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (a == 0) {\n\t\t\tlfs[i] = ((x + y == 0) ? 1 : 0);\n\t\t} else {\n\t\t\tlfs[i] = Comb(a - 1 + x + y, a - 1);\n\t\t}\n\t\tif (C[i] == '1') ++x;\n\t\tif (D[i] == '1') ++y;\n\t}\n\n\t// compute rgs\n\ta = cb;\n\tx = y = 0;\n\tfor (int i = M - 1; i >= 0; --i) {\n\t\tif (a == 0) {\n\t\t\trgs[i] = ((x + y == 0) ? 1 : 0);\n\t\t} else {\n\t\t\trgs[i] = Comb(a - 1 + x + y, a - 1);\n\t\t}\n\t\t//printf(\"%d: %lld %lld %lld %lld\\n\", i, lfs[i], rgs[i], ca, cb);\n\t\tif (C[i] == '1') ++x;\n\t\tif (D[i] == '1') ++y;\n\t}\n\n\ti64 ret = 0;\n\ti64 tmp = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint ct = (C[i] - '0') + (D[i] - '0');\n\t\tif (ct == 0) continue;\n\n\t\tADD(tmp, lfs[i]);\n\t\ttmp = tmp * ct % MOD;\n\t\tADD(ret, tmp * rgs[i]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tfact[0] = facti[0] = 1;\n\tfor (int i = 1; i <= 400000; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfacti[i] = modpow(fact[i]);\n\t}\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s%s%s%s\", A, B, C, D);\n\n\tif (cone(A, A + N) + cone(B, B + N) + cone(C, C + N) + cone(D, D + N) == 0) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\ti64 ret = 0;\n\tADD(ret, solve(N, M, A, B, C, D));\n\tADD(ret, solve(M, N, C, D, A, B));\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=998244353;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nll fac[500111],ifac[500111];\nll kissme(ll x,ll k){return k==0?1:kissme(x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n,m;\nchar sa[100111],sb[100111],sc[100111],sd[100111];\nll pre[100111],suf[100111],pre2[100111];\nll C(ll x,ll y){return x<y?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tint cntc=0;\n\tint cntd=0;\n\tfor(int i=1;i<=m;i++)cntc+=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)cntd+=sd[i]=='1';\n\tint cnta=0,cntb=0;;\n\tpre[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntc==0)pre[i]=1;\n\t\telse pre[i]=C(cntc+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n\tcnta=cntb=0;\n\tsuf[n+1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntd==0)suf[i]=1;\n\t\telse suf[i]=C(cntd+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n//\tfor(int i=0;i<=n+1;i++)cerr<<pre[i]<<\" \";cerr<<endl;\n//\tfor(int i=0;i<=n+1;i++)cerr<<suf[i]<<\" \";cerr<<endl;\n\t\n\tll ret=0;\n\tmemset(pre2,0,sizeof(pre2));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(sa[i]-'0'+sb[i]-'0'==1)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse if(sa[i]-'0'+sb[i]-'0'==2)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])*2%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse pre2[i]=pre2[i-1];\n\t}\n\treturn ret%mod;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=500005;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[500005]=kissme(fac[500005],mod-2);\n\tfor(int i=500004;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",sa+1);\n\tscanf(\"%s\",sb+1);\n\tscanf(\"%s\",sc+1);\n\tscanf(\"%s\",sd+1);\n\tbool ok=0;\n\tfor(int i=1;i<=n;i++)ok|=sa[i]=='1';\n\tfor(int i=1;i<=n;i++)ok|=sb[i]=='1';\n\tfor(int i=1;i<=m;i++)ok|=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)ok|=sd[i]=='1';\n\t\n\tll ans=0;\n\tans+=solve();\n\tswap(sa,sc);\n\tswap(sb,sd);\n\tswap(n,m);\n\tans+=solve();\n\tif(!ok)ans++;\n\tcout<<ans%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\n\nconst int M=1000005,mod=998244353;\nll F[M];\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\nll Div(ll n,ll m){return n*Pow(m,mod-2)%mod;}\nll nCk(ll n,ll k){\n\tif(n<0) return 1;\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nstring A,B,C,D;\n\nbool Check(string s){\n\tint N=s.size();\n\treturn s==string(N,'0');\n}\n\nvl ff(){\n\tvl a(m+1);\n\ta[0]++;\n\tif(Check(A)){\n\t\tfor(int i=0;i<m&&C[i]=='0'&&D[i]=='0';i++) a[i+1]++;\n\t}\n\telse{\n\t\tint S=0,t=0;\n\t\tfor(int i=0;i<n;i++) S+=A[i]-'0';\n\t\tfor(int i=0;i<m;i++){\n\t\t\tt+=C[i]-'0'+D[i]-'0';\n\t\t\ta[i+1]=nCk(S+t-1,t);\n\t\t}\n\t}\n\tswap(A,B);reverse(C.begin(),C.end());reverse(D.begin(),D.end());\n\treturn a;\n}\n\nll f(){\n\tll res=0,t=0;\n\tvl a=ff(),b=ff();\n\tfor(int i=0;i<m;i++) if(C[i]=='1'||D[i]=='1'){\n\t\tt=(C[i]-'0'+D[i]-'0')*(a[i]+t)%mod;\n\t\t(res+=t*b[m-1-i])%=mod;\n\t}\n\tswap(A,C);swap(B,D);swap(n,m);\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m>>A>>B>>C>>D;\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n\tif(Check(A)&&Check(B)&&Check(C)&&Check(D)) cout<<1<<endl;\n\telse cout<<(f()+f())%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint H,W;\nstring A,B,C,D;\nll mo=998244353;\n\nll combi(ll N_, ll C_) {\n\tconst int NUM_=400001;\n\tstatic ll fact[NUM_+1],factr[NUM_+1],inv[NUM_+1];\n\tif (fact[0]==0) {\n\t\tinv[1]=fact[0]=factr[0]=1;\n\t\tfor (int i=2;i<=NUM_;++i) inv[i] = inv[mo % i] * (mo - mo / i) % mo;\n\t\tfor (int i=1;i<=NUM_;++i) fact[i]=fact[i-1]*i%mo, factr[i]=factr[i-1]*inv[i]%mo;\n\t}\n\tif(C_<0 || C_>N_) return 0;\n\treturn factr[C_]*fact[N_]%mo*factr[N_-C_]%mo;\n}\n\nll modpow(ll a, ll n=mo-2) {\n\tll r=1;\n\twhile(n) r=r*((n%2)?a:1)%mo,a=a*a%mo,n>>=1;\n\treturn r;\n}\n\nll L[101010],R[101010],P[101010],RS[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>H>>W>>A>>B>>C>>D;\n\tFORR(c,A) c-='0';\n\tFORR(c,B) c-='0';\n\tFORR(c,C) c-='0';\n\tFORR(c,D) c-='0';\n\ts=A+B+C+D;\n\t\n\tif(count(ALL(s),1)==0) return _P(\"1\\n\");\n\tll ret=0;\n\tFOR(i,2) {\n\t\tZERO(L);\n\t\tZERO(R);\n\t\tZERO(P);\n\t\tZERO(RS);\n\t\t\n\t\tint NL=count(ALL(A),1);\n\t\tint NR=count(ALL(B),1);\n\t\tint NT=0,NB=0;\n\t\tP[0]=1;\n\t\tFOR(x,W) {\n\t\t\tif(C[x]==0 && D[x]==0) {\n\t\t\t\tL[x+1]=0;\n\t\t\t}\n\t\t\telse if(NL==0) {\n\t\t\t\tif(NT+NB==0) L[x+1]=1;\n\t\t\t\telse L[x+1]=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL[x+1] = combi(NT+NB+NL-1,NL-1);\n\t\t\t}\n\t\t\tP[x+1]=P[x];\n\t\t\tif(C[x]&&D[x]) P[x+1]=2*P[x]%mo;\n\t\t\tNT+=C[x];\n\t\t\tNB+=D[x];\n\t\t}\n\t\tNT=0,NB=0;\n\t\tfor(x=W-1;x>=0;x--) {\n\t\t\tif(C[x]==0 && D[x]==0) {\n\t\t\t\tR[x+1]=0;\n\t\t\t}\n\t\t\telse if(NR==0) {\n\t\t\t\tif(NT+NB==0) R[x+1]=1;\n\t\t\t\telse R[x+1]=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR[x+1] = combi(NT+NB+NR-1,NR-1);\n\t\t\t}\n\t\t\t(R[x+1]*=P[x+1])%=mo;\n\t\t\t(RS[x+1]=RS[x+2]+R[x+1])%=mo;\n\t\t\t\n\t\t\t(ret += (C[x]+D[x])*L[x+1]*RS[x+1]%mo*modpow(P[x+1]))%=mo;\n\t\t\t\n\t\t\tNT+=C[x];\n\t\t\tNB+=D[x];\n\t\t}\n\t\t\n\t\t\n\t\tswap(H,W);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpre=(pre+val)%p;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tbool died=true;\n\tfor(int i=1;i<=n;++i)\n\t\tif(A[i]=='1' or B[i]=='1' or C[i]=='1' or D[i]=='1')\n\t\t\t{died=false;break;}\n\tif(died){puts(\"1\");return 0;}\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,cnt=0;\nint pre[350007],inv[350007];\nchar a[Maxn],b[Maxn],c[Maxn],d[Maxn];\nbool x[Maxn],y[Maxn],z[Maxn],w[Maxn];\nlong long power(long long a,long long b)\n{\n\tlong long res=1,now=a,left=b;\n\twhile (left>0)\n\t{\n\t\tif (left%2==1) res=(1LL*res*now)%modp;\n\t\tnow=(1LL*now*now)%modp;\n\t\tleft/=2;\n\t}\n\treturn res%modp;\n}\nint calc(int x,int y)\n{\n\tif (x<y) return 0;\n\tint res=(1LL*pre[x]*inv[y])%modp;\n\tres=(1LL*res*inv[x-y])%modp;\n\treturn res;\n}\nint get(int a,int b,int c)\n{\n\tif (a==0&&b==0&&c==0) return 1;\n\telse if (b==0) return 0;\n\telse return calc(a+b+c-1,b-1);\n}\nint solve()\n{\n\tint cnt1=0,cnt2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (x[i]) ++cnt1;\n\t\tif (y[i]) ++cnt2;\n\t}\n\tint tot1=0,tot2=0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (z[i]) ++tot1;\n\t\tif (w[i]) ++tot2;\n\t}\n\tint res=0,del=0;\n\tint p=0,q=0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (z[i]==false&&w[i]==false) continue;\n\t\tdel=(del+get(p,cnt1,q))%modp;\n\t\tif (z[i]&&w[i]) del=(2LL*del)%modp;\n\t\tif (z[i]) ++q,--tot1;\n\t\tif (w[i]) ++p,--tot2;\n\t\tres=(res+1LL*del*get(tot1,cnt2,tot2)%modp)%modp;\n\t}\n\treturn res%modp;\n}\nint main()\n{\n\tn=read(),m=read();\n\tpre[0]=1;\n\tfor (int i=1;i<=350000;i++)\n\t\tpre[i]=(1LL*pre[i-1]*i)%modp;\n\tinv[350000]=power(pre[350000],modp-2)%modp;\n\tfor (int i=350000;i;i--)\n\t\tinv[i-1]=(1LL*inv[i]*i)%modp;\n\tscanf(\"%s\",a);\n\tscanf(\"%s\",b);\n\tscanf(\"%s\",c);\n\tscanf(\"%s\",d);\n\tmemset(x,false,sizeof(x));\n\tmemset(y,false,sizeof(y));\n\tmemset(z,false,sizeof(z));\n\tmemset(w,false,sizeof(w));\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tif (a[i]=='0') x[i+1]=false; else x[i+1]=true;\n\t\tif (b[i]=='0') y[i+1]=false; else y[i+1]=true;\n\t\tif (x[i+1]) ++cnt;\n\t\tif (y[i+1]) ++cnt;\n\t}\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (c[i]=='0') z[i+1]=false; else z[i+1]=true;\n\t\tif (d[i]=='0') w[i+1]=false; else w[i+1]=true;\n\t\tif (z[i+1]) ++cnt;\n\t\tif (w[i+1]) ++cnt;\n\t}\n\tif (cnt==0)\n\t{\n\t\tprintf(\"%d\\n\",0);\n\t\treturn 0;\n\t}\n\tint ans=solve()%modp;\n\tswap(x,z);\n\tswap(y,w);\n\tswap(n,m);\n\tans=(ans+solve())%modp;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\ntypedef long long llong;\ntypedef long double ld;\ntypedef unsigned long long ull;\n\nusing namespace std;\n\nconst ll MOD = 998244353;\nll pw(ll a, ll b) {\n\tll ans = 1; while (b) {\n\t\twhile (!(b & 1)) b >>= 1, a = (a * a) % MOD;\n\t\tans = (ans * a) % MOD, --b;\n\t} return ans;\n}\nconst int MX = 360000;\n\nint n, m;\nstring a, b, c, d;\n\nll fc[MX];\nll bfc[MX];\n\nll cnk(int n, int k) {\n\tif (n < k)\n\t\treturn 0;\n\treturn fc[n] * bfc[n - k] % MOD * bfc[k] % MOD;\n}\n\nll get(int a, int b, int c) {\n\tif (b == 0) {\n\t\tif (a == 0 && c == 0)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\treturn cnk(a + b + c - 1, a + c);\n}\n\nll solve() {\n\tll sum = 0;\n\tint cl = 0;\n\tint cr = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (a[i] == '1')\n\t\t\t++cl;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (b[i] == '1')\n\t\t\t++cr;\n\tint cd2 = 0, cu2 = 0;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (c[i] == '1')\n\t\t\t++cu2;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (d[i] == '1')\n\t\t\t++cd2;\n\tint cd = 0, cu = 0;\n\tll ans = 0;\n\tfor (int i = 0; i < m; ++i) {\n\t\tif (c[i] == '0' && d[i] == '0')\n\t\t\tcontinue;\n\t\tsum = (sum + get(cd, cl, cu)) % MOD;\n\t\tif (c[i] == '1' && d[i] == '1')\n\t\t\tsum = (sum * 2) % MOD;\n\t\tif (c[i] == '1')\n\t\t\t++cu, --cu2;\n\t\tif (d[i] == '1')\n\t\t\t++cd, --cd2;\n\t\tans = (ans + sum * get(cu2, cr, cd2)) % MOD;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tfc[0] = bfc[0] = 1;\n\tfor (int i = 1; i < MX; ++i) {\n\t\tfc[i] = (fc[i - 1] * i) % MOD;\n\t\tbfc[i] = pw(fc[i], MOD - 2);\n\t}\n\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\tint fl = 0;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (a[i] == '1')\n\t\t\tfl = 1;\n\tfor (int i = 0; i < n; ++i)\n\t\tif (b[i] == '1')\n\t\t\tfl = 1;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (c[i] == '1')\n\t\t\tfl = 1;\n\tfor (int i = 0; i < m; ++i)\n\t\tif (d[i] == '1')\n\t\t\tfl = 1;\n\tif (!fl) {\n\t\tcout << 1 << \"\\n\";\n\t\treturn 0;\n\t}\n\tll ans = solve();\n\tswap(a, c);\n\tswap(b, d);\n\tswap(n, m);\n\tans = (ans + solve()) % MOD;\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 420000\n#define LL long long\n\nconst LL mod=998244353;\nLL n,m,ans,pw[N],f[N],g[N],fac[N],ifac[N];\nchar a[N],b[N],c[N],d[N];\nbool chk;\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nLL C(LL x,LL y){return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\n\nvoid solve(LL n,LL m,char a[],char b[],char c[],char d[]){\n\tmemset(f,0,sizeof f); memset(g,0,sizeof g);\n\tLL l=0,r=0,sum=0,sum2=0,cnt=0,cnt2=0,tmp;\n\tfor (LL i=1;i<=m;i++){\n\t\tif (c[i]=='1') l++;\n\t\tif (d[i]=='1') r++;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\tif (a[i]=='1') sum++;\n\t\tif (b[i]=='1') sum++;\n\t\tif (a[i]=='1' && b[i]=='1') sum2++;\n\t}\n\tif (a[1]=='1'||b[1]=='1') f[0]=1;\n\tif (a[n]=='1'||b[n]=='1') tmp=g[n+1]=pw[sum2];\n\tfor (LL i=1;i<=n;i++){\n\t\tif (i>1&&(a[i-1]=='1'||b[i-1]=='1')) g[i]=C(sum-cnt+r-1,r-1)*pw[cnt2]%mod;\n\t\ttmp=(tmp+g[i])%mod;\n\t\tif (a[i]=='1') cnt++;\n\t\tif (b[i]=='1') cnt++;\n\t\tif (a[i]=='1' && b[i]=='1') cnt2++;\n\t\tif (i<n&&(a[i+1]=='1'||b[i+1]=='1')) f[i]=C(cnt+l-1,l-1)*inv(pw[cnt2])%mod;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\ttmp=(tmp-g[i]+mod)%mod;\n\t\tans=(ans+f[i-1]*tmp)%mod;\n\t}\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s%s%s%s\",a+1,b+1,c+1,d+1);\n\tfor (int i=1;i<=n;i++) chk|=(a[i]=='1')|(b[i]=='1');\n\tfor (int i=1;i<=m;i++) chk|=(c[i]=='1')|(d[i]=='1');\n\tif (!chk){puts(\"1\"); return 0;}\n\tpw[0]=1; for (LL i=1;i<=n*4;i++) pw[i]=pw[i-1]*2%mod;\n\tfac[0]=1; for (LL i=1;i<=n*4;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[n*4]=inv(fac[n*4]); for (LL i=n*4-1;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tsolve(n,m,a,b,c,d);\n\tsolve(m,n,c,d,a,b);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int mod = 998244353;\nconst int maxn = 500100;\nll fac[maxn];\nll invfac[maxn];\nint n, m;\nstring stra, strb, strc, strd;\nll ans = 0;\n\nll c(int a, int b) {\n\tif (a == b) return 1;\n\tif (b < 0) return 0;\n\tif (b > a) return 0;\n\treturn fac[a] * invfac[b] % mod * invfac[a - b] % mod;\n}\n\nint cnt1(const string &str) {\n\tint a = 0;\n\tfor (int i = 0; i < (int)str.length(); i++) {\n\t\ta += str[i] == '1';\n\t}\n\treturn a;\n}\n\nvoid solve() {\n\tll rsum = 1;\n\tll la = cnt1(stra), lb = cnt1(strb), ora = la, orb = lb, lc = cnt1(strc), ld = cnt1(strd);\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (stra[i] != '1' && strb[i] != '1') {\n\t\t\tcontinue;\n\t\t}\n\t\tll mul = 1;\n \t\tif (stra[i] == '1' && strb[i] == '1') {\n \t\t\tmul++;\n \t\t}\n \t\tla -= stra[i] == '1', lb -= strb[i] == '1';\n \t\trsum = rsum * mul % mod;\n \t\tans += rsum *  c(la + lb + lc - 1, lc - 1);\n \t\tans %= mod;\n \t\trsum += c(ora - la + orb - lb + ld - 1, ld - 1);\n \t\trsum %= mod;\n\t}\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tfac[0] = 1;\n\tfor (int i = 1; i < maxn; i++) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t}\n\tinvfac[maxn - 1] = pow(fac[maxn - 1], mod - 2, mod);\n\tfor (int i = maxn - 2; i >= 0; i--) {\n\t\tinvfac[i] = invfac[i + 1] * (i + 1) % mod;\n\t}\n\tcin >> n >> m >> stra >> strb >> strc >> strd;\n\tsolve();\n\tswap(n, m);\n\tswap(stra, strc);\n\tswap(strb, strd);\n\tsolve();\n\tif (cnt1(stra) + cnt1(strb) + cnt1(strc) + cnt1(strd) == 0) {\n\t\tans++;\n\t}\n\tcout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\nvector<int> fact;\nvector<int> ifact;\nvector<int> inv;\nvector<int> pow2;\nvector<int> ipow2;\nconst int MOD = 998244353;\nint add(int a, int b)\n{\n\ta+=b;\n\twhile(a>=MOD) a-=MOD;\n\treturn a;\n}\nint mult(int a, int b)\n{\n\treturn (a*1LL*b)%MOD;\n}\nint modpow(int a, int b)\n{\n\tint r=1;\n\twhile(b)\n\t{\n\t\tif(b&1) r=mult(r,a);\n\t\ta=mult(a,a);\n\t\tb>>=1;\n\t}\n\treturn r;\n}\nint choose(int a, int b)\n{\n\tif(b==0) return 1;\n\tif(a<b) return 0;\n\tif(a==b) return 1;\n\treturn mult(fact[a],mult(ifact[b],ifact[a-b]));\n}\nint inverse(int a)\n{\n\treturn modpow(a,MOD-2);\n}\nvoid init(int _n)\n{\n\tfact.clear(); ifact.clear(); inv.clear(); pow2.clear(); ipow2.clear();\n\tfact.resize(_n+1);\n\tifact.resize(_n+1);\n\tinv.resize(_n+1);\n\tpow2.resize(_n+1);\n\tipow2.resize(_n+1);\n\tpow2[0]=ipow2[0]=1;\n\tifact[0]=1;\n\tfact[0]=1;\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tpow2[i]=add(pow2[i-1],pow2[i-1]);\n\t\tfact[i]=mult(fact[i-1],i);\n\t\tipow2[i]=inverse(pow2[i]);\n\t\t//ifact[i]=mult(ifact[i-1],inv[i]);\n\t}\n\tifact[_n] = inverse(fact[_n]);\n\tfor(int i=_n-1;i>=1;i--)\n\t{\n\t\tifact[i] = mult(ifact[i + 1], i + 1);\n\t}\n\tfor(int i=1;i<=_n;i++)\n\t{\n\t\tinv[i] = mult(fact[i-1],ifact[i]);\n\t}\n}\n\nint l[111111];\nint r[111111];\nint u[111111];\nint d[111111];\nint prefL[111111];\nint prefR[111111];\nint prefU[111111];\nint prefD[111111];\nint prefUD[111111];\n\nint sumL(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefL[r];\n\telse return add(prefL[r],MOD-prefL[l-1]);\n}\n\nint sumR(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefR[r];\n\telse return add(prefR[r],MOD-prefR[l-1]);\n}\n\nint sumU(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefU[r];\n\telse return add(prefU[r],MOD-prefU[l-1]);\n}\n\nint sumD(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefD[r];\n\telse return add(prefD[r],MOD-prefD[l-1]);\n}\n\nint sumUD(int l, int r)\n{\n\tif(l>r) return 0;\n\tif(l==0) return prefUD[r];\n\telse return add(prefUD[r],MOD-prefUD[l-1]);\n}\n\nint solve(int r, int c)\n{\n\treturn choose(r+c-1,r);\n}\n\nvoid calcL(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefL[i]=(s[i]=='1');\n\t\tif(i>0) prefL[i]+=prefL[i-1];\n\t}\n}\n\nvoid calcR(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefR[i]=(s[i]=='1');\n\t\tif(i>0) prefR[i]+=prefR[i-1];\n\t}\n}\n\nvoid calcU(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefU[i]=(s[i]=='1');\n\t\tif(i>0) prefU[i]+=prefU[i-1];\n\t}\n}\n\nvoid calcD(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefD[i]=(s[i]=='1');\n\t\tif(i>0) prefD[i]+=prefD[i-1];\n\t}\n}\n\nvoid calcUD(string s)\n{\n\tfor(int i=0;i<s.length();i++)\n\t{\n\t\tprefUD[i]=(s[i]=='1');\n\t\tif(i>0) prefUD[i]+=prefUD[i-1];\n\t}\n}\n\nint dpl[222222];\nint dpr[222222];\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tinit(233333);\n\tint n,m; cin>>n>>m;\n\tstring L,R,U,D;\n\tcin>>L;\n\tcin>>R;\n\tcin>>U;\n\tcin>>D;\n\tstring sud;\n\tfor(int i=0;i<U.length();i++) sud+=char('0'+((U[i]-'0')&(D[i]-'0')));\n\tcalcL(L); calcR(R); calcU(U); calcD(D); calcUD(sud);\n\tif(sumL(0,n-1)==0&&sumR(0,n-1)==0&&sumU(0,m-1)==0&&sumD(0,m-1)==0){cout<<1<<'\\n'; return 0;}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint ltot=sumL(0,n-1);\n\t\tint c1=sumU(0,l-1);\n\t\tint c2=sumD(0,l-1);\n\t\tif(l==0) dpl[l]=1;\n\t\telse dpl[l]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tint ltot=sumR(0,n-1);\n\t\tint c1=sumU(r+1,m-1);\n\t\tint c2=sumD(r+1,m-1);\n\t\tif(r==m-1) dpr[r]=1;\n\t\telse dpr[r]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tint ans=0;\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint r=l;\n\t\tint coeff = mult(pow2[sumUD(l+1,r-1)],((U[l]=='1')+(D[l]=='1'))*(l==r?1:((U[r]=='1')+(D[r]=='1'))));\n\t\tif(coeff==0) continue;\n\t\tint res1=dpl[l];\n\t\tint res2=dpr[r];\n\t\tans=add(ans,mult(coeff,mult(res1,res2)));\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tdpl[l]=mult(dpl[l],ipow2[prefUD[l]]);\n\t\tdpl[l]=mult(dpl[l],(U[l]=='1')+(D[l]=='1'));\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tdpr[r]=mult(dpr[r],pow2[(r>0?prefUD[r-1]:0)]);\n\t\tdpr[r]=mult(dpr[r],(U[r]=='1')+(D[r]=='1'));\n\t}\n\tint sum=0;\n\tfor(int l=0;l+1<m;l++)\n\t{\n\t\t//solve for all r>l\n\t\tsum=add(sum,dpl[l]);\n\t\tans=add(ans,mult(sum,dpr[l+1]));\n\t}\n\tswap(U,L); swap(R,D); swap(n,m);\n\tsud=\"\";\n\tfor(int i=0;i<U.length();i++) sud+=char('0'+((U[i]-'0')&(D[i]-'0')));\n\tcalcL(L); calcR(R); calcU(U); calcD(D); calcUD(sud);\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint ltot=sumL(0,n-1);\n\t\tint c1=sumU(0,l-1);\n\t\tint c2=sumD(0,l-1);\n\t\tif(l==0) dpl[l]=1;\n\t\telse dpl[l]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tint ltot=sumR(0,n-1);\n\t\tint c1=sumU(r+1,m-1);\n\t\tint c2=sumD(r+1,m-1);\n\t\tif(r==m-1) dpr[r]=1;\n\t\telse dpr[r]=choose(c1+c2-1+ltot,c1+c2);\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tint r=l;\n\t\tint coeff = mult(pow2[sumUD(l+1,r-1)],((U[l]=='1')+(D[l]=='1'))*(l==r?1:((U[r]=='1')+(D[r]=='1'))));\n\t\tif(coeff==0) continue;\n\t\tint res1=dpl[l];\n\t\tint res2=dpr[r];\n\t\tans=add(ans,mult(coeff,mult(res1,res2)));\n\t}\n\tfor(int l=0;l<m;l++)\n\t{\n\t\tdpl[l]=mult(dpl[l],ipow2[prefUD[l]]);\n\t\tdpl[l]=mult(dpl[l],(U[l]=='1')+(D[l]=='1'));\n\t}\n\tfor(int r=0;r<m;r++)\n\t{\n\t\tdpr[r]=mult(dpr[r],pow2[(r>0?prefUD[r-1]:0)]);\n\t\tdpr[r]=mult(dpr[r],(U[r]=='1')+(D[r]=='1'));\n\t}\n\tsum=0;\n\tfor(int l=0;l+1<m;l++)\n\t{\n\t\t//solve for all r>l\n\t\tsum=add(sum,dpl[l]);\n\t\tans=add(ans,mult(sum,dpr[l+1]));\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int N = 800010;\n\nchar sa[N], sb[N], sc[N], sd[N];\nint fact[N], inv_fact[N];\nint ways_up[N], ways_down[N];\n\ninline int C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));\n}\n\nint main() {\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = mul(fact[i - 1], i);\n    inv_fact[i] = inv(fact[i]);\n  }\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%s\", sa);\n  scanf(\"%s\", sb);\n  scanf(\"%s\", sc);\n  scanf(\"%s\", sd);\n  vector<int> a(n), b(n), c(m), d(m);\n  for (int i = 0; i < n; i++) {\n    a[i] = sa[i] - '0';\n    b[i] = sb[i] - '0';\n  }\n  for (int i = 0; i < m; i++) {\n    c[i] = sc[i] - '0';\n    d[i] = sd[i] - '0';\n  }\n  int ans = 0;\n  for (int rot = 0; rot < 2; rot++) {\n    int sum_c = 0, sum_d = 0;\n    for (int p = 0; p < m; p++) {\n      sum_c += c[p];\n      sum_d += d[p];\n    }\n    int sum_up = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] + b[i] == 0) {\n        ways_up[i] = 0;\n      } else {\n        if (sum_c == 0 && sum_up > 0) {\n          ways_up[i] = 0;\n        } else {\n          ways_up[i] = (sum_c == 0 ? 1 : C(sum_c + sum_up - 1, sum_c - 1));\n        }\n        sum_up += a[i] + b[i];\n      }\n    }\n    int sum_down = 0;\n    for (int j = n - 1; j >= 0; j--) {\n      if (a[j] + b[j] == 0) {\n        ways_down[j] = 0;\n      } else {\n        if (sum_d == 0 && sum_down > 0) {\n          ways_down[j] = 0;\n        } else {\n          ways_down[j] = (sum_d == 0 ? 1 : C(sum_d + sum_down - 1, sum_d - 1));\n        }\n        sum_down += a[j] + b[j];\n      }\n    }\n    int sum_i = 0;\n    for (int j = 0; j < n; j++) {\n      add(sum_i, ways_up[j]);\n      sum_i = mul(sum_i, max(1, a[j] + b[j]));\n      add(ans, mul(sum_i, ways_down[j]));\n    }\n    swap(n, m);\n    swap(a, c);\n    swap(b, d);\n  }\n  int cnt_1 = 0;\n  for (int i = 0; i < n; i++) {\n    cnt_1 += a[i] + b[i];\n  }\n  for (int i = 0; i < m; i++) {\n    cnt_1 += c[i] + d[i];\n  }\n  if (cnt_1 == 0) {\n    ans = 1;\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890123456789LL\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) ((x < 0)?-(x):x)\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\ntypedef long long cat;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\ncat mod =998244353;\nvector<cat> fac, inv, inv_fac;\n\ncat pw(cat a, cat e) {\n\tif(e <= 0) return 1;\n\tcat x =pw(a,e/2);\n\tx =(x*x)%mod;\n\tif(e&1) return (x*a)%mod;\n\treturn x;\n}\n\ncat getC(int N, int K) {\n\tif(N < 0 || K < 0 || K > N) return 0;\n\tcat ret =(inv_fac[K]*inv_fac[N-K])%mod;\n\tret =(ret*fac[N])%mod;\n\treturn ret;\n}\n\ncat count(int up, int dn, int n) {\n\tif(n == 0) return (up+dn == 0);\n\treturn getC(up+dn+n-1,n-1);\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint MX =500010;\n\tfac.resize(MX,1);\n\tinv.resize(MX,1);\n\tinv_fac.resize(MX+1,1);\n\tfor(int i =1; i < MX; i++) {\n\t\tfac[i] =(i*fac[i-1])%mod;\n\t\tinv[i] =pw(i,mod-2);\n\t\tinv_fac[i] =(inv[i]*inv_fac[i-1])%mod;\n\t}\n\n\tint N,M;\n\tstring A,B,C,D;\n\tcin >> N >> M >> A >> B >> C >> D;\n\tcat ans =0;\n\tfor(int k =0; k < 2; k++) {\n\t\tswap(N,M);\n\t\tswap(A,C);\n\t\tswap(B,D);\n\n\t\tint nL =0, nR =0;\n\t\tfor(int i =0; i < M; i++) if(C[i] == '1') nL++;\n\t\tfor(int i =0; i < M; i++) if(D[i] == '1') nR++;\n\t\tvector<cat> cL(N,0), cR(N,0);\n\t\tint up =0, dn =0;\n\t\tfor(int i =0; i < N; i++) {\n\t\t\tcL[i] =count(up,dn,nL);\n\t\t\tif(A[i] == '1') up++;\n\t\t\tif(B[i] == '1') dn++;\n\t\t}\n\t\tup =dn =0;\n\t\tfor(int i =N-1; i >= 0; i--) {\n\t\t\tcR[i] =count(up,dn,nR);\n\t\t\tif(A[i] == '1') up++;\n\t\t\tif(B[i] == '1') dn++;\n\t\t}\n\n\t\tcat akt =0;\n\t\tfor(int i =N-1; i >= 0; i--) {\n\t\t\tif(A[i] == '1' || B[i] == '1') akt +=cR[i];\n\t\t\tif(A[i] == '1' && B[i] == '1') akt *=2;\n\t\t\tif(A[i] == '1' || B[i] == '1') ans =(ans+akt%mod*cL[i])%mod;\n\t\t}\n\n\t}\n\tans %=mod;\n\tif(ans < 0) ans +=mod;\n\tcout << ans << \"\\n\";\n\treturn 0;}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define llong long long\nusing namespace std;\n\nconst int N = 2e5;\nconst int P = 998244353;\nllong fact[N*4+3],finv[N*4+3];\nchar sa[N+3],sb[N+3],sc[N+3],sd[N+3];\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong comb(llong x,llong y) {return fact[x]*finv[y]%P*finv[x-y]%P;}\n\nllong solve(int n,int m,char s1[],char s2[],char s3[],char s4[])\n{\n\tint cnt1 = 0,cnt2 = 0,cnt3 = 0,cnt4 = 0,cur3 = 0,cur4 = 0;\n\tfor(int i=1; i<=n; i++) {cnt1 += s1[i]=='1',cnt2 += s2[i]=='1';}\n\tfor(int i=1; i<=m; i++) {cnt3 += s3[i]=='1',cnt4 += s4[i]=='1';}\n\tllong tmp = 1ll;\n\tllong ret = 0ll;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tcur3 += s3[i]=='1'; cur4 += s4[i]=='1';\n\t\tif(s3[i]=='1' || s4[i]=='1')\n\t\t{\n\t\t\tif(s3[i]=='1' && s4[i]=='1') {tmp = tmp*2ll%P;}\n\t\t\tif(cnt2!=0) {ret = (ret+tmp*comb(cnt3+cnt2+cnt4-cur3-cur4-1,cnt2-1))%P;}\n\t\t\telse {ret = (ret+tmp*(cnt3+cnt4-cur3-cur4==0))%P;}\n\t\t\tif(cnt1!=0) {tmp = (tmp+comb(cur3+cur4+cnt1-1,cnt1-1)%P);}\n\t\t\telse {tmp = (tmp+(cur3+cur4==0))%P;}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint n,m;\n\tfact[0] = 1ll;\n\tfor(int i=1; i<=N*4; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N*4] = quickpow(fact[N*4],P-2);\n\tfor(int i=N*4-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s%s%s%s\",sa+1,sb+1,sc+1,sd+1);\n\tbool gg = false;\n\tfor(int i=1; i<=n; i++) if(sa[i]=='1' || sb[i]=='1') gg = true;\n\tfor(int i=1; i<=m; i++) if(sc[i]=='1' || sd[i]=='1') gg = true; \n\tif(gg==false) {printf(\"1\"); return 0;}\n\tllong ans = 0ll;\n\tans += solve(n,m,sa,sb,sc,sd);\n\tans += solve(m,n,sc,sd,sa,sb);\n\tans %= P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define mod 998244353\n#define rep(i,x) for(int i=0;i<x;i++)\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[300005],R[300005],ans;\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<300005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<300005;i++) R[i] = modpow(F[i],mod-2);\n}\nll c(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\nll sol(int n,int m,string a,string b,string cc,string d){\n\tll zan = 0,ret = 0;\n\tint A = 0,B = 0,C = 0,D = 0;\n\trep(i,n) A+=a[i]-'0',B+=b[i]-'0';\n\trep(i,m) C+=cc[i]-'0',D+=d[i]-'0';\n\tint CC = 0,DD = 0;\n\tfor(int i=m-1;i>=0;i--){\n\t\tll add = 0;\n\t\tif(CC+DD == 0 && B == 0){\n\t\t\tadd = 1;\n\t\t}\n\t\telse if(B){\n\t\t\tadd = c(B-1+CC+DD,B-1);\n\t\t}\n\t\tint cnt = cc[i]-'0' + d[i]-'0';\n\t\tC -= cc[i]-'0'; D -= d[i]-'0';\n\t\tCC += cc[i]-'0'; DD += d[i]-'0';\n\t\tif(A){\n\t\t\tret += c(A-1+C+D,A-1) * ((add+zan)%mod) % mod * cnt % mod;\n\t\t}\n\t\telse if(C+D==0){\n\t\t\tret += ((add+zan)%mod) % mod * cnt % mod;\n\t\t}\n\t\tzan = add * cnt % mod + zan * max(1,cnt) % mod;\n\t}\n\treturn ret%mod;\n}\nint n,m,flag;\nstring a,b,cc,d;\nint main(){\n\tcin>>n>>m>>a>>b>>cc>>d;\n\trep(i,n) if(a[i]=='1'||b[i]=='1') flag=1;\n\trep(i,m) if(cc[i]=='1'||d[i]=='1') flag=1;\n\tif(!flag){\n\t    puts(\"1\");\n\t    return 0;\n\t}\n\tmake();\n\tans+=sol(n,m,a,b,cc,d);\n\tans+=sol(m,n,cc,d,a,b);\n\tcout<<ans%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint po(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) { return po(x, mod - 2); }\n\nint fact[400010], invf[400010];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    return comb(n + k - 1, k);\n}\n\nint N, M;\nstring A, B, C, D;\n\nvector<int> Col;\nvector<int> Ldp, Rdp, Rpsum, pmul;\n\nint solve() {\n    Col.clear();\n    for(int i = 0; i < M; i++) {\n        if(C[i] == '1' && D[i] == '1') Col.push_back(3);\n        else if(C[i] == '1') Col.push_back(1);\n        else if(D[i] == '1') Col.push_back(2);\n    }\n\n    if(Col.size() == 0) return 0;\n\n    int a = 0;\n    for(int i = 0; i < N; i++) if(A[i] == '1') a++;\n    int x = 0, y = 0;\n    Ldp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = 0; i < Col.size(); i++) {\n            if(x == 0 && y == 0) Ldp[i] = 1;\n            else Ldp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Ldp[0] = 1;\n\n    a = 0;\n    for(int i = 0; i < N; i++) if(B[i] == '1') a++;\n    x = 0, y = 0;\n    Rdp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = (int)Col.size() - 1; i >= 0; i--) {\n            if(x == 0 && y == 0) Rdp[i] = 1;\n            else Rdp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Rdp.back() = 1;\n\n    pmul = vector<int>(Col.size());\n    for(int i = 0; i < Col.size(); i++) {\n        pmul[i] = (Col[i] == 3? 2 : 1);\n        if(i) pmul[i] = 1LL * pmul[i] * pmul[i - 1] % mod;\n    }\n\n    Rpsum = vector<int>(Col.size());\n    for(int i = (int)Col.size() - 1; i >= 0; i--) {\n        Rpsum[i] = 1LL * Rdp[i] * pmul[i] % mod;\n        if(i != (int)Col.size() - 1) {\n            Rpsum[i] += Rpsum[i + 1];\n            Rpsum[i] %= mod;\n        }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < Col.size(); i++) {\n        ret += 1LL * Ldp[i] * (Col[i] == 3? 2 : 1) % mod * (Rdp[i] + 1LL * (i == Col.size() - 1? 0 : Rpsum[i + 1]) * inv(pmul[i]) % mod) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 400010; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 400010; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> M >> A >> B >> C >> D;\n\n    int ans = 0;\n    ans += solve();\n    ans %= mod;\n    swap(N, M);\n    swap(A, C);\n    swap(B, D);\n    ans += solve();\n    ans %= mod;\n\n    if(ans == 0) ans = 1;\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n ***\n Idea:\n */\n\n#include <memory.h>\n#include <ctime>\n#include <random>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<long> vl;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<long, long> ll;\n\nconst long MOD = 998244353;\n\nclass ModernPainting{\n    long X1, X2, M, nTwo;\n    string top,bot;\n    vl posi, nega, invs;\n    inline long mPlus(long x,long y){ return (x+y)%MOD; }\n    void refMPlus(long &x, long y){\n        x += y;\n        if(x >= MOD) x %= MOD;\n    }\n    inline double mTimes(long x,long y){ return (x*y)%MOD; }\n    void refMTimes(long &x,long y){\n        x *= y;\n        if(x >= MOD) x%=MOD;\n    }\n    long mPower(long n,long k){  // compute n^k (mod MOD)\n        long ans = 1;\n        while(k){\n            if(1&k) refMTimes(ans, n);\n            refMTimes(n, n);\n            k >>= 1;\n        }\n        return ans;\n    }\n    long mInverse(long n){\n        return mPower(n, MOD-2);\n    }\n    void init(){\n        assert(M>0);\n        posi = nega = vl(M+1, 1);\n        invs = vl(2*M+1, 1);\n        nTwo = 0;\n        for(int i=0;i<M;++i) if(top[i]==bot[i]) ++nTwo;\n        for(int i=2;i<=2*M;++i) invs[i] = mInverse(i);\n        if(X1){\n            long Y = 0, Z = 0;\n            for(int i=1;i<=M;++i){\n                long Y1 = Y + (top[i-1]=='1'), Z1 = Z + (bot[i-1]=='1');\n                if(top[i-1]==bot[i-1]){\n                    long fac = mTimes(mTimes(Y1+Z1+X1-1, Y1+Z1+X1-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    posi[i] = mTimes(posi[i-1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X1-1, invs[Y1+Z1]);\n                    posi[i] = mTimes(posi[i-1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        if(X2){\n            long Y = 0, Z = 0;\n            for(long i=M-1;i>=0;--i){\n                long Y1 = Y + (top[i]=='1'), Z1 = Z + (bot[i]=='1');\n                if(top[i]==bot[i]){\n                    long fac = mTimes(mTimes(Y1+Z1+X2-1, Y1+Z1+X2-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    nega[i] = mTimes(nega[i+1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X2-1, invs[Y1+Z1]);\n                    nega[i] = mTimes(nega[i+1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        for(long i=M-1;i>=0;--i) refMPlus(nega[i], nega[i+1]);\n    }\n    long compCnt(){\n        if(!X2) return (long)1;\n        if(!X1) return nega[1];\n        long ans = 0;\n        for(int i=0;i<M;++i) refMPlus(ans, mTimes(posi[i], nega[i+1]));\n        return ans;\n    }\npublic:\n    long solve(string t, string b,long x1, long x2){\n        X1 = x1;\n        X2 = x2;\n        if(X1>X2) swap(X1, X2);\n        top.clear();\n        bot.clear();\n        for(int i=0;i<(int)b.size();++i) if(b[i]=='1'||t[i]=='1'){\n            top += t[i];\n            bot += b[i];\n        }\n        M = (int)top.size();\n        if(!M) return (long)0;\n        init();\n        return mTimes(mPower(2, nTwo), compCnt());\n    }\n};\n\nint main(){\n    int n,m;\n    string A,B,C,D;\n    cin>>n>>m>>A>>B>>C>>D;\n    long X1 = 0, X2 = 0, ans = 0;\n    for(int i=0;i<m;++i){\n        X1 += (C[i] == '1');\n        X2 += (D[i] == '1');\n    }\n    ans += ModernPainting().solve(A, B, X1, X2);\n    X1 = X2 = 0;\n    for(int i=0;i<n;++i){\n        X1 += (A[i] == '1');\n        X2 += (B[i] == '1');\n    }\n    ans += ModernPainting().solve(C, D, X1, X2);\n    cout<<(ans%MOD)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N],inv[N];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\ninline void pls(int&A,int B){A=A+B<p?A+B:A+B-p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,all=0;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=1;i<=m;++i)r+=C[i]-'0'+D[i]-'0';\n\tint tmp=1,val;all=r;\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')tmp=2ll*tmp%p;\n\t\tval=Com(right+r-1,right-1);\n\t\tans=(ans+(ll)tmp*val)%p;\n\t\tval=Com(left+l-1,l);\n\t\tpls(tmp,val);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 420000\n#define LL long long\n\nconst LL mod=998244353;\nLL n,m,ans,pw[N],f[N],g[N],fac[N],ifac[N];\nchar a[N],b[N],c[N],d[N];\nbool chk;\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nLL C(LL x,LL y){if (y<0){if (x<0) return 1; return 0;} return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\n\nvoid solve(LL n,LL m,char a[],char b[],char c[],char d[]){\n\tmemset(f,0,sizeof f); memset(g,0,sizeof g);\n\tLL l=0,r=0,sum=0,sum2=0,cnt=0,cnt2=0,tmp=0;\n\tfor (LL i=1;i<=m;i++){\n\t\tif (c[i]=='1') l++;\n\t\tif (d[i]=='1') r++;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\tif (a[i]=='1') sum++;\n\t\tif (b[i]=='1') sum++;\n\t\tif (a[i]=='1' && b[i]=='1') sum2++;\n\t}\n\tif (a[1]=='1'||b[1]=='1') f[0]=1;\n\tif (a[n]=='1'||b[n]=='1') tmp=g[n+1]=pw[sum2];\n\tfor (LL i=1;i<=n;i++){\n\t\tif (i>1&&(a[i-1]=='1'||b[i-1]=='1')) g[i]=C(sum-cnt+r-1,r-1)*pw[cnt2]%mod;\n\t\ttmp=(tmp+g[i])%mod;\n\t\tif (a[i]=='1') cnt++;\n\t\tif (b[i]=='1') cnt++;\n\t\tif (a[i]=='1' && b[i]=='1') cnt2++;\n\t\tif (i<n&&(a[i+1]=='1'||b[i+1]=='1')) f[i]=C(cnt+l-1,l-1)*inv(pw[cnt2])%mod;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\ttmp=(tmp-g[i]+mod)%mod;\n\t\tans=(ans+f[i-1]*tmp)%mod;\n\t}\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s%s%s%s\",a+1,b+1,c+1,d+1);\n\tfor (int i=1;i<=n;i++) chk|=(a[i]=='1')|(b[i]=='1');\n\tfor (int i=1;i<=m;i++) chk|=(c[i]=='1')|(d[i]=='1');\n\tif (!chk){puts(\"1\"); return 0;}\n\tpw[0]=1; for (LL i=1;i<N;i++) pw[i]=pw[i-1]*2%mod;\n\tfac[0]=1; for (LL i=1;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[N-1]=inv(fac[N-1]); for (LL i=N-2;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tsolve(n,m,a,b,c,d);\n\tsolve(m,n,c,d,a,b);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint a[100011][2],b[100011][2];\nlong long MOD=998244353;\nlong long fa[200011];\nlong long invfa[200011];\nlong long two[200011];\n\n\nint p[100011];\nint ppos[100011];\nint q[100011];\nint sp[100011];\nint sa[100011][2];\n\n\nlong long exgcd(long long a,long long b,long long &x,long long &y)  \n{  \n    if(b==0)\n    {  \n        x=1;\n        y=0;\n        return a;\n    }\n    int r=exgcd(b,a%b,x,y);\n    long long t=y;\n    y=x-(a/b)*y;\n    x=t;\n    return r;\n}  \nlong long inv(long long a)  \n{  \n    long long x,y;  \n    long long r=exgcd(a,MOD,x,y);  \n    if(r==1) return (x%MOD+MOD)%MOD;  \n    return -1;  \n}\n\n\nlong long C(int n,int k)\n{\n    long long ans=fa[n]*invfa[k]%MOD*invfa[n-k]%MOD;\n    return ans;\n}\n\n\nlong long calc(long long x,long long y,long long z)\n{\n    if(x==0)\n    {\n        if(y==0 && z==0)return 1;\n        return 0;\n    }\n    \n    long long ans=(C(x+y+z,x)-C(x+y+z-1,x)+MOD)%MOD;\n    \n    \n    //cout<<\"calc\"<<' '<<x<<' '<<y<<' '<<z<<\"   \"<<ans<<endl;\n    \n    return ans;\n}\n\nlong long gao(int a[][2],int b[][2],int n,int m)\n{\n    int i,j,k;\n    int mm1,mm2;\n    mm1=mm2=0;\n    for(i=1;i<=m;i++)\n    {\n        mm1+=(b[i][0]==1);\n        mm2+=(b[i][1]==1);\n        \n        //cout<<b[i][0]<<' '<<b[i][1]<<endl;\n    }\n    \n    \n    \n    long long ans=0;\n    sa[0][0]=a[0][1]=0;\n    for(i=1;i<=n;i++)\n    {\n        sa[i][0]=sa[i-1][0]+a[i][0];\n        sa[i][1]=sa[i-1][1]+a[i][1];\n    }\n    \n    int nn=0;\n    for(i=1;i<=n;i++)\n    {\n        if(a[i][0]==1 && a[i][1]==1)\n        {\n            p[++nn]=2;\n            ppos[nn]=i;\n        }\n        else if(a[i][0]==1 || a[i][1]==1)\n        {\n            p[++nn]=1;\n            ppos[nn]=i;\n        }\n    }\n    sp[0]=0;\n    for(i=1;i<=nn;i++)\n    {\n        sp[i]=sp[i-1]+(p[i]==2);\n    }\n    \n    \n    long long tmp=0;\n    long long lans=1;\n    long long rans;\n    int ll,rr;\n    ll=1;\n    \n    \n    //cout<<mm1<<' '<<mm2<<\" mmm\"<<endl;\n    for(rr=1;rr<=nn;rr++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[rr]][0],sa[n][1]-sa[ppos[rr]][1]);\n        tmp=(tmp+lans*rans%MOD*two[sp[rr]-sp[ll-1]]%MOD)%MOD;\n    }\n    //cout<<\"tmp0\"<<tmp<<endl;\n    \n    ans=(ans+tmp)%MOD;\n    for(ll=2;ll<=nn;ll++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[ll-1]][0],sa[n][1]-sa[ppos[ll-1]][1]);\n        tmp=(tmp-lans*rans%MOD*two[sp[ll-1]-sp[ll-2]]%MOD+MOD)%MOD;\n        //cout<<tmp<<\"  &&&\"<<endl;\n        tmp=tmp*inv(lans)%MOD;\n        lans=calc(mm1,sa[ppos[ll]-1][0],sa[ppos[ll]-1][1]);\n        tmp=tmp*lans%MOD;\n        if(p[ll-1]==2)\n        {\n            tmp=tmp*inv(2)%MOD;\n        }\n        \n        //cout<<\"tmp\"<<tmp<<endl;\n        \n        ans=(ans+tmp)%MOD;\n    }\n    \n    \n    return ans;\n}\n\n\nint main()\n{\n    int i,j,k;\n    char c;\n    fa[0]=1;\n    invfa[0]=1;\n    for(i=1;i<=200000;i++)\n    {\n        fa[i]=(fa[i-1]*i)%MOD;\n        invfa[i]=inv(fa[i]);\n    }\n    two[0]=1;\n    for(i=1;i<=200000;i++)\n    {\n        two[i]=(two[i-1]*2)%MOD;\n    }\n    \n    \n    scanf(\"%d %d\",&n,&m);\n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=n;i++)\n    {\n        \n            scanf(\" %c\",&c);\n            a[i][j]=c-'0';\n    }\n    }\n    \n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=m;i++)\n    {\n            scanf(\" %c\",&c);\n            b[i][j]=c-'0';\n    }\n    }\n    \n    long long ans=0;\n    ans+=gao(a,b,n,m);\n    ans+=gao(b,a,m,n);\n    ans%=MOD;\n    cout<<ans<<endl;\n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 201010;\nconst int MOD = 998244353;\nconst int INV = (MOD + 1) >> 1;\ntypedef long long ll;\n\nchar S[N];\nint vis[N];\nint fac[N << 2], inv[N << 2];\nint v[N][2], h[N][2];\nint pre[N], suf[N], p2[N];\nint n, m, lim, ans;\n\ninline void Mod(int &x) {\n\twhile (x >= MOD) x -= MOD;\n}\ninline int Pow(int a, int b) {\n\tint c = 1;\n\twhile (b) {\n\t\tif (b & 1) c = (ll)c * a % MOD;\n\t\tb >>= 1; a = (ll)a * a % MOD;\n\t}\n\treturn c;\n}\ninline int Inv(int x) {\n\treturn Pow(x, MOD - 2);\n}\ninline int C(int n, int m) {\n\treturn (ll)fac[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\ninline int Calc(int X, int Y, int Z) {\n\tif (X == 0) return (Y + Z) ? 0: 1;\n\treturn C(X + Y + Z - 1, X - 1);\n}\ninline void Solve(void) {\n\tstatic int x, y, z;\n\tmemset(p2, 0, sizeof p2);\n\tmemset(suf, 0, sizeof suf);\n\tx = y = z = 0;\n\tfor (int i = 1; i <= n; i++) x += h[i][1];\n\tp2[0] = 1;\n\tfor (int i = 1; i <= m; i++)\n\t\tMod(p2[i] = p2[i - 1] << (v[i][0] & v[i][1]));\n\tfor (int i = m; i; i--) {\n\t\tif (!v[i][0] && !v[i][1]) {\n\t\t\tsuf[i] = suf[i + 1];\n\t\t\tcontinue;\n\t\t}\n\t\tMod(suf[i] = suf[i + 1] + (ll)Calc(x, y, z) * p2[i] % MOD);\n\t\ty += v[i][0]; z += v[i][1];\n\t}\n\tx = y = z = 0;\n\tfor (int i = 1; i <= n; i++) x += h[i][0];\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (!v[i][0] && !v[i][1]) continue;\n\t\tpre[i] = (ll)Calc(x, y, z) * Inv(p2[i - 1]) % MOD;\n\t\tMod(ans += (ll)pre[i] * suf[i] % MOD);\n\t\ty += v[i][0]; z += v[i][1];\n\t}\n}\n\n\nint main(void) {\n\tscanf(\"%d%d\\n\", &n, &m);\n\tlim = max(n, m) << 2;\n\tinv[1] = 1;\n\tfor (int i = 2; i <= lim; i++)\n\t\tinv[i] = (ll)(MOD - MOD / i) * inv[MOD % i] % MOD;\n\tfac[0] = inv[0] = 1;\n\tfor (int i = 1; i <= lim; i++) {\n\t\tfac[i] = (ll)fac[i - 1] * i % MOD;\n\t\tinv[i] = (ll)inv[i - 1] * inv[i] % MOD;\n\t}\n\tscanf(\"%s\", S);\n\tfor (int i = 1; i <= n; i++) h[i][0] = S[i - 1] - '0';\n\tscanf(\"%s\", S);\n\tfor (int i = 1; i <= n; i++) h[i][1] = S[i - 1] - '0';\n\tscanf(\"%s\", S);\n\tfor (int i = 1; i <= m; i++) v[i][0] = S[i - 1] - '0';\n\tscanf(\"%s\", S);\n\tfor (int i = 1; i <= m; i++) v[i][1] = S[i - 1] - '0';\n\tSolve();\n\tfor (int i = 1; i <= lim; i++) {\n\t\tswap(h[i][0], v[i][0]);\n\t\tswap(h[i][1], v[i][1]);\n\t}\n\tswap(n, m); Solve();\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 420000\n#define LL long long\n\nconst LL mod=998244353;\nLL n,m,ans,pw[N],f[N],g[N],fac[N],ifac[N];\nchar a[N],b[N],c[N],d[N];\nbool chk;\n\nLL inv(LL x){return x==1?1:(mod-mod/x)*inv(mod%x)%mod;}\n\nLL C(LL x,LL y){if (y<0) return 0; return fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\n\nvoid solve(LL n,LL m,char a[],char b[],char c[],char d[]){\n\tmemset(f,0,sizeof f); memset(g,0,sizeof g);\n\tLL l=0,r=0,sum=0,sum2=0,cnt=0,cnt2=0,tmp=0;\n\tfor (LL i=1;i<=m;i++){\n\t\tif (c[i]=='1') l++;\n\t\tif (d[i]=='1') r++;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\tif (a[i]=='1') sum++;\n\t\tif (b[i]=='1') sum++;\n\t\tif (a[i]=='1' && b[i]=='1') sum2++;\n\t}\n\tif (a[1]=='1'||b[1]=='1') f[0]=1;\n\tif (a[n]=='1'||b[n]=='1') tmp=g[n+1]=pw[sum2];\n\tfor (LL i=1;i<=n;i++){\n\t\tif (i>1&&(a[i-1]=='1'||b[i-1]=='1')) g[i]=C(sum-cnt+r-1,r-1)*pw[cnt2]%mod;\n\t\ttmp=(tmp+g[i])%mod;\n\t\tif (a[i]=='1') cnt++;\n\t\tif (b[i]=='1') cnt++;\n\t\tif (a[i]=='1' && b[i]=='1') cnt2++;\n\t\tif (i<n&&(a[i+1]=='1'||b[i+1]=='1')) f[i]=C(cnt+l-1,l-1)*inv(pw[cnt2])%mod;\n\t}\n\tfor (LL i=1;i<=n;i++){\n\t\ttmp=(tmp-g[i]+mod)%mod;\n\t\tans=(ans+f[i-1]*tmp)%mod;\n\t}\n}\n\nint main(){\n\tscanf(\"%lld%lld\",&n,&m);\n\tscanf(\"%s%s%s%s\",a+1,b+1,c+1,d+1);\n\tfor (int i=1;i<=n;i++) chk|=(a[i]=='1')|(b[i]=='1');\n\tfor (int i=1;i<=m;i++) chk|=(c[i]=='1')|(d[i]=='1');\n\tif (!chk){puts(\"1\"); return 0;}\n\tpw[0]=1; for (LL i=1;i<N;i++) pw[i]=pw[i-1]*2%mod;\n\tfac[0]=1; for (LL i=1;i<N;i++) fac[i]=fac[i-1]*i%mod;\n\tifac[N-1]=inv(fac[N-1]); for (LL i=N-2;i>=0;i--) ifac[i]=ifac[i+1]*(i+1)%mod;\n\tsolve(n,m,a,b,c,d);\n\tsolve(m,n,c,d,a,b);\n\tprintf(\"%lld\\n\",ans);\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\n#include<unordered_set>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 3 * 1000 * 100 + 47;\nconst int MOD = 998244353;\n\nLL F[MAX];\nLL FR[MAX];\nLL R[MAX];\nstring a, b, c, d;\nstring A, B, C, D;\nLL P[MAX];\nLL S[MAX];\nLL ans = 0;\n\nLL cc(int n, int k)\n{\n\tif (k > n) return 0;\n\t\n\tLL res = F[n] * FR[n - k] % MOD;\n\tres = res * FR[k] % MOD;\n\treturn res;\n}\n\nvoid solve1(string a, string c, string d, LL P[])\n{\n\tint y = 0;\n\tint z = 0;\n\tint x = 0;\n\tFOR(i, 0, SZ(a)) x += a[i] == '1';\n\n\tFOR(i, 0, SZ(c))\n\t{\n\t\tif (c[i] == '0' && d[i] == '0')\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c[i] == '1') y++;\n\t\tif (d[i] == '1') z++;\n\n\t\tif (x == 0 && y == 0 && z == 0)\n\t\t{\n\t\t\tP[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tP[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tP[i] = cc(x + y + z - 1, x - 1);\n\t}\n}\n\nvoid solve(string a, string b, string c, string d)\n{\n\tsolve1(a, c, d, P);\n\treverse(ALL(c));\n\treverse(ALL(d));\n\tsolve1(b, c, d, S);\n\n\treverse(ALL(c));\n\treverse(ALL(d));\n\treverse(S, S + SZ(c));\n\n\tS[SZ(c)] = 1;\n\tLL cur = 0;\n\tFOR(i, 0, SZ(c))\n\t{\n\t\tif (c[i] == '0' && d[i] == '0') continue;\n\t\tif (i)\n\t\t{\n\t\t\tcur = (cur + P[i - 1]) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur = (cur + 1) % MOD;\n\t\t}\n\n\t\tif (c[i] == '1' && d[i] == '1') cur = (cur * 2) % MOD;\n\n\t\tans = (ans + cur * S[i + 1]) % MOD;\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tF[0] = FR[0] = F[1] = FR[1] = R[1] = 1;\n\n\tFOR(i, 2, MAX)\n\t{\n\t\tF[i] = F[i - 1] * i % MOD;\n\t\tR[i] = (MOD / i) * R[MOD % i] % MOD;\n\t\tR[i] = (MOD - R[i]) % MOD;\n\t\tFR[i] = R[i] * FR[i - 1] % MOD;\n\t}\n\n\tint n, m;\n\tcin >> n >> m >> a >> b >> c >> d;\n\tFOR(i, 0, SZ(a))\n\t{\n\t\tif (a[i] == '0' && b[i] == '0') continue;\n\t\tA += a[i];\n\t\tB += b[i];\n\t}\n\n\tFOR(i, 0, SZ(c))\n\t{\n\t\tif (c[i] == '0' && d[i] == '0') continue;\n\t\tC += c[i];\n\t\tD += d[i];\n\t}\n\n\tsolve(A, B, C, D);\n\t//cout << ans << endl;\n\tsolve(C, D, A, B);\n\n\tif (ans == 0) ans = 1;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate <class T>\nT inverse(T a, T m) {\n    T u=0,v=1;\n    while(a!=0){\n        T t=m/a;\n        m-=t*a;std::swap(a,m);\n        u-=t*v;std::swap(u,v);\n    }\n    assert(m==1);\n    return u;\n}\ntemplate <class T>\nclass modular {\n    public:\n        int value;\n        constexpr modular() = default;\n        constexpr modular(const modular&) = default;\n        constexpr modular(modular&&) = default;\n        modular& operator=(const modular&) = default;\n        modular& operator=(modular&&) = default;\n        template <class U>modular (const U& x) {value = normalize(x);}\n\n        template <class U>\n            static int normalize(const U& x) {\n                int v=static_cast<int>(-mod()<=x&&x<mod()?x:x%mod());\n                if(v<0)v+=mod();\n                return v;\n            }\n\n        template <class U> explicit operator U()const{return static_cast<U>(value);}\n        constexpr static auto mod(){return T::value;}\n\n        auto&operator+=(const modular&other) {if((value+=other.value)>=mod())value-=mod();return *this;}\n        auto&operator-=(const modular& other){if ((value-=other.value)<0)value+=mod();return *this;}\n        template <class U>auto& operator+=(const U& other){return*this+=modular(other);}\n        template <class U>auto& operator-=(const U& other){return*this-=modular(other);}\n        auto operator-()const{return modular(-value);}\n        auto&operator++(){return*this+=1;}\n        auto&operator--(){return*this-=1;}\n        auto operator++(int){modular result(*this);operator++();return result;}\n        auto operator--(int){modular result(*this);operator--();return result;}\n\n        template <class U = T>\n            auto&operator*=(const modular&rhs){value=normalize(static_cast<std::int64_t>(value)*static_cast<std::int64_t>(rhs.value));return *this;}\n        auto&operator/=(const modular&rhs){return*this*=modular(inverse(rhs.value, mod()));}\n};\ntemplate<class T>struct is_modular:std::false_type{};\ntemplate<class T>struct is_modular <modular<T>>:std::true_type{};\ntemplate<class T>constexpr bool is_modular_v=is_modular<T>::value;\ntemplate<class T> bool operator==(const modular<T>& lhs, const modular<T>& rhs){return lhs.value==rhs.value;}\ntemplate<class T,class U>bool operator==(const modular<T>& lhs, U rhs){return lhs==modular<T>(rhs);}\ntemplate<class T,class U>bool operator==(U lhs, const modular<T>& rhs){return modular<T>(lhs)==rhs;}\ntemplate<class T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs){return !(lhs == rhs);}\ntemplate<class T,class U> bool operator!=(const modular<T>& lhs, U rhs){return !(lhs==rhs);}\ntemplate<class T,class U> bool operator!=(U lhs, const modular<T>& rhs){return !(lhs==rhs);}\ntemplate<class T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T,class U> modular<T> operator+(const modular<T>& lhs, U rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T,class U> modular<T> operator+(U lhs, const modular<T>& rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T,class U> modular<T> operator-(const modular<T>& lhs, U rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T,class U> modular<T> operator-(U lhs, const modular<T>& rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T,class U> modular<T> operator*(const modular<T>& lhs, U rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T,class U> modular<T> operator*(U lhs, const modular<T>& rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U> modular<T> operator/(const modular<T>& lhs, U rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U> modular<T> operator/(U lhs, const modular<T>& rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U>\nmodular<T> power (const modular<T>& a, U b) {\n    assert(b>=0);\n    modular<T>x=a,ret=1;\n    for (;b>0;b/=2){\n        if(b%2==1)ret*=x;\n        x*=x;\n    }\n    return ret;\n}\ntemplate <class T>std::string to_string(const modular<T>& a) {\n    return std::to_string(a.value);\n}\ntemplate <class T>auto operator<<\n(std::ostream& os, const T& a)->std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a.value;\n}\ntemplate <class T>auto operator>>\n(std::istream& is, T& a)-> std::enable_if_t<is_modular_v<T>, std::istream&> {\n    long long x;is>>x;\n    a=T(x);\n    return is;\n}\n\n// using mod_type = int;\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 998'244'353;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\n\nint N;\nstd::vector<mint>fact,finv;\nvoid init(int n){\n    N=n;\n    fact.resize(n+1);\n    finv.resize(n+1);\n    fact.at(0)=1;\n    for(int i=1;i<=n;i++)fact.at(i)=fact.at(i-1)*i;\n    finv.at(n)=1/fact.at(n);\n    for(int i=n;i>=1;i--)finv.at(i-1)=finv.at(i)*i;\n    assert(finv.at(0)==1);\n}\nmint binom(int n,int k){\n    assert(0<=n);\n    if(k<0||n<k)return 0;\n    return fact.at(n)*finv.at(k)*finv.at(n-k);\n}\n\nint main(){\n    int h,w;std::cin>>h>>w;\n    init(2*(h+w)+1);\n    std::string sa,sb,sc,sd;std::cin>>sa>>sb>>sc>>sd;\n    int A=std::count(sa.begin(),sa.end(),'1');\n    int B=std::count(sb.begin(),sb.end(),'1');\n    int C=std::count(sc.begin(),sc.end(),'1');\n    int D=std::count(sd.begin(),sd.end(),'1');\n    if(!A&&!B&&!C&&!D){\n        std::cout<<1<<'\\n';\n        return 0;\n    }\n    mint ans=0;\n    auto cal=[&](int a, int c, int d)->mint{\n        if(a==0)return c==0&&d==0;\n        return binom(a-1+c+d,a-1);\n    };\n    for(int ngtkana=0;ngtkana<2;ngtkana++){\n        // 縦に貫いている中で最も左のものがこれであるときの、\n        // それ以右の場合の数です。\n        // そこに c も d もいない場合は累積和の伝播のためだけに使います。\n        std::vector<mint>right(w+1);\n        int c=0,d=0;\n        for(int j=w-1;j>=0;j--){\n            right.at(j)=right.at(j+1);\n            if(sc.at(j)=='1'||sd.at(j)=='1')\n                right.at(j)+=cal(B,c,d);\n            if(sc.at(j)=='1'&&sd.at(j)=='1')right.at(j)*=2;\n            c+=sc.at(j)=='1';\n            d+=sd.at(j)=='1';\n        }\n\n        // 縦に貫いている中で最も左がこれであるときの、\n        // それよりも左の場合の数と、畳み込んでいきます。\n        c=0,d=0;\n        for(int j=0;j<w;j++){\n            if(sc.at(j)=='1'||sd.at(j)=='1'){\n                ans+=cal(A,c,d)*right.at(j);\n            }\n            c+=sc.at(j)=='1';\n            d+=sd.at(j)=='1';\n        }\n        std::swap(sa,sc);\n        std::swap(sb,sd);\n        std::swap(A,C);\n        std::swap(B,D);\n        std::swap(h,w);\n    }\n    std::cout<<ans<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 200100;\nconst int base = 998244353;\n\nint n,m,sum_a,sum_b,sum_up,sum_down,ans,inv[maxn],L[maxn],R[maxn],a[5][maxn],fac[maxn],tot;\n\nint pw(int a,int n) {\n    if (n==0) return 1;\n    if (n==1) return a;\n    int tg = pw(a,n/2);\n    tg = (1ll*tg*tg) % base;\n    if (n%2==0) return tg;\n    return (1ll*tg*a) % base;\n}\n\nvoid init() {\n    inv[0]=1;\n    fac[0]=1;\n    for (int i=1;i<=maxn;i++) fac[i] = (1ll*fac[i-1]*i) % base;\n    for (int i=1;i<=maxn;i++) inv[i] = pw(fac[i],base-2);\n}\n\nint C(int k,int n) {\n    if (k > n) return 0;\n    return 1ll*fac[n] * inv[k] % base * inv[n-k] % base;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n  //  freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m;\n    init();\n    for (int i=1;i<=4;i++) {\n        for (int j=1;j<=((i<=2)?n:m);j++) {\n            char ch;\n            cin>>ch;\n            a[i][j] = ch - '0';\n        }\n    }\n   // cout<<C(1,3)<<endl;\n   // cout<<inv[2]<<endl;\n    tot=0;\n    for (int times =1;times<=2;times++) {\n        sum_a = sum_b = sum_up = sum_down = 0;\n        for (int i=1;i<=n;i++) {\n            sum_a += a[1][i];\n            sum_b += a[2][i];\n        }\n        tot += sum_a + sum_b;\n        for (int i=1;i<=m;i++) {\n            if (a[3][i]+a[4][i]==0) {\n                L[i] =0;\n            } else {\n                if (sum_a ==0 & sum_up >0) L[i]=0;\n                else L[i] =((sum_a == 0) ? 1 : C(sum_a-1,sum_a + sum_up - 1));\n            }\n            sum_up += a[3][i] + a[4][i];\n        }\n        for (int i=m;i>=1;i--) {\n            if (a[3][i]+a[4][i]==0) {\n                R[i] =0;\n            } else {\n                if (sum_b ==0 & sum_down >0) R[i]=0;\n                else R[i] =((sum_b == 0) ? 1 : C(sum_b-1,sum_b + sum_down - 1));\n            }\n            sum_down += a[3][i] + a[4][i];\n        }\n        int sum=0;\n        for (int i=1;i<=m;i++) {\n            //cout<<L[i]<<\" \"<<R[i]<<endl;\n            sum = (sum + L[i]) % base;\n            sum = (1ll* sum * max(1,a[3][i]+a[4][i])) % base;\n            ans = (ans + 1ll*sum*R[i]%base) % base;\n        }\n\n        swap(n,m);\n        swap(a[1],a[3]);\n        swap(a[2],a[4]);\n    }\n    if (tot==0) ans =1;\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD 998244353\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint N, M;\nchar A[101010], B[101010], C[101010], D[101010];\n\ni64 fact[404040], facti[404040];\n\ni64 modpow(i64 a, int p = MOD - 2)\n{\n\tif (p == 0) return 1;\n\ti64 tmp = modpow(a, p / 2);\n\ttmp = tmp * tmp % MOD;\n\tif (p % 2 == 1) tmp = tmp * a % MOD;\n\treturn tmp;\n}\n\ni64 Comb(int a, int b)\n{\n\tif (a < b) return 0;\n\treturn fact[a] * facti[b] % MOD * facti[a - b] % MOD;\n}\n\ni64 lfs[101010], rgs[101010];\n\nint cone(char* s, char* t)\n{\n\tint ret = 0;\n\twhile (s != t) {\n\t\tif (*s == '1') ++ret;\n\t\t++s;\n\t}\n\treturn ret;\n}\n\ni64 solve(int N, int M, char* A, char* B, char* C, char* D)\n{\n\tint ca = cone(A, A + N);\n\tint cb = cone(B, B + N);\n\n\tif (ca + cb == 0) {\n\t\ti64 ret = 1;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint c = (C[i] - '1') + (D[i] - '1');\n\t\t\tret = ret * max(c, 1) % MOD;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tint a, x, y;\n\n\t// compute lfs\n\ta = ca;\n\tx = y = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (a == 0) {\n\t\t\tlfs[i] == (x + y == 0 ? 1 : 0);\n\t\t} else {\n\t\t\tlfs[i] = Comb(a - 1 + x + y, a - 1);\n\t\t}\n\t\tif (C[i] == '1') ++x;\n\t\tif (D[i] == '1') ++y;\n\t}\n\n\t// compute rgs\n\ta = cb;\n\tx = y = 0;\n\tfor (int i = M - 1; i >= 0; --i) {\n\t\tif (a == 0) {\n\t\t\trgs[i] == (x + y == 0 ? 1 : 0);\n\t\t} else {\n\t\t\trgs[i] = Comb(a - 1 + x + y, a - 1);\n\t\t}\n\t\tif (C[i] == '1') ++x;\n\t\tif (D[i] == '1') ++y;\n\t}\n\n\ti64 ret = 0;\n\ti64 tmp = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint ct = (C[i] - '0') + (D[i] - '0');\n\t\tif (ct == 0) continue;\n\n\t\tADD(tmp, lfs[i]);\n\t\ttmp = tmp * ct % MOD;\n\t\tADD(ret, tmp * rgs[i]);\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tfact[0] = facti[0] = 1;\n\tfor (int i = 1; i <= 400000; ++i) {\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tfacti[i] = modpow(fact[i]);\n\t}\n\tscanf(\"%d%d\", &N, &M);\n\tscanf(\"%s%s%s%s\", A, B, C, D);\n\n\tif (cone(A, A + N) + cone(B, B + N) + cone(C, C + N) + cone(D, D + N) == 0) {\n\t\tputs(\"1\");\n\t\treturn 0;\n\t}\n\n\ti64 ret = 0;\n\tADD(ret, solve(N, M, A, B, C, D));\n\tADD(ret, solve(M, N, C, D, A, B));\n\n\tprintf(\"%lld\\n\", ret);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 998244353\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nll modpow(ll x,ll n){\n\tll res=1;\n\twhile(n>0){\n\t\tif(n&1) res=res*x%mod;\n\t\tx=x*x%mod;\n\t\tn>>=1;\n\t}\n\treturn res;\n}\nll F[300005],R[300005];\nvoid make(){\n\tF[0] = 1;\n\tfor(int i=1;i<300005;i++) F[i] = F[i-1]*i%mod;\n\tfor(int i=0;i<300005;i++) R[i] = modpow(F[i],mod-2);\n}\nll c(int a,int b){\n\treturn F[a]*R[b]%mod*R[a-b]%mod;\n}\n\nll ans;\nll sol(int n,int m,string a,string b,string cc,string d){\n\tll zan = 0,ret = 0;\n\tint A = 0,B = 0,C = 0,D = 0;\n\trep(i,n) A+=a[i]-'0',B+=b[i]-'0';\n\trep(i,m) C+=cc[i]-'0',D+=d[i]-'0';\n\tint CC = 0,DD = 0;\n\tfor(int i=m-1;i>=0;i--){\n\t\t{\n\t\t\tll add = 0;\n\t\t\tif(CC+DD == 0 && B == 0){\n\t\t\t\tadd = 1;\n\t\t\t}\n\t\t\telse if(B){\n\t\t\t\tadd = c(B-1+CC+DD,B-1);\n\t\t\t}\n\t\t\tint cnt = cc[i]-'0' + d[i]-'0';\n\t\t\tC -= cc[i]-'0'; D -= d[i]-'0';\n\t\t\tCC += cc[i]-'0'; DD += d[i]-'0';\n\t\t\tif(A){\n\t\t\t\tret += c(A-1+C+D,A-1) * ((add+zan)%mod) % mod * cnt % mod;\n\t\t\t}\n\t\t\telse if(C+D==0){\n\t\t\t\tret += ((add+zan)%mod) % mod * cnt % mod;\n\t\t\t}\n\t\t\tzan = add * cnt % mod + zan * max(1,cnt) % mod;\n\t\t}\n\t}\n\treturn ret%mod;\n}\nint n,m;\nstring a,b,cc,d;\nint main(){\n\tcin>>n>>m>>a>>b>>cc>>d;\n\tmake();\n\tans+=sol(n,m,a,b,cc,d);\n\tans+=sol(m,n,cc,d,a,b);\n\tcout<<ans%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define llong long long\nusing namespace std;\n\nconst int N = 2e5;\nconst int P = 998244353;\nllong fact[N*4+3],finv[N*4+3];\nchar sa[N+3],sb[N+3],sc[N+3],sd[N+3];\n\nllong quickpow(llong x,llong y)\n{\n\tllong cur = x,ret = 1ll;\n\tfor(int i=0; y; i++)\n\t{\n\t\tif(y&(1ll<<i)) {y-=(1ll<<i); ret = ret*cur%P;}\n\t\tcur = cur*cur%P;\n\t}\n\treturn ret;\n}\nllong comb(llong x,llong y) {return x<0 || y<0 || x<y ? 0ll : fact[x]*finv[y]%P*finv[x-y]%P;}\n\nllong solve(int n,int m,char s1[],char s2[],char s3[],char s4[])\n{\n\tint cnt1 = 0,cnt2 = 0,cnt3 = 0,cnt4 = 0,cur3 = 0,cur4 = 0;\n\tfor(int i=1; i<=n; i++) {cnt1 += s1[i]=='1',cnt2 += s2[i]=='1';}\n\tfor(int i=1; i<=m; i++) {cnt3 += s3[i]=='1',cnt4 += s4[i]=='1';}\n\tllong tmp = 1ll;\n\tllong ret = 0ll;\n\tfor(int i=1; i<=m; i++)\n\t{\n\t\tcur3 += s3[i]=='1'; cur4 += s4[i]=='1';\n\t\tif(s3[i]=='1' || s4[i]=='1')\n\t\t{\n\t\t\tif(s3[i]=='1' && s4[i]=='1') {tmp = tmp*2ll%P;}\n\t\t\tif(cnt2!=0) {ret = (ret+tmp*comb(cnt3+cnt2+cnt4-cur3-cur4-1,cnt2-1))%P;}\n\t\t\telse {ret = (ret+tmp*(cnt3+cnt4-cur3-cur4==0))%P;}\n\t\t\tif(cnt1!=0) {tmp = (tmp+comb(cur3+cur4+cnt1-1,cnt1-1))%P;}\n\t\t\telse {tmp = (tmp+(cur3+cur4==0))%P;}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint n,m;\n\tfact[0] = 1ll;\n\tfor(int i=1; i<=N*4; i++) fact[i] = fact[i-1]*i%P;\n\tfinv[N*4] = quickpow(fact[N*4],P-2);\n\tfor(int i=N*4-1; i>=0; i--) finv[i] = finv[i+1]*(i+1)%P;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s%s%s%s\",sa+1,sb+1,sc+1,sd+1);\n\tbool gg = false;\n\tfor(int i=1; i<=n; i++) if(sa[i]=='1' || sb[i]=='1') gg = true;\n\tfor(int i=1; i<=m; i++) if(sc[i]=='1' || sd[i]=='1') gg = true; \n\tif(gg==false) {printf(\"1\"); return 0;}\n\tllong ans = 0ll;\n\tans += solve(n,m,sa,sb,sc,sd);\n\tans += solve(m,n,sc,sd,sa,sb);\n\tans %= P;\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200500\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nint N,M;\nchar a[4][MAXN];\nint fac[MAXN * 2],invfac[MAXN * 2],f[MAXN],b[MAXN],sum[4][MAXN],s[MAXN];\nint pw[MAXN],ipw[MAXN],ans;\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid update(int &x,int y) {\n\tx = inc(x,y);\n}\nint C(int n,int m) {\n\tif(n < m) return 0;\n\treturn mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nvoid CalcV() {\n\tmemset(f,0,sizeof(f));\n\tmemset(b,0,sizeof(b));\n\tmemset(s,0,sizeof(s));\n\tint X = sum[0][N],Y,Z;\n\tfor(int i = 0 ; i <= M ; ++i) {\n\t\tif(a[2][i + 1] == '0' && a[3][i + 1] == '0') continue;\n\t\tY = sum[2][i],Z = sum[3][i];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) f[i] = 1;\n\t\t\telse f[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tf[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tX = sum[1][N];\n\tfor(int i = M + 1 ; i >= 1 ; --i) {\n\t\tif(a[2][i - 1] == '0' && a[3][i - 1] == '0') continue;\n\t \tY = sum[2][M] - sum[2][i - 1],Z = sum[3][M] - sum[3][i - 1];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) b[i] = 1;\n\t\t\telse b[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tb[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= M ; ++i) s[i] = s[i - 1] + (a[2][i] == '1' && a[3][i] == '1');\n\tfor(int i = 0 ; i <= M ; ++i) {\n\t\tf[i] = mul(f[i],ipw[s[i]]);\n\t}\n\tfor(int i = M + 1 ; i >= 1 ; --i) {\n\t\tb[i] = inc(b[i + 1],mul(b[i],pw[s[i - 1]]));\n\t}\n\tfor(int i = 1 ; i <= M ; ++i) {\n\t\tupdate(ans,mul(f[i - 1],b[i + 1]));\n\t}\n}\nvoid CalcH() {\n\tmemset(f,0,sizeof(f));\n\tmemset(b,0,sizeof(b));\n\tmemset(s,0,sizeof(s));\n\tint X = sum[2][M],Y,Z;\n\tfor(int i = 0 ; i <= N ; ++i) {\n\t\tif(a[0][i + 1] == '0' && a[1][i + 1] == '0') continue;\n\t\tY = sum[0][i],Z = sum[1][i];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) f[i] = 1;\n\t\t\telse f[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tf[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tX = sum[3][M];\n\tfor(int i = N + 1 ; i >= 1 ; --i) {\n\t\tif(a[0][i - 1] == '0' && a[1][i - 1] == '0') continue;\n\t\tY = sum[0][N] - sum[0][i - 1],Z = sum[1][N] - sum[1][i - 1];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) b[i] = 1;\n\t\t\telse b[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tb[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) s[i] = s[i - 1] + (a[0][i] == '1' && a[1][i] == '1');\n\tfor(int i = 0 ; i <= N ; ++i) {\n\t\tf[i] = mul(f[i],ipw[s[i]]);\n\t}\n\tfor(int i = N + 1 ; i >= 1 ; --i) {\n\t\tb[i] = inc(b[i + 1],mul(b[i],pw[s[i - 1]]));\n\t}\n\tfor(int i = 1 ; i <= N ; i++) {\n\t\tupdate(ans,mul(f[i - 1],b[i + 1]));\n\t}\n}\nvoid Solve() {\n\tread(N);read(M);\n\tfor(int i = 0 ; i <= 3 ; ++i) scanf(\"%s\",a[i] + 1);\n\tfor(int i = 0 ; i <= 3 ; ++i) {\n\t\tint T = (i <= 1 ? N : M);\n\t\tfor(int j = 1 ; j <= T ; ++j) {\n\t\t\tsum[i][j] = sum[i][j - 1] + (a[i][j] == '1');\n\t\t}\n\t}\n\tint T = 2 * (N + M) + 10;\n\tfac[0] = 1;\n\tfor(int i = 1 ; i <= T ; ++i) {\n\t\tfac[i] = mul(fac[i - 1],i);\n\t}\n\tinvfac[T] = fpow(fac[T],MOD - 2);\n\tfor(int i = T - 1 ; i >= 0 ; --i) {\n\t\tinvfac[i] = mul(invfac[i + 1],i + 1);\n\t}\n\tpw[0] = 1;\n\tT = max(N,M);\n\tfor(int i = 1 ; i <= T ; ++i) {\n\t\tpw[i] = mul(pw[i - 1],2);\n\t}\n\tipw[0] = 1;\n\tfor(int i = 1 ; i <= T ; ++i) {\n\t\tipw[i] = mul(ipw[i - 1],(MOD + 1) / 2);\n\t}\n\tCalcV();\n\tCalcH();\n\tif(!sum[0][N] && !sum[1][N] && !sum[2][M] && !sum[3][M]) ans = 1;\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include <complex>\n\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL) INF;\nconst int MOD = 998244353;\n\nconst double EPS = 1e-6;\nconst int MAX = 300 * 1000 + 47;\n\n\nint F[MAX];\nint RF[MAX];\nchar S[4][MAX];\nint U[MAX], D[MAX], L[MAX], R[MAX];\nint X[2][MAX];\n\nint BP(int a, int n)\n{\n    int res = 1;\n    while(n)\n    {\n        if (n & 1)res = (res * 1LL * a) % MOD;\n        a = (a * 1LL * a) % MOD;\n        n >>= 1;\n    }\n    return res;\n}\n\nint BIN(int n, int k)\n{\n    if (k > n)return 0;\n    return (F[n] * 1LL * RF[k] % MOD) * 1LL * RF[n-k] % MOD;\n}\n\n\nvoid calc(int *A, int *B, int *C, int n, int m, int *R)\n{\n    int x = 0, y = 0;\n    FOR(i, 0, n) x += A[i];\n    FOR(i, 0, m)\n    {\n        y += B[i] + C[i];\n        R[i] = BIN(x + y - 1, x - 1);\n    }\n}\n\nint SOLVE(int *U, int *D, int *L, int *R, int n, int m)\n{\n    calc(U, L, R, n, m, X[0]);\n    reverse(L, L + m);\n    reverse(R, R + m);\n    calc(D, L, R, n, m, X[1]);\n    reverse(L, L + m);\n    reverse(R, R + m);\n    reverse(X[1], X[1] + m);\n    X[1][m] = 1;\n    int ans = 0;\n    int sum = 0;\n    \n    \n    FOR(i, 0, m)\n    {\n        sum += i ? X[0][i-1] : 1;\n        if (sum >= MOD)sum -= MOD;\n        sum *= L[i] + R[i];\n        if (sum >= MOD)sum -= MOD;\n        ans = (ans + sum * 1LL * X[1][i+1]) % MOD;\n    }\n    return ans;\n}\n\n\nint main()\n{\n    F[0] = RF[0] = 1;\n    FOR(i, 1, MAX)\n    {\n        F[i] = F[i-1] * 1LL * i % MOD;\n        RF[i] = BP(F[i], MOD - 2);\n    }\n    \n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    \n    FOR(i, 0, 4)\n        scanf(\"%s\", S[i]);\n    \n    int sz = 0;\n    FOR(i, 0, n)\n        if (S[0][i] != '0' || S[1][i] != '0')\n            L[sz] = S[0][i] - '0',\n            R[sz] = S[1][i] - '0',\n            ++sz;\n    n = sz;\n    sz = 0;\n    FOR(i, 0, m)\n        if (S[2][i] != '0' || S[3][i] != '0')\n            U[sz] = S[2][i] - '0',\n            D[sz] = S[3][i] - '0',\n            ++sz;\n    m = sz;\n\n    \n    int res = SOLVE(U, D, L, R, m, n);\n    res += SOLVE(L, R, U, D, n, m);\n    res %= MOD;\n    cout << max(1, res) << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 3e5 + 100;\n\nconst int mod = 998244353;\n\nint n, m, ans;\nchar A[maxn], B[maxn], C[maxn], D[maxn];\nint fac[maxn], ifac[maxn];\nint f[maxn], g[maxn], has[maxn], pw[maxn], cnt[maxn], ipw[maxn];\n\nint Exp(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tfac[0] = 1;\n\tpw[0] = ipw[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tpw[i] = (pw[i - 1] << 1) % mod;\n\t\tipw[i] = Exp(pw[i], mod - 2);\n\t}\n\tifac[maxn - 1] = Exp(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint CC(int n, int m) {\n\treturn (m < 0 || n < m) ? 0 : 1ll * fac[n] * ifac[n - m] % mod * ifac[m] % mod;\n}\n\nvoid solve(int n, int m, char *A, char *B, char *C, char *D) {\n\tint x = 0, a = 0, b = 0;\n\tforn(i, 1, m) {\n\t\tx += (C[i] == '1');\n\t}\n\tcnt[0] = 0;\n\tforn(i, 1, n) {\n\t\tcnt[i] = cnt[i - 1] + (A[i] == '1' && B[i] == '1');\n\t}\n\tcnt[n + 1] = cnt[n];\n\tif(x) {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t\tf[i] = 1ll * f[i] * ipw[cnt[i - 1]] % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = 1;\n\t\t\t\twhile(++i <= n) {\n\t\t\t\t\tf[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tx = 0;\n\ta = 0;\n\tb = 0;\n\tforn(i, 1, m) {\n\t\tx += (D[i] == '1');\n\t}\n\tif(x) {\n\t\tg[n + 1] = 0;\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[i] = 0;\n\t\t\t}\n\t\t\tg[i] = 1ll * g[i] * pw[cnt[i]] % mod;\n\t\t\t(g[i] += g[i + 1]) %= mod;\n\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = pw[cnt[i]];\n\t\t\t\twhile(i) {\n\t\t\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\t\t\tg[--i] = g[i + 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tpre();\n\tscf(n, m);\n\tscanf(\"%s\", A + 1);\n\tscanf(\"%s\", B + 1);\n\tscanf(\"%s\", C + 1);\n\tscanf(\"%s\", D + 1);\n\tsolve(n, m, A, B, C, D);\n\tsolve(m, n, C, D, A, B);\n\tif(!ans) {\n\t\tans = 1;\n\t}\n\tprintf(\"%d\\n\", (ans % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint po(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) { return po(x, mod - 2); }\n\nint fact[200010], invf[200010];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    if(k < 0) return 1;\n    return comb(n + k - 1, k);\n}\n\nint N, M;\nstring A, B, C, D;\n\nvector<int> Col;\nvector<int> Ldp, Rdp, Rpsum, pmul;\n\nint solve() {\n    Col.clear();\n    for(int i = 0; i < M; i++) {\n        if(C[i] == '1' && D[i] == '1') Col.push_back(3);\n        else if(C[i] == '1') Col.push_back(1);\n        else if(D[i] == '1') Col.push_back(2);\n    }\n\n    if(Col.size() == 0) return 0;\n\n    int a = 0;\n    for(int i = 0; i < N; i++) if(A[i] == '1') a++;\n    int x = 0, y = 0;\n    Ldp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = 0; i < Col.size(); i++) {\n            if(x == 0 && y == 0) Ldp[i] = 1;\n            else Ldp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Ldp[0] = 1;\n\n    a = 0;\n    for(int i = 0; i < N; i++) if(B[i] == '1') a++;\n    x = 0, y = 0;\n    Rdp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = (int)Col.size() - 1; i >= 0; i--) {\n            if(x == 0 && y == 0) Rdp[i] = 1;\n            else Rdp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Rdp.back() = 1;\n\n    pmul = vector<int>(Col.size());\n    for(int i = 0; i < Col.size(); i++) {\n        pmul[i] = (Col[i] == 3? 2 : 1);\n        if(i) pmul[i] = 1LL * pmul[i] * pmul[i - 1] % mod;\n    }\n\n    Rpsum = vector<int>(Col.size());\n    for(int i = (int)Col.size() - 1; i >= 0; i--) {\n        Rpsum[i] = 1LL * Rdp[i] * pmul[i] % mod;\n        if(i != (int)Col.size() - 1) {\n            Rpsum[i] += Rpsum[i + 1];\n            Rpsum[i] %= mod;\n        }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < Col.size(); i++) {\n        ret += 1LL * Ldp[i] * (Col[i] == 3? 2 : 1) % mod * (Rdp[i] + 1LL * (i == Col.size() - 1? 0 : Rpsum[i + 1]) * inv(pmul[i]) % mod) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 200010; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 200010; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> M >> A >> B >> C >> D;\n\n    int ans = 0;\n    ans += solve();\n    ans %= mod;\n    swap(N, M);\n    swap(A, C);\n    swap(B, D);\n    ans += solve();\n    ans %= mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst long long md=998244353;\nconst int maxn=200000;\nchar str1[100100],str2[100100];\nchar str3[100100],str4[100100];\nlong long fac[maxn+100],inv[maxn+100];\nlong long f[maxn+100],g[maxn+100];\nlong long C(int n,int m){\n\tif(m==0) return 1;\n\tif(m<0||m>n) return 0;\n\treturn fac[n]*inv[m]%md*inv[n-m];\n}\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str1+1),scanf(\"%s\",str2+1);\n\tscanf(\"%s\",str3+1),scanf(\"%s\",str4+1);\n\tfac[0]=1;\n\tfor(int i=1;i<=maxn;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[maxn]=powd(fac[maxn],md-2);\n\tfor(int i=maxn;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str3[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str4[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=n;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tlong long ans=0,sum=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str1[i]-'0')&&(str2[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tsum=0;\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str1[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str2[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=m;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str3[i]-'0')&&(str4[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define ll long long\n#define N 201000\nusing namespace std;\nvoid U(ll &x,ll y){x=x*y%mod;}\nvoid V(ll &x,ll y){x=(x+y)%mod;}\nll K(ll x,int y){ll t=1;for(;y;y>>=1,U(x,x))if(y&1)U(t,x);return t;}\nll jc[N<<1],inv[N<<1],ans=0,fl;\nll C(int x,int y){return x<y?0:jc[x] *inv[y]%mod *inv[x-y]%mod;}\nvoid pre(int mx){jc[0]=1; for (int i=1;i<=mx;i++) jc[i]=jc[i-1]*i%mod;\n\tinv[mx]=K(jc[mx],mod-2); for (int i=mx;i>0;i--) inv[i-1]=inv[i]*i%mod;}\n\n\nll cal(int x,int y,int z){\n\treturn !x? y+z==0: C(x+y+z-1,x-1);\n}\nvoid doit(int n,int m,char l[],char r[],char u[],char d[]){\n\tll tmp; int cl=0,cr=0,cu=0,cd=0,nowu=0,nowd=0,uu,dd;\n\tfor (int i=1;i<=n;i++) cl+=l[i]-'0',cr+=r[i]-'0';\n\tfor (int i=1;i<=m;i++) cu+=u[i]-'0',cd+=d[i]-'0';\n\tfl=!cl&!cr&!cu&!cd;\n\ttmp=cal(cl,0,0);\n\tfor (int i=1;i<=m;i++){\n\t\tnowu+=(uu=u[i]-'0'); nowd+=(dd=d[i]-'0');\n\t\tif (uu||dd){\n\t\t\tif (uu&&dd) U(tmp,2);\n\t\t\tV(ans,tmp*cal(cr,cu-nowu,cd-nowd));\n\t\t\tV(tmp,cal(cl,nowu,nowd));\n\t\t}\n\t}\n}\n\nchar a[N],b[N],c[N],d[N];\nint main(){\n\tpre(N*2-10); int n,m;\n\tscanf(\"%d%d%s%s%s%s\",&n,&m,a+1,b+1,c+1,d+1);\n\tdoit(n,m,a,b,c,d);\n\tdoit(m,n,c,d,a,b);\n\tV(ans,fl);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool flag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') flag = true;\n\t}\n\tif(!flag) swap(l, u), swap(r, d), swap(h, w);\n\t\n\tflag = false;\n\tfor(int i = 1; i <= h; i++){\n\t\tif(u[i] == '1' || d[i] == '1') flag = true;\n\t}\n\tif(!flag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool wflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') wflag = true;\n\t}\n\tbool hflag = false;\n\tfor(int i = 1; i <= h; i++){\n\t\tif(l[i] == '1' || r[i] == '1') hflag = true;\n\t}\n\tif(!wflag && !hflag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = 0;\n\tif(wflag) ans += calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tif(hflag) ans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nMint f(int a, int b, int c) {\n    if (a == 0 && b == 0) return 1;\n    if (c == 0) return 0;\n    Mint ret = nCk(a+b+c, c) - nCk(a+b+c-1, c);\n    return ret;\n}\n\nint N, M;\nchar L[100011], R[100011], U[100011], D[100011];\n\n\nMint calc() {\n    int lcnt = count(L, L+N, '1');\n    int rcnt = count(R, R+N, '1');\n\n    if (lcnt == 0 && rcnt == 0) return 0;\n    int ucnt = count(U, U+M, '1');\n    int dcnt = count(D, D+M, '1');\n\n    int lup = 0, rup = 0;\n    Mint ans = 0;\n    Mint way = 0;\n    REP (i, N) {\n\tint line = 0;\n\tif (L[i] == '1') { lcnt--; line++; }\n\tif (R[i] == '1') { rcnt--; line++; }\n\tif (line) {\n\t    way += f(lup, rup, ucnt);\n\t    way *= line;\n\t    ans += f(lcnt, rcnt, dcnt) * way;\n\t}\n\tif (L[i] == '1') { lup++; }\n\tif (R[i] == '1') { rup++; }\n    }\n    return ans;\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d\", &N, &M);\n    scanf(\"%s\", L);\n    scanf(\"%s\", R);\n    scanf(\"%s\", U);\n    scanf(\"%s\", D);\n    Mint ans = 0;\n\n    if (count(L, L+N, '1') == 0\n\t    && count(R, R+N, '1') == 0\n\t    && count(U, U+M, '1') == 0\n\t    && count(D, D+M, '1') == 0) {\n\tans = 1;\n    } else {\n\tMint ans1 = calc();\n\tREP (i, 100011) {\n\t    swap(L[i], U[i]);\n\t    swap(R[i], D[i]);\n\t}\n\tswap(N, M);\n\tMint ans2 = calc();\n\n\tans = ans1 + ans2;\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i, n) for(int i = 0, _end_ = (n); i < _end_; ++i)\n#define per(i, n) for(int i = (n) - 1; i >= 0 ; --i)\n#define forn(i, l, r) for(int i = (l), _end_ = (r); i <= _end_; ++i)\n#define nrof(i, r, l) for(int i = (r), _end_ = (l); i >= _end_; --i)\n#define FOR(a, b) for(auto (a): (b))\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-6\n#define pi 3.1415926535897932384626433832795\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef vector<LL> vl;\ntypedef pair<int,int> pii;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\ntypedef vector<pli> vli;\ntypedef vector<pll> vll;\n\nconst int iinf = 1e9 + 7;\nconst int oo = 0x3f3f3f3f;\nconst LL linf = 1ll << 60;\nconst flt dinf = 1e60;\n\ntemplate <typename T> inline void scf(T &x) {\n\tbool f = 0;\n\tx = 0;\n\tchar c = getchar();\n\twhile(c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif(c == '-') f = 1, c = getchar();\n\twhile(c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\tif(f) x = -x;\n\treturn;\n}\n\ntemplate <typename T1, typename T2> void scf(T1 &x, T2 &y) {\n\tscf(x);\n\treturn scf(y);\n}\n\ntemplate <typename T1, typename T2, typename T3> void scf(T1 &x, T2 &y, T3 &z) {\n\tscf(x);\n\tscf(y);\n\treturn scf(z);\n}\n\ntemplate <typename T1, typename T2, typename T3, typename T4> void scf(T1 &x, T2 &y, T3 &z, T4 &w) {\n\tscf(x);\n\tscf(y);\n\tscf(z);\n\treturn scf(w);\n}\n\ninline char mygetchar() {\n\tchar c = getchar();\n\twhile(c == ' ' || c == '\\n') c = getchar();\n\treturn c;\n}\n\ntemplate <typename T> inline bool chkmax(T &x, const T &y) {\n\treturn y > x ? x = y, 1 : 0;\n}\n\ntemplate <typename T> inline bool chkmin(T &x, const T &y) {\n\treturn y < x ? x = y, 1 : 0;\n}\n\n#ifdef King_George\n#define DEBUG\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\n\n//---------------------------------------------------------head----------------------------------------------------\n\nconst int maxn = 3e5 + 100;\n\nconst int mod = 998244353;\n\nint n, m, ans;\nchar A[maxn], B[maxn], C[maxn], D[maxn];\nint fac[maxn], ifac[maxn];\nint f[maxn], g[maxn], has[maxn], pw[maxn], cnt[maxn], ipw[maxn];\n\nint Exp(int x, int n) {\n\tint y = 1;\n\twhile(n) {\n\t\tif(n & 1) {\n\t\t\ty = 1ll * y * x % mod;\n\t\t}\n\t\tx = 1ll * x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn y;\n}\n\nvoid pre() {\n\tfac[0] = 1;\n\tpw[0] = ipw[0] = 1;\n\tfor (int i = 1; i < maxn; ++i) {\n\t\tfac[i] = 1ll * fac[i - 1] * i % mod;\n\t\tpw[i] = (pw[i - 1] << 1) % mod;\n\t\tipw[i] = Exp(pw[i], mod - 2);\n\t}\n\tifac[maxn - 1] = Exp(fac[maxn - 1], mod - 2);\n\tfor (int i = maxn - 1; i >= 1; --i) {\n\t\tifac[i - 1] = 1ll * ifac[i] * i % mod;\n\t}\n\treturn;\n}\n\nint CC(int n, int m) {\n\treturn (m < 0 || n < m) ? 0 : 1ll * fac[n] * ifac[n - m] % mod * ifac[m] % mod;\n}\n\nvoid solve(int n, int m, char *A, char *B, char *C, char *D) {\n\tint x = 0, a = 0, b = 0;\n\tforn(i, 1, m) {\n\t\tx += (C[i] == '1');\n\t}\n\tcnt[0] = 0;\n\tforn(i, 1, n) {\n\t\tcnt[i] = cnt[i - 1] + (A[i] == '1' && B[i] == '1');\n\t}\n\tcnt[n + 1] = cnt[n];\n\tif(x) {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t\tf[i] = 1ll * f[i] * ipw[cnt[i - 1]] % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tforn(i, 1, n) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tf[i] = 1;\n\t\t\t\twhile(++i <= n) {\n\t\t\t\t\tf[i] = 0;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tf[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tx = 0;\n\ta = 0;\n\tb = 0;\n\tforn(i, 1, m) {\n\t\tx += (D[i] == '1');\n\t}\n\tif(x) {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = CC(x + a + b - 1, a + b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tg[i] = 0;\n\t\t\t}\n\t\t\tg[i] = 1ll * g[i] * pw[cnt[i]] % mod;\n\t\t\t(g[i] += g[i + 1]) %= mod;\n\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\tif(A[i] == '1') {\n\t\t\t\t++a;\n\t\t\t}\n\t\t\tif(B[i] == '1') {\n\t\t\t\t++b;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tnrof(i, n, 1) {\n\t\t\tif(A[i] == '1' || B[i] == '1') {\n\t\t\t\tg[i] = pw[cnt[i]];\n\t\t\t\twhile(i) {\n\t\t\t\t\tans = (1ll * g[i] * f[i] + ans) % mod;\n\t\t\t\t\tg[--i] = g[i + 1];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tpre();\n\tscf(n, m);\n\tscanf(\"%s\", A + 1);\n\tscanf(\"%s\", B + 1);\n\tscanf(\"%s\", C + 1);\n\tscanf(\"%s\", D + 1);\n\tsolve(n, m, A, B, C, D);\n\tsolve(m, n, C, D, A, B);\n\tif(!ans) {\n\t\tfor(;;) {\n\t\t\tscanf(\"%s\", A + 1);\n\t\t}\n\t\tans = 1;\n\t}\n\tprintf(\"%d\\n\", (ans % mod + mod) % mod);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF 1000000010\n#define INFLL ((1LL<<62)-5)\n#define FO(i,a,b) for (int (i) = (a); (i) < (b); ++(i))\n#define OF(i,a,b) for (int (i) = (a)-1; (i) >= (b); --(i))\n#define SZ(v) int(v.size())\n\nusing namespace std;\n//PAIRS:\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n/*~~~~TEMPLATE END~~~~*/\n\n//DEBUGS:\n//#define DEBUG\n\n#ifdef DEBUG\n#define dprintf printf\n#else\n#define dprintf(...)\n#endif\n\nconst long long MOD = 998244353;\nconst ll MAX_N = 100005;\n\nll inv[MAX_N*4+5];\nll fact[MAX_N*4+5];\nll invfact[MAX_N*4+5];\n\nll minv (ll c) {\n    ll ret = 1;\n    ll cP = c;\n    FO (i,0,31) {\n        if ((MOD-2) & (1<<i)) {\n            ret = (ret*cP) % MOD;\n        }\n        cP = (cP*cP) % MOD;\n    }\n    return ret;\n}\n\nvoid precomp() {\n    FO (i,1,400010) {\n        inv[i] = minv(i);\n    }\n    fact[0] = 1;\n    FO (i,1,400010) fact[i] = (fact[i-1]*i) % MOD;\n    invfact[0] = 1;\n    FO (i,1,400010) invfact[i] = (invfact[i-1]*inv[i]) % MOD;\n}\n\nll chs(ll a, ll b) {\n    return ((fact[a] * invfact[b])%MOD * invfact[a-b])%MOD;\n}\n\nstruct solver {\n    int N, M;\n    vector<int> vAm;\n    vector<int> lV;\n    vector<int> rV;\n    solver(int __N, int _M, vector<int> &_vAm, vector<int> &_lV, vector<int> &_rV) {\n        N = __N;\n        M = _M;\n        vAm = _vAm;\n        lV = _lV;\n        rV = _rV;\n    }\n    ll solve() {\n        // rAm contains right side vals, hori must occur.\n        vector <ll> rAm;\n        ll wAm = 0;\n        for (int i : rV) wAm += i;\n        ll hAm = 0;\n        OF (i,M,0) {\n            if (wAm == 0) {\n                if (hAm > 0) rAm.pb(0);\n                else rAm.pb(1);\n            } else {\n                rAm.pb(chs(wAm+hAm-1, wAm-1));\n            }\n            hAm += vAm[i];\n        }\n        reverse(rAm.begin(), rAm.end());\n        FO (i,0,M) dprintf (\"%lld \", rAm[i]);\n        dprintf(\"\\n\");\n        // lAm contains left side vals, hori need not occur.\n        vector <ll> lAm;\n        wAm = 0;\n        for (int i : lV) wAm += i;\n        hAm = 0;\n        FO (i,0,M) {\n            if (wAm == 0) {\n                if (hAm > 0) lAm.pb(0);\n                else lAm.pb(1);\n            } else {\n                lAm.pb(chs(wAm+hAm-1, wAm-1));\n            }\n            hAm += vAm[i];\n        }\n        FO (i,0,M) dprintf (\"%lld \", lAm[i]);\n        dprintf(\"\\n\");\n        FO (i,0,M)\n            if (!vAm[i]) lAm[i] = 0;\n        FO (i,0,M) {\n            if (i) lAm[i] += lAm[i-1];\n            if (vAm[i] == 2) lAm[i] *= 2;\n            lAm[i] %= MOD;\n        }\n        ll ans = 0;\n        FO (i,0,M) {\n            if (vAm[i]) {\n                ans += (lAm[i] * rAm[i])%MOD;\n                ans %= MOD;\n            }\n        }\n        return ans;\n    }\n};\n\nint N, M;\nvector <int> a, b, c, d;\n\nint main() {\n    precomp();\n    scanf (\"%d %d\", &N, &M);\n    FO (i,0,N) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        a.pb(t);\n    }\n    FO (i,0,N) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        b.pb(t);\n    }\n    FO (i,0,M) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        c.pb(t);\n    }\n    FO (i,0,M) {\n        char t;\n        scanf (\" %c\", &t);\n        t = t - '0';\n        d.pb(t);\n    }\n    ll ans = 0;\n    FO (i,0,2) {\n        vector <int> t;\n        FO (i,0,M) {\n            t.pb(c[i]+d[i]);\n        }\n        solver s(N,M,t,a,b);\n        ans += s.solve();\n        dprintf (\"ans: %lld\\n\", ans);\n\n        swap(N,M);\n        swap(a,c);\n        swap(b,d);\n    }\n    printf (\"%lld\\n\", ans % MOD);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\n#define mo 998244353\n#define ll long long\nll inv[MAXN<<2],fac[MAXN<<2],n,x[MAXN],y[MAXN],z,ans,m;\nchar U[MAXN],D[MAXN],L[MAXN],R[MAXN];\ninline ll Cn(ll k,ll b)\n{\nreturn (ll)fac[k]*inv[b]%mo*inv[k-b]%mo;\n}\ninline void solve(int n,int m,char *L,char *R,char *U,char *D)\n{\n\tll tmp=0;\n\tint cl,cr,cu,cd,nowu,nowd,u,d;\n\tcl=cr=cu=cd=nowu=nowd=u=d=0;\n\tfor(int i=1;i<=n;i++) cl+=L[i]-'0',cr+=R[i]-'0';\n\tfor(int i=1;i<=m;i++) cd+=D[i]-'0',cu+=U[i]-'0';\n\tif(cl+cd==0){cout<<\"1\";exit(0);}\n\ttmp=1;\n//\tcout<<cl<<\" \"<<cr<<\" \"<<cd<<\" \"<<cu<<\" \"<<tmp<<endl;\n\tfor(int i=1;i<=m;i++){\n\t\tnowu+=(u=U[i]-'0');nowd+=(d=D[i]-'0');\n\t\tif(u||d){\n\t\t\tif(u&&d) tmp=tmp*2%mo;\n\t\t\tif(cr!=0) ans=(ans+tmp*Cn(cr+cu+cd-nowu-nowd-1,cr-1))%mo;\n\t\t\telse ans+=(cu+cd-nowu-nowd==0)%mo;\n\t\t\tif(cl!=0) tmp=(tmp+Cn(cl+nowu+nowd-1,cl-1))%mo;\n\t\t\telse tmp+=(nowu+nowd==0);\n//\t\t\tcout<<ans<<\" \"<<tmp<<endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfac[0]=1;inv[1]=inv[0]=1;\n\tfor(int i=1;i<=2*MAXN;i++) fac[i]=fac[i-1]*i%mo;\n\tfor(int i=2;i<=2*MAXN;i++) inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=2*MAXN;i++) inv[i]=(ll)inv[i]*inv[i-1]%mo;\n//\tfor(int i=1;i<=n+m<<1;i++) cout<<inv[i]<<endl;\n\tscanf(\"%s%s%s%s\",L+1,R+1,U+1,D+1);\n\tsolve(n,m,L,R,U,D);\n\tsolve(m,n,U,D,L,R);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\n#define mo 998244353\n#define ll long long\nll inv[MAXN<<2],fac[MAXN<<2],n,x[MAXN],y[MAXN],z,ans,m;\nchar U[MAXN],D[MAXN],L[MAXN],R[MAXN];\ninline ll Cn(ll k,ll b){return (ll)fac[k]*inv[b]%mo*inv[k-b]%mo;}\ninline void solve(int n,int m,char *L,char *R,char *U,char *D)\n{\n\tll tmp=0;\n\tll cl,cr,cu,cd,nowu,nowd,u,d;\n\tcl=cr=cu=cd=nowu=nowd=u=d=0;\n\tfor(int i=1;i<=n;i++) cl+=L[i]-'0',cr+=R[i]-'0';\n\tfor(int i=1;i<=m;i++) cd+=D[i]-'0',cu+=U[i]-'0';\n\tif(cl+cd==0){cout<<\"1\";exit(0);}\n\ttmp=1;\n//\tcout<<cl<<\" \"<<cr<<\" \"<<cd<<\" \"<<cu<<\" \"<<tmp<<endl;\n\tfor(int i=1;i<=m;i++){\n\t\tnowu+=(u=U[i]-'0');nowd+=(d=D[i]-'0');\n\t\tif(u||d){\n\t\t\tif(u&&d) tmp=tmp*2%mo;\n\t\t\tif(cr!=0) ans=(ans+tmp*Cn(cr+cu+cd-nowu-nowd-1,cr-1))%mo;\n\t\t\telse ans+=(cu+cd-nowu-nowd==0)%mo;\n\t\t\tif(cl!=0) tmp=(tmp+Cn(cl+nowu+nowd-1,cl-1))%mo;\n\t\t\telse tmp+=(nowu+nowd==0);\n//\t\t\tcout<<ans<<\" \"<<tmp<<endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfac[0]=1;inv[1]=inv[0]=1;\n\tfor(int i=1;i<=4*MAXN-1;i++) fac[i]=fac[i-1]*i%mo;\n\tfor(int i=2;i<=4*MAXN-1;i++) inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=4*MAXN-1;i++) inv[i]=(ll)inv[i]*inv[i-1]%mo;\n//\tfor(int i=1;i<=n+m<<1;i++) cout<<inv[i]<<endl;\n\tscanf(\"%s%s%s%s\",L+1,R+1,U+1,D+1);\n\tsolve(n,m,L,R,U,D);\n\tsolve(m,n,U,D,L,R);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define MAXN 200500\n#define eps 1e-12\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n\tres = 0;T f = 1;char c = getchar();\n\twhile(c < '0' || c > '9') {\n\t\tif(c == '-') f = -1;\n\t\tc = getchar();\n\t}\n\twhile(c >= '0' && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar();\n\t}\n\tres *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n\tif(x < 0) {x = -x;putchar('-');}\n\tif(x >= 10) {\n\t\tout(x / 10);\n\t}\n\tputchar('0' + x % 10);\n}\nconst int MOD = 998244353;\nint N,M;\nchar a[4][MAXN];\nint fac[MAXN * 2],invfac[MAXN * 2],f[MAXN],b[MAXN],sum[4][MAXN],s[MAXN];\nint pw[MAXN],ipw[MAXN],ans;\nint inc(int a,int b) {\n\treturn a + b >= MOD ? a + b - MOD : a + b;\n}\nint mul(int a,int b) {\n\treturn 1LL * a * b % MOD;\n}\nint fpow(int x,int c) {\n\tint res = 1,t = x;\n\twhile(c) {\n\t\tif(c & 1) res = mul(res,t);\n\t\tt = mul(t,t);\n\t\tc >>= 1;\n\t}\n\treturn res;\n}\nvoid update(int &x,int y) {\n\tx = inc(x,y);\n}\nint C(int n,int m) {\n\tif(n < m) return 0;\n\treturn mul(fac[n],mul(invfac[m],invfac[n - m]));\n}\nvoid CalcV() {\n\tmemset(f,0,sizeof(f));\n\tmemset(b,0,sizeof(b));\n\tmemset(s,0,sizeof(s));\n\tint X = sum[0][N],Y,Z;\n\tfor(int i = 0 ; i <= M ; ++i) {\n\t\tif(a[2][i + 1] == '0' && a[3][i + 1] == '0') continue;\n\t\tY = sum[2][i],Z = sum[3][i];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) f[i] = 1;\n\t\t\telse f[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tf[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tX = sum[1][N];\n\tfor(int i = M + 1 ; i >= 1 ; --i) {\n\t\tif(a[2][i - 1] == '0' && a[3][i - 1] == '0') continue;\n\t \tY = sum[2][M] - sum[2][i - 1],Z = sum[3][M] - sum[3][i - 1];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) b[i] = 1;\n\t\t\telse b[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tb[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= M ; ++i) s[i] = s[i - 1] + (a[2][i] == '1' && a[3][i] == '1');\n\tfor(int i = 0 ; i <= M ; ++i) {\n\t\tf[i] = mul(f[i],ipw[s[i]]);\n\t}\n\tfor(int i = M + 1 ; i >= 1 ; --i) {\n\t\tb[i] = inc(b[i + 1],mul(b[i],pw[s[i - 1]]));\n\t}\n\tfor(int i = 1 ; i <= M ; ++i) {\n\t\tupdate(ans,mul(f[i - 1],b[i + 1]));\n\t}\n}\nvoid CalcH() {\n\tmemset(f,0,sizeof(f));\n\tmemset(b,0,sizeof(b));\n\tmemset(s,0,sizeof(s));\n\tint X = sum[2][M],Y,Z;\n\tfor(int i = 0 ; i <= N ; ++i) {\n\t\tif(a[0][i + 1] == '0' && a[1][i + 1] == '0') continue;\n\t\tY = sum[0][i],Z = sum[1][i];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) f[i] = 1;\n\t\t\telse f[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tf[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tX = sum[3][M];\n\tfor(int i = N + 1 ; i >= 1 ; --i) {\n\t\tif(a[0][i - 1] == '0' && a[1][i - 1] == '0') continue;\n\t\tY = sum[0][N] - sum[0][i - 1],Z = sum[1][N] - sum[1][i - 1];\n\t\tif(!X) {\n\t\t\tif(Y == 0 && Z == 0) b[i] = 1;\n\t\t\telse b[i] = 0;\n\t\t}\n\t\telse {\n\t\t\tb[i] = C(X + Y + Z - 1,X - 1);\n\t\t}\n\t}\n\tfor(int i = 1 ; i <= N ; ++i) s[i] = s[i - 1] + (a[0][i] == '1' && a[1][i] == '1');\n\tfor(int i = 0 ; i <= N ; ++i) {\n\t\tf[i] = mul(f[i],ipw[s[i]]);\n\t}\n\tfor(int i = N + 1 ; i >= 1 ; --i) {\n\t\tb[i] = inc(b[i + 1],mul(b[i],pw[s[i - 1]]));\n\t}\n\tfor(int i = 1 ; i <= N ; i++) {\n\t\tupdate(ans,mul(f[i - 1],b[i + 1]));\n\t}\n}\nvoid Solve() {\n\tread(N);read(M);\n\tfor(int i = 0 ; i <= 3 ; ++i) scanf(\"%s\",a[i] + 1);\n\tfor(int i = 0 ; i <= 3 ; ++i) {\n\t\tint T = (i <= 1 ? N : M);\n\t\tfor(int j = 1 ; j <= T ; ++j) {\n\t\t\tsum[i][j] = sum[i][j - 1] + (a[i][j] == '1');\n\t\t}\n\t}\n\tint T = 2 * (N + M) + 10;\n\tfac[0] = 1;\n\tfor(int i = 1 ; i <= T ; ++i) {\n\t\tfac[i] = mul(fac[i - 1],i);\n\t}\n\tinvfac[T] = fpow(fac[T],MOD - 2);\n\tfor(int i = T - 1 ; i >= 0 ; --i) {\n\t\tinvfac[i] = mul(invfac[i + 1],i + 1);\n\t}\n\tpw[0] = 1;\n\tT = max(N,M);\n\tfor(int i = 1 ; i <= T ; ++i) {\n\t\tpw[i] = mul(pw[i - 1],2);\n\t}\n\tipw[0] = 1;\n\tfor(int i = 1 ; i <= T ; ++i) {\n\t\tipw[i] = mul(ipw[i - 1],(MOD + 1) / 2);\n\t}\n\tCalcV();\n\tCalcH();\n\tout(ans);enter;\n}\nint main() {\n#ifdef ivorysi\n\tfreopen(\"f1.in\",\"r\",stdin);\n#endif\n\tSolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5, MOD = 998244353;\nchar A[N], B[N], C[N], D[N];\nint L[N], R[N], f[3 * N], rf[3 * N];\nint mpow(int x, int n) {\n\tint res = 1;\n\twhile (n) {\n\t\tif (n & 1) res = 1LL * res * x % MOD;\n\t\tx = 1LL * x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nint choose(int n, int m) {\n\treturn 1LL * f[n] * rf[n - m] % MOD * rf[m] % MOD;\n}\nint work(int n, int m, char AA[N], char BB[N], char CC[N], char DD[N]) {\n\tstatic char A[N], B[N], C[N], D[N];\n\tint nn = 0, mm = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\tif (AA[i] == '1' || BB[i] == '1') {\n\t\t\tnn ++;\n\t\t\tA[nn] = AA[i];\n\t\t\tB[nn] = BB[i];\n\t\t}\n\t}\n\tfor (int i = 1; i <= m; ++ i) {\n\t\tif (CC[i] == '1' || DD[i] == '1') {\n\t\t\tmm ++;\n\t\t\tC[mm] = CC[i];\n\t\t\tD[mm] = DD[i];\n\t\t}\n\t}\n\tn = nn, m = mm;\n\tint rl = 0, rr = 0;\n\tfor (int i = 1; i <= n; ++ i) {\n\t\trl += A[i] == '1';\n\t\trr += B[i] == '1';\n\t}\n\tL[0] = 1;\n\tint x = 0, y = 0;\n\tfor (int i = 1; i <= m; ++ i) {\n\t\tx += C[i] == '1';\n\t\ty += D[i] == '1';\n\t\tL[i] = (rl == 0) ? 0 : choose(x + y + rl - 1, rl - 1);\n\t}\n\tx = y = 0;\n\tR[m + 1] = 1;\n\tfor (int i = m; i >= 1; -- i) {\n\t\tx += C[i] == '1';\n\t\ty += D[i] == '1';\n\t\tR[i] = (rr == 0) ? 0 : choose(x + y + rr - 1, rr - 1);\n\t}\n\tint ans = 0, tmp = 1;\n\tfor (int i = 1; i <= m; ++ i) {\n\t\ttmp = 1LL * tmp * (C[i] == '1' && D[i] == '1' ? 2 : 1) % MOD;\n\t\t(ans += 1LL * tmp * R[i + 1] % MOD) %= MOD;\n\t\ttmp = (tmp + L[i]) % MOD;\n\t}\n\treturn ans;\n}\nint main() {\n\tf[0] = 1;\n\tfor (int i = 1; i < 3 * N; ++ i) f[i] = 1LL * f[i - 1] * i % MOD;\n\trf[3 * N - 1] = mpow(f[3 * N - 1], MOD - 2);\n\tfor (int i = 3 * N - 2; i >= 0; -- i) rf[i] = 1LL * rf[i + 1] * (i + 1) % MOD;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s%s%s%s\", A + 1, B + 1, C + 1, D + 1);\n\tint ans = work(n, m, A, B, C, D);\n\treverse(A + 1, A + 1 + n);\n\treverse(B + 1, B + 1 + n);\n\t(ans += work(m, n, D, C, A, B)) %= MOD;\n\tprintf(\"%d\\n\", ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cassert>\n#include <numeric>\n#include <string>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long int int64;\n\n\nconst int MOD = 998244353;\n\nvoid sadd(int &a, int b)\n{\n    a += b;\n    if (a >= MOD) a -= MOD;\n}\nint add(int a, int b)\n{\n    sadd(a, b);\n    return a;\n}\nint mul(int a, int b)\n{\n    return (a * 1LL * b) % MOD;\n}\nvoid smul(int &a, int b)\n{\n    a = mul(a, b);\n}\n\nconst int N = (int) 3e5 + 100;\nint fact[N], rfact[N], ri[N];\n\n\nint getC(int n, int k)\n{\n    return mul(fact[n], mul(rfact[n - k], rfact[k] ) );\n}\n\nint solve(int a, int c, int d)\n{\n    return getC(a + c + d - 1, c + d);\n}\n\nint solve(int n, int m, char sa[], char sb[], char sc[], char sd[] )\n{\n    int a = 0, b = 0;\n    int c = 0, d = 0;\n    for (int i = 0; i < n; i++)\n    {\n        a += sa[i] - '0';\n        b += sb[i] - '0';\n    }\n    for (int i = 0; i < m; i++)\n    {\n        c += sc[i] - '0';\n        d += sd[i] - '0';\n    }\n    int _c = 0, _d = 0;\n\n    int ans = 0;\n    int sumDown = 0;\n    for (int i = m - 1; i >= 0; i--)\n    {\n        if (sc[i] == '0' && sd[i] == '0') continue;\n\n        c -= (sc[i] - '0');\n        d -= (sd[i] - '0');\n\n        eprintf(\"b = %d, _c = %d, _d = %d\\n\", b, _c, _d);\n        sadd(sumDown, solve(b, _c, _d) );\n        if (sc[i] == '1' && sd[i] == '1')\n            smul(sumDown, 2);\n\n        _c += (sc[i] - '0');\n        _d += (sd[i] - '0');\n    \n        int cur = solve(a, c, d);\n        eprintf(\"%d) up = %d, sumDown = %d\\n\", i, cur, sumDown);\n        \n        smul(cur, sumDown);\n\n        sadd(ans, cur);\n    }\n    return ans;\n}\n\n\nvoid init()\n{\n    fact[0] = 1;\n    rfact[0] = 1;\n    ri[1] = 1;\n\n    for (int i = 1; i < N; i++)\n    {\n        if (i >= 2) ri[i] = MOD - mul(ri[MOD % i], MOD / i);\n        fact[i] = mul(fact[i - 1], i);\n        rfact[i] = mul(rfact[i - 1], ri[i] );\n\n        if (mul(i, ri[i] ) != 1) throw;\n    }\n}\n\n\nchar a[N], b[N], c[N], d[N];\nint main(int,  char **)\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\n    init();\n\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s%s%s%s\", a, b, c, d);\n\n    int ans = 0;\n    sadd(ans, solve(n, m, a, b, c, d) );\n    sadd(ans, solve(m, n, c, d, a, b) );\n    printf(\"%d\\n\", ans);\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nvpl factor(ll x) {\n    return {{x,1}};\n}\n\ntemplate<int SZ> struct combo {\n    int MOD, fac[SZ+1], ifac[SZ+1];\n    vpl factors;\n    vi cnt[SZ+1];\n    \n    void init(ll _MOD) {\n        MOD = _MOD; factors = factor(MOD);\n        cnt[0].resize(sz(factors));\n        \n        fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ+1) {\n            cnt[i] = cnt[i-1];\n            \n            int I = i;\n            F0R(j,sz(factors)) \n                while (I % factors[j].f == 0) \n                    I /= factors[j].f, cnt[i][j] ++;\n                \n            fac[i] = mul(I,fac[i-1],MOD), ifac[i] = invGeneral(fac[i],MOD);\n        }\n    }\n    \n    ll comb(ll a, ll b) {\n        if (a == b) return 1;\n        if (a < b || b < 0) return 0;\n        ll tmp = mul(mul(fac[a],ifac[b],MOD),ifac[a-b],MOD);\n        return tmp;\n    }\n};\n\ncombo<400005> z;\nint N,M,ans;\nstring A,B,C,D;\n\nbool zero(string s) {\n    trav(x,s) if (x == '1') return 0;\n    return 1;\n}\n\nint numOne(string s) {\n    int ret = 0;\n    trav(x,s) ret += (x == '1');\n    return ret;\n}\n\nint l[MX], r[MX];\n\nint calc(int a, int b, int c) {\n    if (c == 0) return a+b == 0;\n    return z.comb(a+b+c-1,c-1);\n    int ret = 0;\n    F0R(i,c) AD(ret,mul(z.comb(a-1+i,a-1),z.comb(b+c-1-i,b)));\n    return ret;\n}\n\nvoid test() {\n    if (zero(A) && zero(B)) return;\n    int a = 0, b = 0, c = numOne(C);\n    F0R(i,N) {\n        l[i] = 0;\n        if (A[i] == '1' || B[i] == '1') {\n            l[i] = calc(a,b,c);\n            a += (A[i] == '1');\n            b += (B[i] == '1');\n        }\n    }\n    a = 0, b = 0; int d = numOne(D);\n    F0Rd(i,N) {\n        r[i] = 0;\n        if (A[i] == '1' || B[i] == '1') {\n            r[i] = calc(a,b,d);\n            a += (A[i] == '1');\n            b += (B[i] == '1');\n        }\n    }\n    int sum = 0;\n    F0Rd(i,N) {\n        AD(sum,r[i]);\n        if (A[i] == '1' && B[i] == '1') MUL(sum,2);\n        AD(ans,mul(sum,l[i]));\n    }\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N,M,A,B,C,D); // 4,6,7: bad\n    z.init(MOD);\n    if (zero(A) && zero(B) && zero(C) && zero(D)) {\n        pr(1);\n        exit(0);\n    }\n    test();\n    swap(A,C), swap(B,D); swap(N,M);\n    test();\n    pr(ans);\n    // FOR(a,1,6) FOR(b,1,6) pr(a,b,5,calc(a,b,5));\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxf = 400005;\nconst int MOD = 998244353;\n\nll fact[maxf], invfact[maxf];\nchar a[maxf], b[maxf], c[maxf], d[maxf];\nll anspref[maxf];\nint n, m;\n\nll powmod(ll a, ll b)\n{\n    ll ans = 1;\n    ll tmp = a;\n    while (b)\n    {\n        if (b & 1) ans = (ans * tmp) % MOD;\n        tmp = (tmp * tmp) % MOD;\n        b >>= 1;\n    }\n    return ans;\n}\n\nll getc(ll a, ll b)\n{\n    if (b < 0 || b > a) return 0;\n    return fact[a] * invfact[b] % MOD * invfact[a - b] % MOD;\n}\n\nll f3(int x, int y, int z)\n{\n    if (y == 0)\n    {\n        if (x == 0 && z == 0) return 1;\n        return 0;\n    }\n    ll tot = getc(x + y + z, y);\n    return (tot - getc(x + y + z - 1, y) + MOD) % MOD;\n}\n\nint main()\n{\n    fact[0] = 1;\n    invfact[0] = 1;\n    for (int i = 1; i < maxf; i++)\n    {\n        fact[i] = (fact[i - 1] * i) % MOD;\n        invfact[i] = powmod(fact[i], MOD - 2);\n    }\n    \n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", a);\n    scanf(\"%s\", b);\n    scanf(\"%s\", c);\n    scanf(\"%s\", d);\n    int tot = 0;\n    for (int i = 0; i < n; i++)\n    {\n        tot += a[i] == '1';\n        tot += b[i] == '1';\n    }\n    for (int i = 0; i < m; i++)\n    {\n        tot += c[i] == '1';\n        tot += d[i] == '1';\n    }\n    if (tot == 0)\n    {\n        cout << 1 << endl;\n        return 0;\n    }\n    ll answer = 0;\n    for (int IT = 0; IT < 2; IT++)\n    {\n        int y = 0;\n        for (int i = 0; i < n; i++) y += a[i] == '1';\n        int x = 0;\n        int z = 0;\n        for (int i = 0; i < m; i++) if (c[i] == '1' || d[i] == '1')\n        {\n            anspref[i] = f3(x, y, z);\n            if (c[i] == '1' && d[i] == '1') anspref[i] = (anspref[i] * 2) % MOD;\n            \n            x += c[i] == '1';\n            z += d[i] == '1';\n        }\n        \n        y = 0;\n        for (int i = 0; i < n; i++) y += b[i] == '1';\n        x = 0;\n        z = 0;\n        ll curttans = 0;\n        for (int i = m - 1; i >= 0; i--) if (c[i] == '1' || d[i] == '1')\n        {\n            ll curans = f3(x, y, z);\n            answer += anspref[i] * (curttans + curans);\n            answer %= MOD;\n            curttans = (curttans + curans) % MOD;\n            if (c[i] == '1' && d[i] == '1') curttans = (curttans * 2) % MOD;\n            \n            x += c[i] == '1';\n            z += d[i] == '1';\n        }\n        \n        \n        for (int i = 0; i <= max(n, m); i++) swap(a[i], c[i]);\n        for (int i = 0; i <= max(n, m); i++) swap(b[i], d[i]);\n        swap(n, m);\n//         cout << answer << endl;\n    }\n    cout << answer << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nconst ll MOD = 998244353;\nll add(ll x, ll y) {\n\tx += y;\n\tif (x >= MOD) return x - MOD;\n\treturn x;\n}\nll sub(ll x, ll y) {\n\tx -= y;\n\tif (x < 0) return x + MOD;\n\treturn x;\n}\nll mult(ll x, ll y) {\n\treturn (x * y) % MOD;\n}\nll bin_pow(ll x, ll p) {\n\tif (p == 0) return 1;\n\tif (p & 1) return mult(x, bin_pow(x, p - 1));\n\treturn bin_pow(mult(x, x), p / 2);\n}\nll rev(ll x) {\n\treturn bin_pow(x, MOD - 2);\n}\n\nconst int N = 400100;\nll f[N], rf[N];\nll p2[N], rp2[N];\n\nll getC(int n, int k) {\n\tif (k < 0 || k > n) return 0;\n\treturn mult(f[n], mult(rf[k], rf[n - k]));\n}\n\nint n, m;\nchar s[N];\nint a[N], b[N], c[N], d[N];\nll L[N], R[N];\nint sum[N];\n\nll solve() {\n\tfor (int i = 0; i <= n; i++)\n\t\tsum[i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tsum[i + 1] = sum[i];\n\t\tif (a[i] && b[i])\n\t\t\tsum[i + 1]++;\n\t}\n\tint A = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tA += c[i];\n\tint B = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tL[i] = R[i] = 0;\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == 0 && b[i] == 0) continue;\n\t\tif (A == 0) {\n\t\t\tL[i] = (B == 0 ? 1 : 0);\n\t\t} else {\n\t\t\tL[i] = getC(A - 1 + B, B);\n\t\t}\n\t\tB += a[i] + b[i];\n\t}\n\tA = B = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tA += d[i];\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (a[i] == 0 && b[i] == 0) continue;\n\t\tif (A == 0) {\n\t\t\tR[i] = (B == 0 ? 1 : 0);\n\t\t} else {\n\t\t\tR[i] = getC(A - 1 + B, B);\n\t\t}\n\t\tB += a[i] + b[i];\n\t}\n\tll ans = 0;\n\tll curSum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcurSum = add(curSum, mult(L[i], rp2[sum[i]]));\n\t\tans = add(ans, mult(mult(curSum, R[i]), p2[sum[i + 1]]));\n\t}\n\treturn ans;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tf[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tf[i] = mult(f[i - 1], i);\n\trf[N - 1] = rev(f[N - 1]);\n\tfor (int i = N - 1; i > 0; i--)\n\t\trf[i - 1] = mult(rf[i], i);\n\tp2[0] = 1;\n\tfor (int i = 1; i < N; i++)\n\t\tp2[i] = add(p2[i - 1], p2[i - 1]);\n\trp2[0] = 1;\n\tfor (int i = 1; i < N; i++) {\n\t\trp2[i] = rp2[i - 1];\n\t\tif (rp2[i] & 1) rp2[i] += MOD;\n\t\trp2[i] >>= 1;\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < n; i++)\n\t\ta[i] = (int)s[i] - '0';\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < n; i++)\n\t\tb[i] = (int)s[i] - '0';\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < m; i++)\n\t\tc[i] = (int)s[i] - '0';\n\tscanf(\"%s\", s);\n\tfor (int i = 0; i < m; i++)\n\t\td[i] = (int)s[i] - '0';\n\n\tll ans = solve();\n\tswap(n, m);\n\tswap(a, c);\n\tswap(b, d);\n\tans = add(ans, solve());\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define P 998244353\n#define M 300010\nint F[M], IF[M];\n\nvoid gcd(int a,int b,int &x,int &y) {\n  if(b==0){x=1,y=0;return;}\n  gcd(b,a%b,y,x),y-=a/b*x;\n}\nint inv(int n) {\n  int x,y;gcd(n,P,x,y);\n  if(x<0)x+=P;return x;\n}\nint C(int n, int k) {\n\tif (k < 0 || n < k) return 0;\n\treturn (ll)F[n]*IF[k]%P*IF[n-k]%P;\n}\nint gg(int u, int v, int m) {\n\tif (u == 0 && v == 0 && m == 0) return 1;\n\treturn C(u+v+m-1, m-1);\n}\n\n#define N 100010\nint n, m;\nstring a, b, c, d;\nint f[N], lu[N], lv[N];\n\nint ff() {\n\tmemset(f, 0, sizeof f);\n\tmemset(lu, 0, sizeof lu);\n\tmemset(lv, 0, sizeof lv);\n\tint le = 0;\n\tint ri = 0;\n\tfor (int i = 0; i < m; i ++) {\n\t\tif (c[i] == '1') le ++;\n\t\tif (d[i] == '1') ri ++;\n\t}\n\t\n\tint u = 0, v = 0;\n\t//cout << n << \" \" << m << \" \" << a.length() << \" \" << b.length() << \" \" << c.length() << \" \" << d.length() << endl;\n\t//cout << le << \" \" << ri << endl;\n\t\n\tfor (int i = 0; i < n; i ++) {\n\t\tint w = 0;\n\t\tif (a[i] == '1') w++;\n\t\tif (b[i] == '1') w++;\n\t\tf[i] = (ll)gg(u, v, le)*w%P;\n\t\tlu[i] = u;\n\t\tlv[i] = v;\n\t\tif (a[i] == '1') u++;\n\t\tif (b[i] == '1') v++;\n\t}\n\t\n\tfor (int i = 0; i < n-1; i ++) {\n\t\tif (a[i+1] == '1' && b[i+1] == '1')\n\t\t\t(f[i+1] += (ll)f[i]*2%P) %= P;\n\t\telse\n\t\t\t(f[i+1] += f[i]) %= P;\n\t}\n\t\n\tint S = 0;\n\tu = v = 0;\n\tfor (int i = n-1; i >= 0; i--) {\n\t\tint w = 0;\n\t\tif (a[i] == '1') w++;\n\t\tif (b[i] == '1') w++;\n\t\tif (w >= 1) S = (S + (ll)f[i]*gg(u, v, ri)%P)%P;\n\t\tif (a[i] == '1') u++;\n\t\tif (b[i] == '1') v++;\n\t}\n\t\n\treturn S;\n}\n\nint main() {\n\tF[0]=1;for(int i=1;i<M;i++)F[i]=(ll)F[i-1]*i%P;\n\tIF[M-1]=inv(F[M-1]);for(int i=M-1;i;i--)IF[i-1]=(ll)IF[i]*i%P;\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\tif (a == string(n, '0') && a == string(n, '0') && c == string(m, '0') && d == string(m, '0')) {\n\t\tputs (\"1\");\n\t\treturn 0;\n\t}\n\tint S = 0;\n\tS += ff();\n\tswap(a, c);\n\tswap(b, d);\n\tswap(n, m);\n\t(S += ff()) %= P;\n\tcout << S << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ayy\n// ' lamo\n#include <bits/stdc++.h>\n#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\nconst ld eps=1e-8;\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n// const int P=1e9+7;\nconst int P=998244353; // = 119 * 2**23 + 1\n\n\n\n\n\n\n\nconst int N=100<<10;\nbitset<N> A,B,C,D;\nint n,m;\nint F[N*4],iF[N*4],pow2[N*4];\nint I4,I2;\n\nint powq(int x,int e) {\n\tif(!e) return 1;\n\tif(e&1) return int(1LL*x*powq(x,e-1)%P);\n\tx=powq(x,e>>1);\n\treturn int(1LL*x*x%P);\n}\nvoid add(int &x,int y) {\n\tx+=y;\n\tif(x>=P) x-=P;\n}\n\nvoid init_math(int n) {\n\tF[0]=1;\n\tfor(int i=1;i<=n;i++) F[i]=int(1LL*F[i-1]*i%P);\n\tiF[n]=powq(F[n],P-2);\n\tfor(int i=n;--i>=0;) iF[i]=int(1LL*iF[i+1]*(i+1)%P);\n\n\tpow2[0]=1;\n\tfor(int i=1;i<=n;i++) pow2[i]=pow2[i-1]*2%P;\n\n\tI4=powq(4,P-2);\n\tI2=powq(2,P-2);\n}\n\nvoid read(bitset<N> &bs) {\n\tstring s; cin>>s;\n\tfor(int i=0;i<(int)s.size();i++) bs[i]=(s[i]=='1');\n}\n\nint CC(int n,int k) {\n\tassert(0<=k && k<=n);\n\tassert(n>=0);\n\treturn int(1LL*F[n]*iF[k]%P*iF[n-k]%P);\n}\nint f1(int n,int a,int b,int ec) {\n\t// cerr<<\"f1(\"<<n<<\",\"<<a<<\",\"<<b<<\",\"<<ec<<\") = \"<<(n ? CC(n-1+a+b,a+b) : pow2[ec])<<endl;\n\treturn n ? CC(n-1+a+b,a+b) : pow2[ec];\n}\n\n\n\nint go() {\n\tvector<int> L,R,q;\n\n\tint a=0,b=0,ec=0;\n\tint lc=(int)C.count();\n\tint rc=(int)D.count();\n\n\tint tc=0;\n\tfor(int i=0;i<n;i++) if(A[i] && B[i]) ++tc;\n\n\tfor(int i=0;i<n;i++) {\n\t\tif(!A[i] && !B[i]) continue;\n\t\tL.pb(f1(lc,a,b,ec));\n\t\t// if(A[i] && B[i]) L.back()*=2, L.back()%=P, ++ec;\n\t\tL.back() = int(1LL*L.back()*powq(I2,ec)%P);\n\t\tif(A[i] && B[i]) ++ec;\n\t\tif(A[i]) ++a;\n\t\tif(B[i]) ++b;\n\t\tq.pb(i);\n\n\t\tif(!lc && L.size()>1u) L.back()=0;\n\t}\n\n\ta=b=ec=0;\n\tfor(int i=n;--i>=0;) {\n\t\tif(!A[i] && !B[i]) continue;\n\t\tR.pb(f1(rc,a,b,ec));\n\t\t// if(A[i] && B[i]) R.back()*=2, R.back()%=P, ++ec;\n\t\tR.back() = int(1LL*R.back()*powq(2,tc-ec)%P);\n\t\tif(A[i] && B[i]) ++ec;\n\t\tif(A[i]) ++a;\n\t\tif(B[i]) ++b;\n\n\t\tif(!rc && R.size()>1u) R.back()=0;\n\t}\n\n\treverse(R.begin(),R.end());\n\n\tassert(L.size()==R.size());\n\tint w=(int)L.size();\n\n\tint RS=0;\n\tint Z=0;\n\tfor(int i=w;--i>=0;) {\n\t\tadd(RS,R[i]);\n\t\tadd(Z,int(1LL*RS*L[i]%P));\n\t\t// if(A[q[i]] && B[q[i]]) {\n\t\t// \tadd(Z,int(1LL*RS*L[i]%P));\n\t\t// \t// add(Z,int(P-1LL*L[i]*R[i]%P*I4*2%P));\n\t\t// \tadd(RS,R[i]);\n\t\t// }\n\t}\n\t// cerr<<\"got Z=\"<<Z<<\" via L={\";\n\t// for(int x:L) cerr<<x<<\",\";\n\t// cerr<<\"} and R={\";\n\t// for(int x:R) cerr<<x<<\",\";\n\t// cerr<<\"}\"<<endl;\n\treturn Z;\n}\n\n\n\nint32_t main() {\n\tcin>>n>>m;\n\tinit_math(max(n+m+n+m,N*3)+17);\n\tread(A),read(B),read(C),read(D);\n\n\tint z1=go();\n\tswap(n,m);\n\tswap(A,C);\n\tswap(B,D);\n\tint z2=go();\n\n\tcerr<<z1<<\" \"<<z2<<endl;\n\tif(!A.count() && !B.count() && !C.count() && !D.count())\n\t\tassert(!z1&&!z2), cout<<1<<endl;\n\telse cout<<(z1+z2)%P<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Maxn 100007\n#define modp 998244353\nusing namespace std;\nint read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile (ch<'0'||ch>'9'){if (ch=='-') f=-1;ch=getchar();}\n\twhile (ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint n,m,cnt=0;\nint pre[350007],inv[350007];\nchar a[Maxn],b[Maxn],c[Maxn],d[Maxn];\nbool x[Maxn],y[Maxn],z[Maxn],w[Maxn];\nlong long power(long long a,long long b)\n{\n\tlong long res=1,now=a,left=b;\n\twhile (left>0)\n\t{\n\t\tif (left%2==1) res=(1LL*res*now)%modp;\n\t\tnow=(1LL*now*now)%modp;\n\t\tleft/=2;\n\t}\n\treturn res%modp;\n}\nint calc(int x,int y)\n{\n\tif (x<y) return 0;\n\tint res=(1LL*pre[x]*inv[y])%modp;\n\tres=(1LL*res*inv[x-y])%modp;\n\treturn res;\n}\nint get(int a,int b,int c)\n{\n\tif (a==0&&b==0&&c==0) return 1;\n\telse if (b==0) return 0;\n\telse return calc(a+b+c-1,b-1);\n}\nint solve()\n{\n\tint cnt1=0,cnt2=0;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (x[i]) ++cnt1;\n\t\tif (y[i]) ++cnt2;\n\t}\n\tint tot1=0,tot2=0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (z[i]) ++tot1;\n\t\tif (w[i]) ++tot2;\n\t}\n\tint res=0,del=0;\n\tint p=0,q=0;\n\tfor (int i=1;i<=m;i++)\n\t{\n\t\tif (z[i]==false&&w[i]==false) continue;\n\t\tdel=(del+get(p,cnt1,q))%modp;\n\t\tif (z[i]&&w[i]) del=(2LL*del)%modp;\n\t\tif (z[i]) ++q,--tot1;\n\t\tif (w[i]) ++p,--tot2;\n\t\tres=(res+1LL*del*get(tot1,cnt2,tot2)%modp)%modp;\n\t}\n\treturn res%modp;\n}\nint main()\n{\n\tn=read(),m=read();\n\tpre[0]=1;\n\tfor (int i=1;i<=350000;i++)\n\t\tpre[i]=(1LL*pre[i-1]*i)%modp;\n\tinv[350000]=power(pre[350000],modp-2)%modp;\n\tfor (int i=350000;i;i--)\n\t\tinv[i-1]=(1LL*inv[i]*i)%modp;\n\tscanf(\"%s\",a);\n\tscanf(\"%s\",b);\n\tscanf(\"%s\",c);\n\tscanf(\"%s\",d);\n\tmemset(x,false,sizeof(x));\n\tmemset(y,false,sizeof(y));\n\tmemset(z,false,sizeof(z));\n\tmemset(w,false,sizeof(w));\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tif (a[i]=='0') x[i+1]=false; else x[i+1]=true;\n\t\tif (b[i]=='0') y[i+1]=false; else y[i+1]=true;\n\t\tif (x[i+1]) ++cnt;\n\t\tif (y[i+1]) ++cnt;\n\t}\n\tfor (int i=0;i<m;i++)\n\t{\n\t\tif (c[i]=='0') z[i+1]=false; else z[i+1]=true;\n\t\tif (d[i]=='0') w[i+1]=false; else w[i+1]=true;\n\t\tif (z[i+1]) ++cnt;\n\t\tif (w[i+1]) ++cnt;\n\t}\n\tif (cnt==0)\n\t{\n\t\tprintf(\"%d\\n\",1);\n\t\treturn 0;\n\t}\n\tint ans=solve()%modp;\n\tswap(x,z);\n\tswap(y,w);\n\tswap(n,m);\n\tans=(ans+solve())%modp;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define maxn 401000\nusing namespace std;\nint fac[maxn],inv[maxn],n,m,pw[maxn],pw2[maxn],f[maxn],g[maxn],s[maxn],t[maxn];\nchar A[maxn],B[maxn],C[maxn],D[maxn];\nint qpow(int a,int b){\n\tint ans=1,tmp=a;\n\tfor(;b;b>>=1,tmp=1ll*tmp*tmp%mod)\n\t\tif(b&1)ans=1ll*ans*tmp%mod;\n\treturn ans;\n}\nint gC(int x,int y){\n\tif(x>y||x<0)return 0;\n\treturn 1ll*fac[y]*inv[x]%mod*inv[y-x]%mod;\n}\nint sol(int n,int m,char A[],char B[],char C[],char D[]){\n\tfor(int i=1;i<=m;++i)s[i]=(C[i]=='1'&&D[i]=='1')+s[i-1];\n\tfor(int i=1;i<=m;++i)t[i]=(C[i]=='1')+t[i-1]+(D[i]=='1');\n\tint x=0,y=0,ans=0;\n\tfor(int i=1;i<=n;++i)x+=(A[i]=='1'),y+=(B[i]=='1');\n\tmemset(f,0,sizeof(f)),memset(g,0,sizeof(g));\n\tfor(int i=0;i<=m;++i){\n\t\tf[i]=gC(x,t[i]+x);\n\t\tif(t[i])f[i]-=gC(x,t[i]+x-1);\n\t\tf[i]=1ll*f[i]*pw[s[i]]%mod;\n\t\tif(C[i+1]=='0'&&D[i+1]=='0')f[i]=0;\n\t}\n\tfor(int i=1;i<=m+1;++i){\n\t\tg[i]=gC(y,t[m]-t[i-1]+y);\n\t\tif(g[i])g[i]-=gC(y,t[m]-t[i-1]+y-1);\n\t\tg[i]=1ll*g[i]*pw2[s[i-1]]%mod;\n\t\tif(C[i-1]=='0'&&D[i-1]=='0')g[i]=0;\n\t}\n\tfor(int i=1;i<=m;++i)f[i]=(f[i-1]+f[i])%mod;\n\tfor(int i=1;i<=m;++i)ans=(ans+1ll*f[i-1]*g[i+1])%mod;\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=2*(n+m);++i)fac[i]=1ll*fac[i-1]*i%mod;\n\tinv[2*(n+m)]=qpow(fac[2*(n+m)],mod-2);\n\tfor(int i=2*(n+m)-1;i>=1;--i)inv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tpw[0]=pw2[0]=1;\n\tfor(int i=1;i<=max(n,m);++i)pw[i]=1ll*pw[i-1]*(mod+1)/2%mod,pw2[i]=1ll*pw2[i-1]*2%mod;\n\tscanf(\"%s%s%s%s\",A+1,B+1,C+1,D+1);\n\tfor(int i=1;i<=m;++i)if(A[i]=='1'||B[i]=='1'||C[i]=='1'||D[i]=='1')goto nxt;\n\tputs(\"1\");\n\treturn 0;\n\tnxt:;\n\tprintf(\"%d\",(sol(n,m,A,B,C,D)+sol(m,n,C,D,A,B))%mod);\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=998244353;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nll fac[500111],ifac[500111];\nll kissme(ll x,ll k){return k==0?1:kissme(x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n,m;\nchar sa[100111],sb[100111],sc[100111],sd[100111];\nll pre[100111],suf[100111],pre2[100111];\nll C(ll x,ll y){return x<y?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tint cntc=0;\n\tint cntd=0;\n\tfor(int i=1;i<=m;i++)cntc+=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)cntd+=sd[i]=='1';\n\tint cnta=0,cntb=0;;\n\tpre[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntc==0&&cnta==0&&cntb==0)pre[i]=1;\n\t\telse pre[i]=C(cntc+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n\tcnta=cntb=0;\n\tsuf[n+1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntd==0&&cnta==0&&cntb==0)pre[i]=1;\n\t\telse suf[i]=C(cntd+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n//\tfor(int i=0;i<=n+1;i++)cerr<<pre[i]<<\" \";cerr<<endl;\n//\tfor(int i=0;i<=n+1;i++)cerr<<suf[i]<<\" \";cerr<<endl;\n\t\n\tll ret=0;\n\tmemset(pre2,0,sizeof(pre2));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(sa[i]-'0'+sb[i]-'0'==1)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse if(sa[i]-'0'+sb[i]-'0'==2)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])*2%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse pre2[i]=pre2[i-1];\n//\t\tcerr<<pre2[i]<<\" \";\n\t}\n\treturn ret%mod;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=500005;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[500005]=kissme(fac[500005],mod-2);\n\tfor(int i=500004;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",sa+1);\n\tscanf(\"%s\",sb+1);\n\tscanf(\"%s\",sc+1);\n\tscanf(\"%s\",sd+1);\n\tbool ok=0;\n\tfor(int i=1;i<=n;i++)ok|=sa[i]=='1';\n\tfor(int i=1;i<=n;i++)ok|=sb[i]=='1';\n\tfor(int i=1;i<=m;i++)ok|=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)ok|=sd[i]=='1';\n\t\n\tll ans=0;\n\tans+=solve();\n\tswap(sa,sc);\n\tswap(sb,sd);\n\tswap(n,m);\n\tans+=solve();\n\tif(!ok)ans++;\n\tcout<<ans%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n\nusing namespace std;\n\nconst int maxn = 300100;\nconst int base = 998244353;\n\nint n,m,sum_a,sum_b,sum_up,sum_down,ans,inv[maxn],L[maxn],R[maxn],a[5][maxn],fac[maxn],tot;\n\nint pw(int a,int n) {\n    if (n==0) return 1;\n    if (n==1) return a;\n    int tg = pw(a,n/2);\n    tg = (1ll*tg*tg) % base;\n    if (n%2==0) return tg;\n    return (1ll*tg*a) % base;\n}\n\nvoid init() {\n    inv[0]=1;\n    fac[0]=1;\n    for (int i=1;i<=maxn;i++) fac[i] = (1ll*fac[i-1]*i) % base;\n    for (int i=1;i<=maxn;i++) inv[i] = pw(fac[i],base-2);\n}\n\nint C(int k,int n) {\n    if (k > n) return 0;\n    return 1ll*fac[n] * inv[k] % base * inv[n-k] % base;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n  //  freopen(\"in.txt\",\"r\",stdin);\n    cin>>n>>m;\n    init();\n    for (int i=1;i<=4;i++) {\n        for (int j=1;j<=((i<=2)?n:m);j++) {\n            char ch;\n            cin>>ch;\n            a[i][j] = ch - '0';\n        }\n    }\n  ans =0;\n   // cout<<C(1,3)<<endl;\n   // cout<<inv[2]<<endl;\n    tot=0;\n    for (int times =1;times<=2;times++) {\n        sum_a = sum_b = sum_up = sum_down = 0;\n        for (int i=1;i<=n;i++) {\n            sum_a += a[1][i];\n            sum_b += a[2][i];\n        }\n        tot += sum_a + sum_b;\n        for (int i=1;i<=m;i++) {\n            if (a[3][i]+a[4][i]==0) {\n                L[i] =0;\n            } else {\n                if (sum_a ==0 & sum_up >0) L[i]=0;\n                else L[i] =((sum_a == 0) ? 1 : C(sum_a-1,sum_a + sum_up - 1));\n            }\n            sum_up += a[3][i] + a[4][i];\n        }\n        for (int i=m;i>=1;i--) {\n            if (a[3][i]+a[4][i]==0) {\n                R[i] =0;\n            } else {\n                if (sum_b ==0 & sum_down >0) R[i]=0;\n                else R[i] =((sum_b == 0) ? 1 : C(sum_b-1,sum_b + sum_down - 1));\n            }\n            sum_down += a[3][i] + a[4][i];\n        }\n        int sum=0;\n        for (int i=1;i<=m;i++) {\n            //cout<<L[i]<<\" \"<<R[i]<<endl;\n            sum = (sum + L[i]) % base;\n            sum = (1ll* sum * max(1,a[3][i]+a[4][i])) % base;\n            ans = (ans + 1ll*sum*R[i]%base) % base;\n        }\n\n        swap(n,m);\n        swap(a[1],a[3]);\n        swap(a[2],a[4]);\n    }\n    if (tot==0) ans =1;\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\nconst int mod = 998244353;\n\nint res;\nint f[N], g[N];\nint prd[N * 3], inv[N * 3];\n\nint C(int n, int k) {\n\tif (k < 0) return n < 0;\n\treturn 1LL * prd[n] * inv[n - k] % mod * inv[k] % mod; \n}\n\nint pw(int x, int y) {\n\tif (!y) return 1;\n\tint ret = pw(x, y >> 1); ret = 1LL * ret * ret % mod;\n\tif (y & 1) ret = 1LL * ret * x % mod; return ret;\n}\n\nvoid solve(int n, int m, string a, string b, string c, string d) {\n\tint cntc, cntd;\n\tcntc = cntd = 0;\n\tfor (int i = 1; i <= m; ++i) {\n\t\tcntc += c[i] == '1', cntd += d[i] == '1';\n\t}\n\tf[1] = g[n] = 1;\n\tint cnta, cntb;\n\tcnta = cntb = 0;\n\tfor (int i = 1; i < n; ++i) {\n\t\tcnta += a[i] == '1', cntb += b[i] == '1';\n\t\tf[i + 1] = C(cnta + cntb + cntc - 1, cntc - 1);\n\t}\n\tcnta = cntb = 0;\n\tfor (int i = n; i > 1; --i) {\n\t\tcnta += a[i] == '1', cntb += b[i] == '1';\n\t\tg[i - 1] = C(cnta + cntb + cntd - 1, cntd - 1);\n\t}\n\tint sum = 0, cur = 1;\n\tfor (int i = n; i >= 1; --i) {\n\t\tint cnt = 0;\n\t\tcnt += a[i] == '1', cnt += b[i] == '1';\n\t\tif (!cnt) continue;\n\t\tcur = cur * cnt % mod;\n\t\tsum = (sum + 1LL * cur * f[i]) % mod;\n\t}\n\tfor (int i = n; i >= 1; --i) {\n\t\tint cnt = 0;\n\t\tcnt += a[i] == '1', cnt += b[i] == '1';\n\t\tif (!cnt) continue;\n\t\tres = (res + 1LL * sum * g[i]) % mod;\n\t\tsum = (sum - 1LL * cnt * f[i]) % mod;\n\t\tif (sum < 0) sum += mod;\n\t\tsum = 1LL * sum * pw(cnt, mod - 2) % mod;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tprd[0] = inv[0] = 1;\n\tfor (int i = 1; i < 3 * N; ++i) {\n\t\tprd[i] = 1LL * i * prd[i - 1] % mod;\n\t\tinv[i] = pw(prd[i], mod - 2);\n\t}\n\tint n, m;\n\tstring a, b, c, d;\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\tbool have = 0;\n\ta = \" \" + a, b = \" \" + b, c = \" \" + c, d = \" \" + d; \n\tfor (int i = 1; i <= n; ++i) {\n\t\thave |= a[i] == '1' || b[i] == '1';\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\thave |= c[i] == '1' || d[i] == '1';\n\t}\n\tif (!have) {\n\t\tcout << 1; return 0;\n\t}\n\tsolve(n, m, a, b, c, d);\n\tsolve(m, n, c, d, a, b);\n\tcout << res; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MOD 998244353LL\n\nusing namespace std;\n\ntypedef long long ll;\n\nll factorials[300001];\nll invFactorials[300001];\n\n// Calculates a^b mod n.\nll powMod(ll a, ll b, ll n) {\n  if (b == 0) return 1;\n  ll res = 1;\n  while (b > 1) {\n    if (b & 1) res = (a * res) % n;\n    a = (a * a) % n;\n    b /= 2;\n  }\n  return (a * res) % n;\n}\n\n// Calculates binomial coefficient n choose k.\nll binom(ll n, ll k) {\n  if (k > n) return 0;\n  return factorials[n] * invFactorials[k] % MOD * invFactorials[n - k] % MOD;\n}\n\n// Calculates the number of paintings with x horizontal persons, y persons from\n// the top and z persons from the bottom under the assumption that a horizontal\n// person moves first.\nll countSubs(int x, int y, int z) {\n  if (x == 0) {\n    if (y == 0 && z == 0) return 1;\n    return 0;\n  }\n  return binom(x + y + z - 1, x - 1);\n}\n\n// Counts the number of different paintings assuming that the first person moves\n// vertically. Call again with the mirrored instance to get total number.\nll solve(int n, int m, string &a, string &b, string &c, string &d) {\n  int left = 0, right = 0, bottomRight = 0, topRight = 0;\n  for (int i = 0; i < n; i++) {\n    if (a[i] == '1') left++;\n    if (b[i] == '1') right++;\n  }\n  for (int i = 0; i < m; i++) {\n    if (c[i] == '1') topRight++;\n    if (d[i] == '1') bottomRight++;\n  }\n  ll result = 0, prefix = 0;\n  int bottomLeft = 0, topLeft = 0;\n  for (int i = 0; i < m; i++) {\n    if (c[i] == '0' && d[i] == '0') continue;\n    prefix += countSubs(left, bottomLeft, topLeft);\n    prefix %= MOD;\n    if (c[i] == '1' && d[i] == '1') {\n      prefix *= 2;\n      prefix %= MOD;\n    }\n    if (c[i] == '1') {\n      topLeft++;\n      topRight--;\n    }\n    if (d[i] == '1') {\n      bottomLeft++;\n      bottomRight--;\n    }\n    result += prefix * countSubs(right, bottomRight, topRight);\n    result %= MOD;\n  }\n  return result;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(NULL);\n\n  // Precalculate factorials and inverse factorials.\n  factorials[0] = 1;\n  invFactorials[0] = 1;\n  for (ll i = 1; i <= 300000; i++) {\n    factorials[i] = factorials[i - 1] * i % MOD;\n    invFactorials[i] = powMod(factorials[i], MOD - 2, MOD);\n  }\n\n  ll n, m;\n  cin >> n >> m;\n  string a, b, c, d;\n  cin >> a >> b >> c >> d;\n\n  // If there are no persons at all, the answer is 1.\n  bool anyPerson = false;\n  for (int i = 0; i < n; i++) {\n    anyPerson |= a[i] == '1';\n    anyPerson |= b[i] == '1';\n  }\n  for (int i = 0; i < m; i++) {\n    anyPerson |= c[i] == '1';\n    anyPerson |= d[i] == '1';\n  }\n  if (!anyPerson) {\n    cout << \"1\" << endl;\n    return 0;\n  }\n\n  // Assume first person moves vertically. Then swap instance to consider case\n  // where first person moves horizontally.\n  ll result = (solve(n, m, a, b, c, d) + solve(m, n, c, d, a, b)) % MOD;\n  cout << result << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tint sl = x;\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\tint sr = x;\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tint sum = 0;\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t\tsum += A[it][j];\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tcout<<1<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, p = 998244353;\nchar a[100020];\nchar b[100020];\nchar c[100020];\nchar d[100020];\nlong long v[500020];\nlong long u[500020];\nlong long ans;\nint a1, b1, c1, d1;\nint f[100020];\nint g[100020];\nlong long C(int n, int m) {\n\tif (n == -1 && m == -1) {\n\t\treturn 1;\n\t}\n\tif (m < 0) {\n\t\treturn 0;\n\t}\n\treturn u[n] * v[m] % p * v[n - m] % p;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s%s%s%s\", a, b, c, d);\n\tv[1] = 1;\n\tfor (int i = 2; i <= 500010; i++) {\n\t\tv[i] = v[p % i] * (p - p / i) % p;\n\t}\n\tv[0] = u[0] = u[1] = 1;\n\tfor (int i = 2; i <= 500010; i++) {\n\t\tv[i] = v[i] * v[i - 1] % p;\n\t\tu[i] = u[i - 1] * i % p;\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\tif (a1 == 0 && b1 == 0 && c1 == 0 && d1 == 0) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\n\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i == 0) {\n\t\t\tf[i] = 0;\n\t\t} else {\n\t\t\tf[i] = f[i - 1];\n\t\t}\n\t\tif (c[i] == '1' || d[i] == '1') {\n//\t\t\tcerr << \"?\" << C(c1 + d1 + a1 - 1, a1 - 1) << ' ' << a1 << ' ' << b1 << ' ' << c1 << ' ' << d1 << endl;\n\t\t\tf[i] = (f[i] + C(c1 + d1 + a1 - 1, a1 - 1)) % p;\n\t\t\tif (c[i] == '1' && d[i] == '1') {\n\t\t\t\tf[i] = f[i] * 2 % p;\n\t\t\t}\n\t\t}\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\tc1 = d1 = 0;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (c[i] == '1' || d[i] == '1') {\n\t\t\tans = (ans + f[i] * C(c1 + d1 + b1 - 1, b1 - 1)) % p;\n\t\t}\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\n\n\n\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tf[i] = 0;\n\t\t} else {\n\t\t\tf[i] = f[i - 1];\n\t\t}\n\t\tif (a[i] == '1' || b[i] == '1') {\n//\t\t\tcerr << \"?\" << C(a1 + b1 + c1 - 1, c1 - 1) << ' ' << a1 << ' ' << b1 << ' ' << c1 << ' ' << d1 << endl;\n\t\t\tf[i] = (f[i] + C(a1 + b1 + c1 - 1, c1 - 1)) % p;\n\t\t\tif (a[i] == '1' && b[i] == '1') {\n\t\t\t\tf[i] = f[i] * 2 % p;\n\t\t\t}\n\t\t}\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (a[i] == '1' || b[i] == '1') {\n\t\t\tans = (ans + f[i] * C(a1 + b1 + d1 - 1, d1 - 1)) % p;\n\t\t}\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//my vegetable has exploded. :(\n#include<bits/stdc++.h>\n#define max(x,y) (x>y?x:y)\n#define min(x,y) (x<y?x:y)\n#define MM(x,y) memset(x,y,sizeof(x))\n#define MCPY(a,b) memcpy(a,b,sizeof(b))\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define fi first\n#define se second\nusing namespace std;\n#define nl puts(\"\")\n#define int long long\n\ninline int quickpow(int m,int n,int p){int b=1;while(n){if(n&1)b=b*m%p;n=n>>1;m=m*m%p;}return b;}\ninline int getinv(int x,int p){return quickpow(x,p-2,p);}\ninline int read(void){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){f=ch=='-'?-1:1;ch=getchar();}\n    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n    return x * f;\n}\nconst int MAXN = 2e5 + 10;\nconst int Mod = 998244353;\nconst int inv2 = getinv(2,Mod);\nint inv[MAXN],fac[MAXN],n,m,Ans;\nchar A[MAXN],B[MAXN],C[MAXN],D[MAXN];\nint a[MAXN],b[MAXN];\ninline void init(void){\n    inv[0]=inv[1]=fac[0]=1;\n    rep(i,1,2e5) fac[i] = 1LL * fac[i-1] * i % Mod;\n    inv[200000] = getinv(fac[200000],Mod);\n    per(i,2e5-1,1) inv[i] = inv[i+1] * (i+1) % Mod;\n}\n///------------------head------------------\ninline int Combine(int n,int m){return fac[n] * inv[m] % Mod * inv[n-m] % Mod;}\ninline void calc(int n,int m,char *A,char *B,char *C,char *D){\n    MM(a,0); MM(b,0);\n    a[0] = b[m+1] = 1;\n    int c1=0,c2=0,ret=0;\n    rep(i,1,n) c2 += A[i] == '1';\n    rep(i,1,m){\n        if (D[i]=='1') ++c1;\n        if (C[i]=='1') ++c1;\n        a[i] = Combine(c1+c2,c1);\n        if (c1) a[i] = (a[i] - Combine(c1+c2-1,c1-1) + Mod) % Mod;\n    }\n    c1 = 0,c2 = 0;\n    rep(i,1,n) c2 += B[i] == '1';\n    per(i,m,1){\n        if (D[i]=='1') ++c1;\n        if (C[i]=='1') ++c1;\n        b[i] = Combine(c1+c2,c1);\n        if (c1) b[i] = (b[i] - Combine(c1+c2-1,c1-1) + Mod) % Mod;\n    }\n    int t = 1;\n    rep(i,0,m) {\n        if (i > 0 && C[i] == '1' && D[i] == '1') t = t * inv2 % Mod;\n        a[i] = a[i] * t % Mod;\n        if (i <= m && C[i+1] == '0' && D[i+1] == '0') a[i] = 0;\n    }\n    rep(i,1,m) a[i]=(a[i-1]+a[i])%Mod;\n    t=1;\n    rep(i,1,m+1)\n    {\n        b[i] = b[i] * t % Mod;\n        if (i <= m && C[i] == '1' && D[i] == '1') t = t * 2 % Mod;\n        if (i > 1 && C[i-1] == '0' && D[i-1] == '0') b[i] = 0;\n    }\n    rep(i,1,m) ret = (ret + a[i-1] * b[i+1]) % Mod;\n    Ans = (Ans + ret) % Mod;\n}\nsigned main(signed argc, char *argv[])\n{\n    init();\n    n=read();m=read();\n    scanf(\"%s\",A+1); scanf(\"%s\",B+1); scanf(\"%s\",C+1); scanf(\"%s\",D+1);\n    int ok=0;\n    rep(i,1,n) ok|=(A[i]=='1')|(B[i]=='1');\n    rep(i,1,m) ok|=(C[i]=='1')|(D[i]=='1');\n    if (!ok) return puts(\"-1\"),0;\n    calc(n,m,A,B,C,D); calc(m,n,C,D,A,B);\n    printf(\"%lld\\n\",Ans % Mod);\n    return 0;\n}\n\n/* Examples: */\n/*\n\n*/\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int P=998244353;\ninline void upd(R int &x,R int y){(x+=y)>=P?x-=P:0;}\ninline int add(R int x,R int y){return x+y>=P?x+y-P:x+y;}\ninline int dec(R int x,R int y){return x-y<0?x-y+P:x-y;}\ninline int mul(R int x,R int y){return 1ll*x*y-1ll*x*y/P*P;}\nint ksm(R int x,R int y){\n\tR int res=1;\n\tfor(;y;y>>=1,x=mul(x,x))(y&1)?res=mul(res,x):0;\n\treturn res;\n}\nconst int N=2e5+5,M=1e6+5;\nint fac[M],ifac[M],bin[M],ibin[M];\ninline int C(R int n,R int m){return m>n?0:1ll*fac[n]*ifac[m]%P*ifac[n-m]%P;}\nvoid init(int n=1e6){\n\tfac[0]=ifac[0]=bin[0]=ibin[0]=1;\n\tfp(i,1,n)fac[i]=mul(fac[i-1],i);\n\tifac[n]=ksm(fac[n],P-2);\n\tfd(i,n-1,1)ifac[i]=mul(ifac[i+1],i+1);\n\tfp(i,1,n)bin[i]=mul(bin[i-1],2);\n\tfp(i,1,n)ibin[i]=mul(ibin[i-1],499122177);\n}\nchar mp[4][N];int sum[4][N],f[N],b[N],s[N];\nint n,m,res;\nvoid calc(){\n\tmemset(f,0,sizeof(f));\n\tmemset(b,0,sizeof(b));\n\tmemset(s,0,sizeof(s));\n\tR int x=sum[0][n],y,z;\n\tfp(i,0,m){\n\t\tif(mp[2][i+1]=='0'&&mp[3][i+1]=='0')continue;\n\t\ty=sum[2][i],z=sum[3][i];\n\t\tf[i]=(x?C(x+y+z-1,x-1):(!y&&!z));\n\t}\n\tx=sum[1][n];\n\tfd(i,m+1,1){\n\t\tif(mp[2][i-1]=='0'&&mp[3][i-1]=='0')continue;\n\t\ty=sum[2][m]-sum[2][i-1],z=sum[3][m]-sum[3][i-1];\n\t\tb[i]=(x?C(x+y+z-1,x-1):(!y&&!z));\n\t}\n\tfp(i,1,m)s[i]=s[i-1]+(mp[2][i]=='1'&&mp[3][i]=='1');\n\tfp(i,0,m)f[i]=mul(f[i],ibin[s[i]]);\n\tfd(i,m+1,1)b[i]=add(b[i+1],mul(b[i],bin[s[i-1]]));\n\tfp(i,1,m)upd(res,mul(f[i-1],b[i+1]));\n}\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\tfp(i,0,3)scanf(\"%s\",mp[i]+1);\n\tfp(i,0,3){\n\t\tR int t=(i<=1?n:m);\n\t\tfp(j,1,t)sum[i][j]=sum[i][j-1]+(mp[i][j]=='1');\n\t}\n\tif(!sum[0][n]&&!sum[1][n]&&!sum[2][m]&&!sum[3][m])return puts(\"1\"),0;\n\tcalc();\n\tswap(mp[0],mp[2]),swap(mp[1],mp[3]);\n\tswap(sum[0],sum[2]),swap(sum[1],sum[3]);\n\tswap(n,m);\n\tcalc();\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=400005,mod=998244353;\nint fac[N],rev[N],f[N],pre[N],t[N],p2[N],ip2[N],n,m,ans;\nchar A[N],B[N],C[N],D[N];\n\nint power(int x,int p){\n\tint res=1;\n\tfor(;p;p>>=1,x=(ll)x*x%mod)\n\t\tif(p&1)res=(ll)res*x%mod;\n\treturn res;\n}\nvoid init(int n){\n\tfac[0]=1;\n\trep(i,1,n) fac[i]=(ll)fac[i-1]*i%mod;\n\trev[n]=power(fac[n],mod-2);\n\tper(i,n,1) rev[i-1]=(ll)rev[i]*i%mod;\n\tp2[0]=1,ip2[0]=1;\n\trep(i,1,n) p2[i]=2*p2[i-1]%mod;\n\trep(i,1,n) ip2[i]=(ll)(mod/2+1)*ip2[i-1]%mod;\n}\nint Co(int n,int m){\n\treturn m<0||m>n?0:(ll)fac[n]*rev[m]%mod*rev[n-m]%mod;\n}\n\nvoid solve(int n,int m){\n\tint ca=0,cb=0;\n\trep(i,1,n) ca+=A[i]-'0',cb+=B[i]-'0';\n\trep(i,1,m) t[i]=t[i-1]+(C[i]=='1'&&D[i]=='1');\n\tint cnt=0;\n\trep(i,1,m){\n\t\tcnt+=(C[i-1]=='1');\n\t\tcnt+=(D[i-1]=='1');\n\t\tpre[i]=pre[i-1];\n\t\tif(C[i]=='1'||D[i]=='1'){\n\t\t\tf[i]=(ca==0?cnt==0:Co(ca+cnt-1,ca-1))*(1+t[i]-t[i-1])%mod;\n\t\t\tpre[i]=(pre[i]+(ll)f[i]*ip2[t[i]])%mod;\n\t\t}\n\t}\n\tcnt=0;\n\tper(i,m,1){\n\t\tcnt+=(C[i+1]=='1');\n\t\tcnt+=(D[i+1]=='1');\n\t\tif(C[i]=='1'||D[i]=='1'){\n\t\t\tint owo=(cb==0?cnt==0:Co(cb+cnt-1,cb-1)); \n\t\t\tans=(ans+(ll)owo*f[i])%mod;\n\t\t\tans=(ans+(ll)owo*pre[i-1]%mod*p2[t[i]])%mod;\n\t\t}\n\t}\n}\n\nint main(){\n\tinit(400000);\n\tread(n),read(m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\tsolve(n,m);\n\tswap(A,C),swap(B,D);\n\tsolve(m,n);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nchar A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\ninline void pls(int&A,int B){A=A+B<p?A+B:A+B-p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i]-'0',right+=B[i]-'0';\n\tfor(int i=m;i;--i)r+=C[i]-'0'+D[i]-'0';\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]-'0'+D[i]-'0';\n\t\tr-=C[i]-'0'+D[i]-'0';\n\t\tif(C[i]=='0' and D[i]=='0')continue;\n\t\tif(C[i]=='1' and D[i]=='1')pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpls(pre,val);\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tscanf(\"%s%s\",A+1,B+1);\n\tscanf(\"%s%s\",C+1,D+1);\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int Mod = 998244353, fft_g = 3;\nconst int inv2 = (Mod + 1) >> 1;\n\nconst int maxn = 262144;\n\ninline int fpm(LL b, int e, const int &m)\n{\n\tLL t = 1;\n\tfor ( ; e; (b *= b) %= m, e >>= 1)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nint N;\nint w[maxn + 5];\nint bitrev[maxn + 5];\n\ninline void fft(int *a, const int &n)\n{\n\tREP(i, 0, n) if (i < bitrev[i]) swap(a[i], a[bitrev[i]]);\n\tfor (int i = 2, lyc = n >> 1; i <= n; i <<= 1, lyc >>= 1)\n\t{\n\t\tfor (int j = 0; j < n; j += i)\n\t\t{\n\t\t\tint *l = a + j, *r = a + j + (i >> 1), *p = w;\n\t\t\tREP(k, 0, i >> 1)\n\t\t\t{\n\t\t\t\tint tmp = (LL)*r * *p % Mod;\n\t\t\t\t(*r = *l - tmp) %= Mod;\n\t\t\t\t(*l += tmp) %= Mod;\n\t\t\t\t++l, ++r;\n\t\t\t\tp += lyc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid fft_prepare(int num)\n{\n\tint L = 0;\n\tfor ( ; (1 << L) < num; ++L);\n\tN = 1 << L;\n\tREP(i, 0, N) bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) << (L - 1));\n\tint step = fpm(fft_g, (Mod - 1) / N, Mod);\n\tw[0] = 1;\n\tREP(i, 0, N) w[i + 1] = (LL)w[i] * step % Mod;\n}\n\nconst int max0 = 500100;\n\nint fac[max0 + 5], ifac[max0 + 5];\n\ninline void prepare()\n{\n\tfac[0] = 1;\n\tREP(i, 0, max0) fac[i + 1] = (LL)fac[i] * (i + 1) % Mod;\n\tifac[max0] = fpm(fac[max0], Mod - 2, Mod);\n\tfor (int i = max0 - 1; i >= 0; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n}\n\nint ans = 0;\n\ninline void work(int n, int m, char *a, char *b, char *c, char *d)\n{\n\tint tot = 1;\n\tREP(i, 0, n) if (a[i] == '1' && b[i] == '1') (tot <<= 1) %= Mod;\n\tint cnt = 0;\n\tREP(j, 0, m) cnt += c[j] == '1';\n\tint pre = 1;\n\tint prea = 0;\n\tint preb = 0;\n\tstatic int tmp0[maxn + 5], tmp1[maxn + 5];\n\tmemset(tmp0, 0, sizeof tmp0);\n\tREP(i, 0, n) if (a[i] == '1' || b[i] == '1')\n\t{\n\t\t//x   (prea + x - 1, prea - 1) * (preb + cnt - x - 1, preb)\n\t\t//(prea + preb + cnt - 1, prea + preb)\n\t\tint tmp = 0;\n\t\tif (!(prea + preb)) tmp = 1;\n\t\telse if (!cnt) tmp = 0;\n\t\telse tmp = (LL)fac[prea + preb + cnt - 1] * ifac[prea + preb] % Mod * ifac[cnt - 1] % Mod;\n\t\ttmp = (LL)tmp * pre % Mod;\n\t\t(tmp0[i] += tmp) %= Mod;\n\t\tif (a[i] == '1' && b[i] == '1') pre = (LL)pre * inv2 % Mod;\n\t\tprea += a[i] == '1';\n\t\tpreb += b[i] == '1';\n\t}\n\tmemset(tmp1, 0, sizeof tmp1);\n\tcnt = 0;\n\tREP(j, 0, m) cnt += d[j] == '1';\n\tpre = 1;\n\tprea = preb = 0;\n\tfor (int i = n - 1; i >= 0; --i) if (a[i] == '1' || b[i] == '1')\n\t{\n\t\tint tmp = 0;\n\t\tif (!(prea + preb)) tmp = 1;\n\t\telse if (!cnt) tmp = 0;\n\t\telse tmp = (LL)fac[prea + preb + cnt - 1] * ifac[prea + preb] % Mod * ifac[cnt - 1] % Mod;\n\t\ttmp = (LL)tmp * pre % Mod;\n\t\t(tmp1[n - i - 1] += tmp) %= Mod;\n\t\tif (a[i] == '1' && b[i] == '1') pre = (LL)pre * inv2 % Mod;\n\t\tprea += a[i] == '1';\n\t\tpreb += b[i] == '1';\n\t}\n\tfft_prepare(n << 1);\n\tfft(tmp0, N);\n\tfft(tmp1, N);\n\tREP(i, 0, N) tmp0[i] = (LL)tmp0[i] * tmp1[i] % Mod;\n\tfft(tmp0, N);\n\treverse(tmp0 + 1, tmp0 + N);\n\tint invN = fpm(N, Mod - 2, Mod);\n\tREP(i, 0, n) \n\t{\n\t\ttmp0[i] = (LL)tmp0[i] * invN % Mod * tot % Mod;\n\t\t(ans += tmp0[i]) %= Mod;\n\t}\n}\n\nint n, m;\nchar a[maxn + 5], b[maxn + 5], c[maxn + 5], d[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tprepare();\n\tscanf(\"%d%d\", &n, &m);\n\tbool tmp = 0;\n\tscanf(\"%s\", a);\n\tscanf(\"%s\", b);\n\tREP(i, 0, n) tmp |= a[i] == '1' || b[i] == '1';\n\tscanf(\"%s\", c);\n\tscanf(\"%s\", d);\n\tREP(i, 0, m) tmp |= c[i] == '1' || d[i] == '1';\n\tif (!tmp)\n\t{\n\t\tprintf(\"1\\n\");\n\t}\n\telse\n\t{\n\t\twork(n, m, a, b, c, d);\n\t\twork(m, n, c, d, a, b);\n\t\t(ans += Mod) %= Mod;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\ntemplate<unsigned MOD_> struct ModInt {\n    static const unsigned MOD = MOD_;\n    unsigned x;\n    void undef() { x = (unsigned)-1; }\n    bool isnan() const { return x == (unsigned)-1; }\n    inline int geti() const { return (int)x; }\n    ModInt() { x = 0; }\n    ModInt(const ModInt &y) { x = y.x; }\n    ModInt(int y) { if (y<0 || (int)MOD<=y) y %= (int)MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt(long long y) { if (y<0 || MOD<=y) y %= MOD; if (y<0) y += MOD; x=y; }\n    ModInt(unsigned long long y) { if (MOD<=y) x = y % MOD; else x = y; }\n    ModInt &operator+=(const ModInt y) { if ((x += y.x) >= MOD) x -= MOD; return *this; }\n    ModInt &operator-=(const ModInt y) { if ((x -= y.x) & (1u<<31)) x += MOD; return *this; }\n    ModInt &operator*=(const ModInt y) { x = (unsigned long long)x * y.x % MOD; return *this; }\n    ModInt &operator/=(const ModInt y) { x = (unsigned long long)x * y.inv().x % MOD; return *this; }\n    ModInt operator-() const { return (x ? MOD-x: 0); }\n\n    ModInt inv() const { return pow(MOD-2); }\n    ModInt pow(long long y) const {\n\tModInt b = *this, r = 1;\n\tif (y < 0) { b = b.inv(); y = -y; }\n\tfor (; y; y>>=1) {\n\t    if (y&1) r *= b;\n\t    b *= b;\n\t}\n\treturn r;\n    }\n\n    ModInt extgcd() const {\n\tunsigned a = MOD, b = x; int u = 0, v = 1;\n\twhile (b) {\n\t    int t = a / b;\n\t    a -= t * b; swap(a, b);\n\t    u -= t * v; swap(u, v);\n\t}\n\tif (u < 0) u += MOD;\n\treturn ModInt(u);\n    }\n\n    friend ModInt operator+(ModInt x, const ModInt y) { return x += y; }\n    friend ModInt operator-(ModInt x, const ModInt y) { return x -= y; }\n    friend ModInt operator*(ModInt x, const ModInt y) { return x *= y; }\n    friend ModInt operator/(ModInt x, const ModInt y) { return x *= y.inv(); }\n    friend bool operator<(const ModInt x, const ModInt y) { return x.x < y.x; }\n    friend bool operator==(const ModInt x, const ModInt y) { return x.x == y.x; }\n    friend bool operator!=(const ModInt x, const ModInt y) { return x.x != y.x; }\n};\n\nconst LL MOD = 998244353;\ntypedef ModInt<MOD> Mint;\n\nconst int MAX = 1000011;\nMint inv[MAX], fact[MAX], fact_inv[MAX];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i=1; i<MAX; i++) fact[i] = fact[i-1] * i;\n    fact_inv[MAX-1] = fact[MAX-1].inv();\n    for (int i=MAX-2; i>=0; i--) fact_inv[i] = fact_inv[i+1] * (i+1);\n    inv[0] = 0;\n    for (int i=1; i<MAX; i++) inv[i] = fact_inv[i] * fact[i-1];\n}\n\nMint nCk(int n, int k) {\n    return fact[n] * fact_inv[k] * fact_inv[n-k];\n}\n\nMint f(int a, int b, int c) {\n    if (a == 0 && b == 0) return 1;\n    if (c == 0) return 0;\n    Mint ret = nCk(a+b+c, c) - nCk(a+b+c-1, c);\n    return ret;\n}\n\nint N, M;\nchar L[100011], R[100011], U[100011], D[100011];\n\n\nMint calc() {\n    int lcnt = count(L, L+N, '1');\n    int rcnt = count(R, R+N, '1');\n\n    if (lcnt == 0 && rcnt == 0) return 0;\n    int ucnt = count(U, U+M, '1');\n    int dcnt = count(D, D+M, '1');\n\n    int lup = 0, rup = 0;\n    Mint ans = 0;\n    Mint way = 0;\n    REP (i, N) {\n\tint line = 0;\n\tif (L[i] == '1') { lcnt--; line++; }\n\tif (R[i] == '1') { rcnt--; line++; }\n\tif (line) {\n\t    way += f(lup, rup, ucnt);\n\t    way *= line;\n\t    ans += f(lcnt, rcnt, dcnt) * way;\n\t}\n\tif (L[i] == '1') { lup++; }\n\tif (R[i] == '1') { rup++; }\n    }\n    return ans;\n}\n\nvoid MAIN() {\n    init();\n    scanf(\"%d%d\", &N, &M);\n    scanf(\"%s\", L);\n    scanf(\"%s\", R);\n    scanf(\"%s\", U);\n    scanf(\"%s\", D);\n    Mint ans = 0;\n\n    if (count(L, L+N, '1') == 0\n\t    && count(R, R+N, '1') == 0\n\t    && count(U, U+M, '1') == 0\n\t    && count(D, D+M, '1') == 0) {\n\tans = 0;\n    } else {\n\tMint ans1 = calc();\n\tREP (i, 100011) {\n\t    swap(L[i], U[i]);\n\t    swap(R[i], D[i]);\n\t}\n\tswap(N, M);\n\tMint ans2 = calc();\n\n\tans = ans1 + ans2;\n    }\n    printf(\"%d\\n\", ans.geti());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nstruct FastNewton {\n private:\n  long long P;\n  long long range;\n  vector<long long> inv;\n  vector<long long> fact;\n  vector<long long> fact_inv;\n  vector<long long> v_p;\n \n public:\n  FastNewton (long long _P, long long _range = 0) {\n    init(_P, _range);\n  }\n  \n  // Initialize structures to support computing n choose k mod _P, where n <= range\n  void init(long long _P, long long _range = -1) {\n    P = _P;\n    if (_range == -1) {\n      range = P;\n    } else {\n      range = _range;\n    }\n    inv.resize(range + 5);\n    fact.resize(range + 5);\n    fact_inv.resize(range + 5);\n    v_p.resize(range + 5);\n    fact[0] = 1;\n    fact_inv[0] = 1;\n    inv[0] = -1;\n    inv[1] = 1;\n    for (int i = 2; i < min(range, P); i++) {\n      inv[i] = P - (P / i) * inv[P % i] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      ll tmp = i;\n      while (tmp % P == 0) {\n        tmp /= P;\n      }\n      fact[i] = tmp * fact[i - 1] % P;\n      fact_inv[i] = fact_inv[i - 1] * inv[tmp % P] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      v_p[i] = i / P + v_p[i / P];\n    }\n  }\n  \n  long long get_inv(long long a) const {\n    if (a % P == 0) {\n      cout<<\"ERROR: 0 has not got its inverse\\n\";\n      return -1;\n    }\n    return inv[a % P];\n  }\n  \n  // Computes n! mod P\n  long long get_normal_fact(long long n) const {\n    if (n >= P) {\n      return 0;\n    }\n    return fact[n];\n  }\n  \n  // Computes n!/p^(v_p(n!)) mod P\n  long long get_better_fact(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return fact[n];\n  }\n  \n  // Computes largest k such that p^k | n!\n  long long get_v_p(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return v_p[n];\n  }\n  \n  // Computes (n choose k) mod p\n  long long choose(long long n, long long k) const {\n    if (k < 0 || k > n) {\n      return 0;\n    }\n    if (v_p[n] == v_p[k] + v_p[n - k]) {\n      return fact[n] * fact_inv[k] % P * fact_inv[n - k] % P;\n    } else {\n      return 0;\n    }\n  }\n  \n};\nconst int N = 1e5 + 5;\nconst int P = 998244353;\nFastNewton newt(P, 3 * N);\nint Cnt1(string A) {\n  int heh = 0;\n  for (auto x : A) {\n    heh += (x == '1');\n  }\n  return heh;\n}\nint Go(string A, string B, string C, string D) {\n  int m = SZ(C);\n  int suf = 0;\n  int L = Cnt1(A), R = Cnt1(B), U = Cnt1(C), DD = Cnt1(D);\n  int al = U, ar = 0, cl = DD, cr = 0;\n  int res = 0;\n  FORD (i, m - 1, 0) {\n    int cnt1here = 0;\n    if (C[i] == '1') {\n      al--;\n      cnt1here++;\n    }\n    if (D[i] == '1') {\n      cl--;\n      cnt1here++;\n    }\n    int both = cnt1here == 2;\n    int here_left = -1;\n    if (L == 0) {\n      if (al == 0 && cl == 0) {\n        here_left = 1;\n      } else {\n        here_left = 0;\n      }\n    } else {\n      here_left = newt.choose(al + cl + L - 1, al + cl);\n    }\n    int here_right = 0;\n    if (R == 0) {\n      if (ar == 0 && cr == 0) {\n        here_right = 1;\n      } else {\n        here_right = 0;\n      }\n    } else {\n      here_right = newt.choose(ar + cr + R - 1, ar + cr);\n    }\n    if (cnt1here) {\n      suf = (suf + here_right) % P;\n      if (both) {\n        suf = 2 * suf % P;\n      }\n      res += here_left * suf;\n    }\n    res %= P;\n    if (C[i] == '1') {\n      ar++;\n    }\n    if (D[i] == '1') {\n      cr++;\n    }\n    debug(i, here_left, suf, al, cl, ar, cr);\n  }\n  debug(res);\n  return res;\n}\n  \nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m;\n  cin>>n>>m;\n  string A, B, C, D;\n  cin>>A>>B>>C>>D;\n  int res = Go(A, B, C, D) + Go(C, D, A, B);\n  cout<<res % P<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, p = 998244353;\nchar a[100020];\nchar b[100020];\nchar c[100020];\nchar d[100020];\nlong long v[500020];\nlong long u[500020];\nlong long ans;\nint a1, b1, c1, d1;\nint f[100020];\nint g[100020];\nlong long C(int n, int m) {\n\tif (n == -1 && m == -1) {\n\t\treturn 1;\n\t}\n\tif (m < 0) {\n\t\treturn 0;\n\t}\n\treturn u[n] * v[m] % p * v[n - m] % p;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s%s%s%s\", a, b, c, d);\n\tv[1] = 1;\n\tfor (int i = 2; i <= 500010; i++) {\n\t\tv[i] = v[p % i] * (p - p / i) % p;\n\t}\n\tv[0] = u[0] = u[1] = 1;\n\tfor (int i = 2; i <= 500010; i++) {\n\t\tv[i] = v[i] * v[i - 1] % p;\n\t\tu[i] = u[i - 1] * i % p;\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\tif (a1 == 0 && b1 == 0 && c1 == 0 && d1 == 0) {\n\t\tprintf(\"1\\n\");\n\t\treturn 0;\n\t}\n\n\n\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i == 0) {\n\t\t\tf[i] = 0;\n\t\t} else {\n\t\t\tf[i] = f[i - 1];\n\t\t}\n\t\tif (c[i] == '1' || d[i] == '1') {\n//\t\t\tcerr << \"?\" << C(c1 + d1 + a1 - 1, a1 - 1) << ' ' << a1 << ' ' << b1 << ' ' << c1 << ' ' << d1 << endl;\n\t\t\tf[i] = (f[i] + C(c1 + d1 + a1 - 1, a1 - 1)) % p;\n\t\t\tif (c[i] == '1' && d[i] == '1') {\n\t\t\t\tf[i] = f[i] * 2 % p;\n\t\t\t}\n\t\t}\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\tc1 = d1 = 0;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (c[i] == '1' || d[i] == '1') {\n\t\t\tans = (ans + f[i] * C(c1 + d1 + b1 - 1, b1 - 1)) % p;\n\t\t}\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\n\n\n\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tf[i] = 0;\n\t\t} else {\n\t\t\tf[i] = f[i - 1];\n\t\t}\n\t\tif (a[i] == '1' || b[i] == '1') {\n//\t\t\tcerr << \"?\" << C(a1 + b1 + c1 - 1, c1 - 1) << ' ' << a1 << ' ' << b1 << ' ' << c1 << ' ' << d1 << endl;\n\t\t\tf[i] = (f[i] + C(a1 + b1 + c1 - 1, c1 - 1)) % p;\n\t\t\tif (a[i] == '1' && b[i] == '1') {\n\t\t\t\tf[i] = f[i] * 2 % p;\n\t\t\t}\n\t\t}\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (a[i] == '1' || b[i] == '1') {\n\t\t\tans = (ans + f[i] * C(a1 + b1 + d1 - 1, d1 - 1)) % p;\n\t\t}\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#define MOD 998244353\ntypedef long long ll;\ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1;\n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD;\n\t\ta = a * a % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll fact[300005], inv[300005], dp[100005];\ninline ll C(int n, int m)\n{\n\tif (n == -1 && m == -1)\n\t\treturn 1;\n\tif (n < m || m < 0)\n\t\treturn 0;\n\treturn fact[n] * inv[m] % MOD * inv[n - m] % MOD;\n}\nll work(int n, int m, char *a, char *b, char *c, char *d)\n{\n\tint aa = 0, bb = 0, cc = 0, dd = 0;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\taa += a[i] - '0';\n\t\tbb += b[i] - '0';\n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tcc += c[i] - '0';\n\t\tdd += d[i] - '0';\n\t}\n\tif (!aa && !bb && !cc && !dd)\n\t{\n\t\tputs(\"1\");\n\t\texit(0);\n\t}\n\tcc = dd = 0;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tdp[i] = i ? dp[i - 1] : 0;\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t\t(dp[i] += C(cc + dd + aa - 1, aa - 1)) %= MOD;\n\t\tif (c[i] == '1' && d[i] == '1')\n\t\t\t(dp[i] += dp[i]) %= MOD;\n\t\tcc += c[i] - '0';\n\t\tdd += d[i] - '0';\n\t}\n\tll res = 0;\n\tcc = dd = 0;\n\tfor (int i = m - 1; i >= 0; i--)\n\t{\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t\t(res += dp[i] * C(cc + dd + bb - 1, bb - 1)) %= MOD;\n\t\tcc += c[i] - '0';\n\t\tdd += d[i] - '0';\n\t}\n\treturn res;\n}\nchar a[100005], b[100005], c[100005], d[100005];\nint main()\n{\n\t// freopen(\"CF17-QA-E.in\", \"r\", stdin);\n\tfact[0] = inv[0] = 1;\n\tfor (int i = 1; i <= 3e5; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD;\n\t\tinv[i] = quick_pow(fact[i], MOD - 2);\n\t}\n\tint n, m;\n\tscanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d);\n\tprintf(\"%lld\\n\", (work(n, m, a, b, c, d) + work(m, n, c, d, a, b)) % MOD);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <map>\n\n#define MAX_INT 2147483647\n#define MOD 998244353\n#define PI 3.141592653589793238462643383279502884L\n\n#define long long long int\n\nusing std::vector;\nusing std::map;\nusing std::string;\nusing std::pair;\nusing std::cin;\nusing std::cout;\n\n// @author: pashka\n\nvector<long> fact;\nvector<long> inv_fact;\n\nlong mult(long a, long b) {\n    return (a * b) % MOD;\n}\n\nlong calc_c(int n, int k) {\n    return mult(mult(fact[n], inv_fact[k]), inv_fact[n - k]);\n}\n\nlong pow(long a, int pow) {\n    long res = 1;\n    while (pow > 0) {\n        if (pow & 1) {\n            res = mult(res, a);\n        }\n        a = mult(a, a);\n        pow /= 2;\n    }\n    return res;\n}\n\nlong calc_g(int n, int k) {\n    if (n == 0) return 1;\n    if (k == n) return 0;\n    if (k == 0) return 1;\n    long res = calc_c(n, k);\n    res -= calc_c(n - 1, k - 1);\n    if (res < 0) res += MOD;\n    res %= MOD;\n    return res;\n}\n\nvoid calc(string &left, string &up, string &down, vector<long> &res) {\n    int n = left.size();\n    int m = up.size();\n    int k = 0;\n    for (int i = 0; i < n; i++) {\n        if (left[i] == '1') k++;\n    }\n    res[0] = 1;\n    int t = 0;\n    for (int i = 0; i < m; i++) {\n        if (up[i] == '1') t++;\n        if (down[i] == '1') t++;\n        res[i + 1] = calc_g(t + k, t);\n    }\n}\n\nlong calc(string a, string b, string c, string d) {\n    int n = a.size();\n    int m = c.size();\n    vector<long> left(m + 1);\n    vector<long> right(m + 1);\n    calc(a, c, d, left);\n    std::reverse(c.begin(), c.end());\n    std::reverse(d.begin(), d.end());\n    calc(b, c, d, right);\n    std::reverse(c.begin(), c.end());\n    std::reverse(d.begin(), d.end());\n\n    long ll = 0;\n    long res = 0;\n    for (int i = 0; i < m; i++) {\n        int t = 0;\n        if (c[i] == '1') t++;\n        if (d[i] == '1') t++;\n        if (t == 0) continue;\n        ll = t * (ll + left[i]);\n        ll %= MOD;\n        res += mult(ll, right[m - 1 - i]);\n        res %= MOD;\n//        std::cerr << i << \" \" << ll << \" \" << t << \" \" << left[i] << \" \" << right[m - 1 - i] << \" \" << res << \"\\n\";\n    }\n    return res;\n}\n\nint main() {\n    std::ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n\n    fact.resize(2 * (n + m) + 2);\n    inv_fact.resize(2 * (n + m) + 2);\n    fact[0] = inv_fact[0] = 1;\n    for (int i = 1; i < fact.size(); i++) {\n        fact[i] = mult(fact[i - 1], i);\n        inv_fact[i] = pow(fact[i], MOD - 2);\n    }\n\n    string a, b, c, d;\n    cin >> a >> b >> c >> d;\n\n    long res = (calc(a, b, c, d) + calc(c, d, a, b)) % MOD;\n\n    cout << res;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool flag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') flag = true;\n\t}\n\tif(!flag) swap(l, u), swap(r, d), swap(h, w);\n\t\n\tflag = false;\n\tfor(int i = 1; i <= h; i++){\n\t\tif(u[i] == '1' || d[i] == '1') flag = true;\n\t}\n\tif(!flag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> PII;\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n\n#define P 998244353\n#define M 300010\nint F[M], IF[M];\n\nvoid gcd(int a,int b,int &x,int &y) {\n  if(b==0){x=1,y=0;return;}\n  gcd(b,a%b,y,x),y-=a/b*x;\n}\nint inv(int n) {\n  int x,y;gcd(n,P,x,y);\n  if(x<0)x+=P;return x;\n}\nint C(int n, int k) {\n\tif (k < 0 || n < k) return 0;\n\treturn (ll)F[n]*IF[k]%P*IF[n-k]%P;\n}\nint gg(int u, int v, int m) {\n\tif (u == 0 && v == 0 && m == 0) return 1;\n\treturn C(u+v+m-1, m-1);\n}\n\n#define N 100010\nint n, m;\nstring a, b, c, d;\nint f[N], lu[N], lv[N];\n\nint ff() {\n\tmemset(f, 0, sizeof f);\n\tmemset(lu, 0, sizeof lu);\n\tmemset(lv, 0, sizeof lv);\n\tint le = 0;\n\tint ri = 0;\n\tfor (int i = 0; i < m; i ++) {\n\t\tif (c[i] == '1') le ++;\n\t\tif (d[i] == '1') ri ++;\n\t}\n\t\n\tint u = 0, v = 0;\n\t//cout << n << \" \" << m << \" \" << a.length() << \" \" << b.length() << \" \" << c.length() << \" \" << d.length() << endl;\n\t//cout << le << \" \" << ri << endl;\n\t\n\tfor (int i = 0; i < n; i ++) {\n\t\tint w = 0;\n\t\tif (a[i] == '1') w++;\n\t\tif (b[i] == '1') w++;\n\t\tf[i] = (ll)gg(u, v, le)*w%P;\n\t\tlu[i] = u;\n\t\tlv[i] = v;\n\t\tif (a[i] == '1') u++;\n\t\tif (b[i] == '1') v++;\n\t}\n\t\n\tfor (int i = 0; i < n-1; i ++) {\n\t\tif (a[i+1] == '1' && b[i+1] == '1')\n\t\t\t(f[i+1] += (ll)f[i]*2%P) %= P;\n\t\telse\n\t\t\t(f[i+1] += f[i]) %= P;\n\t}\n\t\n\tint S = 0;\n\tu = v = 0;\n\tfor (int i = n-1; i >= 0; i--) {\n\t\tint w = 0;\n\t\tif (a[i] == '1') w++;\n\t\tif (b[i] == '1') w++;\n\t\tif (w >= 1) S = (S + (ll)f[i]*gg(u, v, ri)%P)%P;\n\t\tif (a[i] == '1') u++;\n\t\tif (b[i] == '1') v++;\n\t}\n\t\n\treturn S;\n}\n\nint main() {\n\tF[0]=1;for(int i=1;i<M;i++)F[i]=(ll)F[i-1]*i%P;\n\tIF[M-1]=inv(F[M-1]);for(int i=M-1;i;i--)IF[i-1]=(ll)IF[i]*i%P;\n\tcin >> n >> m;\n\tcin >> a >> b >> c >> d;\n\tint S = 0;\n\tS += ff();\n\tswap(a, c);\n\tswap(b, d);\n\tswap(n, m);\n\t(S += ff()) %= P;\n\tcout << S << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tint sl = x;\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\tint sr = x;\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tint sum = 0;\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t\tsum += A[it][j];\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tif (sum) cout<<1<<endl;\n\t\telse cout<<0<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// ayy\n// ' lamo\n#include <bits/stdc++.h>\n#include <bits/extc++.h>\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef long long ll;\ntypedef long double ld; //CARE\ntypedef complex<ld> pt;\n#define fi first\n#define se second\n#define pb push_back\nconst ld eps=1e-8;\nconst int inf=1e9+99;\nconst ll linf=1e18+99;\n// const int P=1e9+7;\nconst int P=998244353; // = 119 * 2**23 + 1\n\n\n\n\n\n\n\nconst int N=100<<10;\nbitset<N> A,B,C,D;\nint n,m;\nint F[N*4],iF[N*4],pow2[N*4];\nint I4,I2;\n\nint powq(int x,int e) {\n\tif(!e) return 1;\n\tif(e&1) return int(1LL*x*powq(x,e-1)%P);\n\tx=powq(x,e>>1);\n\treturn int(1LL*x*x%P);\n}\nvoid add(int &x,int y) {\n\tx+=y;\n\tif(x>=P) x-=P;\n}\n\nvoid init_math(int n) {\n\tF[0]=1;\n\tfor(int i=1;i<=n;i++) F[i]=int(1LL*F[i-1]*i%P);\n\tiF[n]=powq(F[n],P-2);\n\tfor(int i=n;--i>=0;) iF[i]=int(1LL*iF[i+1]*(i+1)%P);\n\n\tpow2[0]=1;\n\tfor(int i=1;i<=n;i++) pow2[i]=pow2[i-1]*2%P;\n\n\tI4=powq(4,P-2);\n\tI2=powq(2,P-2);\n}\n\nvoid read(bitset<N> &bs) {\n\tstring s; cin>>s;\n\tfor(int i=0;i<(int)s.size();i++) bs[i]=(s[i]=='1');\n}\n\nint CC(int n,int k) {\n\tassert(0<=k && k<=n);\n\tassert(n>=0);\n\treturn int(1LL*F[n]*iF[k]%P*iF[n-k]%P);\n}\nint f1(int n,int a,int b,int ec) {\n\t// cerr<<\"f1(\"<<n<<\",\"<<a<<\",\"<<b<<\",\"<<ec<<\") = \"<<(n ? CC(n-1+a+b,a+b) : pow2[ec])<<endl;\n\treturn n ? CC(n-1+a+b,a+b) : pow2[ec];\n}\n\n\n\nint go() {\n\tvector<int> L,R,q;\n\n\tint a=0,b=0,ec=0;\n\tint lc=(int)C.count();\n\tint rc=(int)D.count();\n\n\tint tc=0;\n\tfor(int i=0;i<n;i++) if(A[i] && B[i]) ++tc;\n\n\tfor(int i=0;i<n;i++) {\n\t\tif(!A[i] && !B[i]) continue;\n\t\tL.pb(f1(lc,a,b,ec));\n\t\t// if(A[i] && B[i]) L.back()*=2, L.back()%=P, ++ec;\n\t\tL.back() = int(1LL*L.back()*powq(I2,ec)%P);\n\t\tif(A[i] && B[i]) ++ec;\n\t\tif(A[i]) ++a;\n\t\tif(B[i]) ++b;\n\t\tq.pb(i);\n\n\t\tif(!lc && L.size()>1u) L.back()=0;\n\t}\n\n\ta=b=ec=0;\n\tfor(int i=n;--i>=0;) {\n\t\tif(!A[i] && !B[i]) continue;\n\t\tR.pb(f1(rc,a,b,ec));\n\t\t// if(A[i] && B[i]) R.back()*=2, R.back()%=P, ++ec;\n\t\tR.back() = int(1LL*R.back()*powq(2,tc-ec)%P);\n\t\tif(A[i] && B[i]) ++ec;\n\t\tif(A[i]) ++a;\n\t\tif(B[i]) ++b;\n\n\t\tif(!rc && R.size()>1u) R.back()=0;\n\t}\n\n\treverse(R.begin(),R.end());\n\n\tassert(L.size()==R.size());\n\tint w=(int)L.size();\n\n\tint RS=0;\n\tint Z=0;\n\tfor(int i=w;--i>=0;) {\n\t\tadd(RS,R[i]);\n\t\tadd(Z,int(1LL*RS*L[i]%P));\n\t\t// if(A[q[i]] && B[q[i]]) {\n\t\t// \tadd(Z,int(1LL*RS*L[i]%P));\n\t\t// \t// add(Z,int(P-1LL*L[i]*R[i]%P*I4*2%P));\n\t\t// \tadd(RS,R[i]);\n\t\t// }\n\t}\n\t// cerr<<\"got Z=\"<<Z<<\" via L={\";\n\t// for(int x:L) cerr<<x<<\",\";\n\t// cerr<<\"} and R={\";\n\t// for(int x:R) cerr<<x<<\",\";\n\t// cerr<<\"}\"<<endl;\n\treturn Z;\n}\n\n\n\nint32_t main() {\n\tcin>>n>>m;\n\tinit_math(max(n+m+n+m,N*3)+17);\n\tread(A),read(B),read(C),read(D);\n\n\tint z1=go();\n\tswap(n,m);\n\tswap(A,C);\n\tswap(B,D);\n\tint z2=go();\n\n\tcerr<<z1<<\" \"<<z2<<endl;\n\tcout<<(z1+z2)%P<<endl;\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntemplate <class T>\nT inverse(T a, T m) {\n    T u=0,v=1;\n    while(a!=0){\n        T t=m/a;\n        m-=t*a;std::swap(a,m);\n        u-=t*v;std::swap(u,v);\n    }\n    assert(m==1);\n    return u;\n}\ntemplate <class T>\nclass modular {\n    public:\n        int value;\n        constexpr modular() = default;\n        constexpr modular(const modular&) = default;\n        constexpr modular(modular&&) = default;\n        modular& operator=(const modular&) = default;\n        modular& operator=(modular&&) = default;\n        template <class U>modular (const U& x) {value = normalize(x);}\n\n        template <class U>\n            static int normalize(const U& x) {\n                int v=static_cast<int>(-mod()<=x&&x<mod()?x:x%mod());\n                if(v<0)v+=mod();\n                return v;\n            }\n\n        template <class U> explicit operator U()const{return static_cast<U>(value);}\n        constexpr static auto mod(){return T::value;}\n\n        auto&operator+=(const modular&other) {if((value+=other.value)>=mod())value-=mod();return *this;}\n        auto&operator-=(const modular& other){if ((value-=other.value)<0)value+=mod();return *this;}\n        template <class U>auto& operator+=(const U& other){return*this+=modular(other);}\n        template <class U>auto& operator-=(const U& other){return*this-=modular(other);}\n        auto operator-()const{return modular(-value);}\n        auto&operator++(){return*this+=1;}\n        auto&operator--(){return*this-=1;}\n        auto operator++(int){modular result(*this);operator++();return result;}\n        auto operator--(int){modular result(*this);operator--();return result;}\n\n        template <class U = T>\n            auto&operator*=(const modular&rhs){value=normalize(static_cast<std::int64_t>(value)*static_cast<std::int64_t>(rhs.value));return *this;}\n        auto&operator/=(const modular&rhs){return*this*=modular(inverse(rhs.value, mod()));}\n};\ntemplate<class T>struct is_modular:std::false_type{};\ntemplate<class T>struct is_modular <modular<T>>:std::true_type{};\ntemplate<class T>constexpr bool is_modular_v=is_modular<T>::value;\ntemplate<class T> bool operator==(const modular<T>& lhs, const modular<T>& rhs){return lhs.value==rhs.value;}\ntemplate<class T,class U>bool operator==(const modular<T>& lhs, U rhs){return lhs==modular<T>(rhs);}\ntemplate<class T,class U>bool operator==(U lhs, const modular<T>& rhs){return modular<T>(lhs)==rhs;}\ntemplate<class T> bool operator!=(const modular<T>& lhs, const modular<T>& rhs){return !(lhs == rhs);}\ntemplate<class T,class U> bool operator!=(const modular<T>& lhs, U rhs){return !(lhs==rhs);}\ntemplate<class T,class U> bool operator!=(U lhs, const modular<T>& rhs){return !(lhs==rhs);}\ntemplate<class T> modular<T> operator+(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T,class U> modular<T> operator+(const modular<T>& lhs, U rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T,class U> modular<T> operator+(U lhs, const modular<T>& rhs){return modular<T>(lhs)+=rhs;}\ntemplate<class T> modular<T> operator-(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T,class U> modular<T> operator-(const modular<T>& lhs, U rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T,class U> modular<T> operator-(U lhs, const modular<T>& rhs){return modular<T>(lhs)-=rhs;}\ntemplate<class T> modular<T> operator*(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T,class U> modular<T> operator*(const modular<T>& lhs, U rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T,class U> modular<T> operator*(U lhs, const modular<T>& rhs){return modular<T>(lhs)*=rhs;}\ntemplate<class T> modular<T> operator/(const modular<T>& lhs, const modular<T>& rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U> modular<T> operator/(const modular<T>& lhs, U rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U> modular<T> operator/(U lhs, const modular<T>& rhs){return modular<T>(lhs)/=rhs;}\ntemplate<class T, class U>\nmodular<T> power (const modular<T>& a, U b) {\n    assert(b>=0);\n    modular<T>x=a,ret=1;\n    for (;b>0;b/=2){\n        if(b%2==1)ret*=x;\n        x*=x;\n    }\n    return ret;\n}\ntemplate <class T>std::string to_string(const modular<T>& a) {\n    return std::to_string(a.value);\n}\ntemplate <class T>auto operator<<\n(std::ostream& os, const T& a)->std::enable_if_t<is_modular_v<T>, std::ostream&>{\n    return os << a.value;\n}\ntemplate <class T>auto operator>>\n(std::istream& is, T& a)-> std::enable_if_t<is_modular_v<T>, std::istream&> {\n    long long x;is>>x;\n    a=T(x);\n    return is;\n}\n\n// using mod_type = int;\n// struct variable_mod { static mod_type value; };\n// mod_type variable_mod::value;\n// mod_type& mod = variable_mod::value;\n// using mint = modular< variable_mod >;\n\nconstexpr int mod = 998'244'353;\nusing mint = modular<std::integral_constant<std::decay_t<decltype(mod)>, mod>>;\n\n\nint N;\nstd::vector<mint>fact,finv;\nvoid init(int n){\n    N=n;\n    fact.resize(n+1);\n    finv.resize(n+1);\n    fact.at(0)=1;\n    for(int i=1;i<=n;i++)fact.at(i)=fact.at(i-1)*i;\n    finv.at(n)=1/fact.at(n);\n    for(int i=n;i>=1;i--)finv.at(i-1)=finv.at(i)*i;\n    assert(finv.at(0)==1);\n}\nmint binom(int n,int k){\n    assert(0<=n);\n    if(k<0||n<k)return 0;\n    return fact.at(n)*finv.at(k)*finv.at(n-k);\n}\n\nint main(){\n    int h,w;std::cin>>h>>w;\n    init(2*(h+w)+1);\n    std::string sa,sb,sc,sd;std::cin>>sa>>sb>>sc>>sd;\n    int A=std::count(sa.begin(),sa.end(),'1');\n    int B=std::count(sb.begin(),sb.end(),'1');\n    int C=std::count(sc.begin(),sc.end(),'1');\n    int D=std::count(sd.begin(),sd.end(),'1');\n    if(!A&&!B&&!C&&!D){\n        std::cout<<0<<'\\n';\n        return 0;\n    }\n    mint ans=0;\n    auto cal=[&](int a, int c, int d)->mint{\n        if(a==0)return c==0&&d==0;\n        return binom(a-1+c+d,a-1);\n    };\n    for(int ngtkana=0;ngtkana<2;ngtkana++){\n        // 縦に貫いている中で最も左のものがこれであるときの、\n        // それ以右の場合の数です。\n        // そこに c も d もいない場合は累積和の伝播のためだけに使います。\n        std::vector<mint>right(w+1);\n        int c=0,d=0;\n        for(int j=w-1;j>=0;j--){\n            right.at(j)=right.at(j+1);\n            if(sc.at(j)=='1'||sd.at(j)=='1')\n                right.at(j)+=cal(B,c,d);\n            if(sc.at(j)=='1'&&sd.at(j)=='1')right.at(j)*=2;\n            c+=sc.at(j)=='1';\n            d+=sd.at(j)=='1';\n        }\n\n        // 縦に貫いている中で最も左がこれであるときの、\n        // それよりも左の場合の数と、畳み込んでいきます。\n        c=0,d=0;\n        for(int j=0;j<w;j++){\n            if(sc.at(j)=='1'||sd.at(j)=='1'){\n                ans+=cal(A,c,d)*right.at(j);\n            }\n            c+=sc.at(j)=='1';\n            d+=sd.at(j)=='1';\n        }\n        std::swap(sa,sc);\n        std::swap(sb,sd);\n        std::swap(A,C);\n        std::swap(B,D);\n        std::swap(h,w);\n    }\n    std::cout<<ans<<std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\ntypedef long long ll;\nconst int MAX=100010,mod=998244353;\nint N,M,cA,cB,cC,cD,ans;\nll fac[MAX*4],ifac[MAX*4];\nll inv(int a,int p=mod){return a==1?1:(1+p*(a-inv(p%a,a)))/a%p;}\nvoid init(int n){\n\tfor(int i=*fac=1;i<=n;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[n]=inv(fac[n]);\n\tfor(int i=n;i;i--)ifac[i-1]=ifac[i]*i%mod;\n}\nll cho(int n,int m){return!m?1:m>n?0:fac[n]*ifac[m]%mod*ifac[n-m]%mod;}\nchar A[MAX],B[MAX],C[MAX],D[MAX];\nvoid stat(char*s,int&c){\n\tfor(;*s;s++)*s=='1'?c++:1;\n}\nvoid calc(int n,char*A,char*B,int cA,int cB,int cC,int cD){\n\tint f=0,up=cA+cB,dn=0;\n\tfor(int i=n;i--;){\n\t\tint c=int(A[i]=='1')+int(B[i]=='1');\n\t\tif(c){\n\t\t\tf=c*(f+cho(cD-1+dn,dn))%mod;\n\t\t\tup-=c;dn+=c;\n\t\t\tans=(ans+f*cho(cC-1+up,up))%mod;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d%s%s%s%s\",&N,&M,A,B,C,D);\n\tstat(A,cA);stat(B,cB);\n\tstat(C,cC);stat(D,cD);\n\tinit(cA+cB+cC+cD);\n\tif(cA+cB)calc(N,A,B,cA,cB,cC,cD);\n\tif(cC+cD)calc(M,C,D,cC,cD,cA,cB);\n\tif(!cA&&!cB&&!cC&&!cD)(ans+=1)%=mod;\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 23.09.2017 15:44:27       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int md = 998244353;\n\ninline void add(int &a, int b) {\n  a += b;\n  if (a >= md) a -= md;\n}\n\ninline void sub(int &a, int b) {\n  a -= b;\n  if (a < 0) a += md;\n}\n\ninline int mul(int a, int b) {\n  return (long long) a * b % md;\n}\n\ninline int power(int a, int b) {\n  int res = 1;\n  while (b > 0) {\n    if (b & 1) {\n      res = mul(res, a);\n    }\n    a = mul(a, a);\n    b >>= 1;\n  }\n  return res;\n}\n\ninline int inv(int a) {\n  a %= md;\n  if (a < 0) a += md;\n  int b = md, u = 0, v = 1;\n  while (a) {\n    int t = b / a;\n    b -= t * a; swap(a, b);\n    u -= t * v; swap(u, v);\n  }\n  assert(b == 1);\n  if (u < 0) u += md;\n  return u;\n}\n\nconst int N = 800010;\n\nchar sa[N], sb[N], sc[N], sd[N];\nint fact[N], inv_fact[N];\nint ways_up[N], ways_down[N];\n\ninline int C(int n, int k) {\n  if (k < 0 || k > n) return 0;\n  return mul(fact[n], mul(inv_fact[k], inv_fact[n - k]));\n}\n\nint main() {\n  fact[0] = inv_fact[0] = 1;\n  for (int i = 1; i < N; i++) {\n    fact[i] = mul(fact[i - 1], i);\n    inv_fact[i] = inv(fact[i]);\n  }\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  scanf(\"%s\", sa);\n  scanf(\"%s\", sb);\n  scanf(\"%s\", sc);\n  scanf(\"%s\", sd);\n  vector<int> a(n), b(n), c(m), d(m);\n  for (int i = 0; i < n; i++) {\n    a[i] = sa[i] - '0';\n    b[i] = sb[i] - '0';\n  }\n  for (int i = 0; i < m; i++) {\n    c[i] = sc[i] - '0';\n    d[i] = sd[i] - '0';\n  }\n  int ans = 0;\n  for (int rot = 0; rot < 2; rot++) {\n    int sum_c = 0, sum_d = 0;\n    for (int p = 0; p < m; p++) {\n      sum_c += c[p];\n      sum_d += d[p];\n    }\n    int sum_up = 0;\n    for (int i = 0; i < n; i++) {\n      if (a[i] + b[i] == 0) {\n        ways_up[i] = 0;\n      } else {\n        if (sum_c == 0 && sum_up > 0) {\n          ways_up[i] = 0;\n        } else {\n          ways_up[i] = (sum_c == 0 ? 1 : C(sum_c + sum_up - 1, sum_c - 1));\n        }\n        sum_up += a[i] + b[i];\n      }\n    }\n    int sum_down = 0;\n    for (int j = n - 1; j >= 0; j--) {\n      if (a[j] + b[j] == 0) {\n        ways_down[j] = 0;\n      } else {\n        if (sum_d == 0 && sum_down > 0) {\n          ways_down[j] = 0;\n        } else {\n          ways_down[j] = (sum_d == 0 ? 1 : C(sum_d + sum_down - 1, sum_d - 1));\n        }\n        sum_down += a[j] + b[j];\n      }\n    }\n    int sum_i = 0;\n    for (int j = 0; j < n; j++) {\n      add(sum_i, ways_up[j]);\n      sum_i = mul(sum_i, max(1, a[j] + b[j]));\n      add(ans, mul(sum_i, ways_down[j]));\n    }\n    swap(n, m);\n    swap(a, c);\n    swap(b, d);\n  }\n  printf(\"%d\\n\", ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 998244353;\nconst ll INF = 1e18;\nconst int MX = 100001;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace io {\n    // TYPE ID (StackOverflow)\n    \n    template<class T> struct like_array : is_array<T>{};\n    template<class T, size_t N> struct like_array<array<T,N>> : true_type{};\n    template<class T> struct like_array<vector<T>> : true_type{};\n    template<class T> bool is_like_array(const T& a) { return like_array<T>::value; }\n\n    // I/O \n    \n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n    \n    // INPUT \n    \n    template<class T> void re(T& x) { cin >> x; }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest);\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    \n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n    \n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { re(first); re(rest...); }\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n    \n    // OUTPUT \n    \n    template<class T1, class T2> ostream& operator<<(ostream& os, const pair<T1,T2>& a) {\n        os << '{' << a.f << \", \" << a.s << '}'; return os;\n    }\n    template<class T> ostream& printArray(ostream& os, const T& a, int SZ) {\n        os << '{';\n        F0R(i,SZ) {\n            if (i) {\n                os << \", \";\n                if (is_like_array(a[i])) cout << \"\\n\";\n            }\n            os << a[i];\n        }\n        os << '}';\n        return os;\n    }\n    template<class T, size_t SZ> ostream& operator<<(ostream& os, const array<T,SZ>& a) {\n        return printArray(os,a,SZ);\n    }\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& a) {\n        return printArray(os,a,sz(a));\n    }\n    template<class T> ostream& operator<<(ostream& os, const set<T>& a) {\n        os << vector<T>(all(a)); return os;\n    }\n    template<class T1, class T2> ostream& operator<<(ostream& os, const map<T1,T2>& a) {\n        os << vector<pair<T1,T2>>(all(a)); return os;\n    }\n    \n    template<class T> void pr(const T& x) { cout << x << '\\n'; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        cout << first << ' '; pr(rest...); \n    }\n}\n\nusing namespace io;\n\n\nnamespace modOp {\n    int ad(int a, int b, int mod = MOD) { return (a+b)%mod; }\n    int sub(int a, int b, int mod = MOD) { return (a-b+mod)%mod; }\n    int mul(int a, int b, int mod = MOD) { return (ll)a*b%mod; }\n    \n    int AD(int& a, int b, int mod = MOD) { return a = ad(a,b,mod); }\n    int SUB(int& a, int b, int mod = MOD) { return a = sub(a,b,mod); }\n    int MUL(int& a, int b, int mod = MOD) { return a = mul(a,b,mod); }\n    \n    int po (int b, int p, int mod = MOD) { return !p?1:mul(po(mul(b,b,mod),p/2,mod),p&1?b:1,mod); }\n    int inv (int b, int mod = MOD) { return po(b,mod-2,mod); }\n    \n    int invGeneral(int a, int b) { // 0 < a < b, gcd(a,b) = 1\n        if (a == 0) return b == 1 ? 0 : -1;\n        int x = invGeneral(b%a,a); \n        return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n    }\n}\n\nusing namespace modOp;\n\nvpl factor(ll x) {\n    return {{x,1}};\n}\n\ntemplate<int SZ> struct combo {\n    int MOD, fac[SZ+1], ifac[SZ+1];\n    vpl factors;\n    vi cnt[SZ+1];\n    \n    void init(ll _MOD) {\n        MOD = _MOD; factors = factor(MOD);\n        cnt[0].resize(sz(factors));\n        \n        fac[0] = ifac[0] = 1;\n        FOR(i,1,SZ+1) {\n            cnt[i] = cnt[i-1];\n            \n            int I = i;\n            F0R(j,sz(factors)) \n                while (I % factors[j].f == 0) \n                    I /= factors[j].f, cnt[i][j] ++;\n                \n            fac[i] = mul(I,fac[i-1],MOD), ifac[i] = invGeneral(fac[i],MOD);\n        }\n    }\n    \n    ll comb(ll a, ll b) {\n        if (a == b) return 1;\n        if (a < b || b < 0) return 0;\n        ll tmp = mul(mul(fac[a],ifac[b],MOD),ifac[a-b],MOD);\n        return tmp;\n    }\n};\n\ncombo<400005> z;\nint N,M,ans;\nstring A,B,C,D;\n\nbool zero(string s) {\n    trav(x,s) if (x == '1') return 0;\n    return 1;\n}\n\nint numOne(string s) {\n    int ret = 0;\n    trav(x,s) ret += (x == '1');\n    return ret;\n}\n\nint l[MX], r[MX];\n\nint calc(int a, int b, int c) {\n    if (c == 0) return a+b == 0;\n    return z.comb(a+b+c-1,c-1);\n    int ret = 0;\n    F0R(i,c) AD(ret,mul(z.comb(a-1+i,a-1),z.comb(b+c-1-i,b)));\n    return ret;\n}\n\nvoid test() {\n    if (zero(A) && zero(B)) return;\n    int a = 0, b = 0, c = numOne(C);\n    F0R(i,N) {\n        l[i] = 0;\n        if (A[i] == '1' || B[i] == '1') {\n            l[i] = calc(a,b,c);\n            a += (A[i] == '1');\n            b += (B[i] == '1');\n        }\n    }\n    a = 0, b = 0; int d = numOne(D);\n    F0Rd(i,N) {\n        r[i] = 0;\n        if (A[i] == '1' || B[i] == '1') {\n            r[i] = calc(a,b,d);\n            a += (A[i] == '1');\n            b += (B[i] == '1');\n        }\n    }\n    int sum = 0;\n    F0Rd(i,N) {\n        AD(sum,r[i]);\n        if (A[i] == '1' && B[i] == '1') MUL(sum,2);\n        AD(ans,mul(sum,l[i]));\n    }\n}\n\nint main() {\n    // you should actually read the stuff at the bottom\n    setIO(); re(N,M,A,B,C,D); // 4,6,7: bad\n    z.init(MOD);\n    if (zero(A) && zero(B) && zero(C) && zero(D)) {\n        pr(1);\n        exit(0);\n    }\n    test();\n    swap(A,C), swap(B,D); swap(N,M);\n    test();\n    pr(ans);\n    FOR(a,1,6) FOR(b,1,6) pr(a,b,5,calc(a,b,5));\n    // you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',')cerr<<*sdbg++; cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nstruct FastNewton {\n private:\n  long long P;\n  long long range;\n  vector<long long> inv;\n  vector<long long> fact;\n  vector<long long> fact_inv;\n  vector<long long> v_p;\n \n public:\n  FastNewton (long long _P, long long _range = 0) {\n    init(_P, _range);\n  }\n  \n  // Initialize structures to support computing n choose k mod _P, where n <= range\n  void init(long long _P, long long _range = -1) {\n    P = _P;\n    if (_range == -1) {\n      range = P;\n    } else {\n      range = _range;\n    }\n    inv.resize(range + 5);\n    fact.resize(range + 5);\n    fact_inv.resize(range + 5);\n    v_p.resize(range + 5);\n    fact[0] = 1;\n    fact_inv[0] = 1;\n    inv[0] = -1;\n    inv[1] = 1;\n    for (int i = 2; i < min(range, P); i++) {\n      inv[i] = P - (P / i) * inv[P % i] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      ll tmp = i;\n      while (tmp % P == 0) {\n        tmp /= P;\n      }\n      fact[i] = tmp * fact[i - 1] % P;\n      fact_inv[i] = fact_inv[i - 1] * inv[tmp % P] % P;\n    }\n    for (int i = 1; i <= range; i++) {\n      v_p[i] = i / P + v_p[i / P];\n    }\n  }\n  \n  long long get_inv(long long a) const {\n    if (a % P == 0) {\n      cout<<\"ERROR: 0 has not got its inverse\\n\";\n      return -1;\n    }\n    return inv[a % P];\n  }\n  \n  // Computes n! mod P\n  long long get_normal_fact(long long n) const {\n    if (n >= P) {\n      return 0;\n    }\n    return fact[n];\n  }\n  \n  // Computes n!/p^(v_p(n!)) mod P\n  long long get_better_fact(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return fact[n];\n  }\n  \n  // Computes largest k such that p^k | n!\n  long long get_v_p(long long n) const {\n    if (n > range) {\n      cout<<\"ERROR: n too large\\n\";\n      return -1;\n    }\n    return v_p[n];\n  }\n  \n  // Computes (n choose k) mod p\n  long long choose(long long n, long long k) const {\n    if (k < 0 || k > n) {\n      return 0;\n    }\n    if (v_p[n] == v_p[k] + v_p[n - k]) {\n      return fact[n] * fact_inv[k] % P * fact_inv[n - k] % P;\n    } else {\n      return 0;\n    }\n  }\n  \n};\nconst int N = 1e5 + 5;\nconst int P = 998244353;\nFastNewton newt(P, 3 * N);\nint Cnt1(string A) {\n  int heh = 0;\n  for (auto x : A) {\n    heh += (x == '1');\n  }\n  return heh;\n}\nint Go(string A, string B, string C, string D) {\n  int m = SZ(C);\n  int suf = 0;\n  int L = Cnt1(A), R = Cnt1(B), U = Cnt1(C), DD = Cnt1(D);\n  int al = U, ar = 0, cl = DD, cr = 0;\n  int res = 0;\n  FORD (i, m - 1, 0) {\n    int cnt1here = 0;\n    if (C[i] == '1') {\n      al--;\n      cnt1here++;\n    }\n    if (D[i] == '1') {\n      cl--;\n      cnt1here++;\n    }\n    int both = cnt1here == 2;\n    int here_left = -1;\n    if (L == 0) {\n      if (al == 0 && cl == 0) {\n        here_left = 1;\n      } else {\n        here_left = 0;\n      }\n    } else {\n      here_left = newt.choose(al + cl + L - 1, al + cl);\n    }\n    int here_right = 0;\n    if (R == 0) {\n      if (ar == 0 && cr == 0) {\n        here_right = 1;\n      } else {\n        here_right = 0;\n      }\n    } else {\n      here_right = newt.choose(ar + cr + R - 1, ar + cr);\n    }\n    if (cnt1here) {\n      suf = (suf + here_right) % P;\n      if (both) {\n        suf = 2 * suf % P;\n      }\n      res += here_left * suf;\n    }\n    res %= P;\n    if (C[i] == '1') {\n      ar++;\n    }\n    if (D[i] == '1') {\n      cr++;\n    }\n    debug(i, here_left, suf, al, cl, ar, cr);\n  }\n  debug(res);\n  return res;\n}\n  \nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n  \n  int n, m;\n  cin>>n>>m;\n  string A, B, C, D;\n  cin>>A>>B>>C>>D;\n  int res = Go(A, B, C, D) + Go(C, D, A, B);\n  if (Cnt1(A) + Cnt1(B) + Cnt1(C) + Cnt1(D) == 0) {\n    cout<<\"1\"<<endl;\n    return 0;\n  }\n  cout<<res % P<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<typename T = int, T mod = 1'000'000'007, typename U = long long>\nstruct umod{\n        T val;\n        umod(): val(0){}\n        umod(U x){ x %= mod; if(x < 0) x += mod; val = x;}\n        umod& operator += (umod oth){ val += oth.val; if(val >= mod) val -= mod; return *this; }\n\tumod& operator -= (umod oth){ val -= oth.val; if(val < 0) val += mod; return *this; }\n\tumod& operator *= (umod oth){ val = ((U)val) * oth.val % mod; return *this; }\n\tumod& operator /= (umod oth){ return *this *= oth.inverse(); }\n        umod& operator ^= (U oth){ return *this = pwr(*this, oth); }\n\tumod operator + (umod oth) const { return umod(*this) += oth; }\n\tumod operator - (umod oth) const { return umod(*this) -= oth; }\n\tumod operator * (umod oth) const { return umod(*this) *= oth; }\n\tumod operator / (umod oth) const { return umod(*this) /= oth; }\n        umod operator ^ (U oth) const { return umod(*this) ^= oth; }\n\tbool operator < (umod oth) const { return val < oth.val; }\n\tbool operator > (umod oth) const { return val > oth.val; }\n\tbool operator <= (umod oth) const { return val <= oth.val; }\n\tbool operator >= (umod oth) const { return val >= oth.val; }\n\tbool operator == (umod oth) const { return val == oth.val; }\n\tbool operator != (umod oth) const { return val != oth.val; }\n        umod pwr(umod a, U b) const { umod r = 1; for(; b; a *= a, b >>= 1) if(b&1) r *= a; return r; }\n        umod inverse() const {\n\t\tU a = val, b = mod, u = 1, v = 0;\n\t\twhile(b){\n\t\t\tU t = a/b;\n\t\t\ta -= t * b; swap(a, b);\n\t\t\tu -= t * v; swap(u, v);\n\t\t}\n\t\tif(u < 0)\n\t\t\tu += mod;\n\t\treturn u;\n        }\n};\nusing U = umod<int, 998244353>;\ntemplate<typename U>\nstruct NCR {\n        vector<U> fact, ifact;\n        NCR(int size){\n                fact.resize(size + 1); ifact.resize(size + 1);\n                fact[0] = 1;\n                for(int i = 1; i <= size; i++) fact[i] = fact[i - 1] * i;\n                ifact[size] = fact[size].inverse();\n                for(int i = size - 1; i >= 0; i--) ifact[i] = ifact[i + 1] * (i + 1);\n        }\n        U coef(int n, int r){\n                if(n < r) return 0;\n                return fact[n] * ifact[r] * ifact[n - r];\n        }\n};\nconst int maxn = 500500;\nU pref[maxn], suff[maxn], p2[maxn];\nint main(){\n\tNCR<U> ncr(maxn);\n\tint n, m; cin >> n >> m;\n\tstring a, b, c, d; cin >> a >> b >> c >> d;\n\tU ans = 0;\n\tfor(int r = 0; r < 2; r++){\n\t\t{\n\t\t\tint y = count(c.begin(), c.end(), '1');\n\t\t\tint x = 0, z = 0;\n\t\t\tpref[0] = 1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tx += a[i] == '1';\n\t\t\t\tz += b[i] == '1';\n\t\t\t\tif(x + z + y == 0)\n\t\t\t\t\tpref[i + 1] = 1;\n\t\t\t\telse\n\t\t\t\t\tpref[i + 1] = ncr.coef(x + y + z - 1, x + z);\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tint y = count(d.begin(), d.end(), '1');\n\t\t\tint x = 0, z = 0;\n\t\t\tsuff[n] = 1;\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\tx += a[i] == '1';\n\t\t\t\tz += b[i] == '1';\n\t\t\t\tif(x + z + y == 0)\n\t\t\t\t\tsuff[i] = 1;\n\t\t\t\telse\n\t\t\t\t\tsuff[i] = ncr.coef(x + y + z - 1, x + z);\n\t\t\t}\n\t\t}\n\t\tp2[n] = 1;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tp2[i] = p2[i + 1];\n\t\t\tif(a[i] == '1' && b[i] == '1'){\n\t\t\t\tp2[i] *= 2;\n\t\t\t}\n\t\t}\n\t\tU sum = 0;\n\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\tif(a[i] == '1' || b[i] == '1'){\n\t\t\t\tsum += suff[i + 1] * p2[i + 1].inverse();\n\t\t\t\tans += pref[i] * sum * p2[i];\n\t\t\t}\n\t\t}\n\t\tswap(a, c);\n\t\tswap(b, d);\n\t\tswap(n, m);\n\t}\n\tint p = count(a.begin(), a.end(), '0') + count(b.begin(), b.end(), '0') + count(c.begin(), c.end(), '0') + count(d.begin(), d.end(), '0');\n\tif(p == 2 * n + 2 * m) ans = 1;\n\tcout << ans.val << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string.h>\n#include<stdio.h>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nint a[100011][2],b[100011][2];\nlong long MOD=998244353;\nlong long fa[300011];\nlong long invfa[300011];\nlong long two[300011];\n\n\nint p[100011];\nint ppos[100011];\nint q[100011];\nint sp[100011];\nint sa[100011][2];\n\n\n//******************************\n//返回d=gcd(a,b);和对应于等式ax+by=d中的x,y\nlong long extend_gcd(long long a,long long b,long long &x,long long &y)\n{\n if(a==0&&b==0) return -1;//无最大公约数\n if(b==0){x=1;y=0;return a;}\n long long d=extend_gcd(b,a%b,y,x);\n y-=a/b*x;\n return d;\n}\n//*********求逆元素*******************\n//ax = 1(mod n)\nlong long mod_reverse(long long a,long long n)\n{\n long long x,y;\n long long d=extend_gcd(a,n,x,y);\n if(d==1) return (x%n+n)%n;\n else return -1;\n}\n\nlong long inv(long long a)\n{\n    return mod_reverse(a,MOD);\n}\n\n/* \nlong long exgcd(long long a,long long b,long long &x,long long &y)  \n{  \n    if(b==0)\n    {  \n        x=1;\n        y=0;\n        return a;\n    }\n    int r=exgcd(b,a%b,x,y);\n    long long t=y;\n    y=x-(a/b)*y;\n    x=t;\n    return r;\n}  \nlong long inv(long long a)  \n{  \n    long long x,y;  \n    long long r=exgcd(a,MOD,x,y);  \n    if(r==1) return (x%MOD+MOD)%MOD;  \n    return -1;  \n}\n*/\n\nlong long C(int n,int k)\n{\n    long long ans=fa[n]*invfa[k]%MOD*invfa[n-k]%MOD;\n    return ans;\n}\n\n\nlong long calc(long long x,long long y,long long z)\n{\n    if(x==0)\n    {\n        if(y==0 && z==0)return 1;\n        return 0;\n    }\n    \n    long long ans=(C(x+y+z,x)-C(x+y+z-1,x)+MOD)%MOD;\n    \n    \n    //cout<<\"calc\"<<' '<<x<<' '<<y<<' '<<z<<\"   \"<<ans<<endl;\n    \n    return ans;\n}\n\nlong long gao(int a[][2],int b[][2],int n,int m)\n{\n    int i,j,k;\n    int mm1,mm2;\n    mm1=mm2=0;\n    for(i=1;i<=m;i++)\n    {\n        mm1+=(b[i][0]==1);\n        mm2+=(b[i][1]==1);\n        \n        //cout<<b[i][0]<<' '<<b[i][1]<<endl;\n    }\n    \n    \n    \n    long long ans=0;\n    sa[0][0]=a[0][1]=0;\n    for(i=1;i<=n;i++)\n    {\n        sa[i][0]=sa[i-1][0]+a[i][0];\n        sa[i][1]=sa[i-1][1]+a[i][1];\n    }\n    \n    int nn=0;\n    for(i=1;i<=n;i++)\n    {\n        if(a[i][0]==1 && a[i][1]==1)\n        {\n            p[++nn]=2;\n            ppos[nn]=i;\n        }\n        else if(a[i][0]==1 || a[i][1]==1)\n        {\n            p[++nn]=1;\n            ppos[nn]=i;\n        }\n    }\n    sp[0]=0;\n    for(i=1;i<=nn;i++)\n    {\n        sp[i]=sp[i-1]+(p[i]==2);\n    }\n    \n    \n    long long tmp=0;\n    long long lans=1;\n    long long rans;\n    int ll,rr;\n    ll=1;\n    \n    \n    //cout<<mm1<<' '<<mm2<<\" mmm\"<<endl;\n    for(rr=1;rr<=nn;rr++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[rr]][0],sa[n][1]-sa[ppos[rr]][1]);\n        tmp=(tmp+lans*rans%MOD*two[sp[rr]-sp[ll-1]]%MOD)%MOD;\n    }\n    //cout<<\"tmp0\"<<tmp<<endl;\n    \n    ans=(ans+tmp)%MOD;\n    for(ll=2;ll<=nn;ll++)\n    {\n        rans=calc(mm2,sa[n][0]-sa[ppos[ll-1]][0],sa[n][1]-sa[ppos[ll-1]][1]);\n        tmp=(tmp-lans*rans%MOD*two[sp[ll-1]-sp[ll-2]]%MOD+MOD)%MOD;\n        //cout<<tmp<<\"  &&&\"<<endl;\n        tmp=tmp*inv(lans)%MOD;\n        lans=calc(mm1,sa[ppos[ll]-1][0],sa[ppos[ll]-1][1]);\n        tmp=tmp*lans%MOD;\n        if(p[ll-1]==2)\n        {\n            tmp=tmp*inv(2)%MOD;\n        }\n        \n        //cout<<\"tmp\"<<tmp<<endl;\n        \n        ans=(ans+tmp)%MOD;\n    }\n    \n    \n    return ans;\n}\n\n\nint main()\n{\n    int i,j,k;\n    char c;\n    fa[0]=1;\n    invfa[0]=1;\n    for(i=1;i<=300000;i++)\n    {\n        fa[i]=(fa[i-1]*i)%MOD;\n        invfa[i]=inv(fa[i]);\n    }\n    two[0]=1;\n    for(i=1;i<=300000;i++)\n    {\n        two[i]=(two[i-1]*2)%MOD;\n    }\n    \n    bool f=0;\n    scanf(\"%d %d\",&n,&m);\n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=n;i++)\n    {\n        \n            scanf(\" %c\",&c);\n            a[i][j]=c-'0';\n            if(a[i][j]==1)f=1;\n    }\n    }\n    \n    for(j=0;j<=1;j++)\n    {\n    for(i=1;i<=m;i++)\n    {\n            scanf(\" %c\",&c);\n            b[i][j]=c-'0';\n            if(b[i][j]==1)f=1;\n    }\n    }\n    \n    if(f==0)\n    {\n        cout<<1<<endl;\n        return 0;\n    }\n    \n    long long ans=0;\n    ans+=gao(a,b,n,m);\n    ans+=gao(b,a,m,n);\n    ans%=MOD;\n    cout<<(ans+MOD)%MOD<<endl;\n    \n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "//my vegetable has exploded. :(\n#include<bits/stdc++.h>\n#define max(x,y) (x>y?x:y)\n#define min(x,y) (x<y?x:y)\n#define MM(x,y) memset(x,y,sizeof(x))\n#define MCPY(a,b) memcpy(a,b,sizeof(b))\n#define pb push_back\n#define rep(i,a,b) for(int i=a;i<=b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define fi first\n#define se second\nusing namespace std;\n#define nl puts(\"\")\n#define int long long\n\ninline int quickpow(int m,int n,int p){int b=1;while(n){if(n&1)b=b*m%p;n=n>>1;m=m*m%p;}return b;}\ninline int getinv(int x,int p){return quickpow(x,p-2,p);}\ninline int read(void){\n    int x=0,f=1;char ch=getchar();\n    while(!isdigit(ch)){f=ch=='-'?-1:1;ch=getchar();}\n    while(isdigit(ch)){x=(x<<3)+(x<<1)+ch-'0';ch=getchar();}\n    return x * f;\n}\nconst int MAXN = 4e5 + 10;\nconst int Mod = 998244353;\nconst int inv2 = getinv(2,Mod);\nint inv[MAXN],fac[MAXN],n,m,Ans;\nchar A[MAXN],B[MAXN],C[MAXN],D[MAXN];\nint a[MAXN],b[MAXN];\ninline void init(void){\n    inv[0]=inv[1]=fac[0]=1;\n    rep(i,1,4e5) fac[i] = 1LL * fac[i-1] * i % Mod;\n    inv[400000] = getinv(fac[400000],Mod);\n    per(i,4e5-1,1) inv[i] = inv[i+1] * (i+1) % Mod;\n}\n///------------------head------------------\ninline int Combine(int n,int m){return fac[n] * inv[m] % Mod * inv[n-m] % Mod;}\ninline void calc(int n,int m,char *A,char *B,char *C,char *D){\n    MM(a,0); MM(b,0);\n    a[0] = b[m+1] = 1;\n    int c1=0,c2=0,ret=0;\n    rep(i,1,n) c2 += A[i] == '1';\n    rep(i,1,m){\n        if (D[i]=='1') ++c1;\n        if (C[i]=='1') ++c1;\n        a[i] = Combine(c1+c2,c1);\n        if (c1) a[i] = (a[i] - Combine(c1+c2-1,c1-1) + Mod) % Mod;\n    }\n    c1 = 0,c2 = 0;\n    rep(i,1,n) c2 += B[i] == '1';\n    per(i,m,1){\n        if (D[i]=='1') ++c1;\n        if (C[i]=='1') ++c1;\n        b[i] = Combine(c1+c2,c1);\n        if (c1) b[i] = (b[i] - Combine(c1+c2-1,c1-1) + Mod) % Mod;\n    }\n    int t = 1;\n    rep(i,0,m) {\n        if (i > 0 && C[i] == '1' && D[i] == '1') t = t * inv2 % Mod;\n        a[i] = a[i] * t % Mod;\n        if (i <= m && C[i+1] == '0' && D[i+1] == '0') a[i] = 0;\n    }\n    rep(i,1,m) a[i]=(a[i-1]+a[i])%Mod;\n    t=1;\n    rep(i,1,m+1)\n    {\n        b[i] = b[i] * t % Mod;\n        if (i <= m && C[i] == '1' && D[i] == '1') t = t * 2 % Mod;\n        if (i > 1 && C[i-1] == '0' && D[i-1] == '0') b[i] = 0;\n    }\n    rep(i,1,m) ret = (ret + a[i-1] * b[i+1]) % Mod;\n    Ans = (Ans + ret) % Mod;\n}\nsigned main(signed argc, char *argv[])\n{\n    // freopen(\"a01.txt\",\"r\",stdin);\n    // freopen(\"my.out\",\"w\",stdout);\n    init();\n    n=read();m=read();\n    scanf(\"%s\",A+1); scanf(\"%s\",B+1); scanf(\"%s\",C+1); scanf(\"%s\",D+1);\n    int ok=0;\n    rep(i,1,n) ok|=(A[i]=='1')|(B[i]=='1');\n    rep(i,1,m) ok|=(C[i]=='1')|(D[i]=='1');\n    if (!ok) return puts(\"-1\"),0;\n    calc(n,m,A,B,C,D); calc(m,n,C,D,A,B);\n    printf(\"%lld\\n\",Ans % Mod);\n    return 0;\n}\n\n/* Examples: */\n/*\n\n*/\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\n//const ll mod=1e9+7;\nconst ll mod=998244353;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nll Pow(ll n,ll p){\n\tll r=1;\n\tfor(;p>0;p>>=1){\n\t\tif(p&1) r=(r*n)%mod;\n\t\tn=(n*n)%mod;\n\t}\n\treturn r;\n}\n\nconst int M=1000005;\nll F[M];\n\nvoid Init(){\n\tF[0]=1;\n\tfor(int i=1;i<M;i++) F[i]=F[i-1]*i%mod;\n}\n\nll Div(ll n,ll m){\n\treturn n*Pow(m,mod-2)%mod;\n}\n\nll nCk(ll n,ll k){\n\tif(n<0) return 1;\n\treturn Div(F[n],F[n-k]*F[k]%mod);\n}\n\nint n,m;\nstring A,B,C,D;\n\nbool Check(string s){\n\tint N=s.size();\n\treturn s==string(N,'0');\n}\n\nvl ff(){\n\tvl a(m+1);\n\ta[0]++;\n\tif(Check(A)){\n\t\tfor(int i=0;i<m&&C[i]=='0'&&D[i]=='0';i++) a[i+1]++;\n\t}\n\telse{\n\t\tint S=0,t=0;\n\t\tfor(int i=0;i<n;i++) S+=A[i]-'0';\n\t\tfor(int i=0;i<m;i++){\n\t\t\tt+=C[i]-'0'+D[i]-'0';\n\t\t\ta[i+1]=nCk(S+t-1,t);\n\t\t}\n\t}\n\tswap(A,B);\n\treverse(C.begin(),C.end());\n\treverse(D.begin(),D.end());\n\treturn a;\n}\n\nll f(){\n\tll res=0,t=0;\n\tvl a=ff(),b=ff();\n\tfor(int i=0;i<m;i++) if(C[i]=='1'||D[i]=='1'){\n\t\tt=(C[i]-'0'+D[i]-'0')*(a[i]+t)%mod;\n\t\t(res+=t*b[m-1-i])%=mod;\n\t}\n\tswap(A,C);swap(B,D);swap(n,m);\n\treturn res;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin>>n>>m>>A>>B>>C>>D;\n\tInit();\n\tif(Check(A)&&Check(B)&&Check(C)&&Check(D)) cout<<1<<endl;\n\telse cout<<(f()+f())%mod<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int N=200010;\nconst int maxn=200000;\n//const int N=20;\n//const int maxn=10;\nconst int mod=998244353;\nint a[N][2],sa[N][2],b[N][2],sb[N][2];\nint cj[N],inv[N];\nchar s[N];\nint ans;\n\nint power(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod){\n\t\tif(y&1)\tret=1ll*ret*x%mod;\n\t}\n\treturn ret;\n}\n\nint C(int n,int m){\n\treturn 1ll*cj[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint calc(int n,int m){\n\tif(n==0&&m==0)\treturn 1;\n\tif(n==0)\treturn 0;\n\tif(m==0)\treturn 1;\n\treturn C(n+m-1,m);\n}\n\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint n,m;int i,j,now;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);rep(i,1,n)\ta[i][0]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,n)\ta[i][1]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,m)\tb[i][0]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,m)\tb[i][1]=s[i]=='1';\n\trep(i,1,n)\trep(j,0,1)\tsa[i][j]=sa[i-1][j]+a[i][j];\n\trep(i,1,m)\trep(j,0,1)\tsb[i][j]=sb[i-1][j]+b[i][j];\n\trep(i,1,n)\t\n\tcj[0]=1;rep(i,1,maxn)\tcj[i]=1ll*cj[i-1]*i%mod;\n\tinv[maxn]=power(cj[maxn],mod-2);inv[0]=1;\n\tfor(i=maxn-1;i;i--)\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tnow=0;\n\trep(i,1,n){\n\t\tif(a[i][0]+a[i][1]==0)\tcontinue;\n\t\tnow=(now+calc(sb[m][0],sa[i-1][0]+sa[i-1][1]))%mod;\n\t\tans=(ans+1ll*now*(a[i][0]+a[i][1])*calc(sb[m][1],sa[n][0]+sa[n][1]-sa[i][0]-sa[i][1]))%mod;\n\t\tnow=1ll*now*(a[i][0]+a[i][1])%mod;\n\t}\n\tnow=0;\n\trep(i,1,m){\n\t\tif(b[i][0]+b[i][1]==0)\tcontinue;\n\t\tnow=(now+calc(sa[n][0],sb[i-1][0]+sb[i-1][1]))%mod;\n\t\tans=(ans+1ll*now*(b[i][0]+b[i][1])*calc(sa[n][1],sb[m][0]+sb[m][1]-sb[i][0]-sb[i][1]))%mod;\n\t\tnow=1ll*now*(b[i][0]+b[i][1])%mod;\n\t}\n\tif(sa[n][0]+sa[n][1]+sb[m][0]+sb[m][1]==0)\tans=1;\n\tprintf(\"%d\",ans);\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n#define MAXN 100000\n#define MOD 998244353\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint fac[3*MAXN+5], efac[3*MAXN+5], N, M, T, ans; char l[MAXN+5], r[MAXN+5], u[MAXN+5], d[MAXN+5];\nint L[MAXN+5], R[MAXN+5], U[MAXN+5], D[MAXN+5], LR[MAXN+5], UD[MAXN+5], b[MAXN+5], col[MAXN+5], row[MAXN+5];\ninline int e(int s, int n=MOD-2){int a = 1; for(; n; n&1 ? a = 1ll*a*s%MOD : 0, s = 1ll*s*s%MOD, n >>= 1); return a;}\ninline int C(int n, int k){return n<0||k<0||n<k?0:1ll*fac[n]*efac[k]%MOD*efac[n-k]%MOD;}\ninline int F(int U, int D, int R){return R ? C(U+D+R-1,R-1) : !U&&!D;}\nint main()\n{\n\tN = read(), M = read(), scanf(\"%s%s%s%s\",l+1,r+1,u+1,d+1);\n\tfor(rint i = 1; i <= N; L[i] = L[i-1]+l[i]-'0', i++); for(rint i = 1; i <= N; R[i] = R[i-1]+r[i]-'0', LR[i] = LR[i-1]+(r[i]>'0'&&l[i]>'0'), i++);\n\tfor(rint j = 1; j <= M; U[j] = U[j-1]+u[j]-'0', j++); for(rint j = 1; j <= M; D[j] = D[j-1]+d[j]-'0', UD[j] = UD[j-1]+(d[j]>'0'&&u[j]>'0'), j++);\n\tif(!L[N]&&!R[N]&&!U[M]&&!D[M]) return puts(\"1\"),0; T = max(LR[N],UD[M]); b[0] = 1; for(rint i = 1; i <= T; b[i] = b[i-1]<<1, b[i]<MOD?:b[i]-=MOD, i++);\n\tT = max(L[N]+R[N]+max(U[M],D[M]),U[M]+D[M]+max(L[N],R[N])); fac[0] = 1; for(rint i = 1; i <= T; fac[i] = 1ll*i*fac[i-1]%MOD, i++);\n\tefac[T] = e(fac[T],MOD-2); for(rint i = T; i; efac[i-1] = 1ll*i*efac[i]%MOD, i--);\n\tfor(rint i = N; i; row[i] = (row[i+1]+(L[i]>L[i-1]||R[i]>R[i-1]?1ll*b[LR[i]]*F(L[N]-L[i],R[N]-R[i],D[M]):0))%MOD, i--);\n\tfor(rint j = M; j; col[j] = (col[j+1]+(U[j]>U[j-1]||D[j]>D[j-1]?1ll*b[UD[j]]*F(U[M]-U[j],D[M]-D[j],R[N]):0))%MOD, j--);\n\tfor(rint i = N; i; ans = (ans+(L[i]>L[i-1]||R[i]>R[i-1]?1ll*F(L[i-1],R[i-1],U[M])*e(b[LR[i-1]])%MOD*row[i]:0))%MOD, i--);\n\tfor(rint j = M; j; ans = (ans+(U[j]>U[j-1]||D[j]>D[j-1]?1ll*F(U[j-1],D[j-1],L[N])*e(b[UD[j-1]])%MOD*col[j]:0))%MOD, j--); printf(\"%d\\n\",ans); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = (1e5 + 10) * 3, P = 998244353;\ninline void pp(int &x,int d){if((x+=d)>=P)x-=P;}\ninline int mul(int a,int b){return ll(a)*b%P;}\nint fac[N] = {1} , ifac[N] , pw[N] = {1} , ipw[N] = {1};\nint inv(int x){return x == 1 ? 1 : P-ll(P/x)*inv(P%x)%P;}\ninline int comb(int a,int b){return mul(fac[a],mul(ifac[b],ifac[a-b]));}\nint n , m , lsum[N];\nstring A , B , C , D;\n\nint solve(){\n    int left = 0;\n    for(auto ch : A) left += ch == '1';\n    int base = 0 , up = 0 , down = 0;\n    rep(i,0,m) {\n        lsum[i] = i ? lsum[i-1] : 0;\n        if(C[i] == '1' || D[i] == '1') {\n            if(left == 0) pp(lsum[i] , mul(ipw[base] , up == 0 && down == 0));\n            else pp(lsum[i] , mul(ipw[base] , comb(left + up + down - 1 , left - 1)));\n        }\n        up += C[i] == '1';\n        down += D[i] == '1';\n        if(C[i] == '1' && D[i] == '1') base++;\n    }\n    int right = 0;\n    for(auto ch : B) right += ch == '1';\n    base = 0 , up = 0 , down = 0;\n    int res = 0;\n    per(i,0,m) {\n        int tmp = 0;\n        if(right == 0) tmp = mul(ipw[base] , up == 0 && down == 0);\n        else tmp = mul(ipw[base] , comb(right + up + down - 1 , right - 1));\n        up += C[i] == '1';\n        down += D[i] == '1';\n        if(C[i] == '1' || D[i] == '1') pp(res , mul(lsum[i] , tmp));\n        if(C[i] == '1' && D[i] == '1') base++;\n    }\n    return mul(res , pw[base]);\n}\n\nint main(){\n    rep(i,1,N) fac[i] = mul(fac[i-1] , i);\n    ifac[N-1] = inv(fac[N-1]);\n    per(i,1,N) ifac[i-1] = mul(ifac[i] , i);\n    int inv2 = inv(2);\n    rep(i,1,N) pw[i] = mul(pw[i-1] , 2);\n    rep(i,1,N) ipw[i] = mul(ipw[i-1] , inv2);\n    cin >> n >> m;\n    cin >> A >> B >> C >> D;\n    int ans = solve();\n    swap(n , m);\n    swap(A , C);\n    swap(B , D);\n    pp(ans , solve());\n    bool has = false;\n    for(auto ch : A) has |= ch == '1';\n    for(auto ch : B) has |= ch == '1';\n    for(auto ch : C) has |= ch == '1';\n    for(auto ch : D) has |= ch == '1';\n    if(has == false) ans ++;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#define MOD 998244353\ntypedef long long ll; \ninline ll quick_pow(ll a, int n)\n{\n\tll res = 1; \n\twhile (n)\n\t{\n\t\tif (n & 1)\n\t\t\tres = res * a % MOD; \n\t\ta = a * a % MOD; \n\t\tn >>= 1; \n\t}\n\treturn res;\n}\nll fact[300005], inv[300005], dp[100005], ans; \ninline ll C(int n, int m)\n{\n\tif (n == -1 && m == -1)\n\t\treturn 1; \n\tif (n < 0 || m < 0)\n\t\treturn 0; \n\treturn fact[n] * inv[m] % MOD * inv[n - m] % MOD; \n}\ninline void work(int n, int m, char *a, char *b, char *c, char *d)\n{\n\tint a1 = 0, b1 = 0, c1 = 0, d1 = 0; \n\tfor (int i = 0; i < n; i++)\n\t{\n\t\ta1 += a[i] == '1'; \n\t\tb1 += b[i] == '1'; \n\t}\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tc1 += c[i] == '1'; \n\t\td1 += d[i] == '1'; \n\t}\n\tif (!a1 && !b1 && !c1 && !d1)\n\t{\n\t\tans = 1; \n\t\treturn; \n\t}\n\tc1 = d1 = 0; \n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tdp[i] = i ? dp[i - 1] : 0; \n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t\t(dp[i] += C(c1 + d1 + a1 - 1, a1 - 1)) %= MOD; \n\t\tif (c[i] == '1' && d[i] == '1')\n\t\t\t(dp[i] += dp[i]) %= MOD; \n\t\tc1 += c[i] == '1'; \n\t\td1 += d[i] == '1'; \n\t}\n\tc1 = d1 = 0; \n\tfor (int i = m - 1; i >= 0; i--)\n\t{\n\t\tif (c[i] == '1' || d[i] == '1')\n\t\t\t(ans += dp[i] * C(c1 + d1 + b1 - 1, b1 - 1)) %= MOD; \n\t\tc1 += c[i] == '1'; \n\t\td1 += d[i] == '1'; \n\t}\n}\nchar a[100005], b[100005], c[100005], d[100005]; \nint main()\n{\n\t// freopen(\"CF17-QA-E.in\", \"r\", stdin); \n\tint n, m;\n\tscanf(\"%d%d%s%s%s%s\", &n, &m, a, b, c, d); \n\tfact[0] = inv[0] = 1; \n\tfor (int i = 1; i <= 3e5; i++)\n\t{\n\t\tfact[i] = fact[i - 1] * i % MOD; \n\t\tinv[i] = quick_pow(fact[i], MOD - 2); \n\t}\n\twork(n, m, a, b, c, d);\n\twork(m, n, c, d, a, b);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 998244353\ninline void add(int &x, int v) { x += v; if (x >= MOD) x -= MOD; }\ninline int mul(int x , int y) { return (1LL*x*y)%MOD; }\nint modpow(int x, int k) {\n  int a = 1;\n  while(k) {\n    if (k&1)a=mul(a,x);\n    x=mul(x,x);\n    k>>=1;\n  }\n  return a;\n}\nint inv(int x) {\n  return modpow(x,MOD-2);\n}\nint fact[400001];\nint nCr(int n, int r) {\n  if (r < 0 || r > n) return 0;\n  return mul(mul(fact[n], inv(fact[r])),inv(fact[n-r]));\n}\n\nint f(int h, int u, int d) {\n  if (u == 0 && d == 0) return 1;\n  if (h == 0) return 0;\n  return nCr(u+d+h-1, h-1);\n}\n\nint L[100000];\nint R[100000];\nint solve(int H, int W, string left, string right, string top, string bottom) {\n  rep(i, W) L[i] = R[i] = 0;\n\n  int h = 0, u = 0, d = 0;\n  for (char c : right) h += c == '1';\n  for (int r=W-1; r>=0; r--) if (top[r]=='1'||bottom[r]=='1') {\n    R[r] = f(h, u, d);\n    u += top[r]=='1';\n    d += bottom[r]=='1';\n  }\n\n  h = 0, u = 0, d = 0;\n  for (char c : left) h += c == '1';\n  for (int l=0; l<W; l++) if (top[l]=='1' || bottom[l]=='1') {\n    L[l] = f(h, u, d);\n    u += top[l]=='1';\n    d += bottom[l]=='1';\n  }\n\n  int s = 0, e = 0;\n  for (int l=W-1; l>=0; l--) {\n    add(e, R[l]);\n    if (top[l]=='1'&&bottom[l]=='1') e = mul(2, e);\n    add(s, mul(e, L[l]));\n  }\n  return s;\n}\n\nint N, M;\nstring A, B, C, D;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  fact[0] = 1;\n  for (int i=1; i<=400000; i++) fact[i]=mul(fact[i-1],i);\n\n  cin >> N >> M >> A >> B >> C >> D;\n  int s = 0;\n  add(s, solve(N, M, A, B, C, D));\n  add(s, solve(M, N, C, D, B, A));\n  cout << s << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mod 998244353\n#define ll long long\n#define N 201000\nusing namespace std;\nvoid U(ll &x,ll y){x=x*y%mod;}\nvoid V(ll &x,ll y){x=(x+y)%mod;}\nll K(ll x,int y){ll t=1;for(;y;y>>=1,U(x,x))if(y&1)U(t,x);return t;}\nll jc[N<<1],inv[N<<1],ans=0;\nll C(int x,int y){return x<y?0:jc[x] *inv[y]%mod *inv[x-y]%mod;}\nvoid pre(int mx){jc[0]=1; for (int i=1;i<=mx;i++) jc[i]=jc[i-1]*i%mod;\n\tinv[mx]=K(jc[mx],mod-2); for (int i=mx;i>0;i--) inv[i-1]=inv[i]*i%mod;}\n\n\nll cal(int x,int y,int z){\n\treturn !x? y+z==0: C(x+y+z-1,x-1);\n}\nvoid doit(int n,int m,char l[],char r[],char u[],char d[]){\n\tll tmp; int cl=0,cr=0,cu=0,cd=0,nowu=0,nowd=0,uu,dd;\n\tfor (int i=1;i<=n;i++) cl+=l[i]-'0',cr+=r[i]-'0';\n\tfor (int i=1;i<=m;i++) cu+=u[i]-'0',cd+=d[i]-'0';\n\ttmp=cal(cl,0,0);\n\tfor (int i=1;i<=m;i++){\n\t\tnowu+=(uu=u[i]-'0'); nowd+=(dd=d[i]-'0');\n\t\tif (uu||dd){\n\t\t\tif (uu&&dd) U(tmp,2);\n\t\t\tV(ans,tmp*cal(cr,cu-nowu,cd-nowd));\n\t\t\tV(tmp,cal(cl,nowu,nowd));\n\t\t}\n\t}\n}\n\nchar a[N],b[N],c[N],d[N];\nint main(){\n\tpre(N*2-10); int n,m;\n\tscanf(\"%d%d%s%s%s%s\",&n,&m,a+1,b+1,c+1,d+1);\n\tdoit(n,m,a,b,c,d);\n\tdoit(m,n,c,d,a,b);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include  <stdio.h>\n#include   <math.h>\n#include   <time.h>\n#include   <vector>\n#include   <bitset>\n#include    <queue>\n#include      <set>\n#include      <map>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=500005,Mod=998244353;\n\nint n,m,fac[N],ifac[N];\nchar A[N],B[N],C[N],D[N];\n\nint Pow(int a,int b)\n{\n\tint s=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\ts=s*(LL)a%Mod;\n\t\ta=a*(LL)a%Mod;b>>=1;\n\t}\n\treturn s;\n}\n\nint calc(int a,int b)\n{\n\tif(a<b)\n\t\treturn 0;\n\treturn fac[a]*(LL)ifac[b]%Mod*ifac[a-b]%Mod;\n}\n\nint Nums[N],Sums[N];\n\nint solve(int n,int m,char A[],char B[],char C[],char D[])\n{\n\tint NumC=0,NumD=0;\n\tfor(int i=0;i<m;i++)\n\t\tNumC+=C[i]=='1',NumD+=D[i]=='1';\n\tint a=0,b=0,sa=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i==0)\n\t\t\tNums[i]=0;\n\t\telse\n\t\t{\n\t\t\tNums[i]=Nums[i-1];\n\t\t\tif(A[i-1]=='1'&&B[i-1]=='1')\n\t\t\t\tNums[i]=Nums[i]*2%Mod;\n\t\t\tif(A[i-1]=='1')\n\t\t\t\tNums[i]=(Nums[i]+Sums[i-1])%Mod;\n\t\t\tif(B[i-1]=='1')\n\t\t\t\tNums[i]=(Nums[i]+Sums[i-1])%Mod;\n\t\t\ta+=A[i-1]=='1',b+=B[i-1]=='1',sa=sa*((A[i-1]=='1')+(B[i-1]=='1'))%Mod;\n\t\t}\n\t\tSums[i]=(NumC?calc(a+b+NumC-1,a+b):sa);\n\t}\n\ta=0,b=0;sa=1;\n\tint Ans=0;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tif(i!=n-1)\n\t\t\ta+=A[i+1]=='1',b+=B[i+1]=='1',sa=sa*((A[i+1]=='1')+(B[i+1]=='1'))%Mod;\n\t\tif(A[i]=='1')\n\t\t{\n\t\t\tAns=(Ans+(LL)(Nums[i]+Sums[i])*(NumD?calc(a+b+NumD-1,a+b):sa))%Mod;\n\t\t}\n\t\tif(B[i]=='1')\n\t\t{\n\t\t\tAns=(Ans+(LL)(Nums[i]+Sums[i])*(NumD?calc(a+b+NumD-1,a+b):sa))%Mod;\n\t\t}\n\t//\tcout<<i<<\" \"<<Nums[i]<<\" \"<<Sums[i]<<\" \"<<calc(a+b+NumD-1,a+b)<<endl;\n\t}\n\treturn Ans;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tfac[i]=fac[i-1]*(LL)i%Mod;\n\tifac[N-1]=Pow(fac[N-1],Mod-2);\n\tfor(int j=N-1;j;j--)\n\t\tifac[j-1]=ifac[j]*(LL)j%Mod;\n\tscanf(\"%d%d%s%s%s%s\",&n,&m,A,B,C,D);\n\tcout<<(solve(n,m,A,B,C,D)+solve(m,n,C,D,A,B))%Mod;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\t\nusing namespace std;\nint N,M;\nconst int MAX_N=1e5,MAX_M=1e5;\nchar A[MAX_N+1],B[MAX_N+1],C[MAX_M+1],D[MAX_M+1];\nconst ll MOD=998244353;\nint psmup[MAX_M+1],psmdown[MAX_M+1],lftmn,rigmn;\nll lpnt[MAX_M],rpnt[MAX_M],fact[MAX_N*3+1],ifact[MAX_N*3+1];\nll mpw(ll n,ll m){\n\tll ret=1;\n\twhile(m){\n\t\tif(m&1){\n\t\t\tret*=n;\n\t\t\tret%=MOD;\n\t\t}\n\t\tn*=n;\n\t\tn%=MOD;\n\t\tm>>=1;\n\t}\n\treturn ret;\n}\nll cmb(int n,int m){\n\treturn fact[n]*ifact[m]%MOD*ifact[n-m]%MOD;\n}\nint main(){\n\tscanf(\"%d %d %s %s %s %s\",&N,&M,A,B,C,D);\n\tfact[0]=1;\n\tREP(i,MAX_N*3){\n\t\tfact[i+1]=(i+1)*fact[i]%MOD;\n\t}\n\tifact[MAX_N*3]=mpw(fact[MAX_N*3],MOD-2);\n\tfor(int i=MAX_N*3-1;i>=0;i--){\n\t\tifact[i]=(i+1)*ifact[i+1]%MOD;\n\t}\n\tll ans=0;\n\tREP(q,2){\n\t\tREP(i,M){\n\t\t\tpsmup[i+1]=psmup[i]+(C[i]=='1');\n\t\t\tpsmdown[i+1]=psmdown[i]+(D[i]=='1');\n\t\t}\n\t\tlftmn=rigmn=0;\n\t\tREP(i,N){\n\t\t\tlftmn+=(A[i]=='1');\n\t\t\trigmn+=(B[i]=='1');\n\t\t}\n\t\tif(lftmn==0 && rigmn==0 && psmup[M]==0 && psmdown[M]==0){\n\t\t\tans=1;\n\t\t\tbreak;\n\t\t}\n\t\tif(psmup[M]>0 || psmdown[M]>0){\n\t\t\tREP(i,M){\n\t\t\t\tif(C[i]=='1' || D[i]=='1'){\n\t\t\t\t\tif(lftmn==0){\n\t\t\t\t\t\tif(psmup[i]==0 && psmdown[i]==0){\n\t\t\t\t\t\t\tlpnt[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tlpnt[i]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tlpnt[i]=cmb(lftmn+psmup[i]+psmdown[i]-1,lftmn-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(rigmn==0){\n\t\t\t\t\t\tif(psmup[M]-psmup[i+1]==0 && psmdown[M]-psmdown[i+1]==0){\n\t\t\t\t\t\t\trpnt[i]=1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\trpnt[i]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\trpnt[i]=cmb(rigmn+psmup[M]-psmup[i+1]+psmdown[M]-psmdown[i+1]-1,rigmn-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tll tmp=0,p2=1,inv2=mpw(2,MOD-2);\n\t\t\tREP(i,M){\n\t\t\t\tif(C[i]=='1' || D[i]=='1'){\n\t\t\t\t\tif(C[i]=='1' && D[i]=='1'){\n\t\t\t\t\t\tp2<<=1;\n\t\t\t\t\t\tp2%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\ttmp+=p2*rpnt[i]%MOD;\n\t\t\t\t\ttmp%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t\tREP(i,M){\n\t\t\t\tif(C[i]=='1' || D[i]=='1'){\n\t\t\t\t\tans+=tmp*lpnt[i]%MOD;\n\t\t\t\t\tans%=MOD;\n\t\t\t\t\tif(C[i]=='1' && D[i]=='1'){\n\t\t\t\t\t\ttmp*=inv2;\n\t\t\t\t\t\ttmp%=MOD;\n\t\t\t\t\t}\n\t\t\t\t\ttmp+=MOD-rpnt[i];\n\t\t\t\t\ttmp%=MOD;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(A,C);\n\t\tswap(B,D);\n\t\tswap(N,M);\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> pii;\n \n#define fst first\n#define snd second\n#define pb push_back\n#define eb emplace_back\n#define REP(i, a, b)  for(int i = (a), i##end = (b); i < i##end; ++i)\n#define DREP(i, a, b) for(int i=(a-1), i##end = (b); i >=i##end; --i)\n \ntemplate <typename T> bool chkmax(T& a, T b) { return a < b ? a = b, 1 : 0; }\ntemplate <typename T> bool chkmin(T& a, T b) { return a > b ? a = b, 1 : 0; }\n \nconst int N = 300000;\nconst int oo = 0x3f3f3f3f;\nconst int mod = 998244353;\n \ntemplate<typename T> T read() {\n    T n(0), f(1);\n    char ch = getchar();\n    for( ;!isdigit(ch); ch = getchar()) if(ch == '-') f = -1;\n    for( ; isdigit(ch); ch = getchar()) n = n * 10 + ch - 48; \n    return n * f;\n}\n\nLL fpm(LL base, LL exp) {\n    LL res = 1;\n    for(; exp > 0; exp >>= 1) {\n        if(exp & 1) \n            res = res * base % mod;\n        base = base * base % mod;\n    }\n    return res;\n}\n\nint cnt[4];\nchar st[N + 5];\nLL fac[N + 5], inv[N + 5];\n\ninline LL C(int n, int k) {\n    return fac[n] * inv[k] % mod * inv[n - k] % mod;\n}\n\nint n, m;\nbool a[N + 5], b[N + 5], c[N + 5], d[N + 5];\n\nLL calc() {\n    LL pre = 1, res = 0;\n    int lu = 0, ld = 0, ru = cnt[2], rd = cnt[3];\n    for(int i = 0; i < m; ++i) {\n        if(c[i]) lu ++, ru --;\n        if(d[i]) ld ++, rd --;\n        if(c[i] && d[i]) { (pre <<= 1LL) %= mod; }\n\n        if(c[i] || d[i]) { \n            res = (res + pre*(cnt[1] ? C(cnt[1]+ru+rd - 1, cnt[1] - 1) : (ru + rd == 0))) % mod;\n            pre = (pre + (cnt[0] ? C(cnt[0]+lu+ld - 1, cnt[0] - 1) : (lu + ld == 0))) % mod;\n        }\n    }\n    return res;\n}\n\nvoid Input() {\n    cin >> n >> m;\n    scanf(\"%s\", st); for(int i = 0; i < n; ++i) cnt[0] += (a[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < n; ++i) cnt[1] += (b[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < m; ++i) cnt[2] += (c[i] = st[i] - '0');\n    scanf(\"%s\", st); for(int i = 0; i < m; ++i) cnt[3] += (d[i] = st[i] - '0');\n    if(!(cnt[0] + cnt[1] + cnt[2] + cnt[3])) puts(\"1\"), exit(0);\n}\n\nvoid Init() {\n    fac[0] = 1;\n    for(int i = 1; i <= N; ++i) fac[i] = fac[i-1] * i % mod;\n    inv[N] = fpm(fac[N], mod - 2);\n    for(int i = N; i >= 1; --i) inv[i-1] = inv[i] * i % mod;\n}\n\nvoid Solve() {\n    LL Ans = calc();\n\n    swap(n, m); swap(b, c);\n    swap(a, d); swap(a, b);\n    swap(cnt[0], cnt[3]);\n    swap(cnt[1], cnt[2]);\n    swap(cnt[0], cnt[1]);\n\n    Ans = (Ans + calc()) % mod;\n    printf(\"%lld\\n\", Ans);\n}\n\nint main() {\n#ifdef Wearry\n    freopen(\"data.txt\", \"r\", stdin);\n    freopen(\"ans.txt\", \"w\", stdout);\n#endif\n\n    Init();\n    Input();\n    Solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int mod = 998244353;\n\nint po(int x, int n) {\n    int ret = 1;\n    while(n) {\n        if(n & 1) ret = 1LL * ret * x % mod;\n        x = 1LL * x * x % mod;\n        n >>= 1;\n    }\n    return ret;\n}\nint inv(int x) { return po(x, mod - 2); }\n\nint fact[400010], invf[400010];\n\nint comb(int n, int k) {\n    return 1LL * fact[n] * invf[k] % mod * invf[n - k] % mod;\n}\nint H(int n, int k) {\n    if(k < 0) return 1;\n    return comb(n + k - 1, k);\n}\n\nint N, M;\nstring A, B, C, D;\n\nvector<int> Col;\nvector<int> Ldp, Rdp, Rpsum, pmul;\n\nint solve() {\n    Col.clear();\n    for(int i = 0; i < M; i++) {\n        if(C[i] == '1' && D[i] == '1') Col.push_back(3);\n        else if(C[i] == '1') Col.push_back(1);\n        else if(D[i] == '1') Col.push_back(2);\n    }\n\n    if(Col.size() == 0) return 0;\n\n    int a = 0;\n    for(int i = 0; i < N; i++) if(A[i] == '1') a++;\n    int x = 0, y = 0;\n    Ldp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = 0; i < Col.size(); i++) {\n            if(x == 0 && y == 0) Ldp[i] = 1;\n            else Ldp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Ldp[0] = 1;\n\n    a = 0;\n    for(int i = 0; i < N; i++) if(B[i] == '1') a++;\n    x = 0, y = 0;\n    Rdp = vector<int>(Col.size(), 0);\n    if(a) {\n        for(int i = (int)Col.size() - 1; i >= 0; i--) {\n            if(x == 0 && y == 0) Rdp[i] = 1;\n            else Rdp[i] = H(x + y + 1, a - 1);\n            if(Col[i] & 1) x++;\n            if(Col[i] & 2) y++;\n        }\n    }\n    else Rdp.back() = 1;\n\n    pmul = vector<int>(Col.size());\n    for(int i = 0; i < Col.size(); i++) {\n        pmul[i] = (Col[i] == 3? 2 : 1);\n        if(i) pmul[i] = 1LL * pmul[i] * pmul[i - 1] % mod;\n    }\n\n    Rpsum = vector<int>(Col.size());\n    for(int i = (int)Col.size() - 1; i >= 0; i--) {\n        Rpsum[i] = 1LL * Rdp[i] * pmul[i] % mod;\n        if(i != (int)Col.size() - 1) {\n            Rpsum[i] += Rpsum[i + 1];\n            Rpsum[i] %= mod;\n        }\n    }\n\n    int ret = 0;\n    for(int i = 0; i < Col.size(); i++) {\n        ret += 1LL * Ldp[i] * (Col[i] == 3? 2 : 1) % mod * (Rdp[i] + 1LL * (i == Col.size() - 1? 0 : Rpsum[i + 1]) * inv(pmul[i]) % mod) % mod;\n        ret %= mod;\n    }\n    return ret;\n}\n\nint main() {\n    fact[0] = 1;\n    for(int i = 1; i < 400010; i++) {\n        fact[i] = 1LL * fact[i - 1] * i % mod;\n    }\n    for(int i = 0; i < 400010; i++) {\n        invf[i] = inv(fact[i]);\n    }\n\n    cin >> N >> M >> A >> B >> C >> D;\n\n    int ans = 0;\n    ans += solve();\n    ans %= mod;\n    swap(N, M);\n    swap(A, C);\n    swap(B, D);\n    ans += solve();\n    ans %= mod;\n\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\n#define mo 998244353\n#define ll long long\nll inv[MAXN<<2],fac[MAXN<<2],n,m,ans;\nchar U[MAXN],D[MAXN],L[MAXN],R[MAXN];\ninline ll Cn(ll k,ll b){return (ll)fac[k]*inv[b]%mo*inv[k-b]%mo;}\ninline void solve(int n,int m,char *L,char *R,char *U,char *D)\n{\n\tll tmp=0;\n\tll cl,cr,cu,cd,nowu,nowd,u,d;\n\tcl=cr=cu=cd=nowu=nowd=u=d=0;\n\tfor(int i=1;i<=n;i++) cl+=L[i]-'0',cr+=R[i]-'0';\n\tfor(int i=1;i<=m;i++) cd+=D[i]-'0',cu+=U[i]-'0';\n\tif(cl+cd+cr+cu==0){cout<<\"1\";exit(0);}\n\ttmp=1;\n\tfor(int i=1;i<=m;i++){\n\t\tnowu+=(u=U[i]-'0');nowd+=(d=D[i]-'0');\n\t\tif(u||d){\n\t\t\tif(u&&d) tmp=tmp*2%mo;\n\t\t\tif(cr!=0) ans=(ans+tmp*Cn(cr+cu+cd-nowu-nowd-1,cr-1))%mo;\n\t\t\telse ans+=(cu+cd-nowu-nowd==0)%mo;\n\t\t\tif(cl!=0) tmp=(tmp+Cn(cl+nowu+nowd-1,cl-1))%mo;\n\t\t\telse tmp+=(nowu+nowd==0);\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfac[0]=1;inv[1]=inv[0]=1;\n\tfor(int i=1;i<=4*MAXN-1;i++) fac[i]=fac[i-1]*i%mo;\n\tfor(int i=2;i<=4*MAXN-1;i++) inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=4*MAXN-1;i++) inv[i]=(ll)inv[i]*inv[i-1]%mo;\n\tscanf(\"%s%s%s%s\",L+1,R+1,U+1,D+1);\n\tsolve(n,m,L,R,U,D);solve(m,n,U,D,L,R);\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n, m, p = 998244353;\nchar a[100020];\nchar b[100020];\nchar c[100020];\nchar d[100020];\nlong long v[200020];\nlong long u[200020];\nlong long ans;\nint a1, b1, c1, d1;\nint f[100020];\nint g[100020];\nlong long C(int n, int m) {\n\tif (n == -1 && m == -1) {\n\t\treturn 1;\n\t}\n\tif (m < 0) {\n\t\treturn 0;\n\t}\n\treturn u[n] * v[m] % p * v[n - m] % p;\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s%s%s%s\", a, b, c, d);\n\tv[1] = 1;\n\tfor (int i = 2; i <= 200010; i++) {\n\t\tv[i] = v[p % i] * (p - p / i) % p;\n\t}\n\tv[0] = u[0] = u[1] = 1;\n\tfor (int i = 2; i <= 200010; i++) {\n\t\tv[i] = v[i] * v[i - 1] % p;\n\t\tu[i] = u[i - 1] * i % p;\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (i == 0) {\n\t\t\tf[i] = 0;\n\t\t} else {\n\t\t\tf[i] = f[i - 1];\n\t\t}\n\t\tif (c[i] == '1' || d[i] == '1') {\n//\t\t\tcerr << \"?\" << C(c1 + d1 + a1 - 1, a1 - 1) << ' ' << a1 << ' ' << b1 << ' ' << c1 << ' ' << d1 << endl;\n\t\t\tf[i] = (f[i] + C(c1 + d1 + a1 - 1, a1 - 1)) % p;\n\t\t\tif (c[i] == '1' && d[i] == '1') {\n\t\t\t\tf[i] = f[i] * 2 % p;\n\t\t\t}\n\t\t}\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\tc1 = d1 = 0;\n\tfor (int i = m - 1; i >= 0; i--) {\n\t\tif (c[i] == '1' || d[i] == '1') {\n\t\t\tans = (ans + f[i] * C(c1 + d1 + b1 - 1, b1 - 1)) % p;\n\t\t}\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\n\n\n\n\tc1 = d1 = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (c[i] == '1') {\n\t\t\tc1++;\n\t\t}\n\t\tif (d[i] == '1') {\n\t\t\td1++;\n\t\t}\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0) {\n\t\t\tf[i] = 0;\n\t\t} else {\n\t\t\tf[i] = f[i - 1];\n\t\t}\n\t\tif (a[i] == '1' || b[i] == '1') {\n//\t\t\tcerr << \"?\" << C(a1 + b1 + c1 - 1, c1 - 1) << ' ' << a1 << ' ' << b1 << ' ' << c1 << ' ' << d1 << endl;\n\t\t\tf[i] = (f[i] + C(a1 + b1 + c1 - 1, c1 - 1)) % p;\n\t\t\tif (a[i] == '1' && b[i] == '1') {\n\t\t\t\tf[i] = f[i] * 2 % p;\n\t\t\t}\n\t\t}\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\ta1 = b1 = 0;\n\tfor (int i = n - 1; i >= 0; i--) {\n\t\tif (a[i] == '1' || b[i] == '1') {\n\t\t\tans = (ans + f[i] * C(a1 + b1 + d1 - 1, d1 - 1)) % p;\n\t\t}\n\t\tif (a[i] == '1') {\n\t\t\ta1++;\n\t\t}\n\t\tif (b[i] == '1') {\n\t\t\tb1++;\n\t\t}\n\t}\n\n\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int Mod = 998244353, fft_g = 3;\nconst int inv2 = (Mod + 1) >> 1;\n\nconst int maxn = 262144;\n\ninline int fpm(LL b, int e, const int &m)\n{\n\tLL t = 1;\n\tfor ( ; e; (b *= b) %= m, e >>= 1)\n\t\tif (e & 1) (t *= b) %= m;\n\treturn t;\n}\n\nint N;\nint w[maxn + 5];\nint bitrev[maxn + 5];\n\ninline void fft(int *a, const int &n)\n{\n\tREP(i, 0, n) if (i < bitrev[i]) swap(a[i], a[bitrev[i]]);\n\tfor (int i = 2, lyc = n >> 1; i <= n; i <<= 1, lyc >>= 1)\n\t{\n\t\tfor (int j = 0; j < n; j += i)\n\t\t{\n\t\t\tint *l = a + j, *r = a + j + (i >> 1), *p = w;\n\t\t\tREP(k, 0, i >> 1)\n\t\t\t{\n\t\t\t\tint tmp = (LL)*r * *p % Mod;\n\t\t\t\t(*r = *l - tmp) %= Mod;\n\t\t\t\t(*l += tmp) %= Mod;\n\t\t\t\t++l, ++r;\n\t\t\t\tp += lyc;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid fft_prepare(int num)\n{\n\tint L = 0;\n\tfor ( ; (1 << L) < num; ++L);\n\tN = 1 << L;\n\tREP(i, 0, N) bitrev[i] = bitrev[i >> 1] >> 1 | ((i & 1) << (L - 1));\n\tint step = fpm(fft_g, (Mod - 1) / N, Mod);\n\tw[0] = 1;\n\tREP(i, 0, N) w[i + 1] = (LL)w[i] * step % Mod;\n}\n\nconst int max0 = 500100;\n\nint fac[max0 + 5], ifac[max0 + 5];\n\ninline void prepare()\n{\n\tfac[0] = 1;\n\tREP(i, 0, max0) fac[i + 1] = (LL)fac[i] * (i + 1) % Mod;\n\tifac[max0] = fpm(fac[max0], Mod - 2, Mod);\n\tfor (int i = max0 - 1; i >= 0; --i) ifac[i] = (LL)ifac[i + 1] * (i + 1) % Mod;\n}\n\nint ans = 0;\n\ninline void work(int n, int m, char *a, char *b, char *c, char *d)\n{\n\tint tot = 1;\n\tREP(i, 0, n) if (a[i] == '1' && b[i] == '1') (tot <<= 1) %= Mod;\n\tint cnt = 0;\n\tREP(j, 0, m) cnt += c[j] == '1';\n\tint pre = 1;\n\tint prea = 0;\n\tint preb = 0;\n\tstatic int tmp0[maxn + 5], tmp1[maxn + 5];\n\tmemset(tmp0, 0, sizeof tmp0);\n\tREP(i, 0, n) if (a[i] == '1' || b[i] == '1')\n\t{\n\t\t//x   (prea + x - 1, prea - 1) * (preb + cnt - x - 1, preb)\n\t\t//(prea + preb + cnt - 1, prea + preb)\n\t\tint tmp = 0;\n\t\tif (!(prea + preb)) tmp = 1;\n\t\telse if (!cnt) tmp = 0;\n\t\telse tmp = (LL)fac[prea + preb + cnt - 1] * ifac[prea + preb] % Mod * ifac[cnt - 1] % Mod;\n\t\ttmp = (LL)tmp * pre % Mod;\n\t\t(tmp0[i] += tmp) %= Mod;\n\t\tif (a[i] == '1' && b[i] == '1') pre = (LL)pre * inv2 % Mod;\n\t\tprea += a[i] == '1';\n\t\tpreb += b[i] == '1';\n\t}\n\tmemset(tmp1, 0, sizeof tmp1);\n\tcnt = 0;\n\tREP(j, 0, m) cnt += d[j] == '1';\n\tpre = 1;\n\tprea = preb = 0;\n\tfor (int i = n - 1; i >= 0; --i) if (a[i] == '1' || b[i] == '1')\n\t{\n\t\tint tmp = 0;\n\t\tif (!(prea + preb)) tmp = 1;\n\t\telse if (!cnt) tmp = 0;\n\t\telse tmp = (LL)fac[prea + preb + cnt - 1] * ifac[prea + preb] % Mod * ifac[cnt - 1] % Mod;\n\t\ttmp = (LL)tmp * pre % Mod;\n\t\t(tmp1[n - i - 1] += tmp) %= Mod;\n\t\tif (a[i] == '1' && b[i] == '1') pre = (LL)pre * inv2 % Mod;\n\t\tprea += a[i] == '1';\n\t\tpreb += b[i] == '1';\n\t}\n\tfft_prepare(n << 1);\n\tfft(tmp0, N);\n\tfft(tmp1, N);\n\tREP(i, 0, N) tmp0[i] = (LL)tmp0[i] * tmp1[i] % Mod;\n\tfft(tmp0, N);\n\treverse(tmp0 + 1, tmp0 + N);\n\tint invN = fpm(N, Mod - 2, Mod);\n\tREP(i, 0, n) \n\t{\n\t\ttmp0[i] = (LL)tmp0[i] * invN % Mod * tot % Mod;\n\t\t(ans += tmp0[i]) %= Mod;\n\t}\n}\n\nint n, m;\nchar a[maxn + 5], b[maxn + 5], c[maxn + 5], d[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tprepare();\n\tscanf(\"%d%d\", &n, &m);\n\tscanf(\"%s\", a);\n\tscanf(\"%s\", b);\n\tscanf(\"%s\", c);\n\tscanf(\"%s\", d);\n\twork(n, m, a, b, c, d);\n\twork(m, n, c, d, a, b);\n\t(ans += Mod) %= Mod;\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof a)\n#define mcpy(a,b) memcpy(a,b,sizeof b)\n#define lb(x) ((x)&(-(x)))\n#define xx first\n#define yy second\n#define pb push_back\n#define mp make_pair\n#define pii pair<int,int> \n#define dalao 998244353\n#define inf 0x3f3f3f3f\n#define N 100010\nusing namespace std;\ntypedef long long ll;\nint n,m,K,x,y,fac[N<<2]={1},inv[N<<2],l[N],r[N],ans;\nchar a[N],b[N],c[N],d[N],s[N];\ninline int poww(int a,int b){int r=1;for(;b;b>>=1,a=1ll*a*a%dalao)if(b&1)r=1ll*r*a%dalao;return r;}\ninline int C(int a,int b){return a<b||b<0?0:1ll*fac[a]*inv[b]%dalao*inv[a-b]%dalao;}\ninline void upd(int& a,int b){a=a+b>=dalao?a+b-dalao:a+b;}\nint main(){\n\tscanf(\"%d%d%s%s%s%s\",&n,&m,a+1,b+1,c+1,d+1),K=max(n,m);\n\tfor(int i=1;i<=(K<<2);i++)fac[i]=1ll*fac[i-1]*i%dalao;\n\tinv[K<<2]=poww(fac[K<<2],dalao-2);\n\tfor(int i=(K<<2)-1;~i;i--)inv[i]=1ll*inv[i+1]*(i+1)%dalao;\n\tfor(int i=1;i<=n;i++)ans+=a[i]+b[i]-96;\n\tfor(int i=1;i<=m;i++)ans+=c[i]+d[i]-96;\n\tif(!ans)return puts(\"1\"),0;\n\tans=0;\n//\t---------------------------------------------\n\tK=0;\n\tfor(int i=1;i<=m;i++)if(d[i]-48+c[i]-48>0)s[++K]=d[i]-48+c[i]-48;\n\tfor(int i=1;i<=n;i++)x+=a[i]-48;\n\tfor(int i=1;i<=K;i++){\n\t\tif(x==0&&y==0)l[i]=1;\n\t\telse if(x)l[i]=C(x+y-1,x-1);\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<x<<\" \"<<y<<endl;\n\t\ty+=s[i];\n\t}\n\tx=y=0;\n\tfor(int i=1;i<=n;i++)x+=b[i]-48;\n\tfor(int i=K;i;i--){\n\t\tif(x==0&&y==0)r[i]=1;\n\t\telse if(x)r[i]=C(x+y-1,x-1);\n\t\ty+=s[i];\n\t}\n\tx=0;\n\tfor(int i=1;i<=K;i++){\n\t\tupd(x,l[i]);\n\t\tif(s[i]==2)upd(x,x);\n\t\tupd(ans,1ll*r[i]*x%dalao);\n\t}\n//\t---------------------------------------------\n\tK=x=y=0;\n\tfor(int i=1;i<=n;i++)if(a[i]-48+b[i]-48>0)s[++K]=a[i]-48+b[i]-48;\n\tfor(int i=1;i<=m;i++)x+=c[i]-48;\n\tfor(int i=1;i<=K;i++){\n\t\tif(x==0&&y==0)l[i]=1;\n\t\telse if(x)l[i]=C(x+y-1,x-1);\n\t\telse l[i]=0;\n//\t\tcout<<i<<\" \"<<l[i]<<\" \"<<x<<\" \"<<y<<endl;\n\t\ty+=s[i];\n\t}\n\tx=y=0;\n\tfor(int i=1;i<=m;i++)x+=d[i]-48;\n\tfor(int i=K;i;i--){\n\t\tif(x==0&&y==0)r[i]=1;\n\t\telse if(x)r[i]=C(x+y-1,x-1);\n\t\telse r[i]=0;\n\t\ty+=s[i];\n\t}\n\tx=0;\n\tfor(int i=1;i<=K;i++){\n\t\tupd(x,l[i]);\n\t\tif(s[i]==2)upd(x,x);\n\t\tupd(ans,1ll*r[i]*x%dalao);\n\t}\n//\t---------------------------------------------\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=998244353;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nll fac[500111],ifac[500111];\nll kissme(ll x,ll k){return k==0?1:kissme(x*x%mod,k>>1)*(k&1?x:1)%mod;}\nint n,m;\nchar sa[100111],sb[100111],sc[100111],sd[100111];\nll pre[100111],suf[100111],pre2[100111];\nll C(ll x,ll y){return x<y?0:fac[x]*ifac[y]%mod*ifac[x-y]%mod;}\nll solve()\n{\n//\tcerr<<\"solve:\"<<endl;\n\tint cntc=0;\n\tint cntd=0;\n\tfor(int i=1;i<=m;i++)cntc+=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)cntd+=sd[i]=='1';\n\tint cnta=0,cntb=0;;\n\tpre[0]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntc==0&&cnta==0&&cntb==0)pre[i]=1;\n\t\telse pre[i]=C(cntc+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n\tcnta=cntb=0;\n\tsuf[n+1]=1;\n\tfor(int i=n;i>=1;i--)\n\t{\n\t\tcnta+=sa[i]=='1';\n\t\tcntb+=sb[i]=='1';\n\t\tif(cntd==0&&cnta==0&&cntb==0)suf[i]=1;\n\t\telse suf[i]=C(cntd+cnta+cntb-1,cnta+cntb)%mod;\n\t}\n//\tfor(int i=0;i<=n+1;i++)cerr<<pre[i]<<\" \";cerr<<endl;\n//\tfor(int i=0;i<=n+1;i++)cerr<<suf[i]<<\" \";cerr<<endl;\n\t\n\tll ret=0;\n\tmemset(pre2,0,sizeof(pre2));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(sa[i]-'0'+sb[i]-'0'==1)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse if(sa[i]-'0'+sb[i]-'0'==2)\n\t\t{\n\t\t\tpre2[i]=(pre[i-1]+pre2[i-1])*2%mod;\n\t\t\tret+=pre2[i]*suf[i+1]%mod;\n\t\t}\n\t\telse pre2[i]=pre2[i-1];\n//\t\tcerr<<pre2[i]<<\" \";\n\t}\n\treturn ret%mod;\n}\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<=500005;i++)fac[i]=fac[i-1]*i%mod;\n\tifac[500005]=kissme(fac[500005],mod-2);\n\tfor(int i=500004;i>=0;i--)ifac[i]=ifac[i+1]*(i+1)%mod;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",sa+1);\n\tscanf(\"%s\",sb+1);\n\tscanf(\"%s\",sc+1);\n\tscanf(\"%s\",sd+1);\n\tbool ok=0;\n\tfor(int i=1;i<=n;i++)ok|=sa[i]=='1';\n\tfor(int i=1;i<=n;i++)ok|=sb[i]=='1';\n\tfor(int i=1;i<=m;i++)ok|=sc[i]=='1';\n\tfor(int i=1;i<=m;i++)ok|=sd[i]=='1';\n\t\n\tll ans=0;\n\tans+=solve();\n\tswap(sa,sc);\n\tswap(sb,sd);\n\tswap(n,m);\n\tans+=solve();\n\tif(!ok)ans++;\n\tcout<<ans%mod;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst int N=101009,p=998244353,inv2=p+1>>1;\nint A[N],B[N],C[N],D[N];\nint fac[N<<2],inv[N<<2];\nint n,m,ans;char s[N];\n\ninline int qpow(int A,int B){\n\tint res(1);while(B){\n\t\tif(B&1)res=(ll)res*A%p;\n\t\tA=(ll)A*A%p,B>>=1;\n\t}return res;\n}\n\ninline int Com(int nn,int mm){return (ll)fac[nn]*inv[mm]%p*inv[nn-mm]%p;}\nvoid prework(int A){\n\tfac[0]=inv[0]=1;\n\tfor(int i=1;i<=A;++i)fac[i]=(ll)fac[i-1]*i%p;\n\tinv[A]=qpow(fac[A],p-2);\n\tfor(int i=A-1;i;--i)inv[i]=(ll)inv[i+1]*(i+1)%p;\n}\n\nvoid work(){\n\tint left=0,right=0,l=0,r=0,pre=1,val;\n\tfor(int i=1;i<=n;++i)left+=A[i],right+=B[i];\n\tfor(int i=m;i;--i)r+=C[i]+D[i];\n\tfor(int i=1;i<=m;i++){\n\t\tl+=C[i]+D[i];\n\t\tr-=C[i]+D[i];\n\t\tif(!C[i] and !D[i])continue;\n\t\tif(C[i] and D[i])pre=2ll*pre%p;\n\t\tif(right)val=Com(right+r-1,r);\n\t\telse val=(!r);\t\tans=(ans+(ll)pre*val)%p;\n\t\tif(left)val=Com(left+l-1,l);\n\t\telse val=(!l);\t\tpre=(pre+val)%p;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tprework(n+m+n+m);\n\tbool alive=false;\n\tscanf(\"%s\",s+1);for(int i=1;i<=n;++i)alive|=(A[i]=s[i]-'0');\n\tscanf(\"%s\",s+1);for(int i=1;i<=n;++i)alive|=(B[i]=s[i]-'0');\n\tscanf(\"%s\",s+1);for(int i=1;i<=n;++i)alive|=(C[i]=s[i]-'0');\n\tscanf(\"%s\",s+1);for(int i=1;i<=n;++i)alive|=(D[i]=s[i]-'0');\n\tif(!alive){puts(\"1\");return 0;}\n\twork();\n\tswap(n,m);swap(A,C);\n\tswap(B,D);swap(C,D);\n\twork();\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN=1e5+7;\n#define mo 998244353\n#define ll long long\nll inv[MAXN<<2],fac[MAXN<<2],n,x[MAXN],y[MAXN],z,ans,m;\nchar U[MAXN],D[MAXN],L[MAXN],R[MAXN];\ninline ll Cn(ll k,ll b)\n{\nreturn (ll)fac[k]*inv[b]%mo*inv[k-b]%mo;\n}\ninline void solve(int n,int m,char *L,char *R,char *U,char *D)\n{\n\tll tmp=0;\n\tint cl,cr,cu,cd,nowu,nowd,u,d;\n\tcl=cr=cu=cd=nowu=nowd=u=d=0;\n\tfor(int i=1;i<=n;i++) cl+=L[i]-'0',cr+=R[i]-'0';\n\tfor(int i=1;i<=m;i++) cd+=D[i]-'0',cu+=U[i]-'0';\n\tif(cl+cd==0){cout<<\"1\";exit(0);}\n\ttmp=1;\n//\tcout<<cl<<\" \"<<cr<<\" \"<<cd<<\" \"<<cu<<\" \"<<tmp<<endl;\n\tfor(int i=1;i<=m;i++){\n\t\tnowu+=(u=U[i]-'0');nowd+=(d=D[i]-'0');\n\t\tif(u||d){\n\t\t\tif(u&&d) tmp=tmp*2%mo;\n\t\t\tif(cr!=0) ans=(ans+tmp*Cn(cr+cu+cd-nowu-nowd-1,cr-1))%mo;\n\t\t\telse ans+=(cu+cd-nowu-nowd==0)%mo;\n\t\t\tif(cl!=0) tmp=(tmp+Cn(cl+nowu+nowd-1,cl-1))%mo;\n\t\t\telse tmp+=(nowu+nowd==0);\n//\t\t\tcout<<ans<<\" \"<<tmp<<endl;\n\t\t}\n\t}\n}\nint main()\n{\n\tcin>>n>>m;\n\tfac[0]=1;inv[1]=inv[0]=1;\n\tfor(int i=1;i<=2*MAXN;i++) fac[i]=fac[i-1]*i%mo;\n\tfor(int i=2;i<=2*MAXN;i++) inv[i]=(mo-mo/i)*inv[mo%i]%mo;\n\tfor(int i=2;i<=2*MAXN;i++) inv[i]=(ll)inv[i]*inv[i-1]%mo;\n//\tfor(int i=1;i<=n+m<<1;i++) cout<<inv[i]<<endl;\n\tscanf(\"%s%s%s%s\",L+1,R+1,U+1,D+1);\n\tsolve(n,m,L,R,U,D);\n\tsolve(m,n,U,D,L,R);\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include  <stdio.h>\n#include   <math.h>\n#include   <time.h>\n#include   <vector>\n#include   <bitset>\n#include    <queue>\n#include      <set>\n#include      <map>\nusing namespace std;\n\ntypedef long long LL;\nconst int N=500005,Mod=998244353;\n\nint n,m,fac[N],ifac[N],Nummm;\nchar A[N],B[N],C[N],D[N];\n\nint Pow(int a,int b)\n{\n\tint s=1;\n\twhile(b)\n\t{\n\t\tif(b&1)\n\t\t\ts=s*(LL)a%Mod;\n\t\ta=a*(LL)a%Mod;b>>=1;\n\t}\n\treturn s;\n}\n\nint calc(int a,int b)\n{\n\tif(a<b)\n\t\treturn 0;\n\treturn fac[a]*(LL)ifac[b]%Mod*ifac[a-b]%Mod;\n}\n\nint Nums[N],Sums[N];\n\nint solve(int n,int m,char A[],char B[],char C[],char D[])\n{\n\tint NumC=0,NumD=0;\n\tfor(int i=0;i<m;i++)\n\t\tNumC+=C[i]=='1',NumD+=D[i]=='1';\n\tNummm+=NumC+NumD;\n\tint a=0,b=0,sa=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(i==0)\n\t\t\tNums[i]=0;\n\t\telse\n\t\t{\n\t\t\tNums[i]=Nums[i-1];\n\t\t\tif(A[i-1]=='1'&&B[i-1]=='1')\n\t\t\t\tNums[i]=Nums[i]*2%Mod;\n\t\t\tif(A[i-1]=='1')\n\t\t\t\tNums[i]=(Nums[i]+Sums[i-1])%Mod;\n\t\t\tif(B[i-1]=='1')\n\t\t\t\tNums[i]=(Nums[i]+Sums[i-1])%Mod;\n\t\t\ta+=A[i-1]=='1',b+=B[i-1]=='1',sa=sa*((A[i-1]=='1')+(B[i-1]=='1'))%Mod;\n\t\t}\n\t\tSums[i]=(NumC?calc(a+b+NumC-1,a+b):sa);\n\t}\n\ta=0,b=0;sa=1;\n\tint Ans=0;\n\tfor(int i=n-1;i>=0;i--)\n\t{\n\t\tif(i!=n-1)\n\t\t\ta+=A[i+1]=='1',b+=B[i+1]=='1',sa=sa*((A[i+1]=='1')+(B[i+1]=='1'))%Mod;\n\t\tif(A[i]=='1')\n\t\t{\n\t\t\tAns=(Ans+(LL)(Nums[i]+Sums[i])*(NumD?calc(a+b+NumD-1,a+b):sa))%Mod;\n\t\t}\n\t\tif(B[i]=='1')\n\t\t{\n\t\t\tAns=(Ans+(LL)(Nums[i]+Sums[i])*(NumD?calc(a+b+NumD-1,a+b):sa))%Mod;\n\t\t}\n\t//\tcout<<i<<\" \"<<Nums[i]<<\" \"<<Sums[i]<<\" \"<<calc(a+b+NumD-1,a+b)<<endl;\n\t}\n\treturn Ans;\n}\n\nint main()\n{\n\tfac[0]=1;\n\tfor(int i=1;i<N;i++)\n\t\tfac[i]=fac[i-1]*(LL)i%Mod;\n\tifac[N-1]=Pow(fac[N-1],Mod-2);\n\tfor(int j=N-1;j;j--)\n\t\tifac[j-1]=ifac[j]*(LL)j%Mod;\n\tscanf(\"%d%d%s%s%s%s\",&n,&m,A,B,C,D);\n\tint Ans=(solve(n,m,A,B,C,D)+solve(m,n,C,D,A,B))%Mod;\n\tif(!Nummm)\n\t\tAns=1;\n\tcout<<Ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n#define int long long\nconst int N=1e5+10,M=3e5+10,p=998244353,inv2=(p+1)>>1;\nint n,m,v[N];\nchar l[N],r[N],u[N],d[N];\nint fac[M],inv[M];\ninline int C(int x,int y){\n\treturn fac[x]*inv[x-y]%p*inv[y]%p;\n}\ninline int solve(int n,int m,char *l,char *r,char *u,char *d){\n\tmemset(v,0,sizeof v);\n\tint ln=count(l+1,l+n+1,'1');\n\tint rn=count(r+1,r+n+1,'1');\n\tint un=0,dn=0,qu1=1,qu2=1;\n\tfor (int i=1;i<=m;++i){\n\t\tif (u[i]=='0'&&d[i]=='0') {v[i]=v[i-1];continue;}\n\t\tif (ln==0) v[i]=(un==0&&dn==0); else v[i]=C(ln+un+dn-1,ln-1);\n\t\tv[i]=(v[i]*qu1+v[i-1])%p;\n\t\tif (u[i]=='1'&&d[i]=='1') qu1=qu1*inv2%p,qu2=qu2*2%p;\n\t\tun+=u[i]=='1';\n\t\tdn+=d[i]=='1';\n\t}\n\tif (ln+rn+un+dn==0) {puts(\"1\");exit(0);}\n\tint ans=0;\n\tun=dn=0;\n\tfor (int i=m;i;--i){\n\t\tif (u[i]=='0'&&d[i]=='0') continue;\n\t\tif (rn==0) ans=(ans+(un==0&&dn==0)*v[i]*qu2)%p; else ans=(ans+C(rn+un+dn-1,rn-1)*v[i]%p*qu2)%p;\n\t\tif (u[i]=='1'&&d[i]=='1') qu2=qu2*inv2%p;\n\t\tun+=u[i]=='1';\n\t\tdn+=d[i]=='1';\n\t}\n\treturn ans;\n}\nmain(){\n\tfac[0]=1;for (int i=1;i<M;++i) fac[i]=fac[i-1]*i%p;\n\tinv[0]=inv[1]=1;for (int i=2;i<M;++i) inv[i]=inv[p%i]*(p-p/i)%p;\n\tfor (int i=2;i<M;++i) inv[i]=inv[i]*inv[i-1]%p;\n\tscanf(\"%lld%lld%s%s%s%s\",&n,&m,l+1,r+1,u+1,d+1);\n\tprintf(\"%lld\",((solve(n,m,l,r,u,d)+solve(m,n,u,d,l,r))%p+p)%p);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * Sergey Kopeliovich (burunduk30@gmail.com)\n */\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define forn(i, n) for (int i = 0; i < (int)(n); i++)\n\ntypedef long long ll;\n\n// const int N = 1e3 + 3;\nconst int MOD = 998244353;\ninline void add( int &a, int b ) { if ((a += b) >= MOD) a -= MOD; }\ninline void sub( int &a, int b ) { if ((a -= b) < 0) a += MOD; }\ninline int mul( int a, int b ) { return (ll)a * b % MOD; }\n// int Pow( int x, ll n ) {\n// \tif (n == 1)\treturn x;\n// \tint y = Pow(x, n / 2);\n// \treturn (n & 1) ? mul(mul(y, y), x) : mul(y, y);\n// }\n\nconst int N = 2e5 + 3;\nint inv[N];\n\n// int Inv( int a ) { return Pow(a, MOD - 2); }\nint Div( int a, int b ) { return mul(a, inv[b]); }\n\n// int C[N][N];\n\n// int C( int n, int k ) {\n// \tint r = 1;\n// \tforn(i, k) {\n// \t\tr = mul(r, n - i);\n// \t\tr = Div(r, i + 1);\n// \t}\n// \treturn r;\n// }\n\nstruct C {\n\tint n, k, r;\n\tC() {}\n\tC( int n, int k, int r = 1 ) : n(n), k(k), r(r) { }\n\tvoid dn() {\n\t\tr = mul(r, ++n);\n\t\tr = Div(r, n - k);\n\t}\n\tvoid dk() {\n\t\tr = mul(r, n - k++);\n\t\tr = Div(r, k);\n\t}\n};\n\nint main() {\n\tinv[1] = 1;\n\tfor (int i = 2; i < N; i++) \n\t\tinv[i] = ((ll)(MOD - inv[MOD % i]) * (MOD / i)) % MOD;\n\t// C[0][0] = 1;\n\t// forn(i, N - 1)\n\t// \tforn(j, N - 1)\n\t// \t\tadd(C[i + 1][j], C[i][j]), add(C[i + 1][j + 1], C[i][j]);\n\n\tios_base::sync_with_stdio(false), cin.tie(0);\n\tint t1, t2;\n\tcin >> t1 >> t2;\n\tstring sa, sb, sc, sd;\n\tcin >> sa >> sb >> sc >> sd;\n\tauto ok = [&]( char c ) {\n\t\treturn c == '1';\n\t};\n\tauto get = [&]( string &s ) {\n\t\treturn count_if(s.begin(), s.end(), ok);\n\t};\n\n\t// const int M = 15;\n\t// int C[M+1][M+1];\n\t// memset(C, 0, sizeof(C));\n\t// C[0][0] = 1;\n\t// forn(i, M) {\n\t// \tforn(j, M)\t{\n\t// \t\tC[i+1][j+1] += C[i][j], C[i+1][j] += C[i][j];\n\t// \t\tprintf(\"%d \", C[i][j]);\n\t// \t}\n\t// \tputs(\"\");\n\t// }\n\n\tint res = 0;\n\tforn(_, 2) {\n\t\tint n = sa.size(), m = sc.size();\n\t\tint na = get(sa), nb = get(sb);\n\t\tbool was = 0;\n\t\tvector<int> F1(n), F2(n);\n\t\tforn(__, 2) {\n\t\t\tint cnt_a = 0, cnt_b = 0;\n\t\t\tint nc = get(sc);//, cc = 1;//, CC = 1;\n\t\t\tC c1(cnt_b + nc - 1, nc - 1);\n\t\t\tC c2(cnt_a + cnt_b + nc - 1, nc - 1);\n\t\t\tforn(i, n) {\n\t\t\t\tif (ok(sa[i]) || ok(sb[i])) {\n\t\t\t\t\tint f1 = 0;\n\t\t\t\t\tif (cnt_a + cnt_b == 0) {\n\t\t\t\t\t\tf1 = 1;\n\t\t\t\t\t} else if (cnt_a == 0) {\n\t\t\t\t\t\tf1 = c1.r;//C[cnt_b + nc - 1][nc - 1];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf1 = c2.r;//C(cnt_a + cnt_b + nc - 1, nc - 1);\n\t\t\t\t\t\t// int A = cnt_a - 1, B = cnt_b, c = nc - 1;\n\t\t\t\t\t\t// int tmp = cc;//CC;//C[cnt_b + nc - 1][cnt_b];\n\t\t\t\t\t\t// forn(x, nc) {\n\t\t\t\t\t\t// \tadd(f1, tmp);\n\t\t\t\t\t\t// \ttmp = mul(tmp, A + x + 1);\n\t\t\t\t\t\t// \ttmp = Div(tmp, x + 1);\n\t\t\t\t\t\t// \ttmp = Div(tmp, B + c - x);\n\t\t\t\t\t\t// \ttmp = mul(tmp, c - x);\n\t\t\t\t\t\t// \t// add(f1, mul(C[A + x][A], C[B + (c - x)][B]));\n\t\t\t\t\t\t// }\n\t\t\t\t\t\t// printf(\"%d %d\\n\", f1, C(A + B + c + 1, c));\n\t\t\t\t\t}\n\t\t\t\t\tF1[i] = f1;\n\t\t\t\t\tcnt_a += ok(sa[i]), cnt_b += ok(sb[i]);\n\t\t\t\t\tif (ok(sa[i])) {\n\t\t\t\t\t\tc2.dn();\n\t\t\t\t\t}\n\t\t\t\t\tif (ok(sb[i])) {\n\t\t\t\t\t\tc1.dn();\n\t\t\t\t\t\tc2.dn();\n\t\t\t\t\t\t// cc = mul(cc, cnt_b + nc - 1);\n\t\t\t\t\t\t// cc = Div(cc, cnt_b);\n\t\t\t\t\t\t// CC = mul(CC, cnt_b + nc - )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(sc, sd), swap(F1, F2);\n\t\t\treverse(sa.begin(), sa.end());\n\t\t\treverse(sb.begin(), sb.end());\n\t\t}\n\t\treverse(F2.begin(), F2.end());\n\t\tint last = -1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tadd(F2[i], F2[i + 1]);\n\t\t\tif (ok(sa[i + 1]) + ok(sb[i + 1]) == 2)\n\t\t\t\tadd(F2[i], F2[i + 1]);\n\t\t}\n\t\tforn(i, n)\n\t\t\tif (ok(sa[i]) || ok(sb[i]))\n\t\t\t\tadd(res, mul(mul(F1[i], F2[i]), ok(sa[i]) + ok(sb[i])));\n\t\tswap(sa, sc), swap(sb, sd);\n\t}\n\tprintf(\"%d\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n ***\n Question Name:\n ***\n Question Link:\n ***\n Idea:\n */\n\n#include <memory.h>\n#include <ctime>\n#include <random>\n#include <iomanip>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <numeric>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n\n#define REP(i,s,n) for(int (i)=s; (i)<(int)(n);(i)++)\n#define RIT(it,c) for(__typeof(c.begin()) it = c.begin();it!=c.end();it++)\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (int)(x).size()\n#define MSET(m,v) memset(m,v,sizeof(m))\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair<int,int> ii;\ntypedef vector<long> vl;\ntypedef vector<bool> vb;\ntypedef unordered_set<int> ui;\ntypedef pair<long, long> ll;\n\nconst long MOD = 998244353;\n\nclass ModernPainting{\n    long X1, X2, M, nTwo;\n    string top,bot;\n    vl posi, nega, invs;\n    inline long mPlus(long x,long y){ return (x+y)%MOD; }\n    void refMPlus(long &x, long y){\n        x += y;\n        if(x >= MOD) x -= MOD;\n    }\n    inline double mTimes(long x,long y){ return (x*y)%MOD; }\n    void refMTimes(long &x,long y){\n        x *= y;\n        if(x >= MOD) x%=MOD;\n    }\n    long mPower(long n,long k){  // compute n^k (mod MOD)\n        long ans = 1;\n        while(k){\n            if(1&k) refMTimes(ans, n);\n            refMTimes(n, n);\n            k >>= 1;\n        }\n        return ans;\n    }\n    long mInverse(long n){\n        return mPower(n, MOD-2);\n    }\n    void init(){\n        assert(M>0);\n        posi = nega = vl(M+1, 1);\n        invs = vl(2*M+1, 1);\n        nTwo = 0;\n        for(int i=0;i<M;++i) if(top[i]==bot[i]) ++nTwo;\n        for(int i=2;i<=2*M;++i) invs[i] = mInverse(i);\n        if(X1){\n            long Y = 0, Z = 0;\n            for(int i=1;i<=M;++i){\n                long Y1 = Y + (top[i-1]=='1'), Z1 = Z + (bot[i-1]=='1');\n                if(top[i-1]==bot[i-1]){\n                    long fac = mTimes(mTimes(Y1+Z1+X1-1, Y1+Z1+X1-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    posi[i] = mTimes(posi[i-1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X1-1, invs[Y1+Z1]);\n                    posi[i] = mTimes(posi[i-1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        if(X2){\n            long Y = 0, Z = 0;\n            for(long i=M-1;i>=0;--i){\n                long Y1 = Y + (top[i]=='1'), Z1 = Z + (bot[i]=='1');\n                if(top[i]==bot[i]){\n                    long fac = mTimes(mTimes(Y1+Z1+X2-1, Y1+Z1+X2-2), mTimes(invs[Y1+Z1], invs[Y1+Z1-1]));\n                    nega[i] = mTimes(nega[i+1], mTimes(fac, invs[2]));\n                }\n                else{\n                    long fac = mTimes(Y1+Z1+X2-1, invs[Y1+Z1]);\n                    nega[i] = mTimes(nega[i+1], fac);\n                }\n                Y = Y1;\n                Z = Z1;\n            }\n        }\n        for(long i=M-1;i>=0;--i) refMPlus(nega[i], nega[i+1]);\n    }\n    long compCnt(){\n        if(!X2) return (long)1;\n        if(!X1) return nega[0];\n        long ans = 0;\n        for(int i=0;i<M;++i) refMPlus(ans, mTimes(posi[i], nega[i+1]));\n        return ans;\n    }\npublic:\n    long solve(string t, string b,long x1, long x2){\n        X1 = x1;\n        X2 = x2;\n        if(X1>X2) swap(X1, X2);\n        top.clear();\n        bot.clear();\n        for(int i=0;i<(int)b.size();++i) if(b[i]=='1'||t[i]=='1'){\n            top += t[i];\n            bot += b[i];\n        }\n        M = (int)top.size();\n        if(!M) return (long)0;\n        init();\n        return mTimes(mPower(2, nTwo), compCnt());\n    }\n};\n\nint main(){\n    int n,m;\n    string A,B,C,D;\n    cin>>n>>m>>A>>B>>C>>D;\n    long X1 = 0, X2 = 0, ans = 0;\n    for(int i=0;i<m;++i){\n        X1 += (C[i] == '1');\n        X2 += (D[i] == '1');\n    }\n    ans += ModernPainting().solve(A, B, X1, X2);\n    X1 = X2 = 0;\n    for(int i=0;i<n;++i){\n        X1 += (A[i] == '1');\n        X2 += (B[i] == '1');\n    }\n    ans += ModernPainting().solve(C, D, X1, X2);\n    cout<<(ans%MOD)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = (a); i < (b); i++)\n#define rer(i, a, b) for(int i = (a) - 1; i >= (b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<pi, int> ppi;\ntypedef vector<ll> vi;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest) { \n\tcout << arg << \" \"; Debug(rest...); }\ntemplate<class T>ostream& operator<< (ostream& out, const vector<T>& v) {\n\tout << \"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<< \", \";out<<v.back();}out << \"]\";return out;}\ntemplate<class S, class T>ostream& operator<< (ostream& out, const pair<S, T>& v) {\n\tout << \"(\" << v.first << \", \" << v.second << \")\";return out;}\nconst int MAX_N = 600100;\nconst double eps = 1e-6;\nconst ll mod = 998244353;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll fac[MAX_N], inv[MAX_N], fiv[MAX_N]; //fiv:inv(fac(i))\nll pow2[MAX_N];\n\n/*\nll mod_pow(ll a, ll n) {\n\tif(n == 0) return 1;\n\tll res = mod_pow(a, n / 2);\n\tif(n % 2 == 0) return res * res % mod;\n\telse return a * res % mod * res % mod;\n}\n\nll invf(ll a) {\n\treturn mod_pow(a, mod - 2);\n}\n*/\n\nvoid C_init(int n) {\n\tfac[0] = fac[1] = 1; inv[1] = 1;\n\tfiv[0] = fiv[1] = 1;\n\tpow2[0] = 1; pow2[1] = 2;\n\trep(i, 2, n + 1) {\n\t\tfac[i] = fac[i - 1] * i % mod;\n\t\tinv[i] = mod - inv[mod % i] * (mod / i) % mod;\n\t\tfiv[i] = fiv[i - 1] * inv[i] % mod;\n\t\tpow2[i] = pow2[i - 1] * 2 % mod;\n\t}\n}\n\nll getC(int a, int b) { //assume a >= b\n\tif(a < b || a < 0 || b < 0) return 0;\n\treturn fac[a] * fiv[b] % mod * fiv[a - b] % mod;\n}\n\nint N, M;\nstring A, B, C, D;\nll bitcnt[MAX_N];\nll sum[MAX_N];\n\nll solve2(int y, int z, int x) {\n\tif(x == 0) {\n\t\tif(y == 0 && z == 0) return 1;\n\t\telse return 0;\n\t}\n\telse return getC(x + y + z - 1, x - 1);\n}\n\nll solve_sub() {\n\tint ccnt = accumulate(all(C), 0) - '0' * M;\n\tint dcnt = accumulate(all(D), 0) - '0' * M;\n\tint acnt = 0, bcnt = 0;\n\tbitcnt[0] = 0;\n\trep(i, 0, N) bitcnt[i + 1] = bitcnt[i] + ((A[i] == '1' && B[i] == '1') ? 1 : 0);\n\t//debug(vi(bitcnt, bitcnt + N + 1));\n\tsum[N] = 0;\n\trer(i, N, 0) {\n\t\tif(A[i] == '0' && B[i] == '0') sum[i] = sum[i + 1];\n\t\telse {\n\t\t\tsum[i] = sum[i + 1] + solve2(acnt, bcnt, dcnt) * pow2[bitcnt[i + 1]] % mod;\n\t\t\tsum[i] %= mod;\n\t\t}\n\t\tif(A[i] == '1') acnt++;\n\t\tif(B[i] == '1') bcnt++;\n\t}\n\tacnt = 0; bcnt = 0;\n\t//debug(vi(sum, sum + N + 1));\n\tacnt = 0; bcnt = 0;\n\tll res = 0;\n\tll mul = 1;\n\trep(i, 0, N) {\n\t\tif(A[i] == '0' && B[i] == '0') continue;\n\t\tll a = solve2(acnt, bcnt, ccnt);\n\t\tADD(res, a * mul % mod * sum[i] % mod);\n\t\tif(A[i] == '1') acnt++;\n\t\tif(B[i] == '1') bcnt++;\n\t\tif(A[i] == '1' && B[i] == '1') MUL(mul, inv[2]);\n\t}\n\treturn res;\n}\n\n\n\nvoid solve() {\n\tC_init(600010);\n\tcin >> N >> M;\n\tcin >> A >> B >> C >> D;\n\tll ans = 0;\n\tADD(ans, solve_sub());\n\tswap(N, M);\n\tswap(A, C);\n\tswap(B, D);\n\tADD(ans, solve_sub());\n\tcout << ans << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(5);\n#ifdef LOCAL\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\n\nvoid pob(vector<int>& res){\n  string z;\n  cin >> z; \n  R(i,SZ(z)){\n    if(z[i] == '1'){\n      res.PB(1);\n    }else\n      res.PB(0);\n  }\n}\n\nint jed(vector<int>& x){\n  int res = 0;\n  for(int el:x){\n    res += el;\n  }\n  return res;\n}\n\nconst int P = 998244353;\nconst int MAX = 4e5 + 10;\nint sil[MAX],od[MAX];\nint pot(int a,int w){\n  int r = 1;\n  while(w){\n    if(w & 1){\n      r = r * a % P;\n    }\n    a = a * a % P;\n    w/=2;\n  }\n  return r;\n}\nint dwu(int a,int b){\n // debug(a,b, sil[a], od[b], od[a-b]);\n  return sil[a] * od[b] % P * od[a-b] % P;\n}\n\nvector<int> licz2(vector<int>&a,vector<int>& b,int x){\n  //TODO x = 0\n  int n = SZ(a);\n  vector<int> res;\n  int il = 0;\n//   bool cza = 0;\n//   bool czb = 0;\n  bool cz = 0;\n  R(i,n){\n    if(a[i] == 0 && b[i] == 0)\n      res.PB(0);\n    else{\n      if(x == 0){\n        if(!cz){\n          res.PB(1);\n        }else\n          res.PB(0);\n        cz = 1;\n      }else\n        res.PB(dwu(x + il - 1, x-1));\n    }\n//     if(a[i])cza = 1;\n//     if(b[i])czb = 1;\n    il += a[i];\n    il += b[i];\n  }\n  return res;\n}\n\nint licz(vector<int> a,vector<int> b,int x1,int x2){\n  int n = SZ(a);\n  vector<int> res1 = licz2(a,b,x1);\n  reverse(ALL(a));\n  reverse(ALL(b));\n  reverse(ALL(res1));\n  vector<int> res2 = licz2(a,b,x2);\n  debug(a,b,x1,x2,res1,res2);\n  int pom = 0;\n  int res = 0;\n  R(i,n){\n    pom += res2[i];\n    if(a[i] && b[i])pom *= 2;\n    pom %= P;\n    res += pom * res1[i];\n    res %= P;\n  }\n  return res;\n}\nint32_t main() {\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n  sil[0] = 1;\n  R(i,MAX-1){\n    sil[i+1] = sil[i] * (i + 1) % P;\n  }\n  R(i,MAX){\n    od[i] = pot(sil[i], P-2);\n  }\n  \n  \n  int n,m;\n  vector<int> a,b,c,d;\n  cin >> n >> m;\n  pob(a);\n  pob(b);\n  pob(c);\n  pob(d);\n  int res = licz(a,b,jed(c),jed(d));\n  res += licz(c,d,jed(a),jed(b));\n  if(jed(a) == 0 && jed(b) == 0 && jed(c) == 0 && jed(d) == 0){\n    res = 1;\n  }\n  cout << res % P << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#define rep(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int N=300010;\nconst int maxn=300000;\n//const int N=20;\n//const int maxn=10;\nconst int mod=998244353;\nint a[N][2],sa[N][2],b[N][2],sb[N][2];\nint cj[N],inv[N];\nchar s[N];\nint ans;\n\nint power(int x,int y){\n\tint ret=1;\n\tfor(;y;y>>=1,x=1ll*x*x%mod){\n\t\tif(y&1)\tret=1ll*ret*x%mod;\n\t}\n\treturn ret;\n}\n\nint C(int n,int m){\n\treturn 1ll*cj[n]*inv[m]%mod*inv[n-m]%mod;\n}\n\nint calc(int n,int m){\n\tif(n==0&&m==0)\treturn 1;\n\tif(n==0)\treturn 0;\n\tif(m==0)\treturn 1;\n\treturn C(n+m-1,m);\n}\n\nint main(){\n//\tfreopen(\"a.in\",\"r\",stdin);\n//\tfreopen(\"a.out\",\"w\",stdout);\n\tint n,m;int i,j,now;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",s+1);rep(i,1,n)\ta[i][0]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,n)\ta[i][1]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,m)\tb[i][0]=s[i]=='1';\n\tscanf(\"%s\",s+1);rep(i,1,m)\tb[i][1]=s[i]=='1';\n\trep(i,1,n)\trep(j,0,1)\tsa[i][j]=sa[i-1][j]+a[i][j];\n\trep(i,1,m)\trep(j,0,1)\tsb[i][j]=sb[i-1][j]+b[i][j];\n\trep(i,1,n)\t\n\tcj[0]=1;rep(i,1,maxn)\tcj[i]=1ll*cj[i-1]*i%mod;\n\tinv[maxn]=power(cj[maxn],mod-2);inv[0]=1;\n\tfor(i=maxn-1;i;i--)\tinv[i]=1ll*inv[i+1]*(i+1)%mod;\n\tnow=0;\n\trep(i,1,n){\n\t\tif(a[i][0]+a[i][1]==0)\tcontinue;\n\t\tnow=(now+calc(sb[m][0],sa[i-1][0]+sa[i-1][1]))%mod;\n\t\tans=(ans+1ll*now*(a[i][0]+a[i][1])*calc(sb[m][1],sa[n][0]+sa[n][1]-sa[i][0]-sa[i][1]))%mod;\n\t\tnow=1ll*now*(a[i][0]+a[i][1])%mod;\n\t}\n\tnow=0;\n\trep(i,1,m){\n\t\tif(b[i][0]+b[i][1]==0)\tcontinue;\n\t\tnow=(now+calc(sa[n][0],sb[i-1][0]+sb[i-1][1]))%mod;\n\t\tans=(ans+1ll*now*(b[i][0]+b[i][1])*calc(sa[n][1],sb[m][0]+sb[m][1]-sb[i][0]-sb[i][1]))%mod;\n\t\tnow=1ll*now*(b[i][0]+b[i][1])%mod;\n\t}\n\tif(sa[n][0]+sa[n][1]+sb[m][0]+sb[m][1]==0)\tans=1;\n\tprintf(\"%d\",ans);\n}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\n#include<unordered_set>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 3 * 1000 * 100 + 47;\nconst int MOD = 998244353;\n\nLL F[MAX];\nLL FR[MAX];\nLL R[MAX];\nstring a, b, c, d;\nLL P[MAX];\nLL S[MAX];\nLL ans = 0;\n\nLL cc(int n, int k)\n{\n\tif (k > n) return 0;\n\t\n\tLL res = F[n] * FR[n - k] % MOD;\n\tres = res * FR[k] % MOD;\n\treturn res;\n}\n\nvoid solve1(string a, string c, string d, LL P[])\n{\n\tint y = 0;\n\tint z = 0;\n\tint x = 0;\n\tFOR(i, 0, SZ(a)) x += a[i] == '1';\n\n\tFOR(i, 0, SZ(c))\n\t{\n\t\tif (c[i] == '0' && d[i] == '0')\n\t\t{\n\t\t\tif (i) P[i] = P[i - 1];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (c[i] == '1') y++;\n\t\tif (d[i] == '1') z++;\n\n\t\tif (x == 0 && y == 0 && z == 0)\n\t\t{\n\t\t\tP[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tP[i] = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tP[i] = cc(x + y + z - 1, x - 1);\n\t}\n}\n\nvoid solve(string a, string b, string c, string d)\n{\n\tsolve1(a, c, d, P);\n\treverse(ALL(c));\n\treverse(ALL(d));\n\tsolve1(b, c, d, S);\n\n\treverse(ALL(c));\n\treverse(ALL(d));\n\treverse(S, S + SZ(c));\n\n\tS[SZ(c)] = 1;\n\tLL cur = 0;\n\tFOR(i, 0, SZ(c))\n\t{\n\t\tif (c[i] == '0' && d[i] == '0') continue;\n\t\tif (i)\n\t\t{\n\t\t\tcur = (cur + P[i - 1]) % MOD;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcur = (cur + 1) % MOD;\n\t\t}\n\n\t\tif (c[i] == '1' && d[i] == '1') cur = (cur * 2) % MOD;\n\n\t\tans = (ans + cur * S[i + 1]) % MOD;\n\t}\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios::sync_with_stdio(false); cin.tie(0);\n\tF[0] = FR[0] = F[1] = FR[1] = R[1] = 1;\n\n\tFOR(i, 2, MAX)\n\t{\n\t\tF[i] = F[i - 1] * i % MOD;\n\t\tR[i] = (MOD / i) * R[MOD % i] % MOD;\n\t\tR[i] = (MOD - R[i]) % MOD;\n\t\tFR[i] = R[i] * FR[i - 1] % MOD;\n\t}\n\n\tint n, m;\n\tcin >> n >> m >> a >> b >> c >> d;\n\tsolve(a, b, c, d);\n\t//cout << ans << endl;\n\tsolve(c, d, a, b);\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#define llint long long\n#define mod 998244353\n\nusing namespace std;\n\nllint h, w;\nstring l, r, u, d;\nllint udsum[100005];\n\nconst int FACT_MAX = 200005;\nllint fact[FACT_MAX], fact_inv[FACT_MAX];\n\nllint modpow(llint a, llint n)\n{\n\tif(n == 0) return 1;\n\tif(n % 2){\n\t\treturn ((a%mod) * (modpow(a, n-1)%mod)) % mod;\n\t}\n\telse{\n\t\treturn modpow((a*a)%mod, n/2) % mod;\n\t}\n}\n\nvoid make_fact()\n{\n\tllint val = 1;\n\tfact[0] = 1;\n\tfor(int i = 1; i < FACT_MAX; i++){\n\t\tval *= i;\n\t\tval %= mod;\n\t\tfact[i] = val;\n\t}\n\tfact_inv[FACT_MAX-1] = modpow(fact[FACT_MAX-1], mod-2);\n\tfor(int i = FACT_MAX-2; i >= 0; i--){\n\t\tfact_inv[i] = fact_inv[i+1] * (i+1) % mod;\n\t}\n}\n\nllint comb(llint n, llint k)\n{\n\tllint ret = 1;\n\tret *= fact[n];\n\tret *= fact_inv[k], ret %= mod;\n\tret *= fact_inv[n-k], ret %= mod;\n\treturn ret;\n}\n\nllint get(llint h, llint w)\n{\n\tif(h == 0) return 0;\n\th--;\n\treturn comb(h+w, w);\n}\n\nllint calc()\n{\n\tllint lsum = 0, rsum = 0;\n\tfor(int i = 1; i <= h; i++) lsum += l[i]-'0', rsum += r[i]-'0';\n\tif(lsum == 0 && rsum == 0){\n\t\tllint ret = 1;\n\t\tfor(int i = 1; i <= w; i++){\n\t\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\t\tif(cnt) ret *= cnt, ret %= mod;\n\t\t}\n\t\treturn ret;\n\t}\n\tfor(int i = 1; i <= w; i++){\n\t\tudsum[i] = udsum[i-1];\n\t\tudsum[i] += (u[i]-'0') + (d[i]-'0');\n\t}\n\t\n\tllint ret = 0, sum = 0, num = 0, mul = 1;\n\tfor(int i = w; i >= 1; i--){\n\t\tllint cnt = (u[i]-'0') + (d[i]-'0');\n\t\tif(cnt == 0) continue;\n\t\tsum += get(rsum, num), sum %= mod;\n\t\tsum *= cnt, sum %= mod;\n\t\tmul *= cnt, mul %= mod;\n\t\tif(rsum == 0) sum = mul;\n\t\tret += get(lsum, udsum[i-1]) * sum % mod, ret %= mod;\n\t\tnum += cnt;\n\t}\n\tif(lsum == 0) ret = sum;\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> h >> w;\n\tcin >> l >> r >> u >> d;\n\tl = \"#\" + l, r = \"#\" + r, u = \"#\" + u, d = \"#\" + d;\n\t\n\tmake_fact();\n\t\n\tbool aflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') aflag = true;\n\t}\n\tif(!aflag) swap(l, u), swap(r, d), swap(h, w);\n\t\n\tbool bflag = false;\n\tfor(int i = 1; i <= w; i++){\n\t\tif(u[i] == '1' || d[i] == '1') bflag = true;\n\t}\n\tif(!aflag && !bflag){\n\t\tcout << 1 << endl;\n\t\treturn 0;\n\t}\n\t\n\tllint ans = calc();\n\tswap(l, u), swap(r, d), swap(h, w);\n\tif(aflag) ans += calc(), ans %= mod;\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\ntemplate<typename T>\nusing pair2 = pair<T, T>;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\nconst int maxf = 400005;\nconst int MOD = 998244353;\n\nll fact[maxf], invfact[maxf];\nchar a[maxf], b[maxf], c[maxf], d[maxf];\nll anspref[maxf];\nint n, m;\n\nll powmod(ll a, ll b)\n{\n    ll ans = 1;\n    ll tmp = a;\n    while (b)\n    {\n        if (b & 1) ans = (ans * tmp) % MOD;\n        tmp = (tmp * tmp) % MOD;\n        b >>= 1;\n    }\n    return ans;\n}\n\nll getc(ll a, ll b)\n{\n    if (b < 0 || b > a) return 0;\n    return fact[a] * invfact[b] % MOD * invfact[a - b] % MOD;\n}\n\nll f3(int x, int y, int z)\n{\n    if (y == 0)\n    {\n        if (x == 0 && z == 0) return 1;\n        return 0;\n    }\n    ll tot = getc(x + y + z, y);\n    return (tot - getc(x + y + z - 1, y) + MOD) % MOD;\n}\n\nint main()\n{\n    fact[0] = 1;\n    invfact[0] = 1;\n    for (int i = 1; i < maxf; i++)\n    {\n        fact[i] = (fact[i - 1] * i) % MOD;\n        invfact[i] = powmod(fact[i], MOD - 2);\n    }\n    \n    scanf(\"%d%d\", &n, &m);\n    scanf(\"%s\", a);\n    scanf(\"%s\", b);\n    scanf(\"%s\", c);\n    scanf(\"%s\", d);\n    ll answer = 0;\n    for (int IT = 0; IT < 2; IT++)\n    {\n        int y = 0;\n        for (int i = 0; i < n; i++) y += a[i] == '1';\n        int x = 0;\n        int z = 0;\n        for (int i = 0; i < m; i++) if (c[i] == '1' || d[i] == '1')\n        {\n            anspref[i] = f3(x, y, z);\n            if (c[i] == '1' && d[i] == '1') anspref[i] = (anspref[i] * 2) % MOD;\n            \n            x += c[i] == '1';\n            z += d[i] == '1';\n        }\n        \n        y = 0;\n        for (int i = 0; i < n; i++) y += b[i] == '1';\n        x = 0;\n        z = 0;\n        ll curttans = 0;\n        for (int i = m - 1; i >= 0; i--) if (c[i] == '1' || d[i] == '1')\n        {\n            ll curans = f3(x, y, z);\n            answer += anspref[i] * (curttans + curans);\n            answer %= MOD;\n            curttans = (curttans + curans) % MOD;\n            if (c[i] == '1' && d[i] == '1') curttans = (curttans * 2) % MOD;\n            \n            x += c[i] == '1';\n            z += d[i] == '1';\n        }\n        \n        \n        for (int i = 0; i <= max(n, m); i++) swap(a[i], c[i]);\n        for (int i = 0; i <= max(n, m); i++) swap(b[i], d[i]);\n        swap(n, m);\n//         cout << answer << endl;\n    }\n    cout << answer << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// vjudge2氏.\n// https://atcoder.jp/contests/code-festival-2017-quala/submissions/4001102\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 101009, p = 998244353, inv2 = p + 1 >> 1;\nchar A[N], B[N], C[N], D[N];\nint fac[N << 2], inv[N << 2];\nint n, m, ans;\n\ninline int qPow(int A, int B){\n    int res(1);\n    while(B){\n        if(B & 1) res = (ll)res * A % p;\n        A = (ll)A * A % p;\n        B >>= 1;\n    }\n    return res;\n}\n\ninline int Com(int nn, int mm){\n    return (ll)fac[nn] * inv[mm] % p * inv[nn - mm] % p;\n}\nvoid preWork(int A){\n    fac[0] = inv[0] = 1;\n    for(int i = 1; i <= A; ++i) fac[i] = (ll)fac[i - 1] * i % p;\n    inv[A] = qPow(fac[A], p - 2);\n    for(int i = A - 1; i ; --i) inv[i] = (ll)inv[i + 1] * (i + 1) % p;\n}\n\nvoid work(){\n    int left = 0, right = 0,l = 0,r = 0, pre = 1, val;\n    for(int i = 1; i <= n; ++i) left += A[i] - '0', right += B[i] - '0';\n    for(int i = m; i; --i) r += C[i] - '0' + D[i] - '0';\n    for(int i = 1; i <= m; i++){\n        l += C[i] - '0' + D[i] - '0';\n        r -= C[i] - '0' + D[i] - '0';\n        if(C[i] == '0' && D[i] == '0') continue;\n        if(C[i] == '1' && D[i] == '1') pre = 2ll * pre % p;\n        if(right) val = Com(right + r - 1, r);\n        else      val = (!r);\n        ans = (ans + (ll)pre * val ) % p;\n        if(left) val = Com(left + l - 1, l);\n        else     val = (!l);\n        pre = (pre + val) % p;\n    }\n}\n\nint main(){\n    scanf(\"%d %d\", &n, &m);\n    preWork(n + m + n + m);\n    scanf(\"%s %s\", A + 1, B + 1);\n    scanf(\"%s %s\", C + 1, D + 1);\n    bool died = true;\n    for(int i = 1; i <= n; ++i){\n        if(A[i] == '1' || B[i] == '1' || C[i] == '1' || D[i] == '1'){\n            died = false;\n            break;\n        }\n    }\n    if(died){\n        puts(\"1\");\n        return 0;\n    }\n    work();\n    swap(n, m);\n    swap(A, C);\n    swap(B, D);\n    swap(C, D);\n    work();\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\ntypedef long long Int;\n#define MOD 998244353\n\nInt n, m;\nstring str1, str2, str3, str4;\n\nInt fact[1080000];\nInt ll[1080000];\nInt rr[1080000];\nInt res;\nvoid init(){\n\tfact[0] = 1;\n\tfor(Int i = 1;i < 1080000;i++){\n\t\tfact[i] = fact[i-1] * i % MOD;\n\t}\n}\n\nInt pow(Int n, Int p){\n\tif(p == 0)return 1;\n\tInt res = pow(n, p / 2);\n\tres = res * res % MOD;\n\tif(p % 2 == 1)res *= n;\n\treturn res % MOD;\n}\n\nInt inv(Int x){\n\treturn pow(x, MOD - 2);\n}\n\nInt C(Int n, Int k){\n\tif(n < k)return 0;\n\treturn fact[n] * inv(fact[k] * fact[n-k] % MOD) % MOD;\n}\n\nInt solve(int n, int m, string l, string r, string u, string d){\n\tInt res = 0;\n\tint lcnt = 0, rcnt = 0;\n\tfor(int i = 0;i < n;i++){\n\t\tif(l[i] == '1')lcnt++;\n\t\tif(r[i] == '1')rcnt++;\t\t\t\t\t\t\t\t\t\t \n\t}\n\tfill(ll, ll + m + 1, 0);\n\tfill(rr, rr + m + 1, 0);\n\n\tInt cntside = 0;\n\tfor(int i = 0;i <= m;i++){\n\t\tif(i == 0){\n\t\t\tll[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(u[i-1] == '1')cntside++;\n\t\tif(d[i-1] == '1')cntside++;\n\t\tll[i] = (C(cntside + lcnt, lcnt) - C(cntside + lcnt - 1, lcnt)) % MOD;\n\t}\n\tcntside = 0;\n\t\n\tfor(int i = m;i >= 0;i--){\n\t\tif(i == m){\n\t\t\trr[i] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\tif(u[i] == '1')cntside++;\n\t\tif(d[i] == '1')cntside++;\n\t\trr[i] = (C(cntside + rcnt, rcnt) - C(cntside + rcnt - 1, rcnt)) % MOD;\n\t}\n\n\tfor(int i = 0;i < m;i++){\n\t\tres += ll[i] * rr[i+1]; res %= MOD;\n\t\tif((u[i] == '1')  + (d[i] == '1') == 2){\n\t\t\tll[i+1] += ll[i] * 2;\n\t\t}\n\t\tif((u[i] == '1')  + (d[i] == '1') == 1){\n\t\t\tll[i+1] += ll[i];\n\t\t}if((u[i] == '1')  + (d[i] == '1') == 0){\n\t\t\tll[i+1] = ll[i];\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tinit();\n\tcin >> n >> m;\n\tcin >> str1;\n\tcin >> str2;\n\tcin >> str3;\n\tcin >> str4;\n\tres += solve(n, m, str1, str2, str3, str4);\n\tres += solve(m, n, str3, str4, str1, str2);\n\tres %= MOD;\n\tif(res < 0)res += MOD;\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\nconst long long md=998244353;\nconst int maxn=600000;\nchar str1[maxn+100],str2[maxn+100];\nchar str3[maxn+100],str4[maxn+100];\nlong long fac[maxn+100],inv[maxn+100];\nlong long f[maxn+100],g[maxn+100];\nlong long C(int n,int m){\n\tif(n<0&&m==0)\n\t\treturn 1;\n\tif(m<0||m>n) return 0;\n\treturn fac[n]*inv[m]%md*inv[n-m];\n}\nlong long powd(long long x,long long y){\n\tlong long res=1;\n\twhile(y){\n\t\tif(y&1) res=res*x%md;\n\t\tx=x*x%md;\n\t\ty>>=1;\n\t}\n\treturn res;\n}\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tscanf(\"%s\",str1+1),scanf(\"%s\",str2+1);\n\tscanf(\"%s\",str3+1),scanf(\"%s\",str4+1);\n\tbool bo1=1,bo2=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(str1[i]=='1'||str2[i]=='1'){\n\t\t\tbo1=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tif(str3[i]=='1'||str4[i]=='1'){\n\t\t\tbo2=0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(bo1||bo2){\n\t\tlong long ans=1;\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(str1[i]=='1'&&str2[i]=='1')\n\t\t\t\tans=ans*2%md;\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(str3[i]=='1'&&str4[i]=='1')\n\t\t\t\tans=ans*2%md;\n\t\tprintf(\"%lld\\n\",ans);\n\t\treturn 0;\n\t}\n\tfac[0]=1;\n\tfor(int i=1;i<=maxn;i++)\n\t\tfac[i]=fac[i-1]*i%md;\n\tinv[maxn]=powd(fac[maxn],md-2);\n\tfor(int i=maxn;i>=1;i--)\n\t\tinv[i-1]=inv[i]*i%md;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str3[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=n;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=m;i++)\n\t\tif(str4[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=n;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str1[i]-'0')||(str2[i]-'0'))%md;\n\t\tcnt2=cnt2+str1[i]-'0'+str2[i]-'0';\n\t}\n\tlong long ans=0,sum=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str1[i]-'0')&&(str2[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tsum=0;\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str1[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=1;i<=m;i++){\n\t\tf[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tcnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(str2[i]=='1')\n\t\t\tcnt1++;\n\tfor(int i=m;i>=1;i--){\n\t\tg[i]=C(cnt1+cnt2-1,cnt2)*((str3[i]-'0')||(str4[i]-'0'))%md;\n\t\tcnt2=cnt2+str3[i]-'0'+str4[i]-'0';\n\t}\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tsum=(sum+f[i])%md;\n\t\tif((str3[i]-'0')&&(str4[i]-'0'))\n\t\t\tsum=sum*2%md;\n\t\tans=(ans+g[i]*sum)%md;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MOD = 998244353;\n\nconst int MAX = 300300;\n\nLL bpow(LL a, LL b)\n{\n\tLL res = 1;\n\twhile(b)\n\t{\n\t\tif (b & 1) res = (res * a) % MOD;\n\t\ta = (a * a) % MOD;\n\t\tb /= 2;\n\t}\n\treturn res;\n}\n\nLL inv(LL a)\n{\n\treturn bpow(a, MOD - 2);\n}\n\nLL F[MAX];\nLL IF[MAX];\n\nLL C(int n, int k)\n{\n\tLL res = F[n];\n\tres *= IF[k];\n\tres %= MOD;\n\tres *= IF[n-k];\n\tres %= MOD;\n\treturn res;\n}\n\nchar A[4][MAX];\nint n, m;\n\nLL V[2][MAX];\n\nvoid calcVals(int x, char* u, char* d, int m, LL* V)\n{\n\tint y = 0;\n\tint z = 0;\n\tFOR (i, 0, m)\n\t{\n\t\ty += u[i];\n\t\tz += d[i];\n\n\t\tif (x == 0)\n\t\t{\n\t\t\tif (y == 0 && z == 0) V[i] = 1;\n\t\t\telse V[i] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tV[i] = C(x + y + z - 1, x - 1);\n\t\t}\n\t}\n}\n\nLL solve(char* u, char* d, char* l, char* r)\n{\n\tint x = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += l[i];\n\t}\n\n\tcalcVals(x, u, d, m, V[0]);\n\n\tx = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tx += r[i];\n\t}\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\n\tcalcVals(x, u, d, m, V[1]);\n\n\treverse(d, d+m);\n\treverse(u, u+m);\n\treverse(V[1], V[1] + m);\n\n\tLL res = 0;\n\tLL sum = 0;\n\n\tFOR (i, 0, m)\n\t{\n\n\t\tif (i) sum += V[0][i-1];\n\t\telse\n\t\t{\n\t\t\tsum++;\n\t\t}\n\t\tsum = (sum * (u[i] + d[i])) % MOD;\n\t\tLL cur = 0;\n\t\tif (i < m - 1) cur = V[1][i+1];\n\t\telse cur = 1;\n\n\t//\tcout<<i<<\": \"<<sum<<' '<<cur<<endl;\n\n\t\tcur *= sum;\n\n\t\tres = (res + cur) % MOD;\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tF[0] = 1;\n\tIF[0] = 1;\n\tFOR (i, 1, MAX)\n\t{\n\t\tF[i] = (F[i-1] * i) % MOD;\n\t\tIF[i] = inv(F[i]);\n\t}\n\n\tscanf(\"%d%d\", &n, &m);\n\n\tFOR (it, 0, 4)\n\t{\n\t\tscanf(\"%s\", A[it]);\n\t\tint len = strlen(A[it]);\n\t\tFOR (j, 0, len)\n\t\t{\n\t\t\tA[it][j] -= '0';\n\t\t}\n\t}\n\n\tchar* l = A[0];\n\tchar* r = A[1];\n\tchar* u = A[2];\n\tchar* d = A[3];\n\n\tint ind = 0;\n\tFOR (i, 0, m)\n\t{\n\t\tif (u[i] == 0 && d[i] == 0) continue;\n\t\tu[ind] = u[i];\n\t\td[ind] = d[i];\n\t\tind++;\n\t}\n\n\tm = ind;\n\n\tind = 0;\n\tFOR (i, 0, n)\n\t{\n\t\tif (l[i] == 0 && r[i] == 0) continue;\n\t\tl[ind] = l[i];\n\t\tr[ind] = r[i];\n\t\tind++;\n\t}\n\n\tn = ind;\n\n\t//cout<<\"!! \"<<n<<' '<<m<<endl;\n\n\tif (n == 0 || m == 0)\n\t{\n\t\tLL res = 1;\n\t\tFOR (i, 0, m)\n\t\t{\n\t\t\tres = (res * (d[i] + u[i])) % MOD;\n\t\t}\n\t\tFOR (i, 0, n)\n\t\t{\n\t\t\tres = (res * (l[i] + r[i])) % MOD;\n\t\t}\n\n\t\tcout<<res<<endl;\n\t\treturn 0;\n\t}\n\n\tLL res = solve(u, d, l, r);\n\tswap(n, m);\n\tres += solve(l, r, u, d);\n\n\tres %= MOD;\n\tcout<<res<<endl;\n\n\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int mod = 998244353;\n\n    int add(int x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n        return x;\n    }\n\n    int mul(int x, int y) {\n        return (int) (x * 1L * y % mod);\n    }\n\n    int[] fact;\n    int[] factInv;\n\n\n    int solve(int leftCnt, int rightCnt, int middle) {\n        if (middle == 0) {\n            if (leftCnt == 0 && rightCnt == 0) {\n                return 1;\n            }\n            return 0;\n        }\n        return c(leftCnt + rightCnt + middle - 1, middle - 1);\n    }\n\n    int countOnes(String s) {\n        int res = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '1') {\n                res++;\n            }\n        }\n        return res;\n    }\n\n    int solveOneWay(String A, String B, String C, String D) {\n        boolean atleastOne = false;\n        int res = 0;\n        int cntC = countOnes(C), cntD = countOnes(D);\n\n        int[] dp = new int[A.length() + 1];\n        int curA = 0, curB = 0;\n        for (int i = A.length() - 1; i >= 0; i--) {\n            if (A.charAt(i) == '0' && B.charAt(i) == '0') {\n                dp[i] = dp[i + 1];\n                continue;\n            }\n            atleastOne = true;\n            dp[i] = dp[i + 1];\n            int mul = 1;\n            if (A.charAt(i) == '1' && B.charAt(i) == '1') {\n                mul = 2;\n            }\n            dp[i] = add(dp[i], solve(curA, curB, cntD));\n            dp[i] = mul(dp[i], mul);\n            curA += (A.charAt(i) == '1' ? 1 : 0);\n            curB += (B.charAt(i) == '1' ? 1 : 0);\n        }\n\n        curA = 0;\n        curB  = 0;\n        for (int i = 0; i < A.length(); i++) {\n            if (A.charAt(i) == '1' || B.charAt(i) == '1') {\n                int f = solve(curA, curB, cntC);\n                res = add(res, mul(dp[i], f));\n\n\n                if (A.charAt(i) == '1') {\n                    curA++;\n                }\n                if (B.charAt(i) == '1') {\n                    curB++;\n                }\n            }\n        }\n        return atleastOne ? res : -1;\n    }\n\n    int solve(String A, String B, String C, String D) {\n        int r1 = solveOneWay(A, B, C, D);\n        int r2 = solveOneWay(C, D, A, B);\n        if (r1 == -1 && r2 == -1) {\n            return 1;\n        }\n        return add(Math.max(r1, 0), Math.max(r2, 0));\n    }\n\n    final int MAX = (int) 3e5 + 10;\n\n    int[] fact(int n) {\n        int[] res = new int[n];\n        res[0] = 1;\n        for (int i = 1; i < n; i++) {\n            res[i] = mul(res[i - 1], i);\n        }\n        return res;\n    }\n\n    int[] factInv(int[] fact) {\n        int n = fact.length;\n        int[] res = new int[n];\n        res[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n        for (int i = n - 2; i >= 0; i--) {\n            res[i] = mul(res[i + 1], i + 1);\n        }\n        return res;\n    }\n\n    int c(int n, int k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return mul(fact[n], mul(factInv[k], factInv[n - k]));\n    }\n\n    private void solve() {\n        fact = fact(MAX);\n        factInv = factInv(fact);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        String A = in.next();  // len n\n        String B = in.next();\n        String C = in.next();\n        String D = in.next();\n        out.println(solve(A, B, C, D));\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"CodeFestival_QualA_E.in\"));\n            out = new PrintWriter(new File(\"CodeFestival_QualA_E.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int mod = 998244353;\n\n    int add(int x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n        return x;\n    }\n\n    int mul(int x, int y) {\n        return (int) (x * 1L * y % mod);\n    }\n\n    int[] fact;\n    int[] factInv;\n\n\n    int solve(int leftCnt, int rightCnt, int middle) {\n        if (middle == 0) {\n            if (leftCnt == 0 && rightCnt == 0) {\n                return 1;\n            }\n            return 0;\n        }\n        return c(leftCnt + rightCnt + middle - 1, middle - 1);\n    }\n\n    int countOnes(String s) {\n        int res = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '1') {\n                res++;\n            }\n        }\n        return res;\n    }\n\n    int solveOneWay(String A, String B, String C, String D) {\n        boolean atleastOne = false;\n        int res = 0;\n        int cntC = countOnes(C), cntD = countOnes(D);\n\n        int[] dp = new int[A.length() + 1];\n        int curA = 0, curB = 0;\n        for (int i = A.length() - 1; i >= 0; i--) {\n            if (A.charAt(i) == '0' && B.charAt(i) == '0') {\n                dp[i] = dp[i + 1];\n                continue;\n            }\n            atleastOne = true;\n            dp[i] = dp[i + 1];\n            int mul = 1;\n            if (A.charAt(i) == '1' && B.charAt(i) == '1') {\n                mul = 2;\n            }\n            dp[i] = add(dp[i], solve(curA, curB, cntD));\n            dp[i] = mul(dp[i], mul);\n            curA += (A.charAt(i) == '1' ? 1 : 0);\n            curB += (B.charAt(i) == '1' ? 1 : 0);\n        }\n\n        curA = 0;\n        curB  = 0;\n        for (int i = 0; i < A.length(); i++) {\n            if (A.charAt(i) == '1' || B.charAt(i) == '1') {\n                int f = solve(curA, curB, cntC);\n                res = add(res, mul(dp[i], f));\n\n\n                if (A.charAt(i) == '1') {\n                    curA++;\n                }\n                if (B.charAt(i) == '1') {\n                    curB++;\n                }\n            }\n        }\n        return atleastOne ? res : -1;\n    }\n\n    int solve(String A, String B, String C, String D) {\n        int r1 = solveOneWay(A, B, C, D);\n        int r2 = solveOneWay(C, D, A, B);\n        if (r1 == -1 && r2 == -1) {\n            return 0;\n        }\n        return add(Math.max(r1, 0), Math.max(r2, 0));\n    }\n\n    final int MAX = (int) 3e5 + 10;\n\n    int[] fact(int n) {\n        int[] res = new int[n];\n        res[0] = 1;\n        for (int i = 1; i < n; i++) {\n            res[i] = mul(res[i - 1], i);\n        }\n        return res;\n    }\n\n    int[] factInv(int[] fact) {\n        int n = fact.length;\n        int[] res = new int[n];\n        res[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n        for (int i = n - 2; i >= 0; i--) {\n            res[i] = mul(res[i + 1], i + 1);\n        }\n        return res;\n    }\n\n    int c(int n, int k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return mul(fact[n], mul(factInv[k], factInv[n - k]));\n    }\n\n    private void solve() {\n        fact = fact(MAX);\n        factInv = factInv(fact);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        String A = in.next();  // len n\n        String B = in.next();\n        String C = in.next();\n        String D = in.next();\n        out.println(solve(A, B, C, D));\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"CodeFestival_QualA_E.in\"));\n            out = new PrintWriter(new File(\"CodeFestival_QualA_E.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic int mod = 998244353 ;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tchar[] L = ns(n);\n\t\tchar[] R = ns(n);\n\t\tchar[] U = ns(m);\n\t\tchar[] D = ns(m);\n\t\tout.println((count(U, D, L, R) + count(L, R, U, D)) % mod);\n\t}\n\t\n\tstatic long count(char[] U, char[] D, char[] L, char[] R)\n\t{\n\t\tint m = U.length;\n\t\tlong S = 0;\n\t\tlong ans = 0;\n\t\t\n\t\tint[] fu = new int[m+1];\n\t\tfor(int i = 0;i < m;i++)fu[i+1] = fu[i] + U[i] - '0';\n\t\tint[] fd = new int[m+1];\n\t\tfor(int i = 0;i < m;i++)fd[i+1] = fd[i] + D[i] - '0';\n\t\tint fl = 0;\n\t\tfor(char c : L)fl += c-'0';\n\t\tint fr = 0;\n\t\tfor(char c : R)fr += c-'0';\n\t\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint ud = U[i]-'0'+D[i]-'0';\n\t\t\tif(ud == 0)continue;\n\t\t\tS += count(fl, fu[i], fd[i]);\n\t\t\tS = S * ud;\n\t\t\tS %= mod;\n\t\t\tans += S * count(fr, fu[m] - fu[i+1], fd[m] - fd[i+1]);\n\t\t\tans %= mod;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic int[][] fif = enumFIF(500000, mod);\n\t\n\tstatic long count(int l, int u, int d)\n\t{\n\t\tif(l == 0){\n\t\t\treturn u+d > 0 ? 0 : 1;\n\t\t}\n\t\t\n\t\t// C(u+d+(l-1)-1,u+d-1)\n\t\treturn C(u+d+l-1-1+1, u+d-1+1, mod, fif);\n\t\t// C(u+d+2,l-1)\n\t\t\n\t\t// f(1,0)*f(1,0)\n\t\t// f(1,0)*f(1,1)\n\t\t// f(1,0)*f(1,2)\n\t\t// f(1,1)*f(1,0)\n\t\t// f(1,1)*f(1,1)\n\t\t// f(1,2)*f(1,0)\n\t\t\n\t\t// f(i,j) = C(i+1,j)\n\t\t// f(u,0)*f(d,0)\n\t\t// f(u,i)*f(d,j) (i+j<l)\n\t\t// C(u+i-1,u-1)*C(d+j-1,d-1) (i+j<l)\n\t\t// i+j=q, C(u+d+q-1,u+d-1)\n\t\t// C(u+d-1,u+d-1)\n\t\t// C(u+d+(l-1)-1,u+d-1)\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static char[] rev(char[] a)\n\t{\n\t\tfor(int i = 0, j = a.length-1;i < j;i++,j--){\n\t\t\tchar c = a[i]; a[i] = a[j]; a[j] = c;\n\t\t}\n\t\treturn a;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic int mod = 998244353 ;\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni(), m = ni();\n\t\tchar[] L = ns(n);\n\t\tchar[] R = ns(n);\n\t\tchar[] U = ns(m);\n\t\tchar[] D = ns(m);\n\t\tout.println((count(U, D, L, R) + count(L, R, U, D)) % mod);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\n\tstatic long count(char[] U, char[] D, char[] L, char[] R)\n\t{\n\t\tint m = U.length;\n\t\tlong S = 0;\n\t\tlong ans = 0;\n\t\t\n\t\tint[] fu = new int[m+1];\n\t\tfor(int i = 0;i < m;i++)fu[i+1] = fu[i] + U[i] - '0';\n\t\tint[] fd = new int[m+1];\n\t\tfor(int i = 0;i < m;i++)fd[i+1] = fd[i] + D[i] - '0';\n\t\tint fl = 0;\n\t\tfor(char c : L)fl += c-'0';\n\t\tint fr = 0;\n\t\tfor(char c : R)fr += c-'0';\n\t\tif(fu[m] == 0 && fd[m] == 0 && fl == 0 && fr == 0){\n\t\t\treturn invl(2, mod);\n\t\t}\n\t\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint ud = U[i]-'0'+D[i]-'0';\n\t\t\tif(ud == 0)continue;\n\t\t\tS += count(fl, fu[i], fd[i]);\n\t\t\tS = S * ud;\n\t\t\tS %= mod;\n\t\t\tans += S * count(fr, fu[m] - fu[i+1], fd[m] - fd[i+1]);\n\t\t\tans %= mod;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tstatic int[][] fif = enumFIF(500000, mod);\n\t\n\tstatic long count(int l, int u, int d)\n\t{\n\t\tif(l == 0){\n\t\t\treturn u+d > 0 ? 0 : 1;\n\t\t}\n\t\t\n\t\t// C(u+d+(l-1)-1,u+d-1)\n\t\treturn C(u+d+l-1-1+1, u+d-1+1, mod, fif);\n\t\t// C(u+d+2,l-1)\n\t\t\n\t\t// f(1,0)*f(1,0)\n\t\t// f(1,0)*f(1,1)\n\t\t// f(1,0)*f(1,2)\n\t\t// f(1,1)*f(1,0)\n\t\t// f(1,1)*f(1,1)\n\t\t// f(1,2)*f(1,0)\n\t\t\n\t\t// f(i,j) = C(i+1,j)\n\t\t// f(u,0)*f(d,0)\n\t\t// f(u,i)*f(d,j) (i+j<l)\n\t\t// C(u+i-1,u-1)*C(d+j-1,d-1) (i+j<l)\n\t\t// i+j=q, C(u+d+q-1,u+d-1)\n\t\t// C(u+d-1,u+d-1)\n\t\t// C(u+d+(l-1)-1,u+d-1)\n\t}\n\t\n\tpublic static long C(int n, int r, int mod, int[][] fif) {\n\t\tif (n < 0 || r < 0 || r > n)\n\t\t\treturn 0;\n\t\treturn (long) fif[0][n] * fif[1][r] % mod * fif[1][n - r] % mod;\n\t}\n\n\t\n\tpublic static int[][] enumFIF(int n, int mod) {\n\t\tint[] f = new int[n + 1];\n\t\tint[] invf = new int[n + 1];\n\t\tf[0] = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tf[i] = (int) ((long) f[i - 1] * i % mod);\n\t\t}\n\t\tlong a = f[n];\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0) {\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\tinvf[n] = (int) (p < 0 ? p + mod : p);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tinvf[i] = (int) ((long) invf[i + 1] * (i + 1) % mod);\n\t\t}\n\t\treturn new int[][] { f, invf };\n\t}\n\n\t\n\tpublic static char[] rev(char[] a)\n\t{\n\t\tfor(int i = 0, j = a.length-1;i < j;i++,j--){\n\t\t\tchar c = a[i]; a[i] = a[j]; a[j] = c;\n\t\t}\n\t\treturn a;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    final int mod = 998244353;\n\n    int add(int x, int y) {\n        x += y;\n        if (x >= mod) {\n            x -= mod;\n        }\n        return x;\n    }\n\n    int mul(int x, int y) {\n        return (int) (x * 1L * y % mod);\n    }\n\n    int[] fact;\n    int[] factInv;\n\n\n    int solve(int leftCnt, int rightCnt, int middle) {\n        if (middle == 0) {\n            if (leftCnt == 0 && rightCnt == 0) {\n                return 1;\n            }\n            return 0;\n        }\n        return c(leftCnt + rightCnt + middle - 1, middle - 1);\n    }\n\n    int countOnes(String s) {\n        int res = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '1') {\n                res++;\n            }\n        }\n        return res;\n    }\n\n    int solveOneWay(String A, String B, String C, String D) {\n        boolean atleastOne = false;\n        int res = 0;\n        int cntC = countOnes(C), cntD = countOnes(D);\n\n        int[] dp = new int[A.length() + 1];\n        int curA = 0, curB = 0;\n        for (int i = A.length() - 1; i >= 0; i--) {\n            if (A.charAt(i) == '0' && B.charAt(i) == '0') {\n                dp[i] = dp[i + 1];\n                continue;\n            }\n            atleastOne = true;\n            dp[i] = dp[i + 1];\n            int mul = 1;\n            if (A.charAt(i) == '1' && B.charAt(i) == '1') {\n                mul = 2;\n            }\n            dp[i] = add(dp[i], solve(curA, curB, cntD));\n            dp[i] = mul(dp[i], mul);\n            curA += (A.charAt(i) == '1' ? 1 : 0);\n            curB += (B.charAt(i) == '1' ? 1 : 0);\n        }\n\n        curA = 0;\n        curB  = 0;\n        for (int i = 0; i < A.length(); i++) {\n            if (A.charAt(i) == '1' || B.charAt(i) == '1') {\n                int f = solve(curA, curB, cntC);\n                res = add(res, mul(dp[i], f));\n\n\n                if (A.charAt(i) == '1') {\n                    curA++;\n                }\n                if (B.charAt(i) == '1') {\n                    curB++;\n                }\n            }\n        }\n        return atleastOne ? res : -1;\n    }\n\n    int solve(String A, String B, String C, String D) {\n        int r1 = solveOneWay(A, B, C, D);\n        int r2 = solveOneWay(C, D, A, B);\n        if (r1 == -1 && r2 == -1) {\n            return 0;\n        }\n        return add(Math.max(r1, 0), Math.max(r2, 0));\n    }\n\n    final int MAX = (int) 2e5 + 10;\n\n    int[] fact(int n) {\n        int[] res = new int[n];\n        res[0] = 1;\n        for (int i = 1; i < n; i++) {\n            res[i] = mul(res[i - 1], i);\n        }\n        return res;\n    }\n\n    int[] factInv(int[] fact) {\n        int n = fact.length;\n        int[] res = new int[n];\n        res[n - 1] = BigInteger.valueOf(fact[n - 1]).modInverse(BigInteger.valueOf(mod)).intValue();\n        for (int i = n - 2; i >= 0; i--) {\n            res[i] = mul(res[i + 1], i + 1);\n        }\n        return res;\n    }\n\n    int c(int n, int k) {\n        if (k < 0 || k > n) {\n            return 0;\n        }\n        return mul(fact[n], mul(factInv[k], factInv[n - k]));\n    }\n\n    private void solve() {\n        fact = fact(MAX);\n        factInv = factInv(fact);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        String A = in.next();  // len n\n        String B = in.next();\n        String C = in.next();\n        String D = in.next();\n        out.println(solve(A, B, C, D));\n    }\n\n    private void run() {\n        try {\n            in = new FastScanner(new File(\"CodeFestival_QualA_E.in\"));\n            out = new PrintWriter(new File(\"CodeFestival_QualA_E.out\"));\n\n            solve();\n\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n\n    private void runIO() {\n        in = new FastScanner(System.in);\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    private class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        FastScanner(InputStream f) {\n            br = new BufferedReader(new InputStreamReader(f));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return null;\n                st = new StringTokenizer(s);\n            }\n            return st.nextToken();\n        }\n\n        boolean hasMoreTokens() {\n            while (st == null || !st.hasMoreTokens()) {\n                String s = null;\n                try {\n                    s = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (s == null)\n                    return false;\n                st = new StringTokenizer(s);\n            }\n            return true;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().runIO();\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int H = re.i();\n        int W = re.i();\n        string Left = re.s();\n        string Right = re.s();\n        string Up = re.s();\n        string Down = re.s();\n        long count = 0;\n        Fact F = new Fact(2*H+2*W);\n        for(int rnt=0;rnt<2;rnt++){\n            long[] L = new long[W];\n            int c = 0;\n            for(int i=0;i<H;i++){\n                if(Left[i] == '1'){\n                    c++;\n                }\n            }\n            if(c == 0){\n                for(int i=0;i<W;i++){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        L[i] = 1;\n                        break;\n                    }\n                }\n            }\n            else{\n                int u = 0;\n                int d = 0;\n                for(int i=0;i<W;i++){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        L[i] = F.GetConv(u+d+c-1,c-1);\n                    }\n                    if(Up[i] != '0'){\n                        u++;\n                    }\n                    if(Down[i] != '0'){\n                        d++;\n                    }\n                }\n            }\n            long[] R = new long[W];\n            c = 0;\n            for(int i=0;i<H;i++){\n                if(Right[i] == '1'){\n                    c++;\n                }\n            }\n            if(c == 0){\n                for(int i=W-1;i>=0;i--){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        R[i] = 1;\n                        break;\n                    }\n                }\n            }\n            else{\n                int u = 0;\n                int d = 0;\n                for(int i=W-1;i>=0;i--){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        R[i] = F.GetConv(u+d+c-1,c-1);\n                    }\n                    if(Up[i] != '0'){\n                        u++;\n                    }\n                    if(Down[i] != '0'){\n                        d++;\n                    }\n                }\n            }\n            long c2 = 0;\n            for(int i=W-1;i>=0;i--){\n                c2 = (c2 + R[i]) % Define.mod;\n                if(Up[i] != '0' && Down[i] != '0'){\n                    c2 *= 2;\n                }\n                count = (count + L[i] * c2) % Define.mod;\n            }\n            {\n                int tempi = H;\n                H = W;\n                W = tempi;\n                string temps = Left;\n                Left = Up;\n                Up = temps;\n                temps = Right;\n                Right = Down;\n                Down = temps;\n            }\n        }\n        if(H == 1 && W == 1 && count == 0){\n            count++;\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 998244353;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    ReadData re;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        re = new ReadData();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int H = re.i();\n        int W = re.i();\n        string Left = re.s();\n        string Right = re.s();\n        string Up = re.s();\n        string Down = re.s();\n        long count = 0;\n        Fact F = new Fact(2*H+2*W);\n        for(int rnt=0;rnt<2;rnt++){\n            long[] L = new long[W];\n            int c = 0;\n            for(int i=0;i<H;i++){\n                if(Left[i] == '1'){\n                    c++;\n                }\n            }\n            if(c == 0){\n                for(int i=0;i<W;i++){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        L[i] = 1;\n                        break;\n                    }\n                }\n            }\n            else{\n                int u = 0;\n                int d = 0;\n                for(int i=0;i<W;i++){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        L[i] = F.GetConv(u+d+c-1,c-1);\n                    }\n                    if(Up[i] != '0'){\n                        u++;\n                    }\n                    if(Down[i] != '0'){\n                        d++;\n                    }\n                }\n            }\n            long[] R = new long[W];\n            c = 0;\n            for(int i=0;i<H;i++){\n                if(Right[i] == '1'){\n                    c++;\n                }\n            }\n            if(c == 0){\n                for(int i=W-1;i>=0;i--){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        R[i] = 1;\n                        break;\n                    }\n                }\n            }\n            else{\n                int u = 0;\n                int d = 0;\n                for(int i=W-1;i>=0;i--){\n                    if(Up[i] != '0' || Down[i] != '0'){\n                        R[i] = F.GetConv(u+d+c-1,c-1);\n                    }\n                    if(Up[i] != '0'){\n                        u++;\n                    }\n                    if(Down[i] != '0'){\n                        d++;\n                    }\n                }\n            }\n            long c2 = 0;\n            for(int i=W-1;i>=0;i--){\n                c2 = (c2 + R[i]) % Define.mod;\n                if(Up[i] != '0' && Down[i] != '0'){\n                    c2 *= 2;\n                }\n                count = (count + L[i] * c2) % Define.mod;\n            }\n            {\n                int tempi = H;\n                H = W;\n                W = tempi;\n                string temps = Left;\n                Left = Up;\n                Up = temps;\n                temps = Right;\n                Right = Down;\n                Down = temps;\n            }\n        }\n        bool zero = true;\n        for(int i=0;i<H;i++){\n            zero &= Right[i] == '0' && Left[i] == '0';\n        }\n        for(int i=0;i<W;i++){\n            zero &= Up[i] == '0' && Down[i] == '0';\n        }\n        if(zero){\n            count = 1;\n        }\n        sb.Append(count+\"\\n\");\n    }\n}\nclass Fact{\n    public long[] f;\n    public long[] rf;\n    public Fact(int N){\n        f = new long[N+1];\n        rf = new long[N+1];\n        for(int i=0;i<N+1;i++){\n            if(i == 0){\n                f[i] = 1;\n            }\n            else{\n                f[i] = (f[i-1]*i)%Define.mod;\n            }\n        }\n        for(int i=N;i>=0;i--){\n            if(i == N){\n                rf[i] = pow(f[N],Define.mod-2);\n            }\n            else{\n                rf[i] = rf[i+1]*(i+1)%Define.mod;\n            }\n        }\n    }\n    public long pow(long N,long K){\n        if(K == 0){\n            return 1;\n        }\n        else if(K % 2 == 0){\n            long t = pow(N,K/2);\n            return t*t%Define.mod;\n        }\n        else{\n            return N*pow(N,K-1)%Define.mod;\n        }\n    }\n    public long GetFact(int N){\n        return f[N];\n    }\n    public long GetConv(int N,int R){\n        return ((f[N]*rf[R])%Define.mod*rf[N-R])%Define.mod;\n    }\n}\nclass ReadData{\n    string[] str;\n    int counter;\n    public ReadData(){\n        counter = 0;\n    }\n    public string s(){\n        if(counter == 0){\n            str = Console.ReadLine().Split(' ');\n            counter = str.Length;\n        }\n        counter--;\n        return str[str.Length-counter-1];\n    }\n    public int i(){\n        return int.Parse(s());\n    }\n    public long l(){\n        return long.Parse(s());\n    }\n    public double d(){\n        return double.Parse(s());\n    }\n    public int[] ia(int N){\n        int[] ans = new int[N];\n        for(int j=0;j<N;j++){\n            ans[j] = i();\n        }\n        return ans;\n    }\n    public int[] ia(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        int[] ans = new int[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = int.Parse(str[j]);\n        }\n        return ans;\n    }\n    public long[] la(int N){\n        long[] ans = new long[N];\n        for(int j=0;j<N;j++){\n            ans[j] = l();\n        }\n        return ans;\n    }\n    public long[] la(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        long[] ans = new long[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = long.Parse(str[j]);\n        }\n        return ans;\n    }\n    public double[] da(int N){\n        double[] ans = new double[N];\n        for(int j=0;j<N;j++){\n            ans[j] = d();\n        }\n        return ans;\n    }\n    public double[] da(){\n        str = Console.ReadLine().Split(' ');\n        counter = 0;\n        double[] ans = new double[str.Length];\n        for(int j=0;j<str.Length;j++){\n            ans[j] = double.Parse(str[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int[] f,int[] t){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<f.Length;j++){\n            ans[f[j]].Add(t[j]);\n            ans[t[j]].Add(f[j]);\n        }\n        return ans;\n    }\n    public List<int>[] g(int N,int M){\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n    public List<int>[] g(){\n        int N = i();\n        int M = i();\n        List<int>[] ans = new List<int>[N];\n        for(int j=0;j<N;j++){\n            ans[j] = new List<int>();\n        }\n        for(int j=0;j<M;j++){\n            int f = i()-1;\n            int t = i()-1;\n            ans[f].Add(t);\n            ans[t].Add(f);\n        }\n        return ans;\n    }\n}\npublic static class Define{\n    public const long mod = 998244353;\n}\npublic static class Debug{\n    public static void Print(double[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(double[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(long[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(long[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n    public static void Print(int[,,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                for(int l=0;l<k.GetLength(2);l++){\n                    Console.Write(k[i,j,l]+\" \");\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[,] k){\n        for(int i=0;i<k.GetLength(0);i++){\n            for(int j=0;j<k.GetLength(1);j++){\n                Console.Write(k[i,j]+\" \");\n            }\n            Console.WriteLine();\n        }\n    }\n    public static void Print(int[] k){\n        for(int i=0;i<k.Length;i++){\n            Console.WriteLine(k[i]);\n        }\n    }\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.math;\n\nimport std.typecons;\n\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.modint;\n\nalias Mint = ModInt!998244353;\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(1_000_000);\n    iFac = invFactTable!Mint(1_000_000);\n}\nMint C(int n, int k) {\n    if (n == k) return Mint(1);\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n] * iFac[k] * iFac[n-k];\n}\n\nMint solve(int n, int m, bool[] a, bool[] b, bool[] c, bool[] d) {\n    int lc = c.count(true).to!int - 1;\n    int rc = d.count(true).to!int - 1;\n    Mint sm = 0, rsm = 0;\n    int le = (a.count(true) + b.count(true)).to!int;\n    int ri = 0;\n\n    foreach_reverse (l; 0..n) {\n        if (a[l]) le--;\n        if (b[l]) le--;\n        if (!a[l] && !b[l]) continue;\n        rsm += C(rc + ri, rc);\n        if (a[l] && b[l]) rsm *= Mint(2);\n        sm += C(lc + le, lc) * rsm;\n        if (a[l]) ri++;\n        if (b[l]) ri++;\n    }\n    return sm;\n}\n\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m;\n    sc.read(n, m);\n    bool[][] f = new bool[][4];\n    foreach (i; 0..4) {\n        string s;\n        sc.read(s);\n        f[i] = s.map!\"a=='1'\".array;\n    }\n\n    Mint sm = 0;\n    sm += solve(n, m, f[0], f[1], f[2], f[3]);\n    sm += solve(m, n, f[2], f[3], f[0], f[1]);\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n\nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n//     import dcomp.int128;\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/ldc/inline.d */\n// module dcomp.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir)\n        R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/int128.d */\n \n\n// module dcomp.int128;\n\n// import dcomp.array;\n\nversion(LDC) {\n//     import dcomp.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv, std.math;\n\nimport std.typecons;\n\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.modint;\n\nalias Mint = ModInt!998244353;\n\nMint[] fact, iFac;\nstatic this() {\n    fact = factTable!Mint(1_000_000);\n    iFac = invFactTable!Mint(1_000_000);\n}\nMint C(int n, int k) {\n    if (n == k) return Mint(1);\n    if (k < 0 || n < k) return Mint(0);\n    return fact[n] * iFac[k] * iFac[n-k];\n}\n\nMint solve(int n, int m, bool[] a, bool[] b, bool[] c, bool[] d) {\n    int lc = c.count(true).to!int - 1;\n    int rc = d.count(true).to!int - 1;\n    Mint sm = 0, rsm = 0;\n    int le = (a.count(true) + b.count(true)).to!int;\n    int ri = 0;\n\n    foreach_reverse (l; 0..n) {\n        if (a[l]) le--;\n        if (b[l]) le--;\n        if (!a[l] && !b[l]) continue;\n        rsm += C(rc + ri, rc);\n        if (a[l] && b[l]) rsm *= Mint(2);\n        sm += C(lc + le, lc) * rsm;\n        if (a[l]) ri++;\n        if (b[l]) ri++;\n    }\n    return sm;\n}\n\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n, m;\n    sc.read(n, m);\n    bool[][] f = new bool[][4];\n    foreach (i; 0..4) {\n        string s;\n        sc.read(s);\n        f[i] = s.map!\"a=='1'\".array;\n    }\n\n    if (f.map!(v => v.count(true)).sum == 0) {\n        writeln(1);\n        return 0;\n    }\n    Mint sm = 0;\n    sm += solve(n, m, f[0], f[1], f[2], f[3]);\n    sm += solve(m, n, f[2], f[3], f[0], f[1]);\n    writeln(sm);\n    return 0;\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/modint.d */\n// module dcomp.modint;\n\n// import dcomp.numeric.primitive;\n\n \nstruct ModInt(uint MD) if (MD < int.max) {\n    import std.conv : to;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = (v%MD+MD)%MD;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {ModInt m; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(ModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(ModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(ModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(ModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(ModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static ModInt inv(ModInt x) {return ModInt(extGcd!int(x.v, MD)[0]);}\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\n \nstruct DModInt(string name) {\n    import std.conv : to;\n    static uint MD;\n    uint v;\n    this(int v) {this(long(v));}\n    this(long v) {this.v = ((v%MD+MD)%MD).to!uint;}\n    static auto normS(uint x) {return (x<MD)?x:x-MD;}\n    static auto make(uint x) {DModInt m; m.MD = MD; m.v = x; return m;}\n     \n    auto opBinary(string op:\"+\")(DModInt r) const {return make(normS(v+r.v));}\n     \n    auto opBinary(string op:\"-\")(DModInt r) const {return make(normS(v+MD-r.v));}\n     \n    auto opBinary(string op:\"*\")(DModInt r) const {return make((ulong(v)*r.v%MD).to!uint);}\n     \n    auto opBinary(string op:\"/\")(DModInt r) const {return this*inv(r);}\n    auto opOpAssign(string op)(DModInt r) {return mixin (\"this=this\"~op~\"r\");}\n     \n    static DModInt inv(DModInt x) {\n        return DModInt(extGcd!int(x.v, MD)[0]);\n    }\n    string toString() {return v.to!string;}\n}\n\n \n \n\n \n\ntemplate isModInt(T) {\n    const isModInt =\n        is(T : ModInt!MD, uint MD) || is(S : DModInt!S, string s);\n}\n\n\nT[] factTable(T)(size_t length) if (isModInt!T) {\n    import std.range : take, recurrence;\n    import std.array : array;\n    return T(1).recurrence!((a, n) => a[n-1]*T(n)).take(length).array;\n}\n\n \nT[] invFactTable(T)(size_t length) if (isModInt!T) {\n    import std.algorithm : map, reduce;\n    import std.range : take, recurrence, iota;\n    import std.array : array;\n    auto res = new T[length];\n    res[$-1] = T(1) / iota(1, length).map!T.reduce!\"a*b\";\n    foreach_reverse (i, v; res[0..$-1]) {\n        res[i] = res[i+1] * T(i+1);\n    }\n    return res;\n}\n\nT[] invTable(T)(size_t length) if (isModInt!T) {\n    auto f = factTable!T(length);\n    auto invf = invFactTable!T(length);\n    auto res = new T[length];\n    foreach (i; 1..length) {\n        res[i] = invf[i] * f[i-1];\n    }\n    return res;\n}\n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\nimport std.bigint;\n\n \nUnqual!T pow(T, U)(T x, U n)\nif (!isFloatingPoint!T && (isIntegral!U || is(U == BigInt))) {\n    return pow(x, n, T(1));\n}\n\n \nUnqual!T pow(T, U, V)(T x, U n, V e)\nif ((isIntegral!U || is(U == BigInt)) && is(Unqual!T == Unqual!V)) {\n    Unqual!T b = x, v = e;\n    Unqual!U m = n;\n    while (m) {\n        if (m & 1) v *= b;\n        b *= b;\n        m /= 2;\n    }\n    return v;\n}\n\n \n\n\nT powMod(T, U, V)(T x, U n, V md)\nif (isIntegral!U || is(U == BigInt)) {\n    T r = T(1);\n    while (n) {\n        if (n & 1) r = (r*x)%md;\n        x = (x*x)%md;\n        n >>= 1;\n    }\n    return r % md;\n}\n\nulong ulongPowMod(U)(ulong x, U n, ulong md)\nif (isIntegral!U || is(U == BigInt)) {\n//     import dcomp.int128;\n    x %= md;\n    ulong r = 1;\n    while (n) {\n        if (n & 1) {\n            r = mul128(r, x).mod128(md);\n        }\n        x = mul128(x, x).mod128(md);\n        n >>= 1;\n    }\n    return r % md;\n}\n\n \nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\n \n \n\n \n \nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T)  \n{\n    if (b==0) {\n        return [T(1), T(0), a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\n \n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/ldc/inline.d */\n// module dcomp.ldc.inline;\n\nversion(LDC) {\n    pragma(LDC_inline_ir)\n        R inlineIR(string s, R, P...)(P);\n}\n/* IMPORT /Users/yosupo/Program/dcomp/source/dcomp/int128.d */\n \n\n// module dcomp.int128;\n\n// import dcomp.array;\n\nversion(LDC) {\n//     import dcomp.ldc.inline;\n}\n\nversion(LDC) version(X86_64) {\n    version = LDC_IR;\n}\n\n \nulong[2] mul128(ulong a, ulong b) {\n    ulong[2] res;\n    version(LDC_IR) {\n        ulong upper, lower;\n        inlineIR!(`\n            %r0 = zext i64 %0 to i128 \n            %r1 = zext i64 %1 to i128\n            %r2 = mul i128 %r1, %r0\n            %r3 = trunc i128 %r2 to i64\n            %r4 = lshr i128 %r2, 64\n            %r5 = trunc i128 %r4 to i64\n            store i64 %r3, i64* %2\n            store i64 %r5, i64* %3`, void)(a, b, &lower, &upper);\n        return [lower, upper];\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper, lower;\n        asm {\n            mov RAX, a;\n            mul b;\n            mov lower, RAX;\n            mov upper, RDX;\n        }\n        return [lower, upper];\n    } else {\n        ulong B = 2UL^^32;\n        ulong[2] a2 = [a % B, a / B];\n        ulong[2] b2 = [b % B, b / B];\n        ulong[4] c;\n        foreach (i; 0..2) {\n            foreach (j; 0..2) {\n                c[i+j] += a2[i] * b2[j] % B;\n                c[i+j+1] += a2[i] * b2[j] / B;\n            }\n        }\n        foreach (i; 0..3) {\n            c[i+1] += c[i] / B;\n            c[i] %= B;\n        }\n        return [c[0] + c[1] * B, c[2] + c[3] * B];\n    }\n}\n\n \n\n \nulong div128(ulong[2] a, ulong b) {\n    version(LDC_IR) {\n        return inlineIR!(`\n            %r0 = zext i64 %0 to i128\n            %r1 = zext i64 %1 to i128\n            %r2 = shl i128 %r1, 64\n            %r3 = add i128 %r0, %r2\n            %r4 = zext i64 %2 to i128\n            %r5 = udiv i128 %r3, %r4\n            %r6 = trunc i128 %r5 to i64\n            ret i64 %r6`,ulong)(a[0], a[1], b);\n    } else version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RAX;\n        }\n        return res;\n    } else {\n        if (b == 1) return a[0];\n        while (!(b & (1UL << 63))) {\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n            b <<= 1;\n        }\n        ulong ans = 0;\n        foreach (i; 0..64) {\n            bool up = (a[1] & (1UL << 63)) != 0;\n            a[1] <<= 1;\n            if (a[0] & (1UL << 63)) a[1] |= 1;\n            a[0] <<= 1;\n\n            ans <<= 1;\n            if (up || b <= a[1]) {\n                a[1] -= b;\n                ans++;\n            }\n        }\n        return ans;\n    }\n}\n\n\n \nulong mod128(ulong[2] a, ulong b) {\n    version(D_InlineAsm_X86_64) {\n        ulong upper = a[1], lower = a[0];\n        ulong res;\n        asm {\n            mov RDX, upper;\n            mov RAX, lower;\n            div b;\n            mov res, RDX;\n        }\n        return res;\n    } else {\n        return a[0] - div128(a, b) * b;\n    }\n}\n\n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    AB = A+B\n    R = C.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    NR[AB==0] = 0\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x=(coef * NR % MOD).sum()%MOD\n    assert x == cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    n = A.sum()+B.sum()+C.sum()-1; m = C.sum()-1\n    y = fact[n] * fact_inv[m] % MOD * fact_inv[n-m] % MOD\n    return (x+y)%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n    raise exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    AB = A+B\n    R = C.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    NR[AB==0] = 0\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x=(coef * NR % MOD).sum()%MOD\n    \n    n = A.sum()+B.sum()+C.sum()-1; m = C.sum()-1\n    y = fact[n] * fact_inv[m] % MOD * fact_inv[n-m] % MOD\n    return (x+y)%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n    raise exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,1,np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = F(N,M,A,B,np.zeros_like(C),C)\n    x += F(N,M,C,np.zeros_like(C),A,B)\n    raise x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n#    if all(x != 0 for x in [NA,NB,NC,ND]):\n    return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    raise Exception\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA,B,C,D = [np.array(list(readline().rstrip()))-48 for _ in range(4)]\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB=A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L=C.sum(); LU=A.cumsum()-A; LD=B.cumsum()-B\n    NL=fact[LU+LD+L-1]*fact_inv[LU+LD]%MOD*fact_inv[L-1]% MOD\n\n    R=D.sum(); RU=A[::-1].cumsum()-A[::-1]; RD=B[::-1].cumsum()-B[::-1]\n    NR=fact[RU+RD+R-1]*fact_inv[RU+RD]%MOD*fact_inv[R-1]%MOD; NR=NR[::-1]\n\n    x=np.ones(N,np.int64); x[AB==2]=2; coef=cumprod(x,MOD)\n    x=np.ones(N,np.int64); x[AB==2]=(MOD+1)//2; coef_inv=cumprod(x,MOD)\n    NL*=coef_inv; NR*=coef; NL%=MOD; NR%=MOD\n    NL[AB==2]*=2\n    NL[AB==0]=0;NR[AB==0]=0\n    NL_cum=NL.cumsum()%MOD\n    return (NL_cum*NR%MOD).sum()%MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    AB=A+B\n    NA,NB,NC = [np.count_nonzero(x) for x in [A,B,C]]\n    R=NC;RU=A[::-1].cumsum()-A[::-1];RD=B[::-1].cumsum()-B[::-1]\n    NR=fact[RU+RD+R-1]*fact_inv[RU+RD]%MOD*fact_inv[R-1]%MOD; NR=NR[::-1]\n    NR[AB==0]=0\n    x=np.ones(N,np.int64); x[AB==2]=2; coef=cumprod(x,MOD)\n    x=(coef*NR% MOD).sum()%MOD\n    y=fact[NA+NB+NC-1]*fact_inv[NC-1]%MOD*fact_inv[NA+NB]%MOD\n    return (x+y)%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A; C = C[::-1]; D = D[::-1]\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C; A = A[::-1]; B = B[::-1]\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n    raise exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n        \n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef LR_only(N,A,B):\n    return -1\n\ndef LRU_only(N,M,A,B,C):\n    return -1    \n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return LR_only(M,C,D)\n    if ND == 0:\n        return LR_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return LRU_only(M,N,C,D,B)\n    if NC == 0:\n        return LRU_only(N,M,A,B,D)\n    raise Exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n        \n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    raise Exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    assert R > 0\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n        \n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,1,np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    raise Exception\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return LR_only(M,C,D)\n    if ND == 0:\n        return LR_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return LRU_only(M,N,C,D,B)\n    if NC == 0:\n        return LRU_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,1,np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    AB = A+B\n    R = C.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    NR[AB==0] = 0\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x=(coef * NR % MOD).sum()%MOD\n    assert x == cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    n = A.sum()+B.sum()+C.sum()-1; m = C.sum()-1\n    y = fact[n] * fact_inv[m] % MOD * fact_inv[n-m] % MOD\n    return (x+y)%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; temp = A.copy(); A = B; B = temp\n    if NC != 0:\n        NC,ND = ND,NC; temp = C.copy(); C = D; D = temp\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n    raise exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    y = cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    n = A.sum()+B.sum()+C.sum()-1; m = C.sum()-1\n    z = fact[n] * fact_inv[m] % MOD * fact_inv[n-m] % MOD\n    assert y == z\n    return (x+y)%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n    raise exception\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n        \n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef LR_only(N,A,B):\n    raise Exception\n\ndef LRU_only(N,M,A,B,C):\n    raise Exception\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return LR_only(M,C,D)\n    if ND == 0:\n        return LR_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return LRU_only(M,N,C,D,B)\n    if NC == 0:\n        return LRU_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nB = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nC = np.array(list(readline().rstrip()),dtype=np.int64) - 48\nD = np.array(list(readline().rstrip()),dtype=np.int64) - 48\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    AB = A+B\n    R = C.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    NR[AB==0] = 0\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x=(coef * NR % MOD).sum()%MOD\n    assert x == cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    n = A.sum()+B.sum()+C.sum()-1; m = C.sum()-1\n    y = fact[n] * fact_inv[m] % MOD * fact_inv[n-m] % MOD\n    return (x+y)%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A; C = C[::-1]; D = D[::-1]\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C; A = A[::-1]; B = B[::-1]\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)\n\nN=3\nM=2\nwhile True:\n    A=np.random.randint(0,2,N).astype(np.int64)\n    B=np.random.randint(0,2,N).astype(np.int64)\n    C=np.random.randint(0,2,M).astype(np.int64)\n    D=np.random.randint(0,2,M).astype(np.int64)\n    x=F(N,M,A,B,C,D)\n    y=F(M,N,C,D,A,B)\n    z=F(N,M,B,A,C,D)\n    if x != z:\n        break\n\nA,B,C,D\n\nx,y,z\n\ncnt_vertical(N,M,A,B,C,D),cnt_vertical(N,M,B,A,C,D)\n\ncnt_vertical(M,N,C,D,A,B),cnt_vertical(M,N,C,D,B,A)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 998244353\n\nN,M = map(int,readline().split())\nA = np.array(list(readline().rstrip())) - 48\nB = np.array(list(readline().rstrip())) - 48\nC = np.array(list(readline().rstrip())) - 48\nD = np.array(list(readline().rstrip())) - 48\n\nA,B,C,D\n\ndef cumprod(arr,MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr,Lsq**2).reshape(Lsq,Lsq)\n    for n in range(1,Lsq):\n        arr[:,n] *= arr[:,n-1]; arr[:,n] %= MOD\n    for n in range(1,Lsq):\n        arr[n] *= arr[n-1,-1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U,MOD):\n    x = np.arange(U,dtype=np.int64); x[0] = 1\n    fact = cumprod(x,MOD)\n    x = np.arange(U,0,-1,dtype=np.int64); x[0] = pow(int(fact[-1]),MOD-2,MOD)\n    fact_inv = cumprod(x,MOD)[::-1]\n    return fact,fact_inv\n\nU = 10**6\nfact, fact_inv = make_fact(U,MOD)\n\ndef cnt_vertical(N,M,A,B,C,D):\n    \"\"\"\n    ・ABが長さN、CDが長さM。\n    ・初手に縦線を入れる場合。\n    ・縦線の右端の位置に応じて場合分けして集計\n    ・右端の位置を決めると、（左端の位置ごとの左側の入れ方の累積和） x （右側の入れ方の累積和）、適当に重みをつける必要あり\n    \"\"\"\n    AB = A+B\n    # ある場所を初めての縦線としたときに、左側にできる部分。上にある点の個数と下にある点の個数\n    L = C.sum(); LU = A.cumsum() - A; LD = B.cumsum() - B\n    if L >= 1:\n        NL = fact[LU+LD+L-1] * fact_inv[LU+LD] % MOD * fact_inv[L-1] % MOD\n    else:\n        NL = np.zeros(N,dtype=np.int64)\n        i = np.where(AB>0)[0][0]\n        NL[i] = 1\n        \n    R = D.sum(); RU = A[::-1].cumsum() - A[::-1]; RD = B[::-1].cumsum() - B[::-1]\n    NR = fact[RU+RD+R-1] * fact_inv[RU+RD] % MOD * fact_inv[R-1] % MOD; NR = NR[::-1]\n    # とりあえず\n    x = np.full(N,1,np.int64); x[AB==2] = 2; coef = cumprod(x,MOD)\n    x = np.full(N,1,np.int64); x[AB==2] = (MOD+1)//2; coef_inv = cumprod(x,MOD)\n    NL *= coef_inv; NR *= coef; NL %= MOD; NR %= MOD\n    NL[AB==2] *= 2; NL[NL>=MOD] -= MOD\n    NL[AB==0] = 0; NR[AB==0] = 0\n    # sum(l<=r) NL[l] NR[r] を求めればよい。\n    NL_cum = NL.cumsum() % MOD\n    return (NL_cum * NR % MOD).sum() % MOD\n\ndef AB_only(N,A,B):\n    raise Exception\n    x = np.ones(N,dtype=np.int64)\n    x[A+B==2] = 2\n    return cumprod(x,MOD)[-1]\n\ndef ABC_only(N,M,A,B,C):\n    x = cnt_vertical(N,M,A,B,np.zeros_like(C),C)\n    x += cnt_vertical(M,N,C,np.zeros_like(C),A,B)\n    return x%MOD\n\ndef F(N,M,A,B,C,D):\n    # 問題の答えを出します。\n    NA,NB,NC,ND = [np.count_nonzero(x) for x in [A,B,C,D]]\n    if all(x != 0 for x in [NA,NB,NC,ND]):\n        return (cnt_vertical(N,M,A,B,C,D) + cnt_vertical(M,N,C,D,A,B)) % MOD\n    # A,Cに0列を寄せる\n    if NA != 0:\n        NA,NB = NB,NA; A,B = B,A\n    if NC != 0:\n        NC,ND = ND,NC; C,D = D,C\n    if NB == 0:\n        return AB_only(M,C,D)\n    if ND == 0:\n        return AB_only(N,A,B)\n    # B,Dは0ではない\n    if NA == 0 and NC == 0:\n        # 2面B,Dのみ -> binom(B+D,B)\n        return fact[NB+ND] * fact_inv[NB] % MOD * fact_inv[ND] % MOD\n    if NA == 0:\n        return ABC_only(M,N,C,D,B)\n    if NC == 0:\n        return ABC_only(N,M,A,B,D)\n\nanswer = F(N,M,A,B,C,D)\nprint(answer)"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        eprintln!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n}\n\nimpl Combination {\n    fn inv(a: i64) -> i64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: i64, p: i64) -> i64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as i64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as i64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> i64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n}\n\n//===\n\nconst MOD: i64 = 998244353;\n\n// fn solve2(comb: &Combination, h: usize, w: usize) -> i64 {\n//     if w == 0 {\n//         return 1;\n//     }\n//     comb.comb(h+w-1, h)\n// }\n\n// fn solve(comb: &Combination, h: usize, up: usize, dw: usize) -> i64 {\n//     let mut ret = 0;\n//     for i in 0..h {\n//         for j in i..h {\n//             ret += solve2(comb, i, up) * solve2(comb, h-1-j, dw);\n//         }\n//     }\n//     debug!(ret, comb.comb(h+up+dw-1, up+dw));\n//     ret\n// }\n\n\n// fn solve(h: usize, up: &Vec<usize>, dw: &Vec<usize>) {\n// }\n\n\nfn compute(a: Vec<char>, b: Vec<char>, c: Vec<char>, d: Vec<char>) -> i64 {\n    let comb = Combination::new(310000);\n\n    let left = a.into_iter().fold(0, |acc, x| acc+ifv!(x == '1', 1, 0));\n    let right = b.into_iter().fold(0, |acc, x| acc+ifv!(x == '1', 1, 0));\n\n    let up = c.into_iter().map(|c| ifv!(c == '1', 1, 0)).collect::<Vec<_>>();\n    let dw = d.into_iter().map(|c| ifv!(c == '1', 1, 0)).collect::<Vec<_>>();\n    let n = up.len();\n    let mut dbl = vec![0; n];\n    for i in 0..n {\n        dbl[i] = (up[i] + dw[i]) as i64;\n    }\n    let mut up = (0..n).filter(|&i| dbl[i] >= 1).map(|i| up[i]).collect::<Vec<_>>();\n    let mut dw = (0..n).filter(|&i| dbl[i] >= 1).map(|i| dw[i]).collect::<Vec<_>>();\n    let dbl = dbl.into_iter().filter(|&d| d >= 1).collect::<Vec<_>>();\n    let n = up.len();\n\n    if n == 0 {\n        return -1;\n    }\n    if left + right == 0 {\n        let mut ret = 1;\n        for i in 0..n {\n            ret *= dbl[i];\n            ret %= MOD;\n        }\n        return ret;\n    }\n\n\n    let solvel = |h: usize, up: &Vec<usize>, dw: &Vec<usize>| {\n        let n = up.len();\n        let mut ans = vec![];\n        let mut u = 0;\n        let mut d = 0;\n        for i in 0..n {\n            if h+u+d >= 1 {\n                ans.push(comb.comb(h+u+d-1, u+d));\n            } else {\n                ans.push(1);\n            }\n            u += up[i];\n            d += dw[i];\n        }\n        ans\n    };\n\n    let leftans = solvel(left, &up, &dw);\n    up.reverse();\n    dw.reverse();\n    let mut rightans = solvel(right, &up, &dw);\n    rightans.reverse();\n\n    // debug!(left, right, leftans, rightans);\n\n    for i in (1..n).rev() {\n        rightans[i] *= dbl[i];\n        rightans[i] %= MOD;\n        rightans[i-1] += rightans[i];\n        rightans[i-1] %= MOD;\n    }\n    rightans[0] *= dbl[0];\n    rightans[0] %= MOD;\n\n    let mut ans = 0;\n    let inv2 = Combination::inv(2);\n    for i in 0..n {\n        if dbl[i] >= 1 {\n            ans += leftans[i] * rightans[i];\n            ans %= MOD;\n        }\n    }\n    ans\n}\n\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: chars,\n        b: chars,\n        c: chars,\n        d: chars\n    }\n\n    let ans1 = compute(a.clone(), b.clone(), c.clone(), d.clone());\n    let ans2 = compute(c, d, a, b);\n    // debug!(ans1, ans2);\n    if ans1 == -1 && ans2 == -1 {\n        println!(\"1\");\n        return;\n    }\n    let ans1 = max(0, ans1);\n    let ans2 = max(0, ans2);\n    println!(\"{}\", (ans1 + ans2) % MOD);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n// Input macros.\n// Original by tanakh: https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_line {\n    ($t:tt) => {\n        {\n            let mut s = String::new();\n            std::io::stdin().read_line(&mut s).unwrap();\n            s.trim_right().parse::<$t>().unwrap()\n        }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        eprintln!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\nstruct Combination {\n    fact: Vec<i64>,\n    invfact: Vec<i64>,\n}\n\nimpl Combination {\n    fn inv(a: i64) -> i64 {\n        Combination::pow(a, MOD - 2)\n    }\n\n    fn pow(a: i64, p: i64) -> i64 {\n        let mut p = p;\n        let mut aa = a;\n        let mut ret = 1;\n        while p >= 1 {\n            if p & 1 == 1 {\n                ret *= aa;\n                ret %= MOD;\n            }\n            p >>= 1;\n            aa = aa * aa % MOD;\n        }\n        ret\n    }\n\n    fn new(upto: usize) -> Self {\n        let mut fact = vec![0; upto];\n        let mut invfact = vec![0; upto];\n\n        fact[0] = 1;\n        for i in 1..upto {\n            fact[i] = fact[i - 1] * (i as i64) % MOD;\n        }\n\n        invfact[upto - 1] = Combination::inv(fact[upto - 1]);\n        invfact[0] = 1;\n        for i in (1..upto - 1).rev() {\n            invfact[i] = invfact[i + 1] * ((i + 1) as i64) % MOD;\n        }\n\n        Combination {\n            fact: fact,\n            invfact: invfact,\n        }\n    }\n\n    fn comb(&self, n: usize, r: usize) -> i64 {\n        if r < 0 || r > n {\n            return 0;\n        }\n        self.fact[n] * self.invfact[r] % MOD * self.invfact[n - r] % MOD\n    }\n}\n\n//===\n\nconst MOD: i64 = 998244353;\n\n// fn solve2(comb: &Combination, h: usize, w: usize) -> i64 {\n//     if w == 0 {\n//         return 1;\n//     }\n//     comb.comb(h+w-1, h)\n// }\n\n// fn solve(comb: &Combination, h: usize, up: usize, dw: usize) -> i64 {\n//     let mut ret = 0;\n//     for i in 0..h {\n//         for j in i..h {\n//             ret += solve2(comb, i, up) * solve2(comb, h-1-j, dw);\n//         }\n//     }\n//     debug!(ret, comb.comb(h+up+dw-1, up+dw));\n//     ret\n// }\n\n\n// fn solve(h: usize, up: &Vec<usize>, dw: &Vec<usize>) {\n// }\n\n\nfn compute(a: Vec<char>, b: Vec<char>, c: Vec<char>, d: Vec<char>) -> i64 {\n    let comb = Combination::new(310000);\n\n    let left = a.into_iter().fold(0, |acc, x| acc+ifv!(x == '1', 1, 0));\n    let right = b.into_iter().fold(0, |acc, x| acc+ifv!(x == '1', 1, 0));\n\n    let up = c.into_iter().map(|c| ifv!(c == '1', 1, 0)).collect::<Vec<_>>();\n    let dw = d.into_iter().map(|c| ifv!(c == '1', 1, 0)).collect::<Vec<_>>();\n    let n = up.len();\n    let mut dbl = vec![0; n];\n    for i in 0..n {\n        dbl[i] = (up[i] + dw[i]) as i64;\n    }\n    let mut up = (0..n).filter(|&i| dbl[i] >= 1).map(|i| up[i]).collect::<Vec<_>>();\n    let mut dw = (0..n).filter(|&i| dbl[i] >= 1).map(|i| dw[i]).collect::<Vec<_>>();\n    let dbl = dbl.into_iter().filter(|&d| d >= 1).collect::<Vec<_>>();\n    let n = up.len();\n\n    if n == 0 {\n        return 0;\n    }\n    if left + right == 0 {\n        let mut ret = 1;\n        for i in 0..n {\n            ret *= max(1, dbl[i]);\n            ret %= MOD;\n        }\n        return ret;\n    }\n\n\n    let solvel = |h: usize, up: &Vec<usize>, dw: &Vec<usize>| {\n        let n = up.len();\n        let mut ans = vec![];\n        let mut u = 0;\n        let mut d = 0;\n        for i in 0..n {\n            if h+u+d >= 1 {\n                ans.push(comb.comb(h+u+d-1, u+d));\n            } else {\n                ans.push(1);\n            }\n            u += up[i];\n            d += dw[i];\n        }\n        ans\n    };\n\n    let leftans = solvel(left, &up, &dw);\n    up.reverse();\n    dw.reverse();\n    let mut rightans = solvel(right, &up, &dw);\n    rightans.reverse();\n\n    // debug!(left, right, leftans, rightans);\n\n    for i in (1..n).rev() {\n        rightans[i] *= dbl[i];\n        rightans[i] %= MOD;\n        rightans[i-1] += rightans[i];\n        rightans[i-1] %= MOD;\n    }\n    rightans[0] *= dbl[0];\n    rightans[0] %= MOD;\n\n    let mut ans = 0;\n    let inv2 = Combination::inv(2);\n    for i in 0..n {\n        if dbl[i] >= 1 {\n            ans += leftans[i] * rightans[i];\n            ans %= MOD;\n        }\n    }\n    ans\n}\n\n\nfn main() {\n    input! {\n        n: usize, m: usize,\n        a: chars,\n        b: chars,\n        c: chars,\n        d: chars\n    }\n\n    let ans1 = compute(a.clone(), b.clone(), c.clone(), d.clone());\n    let ans2 = compute(c, d, a, b);\n    // debug!(ans1, ans2);\n    // let ans = compute(a.clone(), b.clone(), c.clone(), d.clone()) + ;\n    println!(\"{}\", (ans1 + ans2) % MOD);\n}\n"
  }
]