[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint solve(char* a, char* b, char* c) {\n    int len_a = strlen(a);\n    int len_b = strlen(b);\n    int len_c = strlen(c);\n    \n    int count[10] = {0};\n    for (int i = 0; i < 10; i++) {\n        count[i] = 1;\n    }\n    \n    int ways = 1;\n    \n    for (int i = 0; i < len_a; i++) {\n        if (a[i] == '?') {\n            if (i == 0 && len_a > 1) {\n                ways = (ways * 9) % MOD;\n            } else {\n                ways = (ways * 10) % MOD;\n            }\n        } else {\n            int digit = a[i] - '0';\n            if (count[digit] == 0) return 0;\n            count[digit]--;\n        }\n    }\n    \n    for (int i = 0; i < len_b; i++) {\n        if (b[i] == '?') {\n            if (i == 0 && len_b > 1) {\n                ways = (ways * 9) % MOD;\n            } else {\n                ways = (ways * 10) % MOD;\n            }\n        } else {\n            int digit = b[i] - '0';\n            if (count[digit] == 0) return 0;\n            count[digit]--;\n        }\n    }\n    \n    for (int i = 0; i < len_c; i++) {\n        if (c[i] == '?') {\n            if (i == 0 && len_c > 1) {\n                ways = (ways * 9) % MOD;\n            } else {\n                ways = (ways * 10) % MOD;\n            }\n        } else {\n            int digit = c[i] - '0';\n            if (count[digit] == 0) return 0;\n            count[digit]--;\n        }\n    }\n    \n    return ways;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        char a[20], b[20], c[20];\n        scanf(\"%s %s %s\", a, b, c);\n        \n        int result = solve(a, b, c);\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:45:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n#define MAX_LEN 20\n\ntypedef struct {\n    char str[MAX_LEN + 1];\n    int len;\n} Number;\n\nNumber A, B, C;\nlong long dp[MAX_LEN + 1][2][2][2][2][2][2];\nint pow10[MAX_LEN * 2 + 1];\n\nvoid init_pow10() {\n    pow10[0] = 1;\n    for (int i = 1; i <= MAX_LEN * 2; i++) {\n        pow10[i] = (long long)pow10[i - 1] * 10 % MOD;\n    }\n}\n\nlong long solve(int pos, int carry, int a_lt, int a_gt, int b_lt, int b_gt, int c_lt, int c_gt) {\n    if (pos == 0) {\n        return (carry == 0 && a_lt && a_gt && b_lt && b_gt && c_lt && c_gt) ? 1 : 0;\n    }\n\n    if (dp[pos][carry][a_lt][a_gt][b_lt][b_gt][c_lt][c_gt] != -1) {\n        return dp[pos][carry][a_lt][a_gt][b_lt][b_gt][c_lt][c_gt];\n    }\n\n    long long res = 0;\n    int a_pos = pos - 1;\n    int b_pos = pos - 1;\n    int c_pos = pos - 1;\n\n    char a_char = (a_pos < A.len) ? A.str[A.len - 1 - a_pos] : '0';\n    char b_char = (b_pos < B.len) ? B.str[B.len - 1 - b_pos] : '0';\n    char c_char = (c_pos < C.len) ? C.str[C.len - 1 - c_pos] : '0';\n\n    int a_start = (a_pos == A.len - 1 && A.len > 1) ? 1 : 0;\n    int a_end = 9;\n    if (a_char != '?') {\n        a_start = a_char - '0';\n        a_end = a_char - '0';\n    }\n\n    int b_start = (b_pos == B.len - 1 && B.len > 1) ? 1 : 0;\n    int b_end = 9;\n    if (b_char != '?') {\n        b_start = b_char - '0';\n        b_end = b_char - '0';\n    }\n\n    int c_start = (c_pos == C.len - 1 && C.len > 1) ? 1 : 0;\n    int c_end = 9;\n    if (c_char != '?') {\n        c_start = c_char - '0';\n        c_end = c_char - '0';\n    }\n\n    for (int a_d = a_start; a_d <= a_end; a_d++) {\n        int new_a_lt = a_lt;\n        int new_a_gt = a_gt;\n        if (a_char == '?') {\n            if (a_pos < A.len) {\n                if (a_d < (A.str[A.len - 1 - a_pos] - '0')) new_a_lt = 1;\n                if (a_d > (A.str[A.len - 1 - a_pos] - '0')) new_a_gt = 1;\n            }\n        }\n\n        for (int b_d = b_start; b_d <= b_end; b_d++) {\n            int new_b_lt = b_lt;\n            int new_b_gt = b_gt;\n            if (b_char == '?') {\n                if (b_pos < B.len) {\n                    if (b_d < (B.str[B.len - 1 - b_pos] - '0')) new_b_lt = 1;\n                    if (b_d > (B.str[B.len - 1 - b_pos] - '0')) new_b_gt = 1;\n                }\n            }\n\n            for (int c_d = c_start; c_d <= c_end; c_d++) {\n                int new_c_lt = c_lt;\n                int new_c_gt = c_gt;\n                if (c_char == '?') {\n                    if (c_pos < C.len) {\n                        if (c_d < (C.str[C.len - 1 - c_pos] - '0')) new_c_lt = 1;\n                        if (c_d > (C.str[C.len - 1 - c_pos] - '0')) new_c_gt = 1;\n                    }\n                }\n\n                int sum = a_d + b_d + carry;\n                if (sum % 10 != c_d) continue;\n                int new_carry = sum / 10;\n\n                res += solve(pos - 1, new_carry, new_a_lt, new_a_gt, new_b_lt, new_b_gt, new_c_lt, new_c_gt);\n                res %= MOD;\n            }\n        }\n    }\n\n    dp[pos][carry][a_lt][a_gt][b_lt][b_gt][c_lt][c_gt] = res;\n    return res;\n}\n\nint main() {\n    init_pow10();\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%s %s %s\", A.str, B.str, C.str);\n        A.len = strlen(A.str);\n        B.len = strlen(B.str);\n        C.len = strlen(C.str);\n\n        int max_len = A.len;\n        if (B.len > max_len) max_len = B.len;\n        if (C.len > max_len) max_len = C.len;\n\n        memset(dp, -1, sizeof(dp));\n        long long ans = solve(max_len, 0, 0, 0, 0, 0, 0, 0);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:46:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nstring a, b, c;\nint dp[20][2][2][2][2][2][2];\n\nint solve(int pos, int carry, bool a_lt, bool b_lt, bool c_lt, bool a_leading, bool b_leading, bool c_leading) {\n    if (pos == max(a.size(), max(b.size(), c.size()))) {\n        return (carry == 0 && !a_leading && !b_leading && !c_leading) ? 1 : 0;\n    }\n    \n    int &res = dp[pos][carry][a_lt][b_lt][c_lt][a_leading][b_leading][c_leading];\n    if (res != -1) return res;\n    \n    res = 0;\n    \n    int a_pos = (int)a.size() - 1 - pos;\n    int b_pos = (int)b.size() - 1 - pos;\n    int c_pos = (int)c.size() - 1 - pos;\n    \n    int a_start = 0, a_end = 9;\n    if (!a_lt && a_pos >= 0) {\n        if (a[a_pos] != '?') {\n            a_start = a_end = a[a_pos] - '0';\n        } else {\n            a_start = (a_leading && pos == a.size() - 1) ? 1 : 0;\n        }\n    } else {\n        a_end = 9;\n    }\n    \n    int b_start = 0, b_end = 9;\n    if (!b_lt && b_pos >= 0) {\n        if (b[b_pos] != '?') {\n            b_start = b_end = b[b_pos] - '0';\n        } else {\n            b_start = (b_leading && pos == b.size() - 1) ? 1 : 0;\n        }\n    } else {\n        b_end = 9;\n    }\n    \n    int c_start = 0, c_end = 9;\n    if (!c_lt && c_pos >= 0) {\n        if (c[c_pos] != '?') {\n            c_start = c_end = c[c_pos] - '0';\n        } else {\n            c_start = (c_leading && pos == c.size() - 1) ? 1 : 0;\n        }\n    } else {\n        c_end = 9;\n    }\n    \n    for (int a_d = a_start; a_d <= a_end; a_d++) {\n        if (!a_lt && a_pos >= 0 && a[a_pos] != '?' && a_d != a[a_pos] - '0') continue;\n        bool new_a_lt = a_lt || (a_pos >= 0 && a_d < a[a_pos] - '0');\n        bool new_a_leading = a_leading && (a_d == 0);\n        \n        for (int b_d = b_start; b_d <= b_end; b_d++) {\n            if (!b_lt && b_pos >= 0 && b[b_pos] != '?' && b_d != b[b_pos] - '0') continue;\n            bool new_b_lt = b_lt || (b_pos >= 0 && b_d < b[b_pos] - '0');\n            bool new_b_leading = b_leading && (b_d == 0);\n            \n            int sum = a_d + b_d + carry;\n            int new_carry = sum / 10;\n            int c_d = sum % 10;\n            \n            if (!c_lt && c_pos >= 0 && c[c_pos] != '?' && c_d != c[c_pos] - '0') continue;\n            bool new_c_lt = c_lt || (c_pos >= 0 && c_d < c[c_pos] - '0');\n            bool new_c_leading = c_leading && (c_d == 0);\n            \n            if (c_d < c_start || c_d > c_end) continue;\n            \n            res = (res + solve(pos + 1, new_carry, new_a_lt, new_b_lt, new_c_lt, new_a_leading, new_b_leading, new_c_leading)) % MOD;\n        }\n    }\n    \n    return res;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        cin >> a >> b >> c;\n        memset(dp, -1, sizeof(dp));\n        cout << solve(0, 0, false, false, false, true, true, true) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static final int MOD = 1_000_000_007;\n    static char[] a, b, c;\n    static int[][][][][][] dp;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while (T-- > 0) {\n            a = sc.next().toCharArray();\n            b = sc.next().toCharArray();\n            c = sc.next().toCharArray();\n            int maxLen = Math.max(a.length, Math.max(b.length, c.length));\n            a = pad(a, maxLen).toCharArray();\n            b = pad(b, maxLen).toCharArray();\n            c = pad(c, maxLen).toCharArray();\n            dp = new int[maxLen + 1][2][10][10][10][2];\n            for (int[][][][][] arr5 : dp) {\n                for (int[][][][] arr4 : arr5) {\n                    for (int[][][] arr3 : arr4) {\n                        for (int[][] arr2 : arr3) {\n                            for (int[] arr1 : arr2) {\n                                Arrays.fill(arr1, -1);\n                            }\n                        }\n                    }\n                }\n            }\n            System.out.println(dfs(0, 0, 0, 0, 0, 0));\n        }\n        sc.close();\n    }\n\n    static String pad(char[] s, int len) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len - s.length; i++) {\n            sb.append('0');\n        }\n        sb.append(s);\n        return sb.toString();\n    }\n\n    static int dfs(int pos, int carry, int da, int db, int dc, int started) {\n        if (pos == a.length) {\n            return (carry == 0 && (started == 1 || a.length == 1)) ? 1 : 0;\n        }\n        if (dp[pos][carry][da][db][dc][started] != -1) {\n            return dp[pos][carry][da][db][dc][started];\n        }\n        long res = 0;\n        int startA = (pos >= a.length - a.length) ? 0 : 0;\n        int startB = (pos >= a.length - b.length) ? 0 : 0;\n        int startC = (pos >= a.length - c.length) ? 0 : 0;\n        char ca = (pos >= a.length - a.length) ? a[pos - (a.length - a.length)] : '0';\n        char cb = (pos >= a.length - b.length) ? b[pos - (a.length - b.length)] : '0';\n        char cc = (pos >= a.length - c.length) ? c[pos - (a.length - c.length)] : '0';\n        int maxA = (ca == '?') ? 9 : ca - '0';\n        int maxB = (cb == '?') ? 9 : cb - '0';\n        int maxC = (cc == '?') ? 9 : cc - '0';\n        for (int dA = (pos == a.length - a.length && a.length > 1) ? 1 : 0; dA <= maxA; dA++) {\n            if (ca != '?' && dA != ca - '0') continue;\n            for (int dB = (pos == a.length - b.length && b.length > 1) ? 1 : 0; dB <= maxB; dB++) {\n                if (cb != '?' && dB != cb - '0') continue;\n                for (int dC = (pos == a.length - c.length && c.length > 1) ? 1 : 0; dC <= maxC; dC++) {\n                    if (cc != '?' && dC != cc - '0') continue;\n                    int sum = dA + dB + carry;\n                    int newCarry = sum / 10;\n                    int digit = sum % 10;\n                    if (digit != dC) continue;\n                    int newStarted = started | (dA != 0 ? 1 : 0) | (dB != 0 ? 1 : 0) | (dC != 0 ? 1 : 0);\n                    res += dfs(pos + 1, newCarry, dA, dB, dC, newStarted);\n                    res %= MOD;\n                }\n            }\n        }\n        dp[pos][carry][da][db][dc][started] = (int) res;\n        return (int) res;\n    }\n}",
    "timestamp": "2025-08-05 21:47:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MOD = 1_000_000_007;\n\n    public static int countValidAssignments(String a, String b, String c) {\n        return solve(a, b, c);\n    }\n\n    private static int solve(String a, String b, String c) {\n        List<Integer> questionPositions = new ArrayList<>();\n        collectQuestionPositions(a, b, c, questionPositions);\n\n        return backtrack(a, b, c, questionPositions, 0);\n    }\n\n    private static void collectQuestionPositions(String a, String b, String c, List<Integer> positions) {\n        collectPositionsInString(a, positions);\n        collectPositionsInString(b, positions);\n        collectPositionsInString(c, positions);\n    }\n\n    private static void collectPositionsInString(String s, List<Integer> positions) {\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '?') {\n                positions.add(i);\n            }\n        }\n    }\n\n    private static int backtrack(String a, String b, String c, List<Integer> positions, int index) {\n        if (index == positions.size()) {\n            return isValidEquation(a, b, c) ? 1 : 0;\n        }\n\n        int total = 0;\n        int pos = positions.get(index);\n        String[] strings = {a, b, c};\n\n        for (int digit = 0; digit <= 9; digit++) {\n            for (int i = 0; i < strings.length; i++) {\n                if (isValidReplacement(strings[i], pos, digit)) {\n                    String newStr = replaceCharAt(strings[i], pos, (char)(digit + '0'));\n                    strings[i] = newStr;\n                }\n            }\n\n            total = (total + backtrack(strings[0], strings[1], strings[2], positions, index + 1)) % MOD;\n\n            for (int i = 0; i < strings.length; i++) {\n                if (isValidReplacement(strings[i], pos, digit)) {\n                    strings[i] = replaceCharAt(strings[i], pos, '?');\n                }\n            }\n        }\n\n        return total;\n    }\n\n    private static boolean isValidReplacement(String s, int pos, int digit) {\n        return s.charAt(pos) == '?' || s.charAt(pos) - '0' == digit;\n    }\n\n    private static String replaceCharAt(String s, int pos, char ch) {\n        char[] chars = s.toCharArray();\n        chars[pos] = ch;\n        return new String(chars);\n    }\n\n    private static boolean isValidEquation(String a, String b, String c) {\n        if (!isValidNumber(a) || !isValidNumber(b) || !isValidNumber(c)) {\n            return false;\n        }\n\n        long aNum = Long.parseLong(a);\n        long bNum = Long.parseLong(b);\n        long cNum = Long.parseLong(c);\n\n        return aNum + bNum == cNum;\n    }\n\n    private static boolean isValidNumber(String num) {\n        if (num.length() > 1 && num.charAt(0) == '0') {\n            return false;\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 21:48:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1000000007;\n\nint countWays(string a, string b, string c) {\n    int n = a.length(), m = b.length(), p = c.length();\n    vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(m + 1, vector<int>(p + 1, 0)));\n    dp[0][0][0] = 1;\n\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= m; j++) {\n            for (int k = 0; k <= p; k++) {\n                if (dp[i][j][k] == 0) continue;\n\n                int carry = 0;\n                if (i < n && a[n-1-i] == '?') {\n                    for (int x = 0; x <= 9; x++) {\n                        if (i > 0 || x > 0 || (n == 1 && x == 0)) {\n                            int sum = carry;\n                            if (j < m && b[m-1-j] == '?') {\n                                for (int y = 0; y <= 9; y++) {\n                                    if (j > 0 || y > 0 || (m == 1 && y == 0)) {\n                                        sum = x + y + carry;\n                                        if (k < p && c[p-1-k] == '?') {\n                                            for (int z = 0; z <= 9; z++) {\n                                                if (k > 0 || z > 0 || (p == 1 && z == 0)) {\n                                                    if (sum % 10 == z) {\n                                                        dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                                    }\n                                                }\n                                            }\n                                        } else if (k < p && c[p-1-k] - '0' == sum % 10) {\n                                            dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                        }\n                                    }\n                                }\n                            } else if (j < m && b[m-1-j] - '0' == (sum % 10)) {\n                                if (k < p && c[p-1-k] == '?') {\n                                    for (int z = 0; z <= 9; z++) {\n                                        if (k > 0 || z > 0 || (p == 1 && z == 0)) {\n                                            if (sum % 10 == z) {\n                                                dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                            }\n                                        }\n                                    }\n                                } else if (k < p && c[p-1-k] - '0' == sum % 10) {\n                                    dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                }\n                            }\n                        }\n                    }\n                } else if (i < n && a[n-1-i] - '0' == carry) {\n                    if (j < m && b[m-1-j] == '?') {\n                        for (int y = 0; y <= 9; y++) {\n                            if (j > 0 || y > 0 || (m == 1 && y == 0)) {\n                                int sum = a[n-1-i] - '0' + y + carry;\n                                if (k < p && c[p-1-k] == '?') {\n                                    for (int z = 0; z <= 9; z++) {\n                                        if (k > 0 || z > 0 || (p == 1 && z == 0)) {\n                                            if (sum % 10 == z) {\n                                                dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                            }\n                                        }\n                                    }\n                                } else if (k < p && c[p-1-k] - '0' == sum % 10) {\n                                    dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                }\n                            }\n                        }\n                    } else if (j < m && b[m-1-j] - '0' == (a[n-1-i] - '0' + carry) % 10) {\n                        if (k < p && c[p-1-k] == '?') {\n                            for (int z = 0; z <= 9; z++) {\n                                if (k > 0 || z > 0 || (p == 1 && z == 0)) {\n                                    int sum = a[n-1-i] - '0' + b[m-1-j] - '0' + carry;\n                                    if (sum % 10 == z) {\n                                        dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                                    }\n                                }\n                            }\n                        } else if (k < p && c[p-1-k] - '0' == (a[n-1-i] - '0' + b[m-1-j] - '0' + carry) % 10) {\n                            dp[i+1][j+1][k+1] = (dp[i+1][j+1][k+1] + dp[i][j][k]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return dp[n][m][p];\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        string A, B, C;\n        cin >> A >> B >> C;\n        cout << countWays(A, B, C) << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 1000000007\n\ndef count_possible_assignments(A, B, C):\n    # Convert strings to list for mutability\n    A_lst, B_lst, C_lst = list(A), list(B), list(C)\n    \n    def backtrack(pos, carry):\n        if pos == len(C_lst):\n            return 1 if carry == 0 else 0\n        \n        a_pos = pos if pos < len(A_lst) else 0\n        b_pos = pos if pos < len(B_lst) else 0\n        \n        count = 0\n        \n        # Possible digits for A, B, C\n        a_choices = [A_lst[a_pos]] if a_pos < len(A_lst) and A_lst[a_pos] != '?' else map(str, range(10))\n        b_choices = [B_lst[b_pos]] if b_pos < len(B_lst) and B_lst[b_pos] != '?' else map(str, range(10))\n        c_choices = [C_lst[pos]] if C_lst[pos] != '?' else map(str, range(10))\n        \n        for a in a_choices:\n            for b in b_choices:\n                for c in c_choices:\n                    if (0 if len(A_lst) > 1 and a_pos == 0 and a == '0' else True) and \\\n                       (0 if len(B_lst) > 1 and b_pos == 0 and b == '0' else True) and \\\n                       (0 if len(C_lst) > 1 and pos == 0 and c == '0' else True):\n                        \n                        if (int(a) + int(b) + carry) % 10 == int(c):\n                            count += backtrack(pos + 1, (int(a) + int(b) + carry) // 10)\n                            count %= MOD\n        \n        return count\n\n    return backtrack(0, 0)\n\n# Example usage:\ndatasets = [(\"1?\", \"?1\", \"2?\"), (\"12\", \"34\", \"4?\")]\nresults = [count_possible_assignments(A, B, C) for A, B, C in datasets]\n\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 07:25:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class EquationSolver {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            String a = sc.next();\n            String b = sc.next();\n            String c = sc.next();\n            System.out.println(countPossibleAssignments(a, b, c));\n        }\n        sc.close();\n    }\n\n    private static int countPossibleAssignments(String a, String b, String c) {\n        return countHelper(a, b, c, 0, 0, 0, 0);\n    }\n\n    private static int countHelper(String a, String b, String c, int index, int carry, int sumA, int sumB) {\n        if (index == a.length() && index == b.length() && index == c.length()) {\n            return carry == 0 ? 1 : 0;\n        }\n\n        int result = 0;\n        int ai = (index < a.length() && a.charAt(a.length() - 1 - index) != '?')\n                ? a.charAt(a.length() - 1 - index) - '0'\n                : -1;\n        int bi = (index < b.length() && b.charAt(b.length() - 1 - index) != '?')\n                ? b.charAt(b.length() - 1 - index) - '0'\n                : -1;\n        int ci = (index < c.length() && c.charAt(c.length() - 1 - index) != '?')\n                ? c.charAt(c.length() - 1 - index) - '0'\n                : -1;\n\n        for (int da = 0; da <= 9; da++) {\n            if (ai != -1 && ai != da) continue;\n\n            for (int db = 0; db <= 9; db++) {\n                if (bi != -1 && bi != db) continue;\n\n                int total = da + db + carry;\n                int dc = total % 10;\n                int newCarry = total / 10;\n\n                if (ci != -1 && ci != dc) continue;\n\n                if (index == Math.max(a.length(), Math.max(b.length(), c.length())) - 1) {\n                    if ((index == a.length() - 1 && da == 0) || (index == b.length() - 1 && db == 0)\n                            || (index == c.length() - 1 && dc == 0)) {\n                        continue;\n                    }\n                }\n\n                result = (result + countHelper(a, b, c, index + 1, newCarry, sumA, sumB)) % MOD;\n            }\n        }\n\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 07:26:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint countWays(char *a, char *b, char *c, int posA, int posB, int posC, int carry) {\n    if (posA < 0 && posB < 0 && posC < 0) {\n        return carry == 0 ? 1 : 0;\n    }\n\n    int result = 0;\n    int maxDigitA = posA >= 0 ? (a[posA] == '?' ? 9 : a[posA] - '0') : 0;\n    int maxDigitB = posB >= 0 ? (b[posB] == '?' ? 9 : b[posB] - '0') : 0;\n    int maxDigitC = posC >= 0 ? (c[posC] == '?' ? 9 : c[posC] - '0') : 0;\n    \n    for (int digitA = (posA >= 0 && a[posA] == '?' ? (posA == 0 ? 1 : 0) : maxDigitA); digitA <= maxDigitA; digitA++) {\n        for (int digitB = (posB >= 0 && b[posB] == '?' ? (posB == 0 ? 1 : 0) : maxDigitB); digitB <= maxDigitB; digitB++) {\n            int sumAB = digitA + digitB + carry;\n            int digitC = sumAB % 10;\n            if ((posC >= 0 && c[posC] != '?' && digitC != maxDigitC) || (posC >= 0 && c[posC] == '?' && digitC < (posC == 0 ? 1 : 0))) {\n                continue;\n            }\n            result = (result + countWays(a, b, c, posA - 1, posB - 1, posC - 1, sumAB / 10)) % MOD;\n        }\n    }\n    return result;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    while (datasets--) {\n        char A[201], B[201], C[201];\n        scanf(\"%s %s %s\", A, B, C);\n\n        int lenA = strlen(A);\n        int lenB = strlen(B);\n        int lenC = strlen(C);\n\n        printf(\"%d\\n\", countWays(A, B, C, lenA - 1, lenB - 1, lenC - 1, 0));\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 07:26:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(A, B, C):\n    def is_valid_number(num):\n        return len(str(num)) == len(str(A)) and len(str(num)) > 1 and str(num)[0] != '0'\n\n    def count_possibilities(a, b, c, a_idx, b_idx, c_idx):\n        if a_idx == len(a):\n            return 1 if int(a) + int(b) == int(c) else 0\n\n        total = 0\n        start = 0 if a_idx > 0 or len(a) == 1 else 1\n        \n        for digit in range(start, 10):\n            if a[a_idx] == '?':\n                new_a = a[:a_idx] + str(digit) + a[a_idx+1:]\n            else:\n                if int(a[a_idx]) != digit:\n                    continue\n                new_a = a\n\n            if b[b_idx] == '?':\n                for b_digit in range(start if b_idx > 0 or len(b) == 1 else 1, 10):\n                    if c[c_idx] == '?':\n                        expected_c_digit = (digit + b_digit) % 10\n                        if c_idx == 0 and expected_c_digit == 0 and len(c) > 1:\n                            continue\n                        new_c = c[:c_idx] + str(expected_c_digit) + c[c_idx+1:]\n                        carry = 1 if digit + b_digit >= 10 else 0\n                        if c_idx > 0:\n                            if new_c[c_idx-1] == '?':\n                                total += count_possibilities(new_a, \n                                                            new_a.replace('?', str(b_digit)), \n                                                            new_c, \n                                                            a_idx+1, \n                                                            b_idx+1, \n                                                            c_idx-1)\n                            elif int(new_c[c_idx-1]) == carry:\n                                total += count_possibilities(new_a, \n                                                            new_a.replace('?', str(b_digit)), \n                                                            new_c, \n                                                            a_idx+1, \n                                                            b_idx+1, \n                                                            c_idx-1)\n                        else:\n                            if carry == 0:\n                                total += count_possibilities(new_a, \n                                                            new_a.replace('?', str(b_digit)), \n                                                            new_c, \n                                                            a_idx+1, \n                                                            b_idx+1, \n                                                            c_idx)\n                    else:\n                        if (digit + b_digit + (1 if int(c[c_idx-1]) == 1 else 0)) % 10 == int(c[c_idx]):\n                            new_c = c\n                            carry = 1 if digit + b_digit >= 10 else 0\n                            if c_idx > 0 and new_c[c_idx-1] == '?':\n                                total += count_possibilities(new_a, \n                                                            new_a.replace('?', str(b_digit)), \n                                                            new_c, \n                                                            a_idx+1, \n                                                            b_idx+1, \n                                                            c_idx-1)\n                            elif c_idx > 0 and int(new_c[c_idx-1]) == carry:\n                                total += count_possibilities(new_a, \n                                                            new_a.replace('?', str(b_digit)), \n                                                            new_c, \n                                                            a_idx+1, \n                                                            b_idx+1, \n                                                            c_idx-1)\n                            elif c_idx == 0 and carry == 0:\n                                total += count_possibilities(new_a, \n                                                            new_a.replace('?', str(b_digit)), \n                                                            new_c, \n                                                            a_idx+1, \n                                                            b_idx+1, \n                                                            c_idx)\n            else:\n                if b[b_idx] != str(digit):\n                    continue\n                if c[c_idx] == '?':\n                    expected_c_digit = (digit + int(b[b_idx])) % 10\n                    if c_idx == 0 and expected_c_digit == 0 and len(c) > 1:\n                        continue\n                    new_c = c[:c_idx] + str(expected_c_digit) + c[c_idx+1:]\n                    carry = 1 if digit + int(b[b_idx]) >= 10 else 0\n                    if c_idx > 0:\n                        if new_c[c_idx-1] == '?':\n                            total += count_possibilities(new_a, \n                                                        b, \n                                                        new_c, \n                                                        a_idx+1, \n                                                        b_idx+1, \n                                                        c_idx-1)\n                        elif int(new_c[c_idx-1]) == carry:\n                            total += count_possibilities(new_a, \n                                                        b, \n                                                        new_c, \n                                                        a_idx+1, \n                                                        b_idx+1, \n                                                        c_idx-1)\n                    else:\n                        if carry == 0:\n                            total += count_possibilities(new_a, \n                                                        b, \n                                                        new_c, \n                                                        a_idx+1, \n                                                        b_idx+1, \n                                                        c_idx)\n                else:\n                    if (digit + int(b[b_idx]) + (1 if int(c[c_idx-1]) == 1 else 0)) % 10 == int(c[c_idx]):\n                        new_c = c\n                        carry = 1 if digit + int(b[b_idx]) >= 10 else 0\n                        if c_idx > 0 and new_c[c_idx-1] == '?':\n                            total += count_possibilities(new_a, \n                                                        b, \n                                                        new_c, \n                                                        a_idx+1, \n                                                        b_idx+1, \n                                                        c_idx-1)\n                        elif c_idx > 0 and int(new_c[c_idx-1]) == carry:\n                            total += count_possibilities(new_a, \n                                                        b, \n                                                        new_c, \n                                                        a_idx+1, \n                                                        b_idx+1, \n                                                        c_idx-1)\n                        elif c_idx == 0 and carry == 0:\n                            total += count_possibilities(new_a, \n                                                        b, \n                                                        new_c, \n                                                        a_idx+1, \n                                                        b_idx+1, \n                                                        c_idx)\n\n        return total % 1000000007\n\n    return count_possibilities(A, B, C, 0, 0, len(C)-1)",
    "timestamp": "2025-08-13 07:26:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nMOD = 10**9 + 7\n\ndef solve():\n    input = sys.stdin.read().split()\n    idx = 0\n    T = int(input[idx])\n    idx += 1\n    for _ in range(T):\n        A = input[idx]\n        idx += 1\n        B = input[idx]\n        idx += 1\n        C = input[idx]\n        idx += 1\n        \n        max_len = max(len(A), len(B), len(C))\n        A = A.zfill(max_len)\n        B = B.zfill(max_len)\n        C = C.zfill(max_len)\n        \n        n = max_len\n        dp = [[0]*2 for _ in range(n+1)]\n        dp[n][0] = 1\n        \n        for i in range(n-1, -1, -1):\n            for carry in range(2):\n                if dp[i+1][carry] == 0:\n                    continue\n                a_digits = []\n                b_digits = []\n                c_digits = []\n                if A[i] == '?':\n                    a_digits = list(range(10))\n                else:\n                    a_digits = [int(A[i])]\n                if B[i] == '?':\n                    b_digits = list(range(10))\n                else:\n                    b_digits = [int(B[i])]\n                if C[i] == '?':\n                    c_digits = list(range(10))\n                else:\n                    c_digits = [int(C[i])]\n                \n                for a in a_digits:\n                    if i == 0 and len(A) > 1 and a == 0:\n                        continue\n                    for b in b_digits:\n                        if i == 0 and len(B) > 1 and b == 0:\n                            continue\n                        s = a + b + carry\n                        new_carry = s // 10\n                        c = s % 10\n                        for possible_c in c_digits:\n                            if possible_c == c:\n                                dp[i][new_carry] = (dp[i][new_carry] + dp[i+1][carry]) % MOD\n        total = (dp[0][0]) % MOD\n        print(total)\n\nsolve()",
    "timestamp": "2025-08-13 07:27:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n\nconst int MOD = 1000000007;\n\nbool validNumber(const std::string& num) {\n    return num[0] != '0' || num.size() == 1;\n}\n\nint countWays(const std::string& A, const std::string& B, const std::string& C, int posA, int posB, int posC, int carry, std::vector<std::vector<std::vector<std::vector<int>>>>& dp) {\n    if (posC == C.size()) {\n        return carry == 0 ? 1 : 0;\n    }\n\n    if (dp[posA][posB][posC][carry] != -1) {\n        return dp[posA][posB][posC][carry];\n    }\n\n    int ways = 0;\n\n    for (int digitA = 0; digitA <= 9; digitA++) {\n        if (A[posA] != '?' && A[posA] - '0' != digitA) continue;\n        if (posA == 0 && A.size() > 1 && digitA == 0) continue;\n\n        for (int digitB = 0; digitB <= 9; digitB++) {\n            if (B[posB] != '?' && B[posB] - '0' != digitB) continue;\n            if (posB == 0 && B.size() > 1 && digitB == 0) continue;\n\n            int sum = digitA + digitB + carry;\n            int digitC = sum % 10;\n            int newCarry = sum / 10;\n\n            if (C[posC] != '?' && C[posC] - '0' != digitC) continue;\n            if (posC == 0 && C.size() > 1 && digitC == 0) continue;\n\n            int nextWays = countWays(A, B, C, posA + 1, posB + 1, posC + 1, newCarry, dp);\n            ways = (ways + nextWays) % MOD;\n        }\n    }\n\n    return dp[posA][posB][posC][carry] = ways;\n}\n\nint main() {\n    int T; \n    std::cin >> T;\n    \n    while (T--) {\n        std::string A, B, C;\n        std::cin >> A >> B >> C;\n\n        int n = A.length(), m = B.length(), k = C.length();\n        if (std::max(n, m) > k + 1) {\n            std::cout << \"0\\n\";\n            continue;\n        }\n\n        std::vector<std::vector<std::vector<std::vector<int>>>> dp(n + 1, std::vector<std::vector<std::vector<int>>>(m + 1, std::vector<std::vector<int>>(k + 1, std::vector<int>(2, -1))));\n\n        std::cout << countWays(A, B, C, 0, 0, 0, 0, dp) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:38:34"
  }
]