[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int key;\n    struct Node* left;\n    struct Node* right;\n} Node;\n\nNode* createNode(int key) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nNode* insert(Node* root, int key) {\n    if (root == NULL) {\n        return createNode(key);\n    }\n\n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n\n    return root;\n}\n\nvoid inorderTraversal(Node* root) {\n    if (root != NULL) {\n        inorderTraversal(root->left);\n        printf(\"%d \", root->key);\n        inorderTraversal(root->right);\n    }\n}\n\nvoid preorderTraversal(Node* root) {\n    if (root != NULL) {\n        printf(\"%d \", root->key);\n        preorderTraversal(root->left);\n        preorderTraversal(root->right);\n    }\n}\n\nint main() {\n    Node* root = NULL;\n    int n, key;\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &key);\n        root = insert(root, key);\n    }\n\n    printf(\"Inorder traversal: \");\n    inorderTraversal(root);\n    printf(\"\\n\");\n\n    printf(\"Preorder traversal: \");\n    preorderTraversal(root);\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:12:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    int key;\n    struct Node *left;\n    struct Node *right;\n} Node;\n\nNode* createNode(int key) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->key = key;\n    newNode->left = NULL;\n    newNode->right = NULL;\n    return newNode;\n}\n\nNode* insert(Node* root, int key) {\n    if (root == NULL) {\n        return createNode(key);\n    }\n    if (key < root->key) {\n        root->left = insert(root->left, key);\n    } else if (key > root->key) {\n        root->right = insert(root->right, key);\n    }\n    return root;\n}\n\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->key);\n        inorder(root->right);\n    }\n}\n\nvoid preorder(Node* root) {\n    if (root != NULL) {\n        printf(\"%d \", root->key);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\n\nint main() {\n    Node* root = NULL;\n    int n, key;\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &key);\n        root = insert(root, key);\n    }\n\n    inorder(root);\n    printf(\"\\n\");\n    preorder(root);\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:25"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int key;\n    Node* left;\n    Node* right;\n    Node(int k) : key(k), left(nullptr), right(nullptr) {}\n};\n\nclass BST {\nprivate:\n    Node* root;\n\n    Node* insert(Node* node, int key) {\n        if (node == nullptr) {\n            return new Node(key);\n        }\n        if (key < node->key) {\n            node->left = insert(node->left, key);\n        } else if (key > node->key) {\n            node->right = insert(node->right, key);\n        }\n        return node;\n    }\n\n    void inorder(Node* node) {\n        if (node != nullptr) {\n            inorder(node->left);\n            cout << node->key << \" \";\n            inorder(node->right);\n        }\n    }\n\n    void preorder(Node* node) {\n        if (node != nullptr) {\n            cout << node->key << \" \";\n            preorder(node->left);\n            preorder(node->right);\n        }\n    }\n\npublic:\n    BST() : root(nullptr) {}\n\n    void insert(int key) {\n        root = insert(root, key);\n    }\n\n    void inorder() {\n        inorder(root);\n        cout << endl;\n    }\n\n    void preorder() {\n        preorder(root);\n        cout << endl;\n    }\n};\n\nint main() {\n    BST tree;\n    int n, key;\n    cin >> n;\n    for (int i = 0; i < n; ++i) {\n        cin >> key;\n        tree.insert(key);\n    }\n    tree.inorder();\n    tree.preorder();\n    return 0;\n}",
    "timestamp": "2025-08-05 22:13:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class Node {\n    int key;\n    Node left, right;\n\n    public Node(int item) {\n        key = item;\n        left = right = null;\n    }\n}\n\nclass BST {\n    Node root;\n\n    BST() {\n        root = null;\n    }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n\n        if (key < root.key) {\n            root.left = insertRec(root.left, key);\n        } else if (key > root.key) {\n            root.right = insertRec(root.right, key);\n        }\n\n        return root;\n    }\n\n    void inorder() {\n        inorderRec(root);\n    }\n\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    void preorder() {\n        preorderRec(root);\n    }\n\n    void preorderRec(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preorderRec(root.left);\n            preorderRec(root.right);\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        BST tree = new BST();\n\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        System.out.println(\"Inorder traversal:\");\n        tree.inorder();\n        System.out.println(\"\\nPreorder traversal:\");\n        tree.preorder();\n    }\n}",
    "timestamp": "2025-08-05 22:14:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "class BinarySearchTree {\n    class Node {\n        int key;\n        Node left, right;\n\n        public Node(int item) {\n            key = item;\n            left = right = null;\n        }\n    }\n\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n\n        if (key < root.key)\n            root.left = insertRec(root.left, key);\n        else if (key > root.key)\n            root.right = insertRec(root.right, key);\n\n        return root;\n    }\n\n    void inorderTraversal() {\n        inorderRec(root);\n    }\n\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    void preorderTraversal() {\n        preorderRec(root);\n    }\n\n    void preorderRec(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preorderRec(root.left);\n            preorderRec(root.right);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:14:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nclass TreeNode {\npublic:\n    int key;\n    TreeNode* left;\n    TreeNode* right;\n\n    TreeNode(int value) {\n        key = value;\n        left = nullptr;\n        right = nullptr;\n    }\n};\n\nclass BST {\nprivate:\n    TreeNode* root;\n\n    TreeNode* insertRecursive(TreeNode* node, int key) {\n        if (node == nullptr) {\n            return new TreeNode(key);\n        }\n\n        if (key < node->key) {\n            node->left = insertRecursive(node->left, key);\n        } else if (key > node->key) {\n            node->right = insertRecursive(node->right, key);\n        }\n\n        return node;\n    }\n\n    void inorderTraversalRecursive(TreeNode* node) {\n        if (node == nullptr) return;\n        \n        inorderTraversalRecursive(node->left);\n        cout << node->key << \" \";\n        inorderTraversalRecursive(node->right);\n    }\n\n    void preorderTraversalRecursive(TreeNode* node) {\n        if (node == nullptr) return;\n        \n        cout << node->key << \" \";\n        preorderTraversalRecursive(node->left);\n        preorderTraversalRecursive(node->right);\n    }\n\npublic:\n    BST() {\n        root = nullptr;\n    }\n\n    void insert(int key) {\n        root = insertRecursive(root, key);\n    }\n\n    void inorderTraversal() {\n        inorderTraversalRecursive(root);\n        cout << endl;\n    }\n\n    void preorderTraversal() {\n        preorderTraversalRecursive(root);\n        cout << endl;\n    }\n};\n\nint main() {\n    BST bst;\n    int n, key;\n    \n    cin >> n;\n    for (int i = 0; i < n; i++) {\n        cin >> key;\n        bst.insert(key);\n    }\n\n    bst.inorderTraversal();\n    bst.preorderTraversal();\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = Node(key)\n        else:\n            self._insert(self.root, key)\n\n    def _insert(self, root, key):\n        if key < root.val:\n            if root.left is None:\n                root.left = Node(key)\n            else:\n                self._insert(root.left, key)\n        else:\n            if root.right is None:\n                root.right = Node(key)\n            else:\n                self._insert(root.right, key)\n\n    def inorder(self):\n        self._inorder(self.root)\n        print()\n\n    def _inorder(self, root):\n        if root:\n            self._inorder(root.left)\n            print(root.val, end=' ')\n            self._inorder(root.right)\n\n    def preorder(self):\n        self._preorder(self.root)\n        print()\n\n    def _preorder(self, root):\n        if root:\n            print(root.val, end=' ')\n            self._preorder(root.left)\n            self._preorder(root.right)\n\n# Example usage\n# bst = BST()\n# bst.insert(5)\n# bst.insert(3)\n# bst.insert(7)\n# bst.inorder()    # Output: 3 5 7\n# bst.preorder()   # Output: 5 3 7",
    "timestamp": "2025-08-13 09:31:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "class BinarySearchTree {\n\n    class Node {\n        int key;\n        Node left, right;\n\n        public Node(int item) {\n            key = item;\n            left = right = null;\n        }\n    }\n\n    Node root;\n\n    BinarySearchTree() {\n        root = null;\n    }\n\n    void insert(int key) {\n        root = insertRec(root, key);\n    }\n\n    Node insertRec(Node root, int key) {\n        if (root == null) {\n            root = new Node(key);\n            return root;\n        }\n        if (key < root.key)\n            root.left = insertRec(root.left, key);\n        else if (key > root.key)\n            root.right = insertRec(root.right, key);\n        return root;\n    }\n\n    void inorder() {\n        inorderRec(root);\n    }\n\n    void inorderRec(Node root) {\n        if (root != null) {\n            inorderRec(root.left);\n            System.out.print(root.key + \" \");\n            inorderRec(root.right);\n        }\n    }\n\n    void preorder() {\n        preorderRec(root);\n    }\n\n    void preorderRec(Node root) {\n        if (root != null) {\n            System.out.print(root.key + \" \");\n            preorderRec(root.left);\n            preorderRec(root.right);\n        }\n    }\n\n    public static void main(String[] args) {\n        BinarySearchTree tree = new BinarySearchTree();\n\n        tree.insert(50);\n        tree.insert(30);\n        tree.insert(20);\n        tree.insert(40);\n        tree.insert(70);\n        tree.insert(60);\n        tree.insert(80);\n\n        System.out.println(\"Inorder traversal:\");\n        tree.inorder();\n\n        System.out.println(\"\\nPreorder traversal:\");\n        tree.preorder();\n    }\n}",
    "timestamp": "2025-08-13 09:31:48"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n// Define the structure for a tree node\ntypedef struct Node {\n    int key;\n    struct Node *left, *right;\n} Node;\n\n// Function to create a new BST node\nNode* newNode(int item) {\n    Node* temp = (Node*)malloc(sizeof(Node));\n    temp->key = item;\n    temp->left = temp->right = NULL;\n    return temp;\n}\n\n// Function to insert a new key in the BST\nNode* insert(Node* node, int key) {\n    // If the tree is empty, return a new node\n    if (node == NULL) return newNode(key);\n\n    // Otherwise, recur down the tree\n    if (key < node->key)\n        node->left = insert(node->left, key);\n    else if (key > node->key)\n        node->right = insert(node->right, key);\n\n    // return the (unchanged) node pointer\n    return node;\n}\n\n// Function to do inorder tree traversal\nvoid inorder(Node* root) {\n    if (root != NULL) {\n        inorder(root->left);\n        printf(\"%d \", root->key);\n        inorder(root->right);\n    }\n}\n\n// Function to do preorder tree traversal\nvoid preorder(Node* root) {\n    if (root != NULL) {\n        printf(\"%d \", root->key);\n        preorder(root->left);\n        preorder(root->right);\n    }\n}\n\n// Main function to test the BST operations\nint main() {\n    Node* root = NULL;\n\n    // Insert keys\n    root = insert(root, 50);\n    insert(root, 30);\n    insert(root, 20);\n    insert(root, 40);\n    insert(root, 70);\n    insert(root, 60);\n    insert(root, 80);\n\n    // Print inorder traversal of the BST\n    printf(\"Inorder traversal: \");\n    inorder(root);\n    printf(\"\\n\");\n\n    // Print preorder traversal of the BST\n    printf(\"Preorder traversal: \");\n    preorder(root);\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:31:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Node:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        self.root = self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if node is None:\n            return Node(key)\n\n        if key < node.key:\n            node.left = self._insert_recursive(node.left, key)\n        else:\n            node.right = self._insert_recursive(node.right, key)\n\n        return node\n\n    def inorder_traversal(self):\n        self._inorder_recursive(self.root)\n        print()\n\n    def _inorder_recursive(self, node):\n        if node:\n            self._inorder_recursive(node.left)\n            print(node.key, end=\" \")\n            self._inorder_recursive(node.right)\n\n    def preorder_traversal(self):\n        self._preorder_recursive(self.root)\n        print()\n\n    def _preorder_recursive(self, node):\n        if node:\n            print(node.key, end=\" \")\n            self._preorder_recursive(node.left)\n            self._preorder_recursive(node.right)",
    "timestamp": "2025-08-13 09:32:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BST:\n    def __init__(self):\n        self.root = None\n\n    def insert(self, key):\n        if self.root is None:\n            self.root = TreeNode(key)\n        else:\n            self._insert_recursive(self.root, key)\n\n    def _insert_recursive(self, node, key):\n        if key < node.key:\n            if node.left is None:\n                node.left = TreeNode(key)\n            else:\n                self._insert_recursive(node.left, key)\n        else:\n            if node.right is None:\n                node.right = TreeNode(key)\n            else:\n                self._insert_recursive(node.right, key)\n\n    def inorder(self):\n        self._inorder_recursive(self.root)\n        print()\n\n    def _inorder_recursive(self, node):\n        if node:\n            self._inorder_recursive(node.left)\n            print(node.key, end=' ')\n            self._inorder_recursive(node.right)\n\n    def preorder(self):\n        self._preorder_recursive(self.root)\n        print()\n\n    def _preorder_recursive(self, node):\n        if node:\n            print(node.key, end=' ')\n            self._preorder_recursive(node.left)\n            self._preorder_recursive(node.right)",
    "timestamp": "2025-08-13 09:32:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n\nstruct TreeNode {\n    int key;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode(int value) : key(value), left(nullptr), right(nullptr) {}\n};\n\nclass BinarySearchTree {\nprivate:\n    TreeNode* root;\n\n    TreeNode* insert(TreeNode* node, int key) {\n        if (node == nullptr) {\n            return new TreeNode(key);\n        }\n        if (key < node->key) {\n            node->left = insert(node->left, key);\n        } else if (key > node->key) {\n            node->right = insert(node->right, key);\n        }\n        return node;\n    }\n\n    void inorder(TreeNode* node) {\n        if (node != nullptr) {\n            inorder(node->left);\n            std::cout << node->key << \" \";\n            inorder(node->right);\n        }\n    }\n\n    void preorder(TreeNode* node) {\n        if (node != nullptr) {\n            std::cout << node->key << \" \";\n            preorder(node->left);\n            preorder(node->right);\n        }\n    }\n\npublic:\n    BinarySearchTree() : root(nullptr) {}\n\n    void insert(int key) {\n        root = insert(root, key);\n    }\n\n    void printInorder() {\n        inorder(root);\n        std::cout << std::endl;\n    }\n\n    void printPreorder() {\n        preorder(root);\n        std::cout << std::endl;\n    }\n};\n\nint main() {\n    BinarySearchTree bst;\n    bst.insert(10);\n    bst.insert(5);\n    bst.insert(20);\n    bst.insert(3);\n    bst.insert(7);\n\n    std::cout << \"Inorder: \";\n    bst.printInorder();\n\n    std::cout << \"Preorder: \";\n    bst.printPreorder();\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:52:23"
  }
]