[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_WORDS 100\n#define MAX_WORD_LEN 100\n\nvoid solve(char words[][MAX_WORD_LEN], int n) {\n    bool used[MAX_WORDS] = {false};\n    bool last_chars[26] = {false};\n\n    for (int start = 0; start < n; start++) {\n        bool found_path = false;\n        for (int i = 0; i < n; i++) {\n            if (!used[i] && words[i][0] == words[start][strlen(words[start])-1]) {\n                found_path = true;\n                break;\n            }\n        }\n\n        if (!found_path) {\n            last_chars[words[start][strlen(words[start])-1] - 'a'] = true;\n        }\n\n        used[start] = true;\n        char last_char = words[start][strlen(words[start])-1];\n\n        while (1) {\n            bool found = false;\n            for (int i = 0; i < n; i++) {\n                if (!used[i] && words[i][0] == last_char) {\n                    used[i] = true;\n                    last_char = words[i][strlen(words[i])-1];\n                    found = true;\n                    break;\n                }\n            }\n\n            if (!found) {\n                last_chars[last_char - 'a'] = true;\n                break;\n            }\n        }\n\n        memset(used, false, sizeof(used));\n    }\n\n    for (int i = 0; i < 26; i++) {\n        if (last_chars[i]) {\n            printf(\"%c \", i + 'a');\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    char words[MAX_WORDS][MAX_WORD_LEN];\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", words[i]);\n    }\n\n    solve(words, n);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define MAX_LEN 20\n\nint n;\nchar words[MAX_N][MAX_LEN];\nbool used[MAX_N];\nchar result[26];\nint result_count = 0;\n\nvoid dfs(char last_char) {\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n        if (!used[i] && words[i][0] == last_char) {\n            found = true;\n            used[i] = true;\n            int len = strlen(words[i]);\n            dfs(words[i][len - 1]);\n            used[i] = false;\n        }\n    }\n    if (!found) {\n        bool exists = false;\n        for (int i = 0; i < result_count; i++) {\n            if (result[i] == last_char) {\n                exists = true;\n                break;\n            }\n        }\n        if (!exists) {\n            result[result_count++] = last_char;\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", words[i]);\n    }\n\n    for (int i = 0; i < n; i++) {\n        used[i] = true;\n        int len = strlen(words[i]);\n        dfs(words[i][len - 1]);\n        used[i] = false;\n    }\n\n    // Sort the result\n    for (int i = 0; i < result_count; i++) {\n        for (int j = i + 1; j < result_count; j++) {\n            if (result[i] > result[j]) {\n                char temp = result[i];\n                result[i] = result[j];\n                result[j] = temp;\n            }\n        }\n    }\n\n    for (int i = 0; i < result_count; i++) {\n        printf(\"%c \", result[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <unordered_map>\n#include <set>\n\nusing namespace std;\n\nvoid dfs(const string& current, unordered_map<char, vector<string>>& graph, set<char>& result, vector<bool>& used, const vector<string>& words) {\n    char last_char = current.back();\n    if (graph.find(last_char) == graph.end()) {\n        result.insert(last_char);\n        return;\n    }\n    \n    for (const string& word : graph[last_char]) {\n        int index = find(words.begin(), words.end(), word) - words.begin();\n        if (!used[index]) {\n            used[index] = true;\n            dfs(word, graph, result, used, words);\n            used[index] = false;\n        }\n    }\n    \n    if (graph[last_char].empty()) {\n        result.insert(last_char);\n    }\n}\n\nvector<char> solve(const vector<string>& words) {\n    unordered_map<char, vector<string>> graph;\n    for (const string& word : words) {\n        if (!word.empty()) {\n            char first_char = word[0];\n            graph[first_char].push_back(word);\n        }\n    }\n    \n    set<char> result;\n    vector<bool> used(words.size(), false);\n    \n    for (int i = 0; i < words.size(); ++i) {\n        used[i] = true;\n        dfs(words[i], graph, result, used, words);\n        used[i] = false;\n    }\n    \n    return vector<char>(result.begin(), result.end());\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> words(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> words[i];\n    }\n    \n    vector<char> res = solve(words);\n    for (char c : res) {\n        cout << c << \" \";\n    }\n    cout << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:08:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Shiritori {\n    public static List<Character> solve(List<String> words) {\n        Set<Character> result = new TreeSet<>();\n        if (words.isEmpty()) {\n            return new ArrayList<>(result);\n        }\n        \n        for (int i = 0; i < words.size(); i++) {\n            String startWord = words.get(i);\n            List<String> remainingWords = new ArrayList<>(words);\n            remainingWords.remove(i);\n            dfs(startWord, remainingWords, result);\n        }\n        \n        return new ArrayList<>(result);\n    }\n    \n    private static void dfs(String currentWord, List<String> remainingWords, Set<Character> result) {\n        boolean foundNext = false;\n        char lastChar = currentWord.charAt(currentWord.length() - 1);\n        \n        for (int i = 0; i < remainingWords.size(); i++) {\n            String nextWord = remainingWords.get(i);\n            if (nextWord.charAt(0) == lastChar) {\n                foundNext = true;\n                List<String> newRemaining = new ArrayList<>(remainingWords);\n                newRemaining.remove(i);\n                dfs(nextWord, newRemaining, result);\n            }\n        }\n        \n        if (!foundNext) {\n            result.add(lastChar);\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<String> words = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            words.add(scanner.next());\n        }\n        List<Character> result = solve(words);\n        for (char c : result) {\n            System.out.print(c + \" \");\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:08:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public String[] solution(String[] words) {\n        Set<Character> lastChars = new TreeSet<>();\n        \n        for (int i = 0; i < words.length; i++) {\n            boolean[] used = new boolean[words.length];\n            List<String> currentChain = new ArrayList<>();\n            \n            if (dfs(words, i, used, currentChain)) {\n                lastChars.add(currentChain.get(currentChain.size() - 1).charAt(currentChain.get(currentChain.size() - 1).length() - 1));\n            }\n        }\n        \n        return lastChars.stream().map(String::valueOf).toArray(String[]::new);\n    }\n    \n    private boolean dfs(String[] words, int start, boolean[] used, List<String> currentChain) {\n        used[start] = true;\n        currentChain.add(words[start]);\n        \n        boolean foundNext = false;\n        for (int j = 0; j < words.length; j++) {\n            if (!used[j]) {\n                char lastChar = currentChain.get(currentChain.size() - 1).charAt(currentChain.get(currentChain.size() - 1).length() - 1);\n                if (words[j].charAt(0) == lastChar) {\n                    foundNext = true;\n                    dfs(words, j, used, currentChain);\n                }\n            }\n        }\n        \n        if (!foundNext) {\n            return true;\n        }\n        \n        used[start] = false;\n        currentChain.remove(currentChain.size() - 1);\n        return false;\n    }\n}",
    "timestamp": "2025-08-05 22:08:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "class Solution {\npublic:\n    string lastCharSet(vector<string>& words) {\n        int n = words.size();\n        string result = \"\";\n        vector<bool> used(n, false);\n        \n        for (int start = 0; start < n; start++) {\n            vector<bool> curr_used = used;\n            curr_used[start] = true;\n            char last_char = words[start].back();\n            \n            for (int round = 1; round < n; round++) {\n                bool found = false;\n                for (int j = 0; j < n; j++) {\n                    if (!curr_used[j] && words[j].front() == last_char) {\n                        curr_used[j] = true;\n                        last_char = words[j].back();\n                        found = true;\n                        break;\n                    }\n                }\n                \n                if (!found) break;\n            }\n            \n            result += last_char;\n        }\n        \n        sort(result.begin(), result.end());\n        result.erase(unique(result.begin(), result.end()), result.end());\n        \n        return result;\n    }\n};",
    "timestamp": "2025-08-05 22:08:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def shiritori(strings):\n    from collections import defaultdict\n\n    def dfs(last_char, strings, seen):\n        possible_ends = set()\n        for i, string in enumerate(strings):\n            if i in seen:\n                continue\n            if string[0] == last_char:\n                seen.add(i)\n                possible_ends.update(dfs(string[-1], strings, seen))\n                seen.remove(i)\n        if not possible_ends:\n            return {last_char}\n        return possible_ends\n\n    possible_ends = set()\n    for i, string in enumerate(strings):\n        seen = {i}\n        ends = dfs(string[-1], strings, seen)\n        possible_ends.update(ends)\n\n    return ''.join(sorted(possible_ends))\n\n# Example usage:\nstrings = [\"apple\", \"ear\", \"rhino\", \"orange\", \"grape\", \"elephant\"]\nprint(shiritori(strings))",
    "timestamp": "2025-08-13 09:04:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Shiritori {\n    public static List<Character> findFinalCharacters(List<String> words) {\n        Set<Character> finalChars = new TreeSet<>();\n        for (int i = 0; i < words.size(); i++) {\n            Set<Character> visited = new HashSet<>();\n            dfs(words, words.get(i), new boolean[words.size()], finalChars, visited, i);\n        }\n        return new ArrayList<>(finalChars);\n    }\n\n    private static void dfs(List<String> words, String current, boolean[] used, Set<Character> finalChars, Set<Character> visited, int index) {\n        used[index] = true;\n        visited.add(current.charAt(current.length() - 1));\n\n        boolean hasNext = false;\n        for (int i = 0; i < words.size(); i++) {\n            if (!used[i] && current.charAt(current.length() - 1) == words.get(i).charAt(0)) {\n                hasNext = true;\n                dfs(words, words.get(i), used, finalChars, visited, i);\n            }\n        }\n\n        if (!hasNext) {\n            finalChars.add(current.charAt(current.length() - 1));\n        }\n\n        used[index] = false;\n    }\n\n    public static void main(String[] args) {\n        List<String> words = Arrays.asList(\"apple\", \"ear\", \"rat\", \"tiger\", \"elephant\");\n        List<Character> result = findFinalCharacters(words);\n        for (char c : result) {\n            System.out.print(c + \" \");\n        }\n    }\n}",
    "timestamp": "2025-08-13 09:04:54"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_STRINGS 100\n#define MAX_LENGTH 100\n\nbool used[MAX_STRINGS];\nchar results[26];\n\nvoid shiritori(char strings[][MAX_LENGTH], int n, char last_char) {\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n        if (!used[i] && strings[i][0] == last_char) {\n            used[i] = true;\n            shiritori(strings, n, strings[i][strlen(strings[i]) - 1]);\n            used[i] = false;\n            found = true;\n        }\n    }\n    if (!found) {\n        results[last_char - 'a'] = 1;\n    }\n}\n\nint main() {\n    int n;\n    char strings[MAX_STRINGS][MAX_LENGTH];\n    \n    // Read number of strings\n    scanf(\"%d\", &n);\n    // Read the strings\n    for (int i = 0; i < n; i++) {\n        scanf(\"%s\", strings[i]);\n    }\n    \n    // Initialize results array\n    memset(results, 0, sizeof(results));\n    \n    // Try starting from each string\n    for (int i = 0; i < n; i++) {\n        used[i] = true;\n        shiritori(strings, n, strings[i][strlen(strings[i]) - 1]);\n        used[i] = false;\n    }\n    \n    // Output results in alphabetical order\n    for (char c = 'a'; c <= 'z'; c++) {\n        if (results[c - 'a']) {\n            printf(\"%c \", c);\n        }\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 09:05:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def shiritori(words):\n    # Sort words to ensure alphabetical order of final result\n    words.sort()\n    \n    def can_play(current_words, last_char):\n        result = set()\n        for i in range(len(current_words)):\n            if current_words[i][0] == last_char:\n                remaining = current_words[:i] + current_words[i+1:]\n                sub_result = can_play(remaining, current_words[i][-1])\n                if sub_result:\n                    result.update(sub_result)\n                else:\n                    result.add(current_words[i][-1])\n        return result\n    \n    possible_endings = set()\n    for i in range(len(words)):\n        # Try starting with each word\n        remaining = words[:i] + words[i+1:]\n        current_endings = can_play(remaining, words[i][-1])\n        if current_endings:\n            possible_endings.update(current_endings)\n        else:\n            possible_endings.add(words[i][-1])\n    \n    return sorted(list(possible_endings))",
    "timestamp": "2025-08-13 09:05:21"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef shiritori_last_chars(strings):\n    graph = defaultdict(list)\n    char_to_indices = defaultdict(list)\n    \n    for i, s in enumerate(strings):\n        first_char = s[0]\n        last_char = s[-1]\n        graph[first_char].append((last_char, i))\n        char_to_indices[first_char].append(i)\n    \n    result = set()\n    n = len(strings)\n    \n    def backtrack(last_char, used_indices):\n        has_next = False\n        for next_last, next_idx in graph.get(last_char, []):\n            if next_idx not in used_indices:\n                has_next = True\n                backtrack(next_last, used_indices | {next_idx})\n        if not has_next:\n            result.add(last_char)\n    \n    for i in range(n):\n        backtrack(strings[i][-1], {i})\n    \n    return sorted(result)\n\n# Example usage:\n# strings = [\"taro\", \"octopus\", \"snake\"]\n# print(shiritori_last_chars(strings))",
    "timestamp": "2025-08-13 09:05:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nvoid dfs(const string& current, const vector<string>& words, set<string>& used, char& lastChar) {\n    lastChar = current.back();\n    for (const string& word : words) {\n        if (!used.count(word) && word.front() == lastChar) {\n            used.insert(word);\n            dfs(word, words, used, lastChar);\n            used.erase(word);\n        }\n    }\n}\n\nset<char> findPossibleLastCharacters(vector<string>& words) {\n    set<char> possibleLastChars;\n    for (const string& word : words) {\n        set<string> used;\n        used.insert(word);\n        char lastChar;\n        dfs(word, words, used, lastChar);\n        possibleLastChars.insert(lastChar);\n    }\n    return possibleLastChars;\n}\n\nint main() {\n    vector<string> words = {\"apple\", \"elephant\", \"tiger\", \"rabbit\", \"bat\"};\n    set<char> possibleLastChars = findPossibleLastCharacters(words);\n    \n    for (char c = 'a'; c <= 'z'; ++c) {\n        if (possibleLastChars.count(c)) {\n            cout << c << ' ';\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:49:30"
  }
]