[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing PII = pair<int, int>;\n// template <typename T> using V = vector<T>;\n// template <typename T> using VV = vector<V<T>>;\n// template <typename T> using VVV = vector<VV<T>>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll INF = (1LL<<60);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nclass SCC {\npublic:\n  int V,K;    // 頂点数, scc後の頂点数\n  VVI G;      // グラフの隣接リストの表現\n  VVI rG;     // 辺の向きを逆にしたグラフ\n  VVI DAG;    // scc後のグラフの隣接リストの表現\n  VVI rDAG;   // scc後の辺の向きを逆にしたグラフ\n  VI vs;      // 帰りがけ順の並び\n  VI used;    // すでに調べたか\n  VI cmp;     // 属する強連結成分のトポロジカル順\n  VVI member; // scc後の同一ノードの集合\n  // vector<double> weight;  // i番目の連結成分が持つ情報\n  // 初期化\n  SCC() { V=K=-1; }\n  SCC(int V_): V(V_) {\n    G.assign(V_, VI());\n    rG.assign(V_, VI());\n    used.assign(V_, false);\n    cmp.assign(V_, false);\n    // weight.assign(V_, 1);\n  }\n  // 辺を追加\n  void add_edge(int from,int to) {\n    assert(from<V && to<V);\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  // dfs\n  void dfs(int v) {\n    used[v]=true;\n    for(int nx: G[v]) if(!used[nx]) dfs(nx);\n    vs.push_back(v);\n  }\n  // 逆順dfs\n  void rdfs(int v,int k) {\n    used[v]=true;\n    cmp[v]=k;\n    // weight[k] *= p[v];\n    for(int nx: rG[v]) if(!used[nx]) rdfs(nx,k);\n  }\n  // 2回dfsをする O(|V|+|E|)\n  int scc() {\n    // dfsする\n    used.assign(V,0);\n    vs.clear();\n    for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n    // 逆順でdfs\n    used.assign(V,0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--) if(!used[vs[i]]) rdfs(vs[i],k++);\n    // i番目の連結成分について\n    member.resize(k);\n    for(int i=0;i<V;i++) member[cmp[i]].push_back(i);\n    // weight.resize(k);\n    return K=k;\n  }\n  // O(ElogE)\n  VVI getDAG() {\n    assert(K>=0);\n    VVI res(K);\n    for(int from=0;from<V;from++) {\n      for(int to:G[from]) if(cmp[from]!=cmp[to]) res[cmp[from]].push_back(cmp[to]);\n    }\n    for(int i=0;i<K;i++){\n      sort(res[i].begin(),res[i].end());\n      res[i].erase(unique(res[i].begin(),res[i].end()),res[i].end());\n    }\n    return res;\n  }\n};\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n;\n  cin >> n;\n  vector<string> v(n);\n  vector<int> ans(30, 0);\n  VVI g(30);\n  REP(i, n) {\n    string s;\n    cin >> s;\n    v[i] = s[0];\n    v[i] += s.back();\n    ans[s.back()-'a'] = 1;\n    g[s[0]-'a'].PB(s.back()-'a');\n  }\n\n  SCC scc(26);\n  VI in(26), out(26);\n  REP(i, v.size()) {\n    scc.add_edge(v[i][0]-'a', v[i].back()-'a');\n    in[v[i].back()-'a']++;\n    out[v[i][0]-'a']++;\n  }\n  scc.scc();\n  auto ret = scc.getDAG();\n\n  VI out_s(30);\n  REP(i, 26) {\n    for(auto j: g[i]) {\n      if(scc.cmp[i] != scc.cmp[j]) {\n        out_s[i]++;\n      }\n    }\n  }\n  // cout << out_s << endl;\n\n  REP(i, 26) {\n    if(!ans[i]) continue;\n    if(in[i] - out[i] < 0) continue;\n    if(out_s[i] != 0) continue;\n    cout << (char)(i+'a') << endl;\n  }\n\n  // VV<int> g(30);\n  // V<int> in(30), out(30);\n  // V<int> self(30);\n  // REP(i, v.size()) {\n  //   if(v[i][0] == v[i].back()) {self[v[i].back()-'a'] = 1; continue;}\n  //   g[v[i][0]-'a'].PB(v[i].back()-'a');\n  //   out[v[i][0]-'a']++;\n  //   in[v[i].back()-'a']++;\n  // }\n\n  // V<char> ans;\n  // REP(i, 26) {\n  //   if(in[i] >= 1 && out[i] == 0) {\n  //     ans.PB((char)(i+'a'));\n  //   }\n  //   else if(out[i] == 0 && self[i]) {\n  //     ans.PB((char)(i+'a'));\n  //   }\n  // }\n  // sort(ALL(ans));\n  // ans.erase(unique(ALL(ans)), ans.end());\n  // for(auto i: ans) cout << i << endl;\n  // return 0;\n\n  // bool used[30] = {};\n  // function<void(int)> dfs = [&](int num) {\n  //   ans.PB((char)(num+'a'));\n  //   used[num] = true;\n  //   for(auto i: g[num]) {\n  //     if(!used[i]) {\n  //       dfs(i);\n  //     }\n  //   }\n  // };\n\n  // REP(i, n) {\n  //   // 始点をv[i].back()として探索開始してたどり着ける頂点を列挙する\n  //   memset(used, false, sizeof(used));\n  //   dfs(v[i].back()-'a');\n\n  //   // out[v[i][0]-'a']--;\n  //   // in[v[i].back()-'a']--;\n  //   // int s = 0, t = 0;\n  //   // char c;\n  //   // REP(i, 26) {\n  //   //   if(in[i] - out[i] == 0) {\n\n  //   //   } else if(in[i] - out[i] == 1) {\n  //   //     t++; c = (char)(i + 'a');\n  //   //   } else if(in[i] - out[i] == -1) {\n  //   //     s++;\n  //   //   } else {\n  //   //     s = 100;\n  //   //     break;\n  //   //   }\n  //   // }\n  //   // if(s == 0 && t == 0) ans.PB(v[i].back());\n  //   // else if(s == 1 && t == 1) ans.PB(c);\n  //   // cout << i << \" \" << ans << endl;\n  // }\n\n  // sort(ALL(ans));\n  // ans.erase(unique(ALL(ans)), ans.end());\n  // for(auto i: ans) cout << i << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define enld '\\n'\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"Ofast\")\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr double INFD = 1e100;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst double PI = 3.1415926535897932384626433832795028841971;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ios::sync_with_stdio(false);\n// cin.tie(nullptr);\n// ---------------------------------------------------------------------------\n\n\n#define MAX_V 1000000\nstruct edge{\n    int to,cap,rev;\n};\n\nvector<vector<edge>> G(MAX_V);\nbool used[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n    edge F;\n    edge T;\n    F.to = to;\n    F.cap = cap;\n    F.rev = G[to].size();\n    G[from].push_back(F);\n\n    T.to = from;\n    T.cap = 0;\n    T.rev = G[from].size()-1;\n    G[to].push_back(T);\n}\n\nint dfs(int v,int t,int f){\n    if(v == t) return f;\n    used[v] = true;\n    for(int i=0; i<G[v].size(); i++){\n        edge &e = G[v][i];\n        if(!used[e.to] and e.cap > 0){\n            int d = dfs(e.to,t,min(f,e.cap));\n            if(d > 0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\nint max_flow(int s,int t){\n    int flow = 0;\n    while(1){\n        memset(used, 0, sizeof(used));\n        int f = dfs(s,t,inf);\n        if(f == 0) return flow;\n        flow += f;\n    }\n}\n\n\nint main(){\n    int N;\n    cin >> N;\n    vector<string> S(N);\n    for(int i=0; i<N; i++){\n        cin >> S[i];\n    }\n    vector<bool> last(26,false);\n    for(int i=0; i<N; i++){\n        last[S[i].back()-'a'] = true;\n    }\n    for(int c=0; c<26; c++){\n        if(!last[c]) continue;\n        int s=26,t=27;\n        int cnt = 0;\n        memset(used,0,sizeof(used));\n        for(int i=0; i<30; i++){\n            G[i].clear();\n        }\n        for(int i=0; i<N; i++){\n            int u = (S[i].front() == c+'a') ? s : (S[i].front()-'a');\n            int v = (S[i].back() == c+'a') ? t : (S[i].back()-'a');\n            // cout << u << \" \" << v << enld;\n            add_edge(u,v,1);\n            if(S[i].front() == c+'a') cnt++; \n        }\n        // cout << G[s].size() << enld;\n        int flow = max_flow(s,t);\n        // cout << \"check:\" << char(c+'a') << \" \" << flow << \" \" << cnt << enld;\n        if(flow == cnt){\n            cout << char(c+'a') << enld;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:https://onlinejudge.u-aizu.ac.jp/services/room.html#ACPC2018Day2/problems/I>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct DINIC{\n#define MAX_V 100\n    typedef long long ll;\n    typedef ll CapType;\n    struct edge {\n        int to; // 行き先\n        CapType cap; // 容量\n        int rev; // 逆辺\n        edge() {}\n        edge(int to, CapType cap, int rev) :to(to), cap(cap), rev(rev) {}\n    };\n    vector<edge> G[MAX_V]; // グラフの隣接リスト表現\n    ll level[MAX_V]; // sからの距離\n    ll iter[MAX_V]; // どこまで調べ終わったか\n    \n    void init(){\n        for(int i = 0; i < MAX_V;i++) G[i].clear();\n    }\n    // fromからtoへ向かう容量capの辺をグラフに追加する\n    void add_directed_edge(int from, int to, CapType cap) {\n        G[from].push_back(edge(to, cap, (int)G[to].size()));\n        G[to].push_back(edge(from, 0, (int)G[from].size() - 1));\n    }\n    void add_undirected_edge(int from, int to, CapType cap) {\n        G[from].push_back(edge(to, cap, (int)G[to].size()));\n        G[to].push_back(edge(from, cap, (int)G[from].size() - 1));\n    }\n    \n    // sからの最短距離をBFSで計算する\n    void bfs(int s){\n        fill(level,level+MAX_V,-1);\n        queue<int> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()){\n            int v = q.front(); q.pop();\n            for(int i = 0; i < (int)G[v].size();i++){\n                edge& e = G[v][i];\n                if(e.cap > 0 && level[e.to] < 0){\n                    level[e.to] = level[v] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n    \n    // 増加パスをDFSで探す\n    CapType dfs(int v, int t,CapType f){\n        if(v == t) return f;\n        for(ll &i = iter[v]; i < G[v].size();i++){\n            edge &e = G[v][i];\n            if(e.cap > 0 && level[v] < level[e.to]){\n                CapType d = dfs(e.to,t,min(f,e.cap));\n                if(d > 0){\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    CapType max_flow(int s,int t){\n        CapType flow = 0;\n        for(;;){\n            bfs(s);\n            if(level[t] < 0) return flow;\n            fill(iter,iter+MAX_V,0);\n            CapType f;\n            while((f = dfs(s,t,LINF)) > 0){\n                flow += f;\n            }\n        }\n    }\n};\nDINIC dinic;\nint S = 26,T = S+1;\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll N; cin >> N;\n    vector<string> s(N); for(auto &in:s) cin >> in;\n\n    set<char> st;\n    for(auto& str:s) st.insert(str.back());\n\n    for(auto& c:st){\n        dinic.init();\n\n        int key = c - 'a';\n\n        ll sum = 0;\n        for(int i = 0; i < N;i++){\n            int front = s[i].front() - 'a';\n            int back = s[i].back() - 'a';\n\n            if(key == front && back != key){\n                sum += 1;\n                dinic.add_directed_edge(S, back, 1);\n            }\n            if(key != front){\n                if(back == key){\n                    dinic.add_directed_edge(front, T, 1);\n                }else{\n                    dinic.add_directed_edge(front, back, 1);\n                }\n            }\n        }\n        ll mflow = dinic.max_flow(S, T);\n        if(mflow >= sum){\n            cout << c << endl;\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\ntypedef long long ll;\ntypedef long double ld;\n#define fst first\n#define snd second\n#define all(c) ((c).begin()), ((c).end())\n\n\nstruct graph {\n    int n;\n    vector<vector<int>> adj, rdj;\n    vector<int> group;\n    graph(int n) : n(n), adj(n), rdj(n), group(n) { }\n    void add_edge(int src, int dst) {\n        adj[src].push_back(dst);\n        rdj[dst].push_back(src);\n    }\n\n    vector<vector<int>> strongly_connected_components() { // kosaraju\n        vector<int> ord, visited(n);\n        vector<vector<int>> scc;\n        function<void(int,vector<vector<int>>&, vector<int>&)> dfs\n            = [&](int u, vector<vector<int>> &adj, vector<int> &out) {\n            visited[u] = true;\n            for (int v: adj[u])\n        if (!visited[v]) dfs(v, adj, out);\n            out.push_back(u);\n        };\n        for (int u = 0; u < n; ++u)\n            if (!visited[u]) dfs(u, adj, ord);\n        fill(all(visited), false);\n        for (int i = n-1; i >= 0; --i)\n            if (!visited[ord[i]])\n                scc.push_back({}), dfs(ord[i], rdj, scc.back());\n        for (int i = 0; i < (int)scc.size(); ++i)\n            for (int j = 0; j < (int)scc[i].size(); ++j)\n                group[scc[i][j]] = scc[i][0];\n        return scc;\n    }\n};\n\nint N;\nint G[26][26];\nbool used[26];\n\nvoid solve() {\n    cin >> N;\n    graph g(26);\n\n    REP(i, N) {\n        string s;\n        cin >> s;\n        G[s.front()-'a'][s.back()-'a'] += 1;\n        used[s.front()-'a'] = true;\n        used[s.back()-'a']  = true;\n    }\n\n    REP(i, 26) REP2(j, i+1, 26) {\n        int m = min(G[i][j], G[j][i]);\n        G[i][j] -= m;\n        G[j][i] -= m;\n        while (G[i][j]--) g.add_edge(i, j);\n        while (G[j][i]--) g.add_edge(j, i);\n    }\n\n    vector<vector<int>> scc = g.strongly_connected_components();\n\n    REP(i, 26) if (used[i]) {\n        bool ok = (int)g.rdj[i].size() - (int)g.adj[i].size() >= 0;\n        for (auto j: g.adj[i]) if (g.group[i] != g.group[j]) ok = false;\n        if (ok) cout << (char)('a' + i) << endl;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 26\n#define NUM 27\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_capacity,int arg_rev_index){\n\t\tto = arg_to;\n\t\tcapacity = arg_capacity;\n\t\trev_index = arg_rev_index;\n\t}\n\tint to,capacity,rev_index;\n};\n\nint V,E;\n\nint num_start[SIZE],num_end[SIZE],table[SIZE][SIZE];\nint index_table[SIZE];\nint dist[NUM];\nint cheked_index[NUM];\nchar words[10005][105];\nvector<Edge> G[NUM];\n\nvoid add_edge(int from,int to,int capacity){\n\tG[from].push_back(Edge(to,capacity,G[to].size()));\n\tG[to].push_back(Edge(from,0,G[from].size()-1));\n}\n\nvoid bfs(int source){\n\tfor(int i = 0; i < V; i++)dist[i] = -1;\n\tqueue<int> Q;\n\tdist[source] = 0;\n\tQ.push(source);\n\n\twhile(!Q.empty()){\n\t\tint node_id = Q.front();\n\t\tQ.pop();\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tEdge &e = G[node_id][i];\n\t\t\tif(e.capacity > 0 && dist[e.to] < 0){\n\t\t\t\tdist[e.to] = dist[node_id]+1;\n\t\t\t\tQ.push(e.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint dfs(int node_id,int sink,int flow){\n\tif(node_id == sink)return flow;\n\n\tfor(int &i = cheked_index[node_id]; i < G[node_id].size(); i++){\n\t\tEdge &e = G[node_id][i];\n\t\tif(e.capacity > 0 && dist[node_id] < dist[e.to]){\n\t\t\tint tmp_flow = dfs(e.to,sink,min(flow,e.capacity));\n\t\t\tif(tmp_flow > 0){\n\t\t\t\te.capacity -= tmp_flow;\n\t\t\t\tG[e.to][e.rev_index].capacity += tmp_flow;\n\t\t\t\treturn tmp_flow;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint max_flow(int source,int sink){\n\tint flow = 0,add;\n\twhile(true){\n\t\tbfs(source);\n\t\tif(dist[sink] < 0)break;\n\t\tfor(int i = 0; i < V; i++)cheked_index[i] = 0;\n\t\twhile((add = dfs(source,sink,BIG_NUM)) > 0){\n\t\t\tflow += add;\n\t\t}\n\t}\n\treturn flow;\n}\n\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < SIZE; i++){\n\n\t\tnum_start[i] = 0;\n\t\tnum_end[i] = 0;\n\n\t\tfor(int k = 0; k < SIZE; k++){\n\n\t\t\ttable[i][k] = 0;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%s\",words[i]);\n\n\t\tchar first_ch = words[i][0];\n\t\tchar last_ch = first_ch;\n\n\t\tfor(int k = 0; words[i][k] != '\\0'; k++){\n\n\t\t\tlast_ch = words[i][k];\n\t\t}\n\n\t\tif(last_ch != first_ch){\n\n\t\t\tnum_start[first_ch-'a']++;\n\t\t}\n\t\tnum_end[last_ch-'a']++;\n\n\t\ttable[first_ch-'a'][last_ch-'a']++;\n\t}\n\n\tV = 27;\n\tint index;\n\tint source = 25,sink = 26;\n\n\tfor(int i = 0; i < 26; i++){\n\t\tif(num_end[i] == 0)continue;\n\n\t\tindex = 0;\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(k == i)continue;\n\t\t\tindex_table[k] = index++;\n\t\t}\n\n\t\tif(num_start[i] == 0){\n\t\t\tprintf(\"%c\\n\",'a'+i);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor(int k = 0; k < NUM; k++){\n\n\t\t\tG[k].clear();\n\t\t}\n\n\t\t//sourceからエッジを張る\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(table[i][k] == 0 || k == i)continue;\n\n\t\t\tadd_edge(source,index_table[k],table[i][k]);\n\t\t}\n\n\t\tfor(int a = 0; a < SIZE; a++){\n\t\t\tif(a == i || num_start[a] == 0)continue;\n\t\t\tfor(int b = 0; b < SIZE; b++){\n\t\t\t\tif(b == i || table[a][b] == 0)continue;\n\n\t\t\t\tadd_edge(index_table[a],index_table[b],table[a][b]);\n\t\t\t}\n\t\t}\n\n\t\t//sinkへエッジを張る\n\t\tfor(int k = 0; k < SIZE; k++){\n\t\t\tif(table[k][i] == 0 || k == i)continue;\n\n\t\t\tadd_edge(index_table[k],sink,table[k][i]);\n\t\t}\n\n\t\tif(max_flow(source,sink) == num_start[i]){\n\n\t\t\tprintf(\"%c\\n\",'a'+i);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf 2000000000\nusing namespace std;\n// 0-indexed\nstruct Dinic {\n  struct edge {\n    int to;\n    int cap;\n    int rev;\n  };\n  vector<vector<edge>> lst;\n  vector<int> completed;\n  vector<int> dist;\n  Dinic(int n = 1) {\n    // if 1-indexed\n    //++n;\n    lst.resize(n);\n    completed.resize(n);\n    dist.resize(n);\n  }\n  bool add(int start, int goal, int capacity) {\n    lst[start].push_back(\n        (edge){goal, capacity, (int)lst[goal].size()});\n    lst[goal].push_back(\n        (edge){start, 0, (int)lst[start].size() - 1});\n    return 1;\n  }\n  // dist = time from start to now number\n  void distbfs(int start) {\n    fill(dist.begin(), dist.end(), -1);\n    queue<int> bfsqu;\n    dist[start] = 0;\n    bfsqu.push(start);\n    while(bfsqu.size() > 0) {\n      int now = bfsqu.front();\n      bfsqu.pop();\n      for(int i = 0; i < lst[now].size(); ++i) {\n        edge* nowe = &lst[now][i];\n        if(nowe->cap > 0 && dist[nowe->to] < 0) {\n          dist[nowe->to] = dist[now] + 1;\n          bfsqu.push(nowe->to);\n        }\n      }\n    }\n  }\n  int pathdfs(int now, int goal, int nf) {\n    if(now == goal) return nf;\n    for(int& i = completed[now]; i < lst[now].size(); ++i) {\n      edge* e = &lst[now][i];\n      if(e->cap > 0 && dist[now] < dist[e->to]) {\n        int ans = pathdfs(e->to, goal, min(nf, e->cap));\n        if(ans > 0) {\n          e->cap -= ans;\n          lst[e->to][e->rev].cap += ans;\n          return ans;\n        }\n      }\n    }\n    return 0;\n  }\n  int solve(int start, int goal) {\n    int ans = 0, nf = 0;\n    while(1) {\n      // bfs\n      distbfs(start);\n      // cannnot go to goal from start\n      if(dist[goal] < 0) return ans;\n      // reset\n      fill(completed.begin(), completed.end(), 0);\n      while((nf = pathdfs(start, goal, inf)) > 0) ans += nf;\n    }\n    return -1;\n  }\n};\n\nint cnt[26] = {0};\nint memo[26][26] = {0};\nbool ch[26] = {0};\nint n;\nDinic dn;\n\nvoid solve();\n\nint main() {\n  cin >> n;\n  dn = Dinic(52);\n  for(int i = 0; i < n; ++i) {\n    string s;\n    cin >> s;\n    ch[s[s.size() - 1] - 'a'] = 1;\n    ++cnt[s[0] - 'a'];\n    ++memo[s[0] - 'a'][s[s.size() - 1] - 'a'];\n  }\n  for(int i = 0; i < 26; ++i)\n    for(int j = 0; j < 26; ++j) {\n      if(i == j) dn.add(i + 26, j, 1000000);\n      if(memo[i][j] != 0) dn.add(i, j + 26, memo[i][j]);\n    }\n\n  solve();\n  return 0;\n}\n\nvoid solve() {\n  for(int i = 0; i < 26; ++i) {\n    if(ch[i] && cnt[i] == dn.solve(i, i + 26))\n      cout << (char)(i + 'a') << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct edge{\n\tint to,cap,rev;\n\tedge(){}\n\tedge(int tt,int cc,int rr){\n\t\tto=tt;\n\t\tcap=cc;\n\t\trev=rr;\n\t}\n};\n\n\nclass dinic{\npublic:\n\tconst int INF=1000000;\n\tvector<edge> G[2001];\n\tint level[2001];\n\tint iter[2001];\n\tvoid add_edge(int from,int to,int cap){\n\t\tG[from].push_back(edge(to,cap,G[to].size()));\n\t\tG[to].push_back(edge(from,0,G[from].size()-1));\n\t}\n\n\tvoid bfs(int s){\n\t\tmemset(level,-1,sizeof(level));\n\t\tqueue<int> que;\n\t\tlevel[s]=0;\n\t\tque.push(s);\n\t\twhile(que.size()){\n\t\t\tint v=que.front();\n\t\t\tque.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0 && level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint dfs(int v,int t,int f){\n\t\tif(v==t)return f;\n\t\tint res=0;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(e.cap>0 && level[v]<level[e.to]){\n\t\t\t\tint d=dfs(e.to,t,min(e.cap,f));\n\t\t\t\tif(d>0){\n\t\t\t\t\te.cap-=d;\n\t\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\t\tres+=d;\n\t\t\t\t\tf-=d;\n\t\t\t\t\tif(f==0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tint max_flow(int s,int t){\n\t\tint flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\tmemset(iter,0,sizeof(iter));\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,t,INF))>0){\n\t\t\t\tflow+=f;\n\t\t\t}\n\t\t}\n\t}\n};\n\ndinic di;\n\nint n;\nint f[10005],t[10005];\nint fie[30][30];\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tstring s;\n\t\tcin >> s;\n\t\tf[i]=s[0]-'a';\n\t\tt[i]=s[s.size()-1]-'a';\n\t\tfie[f[i]][t[i]]++;\n\t}\t\n\tfor(int i=0;i<26;i++){\n\t\tbool flag=false;\n\t\tfor(int j=0;j<26;j++){\n\t\t\tif(fie[j][i]>0)flag=true;\n\t\t}\n\t\tif(!flag)continue;\n\t\tint cnt=0;\n\t\tint cnt2=0;\n\t\tfor(int j=0;j<26;j++){\n\t\t\tif(i==j)continue;\n\t\t\tcnt+=fie[j][i];\n\t\t\tcnt2+=fie[i][j];\n\t\t}\n\t\t//printf(\"%d\\n\",i);\n\t\tfor(int j=0;j<1000;j++){\n\t\t\tdi.G[j].clear();\n\t\t}\n\t\tint S=26*2;\n\t\tint T=S+1;\n\t\tdi.add_edge(S,i,cnt2);\n\t\tdi.add_edge(26+i,T,cnt);\n\t\tfor(int j=0;j<26;j++){\n\t\t\tdi.add_edge(26+j,j,10000);\n\t\t\tfor(int k=0;k<26;k++){\n\t\t\t\tif(j==k)continue;\n\t\t\t\tdi.add_edge(j,26+k,fie[j][k]);\n\t\t\t}\n\t\t}\n\t\tint v=di.max_flow(S,T);\n\t\t//printf(\"%d %d\\n\",i,v);\n\t\tif(v==cnt2){\n\t\t\tprintf(\"%c\\n\",('a'+i));\n\t\t}\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n/*\nsigned main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint w=sqrt(n)+10;\n\tvi dp(n+1);\n\trep(i,m){\n\t\tcin>>a>>b;\n\t\tif(b>w){\n\t\t\tif(a!=b-1){\n\t\t\t\tdp[0]+=a+1;\n\t\t\t\tdp[1]-=a;\n\t\t\t\tfor(int j=b-a-1;j<n;j+=b){\n\t\t\t\t\tdp[j]-=b;\n\t\t\t\t\tif(j+1<=n)dp[j+1]+=b;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tdp[1]+=1;\n\t\t\t\tdp[]+=;\n\t\t\t}\n\t\t}else{\n\t\t\t\n\t\t}\n\t}\n\trep(i,n)dp[i+1]+=dp[i];\n\trep(i,n)dp[i+1]+=dp[i];\n\trep(i,n){\n\t\tint sum=dp[i];\n\t\trep(j,w)sum+=d[j][i%j];\n\t\tcout<<sum<<endl;\n\t}\n}\n*/\n\n\nstruct edge{int to,cap,rev;};//ikisaki youryou gyakuhen\nclass MF{//max flow\n\tpublic:\n\tint n;\n\tvector<vector<edge> >G;//[MAX];\n\tvi level,iter;//[MAX];\n\tMF(int size){\n\t\tn=size;\n\t\tG=vector<vector<edge> >(n);\n\t}\n\tvoid add_edge(int from, int to, int cap){\n\t\tedge q={to,cap,int(G[to].size())};\n\t\tG[from].push_back(q);\n\t\tq={from,0,int(G[from].size()-1)};\n\t\tG[to].push_back(q);\n\t}\n\tvoid bfs(int s){\n\t\tlevel=vi(n,-1);\n\t\tqueue<int>q;\n\t\tlevel[s]=0;\n\t\tq.push(s);\n\t\twhile(!q.empty()){\n\t\t\tint v=q.front();q.pop();\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tedge &e=G[v][i];\n\t\t\t\tif(e.cap>0&&level[e.to]<0){\n\t\t\t\t\tlevel[e.to]=level[v]+1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v,int t, int f) {\n\t\tif(v==t)return f;\n\t\tfor(int &i=iter[v];i<G[v].size();i++){\n\t\t\tedge &e=G[v][i];\n\t\t\tif(level[v]>=level[e.to]||e.cap<=0) continue;\n\t\t\tint d =dfs(e.to,t,min(f,e.cap));\n\t\t\tif(d>0){\n\t\t\t\te.cap-=d;\n\t\t\t\tG[e.to][e.rev].cap+=d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint mf(int s,int t) {//from s to t,ford_fulkerson\n\t\tint flow=0;\n\t\twhile(1){\n\t\t\tbfs(s);\n\t\t\tif(level[t]<0)return flow;\n\t\t\titer=vi(n);\n\t\t\tint f;\n\t\t\twhile((f=dfs(s,t,inf))>0)flow+=f;\n\t\t}\n\t}\n};\nint main(){\n\tint n;\n\tcin>>n;\n\tvs in(n);\n\trep(i,n)cin>>in[i];\n\tvvi co(26,vi(26));\n\tvi h(26);\n\trep(i,n){\n\t\tstring s=in[i];\n\t\th[s[s.size()-1]-'a']=1;\n\t\tco[s[0]-'a'][s[s.size()-1]-'a']++;\n\t}\n\n/*\tvvi fl(26,vi(26));\n\trep(i,26)rep(j,26)if(i!=j){\n\t\tMF mf(26);\n\t\trep(x,26)rep(y,26)if(x!=y)\n\t\t\tmf.add_edge(x,y,co[x][y]);\n\t\tfl[i][j]=mf.mf(i,j);\n\t}\n\t*/\n\trep(i,26)if(h[i]){\n\t\tint sum=0;\n\t\tMF mf(27);\n\t\trep(j,26)rep(k,26)if(j!=i&&j!=k&&i!=k&&co[j][k]){\n\t\t\tmf.add_edge(j,k,co[j][k]);\n\t\t}\n\t\trep(j,26){\n\t\t\tif(co[i][j])mf.add_edge(i,j,co[i][j]);\n\t\t\tif(co[j][i])mf.add_edge(j,26,co[j][i]);\n\t\t\tsum+=co[i][j];\n\t\t}\n\t\tint flow=mf.mf(i,26);\n\t\tif(flow==sum)cout<<(char)('a'+i)<<endl;\n\t}\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nusing Weight = int;\nusing Flow = int;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tFlow cap;\n\tEdge() : src(0), dst(0), weight(0) {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = std::vector<Edge>;\nusing Graph = std::vector<Edges>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nvoid add_edge(Graph &g, int a, int b, Weight w = 1) {\n\tg[a].emplace_back(a, b, w);\n\tg[b].emplace_back(b, a, w);\n}\nvoid add_arc(Graph &g, int a, int b, Weight w = 1) { g[a].emplace_back(a, b, w); }\nstruct ford_fulkerson {\n\tusing Matrix = std::vector<std::vector<Flow>>;\n\tint n, t;\n\tstd::vector<int> vis;\n\tstd::vector<std::vector<Flow>> cap, flow;\n\tstd::vector<std::vector<int>> g;\n\tconst Flow INF;\n\tford_fulkerson(int n)\n\t\t: n(n),\n\t\tcap(n, std::vector<Flow>(n)),\n\t\tflow(n, std::vector<Flow>(n)),\n\t\tg(n, std::vector<int>()),\n\t\tINF(std::numeric_limits<Flow>::max() / 8) {}\n\tford_fulkerson(const Graph &graph) : ford_fulkerson(graph.size()) {\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tfor (auto &e : graph[i]) add_edge(e.src, e.dst, e.cap);\n\t}\n\tvoid add_edge(int u, int v, Flow c) {\n\t\tcap[u][v] += c;\n\t\tcap[v][u] += c;\n\t\tflow[v][u] += c;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tFlow solve(int s, int t) {\n\t\tthis->t = t;\n\t\tFlow res = 0, aug = 1;\n\t\twhile (aug > 0) {\n\t\t\tvis.assign(n, false);\n\t\t\tres += (aug = augment(s, INF));\n\t\t}\n\t\treturn res;\n\t}\n\tFlow augment(const int &v, const Flow &lim) {\n\t\tvis[v] = true;\n\t\tif (v == t) return lim;\n\t\tfor (const int &d : g[v]) {\n\t\t\tif (vis[d] || flow[v][d] == cap[v][d]) continue;\n\t\t\tFlow aug = augment(d, std::min(lim, cap[v][d] - flow[v][d]));\n\t\t\tflow[v][d] += aug;\n\t\t\tflow[d][v] -= aug;\n\t\t\tif (aug > 0) return aug;\n\t\t}\n\t\treturn 0;\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tvector<vector<int> > A(26, vector<int>(26, 0));\n\tint res = 0;\n\tvector<int> X(26, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tstring S;\n\t\tcin >> S;\n\t\tif (S[0] != S.back()) {\n\t\t\tA[S[0] - 'a'][S.back() - 'a']++;\n\t\t}\n\t\tX[S.back() - 'a'] = 1;\n\t}\n\tfor (int a = 0; a < 26; a++) {\n\t\tif (X[a] == 1) {\n\t\t\tford_fulkerson ff(27);\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < 26; i++) {\n\t\t\t\tfor (int j = 0; j < 26; j++) {\n\t\t\t\t\tif (A[i][j] > 0) {\n\t\t\t\t\t\tif (j == a) {\n\t\t\t\t\t\t\tff.add_edge(i, 26, A[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tff.add_edge(i, j, A[i][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (i == a) {\n\t\t\t\t\t\t\tsum += A[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ff.solve(a, 26) == sum) {\n\t\t\t\tcout << char(a + 'a') << endl;\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<fixed<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n//はいフロー \nclass dinic{\npublic:\n\tint n,sta,gol;\n\tvector<vector<llint>> hen;\n\tvector<int>dis;//bfsの距離\n\t//隣接行列(O(VVE)なので)\n\tvector<vector<int>>tna;\n\t//hen[town][i]>0 を探す\n\tdinic(int in,int s,int g){\n\t\tn=in;\n\t\tsta=s;\n\t\tgol=g;\n\t\then.res(in);\n\t\tdis.res(in);\n\t\ttna.res(in);\n\t\tfor(int i=0;i<n;i++){hen[i].res(in);}\n\t}\n\tvoid add(int u,int v,llint wei){hen[u][v]+=wei;tna[u].pub(v);tna[v].pub(u);}\n\t//隣接なので逆編情報が不要!!\n\t//増加のbfsする\n\t//それが増加する向きだけに流す\n\t//流れないなら、終了!\n\tvoid bfs(void){\n\t\tint i;\n\t\tfor(i=0;i<n;i++){dis[i]=-1;}//初期化\n\t\tqueue<pair<int,int>>que;\n\t\tque.push(mp(0,sta));\n\t\tdis[sta]=0;\n\t\twhile(!que.empty()){\n\t\t\tint kyo=que.front().fir;\n\t\t\tint town=que.front().sec;\n\t\t\tque.pop();\n\t\t\tfor(auto i:tna[town]){\n\t\t\t\tif(hen[town][i]!=0&&dis[i]==-1){dis[i]=kyo+1;que.push(mp(kyo+1,i));}\n\t\t\t}\n\t\t}\n\t}\n\tllint dfs(int ter,llint lim){\n\t\t//それまでの上限がlim\n\t\t//流した量を返す\n\t\tif(ter==gol){return lim;}\n\t\tllint ans=0;\n\t\tfor(auto i:tna[ter]){\n\t\t\tif(dis[ter]>=dis[i]||hen[ter][i]==0){continue;}//dinic\n\t\t\tif(lim==ans){break;}\n\t\t\tllint nga=dfs(i,min(lim-ans,hen[ter][i]));\n\t\t\tans+=nga;\n\t\t\then[ter][i]-=nga;\n\t\t\then[i][ter]+=nga;\n\t\t}\n\t\treturn ans;\n\t}\n\tllint solve(void){\n\t\tllint ans=0;\n\t\twhile(-1){\n\t\t\tbfs();\n\t\t\tllint nga=dfs(sta,big);\n\t\t\tans+=nga;\n\t\t\tif(nga==0){break;}\n\t\t}\n\t\treturn ans;\n\t}\n};\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,i,c,d,e;cin>>n;\n\tchar go[26][26]={0};\n\tchar aru[26]={0};\n\twhile(n--){\n\t\tstring s;cin>>s;\n\t\taru[s.back()-'a']=1;\n\t\tgo[s[0]-'a'][s.back()-'a']++;\n\t}\n\tfor(c=0;c<26;c++){\n\t\tif(!aru[c]){continue;}\n\t\tdinic gra(28,26,27);\n\t\tfor(d=0;d<26;d++){\n\t\t\tif(d==c){continue;}\n\t\t\tfor(e=0;e<26;e++){\n\t\t\t\tif(d==e){continue;}\n\t\t\t\tif(e==c){continue;}\n\t\t\t\tgra.add(d,e,go[d][e]);\n\t\t\t}\n\t\t}\n\t\tint need=0;\n\t\tfor(d=0;d<26;d++){\n\t\t\tif(go[c][d]>go[d][c]){gra.add(26,d,go[c][d]-go[d][c]);need+=go[c][d]-go[d][c];}\n\t\t\tif(go[c][d]<go[d][c]){gra.add(d,27,go[d][c]-go[c][d]);}\n\t\t}\n\t\tif(gra.solve()==need){cout<<((char)(c+'a'))<<endl;}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n\n    /* \n    // debug\n    friend ostream& operator << (ostream& s, const Graph& G) {\n        s << endl; for (int i = 0; i < G.V; ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n    }\n    */\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n\n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\n\nint N;\nvector<string> S;\n\nint main() {\n    while (cin >> N) {\n        S.resize(N);\n        for (int i = 0; i < N; ++i) cin >> S[i];\n\n        vector<char> res;\n        for (int ch = 0; ch < 26; ++ch) {\n            Graph<int> G(28);\n            int s = 26, t = 27;\n            int deg_out = 0, deg_in = 0;\n            for (int i = 0; i < N; ++i) {\n                int u = S[i][0] - 'a';\n                int v = S[i].back() - 'a';\n                if (u == ch) u = s, ++deg_out;\n                if (v == ch) v = t, ++deg_in;\n                G.addedge(u, v, 1);\n            }\n            Dinic<int> din;\n            int flow = din.solve(G, s, t);\n            if (flow >= deg_out && deg_in > 0) res.push_back((char)('a' + ch));\n        }\n\n        for (auto c : res) {\n            cout << c << endl;\n        }\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\n#include <vector>\n#include <list>\n#include<stack>\n#include<queue>\n#include<array>\n\n#include <set>\n#include<map>\n\n#include<string>\n#include<stdlib.h>\n\n#include<algorithm>\n#include <functional>\n#include<math.h>\n\n#include<fstream>\n#include<iomanip>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pii = pair<int,int>;\n\n#define FOR(k,m,n) for(ll (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\n\nconstexpr int INF = (1 << 30);\nconstexpr ll INFL = (1ll << 60);\nconstexpr ll MOD = 1000000007;// 10^9+7\n\n\n\t\t\t\t\t\t\t  //���C�u�����\\��\n\t\t\t\t\t\t\t  //�l�b�g���[�N�t���[�F�a�{p188�`\nclass NetworkFlow {\npublic:\n\t//�����F���_��\n\tNetworkFlow(int size) {\n\t\tG.resize(size);\n\t\tused.resize(size);\n\t}\n\n\t//from����to�֌������e��cap�̕ӂ��O���t�ɒǉ�����\n\tvoid add_edge(int from, int to, int cap) {\n\t\tEdge e1 = { to, cap, (int)G[to].size() };\n\t\tEdge e2 = { from, 0, (int)G[from].size() - 1 };\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t}\n\n\t//s����t�ւ̍ő嗬�����߂�\n\tint max_flow(int s, int t) {\n\t\tint flow = 0;\n\t\twhile (true) {\n\t\t\tfill(used.begin(), used.end(), false);\n\t\t\tint f = dfs(s, t, INF);\n\t\t\tif (f == 0)return flow;\n\t\t\tflow += f;\n\t\t}\n\t}\n\n\nprivate:\n\t//�^�ƕϐ�\n\tstruct Edge { int to, cap, rev; };//�ӂ�\\���\\���́i�s����A�e�ʁA�t�Ӂj\n\tvector<vector<Edge>> G;   //�O���t�̗אڃ��X�g�\\��\n\tvector<bool> used;//DFS�Ŋ��ɒ��ׂ����̃t���O\n\n\t\t\t\t\t  //�֐�\n\t\t\t\t\t  //�����p�X��DFS�ŒT��\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tused[v] = true;\n\t\tREP(i, (int)G[v].size()) {\n\t\t\tEdge& e = G[v][i];\n\t\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n};\nusing NF = NetworkFlow;\n\n//�ϐ�\nconstexpr int ALNUM = 26;\nint N;\nvector<vector<int>> s(ALNUM, vector<int>(ALNUM, 0));\nvector<bool> res(ALNUM, false);\n\n\n\n\n\n//�T�u�֐�\n//����\nvoid input()\n{\n\tcin >> N;\n\tREP(i, N) {\n\t\tstring ts;\n\t\tcin >> ts;\n\t\tint from = ts.front() - 'a';\n\t\tint to = ts.back() - 'a';\n\t\ts[from][to]++;\n\t}\n}\n\n\n//�v�Z\nvoid calc()\n{\n\tREP(k, ALNUM) {\n\t\tint inAll = 0;\n\t\tint outAll = 0;\n\t\tREP(i, ALNUM) {\n\t\t\t//if (i == k)continue;\n\t\t\toutAll += s[k][i];\n\t\t\tinAll += s[i][k];\n\t\t}\n\t\tNetworkFlow nf(ALNUM + 1);\n\t\tREP(i, ALNUM)REP(j, ALNUM) {\n\t\t\t//if (i == j)continue;\n\t\t\tnf.add_edge(i, (j == k ? ALNUM : j), s[i][j]);\n\t\t}\n\t\tint roop = nf.max_flow(k, ALNUM);\n\t\t\n\t\tif (inAll != 0 && inAll >= outAll && outAll == roop)res[k] = true;\n\t\t//char t = 'a' + k;\n\t\t//string tmp;\n\t\t//tmp += t;\n\t\t//cout << tmp << \" \" << inAll << \" \" << roop << \" \" << outAll << endl;\n\t\t//cout << (in < out) << endl;\n\t\t//if (in > out)res[k] = true;\n\t}\n}\n\n\n//�o��\nvoid output()\n{\n\tREP(i, ALNUM)if (res[i]) {\n\t\tchar t = 'a' + i;\n\t\tstring tmp;\n\t\ttmp += t;\n\t\tcout << t << endl;\n\t}\n}\n\n\n//�f�o�b�O\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//���C���֐�\nint main()\n{\n\tinput();\n\tcalc();\n\toutput();\n\t//debug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass MaxFlow {\npublic:\n  struct edge { ll to, cap, rev; };\n\n  const ll INF = 1LL << 60;\n  ll N;\n  vector< vector<edge> > E;\n  vector<bool> used;\n\n  MaxFlow(ll n): N(n), E(n), used(n) {};\n\n  void add_directed_edge(ll from, ll to, ll cap) {\n    E[from].push_back((edge) { to, cap, (ll) E[to].size() });\n    E[to].push_back((edge) { from, 0, (ll) E[from].size() - 1 });\n  }\n\n  ll dfs(ll v, ll t, ll f) {\n    if(v == t) return f;\n    used[v] = true;\n    REP(i, 0, E[v].size()) {\n      edge &e = E[v][i];\n      if(!used[e.to] && e.cap > 0) {\n        ll d = dfs(e.to, t, min(f, e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          E[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  ll max_flow(ll s, ll t) {\n    ll flow = 0;\n    while(1) {\n      REP(i, 0, N) used[i] = false;\n      ll f = dfs(s, t, INF);\n      if(f == 0 || f == INF) break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nint main(void) {\n  ll N;\n  cin >> N;\n  vector<string> S(N);\n  REP(i, 0, N) cin >> S[i];\n\n  vector<bool> last(256, false);\n  REP(i, 0, N) last[S[i].back()] = true;\n\n  for (char c = 'a'; c <= 'z'; c++) if (last[c]) {\n    MaxFlow mf(28);\n    ll s = 26, t = 27;\n    ll cnt = 0;\n    REP(i, 0, N) {\n      char f = S[i].front(), b = S[i].back();\n      ll u = f == c ? s : f - 'a';\n      ll v = b == c ? t : b - 'a';\n      mf.add_directed_edge(u, v, 1);\n      if (u == s) cnt++;\n    }\n    ll flow = mf.max_flow(s, t);\n    if (cnt == flow) cout << c << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nstruct Graph\n{\n    Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to) { edge[from].push_back(to), rev_edge[to].push_back(from); }\n    const std::size_t V;\n    std::vector<std::vector<std::size_t>> edge, rev_edge;\n};\nint main()\n{\n    int n;\n    std::cin >> n;\n    constexpr int N = 26;\n    Graph g(N);\n    std::vector<int> in(N, 0), out(N, 0);\n    for (int i = 0; i < n; i++) {\n        std::string s;\n        std::cin >> s;\n        const int S = s.front() - 'a', T = s.back() - 'a';\n        g.addEdge(S, T);\n        in[T]++, out[S]++;\n    }\n    std::vector<bool> ok(N, false);\n    std::vector<bool> checked(N, false);\n    std::queue<int> q;\n    for (int i = 0; i < N; i++) {\n        if (in[i] > 0 and out[i] == 0) { checked[i] = ok[i] = true, q.push(i); }\n    }\n    while (not q.empty()) {\n        const int i = q.front();\n        checked[i] = true;\n        q.pop();\n        for (const int to : g.rev_edge[i]) {\n            if (out[to] == 1) { q.push(to); }\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        if (checked[i]) {\n            if (ok[i]) { std::cout << (char)(i + 'a') << std::endl; }\n        } else {\n            if (in[i] > 0 and out[i] <= in[i]) { std::cout << (char)(i + 'a') << std::endl; }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <string>\nusing namespace std;\n\nconst long long INF = (1ll << 50);\n\nstruct Dinic {\n  typedef long long flow_type;\n  struct edge {\n    int src, dst;\n    flow_type capacity, flow;\n    size_t rev;\n  };\n  int n;\n  vector<vector<edge>> adj;\n  Dinic(int n) : n(n), adj(n) { }\n  void add_edge(int src, int dst, flow_type capacity) {\n    adj[src].push_back({src, dst, capacity, 0, adj[dst].size()});\n    adj[dst].push_back({dst, src, 0, 0, adj[src].size()-1});\n  }\n  flow_type max_flow(int s, int t) {\n    vector<int> level(n), iter(n);\n    function<int(void)> levelize = [&]() { // foward levelize\n      level.assign(n, -1); level[s] = 0;\n      queue<int> Q; Q.push(s);\n      while (!Q.empty()) {\n        int u = Q.front(); Q.pop();\n        if (u == t) break;\n        for (auto &e: adj[u]) {\n          if (e.capacity > e.flow && level[e.dst] < 0) {\n            Q.push(e.dst);\n            level[e.dst] = level[u] + 1;\n          }\n        }\n      }\n      return level[t];\n    };\n    function<flow_type(int, flow_type)> augment = [&](int u, flow_type cur) {\n      if (u == t) return cur;\n      for (int &i = iter[u]; i < adj[u].size(); ++i) {\n        edge &e = adj[u][i], &r = adj[e.dst][e.rev];\n        if (e.capacity > e.flow && level[u] < level[e.dst]) {\n          flow_type f = augment(e.dst, min(cur, e.capacity - e.flow));\n          if (f > 0) {\n            e.flow += f;\n            r.flow -= f;\n            return f;\n          }\n        }\n      }\n      return flow_type(0);\n    };\n    for (int u = 0; u < n; ++u) // initialize\n      for (auto &e: adj[u]) e.flow = 0;\n\n    flow_type flow = 0;\n    while (levelize() >= 0) {\n      fill(iter.begin(), iter.end(), 0);\n      for (flow_type f; (f = augment(s, INF)) > 0; )\n        flow += f;\n    }\n    return flow;\n  }\n};\n\n\nint main(){\n\n    int n; cin >> n;\n    vector<string> str(n);\n    for(int i = 0; i < n; i++) cin >> str[i];\n    vector<bool> last(26, false);\n    for(int i = 0; i < n; i++) last[str[i].back() - 'a'] = true;\n\n    for(char c = 'a'; c <= 'z'; c++) if(last[c - 'a']) {\n        long long s = 26, t = 27;\n        long long cnt = 0;\n        Dinic G(28);\n\n\n        for(int i = 0; i < n; i++){\n            long long u = str[i].front() == c ? s : (long long)(str[i].front() - 'a');\n            long long v = str[i].back() == c ? t : (long long)(str[i].back() - 'a');\n            G.add_edge(u, v, 1);\n            if(str[i].front() == c) cnt++;\n        }\n        if(G.max_flow(s, t) == cnt) cout << c << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\n\n// edge class (for network-flow)\ntemplate<class FLOWTYPE> struct Edge {\n    int rev, from, to;\n    FLOWTYPE cap, icap;\n    Edge(int r, int f, int t, FLOWTYPE c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// graph class (for network-flow)\ntemplate<class FLOWTYPE> struct Graph {\n    vector<vector<Edge<FLOWTYPE> > > list;\n    \n    Graph(int n = 0) : list(n) { }\n    void init(int n = 0) { list.clear(); list.resize(n); }\n    void reset() { for (int i = 0; i < (int)list.size(); ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge<FLOWTYPE> >& operator [] (int i) { return list[i]; }\n    inline const size_t size() const { return list.size(); }\n    \n    inline Edge<FLOWTYPE> &redge(Edge<FLOWTYPE> e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n    \n    void addedge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, 0));\n    }\n    \n    void add_undirected_edge(int from, int to, FLOWTYPE cap) {\n        list[from].push_back(Edge<FLOWTYPE>((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge<FLOWTYPE>((int)list[from].size() - 1, to, from, cap));\n    }\n    \n    /*\n     // debug\n     friend ostream& operator << (ostream& s, const Graph& G) {\n     s << endl; for (int i = 0; i < G.V; ++i) { s << i << \" : \" << G.list[i] << endl; }return s;\n     }\n     */\n};\n\ntemplate<class FLOWTYPE> struct Dinic {\n    const FLOWTYPE INF = 1<<30; // to be set\n    vector<int> level, iter;\n    \n    Dinic() { }\n    void dibfs(Graph<FLOWTYPE> &G, int s) {\n        level.assign((int)G.size(), -1);\n        level[s] = 0;\n        queue<int> que;\n        que.push(s);\n        while (!que.empty()) {\n            int v = que.front();\n            que.pop();\n            for (int i = 0; i < G[v].size(); ++i) {\n                Edge<FLOWTYPE> &e = G[v][i];\n                if (level[e.to] < 0 && e.cap > 0) {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    \n    FLOWTYPE didfs(Graph<FLOWTYPE> &G, int v, int t, FLOWTYPE f) {\n        if (v == t) return f;\n        for (int &i = iter[v]; i < G[v].size(); ++i) {\n            Edge<FLOWTYPE> &e = G[v][i], &re = G.redge(e);\n            if (level[v] < level[e.to] && e.cap > 0) {\n                FLOWTYPE d = didfs(G, e.to, t, min(f, e.cap));\n                if (d > 0) {\n                    e.cap -= d;\n                    re.cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    FLOWTYPE solve(Graph<FLOWTYPE> &G, int s, int t) {\n        level.assign((int)G.size(), -1); iter.assign((int)G.size(), 0);\n        FLOWTYPE res = 0;\n        while (true) {\n            dibfs(G, s);\n            if (level[t] < 0) return res;\n            for (int i = 0; i < (int)iter.size(); ++i) iter[i] = 0;\n            FLOWTYPE flow = 0;\n            while ((flow = didfs(G, s, t, INF)) > 0) {\n                res += flow;\n            }\n        }\n    }\n};\n\n\nint main() {\n    int N; cin >> N;\n    vector<string> S(N); S.resize(N);\n    for (int i = 0; i < N; ++i) cin >> S[i];\n        \n    vector<char> res;\n    for (int ch = 0; ch < 26; ++ch) {\n        Graph<int> G(28);\n        int s = 26, t = 27;\n        int deg_out = 0, deg_in = 0;\n        for (int i = 0; i < N; ++i) {\n            int u = S[i][0] - 'a';\n            int v = S[i].back() - 'a';\n            if (u == ch) u = s, ++deg_out;\n            if (v == ch) v = t, ++deg_in;\n            G.addedge(u, v, 1);\n            }\n        Dinic<int> din;\n        int flow = din.solve(G, s, t);\n        if (flow >= deg_out && deg_in > 0) res.push_back((char)('a' + ch));\n    }\n    for (auto c : res) cout << c << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define INF 1000000000\n\nstruct max_flow\n{\n    int V;\n    struct edge{int to,cap,rev;};\n    using Graph=vector<vector<edge>>;\n    Graph graph;\n    vector<bool> visit;\npublic:\n    max_flow(int n) //与えられた頂点は別にスタートとシンクを設定する場合\n    {\n        V=n;\n        graph.resize(V+2,vector<edge> ());\n        visit.resize(V+2,false);\n    }\n\n    void add_edge(int from,int to, int cap)\n    {\n        graph[from].pb((edge){to,cap,(int)graph[to].size()});\n        graph[to].pb((edge){from,0,(int)graph[from].size()-1});\n        return ;\n    }\n\n    int dfs(int s, int t, int f)\n    {\n        if (s==t) return f;\n        visit[s]=true;\n        for (int i=0;i<graph[s].size();i++)\n        {\n            edge &e=graph[s][i];\n            if (!visit[e.to] && e.cap>0)\n            {\n                int d=dfs(e.to,t,min(f,e.cap));\n                if (d>0)\n                {\n                    e.cap-=d;\n                    graph[e.to][e.rev].cap+=d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    int run(int s,int t)\n    {\n        int flow=0;\n        for (;;) //while文\n        {\n            for (int i=0;i<V+2;i++) visit[i]=false;//memsetは初期化\n            int f=dfs(s,t,INF);\n            if (f==0) return flow;\n            else flow+=f;\n        }\n    }\n};\n\nint main()\n{\n    int N; cin >> N;\n    int cnt[28][28];string input;\n    for (int i=0;i<27;i++)\n        for (int j=0;j<27;j++) cnt[i][j]=0;\n    for (int i=0;i<N;i++)\n    {\n        cin >> input;\n        cnt[(int)input[0]-'a'][(int)input[input.size()-1]-'a']++;\n    }\n    vector<char> ans;\n    for (int s=0;s<26;s++)\n    {\n        max_flow solve(26);\n        for (int i=0;i<26;i++)\n        {\n            if (i!=s)\n            {\n                for (int j=0;j<26;j++)\n                {\n                    if (j!=s && cnt[i][j]>0 &&i!=j) solve.add_edge(i+1,j+1,cnt[i][j]);\n                }\n            }\n            else continue;\n        }\n        int sum=0;\n        bool ok=false;\n        if (cnt[s][s]>0) {ok=true;solve.add_edge(0,27,cnt[s][s]);}\n        for (int i=0;i<26;i++)\n        {\n            sum+=cnt[s][i];\n            if (cnt[s][i]>0 && i!=s ) solve.add_edge(0,i+1,cnt[s][i]);\n            if (cnt[i][s]>0 && i!=s) {solve.add_edge(i+1,27,cnt[i][s]);ok=true;}\n        }\n        if (solve.run(0,27)==sum && ok)\n        {\n            char a='a'+s;\n            ans.pb(a);\n        }\n    }\n    for (int i=0;i<ans.size();i++) cout << ans[i] << endl;\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n// (行き先,容量,逆辺)\nstruct edge{ int to,cap,rev; };\n\nconst int MAX_V = 30; // TODO:initialize\nconst int F_INF = 19191919; // TODO:initialize\nvector<edge> G[MAX_V];\nint level[MAX_V]; // sからの距離\nint iter[MAX_V]; // どこまで調べ終わったか\n\nvoid add_edge(int from, int to, int cap){\n    G[from].pb({to,cap,(int)G[to].size()});\n    G[to].pb({from,0,(int)G[from].size()-1});\n}\n\nvoid dinic_bfs(int s){\n    memset(level,-1,sizeof(level));\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n        int v = que.front();\n        que.pop();\n        rep(i,G[v].size()){\n            edge &e = G[v][i];\n            if(e.cap>0 && level[e.to]<0){\n                level[e.to] = level[v]+1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\n// 増加パスをdfsで探す\nint dinic_dfs(int v, int t, int f){\n    if(v==t) return f;\n    for(int &i=iter[v]; i<(int)G[v].size(); ++i){\n        edge &e=G[v][i];\n        if(e.cap>0 && level[v]<level[e.to]){\n            int d = dinic_dfs(e.to,t,min(f,e.cap));\n            if(d>0){\n                e.cap -= d;\n                G[e.to][e.rev].cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// sからtへの最大流\nint max_flow(int s, int t){\n    int flow = 0;\n    while(1){\n        dinic_bfs(s);\n        if(level[t]<0) return flow;\n        memset(iter,0,sizeof(iter));\n        int f;\n        while((f=dinic_dfs(s,t,F_INF))>0) flow+=f;\n    }\n}\n\nconst int A = 26;\nint ct[A][A]={};\n\nint main(){\n    int n;\n    cin >>n;\n\n    rep(i,n){\n        string s;\n        cin >>s;\n        int S = s.size();\n        ++ct[s[0]-'a'][s[S-1]-'a'];\n    }\n\n    rep(i,A){\n        bool exist = false;\n        rep(h,A)if(ct[h][i]) exist = true;\n        if(!exist) continue;\n\n        int S = A+1, T = S+1;\n        rep(j,MAX_V) G[j].clear();\n\n        int out = 0;\n        rep(j,A) out += ct[i][j];\n\n        bool ok = true;\n        rep(h,A)rep(t,A){\n            int u = h, v = t;\n            if(h==i) u=S;\n            if(t==i) v=T;\n            add_edge(u,v,ct[h][t]);\n        }\n\n        int f = max_flow(S,T);\n        // printf(\"%d %d\\n\",out,f);\n        if(out<=f) printf(\"%c\\n\", 'a'+i);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntemplate<typename flow_t>\nstruct Dinic {\n    struct Edge {\n        int to; flow_t cap; int rev; bool isrev;\n        Edge(int t, flow_t c, int r, bool b) : to(t), cap(c), rev(r), isrev(b) { }\n    };\n    const flow_t INF;\n    vector<vector<Edge>> g;\n    vector<int> min_cost, iter;\n    Dinic(int n) : INF(numeric_limits<flow_t>::max()), g(n) { }\n    void add_edge(int from, int to, flow_t cap) {\n        g[from].emplace_back(Edge(to, cap, g[to].size(), false));\n        g[to].emplace_back(Edge(from, 0, g[from].size() - 1, true));\n    }\n    bool bfs(int s, int t) {\n        min_cost.assign(g.size(), -1); min_cost[s] = 0;\n        queue<int> que; que.emplace(s);\n        while (!que.empty() && min_cost[t] == -1) {\n            int v = que.front(); que.pop();\n            for (auto &e: g[v]) if (e.cap > 0 && min_cost[e.to] == -1) {\n                min_cost[e.to] = min_cost[v] + 1;\n                que.emplace(e.to);\n            }\n        }\n        return min_cost[t] != -1;\n    }\n    flow_t dfs(int v, int t, flow_t flow) {\n        if (v == t) return flow;\n        for (int &i = iter[v]; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            if (e.cap > 0 && min_cost[v] < min_cost[e.to]) {\n                flow_t d = dfs(e.to, t, min(flow, e.cap));\n                if (d > 0) {\n                    e.cap -= d, g[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    flow_t max_flow(int s, int t) {\n        flow_t flow = 0;\n        while (bfs(s, t)) {\n            iter.assign(g.size(), 0);\n            flow_t f = 0;\n            while ((f = dfs(s, t, INF)) > 0) flow += f;\n        }\n        return flow;\n    }\n    friend ostream& operator<<(ostream& os, Dinic& mf) {\n        for (int i = 0; i < (int)mf.g.size(); i++) {\n            for (auto &e: mf.g[i]) if (!e.isrev) {\n                auto &rev_e = mf.g[e.to][e.rev];\n                os << i << \" -> \" << e.to << \" (flow: \";\n                os << rev_e.cap << \" / \" << e.cap + rev_e.cap << \")\" << endl;\n            }\n        }\n        return os;\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    vector<string> ss(n);\n    for (auto &si: ss) cin >> si;\n    string ans;\n    for (int c = 0; c < 26; c++) {\n        Dinic<int> mf(26 + 2);\n        int s = 26, t = s + 1;\n        int deg_out = 0, deg_in = 0;\n        for (auto &si: ss) {\n            int u = si.front() - 'a', v = si.back() - 'a';\n            if (u == c) u = s, deg_out++;\n            if (v == c) v = t, deg_in++;\n            mf.add_edge(u, v, 1);\n        }\n        if (deg_in && mf.max_flow(s, t) == deg_out) ans += 'a' + c;\n    }\n    for (char c: ans) cout << c << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nstruct Dinic{\n  \n  struct edge {\n    int to, cap, rev;\n    edge(int a, int b, int c):to(a),cap(b),rev(c){}\n  };\n  \n  vector<vector<edge> > G;\n  vector<int> level, iter;\n  int MAX_V;\n  \n  Dinic(int max_v):G(max_v,vector<edge>()),MAX_V(max_v){}\n  \n  int add_edge(int from,int to,int cap){\n    int id = G[from].size();\n    \n    G[from].push_back(edge(to,cap,G[to].size()));\n    G[to].push_back(edge(from,0,G[from].size() - 1));\n    \n    return id;\n  }\n  \n  void bfs(int s){\n    level.assign(MAX_V,-1);\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while(q.size()){\n      int v = q.front(); q.pop();\n      for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v];i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min(f,e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \n  int solve(int s, int t){\n    int flow = 0;\n    while(1){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.assign(MAX_V,0);\n      int f;\n      while((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n  }\n  \n};\n\nint main(){\n  int n;\n  string s;\n  int count[26][26] = {};\n  \n  cin >> n;\n  \n  for(int i=0;i<n;i++){\n    cin >> s;\n    count[s[0]-'a'][s[s.size()-1]-'a']++;\n  }\n\n  for(int i=0;i<26;i++){\n    int sum = 0; bool f = false;\n    \n    Dinic d(28), d2(30);\n\n    for(int j=0;j<26;j++) sum += count[i][j] * (i != j);\n    for(int j=0;j<26;j++) f |= count[j][i];\n\n    if(!f) continue;\n    \n    for(int j=0;j<26;j++){\n      for(int k=0;k<26;k++){\n        if(j == k) continue;\n\n        if(j == i){\n          d.add_edge(26, k, count[j][k]);\n          d2.add_edge(26, k, count[j][k]);\n        }else if(k == i){\n          d.add_edge(j, 27, count[j][k]);\n          d2.add_edge(j, 27, count[j][k]);\n        }else{\n          d.add_edge(j, k, count[j][k]);\n          d2.add_edge(j, k, count[j][k]);\n        }\n      }\n    }\n\n    d2.add_edge(28, 26, sum);\n    d2.add_edge(28, 29, 1);\n    for(int j=0;j<26;j++) if(i != j) d2.add_edge(29, j, 1);\n    \n    auto flow = d.solve(26, 27);\n    auto flow2 = d2.solve(26, 27);\n\n    if(flow == sum || flow2 == sum+1){\n      printf(\"%c\\n\", i+'a');\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max() / 2;\n\nclass Dinic\n{\n    using type = int;\n    const int INF = 1e9;\n    struct Edge\n    {\n        // 行き先, 容量, 逆辺\n        int to;\n        type cap;\n        int rev;\n        Edge(int _t, type _c, int _r) : to(_t), cap(_c), rev(_r) {}\n    };\n\n    using Graph = std::vector<std::vector<Edge>>;\n    int V;\n    Graph G;\n    // s からの最短距離\n    std::vector<int> level;\n    // 訪問済みか\n    std::vector<int> iter;\n\n    void bfs(int s)\n    {\n        fill(level.begin(), level.end(), -1);\n        std::queue<int> que;\n        level[s] = 0;\n        que.push(s);\n        while (!que.empty())\n        {\n            int v = que.front();\n            que.pop();\n            for (const auto &e : G[v])\n            {\n                if (e.cap > 0 && level[e.to] < 0)\n                {\n                    level[e.to] = level[v] + 1;\n                    que.push(e.to);\n                }\n            }\n        }\n    }\n    // 増加パスを探す\n    type dfs(int v, int t, type f)\n    {\n        if (v == t)\n            return f;\n        for (int &i = iter[v]; i < (int)G[v].size(); i++)\n        {\n            Edge &e = G[v][i];\n            if (e.cap > 0 && level[v] < level[e.to])\n            {\n                type d = dfs(e.to, t, std::min(f, e.cap));\n                if (d > 0)\n                {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\npublic:\n    Dinic(int _v) : V(_v), G(_v), level(_v), iter(_v) {}\n    void add(int from, int to, type cap)\n    {\n        G[from].push_back(Edge{to, cap, (int)G[to].size()});\n        G[to].push_back(Edge{from, 0, (int)G[from].size() - 1});\n    }\n    type maxFlow(int s, int t)\n    {\n        type ret = 0;\n        while (true)\n        {\n            bfs(s);\n            if (level[t] < 0)\n                return ret;\n            fill(iter.begin(), iter.end(), 0);\n            type f;\n            while ((f = dfs(s, t, INF)) > 0)\n            {\n                ret += f;\n            }\n        }\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    vector<vector<int>> cnt(26, vector<int>(26, 0));\n    for (int i = 0; i < n; i++)\n    {\n        string s;\n        cin >> s;\n        int len = s.size();\n        cnt[s[0] - 'a'][s[len - 1] - 'a']++;\n    }\n    for (char c = 0 /* a */; c < 26 /* z */; c++)\n    {\n        int sz = 26 * 26;\n        int src = 0, dest = sz * 2 + 1;\n        Dinic g(2 * sz + 2);\n        int sum = 0, sum2 = 0;\n        for (int i = 0; i < 26; i++)\n        {\n            for (int j = 0; j < 26; j++)\n            {\n                // i/j\n                int st = 26 * i + j + 1, gt = st + sz;\n                g.add(st, gt, cnt[i][j]);\n                if (i == c)\n                {\n                    g.add(src, st, INF);\n                    sum += cnt[i][j];\n                }\n                if (j == c)\n                {\n                    g.add(gt, dest, INF);\n                    sum2 += cnt[i][j];\n                }\n                for (int k = 0; k < 26; k++)\n                {\n                    // j/k\n                    int st2 = 26 * j + k + 1;\n                    g.add(gt, st2, INF);\n                }\n            }\n        }\n        int f = g.maxFlow(src, dest);\n        if (sum2 && f >= sum)\n            cout << (char)('a' + c) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct Dinic{\n  const int INF=1<<28;\n  \n  struct edge {\n    int to,cap,rev;\n    edge(){}\n    edge(int to,int cap,int rev):to(to),cap(cap),rev(rev){}\n  };\n\n  int n;\n  vector<vector<edge> > G;\n  vector<map<int,int> > M;\n  vector<int> level,iter;\n\n  Dinic(){}\n  Dinic(int sz):n(sz),G(n),M(n),level(n),iter(n){}\n  \n  void add_edge(int from,int to,int cap){\n    M[from][to]=G[from].size();\n    M[to][from]=G[to].size();\n    G[from].push_back(edge(to,cap,G[to].size()));\n    // undirected\n    //G[to].push_back(edge(from,cap,G[from].size()-1));\n    // directed\n    G[to].push_back(edge(from,0,G[from].size()-1));\n  }\n  \n  void bfs(int s){\n    fill(level.begin(),level.end(),-1);\n    queue<int> que;\n    level[s]=0;\n    que.push(s);\n    while(!que.empty()){\n      int v=que.front();que.pop();\n      for(int i=0;i<(int)G[v].size();i++){\n\tedge &e = G[v][i];\n\tif(e.cap>0&&level[e.to]<0){\n\t  level[e.to]=level[v]+1;\n\t  que.push(e.to);\n\t}\n      }\n    }\n  }\n  \n  int dfs(int v,int t,int f){\n    if(v==t) return f;\n    for(int &i=iter[v];i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[v]<level[e.to]){\n\tint d = dfs(e.to,t,min(f,e.cap));\n\tif(d>0){\n\t  e.cap-=d;\n\t  G[e.to][e.rev].cap+=d;\n\t  return d;\n\t}\n      }\n    }\n    return 0;\n  }\n  \n  int flow(int s,int t,int lim){\n    int fl=0;\n    for(;;){\n      bfs(s);\n      if(level[t]<0||lim==0) return fl;\n      fill(iter.begin(),iter.end(),0);\n      int f;\n      while((f=dfs(s,t,lim))>0){\n\tfl+=f;\n\tlim-=f;\n      }\n    }\n  }\n\n  int flow(int s,int t){\n    return flow(s,t,INF);\n  }\n\n  //cap==1 only\n  bool back_edge(int s,int t,int from, int to){\n    for(int i=0;i<(int)G[from].size();i++) {\n      edge& e=G[from][i];\n      if(e.to==to) {\n\tif(e.cap==0&&flow(from,to,1)==0) {\n\t  flow(from,s,1);\n\t  flow(t,to,1);\n\t  return 1;\n\t}\n      }\n    }\n    return 0;\n  }\n};\n\n//INSERT ABOVE HERE\nconst int K = 28;\nint cap[K][K];\nsigned main(){\n  int n;\n  cin>>n;\n  vector<string> s(n);\n  for(int i=0;i<n;i++) cin>>s[i];\n\n  for(int i=0;i<26;i++){\n    Dinic flow(K);\n    int x=26,y=27,z=0,e=0;\n    memset(cap,0,sizeof(cap));\n    for(int j=0;j<n;j++){\n      int u=s[j].front()-'a';\n      int v=s[j].back()-'a';\n      if(u==i) z++;\n      if(v==i) e++;\n      if(u==i) u=x;\n      if(v==i) v=y;\n      if(u!=v) cap[u][v]++;\n    }\n    for(int u=0;u<K;u++)\n      for(int v=0;v<K;v++)\n\tif(cap[u][v]) flow.add_edge(u,v,cap[u][v]);\n    if((e&&!z)||(z&&flow.flow(x,y)==z)) cout<<char('a'+i)<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n#define mod 1000000007\n\n#define MAX_V 30\n\nstruct edge{ int to,cap,rev; };\nvector<edge> G[MAX_V];\nint level[MAX_V];\nint iter[MAX_V];\n\nvoid add_edge(int from,int to,int cap){\n  G[from].push_back((edge){to,cap,(int)G[to].size()});\n  G[to].push_back((edge){from,0,(int)G[from].size()-1});\n}\n\nvoid bfs(int s){\n  memset(level,-1,sizeof(level));\n  queue<int> que;\n  level[s]=0;\n  que.push(s);\n  while(!que.empty()){\n    int v=que.front(); que.pop();\n    for(int i=0;i<(int)G[v].size();i++){\n      edge &e=G[v][i];\n      if(e.cap>0&&level[e.to]<0){\n        level[e.to]=level[v]+1;\n        que.push(e.to);\n      }\n    }\n  }\n}\n\nint dfs(int v,int t,int f){\n  if(v==t)return f;\n  for(int &i=iter[v];i<(int)G[v].size();i++){\n    edge &e=G[v][i];\n    if(e.cap>0&&level[v]<level[e.to]){\n      int d=dfs(e.to,t,min(f,e.cap));\n      if(d>0){\n        e.cap-=d;\n        G[e.to][e.rev].cap+=d;\n        return d;\n      }\n    }\n  }\n  return 0;\n}\n\nint max_flow(int s,int t){\n  int flow=0;\n  while(1){\n    bfs(s);\n    if(level[t]<0)return flow;\n    memset(iter,0,sizeof(iter));\n    int f;\n    while((f=dfs(s,t,INF))>0){\n      flow+=f;\n    }\n  }\n}\n\nint N;\nstring S[10001];\nvector<char> p,s;\nint incnt[26],cnt[26];\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    cin>>S[i];\n    p.push_back(S[i][0]);\n    s.push_back(S[i][S[i].size()-1]);\n    incnt[S[i][S[i].size()-1]-'a']++;\n    cnt[S[i][0]-'a']++;\n  }\n  rep(i,26){\n    if(incnt[i]==0)continue;\n    //dbg(incnt[i]);\n    //dbg(cnt[i]);\n    rep(j,27)G[j].clear();\n    rep(j,N){\n      if(s[j]=='a'+i){\n        add_edge(p[j]-'a',26,1);\n      }else{\n        add_edge(p[j]-'a',s[j]-'a',1);\n      }\n    }\n    //dbg(max_flow(i,26));\n    if(cnt[i]<=max_flow(i,26)){\n      cout<<(char)('a'+i)<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y sevcond\n#define pb emplace_back\n#define eb pb\n#define rep(X,Y) for(int X=0;X<(Y);++X)\n#define reps(X,O,Y) for(int X=(O);X<(Y);++X)\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\nusing ll=long long;\n\nusing Cost=ll;\nusing Cap=ll;\nstruct Edge{int to,rev;Cap cap;Cost cost;};\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nvoid add_edge(Graph &g,int f,int t, ll cap){\n\tg[f].pb((Edge){t,(int)g[t].size(),cap,0});\n\tg[t].pb((Edge){f,(int)g[f].size()-1,0,0});\n}\nCost INF=2e11;\nvector<int> used;\nCap dfs(Graph &g,int v,int t,Cap f){\n\tif(v==t) return f;\n\tused[v]=1;\n\tfor(Edge &e:g[v]){\n\t\tif(e.cap<=0 || used[e.to]) continue;\n\t\tCap d=dfs(g,e.to,t,min(f,e.cap));\n\t\tif(d>0){\n\t\t\te.cap-=d;\n\t\t\tg[e.to][e.rev].cap+=d;\n\t\t\treturn d;\n\t\t}\n\t}\n\treturn 0;\n}\n\nCap max_flow(Graph &g,int s,int t){\n\tCap sum=0,f;\n\tint V=g.size();\n\twhile(1){\n\t\tused.resize(V);\n\t\tfill(all(used),0);\n\t\tsum+=f=dfs(g,s,t,INF);\n\t\tif(!f) return sum;\n\t}\n}\n\nint cnt[222][222];\n\nint main(){\n\tint n;\n\tcin>>n;\n\trep(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\t++cnt[s[0]][s[s.size()-1]];\n\t}\n\tvector<char> re;\n\treps(c,'a','z'+1){\n\t\tGraph g(28);\n\t\trep(i,26)if(i+'a'!=c)rep(j,26)if(i!=j && j+'a'!=c) add_edge(g,i,j,cnt[i+'a'][j+'a']);\n\t\tint sum=0,ok=cnt[c][c];\n\t\trep(i,26)if(i+'a'!=c){\n\t\t\tsum+=cnt[c][i+'a'];\n\t\t\tadd_edge(g,26,i,cnt[c][i+'a']);\n\t\t\tif(cnt[i+'a'][c]) ok=1;\n\t\t\tadd_edge(g,i,27,cnt[i+'a'][c]);\n\t\t}\n\t\tif(ok && max_flow(g,26,27)==sum) re.pb(c);\n\t}\n\tfor(char c:re) cout<<c<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define FORR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n\n#define MOD 1000000007\nstatic const ll INF = 1000000000000000ll;\n\nint n;\nint cnt[26][26];\n\nstruct dinic{\n  struct edge{int to;ll cost;};\n  int n;\n  vector< vector<edge> > G;\n  vector<vl> flow, capacity;\n#define RESIDUE(s,t) (capacity[s][t]-flow[s][t])\n  vi level;\n  vector<bool> finished;\n  dinic(int _n){\n    n = _n;\n    G.assign(n,vector<edge>());\n    flow.assign(n,vl(n,0));\n    capacity.assign(n,vl(n,0));\n    level.assign(n,0);\n    finished.assign(n,false);\n  }\n  void add_edge(int from,int to,ll cost){\n    assert(0<=from && from<n);\n    assert(0<=to && to<n);\n    G[from].push_back((edge){to,cost});\n    G[to].push_back((edge){from,0ll});  // 逆に流すフローのためのダミー辺\n  }\n  ll dfs(int u, int t, ll cur){\n    if(u==t || cur==0) return cur;\n    if(finished[u]) return 0;\n    finished[u] = true;\n    REP(i,G[u].size()){\n      edge e = G[u][i];\n      if(level[e.to] > level[u]){\n        ll f = dfs(e.to, t, min(cur, RESIDUE(u,e.to)));\n        if(f>0){\n          flow[u][e.to] += f;\n          flow[e.to][u] -= f;\n          finished[u] = false;\n          return f;\n        }\n      }\n    }\n    return 0;\n  }\n  ll calc(int s, int t){\n    REP(i,n)REP(j,n)flow[i][j]=capacity[i][j]=0;\n    REP(u,n)REP(j,G[u].size()){\n      edge e = G[u][j];\n      capacity[u][e.to] += e.cost;\n    }\n    ll total = 0;\n    while(true){\n      REP(i,n)level[i] = -1;\n      level[s] = 0;\n      queue<int> Q; Q.push(s);\n      int d = n;\n      while(!Q.empty()){\n        int u = Q.front(); Q.pop();\n        REP(i,G[u].size()){\n          edge e = G[u][i];\n          if(RESIDUE(u,e.to) > 0 && level[e.to] == -1){\n            Q.push(e.to);\n            level[e.to] = level[u] + 1;\n          }\n        }\n      }\n      REP(i,n)finished[i]=false;\n      bool flag = false;\n      while(true){\n        ll f = dfs(s,t,INF);\n        if(f==0)break;\n        total += f;\n        flag = true;\n      }\n      if(!flag)break;\n    }\n    return total;\n  }\n};\n\nchar buf[1252];\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n){\n    scanf(\"%s\",buf);\n    int ln = strlen(buf);\n    int a = buf[0]-'a';\n    int b = buf[ln-1]-'a';\n    cnt[a][b]++;\n    REP(i,ln)buf[i]='\\0';\n  }\n  REP(i,26){\n    // can end at i?\n    int indeg = 0, outdeg = 0;\n    REP(j,26){\n      indeg += cnt[j][i];\n      outdeg += cnt[i][j];\n    }\n    if(indeg == 0)continue;\n    indeg -= cnt[i][i];\n    outdeg -= cnt[i][i];\n    dinic D(28);\n    REP(a,26)REP(b,26){\n      if(a==i || b==i)continue;\n      D.add_edge(a,b,cnt[a][b]);\n    }\n    REP(a,26)if(a!=i){\n      D.add_edge(26,a,cnt[i][a]);\n      D.add_edge(a,27,cnt[a][i]);\n    }\n    if(D.calc(26,27)==outdeg){\n      putchar('a'+i);putchar('\\n');\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//sub-BOF\n#define _AOJ_\n        /*vvv>\n        zzzzzI\n .---.  zzuzuI                 .vgggg&,.\n+++++=  dAC:|I  .WbbWo       JMM9^```?TMB`  ..&gNNg,.   gggggggJ,   qgggggggg] (&&&&&&&&[   c+OA&J,   (&&&&&&+J,   .cJeAA&-.  (&&&&&&&&x   .&AA&=-.\n+++++=  dTqk|I  Xpbpbp      JM#`           (M#^   ?MMp  MM|   +TMN. JMF      ' |yk      ` dVY    7Vk,  Vy     XV  cVf     ?Y!  JM         V$      `\n+++++=  dcf:|I  Xppppp      dMN           .MM+     .MM  MM|     MM] JMMMMMM+   |@tqkoh)  ,y0      (V$  yyyyyyyV7  VV           JMWyZWr    TWVVVVW&,\n++++++  d7qk|0  Xppppp      ^HMN,    _.db  WMm,   .MMF  MM|   ..MM` JMF      . |yk       .WV&.   .XW'  yy   4yn.  jyn      +.  JM                #S\n`++++`  ?ZZZX=  ?WWWW=        -THMMMMH9^    (TMMMMM9!   MMMMMMM\"\"   JMMMMMMMME |UU.        ?TUUUUY=    UU.   (UU-  ^7TUUUV7!   JUUUUUUUU  7TUNKO*/\n\n\n//basic\n#pragma GCC target(\"sse4\")\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long lint;\ntypedef long double ld;\ntypedef string cs;\n#define all(v) v.begin(),v.end()\n#define pb push_back\n\n//rep\n#define _vcppunko4(tuple) _getname4 tuple\n#define _getname4(_1,_2,_3,_4,name,...) name\n#define _getname3(_1,_2,_3,name,...) name\n#define _trep2(tuple) _rep2 tuple\n#define _trep3(tuple) _rep3 tuple\n#define _trep4(tuple) _rep4 tuple\n#define _rep1(n) for(lint i=0;i<n;++i)\n#define _rep2(i,n) for(lint i=0;i<n;++i)\n#define _rep3(i,a,b) for(lint i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(lint i=a;i<b;i+=c)\n#define _trrep2(tuple) _rrep2 tuple\n#define _trrep3(tuple) _rrep3 tuple\n#define _trrep4(tuple) _rrep4 tuple\n#define _rrep1(n) for(lint i=n-1;i>=0;--i)\n#define _rrep2(i,n) for(lint i=n-1;i>=0;--i)\n#define _rrep3(i,a,b) for(lint i=b-1;i>=a;--i)\n#define _rrep4(i,a,b,c) for(lint i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rep(...) _vcppunko4((__VA_ARGS__,_trep4,_trep3,_trep2,_rep1))((__VA_ARGS__))\n#define per(...) _vcppunko4((__VA_ARGS__,_trrep4,_trrep3,_trrep2,_rrep1))((__VA_ARGS__))\n#define each(c) for(auto &e:c)\n\n//io\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator>>(istream& is,array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p);\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec);\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p);\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p){ os<<p.first<<\" \"<<p.second;return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec){ os<<vec[0];rep(i,1,vec.size())os<<' '<<vec[i];return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,deque<T>& deq){ os<<deq[0];rep(i,1,deq.size())os<<' '<<deq[i];return os; }\n\n\ninline void in(){}\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){ cin>>head;in(move(tail)...); }\ninline bool out(){ return(cout<<'\\n',0); }\ntemplate <class T>\ninline bool out(T t){ return(cout<<t<<'\\n',0); }\ntemplate <class Head,class... Tail>\ninline bool out(Head head,Tail... tail){ cout<<head<<' ';out(move(tail)...);return 0; }\ntemplate <class T>\ninline void alloc(T &c,lint s){ rep(c.size())c[i].resize(s); }\n#define alc alloc\n\n//TA\n#define lin(...) lint __VA_ARGS__;in(__VA_ARGS__)\n#define stin(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define vin(type,name,size) vector<type> name(size);in(name)\n#define fi e.first\n#define se e.second\n#define YES(c) cout<<((c)?\"YES\\n\":\"NO\\n\"),0\n#define Yes(c) cout<<((c)?\"Yes\\n\":\"No\\n\"),0\n#define POSSIBLE(c) cout<<((c)?\"POSSIBLE\\n\":\"IMPOSSIBLE\\n\"),0\n#define Possible(c) cout<<((c)?\"Possible\\n\":\"Impossible\\n\"),0\n#define o(p) cout<<p<<endl,0\n#define sp(p) cout<<p<<\" \"\n#define no(p) cout<<p\n#define chmin(l,r) l=min(l,r)\n#define chmax(l,r) l=max(l,r)\n#define ve(type) vector<type>\n\n//other\n#ifdef __ENV_TQK__\n#define deb(p) cout<<p<<endl,0\n#else\n#define deb(p) 0\n#endif\nstruct Fastio{\n\tFastio(){\n\t\tcin.tie(0),cout.tie(0);\n\t\tios::sync_with_stdio(0);\n\t\tcout<<fixed<<setprecision(10);\n\t}\n} __fastio;\n\n//mint\n#define md_tmp template<uint_fast64_t md=1000000007>\nmd_tmp class mint{\n\tusing u64=uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr mint(const u64 x=0) noexcept: a(x%md){}\n\tconstexpr u64 &value() noexcept{ return a; }\n\tconstexpr const u64 &value() const noexcept{ return a; }\n\tconstexpr mint operator+(const mint rhs) const noexcept{\n\t\treturn mint(*this)+=rhs;\n\t}\n\tconstexpr mint operator-(const mint rhs) const noexcept{\n\t\treturn mint(*this)-=rhs;\n\t}\n\tconstexpr mint operator*(const mint rhs) const noexcept{\n\t\treturn mint(*this)*=rhs;\n\t}\n\tconstexpr mint operator^(const lint rhs) const noexcept{\n\t\treturn mint(*this)^=rhs;\n\t}\n\tconstexpr mint operator/(const mint rhs) const noexcept{\n\t\treturn mint(*this)/=rhs;\n\t}\n\tconstexpr mint &operator+=(const mint rhs) noexcept{\n\t\ta+=rhs.a;\n\t\tif(a>=md)a-=md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator-=(const mint rhs) noexcept{\n\t\tif(a<rhs.a)a+=md;\n\t\ta-=rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator*=(const mint rhs) noexcept{\n\t\ta=a*rhs.a%md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator^=(const lint rhs) noexcept{\n\t\tif(!rhs)return *this=1;\n\t\tu64 exp=rhs-1;\n\t\tmint base=this->a;\n\t\twhile(exp){\n\t\t\tif(exp&1)*this*=base;\n\t\t\tbase*=base;\n\t\t\texp>>=1;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator/=(const mint rhs) noexcept{\n\t\ta=(*this*(rhs^(md-2))).a;\n\t\treturn *this;\n\t}\n};\nmd_tmp istream& operator>>(istream& os,mint<md>& m){\n\tos>>m.a,m.a%=md;\n\treturn os;\n}\nmd_tmp ostream& operator<<(ostream& os,const mint<md>& m){\n\treturn os<<m.a;\n}\nmd_tmp mint<md> ncr(lint n,lint r){\n\tif(n<r||n<0||r<0)return mint<md>(0);\n\tmint<md>ncr_res=1,ncr_div=1;\n\trep(r)ncr_res*=(n-i),ncr_div*=(r-i);\n\treturn ncr_res/ncr_div;\n}\n#ifndef _AOJ_\nmint<> operator\"\"m(unsigned long long n){ return mint<>(n); }\nmint<998244353> operator\"\"m9(unsigned long long n){ return mint<998244353>(n); }\nmint<1000003> operator\"\"m3(unsigned long long n){ return mint<1000003>(n); }\n#endif\n\n\n\n//const\n#define linf 1152921504606846976\n#define inf linf\n#define MAXN 330\n#define md_1e9_7 1000000007\n#define md_998244353 998244353\n#define pi 3.14159265358979323846\n//#define mod md_1e9_7\nconst int d4[5]={0,1,0,-1,0};\n\n//main------\n\nclass P{ public:lint f,s; P(lint a,lint b):f(a),s(b){}; P():f(0),s(0){}; };\nistream& operator>>(istream& os,P& p){ os>>p.f>>p.s;return os; }\nbool operator<(const P& l,const P& r){ return(l.f-r.f?l.f<r.f:l.s<r.s); }\nbool operator>(const P& l,const P& r){ return(l.f-r.f?l.f>r.f:l.s>r.s); }\n\ntemplate< typename T >\nstruct Dinic{\n\tstruct edge{\n\t\tint to;\n\t\tT cap;\n\t\tint rev;\n\t\tedge(int t,T c,int r):to(t),cap(c),rev(r){}\n\t};\n\n\tconst T INF;\n\tvector< vector< edge > > graph;\n\tvector< T > min_cost;\n\tvector< int > iter;\n\n\tDinic(int n): INF(numeric_limits< T >::max()){\n\t\tgraph.resize(n);\n\t}\n\n\tvoid add_edge(int from,int to,T cap){\n\t\tgraph[from].push_back(edge( to,cap,(int)graph[to].size() ));\n\t\tgraph[to].push_back(edge( from,0,(int)graph[from].size() - 1 ));\n\t}\n\n\tbool bfs(int s,int t){\n\t\tmin_cost.assign(graph.size(),-1);\n\t\tqueue< int > que;\n\t\tmin_cost[s] = 0;\n\t\tque.push(s);\n\t\twhile(!que.empty()){\n\t\t\tint p = que.front();\n\t\t\tque.pop();\n\t\t\tfor(auto &e : graph[p]){\n\t\t\t\tif(e.cap > 0 && min_cost[e.to] == -1){\n\t\t\t\t\tmin_cost[e.to] = min_cost[p] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (min_cost[t] != -1);\n\t}\n\n\tT dfs(int idx,const int t,T flow){\n\t\tif(idx == t) return (flow);\n\t\tfor(int &i = iter[idx]; i < graph[idx].size(); i++){\n\t\t\tedge &e = graph[idx][i];\n\t\t\tif(e.cap > 0 && min_cost[idx] < min_cost[e.to]){\n\t\t\t\tT d = dfs(e.to,t,min(flow,e.cap));\n\t\t\t\tif(d > 0){\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tgraph[e.to][e.rev].cap += d;\n\t\t\t\t\treturn (d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn (0);\n\t}\n\n\tT max_flow(int s,int t){\n\t\tT flow = 0;\n\t\twhile(bfs(s,t)){\n\t\t\titer.assign(graph.size(),0);\n\t\t\tT f = 0;\n\t\t\twhile((f = dfs(s,t,INF)) > 0){\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t\treturn (flow);\n\t}\n};\n\n\nint main(){\n\tlint n;in(n);\n\tvector<P> a(n);\n\tstring s;\n\trep(n)in(s),a[i]={s[0]-'a',s[s.size()-1]-'a'};\n\trep(26){\n\t\tDinic<lint> G(27);\n\t\tlint ideg=0,odeg=0;\n\t\teach(a){\n\t\t\tif(e.s==i)++ideg;\n\t\t\tif(e.f==i){\n\t\t\t\t++odeg;\n\t\t\t\tG.add_edge(26,e.s,1l);\n\t\t\t} else{\n\t\t\t\tG.add_edge(e.f,e.s,1l);\n\t\t\t}\n\t\t}\n\t\tif(ideg&&ideg>=odeg&&G.max_flow(26,i)==odeg)o(char('a'+i));\n\t}\n}\n\n//sub-EOF\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\nstruct Dinic{\n  \n  struct edge {\n    int to, cap, rev;\n    edge(int a, int b, int c):to(a),cap(b),rev(c){}\n  };\n  \n  vector<vector<edge> > G;\n  vector<int> level, iter;\n  int MAX_V;\n  \n  Dinic(int max_v):G(max_v,vector<edge>()),MAX_V(max_v){}\n  \n  int add_edge(int from,int to,int cap){\n    int id = G[from].size();\n    \n    G[from].push_back(edge(to,cap,G[to].size()));\n    G[to].push_back(edge(from,0,G[from].size() - 1));\n    \n    return id;\n  }\n  \n  void bfs(int s){\n    level.assign(MAX_V,-1);\n    queue<int> q;\n    level[s] = 0;\n    q.push(s);\n    while(q.size()){\n      int v = q.front(); q.pop();\n      for(int i=0;i<G[v].size();i++){\n        edge &e = G[v][i];\n        if(e.cap > 0 && level[e.to] < 0){\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n  \n  int dfs(int v, int t, int f){\n    if(v == t) return f;\n    for(int &i = iter[v];i < G[v].size(); i++){\n      edge &e = G[v][i];\n      if(e.cap > 0 && level[v] < level[e.to]){\n        int d = dfs(e.to, t, min(f,e.cap));\n        if(d > 0){\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n  \n  int solve(int s, int t){\n    int flow = 0;\n    while(1){\n      bfs(s);\n      if(level[t] < 0) return flow;\n      iter.assign(MAX_V,0);\n      int f;\n      while((f = dfs(s, t, INF)) > 0) flow += f;\n    }\n  }\n  \n};\n\nint main(){\n  int n;\n  string s;\n\n  int count[26][26] = {};\n  \n  cin >> n;\n  for(int i=0;i<n;i++){\n    cin >> s;\n    count[s[0]-'a'][s[s.size()-1]-'a']++;\n  }\n\n  for(int i=0;i<26;i++){\n    int sum = 0; bool f = false;\n    \n    Dinic d(28), d2(30);\n\n    for(int j=0;j<26;j++) sum += count[i][j] * (i != j);\n    for(int j=0;j<26;j++) f |= count[j][i];\n\n    if(!f) continue;\n    \n    //debug(sum);\n    \n    for(int j=0;j<26;j++){\n      for(int k=0;k<26;k++){\n        if(j == k) continue;\n\n        if(j == i){\n          d.add_edge(26, k, count[j][k]);\n          d2.add_edge(26, k, count[j][k]);\n        }else if(k == i){\n          d.add_edge(j, 27, count[j][k]);\n          d2.add_edge(j, 27, count[j][k]);\n        }else{\n          d.add_edge(j, k, count[j][k]);\n          d2.add_edge(j, k, count[j][k]);\n        }\n      }\n    }\n\n    d2.add_edge(28, 26, sum);\n    d2.add_edge(28, 29, 1);\n    for(int j=0;j<26;j++) if(i != j) d2.add_edge(29, j, 1);\n    \n    auto flow = d.solve(26, 27);\n    auto flow2 = d2.solve(26, 27);\n\n    if(flow == sum || flow2 == sum+1){\n      printf(\"%c\\n\", i+'a');\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\ntemplate<typename T> class Dinic {\npublic:\n    struct edge{\n        int to;\n        T cap;\n        int rev;\n    };\n    vector<vector<edge> > G;\n    vector<int> level,iter;\n    int n;\n    Dinic(int node_size){\n        n = node_size;\n        G.resize(node_size),level.resize(node_size),iter.resize(node_size);\n    }\n    //辺を張る\n    void add_edge(int from,int to,T cap)\n    {\n    \tG[from].push_back((edge){to,cap,(int)G[to].size()});\n    \tG[to].push_back((edge){from,(T)0,(int)G[from].size()-1});\n    }\n    void bfs(int s)\n    {\n    \tfill(level.begin(),level.end(),-1);\n    \tqueue<int> que;\n    \tlevel[s] = 0;\n    \tque.push(s);\n    \twhile(!que.empty()){\n    \t\tint v = que.front();\n    \t\tque.pop();\n    \t\tfor(auto& e : G[v]){\n    \t\t\tif(e.cap > 0 && level[e.to] < 0){\n    \t\t\t\tlevel[e.to] = level[v] + 1;\n    \t\t\t\tque.push(e.to);\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n    T dfs(int v,int t,T f)\n    {\n    \tif(v==t){\n    \t\treturn f;\n    \t}\n    \tfor(int &i = iter[v];i<(int)G[v].size();i++){\n    \t\tedge &e = G[v][i];\n    \t\tif(e.cap > 0 && level[v] < level[e.to]){\n    \t\t\tT d = dfs(e.to,t,min(f,e.cap));\n    \t\t\tif(d>0){\n    \t\t\t\te.cap -= d;\n    \t\t\t\tG[e.to][e.rev].cap += d;\n    \t\t\t\treturn d;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn 0;\n    }\n    //最大流を計算\n    T solve(int s,int t)\n    {\n    \tT flow = 0;\n    \tfor(;;){\n    \t\tbfs(s);\n    \t\tif(level[t]<0){\n    \t\t\treturn flow;\n    \t\t}\n    \t\tfill(iter.begin(),iter.end(),0);\n    \t\tT f;\n    \t\twhile((f=dfs(s,t,numeric_limits<T>::max())) > 0){\n    \t\t\tflow += f;\n    \t\t}\n    \t}\n    }\n};\n\n\nint main(){\n    int n;\n    cin >> n;\n    vector<string> s(n);\n    rep(i,n)cin >> s[i];\n    \n    for(int i=0;i<26;i++){\n        Dinic<int> dc(30);\n        int cnt = 0;\n        bool flag = 0;\n        for(int j=0;j<n;j++){\n            char a,b;\n            a = s[j][0];\n            b = s[j][s[j].size()-1];\n            if(s[j][0]=='a'+i){\n                if(b=='a'+i){\n                    flag = 1;\n                }else{\n                    cnt++;\n                    dc.add_edge(0,b-'a',1);\n                }\n            }else{\n                if(b=='a'+i){\n                    flag = 1;\n                    dc.add_edge(a-'a',27,1);\n                }else{\n                    dc.add_edge(a-'a',b-'a',1);\n                }\n            }\n        }\n        int ans = dc.solve(0,27);\n        if(!flag){\n            continue;\n        }\n        if(ans>=cnt){\n            cout << (char)('a'+i) << endl;\n        }else{\n            continue;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FOR(i, a, b) for(ll i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(ll i = (a); i > (b); --i)\n#define REP(i, n) for(ll i = 0; i < (n); ++i)\n#define REPR(i, n) for(ll i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt __builtin_popcount\n#define SZ(x) ((ll)(x).size())\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\n#define CINT(...)                                                              \\\n    int __VA_ARGS__;                                                           \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    ll __VA_ARGS__;                                                            \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Yes(a) cout << (a ? \"Yes\" : \"No\") << \"\\n\"\n#define YES(a) cout << (a ? \"YES\" : \"NO\") << \"\\n\"\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef vector<ll> VL;\ntypedef pair<ll, ll> PL;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\nconst double PI = atan(1.0) * 4.0;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dx[] = {1, 0, -1, 0};\nconst ll dy[] = {0, 1, 0, -1};\n\nvoid cinfast() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nstruct edge {\n    ll to, cap, rev;\n};\n\nstruct Dinic {\n    vector<vector<edge>> G;\n    VL level, iter;\n    ll N;\n\n    Dinic(ll size) : N(size) { init(size); };\n\n    void init(ll size) { G.resize(N); }\n\n    void add_edge(ll from, ll to, ll cap) {\n        G[from].push_back({to, cap, (ll)G[to].size()});\n        G[to].push_back({from, 0, (ll)G[from].size() - 1});\n    }\n    void bfs(ll s) {\n        level.assign(N, -1);\n        queue<ll> q;\n        level[s] = 0;\n        q.push(s);\n        while(!q.empty()) {\n            ll now = q.front();\n            q.pop();\n            FOREACH(e, G[now]) {\n                if(e.cap > 0 && level[e.to] == -1) {\n                    level[e.to] = level[now] + 1;\n                    q.push(e.to);\n                }\n            }\n        }\n    }\n\n    ll dfs(ll now, ll t, ll f) {\n        if(now == t) return f;\n        for(ll &i = iter[now]; i < G[now].size(); i++) {\n            edge &e = G[now][i];\n            if(e.cap > 0 && level[now] < level[e.to]) {\n                ll d = dfs(e.to, t, min(f, e.cap));\n                if(d > 0) {\n                    e.cap -= d;\n                    G[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n\n    ll max_flow(ll s, ll t) {\n        ll flow = 0;\n        while(1) {\n            bfs(s);\n            if(level[t] < 0) return flow;\n            iter.assign(N, 0);\n            ll f;\n            while((f = dfs(s, t, LINF)) > 0) {\n                flow += f;\n            }\n        }\n    }\n};\n\nsigned main() {\n    LCIN(N);\n    vector<string> S(N);\n    REP(i, N) cin >> S[i];\n    vector<char> ans;\n    REP(i, 26) {\n        Dinic mf(28);\n        ll s = 26, t = 27, in = 0, out = 0;\n        REP(j, N) {\n            ll from = S[j][0] - 'a', to = S[j].back() - 'a';\n            if(from == i) from = s, out++;\n            if(to == i) to = t, in++;\n            mf.add_edge(from, to, 1);\n        }\n        ll f = mf.max_flow(s, t);\n        if(f == out && in > 0) ans.emplace_back('a' + i);\n    }\n    REP(i, ans.size()) cout << ans[i] << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\ntemplate<typename T> struct edge {\n  int to;\n  T cap;\n  int rev_id;\n\n  edge(int to_,T cap_,int rev_id_) : to(to_),cap(cap_),rev_id(rev_id_){};\n};\n\n\ntemplate<typename T> struct Graph_for_flow {\n  vector< vector<edge<T>> > G;\n  vector<bool> used;\n  int V,E;\n\n  Graph_for_flow(T V_) {\n    init(V_);\n  }\n\n  void init(int V_) {\n    V = V_;\n\n    G.clear();\n    G.resize(V);\n\n    used.resize(V);\n\n  }\n\n  void add_edge(int from,int to,T cap) {\n    if(from < 0 || from >= V || to < 0 || to >= V ) {\n      cerr << \"warning\" << endl;\n    }\n\n    G[from].push_back(edge<T>(to,cap,G[to].size()));\n    G[to].push_back(edge<T>(from,0,G[from].size() - 1));\n  }\n\n  T dfs(int v,int t,T f) {\n    if(v == t) return f;\n\n    used[v] = true;\n\n    for(auto &e : G[v]) {\n      if(!used[e.to] && e.cap > 0) {\n        T d = dfs(e.to,t,min(f,e.cap));\n        if(d > 0) {\n          e.cap -= d;\n          G[e.to][e.rev_id].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  T max_flow(int s,int t) {\n    T flow = 0;\n    for(;;) {\n      fill(used.begin(),used.end(),false);\n      T f = dfs(s,t,1e9);\n      if(f == 0)break;\n      flow += f;\n    }\n    return flow;\n  }\n};\n\nusing ll = long long;\nll N;\nvector<string> S;\n\nint main() {\n  cin >> N;\n\n  S.resize(N);\n\n  rep(i,N) cin >> S[i];\n\n\n  vector<char> ans;\n\n  rep(i,26) {\n    Graph_for_flow<ll> graph(28);\n    int deg_out = 0,deg_in = 0;\n    int s = 26,t = 27;\n    rep(j,N) {\n      char u = S[j].front() - 'a';\n      char v = S[j].back() - 'a';\n\n      if(u == i) {u = s;deg_out++;}\n      if(v == i) {v = t;deg_in++;}\n\n      graph.add_edge(u,v,1);\n    }\n\n    ll flow = graph.max_flow(s,t);\n\n    if(flow >= deg_out && deg_in > 0)ans.push_back(i + 'a');\n  }\n\n  for(auto v : ans) {\n    cout << v << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 3047 Shiritori\n// 2019.8.13 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n//// 入出力関係\n#if 1\n#define gc() getchar_unlocked()\n#define pc(x) putchar_unlocked(x)\n#else\n#define gc() getchar()\n#define pc(x) putchar(x)\n#endif\n\nint in() { // 非負整数の入力\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nint ins(char *s) { // 文字列の入力　スペース以下の文字で入力終了\n\tchar *p = s;\n\tdo *s = gc();\n\twhile (*s++ > ' ');\n\t*--s = 0;\n\treturn s - p;\n}\n\n/*******************************************/\n/* Dinic's Max Flow Algorithm \n/*******************************************/\n\n#define INF 10005\n#define VMAX 30\ntypedef struct { int to; int cap; int rev; } EDGE;\nEDGE edge[VMAX][VMAX*2]; int hi[VMAX];\nint level[VMAX], iter[VMAX];\nint queue[VMAX], qtop;\n\nvoid add_edge(int from, int to, int cap) {\n\tint f, t; EDGE *e;\n\tf = hi[from]++, t = hi[to]++;\n\te = &edge[from][f], e->to = to, e->cap = cap, e->rev = t;\n\te = &edge[to][t], e->to = from, e->cap = 0, e->rev = f;\n}\n\nvoid bfs(int s) {\n\tint i, v; EDGE *e;\n\tmemset(level, -1, sizeof(level));\n\tlevel[s] = 0;\n\tqueue[0] = s, qtop = 1;\n\twhile (qtop) {\n\t\tv = queue[--qtop];\n\t\tfor (i = 0; i < hi[v]; i++) {\n\t\t\te = &edge[v][i];\n\t\t\tif (e->cap > 0 && level[e->to] < 0) {\n\t\t\t\tlevel[e->to] = level[v] + 1;\n\t\t\t\tqueue[qtop++] = e->to;\n\t\t\t}\n\t\t}\n\t}\n}\n \nint dfs(int v, int t, int f) {\n\tint *i, d; EDGE *e;\n\tif (v == t) return f;\n\tfor (i = &iter[v]; *i < hi[v]; (*i)++) {\n\t\te = &edge[v][*i];\n\t\tif (e->cap > 0 && level[v] < level[e->to]) {\n\t\t\td = dfs(e->to, t, f <= e->cap? f: e->cap);\n\t\t\tif (d > 0) {\n\t\t\t\te->cap -= d;\n\t\t\t\tedge[e->to][e->rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n \nint maxFlow(int s, int t) {\n\tint f, flow = 0;\n\twhile (1) {\n\t\tbfs(s);\n\t\tif (level[t] < 0) break;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\twhile ((f = dfs(s, t, INF)) > 0) flow += f;\n\t}\n\treturn flow;\n}\n\n//// 本問題関係\nint rel[30][30];\nchar s[103];\nchar f[30];\n\nint main()\n{\n\tint i, j, k, N, S, T;\n\n\tN = in();\n\twhile (N--) {\n\t\tint a, b, w = ins(s);\n\t\ta = s[0] - 'a', b = s[w-1] - 'a';\n\t\tif (a != b) rel[a][b]++;\n\t\tf[b] = 1;\n\t}\n\tT = 26;\n\tfor (i = 0; i < 26; i++) if (f[i]) {\n\t\tint fi = 0, fo = 0;\n\t\tfor (j = 0; j < 26; j++) fo += rel[i][j];\n\t\tS = i;\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tfor (j = 0; j < 26; j++) for (k = 0; k < 26; k++) if (rel[j][k]) {\n\t\t\tif (k == i) add_edge(j, T, rel[j][k]);\n\t\t\telse        add_edge(j, k, rel[j][k]);\n\t\t}\n\t\tif (maxFlow(S, T) == fo) pc('a'+i), pc('\\n');\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<62)-(1LL<<31))\n#define min(p,q)((p)<(q)?(p):(q))\n\nint d[26][26];\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{int s,g,c;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[1000];//適宜変える(ecnt)\n\tint inv[1000];//逆辺のindex(ecnt)\n\tint id[30];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nvoid makeinvedge(){\n\t//逆辺とidx\n\trep(i,0,g.ecnt){\n\t\tint l=0,r=g.ecnt;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(g.e[m].s<g.e[i].g||(g.e[m].s==g.e[i].g&&g.e[m].g<=g.e[i].s))l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tif(g.e[l].s!=g.e[i].g||g.e[l].g!=g.e[i].s){\n\t\t\tg.e[g.ecnt].s=g.e[i].g;\n\t\t\tg.e[g.ecnt].g=g.e[i].s;\n\t\t\tg.e[g.ecnt].c=0;\n\t\t\tg.ecnt++;\n\t\t}\n\t}\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\trep(i,0,g.ecnt){\n\t\tint l=0,r=g.ecnt;\n\t\twhile(r-l>1){\n\t\t\tint m=(l+r)/2;\n\t\t\tif(g.e[m].s<g.e[i].g||(g.e[m].s==g.e[i].g&&g.e[m].g<=g.e[i].s))l=m;\n\t\t\telse r=m;\n\t\t}\n\t\tg.inv[i]=l;\n\t}\n}\nvoid readgraph(int v){\n\t//適宜変える\n\tg.vcnt=27;\n\tg.ecnt=26*26;\n\tfor(int i=0;i<26;i++)for(int j=0;j<26;j++){\n\t\tg.e[i*26+j].s=i;\n\t\tg.e[i*26+j].g=j==v?26:j;\n\t\tg.e[i*26+j].c=d[i][j];\n\t}\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\tmakeinvedge();\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n\n//dinic O(VVE)\n//ソースs,シンクtを引いてsからtへの最大流を返す\n//*\nint dist[1010];//ソースからの距離\nint checked[1010];//dfsの行き止まりフラグ\nvoid dinicbfs(int s){\n\trep(i,0,g.vcnt)dist[i]=-1;\n\tdist[s]=0;\n\t//まだ流せる辺だけを使ってbfs\n\tint que[1010],qcnt=0;\n\tque[qcnt++]=s;\n\trep(q,0,qcnt){\n\t\tint v=que[q];\n\t\trep(i,g.id[v],g.id[v+1])if(g.e[i].c>0&&dist[g.e[i].g]==-1){\n\t\t\tdist[g.e[i].g]=dist[v]+1;\n\t\t\tque[qcnt++]=g.e[i].g;\n\t\t}\n\t}\n}\nll dinicdfs(int a,int t,ll m){\n\t//aはm受け取ってる(⇔aから最大m流せる)\n\t//いくら流せるかを返す\n\tif(a==t)return m;\n\tif(checked[a])return 0;\n\tll ans=0;\n\tchecked[a]=1;\n\trep(i,g.id[a],g.id[a+1])if(g.e[i].c>0&&dist[g.e[i].g]>dist[a]){\n\t\tint b=g.e[i].g;\n\t\tll addedflow=dinicdfs(b,t,min(m,g.e[i].c));\n\t\tif(addedflow){\n\t\t\tg.e[i].c-=addedflow;\n\t\t\tg.e[g.inv[i]].c+=addedflow;\n\t\t\tchecked[a]=0;\n\t\t\tans+=addedflow;\n\t\t\tm-=addedflow;\n\t\t\tif(m<=0)break;\n\t\t}\n\t}\n\treturn ans;\n}\n//ソース,シンク\nll dinic(int s,int t){\n\tll ans=0;\n\tint flag=1;\n\twhile(flag){\n\t\tflag=0;//更新フラグ\n\t\tdinicbfs(s);\n\t\twhile(!checked[s]){\n\t\t\tll addedflow=dinicdfs(s,t,INF);\n\t\t\tans+=addedflow;\n\t\t\tif(addedflow)flag=1;\n\t\t}\n\t\trep(i,0,g.vcnt)checked[i]=0;\n\t}\n\treturn ans;\n}\n//*/\n\nint out[26],in[26];\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++){\n\t\tchar s[110];\n\t\tscanf(\" %s\",s);\n\t\tint len=strlen(s);\n\t\td[s[0]-'a'][s[len-1]-'a']++;\n\t\tout[s[0]-'a']++;\n\t\tin[s[len-1]-'a']++;\n\t}\n\tfor(int i=0;i<26;i++){\n\t\treadgraph(i);\n\t\tif(in[i]&&dinic(i,26)==out[i])printf(\"%c\\n\",'a'+i);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<limits.h>\n#define CMAX 26\n#define SMAX 100\n#define MIN(a,b) ((a) < (b) ? (a) : (b))\n\nint net[CMAX][CMAX], matrix[CMAX+2][CMAX+2], iter[CMAX+2], level[CMAX+2];\nint Bfs(int, int, int);\nint Dfs(int, int, int, int);\nint main(void)\n{\n  int i, j, k, n, v;\n  char buf[SMAX];\n  scanf(\"%d\", &n);\n  for (i = 0; i < n; i++) {\n    int len, a, b;\n    scanf(\"%s%*c\", buf);\n    len = strlen(buf);\n    a = buf[0] - 'a';\n    b = buf[len-1] - 'a';\n    net[a][b]++;\n  }\n  for (i = 0; i < CMAX; i++) {\n    int maxflow = 0, inflow = 0, outflow = 0;\n    for (j = 0; j < CMAX; j++) {\n      inflow += net[j][i];\n      outflow += net[i][j];\n    }\n    v = CMAX + 2;\n    memset(matrix, 0, sizeof(matrix));\n    for (j = 0; j < CMAX; j++) {\n      for (k = 0; k < CMAX; k++) {\n        if (j == i && k == i) matrix[CMAX][CMAX+1] = net[i][i];\n        else if (j == i && k != i) matrix[CMAX][k] = net[i][k];\n        else if (j != i && k == i) matrix[j][CMAX+1] = net[j][i];\n        else matrix[j][k] = net[j][k];\n      }\n    }\n    while (Bfs(CMAX, CMAX + 1, v)) {\n      memset(iter, 0, sizeof(iter));\n      maxflow += Dfs(CMAX, CMAX + 1, v, INT_MAX);\n    }\n    if (outflow == maxflow && inflow > 0) printf(\"%c\\n\", i + 'a');\n  }\n}\n\nint Bfs(int s, int t, int size)\n{\n  int i, v, head = 0, tail = 0, queue[CMAX+2];\n  memset(level, -1, sizeof(level));\n  level[s] = 0;\n  queue[tail++] = s;\n  do {\n    i = queue[head++];\n    for (v = 0; v < size; v++) {\n      if (level[v] < 0 && matrix[i][v] > 0) {\n        queue[tail++] = v;\n        level[v] = level[i] + 1;\n      }\n    }\n  } while (head != tail);\n  return level[t] >= 0;\n}\n\nint Dfs(int u, int t, int size, int f)\n{\n  int *i, fsum = 0;\n  if (u == t) return f;\n  for (i = &iter[u]; *i < size; (*i)++) {\n    if (level[u] < level[(*i)] && matrix[u][(*i)] > 0) {\n      int ftemp = Dfs((*i), t, size, MIN(f - fsum, matrix[u][(*i)]));\n      if (ftemp > 0) {\n        matrix[u][(*i)] -= ftemp;\n        matrix[(*i)][u] += ftemp;\n        fsum += ftemp;\n        if (fsum == f) break;\n      }\n    }\n  }\n  return fsum;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\nimport kotlin.collections.ArrayList\n\nclass Flow(val to: Int, var flow: Int) {\n    private var mPair: Flow? = null\n    var pair: Flow\n        get() = mPair!!\n        set(value) {\n            mPair = value\n        }\n}\n\n\n\nfun calMaxFlow(nodes: Array<Array<Flow>>, source: Int, sink: Int): Int {\n    val depth = IntArray(nodes.size){-1}\n    val searching = IntArray(nodes.size){0}\n    val queue: Queue<Int> = ArrayDeque<Int>()\n    fun bfs(): Unit {\n        depth.fill(-1)\n        depth[source] = 0\n        queue.add(source)\n        while (queue.isNotEmpty()) {\n            val top = queue.poll()\n            for (flow in nodes[top]) if (flow.flow > 0 && depth[flow.to] == -1) {\n                depth[flow.to] = depth[top] + 1\n                queue.add(flow.to)\n            }\n        }\n    }\n    fun dfs(current: Int, min: Int = Int.MAX_VALUE): Int {\n        if (current == sink) return min\n        while(searching[current] < nodes[current].size) {\n            val flow = nodes[current][searching[current]]\n            if (flow.flow > 0 && depth[current] < depth[flow.to]) {\n                val f = dfs(flow.to, minOf(min, flow.flow))\n                if (f > 0) {\n                    flow.flow -= f\n                    flow.pair.flow += f\n                    return f\n                }\n            }\n            ++searching[current]\n        }\n        return 0\n    }\n    var flow = 0\n    var hasFlow = true\n    while (hasFlow) {\n        hasFlow = false\n        bfs()\n        searching.fill(0)\n        var f = dfs(source)\n        while(f > 0) {\n            flow += f\n            hasFlow = true\n            f = dfs(source)\n        }\n    }\n    return flow\n}\n\nfun makeGraph(counts: Array<IntArray>, base: Int): Array<Array<Flow>> {\n    val nodes = Array(28){ArrayList<Flow>()}\n    fun setNode(from: Int, to: Int, flow: Int): Unit {\n        nodes[from].add(Flow(to, flow))\n        nodes[to].add(Flow(from, 0))\n        nodes[from].last().pair = nodes[to].last()\n        nodes[to].last().pair = nodes[from].last()\n    }\n    for (i in 0 until 26) if (i != base) {\n        for (j in 0 until 26) if (j != base) {\n            if (counts[i][j] != 0) setNode(i, j, counts[i][j])\n        }\n    }\n    for (i in 0 until 26) if (i != base) {\n        if (counts[base][i] != 0) setNode(26, i, counts[base][i])\n        if (counts[i][base] != 0) setNode(i, 27, counts[i][base])\n    }\n    if (counts[base][base] != 0) setNode(26, 27, counts[base][base])\n    return nodes.map{it.toTypedArray()}.toTypedArray()\n}\nfun main(args: Array<String>) {\n    val n = readLine()!!.trim().toInt()\n    val words = Array(n){readLine()!!.trim()}\n    val counts = Array(26){IntArray(26){0} }\n    for (word in words) {\n        ++counts[word.first() - 'a'][word.last() - 'a']\n    }\n    for (c in 'a' .. 'z') {\n        if (counts.sumBy{it[c - 'a']} == 0) continue\n        if (counts[c - 'a'].sum() == 0) {\n            println(c)\n            continue\n        }\n        val graph = makeGraph(counts, c - 'a')\n        val flow = calMaxFlow(graph, 26, 27)\n        if (counts[c - 'a'].sum() <= flow) {\n            println(c)\n        }\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby, combinations_with_replacement\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = 10**10\nmod = 10 ** 9 + 7\n\nclass Dinic:\n    def __init__(self, v, inf=10**10):\n        self.v = v\n        self.inf = inf\n        self.G = [[] for _ in range(v)]\n        self.level = [-1]*v  # 深さ\n        self.ite = [0]*v  # DFSでの探索が済んでいるか\n    def add_edge(self, fr, to, cap):\n        self.G[fr].append([to, cap, len(self.G[to])])\n        self.G[to].append([fr, 0, len(self.G[fr])-1])\n    def bfs(self, s):  # BFSで深さ決定,sがstart\n        self.level = [-1]*self.v  # 必要\n        self.level[s] = 0\n        Q = deque()\n        Q.append(s)\n        while Q:\n            v = Q.popleft()\n            for i in range(len(self.G[v])):\n                e = self.G[v][i]\n                if e[1]>0 and self.level[e[0]]<0: ###capacity>0かつtoの深さ未定\n                    self.level[e[0]] = self.level[v]+1\n                    Q.append(e[0])\n    def dfs(self, v, t, f):  # DFSで増加パス探索,v開始、t終点、総フローf\n        if v==t:\n            return f\n        for i in range(self.ite[v], len(self.G[v])):\n            self.ite[v] = i\n            e = self.G[v][i]\n            if e[1]>0 and self.level[v]<self.level[e[0]]:\n                d = self.dfs(e[0], t, min(f, e[1]))\n                if d>0:\n                    e[1] -= d  # cap減少\n                    self.G[e[0]][e[2]][1] += d  # 逆辺のcap増加\n                    return d\n        return 0\n    def max_flow(self, s, t):\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.level[t]<0:\n                return flow\n            self.ite = [0]*self.v  # DFSでの探索が済んでいるか否か\n            f = self.dfs(s,t,self.inf)\n            while f>0:\n                flow += f\n                f = self.dfs(s,t,self.inf)\n\ndef ctoi(c):\n    return ord(c) - ord('a')\n\nN = INT()\nS = [input() for _ in range(N)]\n\nans = []\nfor i in range(len(ascii_lowercase)):\n    D = Dinic(len(ascii_lowercase)+2)\n    s = 26\n    t = s+1\n\n    deg_in = 0\n    deg_out = 0\n\n    for x in S:\n        u = ctoi(x[0])\n        v = ctoi(x[-1])\n        if u == i:\n            u = s\n            deg_out += 1\n        if v == i:\n            v = t\n            deg_in += 1\n\n        D.add_edge(u, v, 1)\n\n    f = D.max_flow(s, t)\n    if f >= deg_out and deg_in > 0:\n        ans.append(ascii_lowercase[i])\n\nprint(*ans, sep=\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import Counter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nclass Dinic:\n    \"\"\" 最大流(Dinic) \"\"\"\n\n    INF = 10 ** 18\n\n    def __init__(self, n):\n        self.n = n\n        self.links = [[] for _ in range(n)]\n        self.depth = None\n        self.progress = None\n \n    def add_link(self, _from, to, cap):\n        self.links[_from].append([cap, to, len(self.links[to])])\n        self.links[to].append([0, _from, len(self.links[_from]) - 1])\n \n    def bfs(self, s):\n        from collections import deque\n\n        depth = [-1] * self.n\n        depth[s] = 0\n        q = deque([s])\n        while q:\n            v = q.popleft()\n            for cap, to, _ in self.links[v]:\n                if cap > 0 and depth[to] < 0:\n                    depth[to] = depth[v] + 1\n                    q.append(to)\n        self.depth = depth\n \n    def dfs(self, v, t, flow):\n        if v == t:\n            return flow\n        links_v = self.links[v]\n        for i in range(self.progress[v], len(links_v)):\n            self.progress[v] = i\n            cap, to, rev = link = links_v[i]\n            if cap == 0 or self.depth[v] >= self.depth[to]:\n                continue\n            d = self.dfs(to, t, min(flow, cap))\n            if d == 0:\n                continue\n            link[0] -= d\n            self.links[to][rev][0] += d\n            return d\n        return 0\n \n    def max_flow(self, s, t):\n        INF = Dinic.INF\n        flow = 0\n        while True:\n            self.bfs(s)\n            if self.depth[t] < 0:\n                return flow\n            self.progress = [0] * self.n\n            current_flow = self.dfs(s, t, INF)\n            while current_flow > 0:\n                flow += current_flow\n                current_flow = self.dfs(s, t, INF)\n\nN = INT()\nA = [input() for i in range(N)]\nM = 26\nC = Counter()\noutcnt = [0] * M\nincnt = [0] * M\nfor s in A:\n    a, b = ord(s[0])-97, ord(s[-1])-97\n    # 辺(a, b)の容量、aから出る辺の数、bに入る辺の数\n    C[(a, b)] += 1\n    outcnt[a] += 1\n    incnt[b] += 1\n\ndinic = Dinic(M*2)\nfor a in range(M):\n    # 各文字でin -> out間はINFで繋いでおく\n    dinic.add_link(a, M+a, INF)\n    for b in range(M):\n        # 文字aのout -> 文字bのin\n        dinic.add_link(M+a, b, C[(a, b)])\n\nans = []\nfor a in range(M):\n    # 文字aのoutからinに向かって流す\n    res = dinic.max_flow(M+a, a)\n    # aで終わる単語が1つ以上あって、aに戻ってこれる流量がaを出る辺の数以上にあればOK\n    if incnt[a] >= 1 and res >= outcnt[a]:\n        ans.append(chr(a+97))\n[print(a) for a in ans]\n\n"
  }
]