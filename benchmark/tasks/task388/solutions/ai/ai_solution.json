[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define INF INT_MAX\n\nint N, M;\nint dist[MAX_N + 1][MAX_N + 1];\n\nvoid initialize() {\n    for (int i = 1; i <= MAX_N; i++) {\n        for (int j = 1; j <= MAX_N; j++) {\n            if (i == j) dist[i][j] = 0;\n            else dist[i][j] = INF;\n        }\n    }\n}\n\nvoid floydWarshall() {\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF && dist[i][k] + dist[k][j] < dist[i][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n}\n\nint solve() {\n    floydWarshall();\n    int total = 0;\n    int current = 1;\n    for (int next = 2; next <= N; next++) {\n        if (dist[current][next] == INF) return -1;\n        total += dist[current][next];\n        current = next;\n    }\n    if (dist[current][1] == INF) return -1;\n    total += dist[current][1];\n    return total;\n}\n\nint main() {\n    initialize();\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < M; i++) {\n        int u, v, d;\n        scanf(\"%d %d %d\", &u, &v, &d);\n        if (d < dist[u][v]) {\n            dist[u][v] = d;\n        }\n    }\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 21:18:59"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nvector<vector<pii>> adj;\nvector<int> dist;\n\nvoid dijkstra(int start) {\n    priority_queue<pii, vector<pii>, greater<pii>> pq;\n    dist.assign(dist.size(), INT_MAX);\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int u = pq.top().second;\n        int d = pq.top().first;\n        pq.pop();\n\n        if (d > dist[u]) continue;\n\n        for (auto &edge : adj[u]) {\n            int v = edge.first;\n            int w = edge.second;\n            if (dist[v] > dist[u] + w) {\n                dist[v] = dist[u] + w;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    adj.resize(N + 1);\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].push_back({v, w});\n    }\n\n    int total = 0;\n    bool possible = true;\n    dist.resize(N + 1);\n\n    for (int i = 1; i < N; ++i) {\n        dijkstra(i);\n        if (dist[i + 1] == INT_MAX) {\n            possible = false;\n            break;\n        }\n        total += dist[i + 1];\n    }\n\n    if (possible) {\n        dijkstra(N);\n        if (dist[1] == INT_MAX) {\n            possible = false;\n        } else {\n            total += dist[1];\n        }\n    }\n\n    cout << (possible ? total : -1) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:19:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int[][] dist = new int[N+1][N+1];\n        for (int i = 1; i <= N; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n            dist[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int d = sc.nextInt();\n            dist[u][v] = Math.min(dist[u][v], d);\n        }\n\n        // Floyd-Warshall to compute all pairs shortest paths\n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    if (dist[i][k] != Integer.MAX_VALUE && dist[k][j] != Integer.MAX_VALUE) {\n                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n        }\n\n        long total = 0;\n        boolean possible = true;\n        for (int i = 1; i < N; i++) {\n            if (dist[i][i+1] == Integer.MAX_VALUE) {\n                possible = false;\n                break;\n            }\n            total += dist[i][i+1];\n        }\n        if (possible && dist[N][1] != Integer.MAX_VALUE) {\n            total += dist[N][1];\n            System.out.println(total);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:19:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class TravelingSalesmanProblem {\n    static final int INF = Integer.MAX_VALUE / 2;\n    static int N, M;\n    static int[][] graph;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        N = Integer.parseInt(st.nextToken());\n        M = Integer.parseInt(st.nextToken());\n        \n        graph = new int[N+1][N+1];\n        for (int[] row : graph) {\n            Arrays.fill(row, INF);\n        }\n        \n        for (int i = 0; i < M; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            int w = Integer.parseInt(st.nextToken());\n            graph[u][v] = Math.min(graph[u][v], w);\n        }\n        \n        int result = solve();\n        System.out.println(result);\n    }\n    \n    static int solve() {\n        int[][] dp = new int[1 << (N-1)][N+1];\n        for (int[] row : dp) {\n            Arrays.fill(row, INF);\n        }\n        dp[0][1] = 0;\n        \n        for (int mask = 0; mask < (1 << (N-1)); mask++) {\n            for (int cur = 1; cur <= N; cur++) {\n                if (dp[mask][cur] == INF) continue;\n                \n                for (int next = 2; next <= N; next++) {\n                    if ((mask & (1 << (next-2))) != 0) continue;\n                    \n                    if (graph[cur][next] != INF) {\n                        int newMask = mask | (1 << (next-2));\n                        dp[newMask][next] = Math.min(dp[newMask][next], \n                                                     dp[mask][cur] + graph[cur][next]);\n                    }\n                }\n            }\n        }\n        \n        int minPath = INF;\n        for (int mask = 0; mask < (1 << (N-1)); mask++) {\n            if (mask == (1 << (N-1)) - 1) {\n                for (int cur = 2; cur <= N; cur++) {\n                    if (graph[cur][1] != INF) {\n                        minPath = Math.min(minPath, dp[mask][cur] + graph[cur][1]);\n                    }\n                }\n            }\n        }\n        \n        return minPath == INF ? -1 : minPath;\n    }\n}",
    "timestamp": "2025-08-05 21:19:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <string.h>\n\n#define MAX_N 20\n#define MAX_M 400\n\nint graph[MAX_N + 1][MAX_N + 1];\nint N, M;\n\nint solve() {\n    int min_dist = INT_MAX;\n    \n    for (int mask = 1; mask < (1 << (N - 1)); mask++) {\n        if ((mask & ((1 << (N - 1)) - 1)) != ((1 << (N - 1)) - 1)) \n            continue;\n        \n        int curr = 1;\n        int total_dist = 0;\n        int visited = 1;\n        int next_vertex = 2;\n        \n        for (int j = 0; j < N - 1; j++) {\n            int found = 0;\n            for (int k = 1; k <= N; k++) {\n                if (k == curr) continue;\n                \n                if (graph[curr][k] != 0 && \n                    (next_vertex == k || \n                     ((mask & (1 << (k - 2))) && k == next_vertex))) {\n                    \n                    if (graph[curr][k] == -1) {\n                        total_dist = -1;\n                        break;\n                    }\n                    \n                    total_dist += graph[curr][k];\n                    curr = k;\n                    \n                    if (curr == next_vertex) {\n                        next_vertex++;\n                        visited |= (1 << (curr - 2));\n                    }\n                    \n                    found = 1;\n                    break;\n                }\n            }\n            \n            if (total_dist == -1 || !found) {\n                total_dist = -1;\n                break;\n            }\n        }\n        \n        if (total_dist != -1 && graph[curr][1] != 0) {\n            if (graph[curr][1] == -1) \n                total_dist = -1;\n            else \n                total_dist += graph[curr][1];\n        }\n        \n        if (total_dist != -1 && min_dist > total_dist) {\n            min_dist = total_dist;\n        }\n    }\n    \n    return min_dist == INT_MAX ? -1 : min_dist;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        scanf(\"%d %d\", &N, &M);\n        \n        memset(graph, 0, sizeof(graph));\n        \n        for (int i = 0; i < M; i++) {\n            int u, v, w;\n            scanf(\"%d %d %d\", &u, &v, &w);\n            graph[u][v] = w;\n        }\n        \n        printf(\"%d\\n\", solve());\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 20;\nconst int INF = 1e9;\n\nint N, M;\nvector<vector<pair<int, int>>> graph(MAXN);\nint dist[MAXN][MAXN];\n\nint solve() {\n    // Initialize distance matrix\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            dist[i][j] = (i == j) ? 0 : INF;\n        }\n    }\n\n    // Add graph edges\n    for (int i = 1; i <= N; i++) {\n        for (auto& [v, w] : graph[i]) {\n            dist[i][v] = min(dist[i][v], w);\n        }\n    }\n\n    // Floyd-Warshall algorithm for all-pairs shortest paths\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (dist[i][k] != INF && dist[k][j] != INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n\n    // Check if path exists from 1 to 2, 2 to 3, ..., N-1 to N, N to 1\n    int total_dist = 0;\n    for (int i = 1; i < N; i++) {\n        if (dist[i][i+1] == INF) return -1;\n        total_dist += dist[i][i+1];\n    }\n    if (dist[N][1] == INF) return -1;\n    total_dist += dist[N][1];\n\n    return total_dist;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    cin >> N >> M;\n    for (int i = 0; i < M; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        graph[u].push_back({v, w});\n    }\n\n    int result = solve();\n    cout << result << \"\\n\";\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:20:12"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef dijkstra(graph, start, n):\n    distances = [float('inf')] * (n + 1)\n    distances[start] = 0\n    priority_queue = [(0, start)]\n\n    while priority_queue:\n        current_distance, current_vertex = heapq.heappop(priority_queue)\n\n        if current_distance > distances[current_vertex]:\n            continue\n\n        for neighbor, weight in graph[current_vertex]:\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    \n    return distances\n\ndef solve(n, m, edges):\n    graph = [[] for _ in range(n + 1)]\n    for u, v, d in edges:\n        graph[u].append((v, d))\n\n    distance_start_1 = dijkstra(graph, 1, n)\n    \n    if distance_start_1[2] == float('inf'):\n        return -1\n\n    path_distance = 0\n    current_vertex = 2\n\n    while current_vertex <= n:\n        distance_to_next = dijkstra(graph, current_vertex, n)\n        next_vertex = current_vertex + 1 if current_vertex < n else 1\n        if distance_to_next[next_vertex] == float('inf'):\n            return -1\n        path_distance += distance_to_next[next_vertex]\n        current_vertex = next_vertex\n\n    return path_distance\n\nif __name__ == \"__main__\":\n    n, m = map(int, input().split())\n    edges = [tuple(map(int, input().split())) for _ in range(m)]\n    result = solve(n, m, edges)\n    print(result)",
    "timestamp": "2025-08-13 06:02:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TravelingSalesmanProblemK {\n\n    private static final int INF = Integer.MAX_VALUE / 2; // To avoid overflow when adding\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        int[][] dist = new int[N][N];\n        for (int[] row : dist) {\n            Arrays.fill(row, INF);\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            int d = scanner.nextInt();\n            dist[u][v] = Math.min(dist[u][v], d);\n        }\n\n        // Floyd-Warshall Algorithm to find all-pairs shortest paths\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (dist[i][k] < INF && dist[k][j] < INF) {\n                        dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                    }\n                }\n            }\n        }\n\n        int[] path = new int[N];\n        Arrays.fill(path, INF);\n        path[0] = 0;\n\n        for (int i = 1; i < N; i++) {\n            if (path[i - 1] < INF && dist[i - 1][i] < INF) {\n                path[i] = path[i - 1] + dist[i - 1][i];\n            }\n        }\n\n        int result = INF;\n        if (path[N - 1] < INF && dist[N - 1][0] < INF) {\n            result = path[N - 1] + dist[N - 1][0];\n        }\n\n        System.out.println(result == INF ? -1 : result);\n    }\n}",
    "timestamp": "2025-08-13 06:02:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAXN 18\n#define INF INT_MAX\n\nint N, M;\nint dist[MAXN][MAXN];\nint dp[1 << MAXN][MAXN];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint tsp(int mask, int pos) {\n    if (mask == (1 << N) - 1) {\n        return dist[pos][0] != INF ? dist[pos][0] : INF;\n    }\n    if (dp[mask][pos] != -1) {\n        return dp[mask][pos];\n    }\n    int ans = INF;\n    for (int next = 0; next < N; ++next) {\n        if ((mask & (1 << next)) == 0 && dist[pos][next] != INF) {\n            ans = min(ans, dist[pos][next] + tsp(mask | (1 << next), next));\n        }\n    }\n    return dp[mask][pos] = ans;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            dist[i][j] = INF;\n        }\n    }\n    for (int i = 0; i < M; ++i) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        dist[u - 1][v - 1] = w;\n    }\n    for (int i = 0; i < (1 << N); ++i) {\n        for (int j = 0; j < N; ++j) {\n            dp[i][j] = -1;\n        }\n    }\n    int result = tsp(1, 0);\n    printf(\"%d\\n\", result == INF ? -1 : result);\n    return 0;\n}",
    "timestamp": "2025-08-13 06:02:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve_traveling_salesman(N, M, edges):\n    # Create adjacency list\n    graph = [[] for _ in range(N+1)]\n    for u, v, w in edges:\n        graph[u].append((v, w))\n    \n    # Initialize distance matrix\n    INF = float('inf')\n    dist = [[INF] * (1 << (N-1)) for _ in range(N+1)]\n    dist[1][0] = 0\n    \n    # Priority queue for Dijkstra-like approach\n    pq = [(0, 1, 0)]\n    \n    while pq:\n        current_dist, current_vertex, visited_mask = heapq.heappop(pq)\n        \n        # If mask indicates all vertices visited in order\n        if visited_mask == (1 << (N-1)) - 1:\n            # Try to return to vertex 1\n            for next_v, next_w in graph[current_vertex]:\n                if next_v == 1:\n                    return current_dist + next_w\n            continue\n        \n        # Skip if current path is not optimal\n        if current_dist > dist[current_vertex][visited_mask]:\n            continue\n        \n        # Try moving to next vertices in sequence\n        for next_v, next_w in graph[current_vertex]:\n            # Determine next expected vertex in sequence\n            next_expected = 0\n            for i in range(N-1):\n                if not (visited_mask & (1 << i)):\n                    next_expected = i + 2\n                    break\n            \n            # If moving to next expected vertex\n            if next_v == next_expected:\n                new_mask = visited_mask | (1 << (next_expected - 2))\n                new_dist = current_dist + next_w\n                \n                # Update if new path is shorter\n                if new_dist < dist[next_v][new_mask]:\n                    dist[next_v][new_mask] = new_dist\n                    heapq.heappush(pq, (new_dist, next_v, new_mask))\n            \n            # Allow moving to other vertices if not at end\n            elif visited_mask != (1 << (N-1)) - 1:\n                new_dist = current_dist + next_w\n                \n                # Update if new path is shorter\n                if new_dist < dist[next_v][visited_mask]:\n                    dist[next_v][visited_mask] = new_dist\n                    heapq.heappush(pq, (new_dist, next_v, visited_mask))\n    \n    return -1\n\n# Read input\nN, M = map(int, input().split())\nedges = []\nfor _ in range(M):\n    u, v, w = map(int, input().split())\n    edges.append((u, v, w))\n\n# Solve and print result\nresult = solve_traveling_salesman(N, M, edges)\nprint(result)",
    "timestamp": "2025-08-13 06:03:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    N, M = map(int, input().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b, c = map(int, input().split())\n        adj[a].append((b, c))\n    \n    # We need to find the shortest path from 1 to 2, then 2 to 3, ..., N-1 to N, and N to 1\n    total = 0\n    current_pos = 1\n    \n    for target in range(2, N+1):\n        # Dijkstra's algorithm to find the shortest path from current_pos to target\n        dist = [float('inf')] * (N+1)\n        dist[current_pos] = 0\n        heap = []\n        heapq.heappush(heap, (0, current_pos))\n        \n        found = False\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if u == target:\n                found = True\n                break\n            if current_dist > dist[u]:\n                continue\n            for (v, cost) in adj[u]:\n                if dist[v] > dist[u] + cost:\n                    dist[v] = dist[u] + cost\n                    heapq.heappush(heap, (dist[v], v))\n        \n        if not found:\n            print(-1)\n            return\n        total += dist[target]\n        current_pos = target\n    \n    # Now find the path from N back to 1\n    dist = [float('inf')] * (N+1)\n    dist[current_pos] = 0\n    heap = []\n    heapq.heappush(heap, (0, current_pos))\n    \n    found = False\n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if u == 1:\n            found = True\n            break\n        if current_dist > dist[u]:\n            continue\n        for (v, cost) in adj[u]:\n            if dist[v] > dist[u] + cost:\n                dist[v] = dist[u] + cost\n                heapq.heappush(heap, (dist[v], v))\n    \n    if not found:\n        print(-1)\n        return\n    total += dist[1]\n    print(total)\n\nsolve()",
    "timestamp": "2025-08-13 06:03:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<vector<int>> dist(N + 1, vector<int>(N + 1, INF));\n\n    for (int i = 1; i <= N; i++) {\n        dist[i][i] = 0;\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v, d;\n        cin >> u >> v >> d;\n        dist[u][v] = min(dist[u][v], d);\n    }\n\n    // Floyd-Warshall algorithm to find shortest paths between all-pairs\n    for (int k = 1; k <= N; k++) {\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (dist[i][k] < INF && dist[k][j] < INF) {\n                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n    }\n\n    int result = 0;\n    bool possible = true;\n\n    for (int i = 1; i < N && possible; i++) {\n        if (dist[i][i + 1] < INF) {\n            result += dist[i][i + 1];\n        } else {\n            possible = false;\n        }\n    }\n\n    if (possible && dist[N][1] < INF) {\n        result += dist[N][1];\n    } else {\n        possible = false;\n    }\n\n    if (!possible) {\n        cout << -1 << endl;\n    } else {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:29:47"
  }
]