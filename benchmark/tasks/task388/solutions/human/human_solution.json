[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  map<int,map<int,int>> m;\n  int N,M;\n  cin >> N >> M;\n  int a,b,c;\n  for(int i=0;i<M;i++){\n    cin >> a >> b >> c;\n    m[a][b] = m[a][b]==0 ? c : min(m[a][b],c);\n  }\n\n  int ans = 0;\n  for(int k=1;k<=N;k++){\n    for(int i=1;i<=N;i++){\n      for(int j=1;j<=N;j++){\n        if(m[i][k]!=0&&m[k][j]!=0) m[i][j] = m[i][j]==0 ? m[i][k]+m[k][j] : min(m[i][j],m[i][k]+m[k][j]);\n      }\n    }\n  }\n  for(int i=1;i<=N;i++){\n    int next = i==N ? 1 : i+1;\n    if(m[i][next]==INF){\n      cout << -1 << endl;\n      return 0;\n    }\n    ans += m[i][next];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N (100010)\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct edge {\n\tint to, cost;\n\tedge(int to, int cost) : to(to), cost(cost) {}\n\tedge(){}\n};\n\nvector<edge> g[MAX_N];\nbool vis[MAX_N];\nint tVertex[MAX_N];\nint len[MAX_N], dist[MAX_N], belong[MAX_N];\nint par[MAX_N], chi[MAX_N];\nint inDeg[MAX_N], outDeg[MAX_N];\nint d[1024][1024];\nint idx;\n\nvoid findCompress(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tedge e = g[v][i];\n\t\tif (!vis[e.to]){\n\t\t\tfindCompress(e.to);\n\t\t}\n\t}\n\t\n\tif (!v || inDeg[v] > 1 || outDeg[v] > 1){\n\t\ttVertex[v] = idx++;\n\t}\n}\n\nint s;\nint makeCompress(int now, int p, int cost, int id)\n{\n\tif (~tVertex[now]){\n\t\tbelong[now] = -1;\n\t\tlen[id] = cost;\n\t\td[tVertex[p]][tVertex[now]] = min(cost, d[tVertex[p]][tVertex[now]]);\n\t\tcost = 0;\n\t\tp = now;\n\t}\n\t\n\tif (vis[now]) return (tVertex[now]);\n\tif (!~tVertex[now]) belong[now] = id;\n\tvis[now] = true;\n\tpar[now] = tVertex[p];\n\tdist[now] = cost;\n\t\n\tint r = -1;\n\tfor (int i = 0; i < g[now].size(); i++){\n\t\tint nid = id;\n\t\tif (~tVertex[now]) nid = ++s;\n\t\tr = makeCompress(g[now][i].to, p, cost + g[now][i].cost, nid);\n\t}\n\tif (~tVertex[now]) r = tVertex[now];\n\t\n\treturn (chi[now] = r);\n}\n\nint main()\n{\n\tint n, m;\n\t\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t--a; --b;\n\t\tfor (int i = 0; i < g[a].size(); i++){\n\t\t\tif (g[a][i].to == b){\n\t\t\t\tg[a][i].cost = min(g[a][i].cost, c);\n\t\t\t\tgoto updated;\n\t\t\t}\n\t\t}\n\t\t\n\t\tg[a].push_back(edge(b, c));\n\t\toutDeg[a]++; inDeg[b]++;\n\t\tupdated:;\n\t}\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(tVertex, -1, sizeof(tVertex));\n\tmemset(par, -1, sizeof(par));\n\tfindCompress(0);\n\t\n\tfor (int i = 0; i < n; i++) if (vis[i] == false) return (!printf(\"-1\\n\"));\n\n\tfor (int i = 0; i < 1024; i++){\n\t\tfor (int j = 0; j < 1024; j++){\n\t\t\td[i][j] = 1 << 25;\n\t\t}\n\t\td[i][i] = 0;\n\t}\n\tmemset(vis, 0, sizeof(vis));\n\tmakeCompress(0, 0, 0, 0);\n\n\tfor (int k = 0; k < idx; k++){\n\t\tfor (int i = 0; i < idx; i++){\n\t\t\tfor (int j = 0; j < idx; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < idx; i++){\n\t\tfor (int j = 0; j < idx; j++){\n\t\t\tif (d[i][j] == 1 << 25) return (!printf(\"-1\\n\"));\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tint from = i, to = (i + 1) % n;\n\t\tint fl = belong[from], tl = belong[to];\n\t\tint c = chi[from], p = par[to];\n\t\tif (fl == tl && dist[from] < dist[to]){\n\t\t\tres += dist[to] - dist[from];\n\t\t}\n\t\telse {\n\t\t\tres += (!~fl ? 0 : (len[fl] - dist[from])) + d[c][p] + dist[to];\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nvector<vector<pair<int, int> > > g;\nvector<int> in;\nvector<int> out;\nvector<bool> ok;\nvector<int> id;\nvector<int> from;\nvector<long long> fromdist;\nvector<int> to;\nvector<long long> todist;\nvector<vector<long long> > dist;\n\nint un;\n\nclass UnionFind{\nprivate:\n  vector<int> id;\n\n  int getId(int i){\n    if(i == id[i]) return i;\n    return id[i] = getId(id[i]);\n  }\npublic:\n  UnionFind(int size = 0){ init(size); }\n  ~UnionFind(){}\n  void init(int size){\n    id = vector<int>(size);\n    for(int i = 0; i < size; i++)\n      id[i] = i;\n  }\n  void unite(int i, int j){\n    int next = min( getId(i), getId(j) );\n    id[getId(i)] = id[getId(j)] = next;\n  }\n  int operator [](int i){ return getId(i); }\n  int count(){\n    set<int> s;\n    for(int i = 0; i < (int)id.size(); i++)\n      s.insert(getId(i));\n    return s.size();\n  }\n};\n\nUnionFind uf;\n\npair<int, long long> dfs(int pos, int init, ll dis = 0, bool first = true){\n  if((!first || pos != init) && ok[pos]){\n    dist[id[init]][id[pos]] = min(dist[id[init]][id[pos]], dis);\n    return mp(pos, dis);\n  }\n\n  if(!ok[pos]){\n    from[id[pos]]     = init;\n    fromdist[id[pos]] = dis;\n  }\n\n  pair<int, int> last;\n  for(int i = 0; i < (int)g[pos].size(); i++){\n    int next = g[pos][i].f;\n    ll d = g[pos][i].s;\n\n    if(first) un = next;\n    last = dfs(next, init, dis + d, false);\n\n    if(!ok[pos]){\n      uf.unite(id[pos], id[un]);\n      to[id[pos]]     = last.first;\n      todist[id[pos]] = last.second - dis;\n    }\n  }\n\n  return last;\n}\n\nint main(){\n  int n = getInt();\n  int m = getInt();\n\n  g = vector<vector<pair<int, int> > >(n);\n  in = vector<int>(n);\n  out = vector<int>(n);\n  ok = vector<bool>(n, false);\n  id = vector<int>(n);\n\n  REP(i,m){\n    int a = getInt() - 1;\n    int b = getInt() - 1;\n    int c = getInt();\n\n    bool find = false;\n    for(int i = 0; i < g[a].size(); i++){\n      if(g[a][i].f == b){\n        find = true;\n        g[a][i].s = min(g[a][i].s, c);\n      }\n    }\n\n    if(!find){\n      g[a].push_back(mp(b, c));\n      in[b]++;\n      out[a]++;\n    }\n  }\n\n  map<int, int> okid;\n  map<int, int> trid;\n\n  REP(i,n){\n    if(in[i] == 0 || out[i] == 0){\n      puts(\"-1\");\n      return 0;\n    }\n    if(in[i] == 1 && out[i] == 1){\n      // trivial\n      int id2 = trid.size();\n      trid[id2] = i;\n      id[i] = id2;\n    }else{\n      // non-trivial\n      int id2 = okid.size();\n      okid[id2] = i;\n      ok[i] = true;\n      id[i] = id2;\n    }\n  }\n\n  // REP(i,n) printf(\"%d: %d\\n\", i, (int)ok[i]);\n\n  int N = okid.size();\n  int M = trid.size();\n  const long long MAX = (1ll << 60);\n  long long ans = 0;\n\n  if(N == 0){\n    id[n - 1] = 0;\n    id[n - 2] = 1;\n    ok[n - 1] = true;\n    ok[n - 2] = true;\n\n    N += 2;\n    M -= 2;\n  }\n\n  // printf(\"N: %d\\n\", N);\n  if(N > 1000) return 0;\n\n  dist = vector<vector<ll> >(N, vector<ll>(N, MAX));\n  to = vector<int>(M, -1);\n  from = vector<int>(M, -1);\n\n  todist = vector<ll>(M);\n  fromdist = vector<ll>(M);\n\n  uf.init(M);\n\n  REP(i,N) dist[i][i] = 0;\n\n  REP(i,n) if(ok[i]){\n    dfs(i, i);\n  }\n\n  REP(k,N) REP(i,N) REP(j,N)\n    dist[i][j] = min((long long)dist[i][j], (long long)dist[i][k] + dist[k][j]);\n\n  REP(i,N) REP(j,N) if(dist[i][j] == MAX){\n    puts(\"-1\");\n    return 0;\n  }\n\n  if(N != 0){\n    REP(i,M) if(from[i] == -1 || to[i] == -1){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n\n  // REP(i,N){ REP(j,N) printf(\"%4d \", (int)dist[i][j]); puts(\"\"); }\n\n  for(int j = 0; j < n; j++){\n    int prev = j;\n    int next = j == n - 1 ? 0 : j + 1;\n    long long tmp = 0;\n\n    if(!ok[prev] && !ok[next] && uf[id[prev]] == uf[id[next]] && fromdist[id[prev]] < fromdist[id[next]]){\n      tmp += fromdist[id[next]] - fromdist[id[prev]];\n    }else{\n      if(!ok[prev]){\n        tmp += todist[id[prev]];\n        prev = to[id[prev]];\n      }\n\n      if(!ok[next]){\n        tmp += fromdist[id[next]];\n        next = from[id[next]];\n      }\n\n      tmp += dist[id[prev]][id[next]];\n    }\n\n    // printf(\"%d => %d: %lld\\n\", j + 1, 1 + (j == n - 1 ? 0 : j + 1), tmp);\n\n    ans += tmp;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vint;\ntypedef vector<vector<pii> > vvpii;\n\nvvpii G0, rG0;\nvint Vs, Vtbl;\n\nconst int INF = 500000000;\n\nvoid compress(const vvpii &G, vint &near, vint &ndist, vvpii &Gc){\n\tint n = G.size();\n\tnear.assign(n, -1);\n\tndist.resize(n);\n\tGc.resize(Vs.size());\n\n\tfor(int i = 0; i < Vs.size(); ++i){\n\t\tint from = Vs[i];\n\t\tnear[from] = i;\n\n\t\tfor(int j = 0; j < G[from].size(); ++j){\n\t\t\tint dsum = G[from][j].first;\n\t\t\tint v = G[from][j].second;\n\t\t\twhile(Vtbl[v] < 0){\n\t\t\t\tnear[v] = i;\n\t\t\t\tndist[v] = dsum;\n\t\t\t\tdsum += G[v][0].first;\n\t\t\t\tv = G[v][0].second;\n\t\t\t}\n\t\t\tGc[i].push_back( pii(dsum, Vtbl[v]) );\n\t\t}\n\t}\n}\n\nvoid dijkstra(const vvpii &Gc, vector<vint> &dtbl){\n\tint nc = Gc.size();\n\tdtbl.assign(nc, vint(nc, INF));\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\n\tfor(int i = 0; i < nc; ++i){\n\t\tpq.push( pii(0, i) );\n\t\tdtbl[i][i] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.top().first, v = pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(dtbl[i][v] == c){\n\t\t\t\tfor(int j = 0; j < Gc[v].size(); ++j){\n\t\t\t\t\tint t = Gc[v][j].second, d = c + Gc[v][j].first;\n\t\t\t\t\tif(dtbl[i][t] > d){\n\t\t\t\t\t\tdtbl[i][t] = d;\n\t\t\t\t\t\tpq.push( pii(t, d) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve(){\n\tint n = G0.size();\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(G0[i].empty() || rG0[i].empty())\n\t\t\treturn -1;\n\t}\n\n\tVtbl.assign(n, -1);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(i < 2 || G0[i].size() > 1 || rG0[i].size() > 1){\n\t\t\tVtbl[i] = Vs.size();\n\t\t\tVs.push_back(i);\n\t\t}\n\t}\n\n\tvvpii Gc, rGc;\n\tvint near, rnear, ndist, rndist;\n\tcompress(G0, near, ndist, Gc);\n\tcompress(rG0, rnear, rndist, rGc);\n\n\tvector<vint> dtbl;\n\tdijkstra(Gc, dtbl);\n\n\tint from = n - 1;\n\tlong long ans = 0;\n\tfor(int to = 0; to < n; ++to){\n\t\tint vf = rnear[from], vt = near[to];\n\t\tif(vf < 0 || vt < 0) return -1;\n\t\t\n\t\tint mind = rndist[from] + dtbl[vf][vt] + ndist[to];\n\t\tif(near[from] == near[to] && rnear[from] == rnear[to]){\n\t\t\tint x = rndist[from] - rndist[to];\n\t\t\tif(x >= 0 && mind > x){\n\t\t\t\tmind = x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mind >= INF) return -1;\n\t\tans += mind;\n\n\t\tfrom = to;\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\tint n, m, a, b, c;\n\tcin >> n >> m;\n\tG0.resize(n);\n\trG0 = G0;\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> a >> b >> c;\n\t\tG0[a-1].push_back( pii(c, b-1) );\n\t\trG0[b-1].push_back( pii(c, a-1) );\n\t}\n\t\n\tcout << solve() << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_M = MAX_N + 500;\nconst int MAX_GN = 1000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\n\nstruct Edge {\n  int gi, gj, gc;\n  si vs;\n  Edge() {}\n  Edge(int _gi, int _gj, int _gc): gi(_gi), gj(_gj), gc(_gc) {}\n};\n\ntypedef vector<Edge *> ve;\n\n/* global variables */\n\nvpii nbrs[MAX_N];\nint ins[MAX_N], outs[MAX_N];\nint gids[MAX_N], g2i[MAX_GN], eids[MAX_N], dists[MAX_GN];\nEdge edges[MAX_GN * 2];\nvi gnbrs[MAX_GN];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  memset(ins, 0, sizeof(ins));\n  memset(outs, 0, sizeof(outs));\n\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--, b--;\n\n    nbrs[a].push_back(pii(b, c));\n    outs[a]++;\n    ins[b]++;\n  }\n\n  int gn = 0;\n  memset(gids, -1, sizeof(gids));\n  \n  for (int i = 0; i < n; i++) {\n    if (ins[i] == 0 || outs[i] == 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if (ins[i] > 1 || outs[i] > 1)\n      gids[i] = gn, g2i[gn++] = i;\n  }\n  //printf(\"gn=%d\\n\", gn);\n\n  if (gn == 0) {\n    ll csum = 0;\n    for (int i = 0; i < n; i++) {\n      int j = (i + 1) % n;\n      for (int ui = i; ui != j;) {\n\tpii& v = nbrs[ui].front();\n\tui = v.first;\n\tcsum += v.second;\n      }\n    }\n    cout << csum << endl;\n    return 0;\n  }\n  \n  int en = 0;\n  memset(eids, -1, sizeof(eids));\n\n  for (int gi = 0; gi < gn; gi++) {\n    int st = g2i[gi];\n    vpii& nbr = nbrs[st];\n\n    for (vpii::iterator vit = nbr.begin(); vit != nbr.end(); vit++) {\n      int ui = vit->first;\n      int csum = vit->second;\n\n      Edge& eu = edges[en];\n\n      while (gids[ui] < 0) {\n\teids[ui] = en;\n\teu.vs.insert(ui);\n\tpii& u = nbrs[ui].front();\n\tui = u.first;\n\tcsum += u.second;\n      }\n\n      eu.gi = gi;\n      eu.gj = gids[ui];\n      eu.gc = csum;\n\n      gnbrs[gi].push_back(en++);\n      //printf(\"edge[%d]: %d,%d,%d\\n\", en-1, eu.gi, eu.gj, eu.gc);\n    }\n  }\n  //printf(\"en=%d\\n\", en);\n\n  ll csum = 0;\n\n  for (int i0 = 0; i0 < n; i0++) {\n    //printf(\"%d/%d\\n\", i0, n);\n    int st = i0;\n    int gl = (i0 + 1) % n;\n\n    int gi0 = gids[st];\n\n    if (gi0 < 0) {\n      while (st != gl && gids[st] < 0) {\n\t//printf(\"%d->%d\\n\", st, gl);\n\tpii& u = nbrs[st].front();\n\tcsum += u.second;\n\tst = u.first;\n      }\n      gi0 = gids[st];\n      if (st == gl) continue;\n    }\n\n    int gi1 = (gids[gl] >= 0) ? gids[gl] : edges[eids[gl]].gi;\n    //printf(\"gi0, gi1 = %d, %d\\n\", gi0, gi1);\n    \n    for (int i = 0; i < gn; i++) dists[i] = INF;\n    dists[gi0] = 0;\n\n    priority_queue<pii,vpii,greater<pii> > q;\n    q.push(pii(0, gi0));\n\n    while (! q.empty()) {\n      pii u = q.top(); q.pop();\n      int& ud = u.first;\n      int& ui = u.second;\n      //printf(\"ui(%d)->gi1(%d)\\n\", ui, gi1);\n      \n      if (ud != dists[ui]) continue;\n      if (ui == gi1) break;\n\n      vi& gnbr = gnbrs[ui];\n      for (vi::iterator vit = gnbr.begin(); vit != gnbr.end(); vit++) {\n\tint& vi = edges[*vit].gj;\n\tint nvd = ud + edges[*vit].gc;\n\tif (dists[vi] > nvd) {\n\t  dists[vi] = nvd;\n\t  q.push(pii(nvd, vi));\n\t}\n      }\n    }\n\n    if (dists[gi1] >= INF) {\n      cout << -1 << endl;\n      return 0;\n    }\n\n    csum += dists[gi1];\n\n    if (eids[gl] >= 0) {\n      si& vs = edges[eids[gl]].vs;\n      st = g2i[gi1];\n      while (st != gl) {\n\t//printf(\"st(%d)->gl(%d)\\n\", st, gl);\n\tvpii& nbr = nbrs[st];\n\tfor (vpii::iterator vit = nbr.begin(); vit != nbr.end(); vit++)\n\t  if (vs.find(vit->first) != vs.end()) {\n\t    csum += vit->second;\n\t    st = vit->first;\n\t    break;\n\t  }\n      }\n    }\n  }\n\n  cout << csum << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\tfill(d.begin(), d.end(), INT_MAX); d[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t}\n\t\tdfs(E.v, g, in, vis, G, a, b);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tdfs(0, g, in, vis, G, a, b);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tll ans = 0;\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (b[u].first == b[v].first && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tvector<int> d(N);\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t}\n\t\tdfs(E.v, g, in, vis, G, a, b);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tdfs(0, g, in, vis, G, a, b);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] >= 2 || g[u].size() >= 2)\n\t\t\thoge.push_back(u);\n\tll ans = 0;\n\tvector<int> d(N);\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (b[u].first == b[v].first && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tfor (int i = 0; i < hoge.size(); i++)\n\t\t\td[hoge[i]] = INT_MAX;\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nvector<vector<pair<int, int> > > g;\nvector<int> in;\nvector<int> out;\nvector<bool> ok;\nvector<int> id;\nvector<int> from;\nvector<long long> fromdist;\nvector<int> to;\nvector<long long> todist;\nvector<vector<pair<int, long long> > > dist;\nvector<vector<long long> > dijk;\n\nint un;\n\nclass UnionFind{\nprivate:\n  vector<int> id;\n\n  int getId(int i){\n    if(i == id[i]) return i;\n    return id[i] = getId(id[i]);\n  }\npublic:\n  UnionFind(int size = 0){ init(size); }\n  ~UnionFind(){}\n  void init(int size){\n    id = vector<int>(size);\n    for(int i = 0; i < size; i++)\n      id[i] = i;\n  }\n  void unite(int i, int j){\n    int next = min( getId(i), getId(j) );\n    id[getId(i)] = id[getId(j)] = next;\n  }\n  int operator [](int i){ return getId(i); }\n  int count(){\n    set<int> s;\n    for(int i = 0; i < (int)id.size(); i++)\n      s.insert(getId(i));\n    return s.size();\n  }\n};\n\nUnionFind uf;\n\npair<int, long long> dfs(int pos, int init, ll dis = 0, bool first = true){\n  if((!first || pos != init) && ok[pos]){\n    dist[id[init]].push_back(mp(id[pos], dis));\n    return mp(pos, dis);\n  }\n\n  if(!ok[pos]){\n    from[id[pos]]     = init;\n    fromdist[id[pos]] = dis;\n  }\n\n  pair<int, int> last;\n  for(int i = 0; i < (int)g[pos].size(); i++){\n    int next = g[pos][i].f;\n    ll d = g[pos][i].s;\n\n    if(first) un = next;\n    last = dfs(next, init, dis + d, false);\n\n    if(!ok[pos]){\n      uf.unite(id[pos], id[un]);\n      to[id[pos]]     = last.first;\n      todist[id[pos]] = last.second - dis;\n    }\n  }\n\n  return last;\n}\n\nint main(){\n  int n = getInt();\n  int m = getInt();\n\n  g = vector<vector<pair<int, int> > >(n);\n  in = vector<int>(n);\n  out = vector<int>(n);\n  ok = vector<bool>(n, false);\n  id = vector<int>(n);\n\n  REP(i,m){\n    int a = getInt() - 1;\n    int b = getInt() - 1;\n    int c = getInt();\n\n    bool find = false;\n    for(int i = 0; i < g[a].size(); i++){\n      if(g[a][i].f == b){\n        find = true;\n        g[a][i].s = min(g[a][i].s, c);\n      }\n    }\n\n    if(!find){\n      g[a].push_back(mp(b, c));\n      in[b]++;\n      out[a]++;\n    }\n  }\n\n  map<int, int> okid;\n  map<int, int> trid;\n\n  REP(i,n){\n    if(in[i] == 0 || out[i] == 0){\n      puts(\"-1\");\n      return 0;\n    }\n    if(in[i] == 1 && out[i] == 1){\n      // trivial\n      int id2 = trid.size();\n      trid[id2] = i;\n      id[i] = id2;\n    }else{\n      // non-trivial\n      int id2 = okid.size();\n      okid[id2] = i;\n      ok[i] = true;\n      id[i] = id2;\n    }\n  }\n\n  // REP(i,n) printf(\"%d: %d\\n\", i, (int)ok[i]);\n\n  int N = okid.size();\n  int M = trid.size();\n  const long long MAX = (1ll << 60);\n  long long ans = 0;\n\n  if(N == 0){\n    id[n - 1] = 0;\n    id[n - 2] = 1;\n    ok[n - 1] = true;\n    ok[n - 2] = true;\n\n    N += 2;\n    M -= 2;\n  }\n\n  // printf(\"N: %d\\n\", N);\n  if(N > 1000) return 0;\n\n  dist = vector<vector<pair<int, ll> > >(N);\n  dijk = vector<vector<ll> >(N, vector<ll>(N, -1));\n\n  to = vector<int>(M, -1);\n  from = vector<int>(M, -1);\n\n  todist = vector<ll>(M);\n  fromdist = vector<ll>(M);\n\n  uf.init(M);\n\n  REP(i,n) if(ok[i]){\n    dfs(i, i);\n  }\n\n  //REP(k,N) REP(i,N) REP(j,N)\n  //  dist[i][j] = min((long long)dist[i][j], (long long)dist[i][k] + dist[k][j]);\n\n  REP(i,N){\n    typedef pair<long long, int> data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    pq.push(mp(0, i));\n    int cnt = 0;\n\n    while(!pq.empty() && cnt != N){\n      data d = pq.top(); pq.pop();\n      long long ds = d.f;\n      int pos = d.s;\n\n      if(dijk[i][pos] != -1) continue;\n      dijk[i][pos] = ds;\n      cnt++;\n\n      for(int j = 0; j < dist[pos].size(); j++){\n        int next     = dist[pos][j].f;\n        long long dd = ds + dist[pos][j].s;\n\n        if(dijk[i][next] == -1){\n          pq.push(mp(dd, next));\n        }\n      }\n    }\n  }\n\n\n  REP(i,N) REP(j,N) if(dijk[i][j] == -1){\n    puts(\"-1\");\n    return 0;\n  }\n\n  if(N != 0){\n    REP(i,M) if(from[i] == -1 || to[i] == -1){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n\n  // REP(i,N){ REP(j,N) printf(\"%4d \", (int)dijk[i][j]); puts(\"\"); }\n\n  for(int j = 0; j < n; j++){\n    int prev = j;\n    int next = j == n - 1 ? 0 : j + 1;\n    long long tmp = 0;\n\n    if(!ok[prev] && !ok[next] && uf[id[prev]] == uf[id[next]] && fromdist[id[prev]] < fromdist[id[next]]){\n      tmp += fromdist[id[next]] - fromdist[id[prev]];\n    }else{\n      if(!ok[prev]){\n        tmp += todist[id[prev]];\n        prev = to[id[prev]];\n      }\n\n      if(!ok[next]){\n        tmp += fromdist[id[next]];\n        next = from[id[next]];\n      }\n\n      tmp += dijk[id[prev]][id[next]];\n    }\n\n    // printf(\"%d => %d: %lld\\n\", j + 1, 1 + (j == n - 1 ? 0 : j + 1), tmp);\n\n    ans += tmp;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nvector<vector<pair<int, int> > > g;\nvector<int> in;\nvector<int> out;\nvector<bool> ok;\nvector<int> id;\nvector<int> from;\nvector<long long> fromdist;\nvector<int> to;\nvector<long long> todist;\nvector<vector<long long> > dist;\nvector<vector<long long> > dijk;\n\nint un;\n\nclass UnionFind{\nprivate:\n  vector<int> id;\n\n  int getId(int i){\n    if(i == id[i]) return i;\n    return id[i] = getId(id[i]);\n  }\npublic:\n  UnionFind(int size = 0){ init(size); }\n  ~UnionFind(){}\n  void init(int size){\n    id = vector<int>(size);\n    for(int i = 0; i < size; i++)\n      id[i] = i;\n  }\n  void unite(int i, int j){\n    int next = min( getId(i), getId(j) );\n    id[getId(i)] = id[getId(j)] = next;\n  }\n  int operator [](int i){ return getId(i); }\n  int count(){\n    set<int> s;\n    for(int i = 0; i < (int)id.size(); i++)\n      s.insert(getId(i));\n    return s.size();\n  }\n};\n\nUnionFind uf;\n\npair<int, long long> dfs(int pos, int init, ll dis = 0, bool first = true){\n  if((!first || pos != init) && ok[pos]){\n    dist[id[init]][id[pos]] = min(dist[id[init]][id[pos]], dis);\n    return mp(pos, dis);\n  }\n\n  if(!ok[pos]){\n    from[id[pos]]     = init;\n    fromdist[id[pos]] = dis;\n  }\n\n  pair<int, int> last;\n  for(int i = 0; i < (int)g[pos].size(); i++){\n    int next = g[pos][i].f;\n    ll d = g[pos][i].s;\n\n    if(first) un = next;\n    last = dfs(next, init, dis + d, false);\n\n    if(!ok[pos]){\n      uf.unite(id[pos], id[un]);\n      to[id[pos]]     = last.first;\n      todist[id[pos]] = last.second - dis;\n    }\n  }\n\n  return last;\n}\n\nint main(){\n  int n = getInt();\n  int m = getInt();\n\n  g = vector<vector<pair<int, int> > >(n);\n  in = vector<int>(n);\n  out = vector<int>(n);\n  ok = vector<bool>(n, false);\n  id = vector<int>(n);\n\n  REP(i,m){\n    int a = getInt() - 1;\n    int b = getInt() - 1;\n    int c = getInt();\n\n    bool find = false;\n    for(int i = 0; i < g[a].size(); i++){\n      if(g[a][i].f == b){\n        find = true;\n        g[a][i].s = min(g[a][i].s, c);\n      }\n    }\n\n    if(!find){\n      g[a].push_back(mp(b, c));\n      in[b]++;\n      out[a]++;\n    }\n  }\n\n  map<int, int> okid;\n  map<int, int> trid;\n\n  REP(i,n){\n    if(in[i] == 0 || out[i] == 0){\n      puts(\"-1\");\n      return 0;\n    }\n    if(in[i] == 1 && out[i] == 1){\n      // trivial\n      int id2 = trid.size();\n      trid[id2] = i;\n      id[i] = id2;\n    }else{\n      // non-trivial\n      int id2 = okid.size();\n      okid[id2] = i;\n      ok[i] = true;\n      id[i] = id2;\n    }\n  }\n\n  // REP(i,n) printf(\"%d: %d\\n\", i, (int)ok[i]);\n\n  int N = okid.size();\n  int M = trid.size();\n  const long long MAX = (1ll << 60);\n  long long ans = 0;\n\n  if(N == 0){\n    id[n - 1] = 0;\n    id[n - 2] = 1;\n    ok[n - 1] = true;\n    ok[n - 2] = true;\n\n    N += 2;\n    M -= 2;\n  }\n\n  // printf(\"N: %d\\n\", N);\n  if(N > 1000) return 0;\n\n  dist = vector<vector<ll> >(N, vector<ll>(N, MAX));\n  dijk = vector<vector<ll> >(N, vector<ll>(N, -1));\n\n  to = vector<int>(M, -1);\n  from = vector<int>(M, -1);\n\n  todist = vector<ll>(M);\n  fromdist = vector<ll>(M);\n\n  uf.init(M);\n\n  REP(i,N) dist[i][i] = 0;\n\n  REP(i,n) if(ok[i]){\n    dfs(i, i);\n  }\n\n  //REP(k,N) REP(i,N) REP(j,N)\n  //  dist[i][j] = min((long long)dist[i][j], (long long)dist[i][k] + dist[k][j]);\n\n  REP(i,N){\n    typedef pair<long long, int> data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    pq.push(mp(0, i));\n    int cnt = 0;\n\n    while(pq.size() || cnt != N){\n      data d = pq.top(); pq.pop();\n      int pos = d.s;\n      long long ds = d.f;\n\n      if(dijk[i][pos] != -1) continue;\n      dijk[i][pos] = ds;\n      cnt++;\n\n      int oid = okid[pos];\n\n      for(int j = 0; j < N; j++){\n        if(dijk[i][j] == -1 && dist[pos][j] != MAX){\n          long long dd = ds + dist[pos][j];\n          pq.push(mp(dd, j));\n        }\n      }\n    }\n  }\n\n\n  REP(i,N) REP(j,N) if(dijk[i][j] == MAX){\n    puts(\"-1\");\n    return 0;\n  }\n\n  if(N != 0){\n    REP(i,M) if(from[i] == -1 || to[i] == -1){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n\n  // REP(i,N){ REP(j,N) printf(\"%4d \", (int)dijk[i][j]); puts(\"\"); }\n\n  for(int j = 0; j < n; j++){\n    int prev = j;\n    int next = j == n - 1 ? 0 : j + 1;\n    long long tmp = 0;\n\n    if(!ok[prev] && !ok[next] && uf[id[prev]] == uf[id[next]] && fromdist[id[prev]] < fromdist[id[next]]){\n      tmp += fromdist[id[next]] - fromdist[id[prev]];\n    }else{\n      if(!ok[prev]){\n        tmp += todist[id[prev]];\n        prev = to[id[prev]];\n      }\n\n      if(!ok[next]){\n        tmp += fromdist[id[next]];\n        next = from[id[next]];\n      }\n\n      tmp += dijk[id[prev]][id[next]];\n    }\n\n    // printf(\"%d => %d: %lld\\n\", j + 1, 1 + (j == n - 1 ? 0 : j + 1), tmp);\n\n    ans += tmp;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nvector<vector<pair<int, int> > > g;\nvector<int> in;\nvector<int> out;\nvector<bool> ok;\nvector<int> id;\nvector<int> from;\nvector<long long> fromdist;\nvector<int> to;\nvector<long long> todist;\nvector<vector<pair<int, long long> > > dist;\nvector<vector<long long> > dijk;\n\nint un;\n\nclass UnionFind{\nprivate:\n  vector<int> id;\n\n  int getId(int i){\n    if(i == id[i]) return i;\n    return id[i] = getId(id[i]);\n  }\npublic:\n  UnionFind(int size = 0){ init(size); }\n  ~UnionFind(){}\n  void init(int size){\n    id = vector<int>(size);\n    for(int i = 0; i < size; i++)\n      id[i] = i;\n  }\n  void unite(int i, int j){\n    int next = min( getId(i), getId(j) );\n    id[getId(i)] = id[getId(j)] = next;\n  }\n  int operator [](int i){ return getId(i); }\n  int count(){\n    set<int> s;\n    for(int i = 0; i < (int)id.size(); i++)\n      s.insert(getId(i));\n    return s.size();\n  }\n};\n\nUnionFind uf;\n\nint init;\nll dis;\n\npair<int, long long> dfs(int pos, bool first = true){\n  if((!first || pos != init) && ok[pos]){\n    dist[id[init]].push_back(mp(id[pos], dis));\n    return mp(pos, dis);\n  }\n\n  if(!ok[pos]){\n    from[id[pos]]     = init;\n    fromdist[id[pos]] = dis;\n  }\n\n  pair<int, int> last;\n  for(int i = 0; i < (int)g[pos].size(); i++){\n    int next = g[pos][i].f;\n    ll d = g[pos][i].s;\n\n    if(first) un = next;\n\n    dis += d;\n    last = dfs(next, false);\n    dis -= d;\n\n    if(!ok[pos]){\n      uf.unite(id[pos], id[un]);\n      to[id[pos]]     = last.first;\n      todist[id[pos]] = last.second - dis;\n    }\n  }\n\n  return last;\n}\n\nint main(){\n  int n = getInt();\n  int m = getInt();\n\n  g = vector<vector<pair<int, int> > >(n);\n  in = vector<int>(n);\n  out = vector<int>(n);\n  ok = vector<bool>(n, false);\n  id = vector<int>(n);\n\n  REP(i,m){\n    int a = getInt() - 1;\n    int b = getInt() - 1;\n    int c = getInt();\n\n    bool find = false;\n    for(int i = 0; i < g[a].size(); i++){\n      if(g[a][i].f == b){\n        find = true;\n        g[a][i].s = min(g[a][i].s, c);\n      }\n    }\n\n    if(!find){\n      g[a].push_back(mp(b, c));\n      in[b]++;\n      out[a]++;\n    }\n  }\n\n  map<int, int> okid;\n  map<int, int> trid;\n\n  REP(i,n){\n    if(in[i] == 0 || out[i] == 0){\n      puts(\"-1\");\n      return 0;\n    }\n    if(in[i] == 1 && out[i] == 1){\n      // trivial\n      int id2 = trid.size();\n      trid[id2] = i;\n      id[i] = id2;\n    }else{\n      // non-trivial\n      int id2 = okid.size();\n      okid[id2] = i;\n      ok[i] = true;\n      id[i] = id2;\n    }\n  }\n\n  // REP(i,n) printf(\"%d: %d\\n\", i, (int)ok[i]);\n\n  int N = okid.size();\n  int M = trid.size();\n  const long long MAX = (1ll << 60);\n  long long ans = 0;\n\n  if(N == 0){\n    vector<ll> memo(n);\n\n    int cnt = 0;\n    int now = 0;\n    ll d = 0;\n    while(cnt != n){\n      if(cnt != 0 && 0 == now){\n        puts(\"-1\");\n        return 0;\n      }\n      cnt++;\n      d += g[now][0].s;\n      now = g[now][0].f;\n      memo[now] = d;\n    }\n\n    for(int i = 0; i < n; i++){\n      int j = i == n - 1 ? 0 : i + 1;\n\n      if(memo[j] > memo[i])\n        ans += memo[j] - memo[i];\n      else\n        ans += memo[0] - memo[i] + memo[j];\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n\n  // printf(\"N: %d\\n\", N);\n  if(N > 1000) return 0;\n\n  dist = vector<vector<pair<int, ll> > >(N);\n  dijk = vector<vector<ll> >(N, vector<ll>(N, -1));\n\n  to = vector<int>(M, -1);\n  from = vector<int>(M, -1);\n\n  todist = vector<ll>(M);\n  fromdist = vector<ll>(M);\n\n  uf.init(M);\n\n  REP(i,n) if(ok[i]){\n    init = i;\n    dfs(i);\n  }\n\n  //REP(k,N) REP(i,N) REP(j,N)\n  //  dist[i][j] = min((long long)dist[i][j], (long long)dist[i][k] + dist[k][j]);\n\n  REP(i,N){\n    typedef pair<long long, int> data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    pq.push(mp(0, i));\n    int cnt = 0;\n\n    while(!pq.empty() && cnt != N){\n      data d = pq.top(); pq.pop();\n      long long ds = d.f;\n      int pos = d.s;\n\n      if(dijk[i][pos] != -1) continue;\n      dijk[i][pos] = ds;\n      cnt++;\n\n      for(int j = 0; j < dist[pos].size(); j++){\n        int next     = dist[pos][j].f;\n        long long dd = ds + dist[pos][j].s;\n\n        if(dijk[i][next] == -1){\n          pq.push(mp(dd, next));\n        }\n      }\n    }\n  }\n\n  REP(i,N) REP(j,N) if(dijk[i][j] == -1){\n    puts(\"-1\");\n    return 0;\n  }\n\n  if(N != 0){\n    REP(i,M) if(from[i] == -1 || to[i] == -1){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n\n  // REP(i,N){ REP(j,N) printf(\"%4d \", (int)dijk[i][j]); puts(\"\"); }\n\n  for(int j = 0; j < n; j++){\n    int prev = j;\n    int next = j == n - 1 ? 0 : j + 1;\n    long long tmp = 0;\n\n    if(!ok[prev] && !ok[next] && uf[id[prev]] == uf[id[next]] && fromdist[id[prev]] < fromdist[id[next]]){\n      tmp += fromdist[id[next]] - fromdist[id[prev]];\n    }else{\n      if(!ok[prev]){\n        tmp += todist[id[prev]];\n        prev = to[id[prev]];\n      }\n\n      if(!ok[next]){\n        tmp += fromdist[id[next]];\n        next = from[id[next]];\n      }\n\n      tmp += dijk[id[prev]][id[next]];\n    }\n\n    // printf(\"%d => %d: %lld\\n\", j + 1, 1 + (j == n - 1 ? 0 : j + 1), tmp);\n\n    ans += tmp;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 4;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint unko = 0;\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b, vector<int>& c) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t\tc[f.v] = unko;\n\t\t}\n\t\tunko++;\n\t\tdfs(E.v, g, in, vis, G, a, b, c);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tin[0]++;\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tvector<int> c(N, -1);\n\tdfs(0, g, in, vis, G, a, b, c);\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1 && !vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1)\n\t\t\thoge.push_back(u);\n\tint n = hoge.size();\n\tvector<vector<int> > d(n, vector<int>(n, INF));\n\tfor (int i = 0; i < n; i++) d[i][i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint u = hoge[i];\n\t\tfor (int k = 0; k < G[u].size(); k++) {\n\t\t\tedge e = G[u][k];\n\t\t\tint j = lower_bound(hoge.begin(), hoge.end(), e.v) - hoge.begin();\n\t\t\td[i][j] = min(d[i][j], e.w);\n\t\t}\n\t}\n\tfor (int k = 0; k < n; k++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\tll ans = 0;\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (c[u] != -1 && c[v] != -1 && c[u] == c[v] && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tint i = lower_bound(hoge.begin(), hoge.end(), s) - hoge.begin();\n\t\tint j = lower_bound(hoge.begin(), hoge.end(), t) - hoge.begin();\n\t\tif (d[i][j] == INF) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans += d[i][j];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t}\n\t\tdfs(E.v, g, in, vis, G, a, b);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tdfs(0, g, in, vis, G, a, b);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] >= 2 || g[u].size() >= 2)\n\t\t\thoge.push_back(u);\n\tll ans = 0;\n\tvector<int> d(N);\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (a[u].first == a[v].first && b[u].first == b[v].first && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tfor (int i = 0; i < hoge.size(); i++)\n\t\t\td[hoge[i]] = INT_MAX;\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n\n#define SIZE 10000\n\nint glaf[SIZE+1][SIZE+1];\n\nint salesman(int count,int cost, int s,bool check[], int V){\n  int ans = -1;\n  if(count != 0) check[s] = true;\n  for(int i=1;i<=V;i++){\n    if(!check[i]) break;\n    else if(i==V) return cost;\n  }\n  for(int i=1;i<=V;i++){\n    if(glaf[s][i]!=0&&!check[i]){\n      int goal_cost = salesman(count+1,cost+glaf[s][i],i,check,V);\n      if(ans==-1 || ( goal_cost!=-1 && goal_cost < ans )) ans = goal_cost;\n    }\n  }\n  check[s] = false;\n  return ans;\n}\n\nint main(){\n  int V,E;\n  cin >> V >> E;\n  for(int i=1;i<=V;i++)\n    for(int j=1;j<=V;j++)\n      glaf[i][j] = 0;\n  bool check[V];\n  for(int i=1;i<V;i++)\n    check[i] = false;\n\n  int s,t,d;\n  for(int i=0;i<E;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] += d;\n  }\n\n  int ans = salesman(0,0,1,check,V);\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <list>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER)\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define EPS 1e-9\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\nint n, m;\nint indeg[100001], outdeg[100001];\nvector<pair<int,ll> > edges[100001];\n\nbool is_super(int i) {\n\treturn i == 0 || i == n-1 || indeg[i] != 1 || outdeg[i] != 1;\n}\n\nint root[100001]; ll dists[100001];\nvector<pair<int,ll> > superedges[100001];\nint superid[100001];\nll superdists[1111][1111];\n\nvoid dfs(int i, bool first, int a, ll dist) {\n\tif(!first && is_super(i)) {\n\t\tsuperedges[a].push_back(mp(i, dist));\n\t}else {\n\t\troot[i] = a;\n\t\tdists[i] = dist;\n\t\teach(j, edges[i])\n\t\t\tdfs(j->first, false, a, dist+j->second);\n\t}\n}\nstruct S {\n\tint i; ll d;\n\tS(int i_, ll d_): i(i_), d(d_) {}\n};\nbool operator<(const S &s, const S &t) {\n\treturn s.d > t.d;\n}\n\nll getdist(int i, int j) {\n\tll d = superdists[superid[root[i]]][superid[root[j]]];\n\tif(root[i] == root[j] && dists[i] <= dists[j])\n\t\td = 0;\n\tif(d == INFL || dists[i] == INFL || dists[j] == INFL)\n\t\treturn INFL;\n\treturn d - dists[i] + dists[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta --, b --;\n\t\tedges[a].pb(mp(b, c));\n\t\toutdeg[a] ++;\n\t\tindeg[b] ++;\n\t}\n\tint supers = 0;\n\trep(i, n) if(is_super(i)) supers ++;\n\tif(supers > 1100) {\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\tmset(dists, INF);\n\tsupers = 0;\n\trep(i, n) if(is_super(i)) {\n\t\tdfs(i, true, i, 0);\n\t\tsuperid[i] = supers;\n\t\tsupers ++;\n\t}\n\tmset(superdists, INF);\n\trep(i, n) if(is_super(i)) {\n\t\tstatic bool vis[1111];\n\t\tmset(vis, 0);\n\t\tint id = superid[i];\n\t\tpriority_queue<S> q;\n\t\teach(j, superedges[i])\n\t\t\tq.push(S(j->first, j->second));\n\t\twhile(!q.empty()) {\n\t\t\tS s = q.top(); q.pop();\n\t\t\tint sid = superid[s.i];\n\t\t\tif(vis[sid]) continue;\n\t\t\tsuperdists[id][sid] = s.d;\n\t\t\tvis[sid] = 1;\n\t\t\teach(j, superedges[s.i])\n\t\t\t\tq.push(S(j->first, s.d + j->second));\n\t\t}\n\t}\n\tll r = 0;\n\trep(i, n) {\n\t\tll d = getdist(i, (i+1)%n);\n\t\tif(d == INFL) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tr += d;\n\t}\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint unko = 0;\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b, vector<int>& c) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t\tc[f.v] = unko;\n\t\t}\n\t\tunko++;\n\t\tdfs(E.v, g, in, vis, G, a, b, c);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tin[0]++;\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tvector<int> c(N, -1);\n\tdfs(0, g, in, vis, G, a, b, c);\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1 && !vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1)\n\t\t\thoge.push_back(u);\n\tll ans = 0;\n\tvector<int> d(N);\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (c[u] != -1 && c[v] != -1 && c[u] == c[v] && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tfor (int i = 0; i < hoge.size(); i++)\n\t\t\td[hoge[i]] = INT_MAX;\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  map< int,map<int,int> > m;\n  int N,M;\n  cin >> N >> M;\n  int a,b,c;\n  for(int i=0;i<M;i++){\n    cin >> a >> b >> c;\n    m[a][b] = m[a][b]==0 ? c : min(m[a][b],c);\n  }\n\n  int ans = 0;\n  for(int k=1;k<=N;k++){\n    for(int i=1;i<=N;i++){\n      for(int j=1;j<=N;j++){\n        if(m[i][k]!=0&&m[k][j]!=0) m[i][j] = m[i][j]==0 ? m[i][k]+m[k][j] : min(m[i][j],m[i][k]+m[k][j]);\n      }\n    }\n  }\n  for(int i=1;i<=N;i++){\n    int next = i==N ? 1 : i+1;\n    if(m[i][next]==INF){\n      cout << -1 << endl;\n      return 0;\n    }\n    ans += m[i][next];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint unko = 0;\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b, vector<int>& c) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t\tc[f.v] = unko;\n\t\t}\n\t\tunko++;\n\t\tdfs(E.v, g, in, vis, G, a, b, c);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tvector<int> c(N, -1);\n\tdfs(0, g, in, vis, G, a, b, c);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] >= 2 || g[u].size() >= 2)\n\t\t\thoge.push_back(u);\n\tll ans = 0;\n\tvector<int> d(N);\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (c[u] == c[v] && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tfor (int i = 0; i < hoge.size(); i++)\n\t\t\td[hoge[i]] = INT_MAX;\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  int N,M;\n  cin >> N >> M;\n  int glaf[N+1][N+1];\n  for(int i=0;i<=N;i++){\n    for(int j=0;j<=N;j++){\n      glaf[i][j] = INF;\n    }\n    glaf[i][i] = 0;\n  }\n\n  int s,t,d;\n  for(int i=0;i<M;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = min(d,glaf[s][t]);\n  }\n\n  for(int k=1;k<=N;k++)\n    for(int i=1;i<=N;i++)\n      for(int j=1;j<=N;j++)\n        glaf[i][j] = min(glaf[i][j],glaf[i][k]+glaf[k][j]);\n\n  int ans = 0;\n  for(int i=1;i<=N;i++){\n    int g = (i==N) ? 1 : i+1;\n    if(glaf[i][g]==INF){\n      cout << -1 << endl;\n      return 0;\n    }\n    ans += glaf[i][g];\n  }\n  // for(int i=1;i<=N;i++){\n  //   for(int j=1;j<=N;j++)\n  //     printf(\"%3d \",glaf[i][j]);\n  //   cout << endl;\n  // }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N (100010)\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct edge {\n\tint to, cost;\n\tedge(int to, int cost) : to(to), cost(cost) {}\n\tedge(){}\n};\n\nvector<edge> g[MAX_N];\nbool vis[MAX_N];\nint tVertex[MAX_N];\nint len[MAX_N], dist[MAX_N], belong[MAX_N];\nint par[MAX_N], chi[MAX_N];\nint inDeg[MAX_N], outDeg[MAX_N];\nint d[1024][1024];\nint idx;\n\nvoid findCompress(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tedge e = g[v][i];\n\t\tif (!vis[e.to]){\n\t\t\tfindCompress(e.to);\n\t\t}\n\t}\n\t\n\tif (!v || inDeg[v] > 1 || outDeg[v] > 1){\n\t\ttVertex[v] = idx++;\n\t}\n}\n\nint s;\nint makeCompress(int now, int p, int cost, int id)\n{\n\tif (~tVertex[now]){\n\t\tbelong[now] = -1;\n\t\tlen[id] = cost;\n\t\td[tVertex[p]][tVertex[now]] = min(cost, d[tVertex[p]][tVertex[now]]);\n\t\tcost = 0;\n\t\tp = now;\n\t}\n\t\n\tif (vis[now]) return (tVertex[now]);\n\tif (!~tVertex[now]) belong[now] = id;\n\tvis[now] = true;\n\tpar[now] = tVertex[p];\n\tdist[now] = cost;\n\t\n\tint r = -1;\n\tfor (int i = 0; i < g[now].size(); i++){\n\t\tint nid = id;\n\t\tif (~tVertex[now]) nid = ++s;\n\t\tr = makeCompress(g[now][i].to, p, cost + g[now][i].cost, nid);\n\t}\n\tif (~tVertex[now]) r = tVertex[now];\n\t\n\treturn (chi[now] = r);\n}\n\nint main()\n{\n\tint n, m;\n\t\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t--a; --b;\n\t\tfor (int i = 0; i < g[a].size(); i++){\n\t\t\tif (g[a][i].to == b){\n\t\t\t\tg[a][i].cost = min(g[a][i].cost, c);\n\t\t\t\tgoto updated;\n\t\t\t}\n\t\t}\n\t\t\n\t\tg[a].push_back(edge(b, c));\n\t\toutDeg[a]++; inDeg[b]++;\n\t\tupdated:;\n\t}\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(tVertex, -1, sizeof(tVertex));\n\tmemset(par, -1, sizeof(par));\n\tfindCompress(0);\n\t\n\tif (idx >= 1024) return (!printf(\"-1\\n\"));\n\tfor (int i = 0; i < n; i++) if (vis[i] == false) return (!printf(\"-1\\n\"));\n\t\n\tfor (int i = 0; i < 1024; i++){\n\t\tfor (int j = 0; j < 1024; j++){\n\t\t\td[i][j] = 1 << 25;\n\t\t}\n\t\td[i][i] = 0;\n\t}\n\tmemset(vis, 0, sizeof(vis));\n\t\n\tmakeCompress(0, 0, 0, 0);\n\t\n\tfor (int k = 0; k < idx; k++){\n\t\tfor (int i = 0; i < idx; i++){\n\t\t\tfor (int j = 0; j < idx; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint res = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tint from = i, to = (i + 1) % n;\n\t\tint fl = belong[from], tl = belong[to];\n\t\tint c = chi[from], p = par[to];\n\t\tif (fl == tl && dist[from] < dist[to]){\n\t\t\tres += dist[to] - dist[from];\n\t\t}\n\t\telse {\n\t\t\tres += (!~fl ? 0 : (len[fl] - dist[from])) + d[c][p] + dist[to];\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int N,M;\n  cin >> N >> M;\n  int glaf[N+1][N+1];\n  for(int i=1;i<=N;i++)\n    for(int j=1;j<=N;j++)\n      glaf[i][j] = -1;\n\n  int s,t,d;\n  for(int i=0;i<M;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  for(int k=1;k<=N;k++){\n    for(int i=1;i<=N;i++){\n      for(int j=1;j<=N;j++){\n        if(glaf[i][k]!=-1&&glaf[k][j]!=-1){\n          glaf[i][j] = glaf[i][j] < 0 ? glaf[i][k]+glaf[k][j] : min(glaf[i][j],glaf[i][k]+glaf[k][j]);\n        }\n      }\n    }\n  }\n\n  int ans = 0;\n  for(int i=1;i<N;i++)\n    ans += glaf[i][i+1];\n  ans += glaf[N][1];\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <list>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER)\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define EPS 1e-9\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\nint n, m;\nint indeg[100001], outdeg[100001];\nvector<pair<int,ll> > edges[100001];\n\nbool is_super(int i) {\n\treturn i == 0 || i == n-1 || indeg[i] != 1 || outdeg[i] != 1;\n}\n\nint root[100001]; ll dists[100001];\nvector<pair<int,ll> > superedges[100001];\nint superid[100001];\nll superdists[1111][1111];\n\nvoid dfs(int i, bool first, int a, ll dist) {\n\tif(!first && is_super(i)) {\n\t\tsuperedges[a].push_back(mp(i, dist));\n\t}else {\n\t\troot[i] = a;\n\t\tdists[i] = dist;\n\t\teach(j, edges[i])\n\t\t\tdfs(j->first, false, a, dist+j->second);\n\t}\n}\nstruct S {\n\tint i; ll d;\n\tS(int i_, ll d_): i(i_), d(d_) {}\n};\nbool operator<(const S &s, const S &t) {\n\treturn s.d > t.d;\n}\n\nll getdist(int i, int j) {\n\tll d = superdists[superid[root[i]]][superid[root[j]]];\n\tif(root[i] == root[j] && dists[i] <= dists[j])\n\t\td = 0;\n\tif(d == INFL || dists[i] == INFL || dists[j] == INFL)\n\t\treturn INFL;\n\treturn d - dists[i] + dists[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta --, b --;\n\t\tedges[a].pb(mp(b, c));\n\t\toutdeg[a] ++;\n\t\tindeg[b] ++;\n\t}\n\tint supers = 0;\n\trep(i, n) if(is_super(i)) supers ++;\n\tif(supers > 1100) {\n\t\tcout << \"-1\";\n\t\treturn 0;\n\t}\n\tmset(dists, INF);\n\tsupers = 0;\n\trep(i, n) if(is_super(i)) {\n\t\tdfs(i, true, i, 0);\n\t\tsuperid[i] = supers;\n\t\tsupers ++;\n\t}\n\tmset(superdists, INF);\n\trep(i, n) if(is_super(i)) {\n\t\tstatic bool vis[1111];\n\t\tmset(vis, 0);\n\t\tint id = superid[i];\n\t\tpriority_queue<S> q;\n\t\teach(j, superedges[i])\n\t\t\tq.push(S(j->first, j->second));\n\t\twhile(!q.empty()) {\n\t\t\tS s = q.top(); q.pop();\n\t\t\tint sid = superid[s.i];\n\t\t\tif(vis[sid]) continue;\n\t\t\tsuperdists[id][sid] = s.d;\n\t\t\tvis[sid] = 1;\n\t\t\teach(j, superedges[s.i])\n\t\t\t\tq.push(S(j->first, s.d + j->second));\n\t\t}\n\t}\n\tll r = 0;\n\trep(i, n) {\n\t\tll d = getdist(i, (i+1)%n);\n\t\tif(d == INFL) {\n\t\t\tcout << \"-1\";\n\t\t\treturn 0;\n\t\t}\n\t\tr += d;\n\t}\n\tcout << r;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 4;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint unko = 0;\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b, vector<int>& c) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t\tc[f.v] = unko;\n\t\t}\n\t\tunko++;\n\t\tdfs(E.v, g, in, vis, G, a, b, c);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tin[0]++;\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tvector<int> c(N, -1);\n\tdfs(0, g, in, vis, G, a, b, c);\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1 && !vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1)\n\t\t\thoge.push_back(u);\n\tint n = hoge.size();\n\tvector<vector<int> > d(n, vector<int>(n, INF));\n\tfor (int i = 0; i < n; i++) d[i][i] = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tint u = hoge[i];\n\t\tfor (int k = 0; k < G[u].size(); k++) {\n\t\t\tedge e = G[u][k];\n\t\t\tint j = lower_bound(hoge.begin(), hoge.end(), e.v) - hoge.begin();\n\t\t\td[i][j] = min(d[i][j], e.w);\n\t\t}\n\t}\n\tfor (int k = 0; k < n; k++)\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\tll ans = 0;\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (c[u] != -1 && c[v] != -1 && c[u] == c[v] && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tint i = lower_bound(hoge.begin(), hoge.end(), s) - hoge.begin();\n\t\tint j = lower_bound(hoge.begin(), hoge.end(), t) - hoge.begin();\n\t\tans += d[i][j];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  int N,M;\n  cin >> N >> M;\n  int glaf[N+1][N+1];\n  for(int i=0;i<=N;i++){\n    for(int j=0;j<=N;j++){\n      glaf[i][j] = INF;\n    }\n    glaf[i][i] = 0;\n  }\n\n  int s,t,d;\n  for(int i=0;i<M;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  for(int k=1;k<=N;k++)\n    for(int i=1;i<=N;i++)\n      for(int j=1;j<=N;j++)\n        glaf[i][j] = min(glaf[i][j],glaf[i][k]+glaf[k][j]);\n\n  int ans = 0;\n  for(int i=1;i<=N;i++){\n    int g = (i==N) ? 1 : i+1;\n    if(glaf[i][g]==INF){\n      cout << -1 << endl;\n      return 0;\n    }\n    ans += glaf[i][g];\n  }\n  // for(int i=1;i<=N;i++){\n  //   for(int j=1;j<=N;j++)\n  //     printf(\"%3d \",glaf[i][j]);\n  //   cout << endl;\n  // }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\tfill(d.begin(), d.end(), INT_MAX); d[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t}\n\t\tdfs(E.v, g, in, vis, G, a, b);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tdfs(0, g, in, vis, G, a, b);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tll ans = 0;\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (b[u].first == b[v].first && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tvector<int> d(N);\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < int(n); ++ (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> inline void chmin(T & a, T const & b) { a = min(a, b); }\n\nvector<int> dijkstra(vector<vector<pair<int, int> > > const & g, int root) {\n    vector<int> dist(g.size(), INT_MAX);\n    priority_queue<pair<int, int> > que;\n    dist[root] = 0;\n    que.emplace(- dist[root], root);\n    while (not que.empty()) {\n        int dist_i; int i; tie(dist_i, i) = que.top(); que.pop();\n        if (dist[i] < - dist_i) continue;\n        for (auto it : g[i]) {\n            int j; int cost; tie(j, cost) = it;\n            if (- dist_i + cost < dist[j]) {\n                dist[j] = - dist_i + cost;\n                que.emplace(dist_i - cost, j);\n            }\n        }\n    }\n    return dist;\n}\n\nvector<vector<int> > warshall_floyd(vector<vector<pair<int, int> > > const & g) {\n    int n = g.size();\n    vector<vector<int> > dist(n, vector<int>(n, INT_MAX));\n    REP (i, n) {\n        dist[i][i] = 0;\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            dist[i][j] = cost;\n        }\n    }\n    REP (k, n) {\n        REP (i, n) if (dist[i][k] != INT_MAX) {\n            REP (j, n) if (dist[k][j] != INT_MAX) {\n                chmin(dist[i][j], dist[i][k] + dist[k][j]);\n            }\n        }\n    }\n    return dist;\n}\n\ntemplate <class Monoid>\nstruct sparse_table {\n    typedef typename Monoid::underlying_type underlying_type;\n    vector<vector<underlying_type> > table;\n    Monoid mon;\n    sparse_table() = default;\n    sparse_table(vector<underlying_type> const & data, Monoid const & a_mon = Monoid())\n            : mon(a_mon) {\n        int n = data.size();\n        int log_n = 32 - __builtin_clz(n);\n        table.resize(log_n, vector<underlying_type>(n, mon.unit()));\n        table[0] = data;\n        for (int k = 0; k < log_n-1; ++ k) {\n            for (int i = 0; i < n; ++ i) {\n                table[k+1][i] = mon.append(table[k][i], i + (1ll<<k) < n ? table[k][i + (1ll<<k)] : mon.unit());\n            }\n        }\n    }\n    underlying_type range_concat(int l, int r) const {\n        assert (0 <= l and l <= r and r <= table[0].size());\n        if (l == r) return mon.unit();\n        int k = 31 - __builtin_clz(r - l);  // log2\n        return mon.append(table[k][l], table[k][r - (1ll<<k)]);\n    }\n};\nstruct indexed_min_monoid {\n    typedef pair<int, int> underlying_type;\n    underlying_type unit() const { return { INT_MAX, INT_MAX }; }\n    underlying_type append(underlying_type a, underlying_type b) const { return min(a, b); }\n};\nstruct lowest_common_ancestor {\n    sparse_table<indexed_min_monoid> table;\n    vector<int> index;\n    lowest_common_ancestor() = default;\n    lowest_common_ancestor(int root, vector<vector<int> > const & g) {\n        vector<pair<int, int> > tour;\n        index.assign(g.size(), -1);\n        function<void (int, int, int)> go = [&](int i, int parent, int depth) {\n            index[i] = tour.size();\n            tour.emplace_back(depth, i);\n            for (int j : g[i]) if (j != parent) {\n                go(j, i, depth + 1);\n                tour.emplace_back(depth, i);\n            }\n        };\n        go(root, -1, 0);\n        table = sparse_table<indexed_min_monoid>(tour);\n    }\n    int operator () (int x, int y) const {\n        x = index[x];\n        y = index[y];\n        if (x > y) swap(x, y);\n        return table.range_concat(x, y + 1).second;\n    }\n};\n\nll solve(int n, int m, vector<vector<pair<int, int> > > & g) {\n\n    // erase duplicated edges\n    REP (i, n) {\n        sort(ALL(g[i]));\n        g[i].erase(unique(ALL(g[i]), [&](pair<int, int> e1, pair<int, int> e2) {\n            return e1.first == e2.first;\n        }), g[i].end());\n    }\n\n    // calculate shortest-paths and check the possibility\n    constexpr int root = 0;\n    vector<int> dist_root = dijkstra(g, root);\n    if (count(ALL(dist_root), INT_MAX)) {\n        return -1;\n    }\n    vector<vector<pair<int, int> > > rev_g(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            rev_g[j].emplace_back(i, cost);\n        }\n    }\n    auto rev_dist_root = dijkstra(rev_g, root);\n    if (count(ALL(rev_dist_root), INT_MAX)) {\n        return -1;\n    }\n\n    // make a shortest-path tree; collect the unused edges\n    vector<vector<int> > children(n);\n    vector<int> parent(n, -1);\n    vector<vector<pair<int, int> > > unused_edges(n);\n    REP (i, n) {\n        for (auto edge : g[i]) {\n            int j, cost; tie(j, cost) = edge;\n            if (dist_root[i] + cost == dist_root[j] and parent[j] == -1) {\n                children[i].push_back(j);\n                parent[j] = i;\n            } else {\n                unused_edges[i].emplace_back(j, cost);\n            }\n        }\n    }\n\n    // select and reorder distinguished vertices\n    map<int, int> distinguished;\n    auto distinguished_insert = [&](int i) {\n        if (not distinguished.count(i)) {\n            distinguished.emplace(i, distinguished.size());\n        }\n    };\n    distinguished_insert(0);\n    REP (i, n) {\n        if (not unused_edges[i].empty()) {\n            distinguished_insert(i);\n        }\n        for (auto edge : unused_edges[i]) {\n            int j = edge.first;\n            distinguished_insert(j);\n        }\n    }\n\n    // compute distances for all distinguished vertices; find the lowest distinguished ancestors for each vertex\n    vector<vector<pair<int, int> > > h(distinguished.size());\n    REP (i, n) {\n        for (auto edge : unused_edges[i]) {\n            int j, cost; tie(j, cost) = edge;\n            h[distinguished[i]].emplace_back(distinguished[j], cost);\n        }\n    }\n    vector<int> ancestor(n, -1);\n    function<void (int, int)> go = [&](int i, int last) {\n        if (distinguished.count(i)) {\n            if (last != -1) {\n                h[distinguished[last]].emplace_back(distinguished[i], dist_root[i] - dist_root[last]);\n            }\n            last = i;\n        }\n        ancestor[i] = last;\n        for (int j : children[i]) {\n            go(j, last);\n        }\n    };\n    go(root, -1);\n    auto dist = warshall_floyd(h);\n\n    // prepare the lca for the shortest-path tree\n    lowest_common_ancestor lca(root, children);\n\n    // compute the result\n    ll result = 0;\n    REP (i, n) {\n        int j = (i + 1) % n;\n        if (lca(i, j) == i) {\n            result += dist_root[j] - dist_root[i];\n        } else {\n            int acc = INT_MAX;\n            for (auto it : distinguished) {\n                int k, distinguished_k; tie(k, distinguished_k) = it;\n                if (lca(i, k) == i) {\n                    chmin(acc, (dist_root[k] - dist_root[i]) + dist[distinguished_k][distinguished[ancestor[j]]] + (dist_root[j] - dist_root[ancestor[j]]));\n                }\n            }\n            result += acc;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    // input\n    int n, m; scanf(\"%d%d\", &n, &m);\n    vector<vector<pair<int, int> > > g(n);\n    REP (i, m) {\n        int a, b, c; scanf(\"%d%d%d\", &a, &b, &c);\n        -- a; -- b;\n        g[a].emplace_back(b, c);\n    }\n    // solve\n    ll result = solve(n, m, g);\n    // output\n    printf(\"%lld\\n\", result);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\tfill(d.begin(), d.end(), INT_MAX); d[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t}\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tdfs(0, g, vis, G, a, b);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tll ans = 0;\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (b[u].first == b[v].first && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tvector<int> d(N);\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint unko = 0;\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b, vector<int>& c) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t\tc[f.v] = unko;\n\t\t}\n\t\tunko++;\n\t\tdfs(E.v, g, in, vis, G, a, b, c);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tin[0]++;\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tvector<int> c(N, -1);\n\tdfs(0, g, in, vis, G, a, b, c);\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1 && !vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (c[u] == -1)\n\t\t\thoge.push_back(u);\n\tll ans = 0;\n\tvector<int> d(N);\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (c[u] != -1 && c[v] != -1 && c[u] == c[v] && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tfor (int i = 0; i < hoge.size(); i++)\n\t\t\td[hoge[i]] = INT_MAX;\n\t\tdijkstra(N, G, s, d);\n\t\tif (d[t] == INT_MAX) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <list>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER)\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define EPS 1e-9\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\nint n, m;\nint indeg[100001], outdeg[100001];\nvector<pair<int,ll> > edges[100001];\n\nbool is_super(int i) {\n\treturn i == 0 || i == n-1 || indeg[i] != 1 || outdeg[i] != 1;\n}\n\nint root[100001]; ll dists[100001];\nvector<pair<int,ll> > superedges[100001];\nint superid[100001];\nll superdists[1111][1111];\n\nvoid dfs(int i, bool first, int a, ll dist) {\n\tif(!first && is_super(i)) {\n\t\tsuperedges[a].push_back(mp(i, dist));\n\t}else {\n\t\troot[i] = a;\n\t\tdists[i] = dist;\n\t\teach(j, edges[i])\n\t\t\tdfs(j->first, false, a, dist+j->second);\n\t}\n}\nstruct S {\n\tint i; ll d;\n\tS(int i_, ll d_): i(i_), d(d_) {}\n};\nbool operator<(const S &s, const S &t) {\n\treturn s.d > t.d;\n}\n\nll getdist(int i, int j) {\n\tll d = superdists[superid[root[i]]][superid[root[j]]];\n\tif(root[i] == root[j] && dists[i] <= dists[j])\n\t\td = 0;\n\tif(d == INFL || dists[i] == INFL || dists[j] == INFL)\n\t\treturn INFL;\n\treturn d - dists[i] + dists[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta --, b --;\n\t\tedges[a].pb(mp(b, c));\n\t\toutdeg[a] ++;\n\t\tindeg[b] ++;\n\t}\n\tint supers = 0;\n\trep(i, n) if(is_super(i)) supers ++;\n\tif(supers > 1100) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tmset(dists, INF);\n\tsupers = 0;\n\trep(i, n) if(is_super(i)) {\n\t\tdfs(i, true, i, 0);\n\t\tsuperid[i] = supers;\n\t\tsupers ++;\n\t}\n\tmset(superdists, INF);\n\trep(i, n) if(is_super(i)) {\n\t\tstatic bool vis[1111];\n\t\tmset(vis, 0);\n\t\tint id = superid[i];\n\t\tpriority_queue<S> q;\n\t\teach(j, superedges[i])\n\t\t\tq.push(S(j->first, j->second));\n\t\twhile(!q.empty()) {\n\t\t\tS s = q.top(); q.pop();\n\t\t\tint sid = superid[s.i];\n\t\t\tif(vis[sid]) continue;\n\t\t\tsuperdists[id][sid] = s.d;\n\t\t\tvis[sid] = 1;\n\t\t\teach(j, superedges[s.i])\n\t\t\t\tq.push(S(j->first, s.d + j->second));\n\t\t}\n\t}\n\tll r = 0;\n\trep(i, n) {\n\t\tll d = getdist(i, (i+1)%n);\n\t\tif(d == INFL) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tr += d;\n\t}\n\tprintf(\"%I64d\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define SIZE 10000\n\nint glaf[SIZE+1][SIZE+1];\n\nint salesman(int count,int cost, int s,bool check[], int V){\n  int ans = -1;\n  if(count != 0) check[s] = true;\n  for(int i=1;i<=V;i++){\n    if(!check[i]) break;\n    else if(i==V) return cost;\n  }\n  for(int i=1;i<=V;i++){\n    if(glaf[s][i]!=0&&!check[i]){\n      int goal_cost = salesman(count+1,cost+glaf[s][i],i,check,V);\n      if(ans==-1 || ( goal_cost!=-1 && goal_cost < ans )) ans = goal_cost;\n    }\n  }\n  check[s] = false;\n  return ans;\n}\n\nint main(){\n  int V,E;\n  cin >> V >> E;\n  for(int i=1;i<=V;i++)\n    for(int j=1;j<=V;j++)\n      glaf[i][j] = 0;\n  bool check[V];\n  for(int i=1;i<V;i++)\n    check[i] = false;\n\n  int s,t,d;\n  for(int i=0;i<E;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] += d;\n  }\n\n  int ans = salesman(0,0,1,check,V);\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nvector<vector<pair<int, int> > > g;\nvector<int> in;\nvector<int> out;\nvector<bool> ok;\nvector<int> id;\nvector<int> from;\nvector<long long> fromdist;\nvector<int> to;\nvector<long long> todist;\nvector<vector<pair<int, long long> > > dist;\nvector<vector<long long> > dijk;\n\nint un;\n\nclass UnionFind{\nprivate:\n  vector<int> id;\n\n  int getId(int i){\n    if(i == id[i]) return i;\n    return id[i] = getId(id[i]);\n  }\npublic:\n  UnionFind(int size = 0){ init(size); }\n  ~UnionFind(){}\n  void init(int size){\n    id = vector<int>(size);\n    for(int i = 0; i < size; i++)\n      id[i] = i;\n  }\n  void unite(int i, int j){\n    int next = min( getId(i), getId(j) );\n    id[getId(i)] = id[getId(j)] = next;\n  }\n  int operator [](int i){ return getId(i); }\n  int count(){\n    set<int> s;\n    for(int i = 0; i < (int)id.size(); i++)\n      s.insert(getId(i));\n    return s.size();\n  }\n};\n\nUnionFind uf;\n\nint init;\nll dis;\nbool first;\n\npair<int, long long> dfs(int pos){\n  if((!first || pos != init) && ok[pos]){\n    dist[id[init]].push_back(mp(id[pos], dis));\n    return mp(pos, dis);\n  }\n\n  first = false;\n  if(!ok[pos]){\n    from[id[pos]]     = init;\n    fromdist[id[pos]] = dis;\n  }\n\n  pair<int, int> last;\n  for(int i = 0; i < (int)g[pos].size(); i++){\n    int next = g[pos][i].f;\n    ll d = g[pos][i].s;\n\n    if(first) un = next;\n\n    dis += d;\n    last = dfs(next);\n    dis -= d;\n\n    if(!ok[pos]){\n      uf.unite(id[pos], id[un]);\n      to[id[pos]]     = last.first;\n      todist[id[pos]] = last.second - dis;\n    }\n  }\n\n  return last;\n}\n\nint main(){\n  int n = getInt();\n  int m = getInt();\n\n  g = vector<vector<pair<int, int> > >(n);\n  in = vector<int>(n);\n  out = vector<int>(n);\n  ok = vector<bool>(n, false);\n  id = vector<int>(n);\n\n  REP(i,m){\n    int a = getInt() - 1;\n    int b = getInt() - 1;\n    int c = getInt();\n\n    bool find = false;\n    for(int i = 0; i < g[a].size(); i++){\n      if(g[a][i].f == b){\n        find = true;\n        g[a][i].s = min(g[a][i].s, c);\n      }\n    }\n\n    if(!find){\n      g[a].push_back(mp(b, c));\n      in[b]++;\n      out[a]++;\n    }\n  }\n\n  map<int, int> okid;\n  map<int, int> trid;\n\n  REP(i,n){\n    if(in[i] == 0 || out[i] == 0){\n      puts(\"-1\");\n      return 0;\n    }\n    if(in[i] == 1 && out[i] == 1){\n      // trivial\n      int id2 = trid.size();\n      trid[id2] = i;\n      id[i] = id2;\n    }else{\n      // non-trivial\n      int id2 = okid.size();\n      okid[id2] = i;\n      ok[i] = true;\n      id[i] = id2;\n    }\n  }\n\n  // REP(i,n) printf(\"%d: %d\\n\", i, (int)ok[i]);\n\n  int N = okid.size();\n  int M = trid.size();\n  const long long MAX = (1ll << 60);\n  long long ans = 0;\n\n  if(N == 0){\n    vector<ll> memo(n);\n\n    int cnt = 0;\n    int now = 0;\n    ll d = 0;\n    while(cnt != n){\n      if(cnt != 0 && 0 == now){\n        puts(\"-1\");\n        return 0;\n      }\n      cnt++;\n      d += g[now][0].s;\n      now = g[now][0].f;\n      memo[now] = d;\n    }\n\n    for(int i = 0; i < n; i++){\n      int j = i == n - 1 ? 0 : i + 1;\n\n      if(memo[j] > memo[i])\n        ans += memo[j] - memo[i];\n      else\n        ans += memo[0] - memo[i] + memo[j];\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n  }\n\n  // printf(\"N: %d\\n\", N);\n  if(N > 1000) return 0;\n\n  dist = vector<vector<pair<int, ll> > >(N);\n  dijk = vector<vector<ll> >(N, vector<ll>(N, -1));\n\n  to = vector<int>(M, -1);\n  from = vector<int>(M, -1);\n\n  todist = vector<ll>(M);\n  fromdist = vector<ll>(M);\n\n  uf.init(M);\n\n  REP(i,n) if(ok[i]){\n    first = true;\n    init = i;\n    dfs(i);\n  }\n\n  //REP(k,N) REP(i,N) REP(j,N)\n  //  dist[i][j] = min((long long)dist[i][j], (long long)dist[i][k] + dist[k][j]);\n\n  REP(i,N){\n    typedef pair<long long, int> data;\n    priority_queue<data, vector<data>, greater<data> > pq;\n    pq.push(mp(0, i));\n    int cnt = 0;\n\n    while(!pq.empty() && cnt != N){\n      data d = pq.top(); pq.pop();\n      long long ds = d.f;\n      int pos = d.s;\n\n      if(dijk[i][pos] != -1) continue;\n      dijk[i][pos] = ds;\n      cnt++;\n\n      for(int j = 0; j < dist[pos].size(); j++){\n        int next     = dist[pos][j].f;\n        long long dd = ds + dist[pos][j].s;\n\n        if(dijk[i][next] == -1){\n          pq.push(mp(dd, next));\n        }\n      }\n    }\n  }\n\n\n  REP(i,N) REP(j,N) if(dijk[i][j] == -1){\n    puts(\"-1\");\n    return 0;\n  }\n\n  if(N != 0){\n    REP(i,M) if(from[i] == -1 || to[i] == -1){\n      puts(\"-1\");\n      return 0;\n    }\n  }\n\n\n  // REP(i,N){ REP(j,N) printf(\"%4d \", (int)dijk[i][j]); puts(\"\"); }\n\n  for(int j = 0; j < n; j++){\n    int prev = j;\n    int next = j == n - 1 ? 0 : j + 1;\n    long long tmp = 0;\n\n    if(!ok[prev] && !ok[next] && uf[id[prev]] == uf[id[next]] && fromdist[id[prev]] < fromdist[id[next]]){\n      tmp += fromdist[id[next]] - fromdist[id[prev]];\n    }else{\n      if(!ok[prev]){\n        tmp += todist[id[prev]];\n        prev = to[id[prev]];\n      }\n\n      if(!ok[next]){\n        tmp += fromdist[id[next]];\n        next = from[id[next]];\n      }\n\n      tmp += dijk[id[prev]][id[next]];\n    }\n\n    // printf(\"%d => %d: %lld\\n\", j + 1, 1 + (j == n - 1 ? 0 : j + 1), tmp);\n\n    ans += tmp;\n  }\n\n  printf(\"%lld\\n\", ans);\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <list>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER)\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define EPS 1e-9\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\nint n, m;\nint indeg[100001], outdeg[100001];\nvpii edges[100001];\n\nbool is_super(int i) {\n\treturn i == 0 || i == n-1 || indeg[i] != 1 || outdeg[i] != 1;\n}\n\nint root[100001], dists[100001];\nvpii superedges[100001];\nint superid[100001];\nint superdists[1111][1111];\n\nvoid dfs(int i, bool first, int a, int dist) {\n\tif(!first && is_super(i)) {\n\t\tsuperedges[a].push_back(mp(i, dist));\n\t}else {\n\t\troot[i] = a;\n\t\tdists[i] = dist;\n\t\teach(j, edges[i])\n\t\t\tdfs(j->first, false, a, dist+j->second);\n\t}\n}\nstruct S {\n\tint i, d;\n\tS(int i_, int d_): i(i_), d(d_) {}\n};\nbool operator<(const S &s, const S &t) {\n\treturn s.d > t.d;\n}\n\nint getdist(int i, int j) {\n\tint d = superdists[superid[root[i]]][superid[root[j]]];\n\tif(root[i] == root[j] && dists[i] <= dists[j])\n\t\td = 0;\n\tif(d == INF || dists[i] == INF || dists[j] == INF)\n\t\treturn INF;\n\treturn d - dists[i] + dists[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta --, b --;\n\t\tedges[a].pb(mp(b, c));\n\t\toutdeg[a] ++;\n\t\tindeg[b] ++;\n\t}\n\tint supers = 0;\n\trep(i, n) if(is_super(i)) supers ++;\n\tif(supers > 1100) {\n\t\tputs(\"-1\");\n\t\treturn 0;\n\t}\n\tmset(dists, INF);\n\tsupers = 0;\n\trep(i, n) if(is_super(i)) {\n\t\tdfs(i, true, i, 0);\n\t\tsuperid[i] = supers;\n\t\tsupers ++;\n\t}\n\tmset(superdists, INF);\n\trep(i, n) if(is_super(i)) {\n\t\tstatic bool vis[1111];\n\t\tmset(vis, 0);\n\t\tint id = superid[i];\n\t\tpriority_queue<S> q;\n\t\teach(j, superedges[i])\n\t\t\tq.push(S(j->first, j->second));\n\t\twhile(!q.empty()) {\n\t\t\tS s = q.top(); q.pop();\n\t\t\tint sid = superid[s.i];\n\t\t\tif(vis[sid]) continue;\n\t\t\tsuperdists[id][sid] = s.d;\n\t\t\tvis[sid] = 1;\n\t\t\teach(j, superedges[s.i])\n\t\t\t\tq.push(S(j->first, s.d + j->second));\n\t\t}\n\t}\n\tll r = 0;\n\trep(i, n) {\n\t\tint d = getdist(i, (i+1)%n);\n\t\tif(d == INF) {\n\t\t\tputs(\"-1\");\n\t\t\treturn 0;\n\t\t}\n\t\tr += d;\n\t}\n\tprintf(\"%d\\n\", r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vint;\ntypedef vector<vector<pii> > vvpii;\n\nvvpii G0, rG0;\nvint Vs, Vtbl;\n\nconst int INF = 500000000;\n\nvoid compress(const vvpii &G, vint &near, vint &ndist, vvpii &Gc){\n\tint n = G.size();\n\tnear.assign(n, -1);\n\tndist.resize(n);\n\tGc.resize(Vs.size());\n\n\tfor(int i = 0; i < Vs.size(); ++i){\n\t\tint from = Vs[i];\n\t\tnear[from] = i;\n\n\t\tfor(int j = 0; j < G[from].size(); ++j){\n\t\t\tint dsum = G[from][j].first;\n\t\t\tint v = G[from][j].second;\n\t\t\twhile(Vtbl[v] < 0){\n\t\t\t\tnear[v] = i;\n\t\t\t\tndist[v] = dsum;\n\t\t\t\tdsum += G[v][0].first;\n\t\t\t\tv = G[v][0].second;\n\t\t\t}\n\t\t\tGc[i].push_back( pii(dsum, Vtbl[v]) );\n\t\t}\n\t}\n}\n\nvoid dijkstra(const vvpii &Gc, vector<vint> &dtbl){\n\tint nc = Gc.size();\n\tdtbl.assign(nc, vint(nc, INF));\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\n\tfor(int i = 0; i < nc; ++i){\n\t\tpq.push( pii(0, i) );\n\t\tdtbl[i][i] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.top().first, v = pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(dtbl[i][v] == c){\n\t\t\t\tfor(int j = 0; j < Gc[v].size(); ++j){\n\t\t\t\t\tint t = Gc[v][j].second, d = c + Gc[v][j].first;\n\t\t\t\t\tif(dtbl[i][t] > d){\n\t\t\t\t\t\tdtbl[i][t] = d;\n\t\t\t\t\t\tpq.push( pii(d, t) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve(){\n\tint n = G0.size();\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(G0[i].empty() || rG0[i].empty())\n\t\t\treturn -1;\n\t}\n\n\tVtbl.assign(n, -1);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(i < 2 || G0[i].size() > 1 || rG0[i].size() > 1){\n\t\t\tVtbl[i] = Vs.size();\n\t\t\tVs.push_back(i);\n\t\t}\n\t}\n\n\tvvpii Gc, rGc;\n\tvint near, rnear, ndist, rndist;\n\tcompress(G0, near, ndist, Gc);\n\tcompress(rG0, rnear, rndist, rGc);\n\n\tvector<vint> dtbl;\n\tdijkstra(Gc, dtbl);\n\n\tint from = n - 1;\n\tlong long ans = 0;\n\tfor(int to = 0; to < n; ++to){\n\t\tint vf = rnear[from], vt = near[to];\n\t\tif(vf < 0 || vt < 0) return -1;\n\t\t\n\t\tint d = rndist[from] + dtbl[vf][vt] + ndist[to];\n\t\tif(near[from] == near[to] && rnear[from] == rnear[to]){\n\t\t\tint x = rndist[from] - rndist[to];\n\t\t\tif(x >= 0 && d > x){\n\t\t\t\td = x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(d >= INF) return -1;\n\t\tans += d;\n\n\t\tfrom = to;\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\tint n, m, a, b, c;\n\tcin >> n >> m;\n\tG0.resize(n);\n\trG0 = G0;\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> a >> b >> c;\n\t\tG0[a-1].push_back( pii(c, b-1) );\n\t\trG0[b-1].push_back( pii(c, a-1) );\n\t}\n\t\n\tcout << solve() << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  int N,M;\n  cin >> N >> M;\n  int glaf[N+1][N+1];\n  for(int i=0;i<=N;i++){\n    for(int j=0;j<=N;j++){\n      glaf[i][j] = INF;\n    }\n    glaf[i][i] = 0;\n  }\n\n  int s,t,d;\n  for(int i=0;i<M;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  for(int k=1;k<=N;k++)\n    for(int i=1;i<=N;i++)\n      for(int j=1;j<=N;j++)\n          glaf[i][j] = min(glaf[i][j],glaf[i][k]+glaf[k][j]);\n\n  int ans = 0;\n  for(int i=1;i<N;i++)\n    ans += glaf[i][i+1];\n  ans += glaf[N][1];\n  for(int i=1;i<N;i++) cout << glaf[i][i+1] << endl;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_M = MAX_N + 500;\nconst int MAX_GN = 1000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\ntypedef set<int> si;\n\nstruct Edge {\n  int gi, gj, gc;\n  si vs;\n  Edge() {}\n  Edge(int _gi, int _gj, int _gc): gi(_gi), gj(_gj), gc(_gc) {}\n};\n\ntypedef vector<Edge *> ve;\n\n/* global variables */\n\nvpii nbrs[MAX_N];\nint ins[MAX_N], outs[MAX_N];\nint gids[MAX_N], g2i[MAX_GN], eids[MAX_N], dists[MAX_GN][MAX_GN];\nEdge edges[MAX_GN * 2];\nvi gnbrs[MAX_GN];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  memset(ins, 0, sizeof(ins));\n  memset(outs, 0, sizeof(outs));\n\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--, b--;\n\n    nbrs[a].push_back(pii(b, c));\n    outs[a]++;\n    ins[b]++;\n  }\n\n  int gn = 0;\n  memset(gids, -1, sizeof(gids));\n  \n  for (int i = 0; i < n; i++) {\n    if (ins[i] == 0 || outs[i] == 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if (ins[i] > 1 || outs[i] > 1)\n      gids[i] = gn, g2i[gn++] = i;\n  }\n  //printf(\"gn=%d\\n\", gn);\n\n  if (gn == 0) {\n    ll csum = 0;\n    for (int i = 0; i < n; i++) {\n      int j = (i + 1) % n;\n      for (int ui = i; ui != j;) {\n\tpii& v = nbrs[ui].front();\n\tui = v.first;\n\tcsum += v.second;\n      }\n    }\n    cout << csum << endl;\n    return 0;\n  }\n  \n  int en = 0;\n  memset(eids, -1, sizeof(eids));\n\n  for (int gi = 0; gi < gn; gi++) {\n    int st = g2i[gi];\n    vpii& nbr = nbrs[st];\n\n    for (vpii::iterator vit = nbr.begin(); vit != nbr.end(); vit++) {\n      int ui = vit->first;\n      int csum = vit->second;\n\n      Edge& eu = edges[en];\n\n      while (gids[ui] < 0) {\n\teids[ui] = en;\n\teu.vs.insert(ui);\n\tpii& u = nbrs[ui].front();\n\tui = u.first;\n\tcsum += u.second;\n      }\n\n      eu.gi = gi;\n      eu.gj = gids[ui];\n      eu.gc = csum;\n\n      gnbrs[gi].push_back(en++);\n      //printf(\"edge[%d]: %d,%d,%d\\n\", en-1, eu.gi, eu.gj, eu.gc);\n    }\n  }\n  //printf(\"en=%d\\n\", en);\n\n  ll csum = 0;\n\n  for (int i = 0; i < gn; i++) {\n    for (int j = 0; j < gn; j++) dists[i][j] = INF;\n    dists[i][i] = 0;\n  }\n  \n  for (int i0 = 0; i0 < n; i0++) {\n    //printf(\"%d/%d\\n\", i0, n);\n    int st = i0;\n    int gl = (i0 + 1) % n;\n\n    int gi0 = gids[st];\n\n    if (gi0 < 0) {\n      while (st != gl && gids[st] < 0) {\n\t//printf(\"%d->%d\\n\", st, gl);\n\tpii& u = nbrs[st].front();\n\tcsum += u.second;\n\tst = u.first;\n      }\n      gi0 = gids[st];\n      if (st == gl) continue;\n    }\n\n    int gi1 = (gids[gl] >= 0) ? gids[gl] : edges[eids[gl]].gi;\n    //printf(\"gi0, gi1 = %d, %d\\n\", gi0, gi1);\n\n    if (dists[gi0][gi1] >= INF) {\n      priority_queue<pii,vpii,greater<pii> > q;\n      q.push(pii(0, gi0));\n\n      while (! q.empty()) {\n\tpii u = q.top(); q.pop();\n\tint& ud = u.first;\n\tint& ui = u.second;\n\t//printf(\"ui(%d)->gi1(%d)\\n\", ui, gi1);\n      \n\tif (ud != dists[gi0][ui]) continue;\n\t//if (ui == gi1) break;\n\n\tvi& gnbr = gnbrs[ui];\n\tfor (vi::iterator vit = gnbr.begin(); vit != gnbr.end(); vit++) {\n\t  int& vi = edges[*vit].gj;\n\t  int nvd = ud + edges[*vit].gc;\n\t  if (dists[gi0][vi] > nvd) {\n\t    dists[gi0][vi] = nvd;\n\t    q.push(pii(nvd, vi));\n\t  }\n\t}\n      }\n\n      if (dists[gi0][gi1] >= INF) {\n\tcout << -1 << endl;\n\treturn 0;\n      }\n    }\n\n    csum += dists[gi0][gi1];\n\n    if (eids[gl] >= 0) {\n      si& vs = edges[eids[gl]].vs;\n      st = g2i[gi1];\n      while (st != gl) {\n\t//printf(\"st(%d)->gl(%d)\\n\", st, gl);\n\tvpii& nbr = nbrs[st];\n\tfor (vpii::iterator vit = nbr.begin(); vit != nbr.end(); vit++)\n\t  if (vs.find(vit->first) != vs.end()) {\n\t    csum += vit->second;\n\t    st = vit->first;\n\t    break;\n\t  }\n      }\n    }\n  }\n\n  cout << csum << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <functional>\n#include <vector>\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef vector<int> vint;\ntypedef vector<vector<pii> > vvpii;\n\nvvpii G0, rG0;\nvint Vs, Vtbl;\n\nconst int INF = 500000000;\n\nvoid compress(const vvpii &G, vint &near, vint &ndist, vvpii &Gc){\n\tint n = G.size();\n\tnear.assign(n, -1);\n\tndist.resize(n);\n\tGc.resize(Vs.size());\n\n\tfor(int i = 0; i < Vs.size(); ++i){\n\t\tint from = Vs[i];\n\t\tnear[from] = from;\n\n\t\tfor(int j = 0; j < G[from].size(); ++j){\n\t\t\tint dsum = G[from][j].first;\n\t\t\tint v = G[from][j].second;\n\t\t\twhile(Vtbl[v] < 0){\n\t\t\t\tnear[v] = from;\n\t\t\t\tndist[v] = dsum;\n\t\t\t\tdsum += G[v][0].first;\n\t\t\t\tv = G[v][0].second;\n\t\t\t}\n\t\t\tGc[from].push_back( pii(dsum, v) );\n\t\t}\n\t}\n}\n\nvoid dijkstra(const vvpii &Gc, vector<vint > &dtbl){\n\tint nc = Gc.size();\n\tdtbl.assign(nc, vint(nc, INF));\n\tpriority_queue<pii,vector<pii>,greater<pii> > pq;\n\n\tfor(int i = 0; i < nc; ++i){\n\t\tpq.push( pii(0, i) );\n\t\tdtbl[i][i] = 0;\n\t\twhile(!pq.empty()){\n\t\t\tint c = pq.top().first, v = pq.top().second;\n\t\t\tpq.pop();\n\t\t\tif(dtbl[i][v] == c){\n\t\t\t\tfor(int j = 0; j < Gc[v].size(); ++j){\n\t\t\t\t\tint t = Gc[v][j].second, d = c + Gc[v][j].first;\n\t\t\t\t\tif(dtbl[i][t] > d){\n\t\t\t\t\t\tdtbl[i][t] = d;\n\t\t\t\t\t\tpq.push( pii(t, d) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nlong long solve(){\n\tint n = G0.size();\n\n\tfor(int i = 0; i < n; ++i){\n\t\tif(G0[i].empty() || rG0[i].empty())\n\t\t\treturn -1;\n\t}\n\n\tVtbl.assign(n, -1);\n\tfor(int i = 0; i < n; ++i){\n\t\tif(i < 2 || G0[i].size() > 1 || rG0[i].size() > 1){\n\t\t\tVtbl[i] = Vs.size();\n\t\t\tVs.push_back(i);\n\t\t}\n\t}\n\n\tvvpii Gc, rGc;\n\tvint near, rnear, ndist, rndist;\n\tcompress(G0, near, ndist, Gc);\n\tcompress(rG0, rnear, rndist, rGc);\n\n\tvector<vint> dtbl;\n\tdijkstra(Gc, dtbl);\n\n\tint from = n - 1;\n\tlong long ans = 0;\n\tfor(int to = 0; to < n; ++to){\n\t\tint vf = rnear[from], vt = near[to];\n\t\tif(vf < 0 || vt < 0) return -1;\n\t\t\n\t\tint mind = rndist[from] + dtbl[vf][vt] + ndist[to];\n\t\tif(near[from] == near[to] && rnear[from] == rnear[to]){\n\t\t\tint x = rndist[from] - rndist[to];\n\t\t\tif(x >= 0 && mind > x){\n\t\t\t\tmind = x;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(mind >= INF) return -1;\n\t\tans += mind;\n\n\t\tfrom = to;\n\t}\n\t\n\treturn ans;\n}\n\nint main(){\n\tint n, m, a, b, c;\n\tcin >> n >> m;\n\tG0.resize(n);\n\trG0 = G0;\n\t\n\tfor(int i = 0; i < m; ++i){\n\t\tcin >> a >> b >> c;\n\t\tG0[a-1].push_back( pii(c, b-1) );\n\t\trG0[b-1].push_back( pii(c, a-1) );\n\t}\n\t\n\tcout << solve() << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nint n, m;\nint q, r;\nint matrix[1010][1010];\nvector<pair<int, int> > g[100010];\nvector<pair<int, int> > revG[100010];\nbool visit[100010];\nint mapto[100010];\n\nint parent[100010];\nint child[100010];\nint lineNumber[100010];\nint dist[100010];\nint line[100010];\n\n// calc revG\nint dfs1(int from) {\n  if (visit[from]) { return 0; }\n  visit[from] = true;\n\n  int ret = 1;\n  FORIT(it, revG[from]) { ret += dfs1(it->first); }\n  return ret;\n}\n\n// calc degree > 1 node\nint dfs2(int from) {\n  if (visit[from]) {\n    if (mapto[from] == -1) { mapto[from] = q++; }\n    return 0;\n  }\n  visit[from] = true;\n\n  if (g[from].size() > 1 && mapto[from] == -1) {\n    mapto[from] = q++;\n  }\n\n  int ret = 1;\n  FORIT(it, g[from]) { ret += dfs2(it->first); }\n  return ret;\n}\n\n// calc dist\nint dfs3(int from, int p, int d, int number) {\n  if (mapto[from] != -1) {\n    lineNumber[from] = 0;\n    line[number] = d;\n    matrix[p][mapto[from]] = min(matrix[p][mapto[from]], d);\n    p = mapto[from];\n    d = 0;\n  }\n\n  if (visit[from]) {\n    assert(mapto[from] != -1);\n    return mapto[from];\n  }\n  visit[from] = true;\n\n  int ret = -1;\n  parent[from] = p;\n  dist[from] = d;\n\n  if (mapto[from] == -1) {\n    lineNumber[from] = number;\n  }\n\n  FORIT(it, g[from]) {\n    int nnumber = number;\n    if (mapto[from] != -1) { nnumber = r++; }\n    ret = dfs3(it->first, p, d + it->second, nnumber);\n  }\n  if (mapto[from] != -1) { ret = mapto[from]; }\n  child[from] = ret;\n\n  assert(ret != -1);\n  return ret;\n}\n\nint main() {\n  while (scanf(\"%d %d\", &n, &m) > 0) {\n    q = 0;\n    MEMSET(mapto, -1);\n    MEMSET(matrix, 0x0f);\n    MEMSET(lineNumber, 0);\n    MEMSET(line, 0);\n    REP(i, n) { g[i].clear(); }\n    REP(i, n) { revG[i].clear(); }\n    map<pair<int, int>, int> edge;\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      f--; t--;\n      pair<int, int> ft = make_pair(f, t);\n      if (!edge.count(ft)) { edge[ft] = 10000; }\n      edge[ft] = min(edge[ft], c);\n    }\n    FORIT(it, edge) {\n      int f = it->first.first;\n      int t = it->first.second;\n      int c = it->second;\n      g[f].push_back(make_pair(t, c));\n      revG[t].push_back(make_pair(f, c));\n    }\n\n    MEMSET(visit, false);\n    if (dfs1(0) != n) {\n      printf(\"-1\\n\");\n      continue;\n    }\n\n    MEMSET(visit, false);\n    q = 0;\n    mapto[0] = q++;\n    if (dfs2(0) != n) {\n      printf(\"-1\\n\");\n      continue;\n    }\n\n    MEMSET(visit, false);\n    r = 1;\n    dfs3(0, mapto[0], 1 << 30, 0);\n    line[0] = 0;\n    REP(i, q) { matrix[i][i] = 0; }\n    REP(k, q) REP(i, q) REP(j, q) {\n      matrix[i][j] = min(matrix[i][j], matrix[i][k] + matrix[k][j]);\n    }\n\n    ll ans = 0;\n    int prev = 0;\n    REP(i, n) {\n      int next = (i + 1) % n;\n      int pl = lineNumber[prev];\n      int nl = lineNumber[next];\n      //int pp = parent[prev];\n      int np = parent[next];\n      int pc = child[prev];\n      //int nc = child[next];\n      ll pans = ans;\n      if (pl == nl && dist[prev] < dist[next]) {\n        ans += dist[next] - dist[prev];\n      } else {\n        ans += line[pl] - dist[prev];\n        ans += matrix[pc][np];\n        ans += dist[next];\n      }\n      assert(ans > pans);\n      prev = next;\n    }\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  int N,M;\n  cin >> N >> M;\n  int glaf[N+1][N+1];\n  for(int i=0;i<=N;i++){\n    for(int j=0;j<=N;j++){\n      glaf[i][j] = INF;\n    }\n    glaf[i][i] = 0;\n  }\n\n  int s,t,d;\n  for(int i=0;i<M;i++){\n    cin >> s >> t >> d;\n    glaf[s][t] = d;\n  }\n\n  for(int k=1;k<=N;k++)\n    for(int i=1;i<=N;i++)\n      for(int j=1;j<=N;j++)\n          glaf[i][j] = min(glaf[i][j],glaf[i][k]+glaf[k][j]);\n\n  int ans = 0;\n  for(int i=1;i<N;i++)\n    ans += glaf[i][i+1];\n  ans += glaf[N][1];\n  //for(int i=1;i<N;i++) cout << glaf[i][i+1] << endl;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\nconst int MAX_M = MAX_N + 500;\nconst int MAX_GN = 1000;\n\nconst int INF = 1 << 30;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vpii;\n\nstruct Edge {\n  int gi, gj, gc;\n  Edge() {}\n  Edge(int _gi, int _gj, int _gc): gi(_gi), gj(_gj), gc(_gc) {}\n};\n\ntypedef vector<Edge *> ve;\n\n/* global variables */\n\nvpii nbrs[MAX_N];\nint ins[MAX_N], outs[MAX_N];\nint gids[MAX_N], g2i[MAX_GN], eids[MAX_N], dists[MAX_GN];\nEdge edges[MAX_GN];\nvi gnbrs[MAX_GN];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  memset(ins, 0, sizeof(ins));\n  memset(outs, 0, sizeof(outs));\n\n  for (int i = 0; i < m; i++) {\n    int a, b, c;\n    cin >> a >> b >> c;\n    a--, b--;\n\n    nbrs[a].push_back(pii(b, c));\n    outs[a]++;\n    ins[b]++;\n  }\n\n  int gn = 0;\n  memset(gids, -1, sizeof(gids));\n  \n  for (int i = 0; i < n; i++) {\n    if (ins[i] == 0 || outs[i] == 0) {\n      cout << -1 << endl;\n      return 0;\n    }\n    if (ins[i] > 1 || outs[i] > 1)\n      gids[i] = gn, g2i[gn++] = i;\n  }\n  //printf(\"gn=%d\\n\", gn);\n\n  if (gn == 0) {\n    int csum = 0;\n    for (int i = 0; i < n; i++) {\n      int j = (i + 1) % n;\n      for (int ui = i; ui != j;) {\n\tpii& v = nbrs[ui].front();\n\tui = v.first;\n\tcsum += v.second;\n      }\n    }\n    cout << csum << endl;\n    return 0;\n  }\n  \n  int en = 0;\n  memset(eids, -1, sizeof(eids));\n\n  for (int gi = 0; gi < gn; gi++) {\n    int st = g2i[gi];\n    vpii& nbr = nbrs[st];\n\n    for (vpii::iterator vit = nbr.begin(); vit != nbr.end(); vit++) {\n      int ui = vit->first;\n      int csum = vit->second;\n\n      Edge& eu = edges[en];\n\n      while (gids[ui] < 0) {\n\teids[ui] = en;\n\tpii& u = nbrs[ui].front();\n\tui = u.first;\n\tcsum += u.second;\n      }\n\n      eu.gi = gi;\n      eu.gj = gids[ui];\n      eu.gc = csum;\n\n      gnbrs[gi].push_back(en++);\n      //printf(\"edge[%d]: %d,%d,%d\\n\", en-1, eu.gi, eu.gj, eu.gc);\n    }\n  }\n  //printf(\"en=%d\\n\", en);\n\n  int csum = 0;\n\n  for (int i0 = 0; i0 < n; i0++) {\n    int st = i0;\n    int gl = (i0 + 1) % n;\n\n    int gi0 = gids[st];\n    //printf(\"gi0=%d,gi1=%d,ei0=%d,ei1=%d\\n\", gi0, gi1, ei0, ei1);\n\n    if (gi0 < 0) {\n      while (st != gl && gids[st] < 0) {\n\tpii& u = nbrs[st].front();\n\tcsum += u.second;\n\tst = u.first;\n      }\n      gi0 = gids[st];\n      if (st == gl) continue;\n    }\n\n    int gi1 = (gids[gl] >= 0) ? gids[gl] : edges[eids[gl]].gi;\n    \n    for (int i = 0; i < gn; i++) dists[i] = INF;\n    dists[gi0] = 0;\n\n    priority_queue<pii,vpii,greater<pii> > q;\n    q.push(pii(0, gi0));\n\n    while (! q.empty()) {\n      pii u = q.top(); q.pop();\n      int& ud = u.first;\n      int& ui = u.second;\n\n      if (ud != dists[ui]) continue;\n      if (ui == gi1) break;\n\n      vi& gnbr = gnbrs[ui];\n      for (vi::iterator vit = gnbr.begin(); vit != gnbr.end(); vit++) {\n\tint& vi = edges[*vit].gj;\n\tint nvd = ud + edges[*vit].gc;\n\tif (dists[vi] > nvd) {\n\t  dists[vi] = nvd;\n\t  q.push(pii(nvd, vi));\n\t}\n      }\n    }\n\n    if (dists[gi1] >= INF) {\n      cout << -1 << endl;\n      return 0;\n    }\n\n    csum += dists[gi1];\n\n    st = g2i[gi1];\n    while (st != gl) {\n      pii& u = nbrs[st].front();\n      st = u.first;\n      csum += u.second;\n    }\n  }\n\n  cout << csum << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int v, w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\nint INF = INT_MAX / 2;\n\nvoid dijkstra(int n, vector<vector<edge> >& G, int s, vector<int>& d) {\n\td[s] = 0;\n\tpriority_queue<i_i, vector<i_i>, greater<i_i> > q;\n\tq.push(i_i(0, s));\n\twhile (!q.empty()) {\n\t\ti_i p = q.top(); q.pop();\n\t\tint u = p.second;\n\t\tif (p.first > d[u]) continue;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tedge e = G[u][i];\n\t\t\tif (d[e.v] > d[u] + e.w) {\n\t\t\t\td[e.v] = d[u] + e.w;\n\t\t\t\tq.push(i_i(d[e.v], e.v));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint unko = 0;\n\nvoid dfs(int u, vector<vector<edge> >& g, vector<int>& in, vector<bool>& vis, vector<vector<edge> >& G, vector<i_i>& a, vector<i_i>& b, vector<int>& c) {\n\tif (vis[u]) return;\n\tvis[u] = true;\n\ta[u] = b[u] = i_i(u, 0);\n\tfor (int i = 0; i < g[u].size(); i++) {\n\t\tedge e = g[u][i];\n\t\tedge f;\n\t\tint sum = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0])\n\t\t\tsum += f.w;\n\t\tsum += f.w;\n\t\tedge E = {f.v, sum};\n\t\tG[u].push_back(E);\n\t\tint x = 0;\n\t\tfor (f = e; in[f.v] == 1 && g[f.v].size() == 1; f = g[f.v][0]) {\n\t\t\tvis[f.v] = true;\n\t\t\tx += f.w;\n\t\t\ta[f.v] = i_i(E.v, sum - x);\n\t\t\tb[f.v] = i_i(u, x);\n\t\t\tc[f.v] = unko;\n\t\t}\n\t\tunko++;\n\t\tdfs(E.v, g, in, vis, G, a, b, c);\n\t}\n}\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> in(N);\n\tvector<vector<edge> > g(N);\n\tedge e = {0, 0};\n\tg[0].push_back(e);\n\twhile (M--) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--; b--;\n\t\tin[b]++;\n\t\tedge e = {b, c};\n\t\tg[a].push_back(e);\n\t}\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] == 0 || g[u].empty()) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<bool> vis(N);\n\tvector<vector<edge> > G(N);\n\tvector<i_i> a(N), b(N);\n\tvector<int> c(N, -1);\n\tdfs(0, g, in, vis, G, a, b, c);\n\tfor (int u = 0; u < N; u++)\n\t\tif (!vis[u]) {\n\t\t\tcout << -1 << endl;\n\t\t\treturn 0;\n\t\t}\n\tvector<int> hoge;\n\tfor (int u = 0; u < N; u++)\n\t\tif (in[u] >= 2 || g[u].size() >= 2)\n\t\t\thoge.push_back(u);\n\tll ans = 0;\n\tvector<int> d(N);\n\tfor (int u = 0; u < N; u++) {\n\t\tint v = (u + 1) % N;\n\t\tif (c[u] != -1 && c[v] != -1 && c[u] == c[v] && b[u].second < b[v].second) {\n\t\t\tans += b[v].second - b[u].second;\n\t\t\tcontinue;\n\t\t}\n\t\tint s = a[u].first, t = b[v].first;\n\t\tans += a[u].second + b[v].second;\n\t\tfor (int i = 0; i < hoge.size(); i++)\n\t\t\td[hoge[i]] = INT_MAX;\n\t\tdijkstra(N, G, s, d);\n\t\tans += d[t];\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\n\n#define INF 100000000\n\nint main(){\n  map<int,map<int,int>> m;\n  int N,M;\n  cin >> N >> M;\n  int a,b,c;\n  for(int i=0;i<M;i++){\n    cin >> a >> b >> c;\n    m[a][b] = m[a][b]==0 ? c : min(m[a][b],c);\n  }\n\n  int ans = 0;\n  for(int k=1;k<=N;k++){\n    for(int i=1;i<=N;i++){\n      for(int j=1;j<=N;j++){\n        if(m[i][k]!=0&&m[k][j]!=0) m[i][j] = m[i][j]==0 ? m[i][k]+m[k][j] : min(m[i][j],m[i][k]+m[k][j]);\n      }\n    }\n  }\n  for(int i=1;i<=N;i++){\n    int next = i==N ? 1 : i+1;\n    if(m[i][next]==INF){\n      cout << -1 << endl;\n      return 0;\n    }\n    ans += m[i][next];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define MAX_N (100010)\n\nusing namespace std;\n\ntypedef long long lint;\n\nstruct edge {\n\tint to, cost;\n\tedge(int to, int cost) : to(to), cost(cost) {}\n\tedge(){}\n};\n\nvector<edge> g[MAX_N];\nbool vis[MAX_N];\nint tVertex[MAX_N];\nint len[MAX_N], dist[MAX_N], belong[MAX_N];\nint par[MAX_N], chi[MAX_N];\nint inDeg[MAX_N], outDeg[MAX_N];\nint d[1024][1024];\nint idx;\n\nvoid findCompress(int v)\n{\n\tvis[v] = true;\n\t\n\tfor (int i = 0; i < g[v].size(); i++){\n\t\tedge e = g[v][i];\n\t\tif (!vis[e.to]){\n\t\t\tfindCompress(e.to);\n\t\t}\n\t}\n\t\n\tif (!v || inDeg[v] > 1 || outDeg[v] > 1){\n\t\ttVertex[v] = idx++;\n\t}\n}\n\nint s;\nint makeCompress(int now, int p, int cost, int id)\n{\n\tif (~tVertex[now]){\n\t\tbelong[now] = -1;\n\t\tlen[id] = cost;\n\t\td[tVertex[p]][tVertex[now]] = min(cost, d[tVertex[p]][tVertex[now]]);\n\t\tcost = 0;\n\t\tp = now;\n\t}\n\t\n\tif (vis[now]) return (tVertex[now]);\n\tif (!~tVertex[now]) belong[now] = id;\n\tvis[now] = true;\n\tpar[now] = tVertex[p];\n\tdist[now] = cost;\n\t\n\tint r = -1;\n\tfor (int i = 0; i < g[now].size(); i++){\n\t\tint nid = id;\n\t\tif (~tVertex[now]) nid = ++s;\n\t\tr = makeCompress(g[now][i].to, p, cost + g[now][i].cost, nid);\n\t}\n\tif (~tVertex[now]) r = tVertex[now];\n\t\n\treturn (chi[now] = r);\n}\n\nint main()\n{\n\tint n, m;\n\t\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d %d %d\", &a, &b, &c);\n\t\t--a; --b;\n\t\tfor (int i = 0; i < g[a].size(); i++){\n\t\t\tif (g[a][i].to == b){\n\t\t\t\tg[a][i].cost = min(g[a][i].cost, c);\n\t\t\t\tgoto updated;\n\t\t\t}\n\t\t}\n\t\t\n\t\tg[a].push_back(edge(b, c));\n\t\toutDeg[a]++; inDeg[b]++;\n\t\tupdated:;\n\t}\n\t\n\tmemset(vis, 0, sizeof(vis));\n\tmemset(tVertex, -1, sizeof(tVertex));\n\tmemset(par, -1, sizeof(par));\n\tfindCompress(0);\n\t\n\tif (idx >= 1024) return (!printf(\"-1\\n\"));\n\tfor (int i = 0; i < n; i++) if (vis[i] == false) return (!printf(\"-1\\n\"));\n\t\n\tfor (int i = 0; i < 1024; i++){\n\t\tfor (int j = 0; j < 1024; j++){\n\t\t\td[i][j] = 1 << 25;\n\t\t}\n\t\td[i][i] = 0;\n\t}\n\tmemset(vis, 0, sizeof(vis));\n\tmakeCompress(0, 0, 0, 0);\n\t\n\tfor (int k = 0; k < idx; k++){\n\t\tfor (int i = 0; i < idx; i++){\n\t\t\tfor (int j = 0; j < idx; j++){\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n    for (int i = 0; i < idx; i++){\n        for (int j = 0; j < idx; j++){\n            if (d[i][j] == 1 << 25) return (!printf(\"-1\\n\"));\n        }\n    }\t\n\tlint res = 0;\n\t\n\tfor (int i = 0; i < n; i++){\n\t\tint from = i, to = (i + 1) % n;\n\t\tint fl = belong[from], tl = belong[to];\n\t\tint c = chi[from], p = par[to];\n\t\tif (fl == tl && dist[from] < dist[to]){\n\t\t\tres += dist[to] - dist[from];\n\t\t}\n\t\telse {\n\t\t\tres += (!~fl ? 0 : (len[fl] - dist[from])) + d[c][p] + dist[to];\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", res);\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <list>\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\n#if defined(_MSC_VER)\n#define aut(r,v) auto r = (v)\n#else\n#define aut(r,v) typeof(v) r = (v)\n#endif\n#define each(it,o) for(aut(it, (o).begin()); it != (o).end(); ++ it)\n#define all(o) (o).begin(), (o).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset(m,v,sizeof(m))\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define EPS 1e-9\nusing namespace std;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\nint n, m;\nint indeg[100001], outdeg[100001];\nvector<pair<int,ll> > edges[100001];\n\nbool is_super(int i) {\n\treturn i == 0 || i == n-1 || indeg[i] != 1 || outdeg[i] != 1;\n}\n\nint root[100001], root2[100001], last[100001]; ll dists[100001], dists2[100001];\nvector<pair<int,ll> > superedges[100001];\nint superid[100001];\nll superdists[1111][1111];\n\nint dfs(int i, bool first, int a, int b, ll dist, ll &dist2) {\n\tif(!first && is_super(i)) {\n\t\tsuperedges[a].push_back(mp(i, dist));\n\t\tdist2 = 0;\n\t\treturn i;\n\t}else {\n\t\troot[i] = a;\n\t\troot2[i] = first ? i : b;\n\t\tdists[i] = dist;\n\t\tint l = -INF;\n\t\teach(j, edges[i]) {\n\t\t\tl = dfs(j->first, false, a, b == -1 ? j->first : b, dist+j->second, dist2);\n\t\t}\n\t\tif(first) last[i] = i, dists2[i] = 0;\n\t\telse {\n\t\t\teach(j, edges[i]) dist2 += j->second;\n\t\t\tlast[i] = l, dists2[i] = dist2;\n\t\t}\n\t\treturn l;\n\t}\n}\nstruct S {\n\tint i; ll d;\n\tS(int i_, ll d_): i(i_), d(d_) {}\n};\nbool operator<(const S &s, const S &t) {\n\treturn s.d > t.d;\n}\n\nll getdist(int i, int j) {\n\tif((root2[i] == root2[j] || root[j] == i) && dists[i] <= dists[j])\n\t\treturn dists[j] - dists[i];\n\tll d = superdists[superid[last[i]]][superid[root[j]]];\n\tif(d == INFL)\n\t\treturn INFL;\n\treturn d + dists2[i] + dists[j];\n}\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, m) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\ta --, b --;\n\t\tedges[a].pb(mp(b, c));\n\t\toutdeg[a] ++;\n\t\tindeg[b] ++;\n\t}\n\tint supers = 0;\n\trep(i, n) if(is_super(i)) supers ++;\n\tif(supers > 1100) {\n\t\tcout << \"-1\" << endl;\n\t\treturn 0;\n\t}\n\tsupers = 0;\n\trep(i, n) if(is_super(i)) {\n\t\tll d;\n\t\tdfs(i, true, i, -1, 0, d);\n\t\tsuperid[i] = supers;\n\t\tsupers ++;\n\t}\n\tmset(superdists, INF);\n\trep(i, n) if(is_super(i)) {\n\t\tstatic bool vis[1111];\n\t\tmset(vis, 0);\n\t\tint id = superid[i];\n\t\tpriority_queue<S> q;\n\t\tq.push(S(i, 0));\n\t\twhile(!q.empty()) {\n\t\t\tS s = q.top(); q.pop();\n\t\t\tint sid = superid[s.i];\n\t\t\tif(vis[sid]) continue;\n\t\t\tsuperdists[id][sid] = s.d;\n\t\t\tvis[sid] = 1;\n\t\t\teach(j, superedges[s.i])\n\t\t\t\tq.push(S(j->first, s.d + j->second));\n\t\t}\n\t}\n\tll r = 0;\n\trep(i, n) {\n\t\tll d = getdist(i, (i+1)%n);\n\t\tif(d == INFL) {\n\t\t\tcout << \"-1\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tr += d;\n\t}\n\tcout << r << endl;\n\treturn 0;\n}"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighborCost = {i: dict() for i in range(1,n+1)}\nfullCost = {i: float('inf') for i in range(1,n+1)}\nfullCost[1] = 0\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    try:\n        if cost < neighborCost[fro][to]:\n            neighborCost[fro][to] = cost\n    except KeyError:\n        neighborCost[fro][to] = cost\n\ndef minCostNode(fullCost, visited):\n    neededNodes = {node: cost for node,cost in fullCost.items() if node not in visited}\n    return min(neededNodes, key=neededNodes.get) if neededNodes else None\n\ndef calcFullCost(fullCost, start, goal):\n    visited = set()\n    hub = start\n    while hub:\n        for neighbor,cost in neighborCost[hub].items():\n            newCost = fullCost[hub] + cost\n            if newCost < fullCost[neighbor]:\n                fullCost[neighbor] = newCost\n        visited.add(hub)\n        hub = minCostNode(fullCost, visited)\n    fullCost = {node: float(\"inf\") if node != goal else cost for node,cost in fullCost.items() }\n    print(fullCost)\n    return fullCost\n\ndirection = list(range(1,n+1)) + [1]\nprint(direction)\nfor i in range(len(direction)-1):\n    fullCost = calcFullCost(fullCost, direction[i], direction[i+1])\nprint(fullCost[1] if fullCost[1] != float('inf') else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighborCost = {i: dict() for i in range(1,n+1)}\nfullCost = {i: float('inf') for i in range(1,n+1)}\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    neighborCost[fro][to] = cost\nfullCost[1] = 0\n\ndef minCostNode(fullCost, visited):\n    neededNodes = {node: cost for node,cost in fullCost.items() if node not in visited}\n    return min(neededNodes, key=neededNodes.get) if neededNodes else None\n\ndef calcFullCost(fullCost, start, goal):\n    visited = set()\n    hub = start\n    while hub:\n        for neighbor,cost in neighborCost[hub].items():\n            newCost = fullCost[hub] + cost\n            if newCost < fullCost[neighbor]:\n                fullCost[neighbor] = newCost\n        visited.add(hub)\n        hub = minCostNode(fullCost, visited)\n    fullCost = {node: float(\"inf\") if node != goal else cost for node,cost in fullCost.items() }\n    return fullCost\n\ndirection = list(range(1,n+1)) + [1]\nfor i in range(len(direction)-1):\n    fullCost = calcFullCost(fullCost, direction[i], direction[i+1])\nprint(fullCost[1] if fullCost[1] != float('inf') else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighbors = {i: dict() for i in range(1,n+1)}\nfullCosts = {i: float('inf') for i in range(1,n+1)}\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    neighbors[fro][to] = cost\nfullCosts[1] = 0\n\ndef minCost(start,goal):\n    def bfsPaths(start,goal):\n        pathQueue = [[start]]\n        while pathQueue:\n            path = pathQueue.pop(0)\n            node = path[-1]\n            for neighbor in set(neighbors[node].keys()) - set(path):\n                if neighbor is goal:\n                    yield path + [neighbor]\n                else:\n                    pathQueue.append(path + [neighbor])\n    paths = bfsPaths(start,goal)\n    def toCost(path):\n        costs = [neighbors[path[i]][path[i+1]] for i in range(len(path)-1)]\n        return sum(costs)\n    costs = list(map(toCost, paths))\n    return min(costs) if costs else None\n\ndirection = list(range(1,n+1)) + [1]\ncosts = []\nfor i in range(len(direction)-1):\n    costs.append(minCost(direction[i], direction[i+1]))\nprint(sum(costs) if None not in costs else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighborCost = {i: dict() for i in range(1,n+1)}\nfullCost = {i: float('inf') for i in range(1,n+1)}\nfullCost[1] = 0\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    try:\n        if cost < neighborCost[fro][to]:\n            neighborCost[fro][to] = cost\n    except KeyError:\n        neighborCost[fro][to] = cost\n\ndef minCostNode(fullCost, visited):\n    neededNodes = {node: cost for node,cost in fullCost.items() if node not in visited}\n    return min(neededNodes, key=neededNodes.get) if neededNodes else None\n\ndef calcFullCost(fullCost, start, goal):\n    visited = set()\n    hub = start\n    while hub:\n        for neighbor,cost in neighborCost[hub].items():\n            newCost = fullCost[hub] + cost\n            if newCost < fullCost[neighbor]:\n                fullCost[neighbor] = newCost\n        visited.add(hub)\n        hub = minCostNode(fullCost, visited)\n    fullCost = {node: float(\"inf\") if node != goal else cost for node,cost in fullCost.items() }\n    # print(fullCost)\n    return fullCost\n\ndirection = list(range(1,n+1)) + [1]\n# print(direction)\nfor i in range(len(direction)-1):\n    fullCost = calcFullCost(fullCost, direction[i], direction[i+1])\nprint(fullCost[1] if fullCost[1] != float('inf') else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighbors = {i: dict() for i in range(1,n+1)}\nfullCosts = {i: float('inf') for i in range(1,n+1)}\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    neighbors[fro][to] = cost\nfullCosts[1] = 0\n\ndef minCost(start,goal):\n    def bfsPaths(start,goal):\n        pathQueue = [[start]]\n        while pathQueue:\n            path = pathQueue.pop(0)\n            node = path[-1]\n            for neighbor in set(neighbors[node].keys()) - set(path):\n                if neighbor is goal:\n                    yield path + [neighbor]\n                else:\n                    pathQueue.append(path + [neighbor])\n    paths = bfsPaths(start,goal)\n    def toCost(path):\n        costs = [neighbors[path[i]][path[i+1]] for i in range(len(path)-1)]\n        return sum(costs)\n    costs = list(map(toCost, paths))\n    return min(costs) if costs else None\n\ndirection = list(range(1,n+1)) + [1]\ncosts = []\nfor i in range(len(direction)-1):\n    costs.append(minCost(direction[i], direction[i+1]))\nprint(sum(costs))\n\n"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighborCost = dict()\nfor i in range(1,n+1):\n    neighborCost[i] = {i: float('inf') for i in range(1,n+1)}\nfullCost = {i: float('inf') for i in range(1,n+1)}\nfullCost[1] = 0\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    if cost < neighborCost[fro][to]:\n        neighborCost[fro][to] = cost\n\ndef minCostNode(fullCost, visited):\n    neededNodes = {node: cost for node,cost in fullCost.items() if node not in visited}\n    return min(neededNodes, key=neededNodes.get) if neededNodes else None\n\ndef calcFullCost(fullCost, start, goal):\n    visited = set()\n    hub = start\n    while hub:\n        for neighbor,cost in neighborCost[hub].items():\n            newCost = fullCost[hub] + cost\n            if newCost < fullCost[neighbor]:\n                fullCost[neighbor] = newCost\n        visited.add(hub)\n        hub = minCostNode(fullCost, visited)\n    fullCost = {node: float(\"inf\") if node != goal else cost for node,cost in fullCost.items() }\n    # print(fullCost)\n    return fullCost\n\ndirection = list(range(1,n+1)) + [1]\n# print(direction)\nfor i in range(len(direction)-1):\n    fullCost = calcFullCost(fullCost, direction[i], direction[i+1])\nprint(fullCost[1] if fullCost[1] != float('inf') else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "# n=nodes, m=edges\nn,m = map(int, input().split())\nneighborCost = dict()\nfor i in range(1,n+1):\n    neighborCost[i] = {i: float('inf') for i in range(1,n+1)}\nfullCost = {i: float('inf') for i in range(1,n+1)}\nfullCost[1] = 0\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    if cost < neighborCost[fro][to]:\n        neighborCost[fro][to] = cost\n\ndef minCostNode(fullCost, visited):\n    neededNodes = {node: cost for node,cost in fullCost.items() if node not in visited}\n    return min(neededNodes, key=neededNodes.get) if neededNodes else None\n\ndef calcFullCost(fullCost, start, goal):\n    visited = set()\n    hub = start\n    while hub:\n        for neighbor,cost in neighborCost[hub].items():\n            newCost = fullCost[hub] + cost\n            if newCost < fullCost[neighbor]:\n                fullCost[neighbor] = newCost\n        visited.add(hub)\n        hub = minCostNode(fullCost, visited)\n    fullCost = {node: float(\"inf\") if node != goal else cost for node,cost in fullCost.items() }\n    print(fullCost)\n    return fullCost\n\ndirection = list(range(1,n+1)) + [1]\nprint(direction)\nfor i in range(len(direction)-1):\n    fullCost = calcFullCost(fullCost, direction[i], direction[i+1])\nprint(fullCost[1] if fullCost[1] != float('inf') else -1)\n\n"
  },
  {
    "language": "Python",
    "code": "import functools as fn\nimport time\nfrom collections import defaultdict\n# n=nodes, m=edges\nn,m = map(int, input().split())\ngraph = defaultdict(lambda: defaultdict(lambda: None))\nfor i in range(m):\n    fro, to, cost = map(int, input().split())\n    if graph[fro][to] is None or graph[fro][to] > cost:\n        graph[fro][to] = cost\n\ndef minCostNode(totCost, visited):\n    lis = totCost.items()\n    fil = filter(lambda t: t[0] not in visited, lis)\n    mi = fn.reduce(lambda a,b: a if a[1]<b[1] else b, fil, (None,float('inf')))\n    return mi[0] # maybe None\n\ndef dijkstra(fro, froCost, to):\n    visited = set()\n    totCost = defaultdict(lambda: None)\n    totCost[fro] = froCost\n    hub = fro\n    while hub and hub != to:\n        # time.sleep(0.1)\n        # print(hub,totCost.items())\n        for neighbor,cost in graph[hub].items():\n            newCost = totCost[hub] + cost\n            if totCost[neighbor] is None or newCost < totCost[neighbor]:\n                totCost[neighbor] = newCost\n        visited.add(hub)\n        hub = minCostNode(totCost, visited)\n    toCost = totCost[to]\n    return toCost # maybe None\n\nfroCost = 0\nfor fro, to in zip(range(1,n), range(2,n+1)):\n    froCost = dijkstra(fro, froCost, to)\nfinalCost = dijkstra(n, froCost, 1)\nprint(finalCost if finalCost else -1)\n\n"
  }
]