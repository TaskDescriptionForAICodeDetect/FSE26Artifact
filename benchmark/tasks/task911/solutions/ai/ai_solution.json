[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint distance(int start, int end, int m) {\n    int forward = (end - start + m) % m;\n    int backward = (start - end + m) % m;\n    return min(forward, backward);\n}\n\nint main() {\n    int m, n, x;\n    scanf(\"%d %d %d\", &m, &n, &x);\n    \n    int levels[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &levels[i]);\n    }\n    \n    int total_presses = 0;\n    \n    for (int i = 1; i < n; i++) {\n        int curr_min_presses = INT_MAX;\n        \n        for (int favorite = 1; favorite <= m; favorite++) {\n            int curr_presses = 0;\n            int curr_pos = levels[i-1];\n            \n            curr_presses += distance(curr_pos, favorite, m);\n            curr_pos = favorite;\n            \n            curr_presses += distance(curr_pos, levels[i], m);\n            \n            curr_min_presses = min(curr_min_presses, curr_presses);\n        }\n        \n        total_presses += curr_min_presses;\n    }\n    \n    printf(\"%d\\n\", total_presses);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nlong long min(long long a, long long b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int *a = (int *)malloc(n * sizeof(int));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    long long total = 0;\n    for (int i = 1; i < n; i++) {\n        if (a[i] > a[i-1]) {\n            total += a[i] - a[i-1];\n        } else {\n            total += m - a[i-1] + a[i];\n        }\n    }\n\n    long long *diff = (long long *)calloc(m + 2, sizeof(long long));\n    for (int i = 1; i < n; i++) {\n        int prev = a[i-1];\n        int curr = a[i];\n        if (curr > prev) {\n            if (prev + 1 <= curr - 1) {\n                diff[prev + 1] += 1;\n                diff[curr] -= (curr - prev - 1);\n                diff[curr] += 1;\n                if (curr + 1 <= m) {\n                    diff[curr + 1] += (curr - prev - 1);\n                }\n            }\n        } else {\n            if (prev + 1 <= m) {\n                diff[prev + 1] += 1;\n                diff[m + 1] -= (m - prev);\n                diff[1] += (m - prev);\n                if (curr > 1) {\n                    diff[1] += (curr - 1);\n                    diff[curr] -= (curr - 1);\n                }\n            }\n            if (curr > 1) {\n                diff[1] += (curr - 1);\n                diff[curr] -= (curr - 1);\n            }\n        }\n    }\n\n    long long min_reduction = 0;\n    long long current = 0;\n    for (int x = 1; x <= m; x++) {\n        current += diff[x];\n        if (x == 1) {\n            min_reduction = current;\n        } else {\n            min_reduction = min(min_reduction, current);\n        }\n    }\n\n    printf(\"%lld\\n\", total - min_reduction);\n    free(a);\n    free(diff);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i];\n    }\n\n    long long total = 0;\n    for (int i = 1; i < n; ++i) {\n        if (a[i] > a[i-1]) {\n            total += a[i] - a[i-1];\n        } else {\n            total += a[i] + m - a[i-1];\n        }\n    }\n\n    vector<long long> diff(m + 2, 0);\n    for (int i = 1; i < n; ++i) {\n        int prev = a[i-1];\n        int curr = a[i];\n        if (curr > prev) {\n            int start = prev + 1;\n            int end = curr - 1;\n            if (start <= end) {\n                int val1 = curr - prev;\n                int val2 = m - curr + prev + 1;\n                diff[start] += val2 - val1;\n                diff[end + 1] -= val2 - val1;\n            }\n        } else {\n            int start1 = prev + 1;\n            int end1 = m;\n            if (start1 <= end1) {\n                int val1 = curr + m - prev;\n                int val2 = m - curr + prev + 1;\n                diff[start1] += val2 - val1;\n                diff[end1 + 1] -= val2 - val1;\n            }\n            int start2 = 1;\n            int end2 = curr - 1;\n            if (start2 <= end2) {\n                int val1 = curr - prev + m;\n                int val2 = m - curr + prev + 1;\n                diff[start2] += val2 - val1;\n                diff[end2 + 1] -= val2 - val1;\n            }\n        }\n    }\n\n    long long max_reduction = 0;\n    long long current = 0;\n    for (int x = 1; x <= m; ++x) {\n        current += diff[x];\n        if (current > max_reduction) {\n            max_reduction = current;\n        }\n    }\n\n    cout << total - max_reduction << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n\n        long total = 0;\n        for (int i = 1; i < n; i++) {\n            int prev = a[i - 1];\n            int current = a[i];\n            if (current > prev) {\n                total += current - prev;\n            } else if (current < prev) {\n                total += m - prev + current;\n            }\n        }\n\n        long maxReduction = 0;\n        int[] diff = new int[m + 2];\n        for (int i = 1; i < n; i++) {\n            int prev = a[i - 1];\n            int current = a[i];\n            if (current > prev) {\n                int start = prev + 1;\n                int end = current - 1;\n                if (start <= end) {\n                    diff[start] += 1;\n                    diff[end + 1] -= 1;\n                }\n            } else if (current < prev) {\n                int start1 = prev + 1;\n                int end1 = m;\n                if (start1 <= end1) {\n                    diff[start1] += 1;\n                    diff[end1 + 1] -= 1;\n                }\n                int start2 = 1;\n                int end2 = current - 1;\n                if (start2 <= end2) {\n                    diff[start2] += 1;\n                    diff[end2 + 1] -= 1;\n                }\n            }\n        }\n\n        long currentDiff = 0;\n        long max = 0;\n        for (int x = 1; x <= m; x++) {\n            currentDiff += diff[x];\n            long reduction = currentDiff * (x - 1);\n            if (reduction > max) {\n                max = reduction;\n            }\n        }\n\n        System.out.println(total - max);\n    }\n}",
    "timestamp": "2025-08-05 23:20:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LampBrightness {\n    public static int minimumButtonPresses(int m, int[] sequence) {\n        int totalPresses = 0;\n        \n        for (int i = 1; i < sequence.length; i++) {\n            int start = sequence[i-1];\n            int end = sequence[i];\n            \n            if (start == end) continue;\n            \n            int directForward = (end - start + m) % m;\n            int directBackward = (start - end + m) % m;\n            \n            int minPresses = Math.min(directForward, directBackward);\n            totalPresses += minPresses;\n        }\n        \n        return totalPresses;\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int m = scanner.nextInt();\n        int n = scanner.nextInt();\n        \n        int[] sequence = new int[n];\n        for (int i = 0; i < n; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n        \n        int result = minimumButtonPresses(m, sequence);\n        System.out.println(result);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 23:20:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nint minButtonPresses(int m, vector<int>& levels) {\n    int minPresses = INT_MAX;\n    \n    for (int x = 1; x <= m; x++) {\n        int totalPresses = 0;\n        int current = levels[0];\n        \n        for (int i = 1; i < levels.size(); i++) {\n            int target = levels[i];\n            int forwardPresses = (target - current + m) % m;\n            int favoritePresses = 1 + forwardPresses;\n            \n            totalPresses += min(forwardPresses, favoritePresses);\n            current = target;\n        }\n        \n        minPresses = min(minPresses, totalPresses);\n    }\n    \n    return minPresses;\n}\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    \n    vector<int> levels(n);\n    for (int i = 0; i < n; i++) {\n        cin >> levels[i];\n    }\n    \n    cout << minButtonPresses(m, levels) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:20:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_button_presses(m, x, levels):\n    n = len(levels)\n    min_presses = float('inf')\n    \n    for favorite in range(1, m + 1):\n        presses = 0\n        current_brightness = levels[0]\n        \n        for i in range(1, n):\n            target_brightness = levels[i]\n            \n            if target_brightness == favorite:\n                presses += 1\n            else:\n                forward_presses = (target_brightness - current_brightness) % m\n                backward_presses = (current_brightness - target_brightness) % m\n                \n                if favorite == current_brightness:\n                    presses += min(forward_presses, backward_presses)\n                else:\n                    presses += min(forward_presses, backward_presses + 1)\n            \n            current_brightness = target_brightness\n            \n        min_presses = min(min_presses, presses)\n    \n    return min_presses\n\n# Example usage\nm = 5\nlevels = [1, 3, 5, 2, 4]\nprint(min_button_presses(m, 3, levels))",
    "timestamp": "2025-08-13 14:45:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class LampBrightness {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int m = scanner.nextInt();\n        int n = scanner.nextInt();\n        int[] a = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        \n        int minPresses = Integer.MAX_VALUE;\n        \n        for (int x = 1; x <= m; x++) {\n            int currentPresses = 0;\n            int currentLevel = a[0];\n            \n            for (int i = 1; i < n; i++) {\n                if (a[i] == x) {\n                    currentPresses += (currentLevel != x) ? 1 : 0;\n                    currentLevel = x;\n                } else {\n                    int diff = Math.abs(a[i] - currentLevel);\n                    int wrappedDiff = Math.min(diff, m - diff);\n                    currentPresses += wrappedDiff;\n                    currentLevel = a[i];\n                }\n            }\n            minPresses = Math.min(minPresses, currentPresses);\n        }\n        \n        System.out.println(minPresses);\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 14:45:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint main() {\n    int m, n;\n    scanf(\"%d %d\", &m, &n);\n    \n    int a[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    int minPresses = n - 1;\n    for (int x = 1; x <= m; x++) {\n        int currentPresses = 0;\n        int level = a[0];\n        for (int i = 1; i < n; i++) {\n            if (a[i] == x) {\n                currentPresses++;\n            } else {\n                int forwardPresses = (a[i] + m - level) % m;\n                int favoritePresses = 1 + (a[i] + m - x) % m;\n                currentPresses += min(forwardPresses, favoritePresses);\n            }\n            level = a[i];\n        }\n        minPresses = min(minPresses, currentPresses);\n    }\n\n    printf(\"%d\\n\", minPresses);\n    return 0;\n}",
    "timestamp": "2025-08-13 14:45:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint min_button_presses(int m, int x, const vector<int>& levels) {\n    int presses = 0;\n    for (size_t i = 1; i < levels.size(); ++i) {\n        int current = levels[i - 1];\n        int next = levels[i];\n        \n        int normalPresses = (next - current + m) % m;\n        int favPresses = 1 + ((next - x + m) % m);\n        \n        presses += min(normalPresses, favPresses);\n    }\n    return presses;\n}\n\nint find_optimal_favorite_level(int m, const vector<int>& levels) {\n    int minPresses = INT_MAX;\n    int optimalX = levels[0];\n    for (int x = 1; x <= m; ++x) {\n        int presses = min_button_presses(m, x, levels);\n        if (presses < minPresses) {\n            minPresses = presses;\n            optimalX = x;\n        }\n    }\n    return minPresses;\n}\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<int> levels(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> levels[i];\n    }\n\n    int minPresses = find_optimal_favorite_level(m, levels);\n    cout << minPresses << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:45:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_button_presses(m, a, x):\n    n = len(a)\n    min_presses = float('inf')\n    \n    for x in range(1, m + 1):\n        total_presses = 0\n        current = a[0]\n        \n        for i in range(1, n):\n            target = a[i]\n            forward_presses = (target - current + m) % m\n            favorite_presses = 1 + abs(target - x)\n            total_presses += min(forward_presses, favorite_presses)\n            current = target\n        \n        min_presses = min(min_presses, total_presses)\n    \n    return min_presses\n\n# Read input\nm, n = map(int, input().split())\na = list(map(int, input().split()))\n\n# Print result\nprint(min_button_presses(m, a, x=0))",
    "timestamp": "2025-08-13 14:45:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "n, m = map(int, input().split())\na = list(map(int, input().split()))\nres = 0\n\nfor i in range(n-1):\n    current = a[i]\n    next_val = a[i+1]\n    if next_val > current:\n        res += next_val - current\n    elif next_val < current:\n        res += m - current + next_val\n\nmax_saved = 0\nprefix = [0] * (m + 2)\n\nfor i in range(n-1):\n    current = a[i]\n    next_val = a[i+1]\n    if next_val > current:\n        # The favorite x can be in [current + 1, next_val - 1]\n        # The saving is (next_val - x) instead of (next_val - current)\n        # So the saving is (x - current - 1) + 1 (press favorite) - (next_val - current)\n        # Wait, no. The saving is (next_val - current) - (1 + (next_val - x)) = (x - current - 1)\n        # So we want to maximize (x - current - 1) for x in [current + 1, next_val - 1]\n        # The maximum is (next_val - 1 - current - 1 + 1) = next_val - current - 1\n        # So for x in [current + 1, next_val - 1], the saving is (x - current - 1)\n        # So we can add 1 to [current + 1, next_val - 1] in the prefix array\n        if current + 1 <= next_val - 1:\n            prefix[current + 1] += 1\n            prefix[next_val] -= 1\n    else:\n        # The favorite x can be in [current + 1, m] or [1, next_val - 1]\n        # The saving is (m - current + x) - (1 + (m - current + next_val)) = x - next_val - 1\n        # So for x in [current + 1, m], saving is x - next_val - 1\n        # For x in [1, next_val - 1], saving is (m - current + x) - (1 + (m - current + next_val)) = x - next_val - 1\n        # So we can add 1 to [current + 1, m] and [1, next_val - 1]\n        if current + 1 <= m:\n            prefix[current + 1] += 1\n            prefix[m + 1] -= 1\n        if 1 <= next_val - 1:\n            prefix[1] += 1\n            prefix[next_val] -= 1\n\nmax_val = 0\ncurrent_sum = 0\nfor x in range(1, m + 1):\n    current_sum += prefix[x]\n    if current_sum > max_val:\n        max_val = current_sum\n\nprint(res - max_val)",
    "timestamp": "2025-08-13 14:45:50"
  }
]