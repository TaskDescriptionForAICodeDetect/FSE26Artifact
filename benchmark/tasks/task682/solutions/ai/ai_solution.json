[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\n// Adjacency list representation\nstruct Node {\n    int vertex;\n    struct Node* next;\n};\n\n// Global variables\nstruct Node* graph[MAX_N];\nint values[MAX_N];\nint parent[MAX_N];\nint dist[MAX_N];\nint path[MAX_N];\n\n// Add edge to graph\nvoid addEdge(int u, int v) {\n    struct Node* newNode = malloc(sizeof(struct Node));\n    newNode->vertex = v;\n    newNode->next = graph[u];\n    graph[u] = newNode;\n}\n\n// BFS to find shortest path\nvoid bfs(int start) {\n    int visited[MAX_N] = {0};\n    int queue[MAX_N], front = 0, rear = 0;\n\n    memset(dist, 0x3f, sizeof(dist));\n    memset(parent, -1, sizeof(parent));\n\n    queue[rear++] = start;\n    visited[start] = 1;\n    dist[start] = 0;\n\n    while (front < rear) {\n        int u = queue[front++];\n        \n        for (struct Node* v = graph[u]; v != NULL; v = v->next) {\n            if (!visited[v->vertex]) {\n                queue[rear++] = v->vertex;\n                visited[v->vertex] = 1;\n                dist[v->vertex] = dist[u] + 1;\n                parent[v->vertex] = u;\n            }\n        }\n    }\n}\n\n// Reconstruct path from start to end\nint getPath(int end) {\n    int pathLen = 0;\n    while (end != -1) {\n        path[pathLen++] = values[end];\n        end = parent[end];\n    }\n\n    // Reverse path\n    for (int i = 0; i < pathLen/2; i++) {\n        int temp = path[i];\n        path[i] = path[pathLen-1-i];\n        path[pathLen-1-i] = temp;\n    }\n\n    return pathLen;\n}\n\n// Longest Increasing Subsequence\nint lis(int* arr, int n) {\n    int dp[MAX_N], len = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int pos = -1;\n        for (int j = 0; j < len; j++) {\n            if (dp[j] < arr[i]) {\n                pos = j;\n            }\n        }\n\n        if (pos == len - 1) {\n            dp[len++] = arr[i];\n        } else if (pos == -1) {\n            dp[0] = arr[i];\n        } else {\n            dp[pos+1] = arr[i];\n        }\n    }\n\n    return len;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    // Read values\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &values[i]);\n    }\n\n    // Read edges\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        addEdge(v, u);\n    }\n\n    // BFS from start vertex\n    bfs(1);\n\n    // Find max LIS\n    int maxLIS = 0;\n    for (int k = 1; k <= N; k++) {\n        int pathLen = getPath(k);\n        int lisLen = lis(path, pathLen);\n        maxLIS = (lisLen > maxLIS) ? lisLen : maxLIS;\n    }\n\n    printf(\"%d\\n\", maxLIS);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200000\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[MAX_N * 2];\nint head[MAX_N + 1];\nint a[MAX_N + 1];\nint parent[MAX_N + 1];\nint path[MAX_N];\nint path_len;\nint lis[MAX_N];\nint result[MAX_N + 1];\nint edge_count = 0;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int parent_u) {\n    parent[u] = parent_u;\n    int pos = -1;\n    int low = 0, high = path_len - 1;\n    while (low <= high) {\n        int mid = (low + high) / 2;\n        if (lis[mid] < a[u]) {\n            pos = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    int old_val = -1;\n    int old_len = path_len;\n    if (pos == -1) {\n        if (path_len == 0 || a[u] < lis[0]) {\n            if (path_len == 0) {\n                path_len = 1;\n            }\n            old_val = lis[0];\n            lis[0] = a[u];\n        }\n    } else {\n        if (pos + 1 >= path_len) {\n            path_len = pos + 2;\n            old_val = lis[pos + 1];\n            lis[pos + 1] = a[u];\n        } else if (a[u] < lis[pos + 1]) {\n            old_val = lis[pos + 1];\n            lis[pos + 1] = a[u];\n        }\n    }\n    result[u] = path_len;\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if (v != parent_u) {\n            dfs(v, u);\n        }\n    }\n    if (old_val != -1) {\n        if (pos == -1) {\n            lis[0] = old_val;\n        } else {\n            lis[pos + 1] = old_val;\n        }\n    }\n    path_len = old_len;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%d\", &a[i]);\n        head[i] = -1;\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n    path_len = 0;\n    dfs(1, -1);\n    for (int i = 1; i <= N; ++i) {\n        printf(\"%d\\n\", result[i]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> adj[MAXN];\nint a[MAXN];\nint parent[MAXN];\nvector<int> path;\nvector<int> lis;\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    for (int v : adj[u]) {\n        if (v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nvector<int> get_path(int k) {\n    vector<int> path;\n    while (k != 0) {\n        path.push_back(a[k]);\n        k = parent[k];\n    }\n    reverse(path.begin(), path.end());\n    return path;\n}\n\nint longest_increasing_subsequence(const vector<int>& seq) {\n    vector<int> dp;\n    for (int num : seq) {\n        auto it = lower_bound(dp.begin(), dp.end(), num);\n        if (it == dp.end()) {\n            dp.push_back(num);\n        } else {\n            *it = num;\n        }\n    }\n    return dp.size();\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    dfs(1, 0);\n\n    for (int k = 1; k <= N; ++k) {\n        vector<int> path = get_path(k);\n        cout << longest_increasing_subsequence(path) << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:34:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static List<List<Integer>> tree;\n    static int[] a;\n    static int[] path;\n    static int[] result;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(br.readLine());\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n        a = new int[N + 1];\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        for (int i = 1; i <= N; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            st = new StringTokenizer(br.readLine());\n            int u = Integer.parseInt(st.nextToken());\n            int v = Integer.parseInt(st.nextToken());\n            tree.get(u).add(v);\n            tree.get(v).add(u);\n        }\n\n        result = new int[N + 1];\n        path = new int[N + 1];\n        Arrays.fill(path, Integer.MAX_VALUE);\n        dfs(1, 0, 0);\n        for (int i = 1; i <= N; i++) {\n            System.out.println(result[i]);\n        }\n    }\n\n    static void dfs(int u, int parent, int len) {\n        int idx = lowerBound(path, a[u], len);\n        int oldVal = path[idx];\n        path[idx] = a[u];\n        result[u] = (idx == len) ? len + 1 : len;\n\n        for (int v : tree.get(u)) {\n            if (v != parent) {\n                dfs(v, u, (idx == len) ? len + 1 : len);\n            }\n        }\n        path[idx] = oldVal;\n    }\n\n    static int lowerBound(int[] arr, int key, int right) {\n        int left = 0;\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (arr[mid] < key) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}",
    "timestamp": "2025-08-05 22:34:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    static final int MAX_N = 100005;\n    static List<Integer>[] graph;\n    static int[] values;\n    static int[] parent;\n    static boolean[] visited;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        \n        graph = new ArrayList[N + 1];\n        values = new int[N + 1];\n        parent = new int[N + 1];\n        visited = new boolean[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n            values[i] = sc.nextInt();\n        }\n\n        for (int i = 1; i < N; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n\n        int maxLIS = 0;\n        for (int k = 1; k <= N; k++) {\n            List<Integer> path = findPath(1, k);\n            int lis = longestIncreasingSubsequence(path);\n            maxLIS = Math.max(maxLIS, lis);\n        }\n\n        System.out.println(maxLIS);\n    }\n\n    static List<Integer> findPath(int start, int end) {\n        Arrays.fill(visited, false);\n        Arrays.fill(parent, 0);\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        visited[start] = true;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            if (current == end) break;\n\n            for (int neighbor : graph[current]) {\n                if (!visited[neighbor]) {\n                    queue.offer(neighbor);\n                    visited[neighbor] = true;\n                    parent[neighbor] = current;\n                }\n            }\n        }\n\n        List<Integer> path = new ArrayList<>();\n        int current = end;\n        while (current != start) {\n            path.add(values[current]);\n            current = parent[current];\n        }\n        path.add(values[start]);\n        Collections.reverse(path);\n        return path;\n    }\n\n    static int longestIncreasingSubsequence(List<Integer> sequence) {\n        if (sequence.isEmpty()) return 0;\n        \n        int[] dp = new int[sequence.size()];\n        Arrays.fill(dp, 1);\n\n        for (int i = 1; i < sequence.size(); i++) {\n            for (int j = 0; j < i; j++) {\n                if (sequence.get(i) > sequence.get(j)) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n\n        int maxLIS = 0;\n        for (int length : dp) {\n            maxLIS = Math.max(maxLIS, length);\n        }\n        return maxLIS;\n    }\n}",
    "timestamp": "2025-08-05 22:35:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 200005;\nvector<int> graph[MAXN];\nint values[MAXN];\nint parent[MAXN];\nint depth[MAXN];\n\nvoid dfs(int node, int par, int d) {\n    parent[node] = par;\n    depth[node] = d;\n    for (int neighbor : graph[node]) {\n        if (neighbor != par) {\n            dfs(neighbor, node, d + 1);\n        }\n    }\n}\n\nvector<int> getPath(int start, int end) {\n    vector<int> path;\n    while (end != start) {\n        path.push_back(values[end]);\n        end = parent[end];\n    }\n    path.push_back(values[start]);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\nint longestIncreasingSubsequence(vector<int>& seq) {\n    vector<int> lis;\n    for (int num : seq) {\n        auto it = lower_bound(lis.begin(), lis.end(), num);\n        if (it == lis.end()) {\n            lis.push_back(num);\n        } else {\n            *it = num;\n        }\n    }\n    return lis.size();\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N, M;\n    cin >> N >> M;\n\n    for (int i = 1; i <= N; i++) {\n        cin >> values[i];\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n\n    dfs(1, 0, 0);\n\n    int maxLIS = 0;\n    for (int k = 1; k <= N; k++) {\n        vector<int> path = getPath(1, k);\n        maxLIS = max(maxLIS, longestIncreasingSubsequence(path));\n    }\n\n    cout << maxLIS << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:35:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque, defaultdict\n\ndef lis_length(sequence):\n    if not sequence:\n        return 0\n    lis = []\n    for num in sequence:\n        if not lis or num > lis[-1]:\n            lis.append(num)\n        else:\n            left, right = 0, len(lis) - 1\n            while left < right:\n                mid = (left + right) // 2\n                if lis[mid] < num:\n                    left = mid + 1\n                else:\n                    right = mid\n            lis[left] = num\n    return len(lis)\n\ndef bfs_shortest_paths(tree, values, start_vertex):\n    n = len(tree)\n    queue = deque([start_vertex])\n    paths = {i: [] for i in range(1, n+1)}\n    visited = set([start_vertex])\n    paths[start_vertex] = [values[start_vertex - 1]]\n\n    while queue:\n        current = queue.popleft()\n        for neighbor in tree[current]:\n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append(neighbor)\n                paths[neighbor] = paths[current] + [values[neighbor - 1]]\n    return paths\n\ndef solve_lis_on_tree(N, edges, a_values):\n    tree = defaultdict(list)\n    for u, v in edges:\n        tree[u].append(v)\n        tree[v].append(u)\n\n    shortest_paths = bfs_shortest_paths(tree, a_values, 1)\n\n    lis_lengths = []\n    for k in range(1, N+1):\n        seq = shortest_paths[k]\n        lis_lengths.append(lis_length(seq))\n\n    return lis_lengths\n\n# Example usage:\n# N = number of vertices\n# edges = list of edges (u, v)\n# a_values = list of integers a_i on each vertex\n\nN = 5\nedges = [(1, 2), (1, 3), (3, 4), (3, 5)]\na_values = [3, 1, 4, 1, 5]\n\nprint(solve_lis_on_tree(N, edges, a_values))",
    "timestamp": "2025-08-13 11:22:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TreeLongestIncreasingSubsequence {\n\n    static int N;\n    static ArrayList<Integer>[] adj;\n    static int[] values;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        N = sc.nextInt();\n        values = new int[N + 1];\n        adj = new ArrayList[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            values[i] = sc.nextInt();\n        }\n        \n        for (int i = 0; i <= N; i++) {\n            adj[i] = new ArrayList<>();\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            adj[u].add(v);\n            adj[v].add(u);\n        }\n        \n        int[] parent = new int[N + 1];\n        Arrays.fill(parent, -1);\n        parent[1] = 0;\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(1);\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            for (int neighbor : adj[node]) {\n                if (parent[neighbor] == -1) {\n                    parent[neighbor] = node;\n                    queue.add(neighbor);\n                }\n            }\n        }\n        \n        for (int k = 1; k <= N; k++) {\n            List<Integer> pathSequence = new ArrayList<>();\n            int node = k;\n            while (node != 0) {\n                pathSequence.add(values[node]);\n                node = parent[node];\n            }\n            Collections.reverse(pathSequence);\n            int longestIncSubseqLen = longestIncreasingSubsequence(pathSequence);\n            System.out.println(longestIncSubseqLen);\n        }\n        \n        sc.close();\n    }\n    \n    private static int longestIncreasingSubsequence(List<Integer> sequence) {\n        if (sequence.isEmpty()) return 0;\n\n        ArrayList<Integer> lis = new ArrayList<>();\n        for (int num : sequence) {\n            int pos = Collections.binarySearch(lis, num);\n            if (pos < 0) pos = -(pos + 1);\n            if (pos == lis.size()) {\n                lis.add(num);\n            } else {\n                lis.set(pos, num);\n            }\n        }\n        return lis.size();\n    }\n}",
    "timestamp": "2025-08-13 11:22:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100001\n\ntypedef struct {\n    int to, next;\n} Edge;\n\nEdge edges[MAX_N * 2];\nint head[MAX_N], edgeCount;\nint a[MAX_N];\nint parent[MAX_N], depth[MAX_N];\nint sequence[MAX_N], seqSize;\n\nvoid addEdge(int u, int v) {\n    edges[edgeCount] = (Edge){v, head[u]};\n    head[u] = edgeCount++;\n    edges[edgeCount] = (Edge){u, head[v]};\n    head[v] = edgeCount++;\n}\n\nvoid dfs(int u, int p) {\n    parent[u] = p;\n    depth[u] = depth[p] + 1;\n    for(int i = head[u]; i != -1; i = edges[i].next) {\n        int v = edges[i].to;\n        if(v != p) {\n            dfs(v, u);\n        }\n    }\n}\n\nint longestIncreasingSubsequence() {\n    int dp[MAX_N], len = 0;\n    for(int i = 0; i < seqSize; ++i) {\n        int l = 0, r = len;\n        while(l < r) {\n            int m = (l + r) / 2;\n            if(dp[m] < sequence[i]) l = m + 1;\n            else r = m;\n        }\n        dp[l] = sequence[i];\n        if(l == len) ++len;\n    }\n    return len;\n}\n\nvoid findSequence(int u) {\n    seqSize = 0;\n    while(u != 0) {\n        sequence[seqSize++] = a[u];\n        u = parent[u];\n    }\n    for(int i = 0; i < seqSize / 2; ++i) {\n        int temp = sequence[i];\n        sequence[i] = sequence[seqSize - i - 1];\n        sequence[seqSize - i - 1] = temp;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    memset(head, -1, sizeof(head));\n    edgeCount = 0;\n    \n    for(int i = 1; i <= n; ++i) {\n        scanf(\"%d\", &a[i]);\n    }\n\n    for(int i = 0; i < n - 1; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n\n    depth[0] = -1;\n    dfs(1, 0);\n\n    for(int k = 1; k <= n; ++k) {\n        findSequence(k);\n        printf(\"%d\\n\", longestIncreasingSubsequence());\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function longestIncreasingSubsequence(arr) {\n    const dp = [];\n    for (let num of arr) {\n        let left = 0, right = dp.length;\n        while (left < right) {\n            let mid = (left + right) >> 1;\n            if (dp[mid] < num) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        dp[left] = num;\n    }\n    return dp.length;\n}\n\nfunction getLongestIncreasingSubsequenceInPaths(N, edges, values) {\n    const adjList = Array.from({ length: N + 1 }, () => []);\n    edges.forEach(([u, v]) => {\n        adjList[u].push(v);\n        adjList[v].push(u);\n    });\n\n    const parents = new Array(N + 1).fill(null);\n    const depth = new Array(N + 1).fill(0);\n\n    const dfs = (node, parent) => {\n        for (let neighbor of adjList[node]) {\n            if (neighbor !== parent) {\n                parents[neighbor] = node;\n                depth[neighbor] = depth[node] + 1;\n                dfs(neighbor, node);\n            }\n        }\n    };\n\n    dfs(1, null);\n\n    const pathTo1 = (k) => {\n        let path = [];\n        while (k !== null) {\n            path.push(values[k - 1]);\n            k = parents[k];\n        }\n        path.reverse();\n        return path;\n    };\n\n    let result = [];\n    for (let k = 1; k <= N; k++) {\n        let sequence = pathTo1(k);\n        let lisLength = longestIncreasingSubsequence(sequence);\n        result.push(lisLength);\n    }\n\n    return result;\n}\n\n// Example usage:\n// N is number of vertices\n// edges is an array of [u_i, v_i] representing the tree edges\n// values is the array a_i for each vertex\nconst N = 5;\nconst edges = [[1, 2], [1, 3], [2, 4], [2, 5]];\nconst values = [3, 2, 1, 4, 5];\nconsole.log(getLongestIncreasingSubsequenceInPaths(N, edges, values)); \n// Output for this example would be run and evaluated as necessary based on specific values",
    "timestamp": "2025-08-13 11:22:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, edges, values):\n    # Create adjacency list representation of the tree\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Find shortest path from vertex 1 to every other vertex\n    def bfs_path(start):\n        dist = [float('inf')] * (N + 1)\n        parent = [0] * (N + 1)\n        dist[start] = 0\n        q = deque([start])\n\n        while q:\n            curr = q.popleft()\n            for neighbor in graph[curr]:\n                if dist[neighbor] == float('inf'):\n                    dist[neighbor] = dist[curr] + 1\n                    parent[neighbor] = curr\n                    q.append(neighbor)\n\n        return parent, dist\n\n    # Reconstruct path from start to end\n    def get_path(parent, end):\n        path = []\n        curr = end\n        while curr != 0:\n            path.append(values[curr - 1])\n            curr = parent[curr]\n        return path[::-1]\n\n    # Longest increasing subsequence\n    def lis(arr):\n        if not arr:\n            return 0\n        dp = [1] * len(arr)\n        for i in range(1, len(arr)):\n            for j in range(i):\n                if arr[i] > arr[j]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)\n\n    # Process for each vertex\n    max_lis = 0\n    parent, dist = bfs_path(1)\n    for k in range(1, N + 1):\n        path = get_path(parent, k)\n        max_lis = max(max_lis, lis(path))\n\n    return max_lis\n\n# Example usage\nN = 5\nedges = [(1,2), (1,3), (2,4), (2,5)]\nvalues = [1, 3, 2, 4, 5]\nprint(solve(N, edges, values))",
    "timestamp": "2025-08-13 11:23:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, edges, values) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    for (const [u, v] of edges) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    function findPath(start, end) {\n        const queue = [[start]];\n        const visited = new Set([start]);\n\n        while (queue.length) {\n            const path = queue.shift();\n            const node = path[path.length - 1];\n\n            if (node === end) return path;\n\n            for (const neighbor of graph[node]) {\n                if (!visited.has(neighbor)) {\n                    visited.add(neighbor);\n                    queue.push([...path, neighbor]);\n                }\n            }\n        }\n        return [];\n    }\n\n    function longestIncreasingSubsequence(arr) {\n        const dp = new Array(arr.length).fill(1);\n        for (let i = 1; i < arr.length; i++) {\n            for (let j = 0; j < i; j++) {\n                if (arr[i] > arr[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        return Math.max(...dp);\n    }\n\n    let maxLIS = 0;\n    for (let k = 1; k <= N; k++) {\n        const path = findPath(1, k);\n        const pathValues = path.map(node => values[node - 1]);\n        const currentLIS = longestIncreasingSubsequence(pathValues);\n        maxLIS = Math.max(maxLIS, currentLIS);\n    }\n\n    return maxLIS;\n}",
    "timestamp": "2025-08-13 11:23:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom bisect import bisect_left\n\ndef main():\n    sys.setrecursionlimit(1 << 25)\n    N = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    adj = [[] for _ in range(N)]\n    for _ in range(N-1):\n        u, v = map(int, sys.stdin.readline().split())\n        u -= 1\n        v -= 1\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    parent = [-1]*N\n    stack = [0]\n    parent[0] = -2  # mark as visited\n    order = []\n    while stack:\n        u = stack.pop()\n        order.append(u)\n        for v in adj[u]:\n            if parent[v] == -1:\n                parent[v] = u\n                stack.append(v)\n    \n    # Now process nodes in order (BFS order)\n    res = [0]*N\n    # We'll maintain a dynamic programming array for LIS\n    dp = []\n    history = []\n    for u in order:\n        if u == 0:\n            val = a[0]\n            pos = bisect_left(dp, val)\n            if pos == len(dp):\n                dp.append(val)\n            else:\n                history.append((pos, dp[pos]))\n                dp[pos] = val\n            res[u] = len(dp)\n        else:\n            p = parent[u]\n            val = a[u]\n            pos = bisect_left(dp, val)\n            old_len = len(dp)\n            old_val = None\n            if pos == old_len:\n                dp.append(val)\n            else:\n                history.append((pos, dp[pos]))\n                old_val = dp[pos]\n                dp[pos] = val\n            res[u] = len(dp)\n            # Rollback when backtracking (simulated by processing in order)\n            # To simulate backtracking, we need to process children first, but it's tricky.\n            # Alternative approach: for each node, the path is root to node, so we can collect the path and compute LIS for it.\n            # But that's O(N^2 log N) in worst case.\n            # So, we need a better approach.\n            # The above approach doesn't work because we can't rollback properly.\n            # Hence, we'll switch to collecting the path for each node and compute LIS.\n    \n    # Alternative approach: collect path for each node and compute LIS.\n    # Precompute parent pointers and then for each node, collect the path.\n    res = [0]*N\n    path = []\n    stack = [(0, True)]\n    dp = []\n    while stack:\n        u, is_forward = stack.pop()\n        if is_forward:\n            val = a[u]\n            pos = bisect_left(dp, val)\n            old_len = len(dp)\n            if pos == old_len:\n                dp.append(val)\n            else:\n                history.append((pos, dp[pos]))\n                dp[pos] = val\n            res[u] = len(dp)\n            # Push back with False to backtrack\n            stack.append((u, False))\n            # Push children in reverse order to process in order\n            for v in reversed(adj[u]):\n                if v != parent[u]:\n                    stack.append((v, True))\n        else:\n            # Backtrack\n            if history:\n                pos, old_val = history.pop()\n                if pos < len(dp):\n                    dp[pos] = old_val\n                else:\n                    dp.pop()\n    print('\\n'.join(map(str, res)))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 11:23:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const fs = require('fs');\n    const input = fs.readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    let ptr = 0;\n    const N = parseInt(input[ptr++], 10);\n    const a = input[ptr++].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => []);\n    for (let i = 0; i < N - 1; i++) {\n        const [u, v] = input[ptr++].split(' ').map(Number);\n        adj[u].push(v);\n        adj[v].push(u);\n    }\n\n    const parent = Array(N + 1).fill(0);\n    const path = Array(N + 1).fill().map(() => []);\n    path[1] = [a[0]];\n    const stack = [[1, 0]];\n    parent[1] = 0;\n\n    const res = Array(N + 1).fill(0);\n    res[1] = 1;\n\n    while (stack.length > 0) {\n        const [u, _] = stack.pop();\n        for (const v of adj[u]) {\n            if (v !== parent[u]) {\n                parent[v] = u;\n                const currentPath = [...path[u], a[v - 1]];\n                path[v] = currentPath;\n                const seq = currentPath;\n                const lis = [];\n                for (const num of seq) {\n                    let left = 0, right = lis.length;\n                    while (left < right) {\n                        const mid = (left + right) >> 1;\n                        if (lis[mid] < num) {\n                            left = mid + 1;\n                        } else {\n                            right = mid;\n                        }\n                    }\n                    if (left === lis.length) {\n                        lis.push(num);\n                    } else {\n                        lis[left] = num;\n                    }\n                }\n                res[v] = lis.length;\n                stack.push([v, u]);\n            }\n        }\n    }\n\n    const output = [];\n    for (let k = 1; k <= N; k++) {\n        output.push(res[k]);\n    }\n    console.log(output.join('\\n'));\n};\n\nsolve();",
    "timestamp": "2025-08-13 11:23:50"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> a;\n\nvector<int> bfs(int n) {\n    vector<int> dist(n + 1, -1), parent(n + 1, -1);\n    vector<int> path;\n    dist[1] = 0;\n    path.push_back(1);\n    vector<int> queue = {1};\n    \n    while (!queue.empty()) {\n        int u = queue.front();\n        queue.erase(queue.begin());\n        \n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                parent[v] = u;\n                queue.push_back(v);\n            }\n        }\n    }\n    \n    return parent;\n}\n\nint lis(const vector<int>& seq) {\n    vector<int> lis_sequence;\n    for (int num : seq) {\n        auto it = lower_bound(lis_sequence.begin(), lis_sequence.end(), num);\n        if (it == lis_sequence.end()) {\n            lis_sequence.push_back(num);\n        } else {\n            *it = num;\n        }\n    }\n    return lis_sequence.size();\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    adj.resize(n + 1);\n    a.resize(n + 1);\n    \n    for (int i = 1; i <= n; ++i) {\n        cin >> a[i];\n    }\n    \n    for (int i = 1; i < n; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n    \n    vector<int> parent = bfs(n);\n    \n    for (int k = 1; k <= n; ++k) {\n        vector<int> path;\n        int current = k;\n        \n        while (current != -1) {\n            path.push_back(a[current]);\n            current = parent[current];\n        }\n        \n        reverse(path.begin(), path.end());\n        cout << lis(path) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:03:26"
  }
]