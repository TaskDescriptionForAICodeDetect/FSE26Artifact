[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define R cin>>\n#define Z class\n#define ll long long\n#define ln cout<<'\\n'\n#define in(a) insert(a)\n#define pb(a) push_back(a)\n#define pd(a) printf(\"%.10f\\n\",a)\n#define mem(a) memset(a,0,sizeof(a))\n#define all(c) (c).begin(),(c).end()\n#define iter(c) __typeof((c).begin())\n#define rrep(i,n) for(ll i=(ll)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(ll i=(ll)(m);i<(ll)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\ntemplate<Z A>void pr(A a){cout<<a;ln;}\ntemplate<Z A,Z B>void pr(A a,B b){cout<<a<<' ';pr(b);}\ntemplate<Z A,Z B,Z C>void pr(A a,B b,C c){cout<<a<<' ';pr(b,c);}\ntemplate<Z A,Z B,Z C,Z D>void pr(A a,B b,C c,D d){cout<<a<<' ';pr(b,c,d);}\ntemplate<Z A>void PR(A a,ll n){rep(i,n){if(i)cout<<' ';cout<<a[i];}ln;}\nll check(ll n,ll m,ll x,ll y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1e9+7,MAXL=1LL<<61,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<ll,ll> P;\n\nll n,k;\nset<vector<ll> > s;\n\nvoid dfs(vector<ll> v) {\n  if(s.count(v)) return;\n  s.in(v);\n  rep(i,n-k+1) {\n    vector<ll> a=v;\n    rotate(a.begin()+i,a.begin()+i+1,a.begin()+i+k);\n    dfs(a);\n  }\n}\n\nclass BIT{\npublic:\n  ll n,bit[555555];\n  BIT(){fill(bit,bit+555555,0);}\n  void add(ll i,ll x){\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n    }\n  }\n  ll sum(ll i){\n    ll s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n};\n\nBIT b;\nll calc(vector<ll> a) {\n  b=BIT();\n  b.n=n+1;\n  ll ans=0;\n  rep(i,a.size()) {\n    b.add(a[i],1);\n    ans+=b.sum(n+1)-b.sum(a[i]);\n  }\n  return ans;\n}\n\nvoid solve(vector<ll> a) {\n  if(n==k) {\n    int k=-1;\n    rep(i,n) {\n      if(a[i]==1) k=i;\n    }\n    rotate(a.begin(),a.begin()+k,a.end());\n    rep(i,n) {\n      if(i+1!=a[i]) {\n        //pr(\"No\");\n        PR(a,a.size());\n        exit(0);\n        return;\n      }\n    }\n    //pr(\"Yes\");\n    return;\n  }\n  vector<ll> v;\n  rep(i,n-k) v.pb(a[i]);\n  ll x=calc(v);\n  v.clear();\n  REP(i,n-k,n) v.pb(a[i]);\n  ll y=calc(v);\n  if(x%2==y%2);\n  else {\n    pr(x,y);\n    PR(a,a.size()),exit(0);\n  }\n  //if(x%2==y%2) pr(\"Yes\");\n  //else pr(\"No\"),exit(0);\n}\n\nvoid Main() {\n  cin >> n >> k;\n  vector<ll> a(n);\n  /*\n  rep(i,n) a[i]=i+1;\n  dfs(a);\n  tr(it,s) {\n    vector<ll> v=*it;\n    PR(v,v.size());\n    pr(calc(v));\n    //solve(v);\n  }\n  return;\n  */\n  rep(i,n) R a[i];\n  if(n==k) {\n    int k=-1;\n    rep(i,n) {\n      if(a[i]==1) k=i;\n    }\n    rotate(a.begin(),a.begin()+k,a.end());\n    rep(i,n) {\n      if(i+1!=a[i]) {\n        pr(\"No\");\n        return;\n      }\n    }\n    pr(\"Yes\");\n    return;\n  }\n  if(k%2==0) pr(\"Yes\");\n  else if(calc(a)%2==0) pr(\"Yes\");\n  else pr(\"No\");\n}\n\nint main(){ios::sync_with_stdio(0);cin.tie(0);Main();return 0;}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dbg(x) cout<<#x<<\"=\"<<x<<endl\n\nusing P=pair<int,int>;\n\nint main(){\n    int n,k;\n    cin>>n>>k;\n    if(k==2){\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n    vector<int> p(n);\n    for (int i = 0; i < n; ++i) {\n        cin>>p[i];\n        --p[i];\n    }\n    if(n==k){\n        for (int i = 0; i < n-1; ++i) {\n            if(p[i]!=n-1&&p[i]>p[i+1]){\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n        }\n        cout<<\"Yes\"<<endl;\n        return 0;\n    }\n\n    vector<bool> vis(n,false);\n    int ms=0;\n    for (int i = 0; i < n; ++i) {\n      if(vis[i])continue;\n      int crt=i;\n      int d=0;\n      while(!vis[crt]){\n        vis[crt]=true;\n        d++;\n        crt=p[crt];\n      }\n      d%=2;\n      if(d==0)ms++;\n    }\n    ms%=2;\n\n    if(k%2==1&&ms%2==1)cout<<\"No\"<<endl;\n    else cout<<\"Yes\"<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <iterator>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  constexpr usize operator\"\" _z(unsigned long long x) noexcept {\n    return static_cast<usize>(x);\n  }\n\n  template <class T> class integral_iterator {\n  public:\n    using difference_type = T;\n    using value_type = T;\n    using pointer = const value_type*;\n    using reference = value_type;\n    using iterator_category = std::random_access_iterator_tag;\n\n  private:\n    using self_type = integral_iterator<value_type>;\n    value_type i;\n\n  public:\n    constexpr integral_iterator() noexcept : i() {}\n    explicit constexpr integral_iterator(const value_type i) noexcept : i(i) {}\n    constexpr self_type operator++(int) noexcept { return self_type(i++); }\n    constexpr self_type operator--(int) noexcept { return self_type(i--); }\n    constexpr self_type operator[](const difference_type rhs) const noexcept {\n      return self_type(i + rhs);\n    }\n    constexpr self_type& operator++() noexcept {\n      ++i;\n      return *this;\n    }\n    constexpr self_type& operator--() noexcept {\n      --i;\n      return *this;\n    }\n    constexpr reference operator*() const noexcept { return i; }\n    constexpr self_type operator+(const difference_type rhs) const noexcept {\n      return self_type(i + rhs);\n    }\n    constexpr self_type operator-(const difference_type rhs) const noexcept {\n      return self_type(i - rhs);\n    }\n    constexpr difference_type operator-(const self_type rhs) const noexcept {\n      return i - rhs.i;\n    }\n    constexpr bool operator<(const self_type rhs) const noexcept {\n      return i < rhs.i;\n    }\n    constexpr bool operator<=(const self_type rhs) const noexcept {\n      return i <= rhs.i;\n    }\n    constexpr bool operator>(const self_type rhs) const noexcept {\n      return i > rhs.i;\n    }\n    constexpr bool operator>=(const self_type rhs) const noexcept {\n      return i >= rhs.i;\n    }\n    constexpr bool operator==(const self_type rhs) const noexcept {\n      return i == rhs.i;\n    }\n    constexpr bool operator!=(const self_type rhs) const noexcept {\n      return i != rhs.i;\n    }\n    constexpr self_type& operator+=(const difference_type rhs) noexcept {\n      i += rhs;\n      return *this;\n    }\n    constexpr self_type& operator-=(const difference_type rhs) noexcept {\n      i -= rhs;\n      return *this;\n    }\n  };\n  template <class T>\n  constexpr integral_iterator<T> make_int_itr(const T i) noexcept {\n    return integral_iterator<T>(i);\n  }\n  class rep {\n    const usize f, l;\n\n  public:\n    constexpr rep(const usize f, const usize l) noexcept : f(f), l(l) {}\n    constexpr auto begin() const noexcept { return make_int_itr(f); }\n    constexpr auto end() const noexcept { return make_int_itr(l); }\n  };\n  class revrep {\n    const usize f, l;\n\n  public:\n    revrep(const usize f, const usize l) noexcept : f(l), l(f) {}\n    auto begin() const noexcept {\n      return std::make_reverse_iterator(make_int_itr(f));\n    }\n    auto end() const noexcept {\n      return std::make_reverse_iterator(make_int_itr(l));\n    }\n  };\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n\n} // namespace n91\n\n#include <cstdint>\n\nnamespace n91 {\n\n  constexpr std::uint_fast64_t totient(std::uint_fast64_t x) noexcept {\n    using u64 = std::uint_fast64_t;\n    u64 ret = x;\n    for (u64 i = static_cast<u64>(2); i * i <= x; ++i) {\n      if (x % i == static_cast<u64>(0)) {\n        ret -= ret / i;\n        x /= i;\n        while (x % i == static_cast<u64>(0)) {\n          x /= i;\n        }\n      }\n    }\n    if (x != static_cast<u64>(1)) {\n      ret -= ret / x;\n    }\n    return ret;\n  }\n\n  template <std::uint_fast64_t Modulus,\n    std::uint_fast64_t InverseExp =\n    totient(Modulus) - static_cast<std::uint_fast64_t>(1)>\n    class modint {\n    using u64 = std::uint_fast64_t;\n\n    static_assert(Modulus < static_cast<u64>(1) << static_cast<u64>(32),\n      \"Modulus must be less than 2**32\");\n\n    u64 a;\n\n    constexpr modint& negate() noexcept {\n      if (a != static_cast<u64>(0)) {\n        a = Modulus - a;\n      }\n      return *this;\n    }\n\n    public:\n      constexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n        : a(x% Modulus) {}\n      constexpr u64& value() noexcept { return a; }\n      constexpr const u64& value() const noexcept { return a; }\n      constexpr modint operator+() const noexcept { return modint(*this); }\n      constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n      constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n      }\n      constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n      }\n      constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n      }\n      constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n      }\n      constexpr modint& operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n          a -= Modulus;\n        }\n        return *this;\n      }\n      constexpr modint& operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n          a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n      }\n      constexpr modint& operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n      }\n      constexpr modint& operator/=(modint rhs) noexcept {\n        u64 exp = InverseExp;\n        while (exp) {\n          if (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n            *this *= rhs;\n          }\n          rhs *= rhs;\n          exp /= static_cast<u64>(2);\n        }\n        return *this;\n      }\n      constexpr bool operator==(const modint rhs) const noexcept {\n        return a == rhs.a;\n      }\n      constexpr bool operator!=(const modint rhs) const noexcept {\n        return a != rhs.a;\n      }\n  };\n\n  template <class T, std::uint_fast64_t v> class modint_constant {\n  public:\n    static constexpr T value = static_cast<T>(v);\n\n    using value_type = T;\n  };\n\n} // namespace n91\n\n#include <functional>\n#include <utility>\n\nnamespace n91 {\n\n  template <class T, class U, class Operate = std::multiplies<T>>\n  constexpr T power(T base, U exp, const Operate & oper = Operate(),\n    T iden = static_cast<T>(1)) {\n    while (exp != static_cast<U>(0)) {\n      if (exp % static_cast<U>(2) != static_cast<U>(0)) {\n        iden = oper(iden, base);\n      }\n      exp /= static_cast<U>(2);\n      base = oper(base, base);\n    }\n    return iden;\n  }\n\n} // namespace n91\n\n#include <vector>\n\nnamespace n91 {\n\n  template <class T> class fact_binom {\n  public:\n    using value_type = T;\n    using container_type = std::vector<value_type>;\n    using size_type = typename container_type::size_type;\n\n  private:\n    container_type factrial, inv_fact;\n\n  public:\n    fact_binom() : factrial(), inv_fact() {}\n    explicit fact_binom(const size_type n) : factrial(n + 1), inv_fact(n + 1) {\n      factrial[0] = static_cast<value_type>(1);\n      for (size_type i = 0; i != n; ++i) {\n        factrial[i + 1] = static_cast<value_type>(i + 1) * factrial[i];\n      }\n      inv_fact[n] = static_cast<value_type>(1) / factrial[n];\n      for (size_type i = n; i != 0; --i) {\n        inv_fact[i - 1] = inv_fact[i] * static_cast<value_type>(i);\n      }\n    }\n\n    value_type operator()(const size_type n, const size_type r) const {\n      return factrial[n] * inv_fact[r] * inv_fact[n - r];\n    }\n  };\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <set>\n#include <utility>\n\nnamespace std {\n  template <typename T> class BIT {\n  private:\n    int n;\n    vector<T> bit;\n\n  public:\n    // 0_indexed で i 番目の要素に x を加える\n    void add(int i, T x) {\n      i++;\n      while (i < n) {\n        bit[i] += x, i += i & -i;\n      }\n    }\n    // 0_indexed で [0,i] の要素の和(両閉区間！！)\n    T sum(int i) {\n      i++;\n      T s = 0;\n      while (i > 0) {\n        s += bit[i], i -= i & -i;\n      }\n      return s;\n    }\n    BIT() {}\n    //初期値がすべて0の場合\n    BIT(int sz) : n(sz + 1), bit(n, 0) {}\n    BIT(const vector<T>& v) : n((int)v.size() + 1), bit(n, 0) {\n      for (int i = 0; i < n - 1; i++) {\n        add(i, v[i]);\n      }\n    }\n    void print() {\n      for (int i = 0; i < n - 1; i++) {\n        cout << sum(i) - sum(i - 1) << \" \";\n      }\n      cout << \"\\n\";\n    }\n    //-1スタート\n    void print_sum() {\n      for (int i = 0; i < n; i++) {\n        cout << sum(i - 1) << \" \";\n      }\n      cout << \"\\n\";\n    }\n  };\n\n  // u を昇順にソートするのに必要な交換回数(転倒数) (u は {0,..., n-1}\n  // からなる重複を許した長さ n の数列)\n  long long inv_count(const vector<int>& u) {\n    int n = (int)u.size();\n    BIT<int> bt(n);\n    long long ans = 0;\n    for (int i = 0; i < n; i++) {\n      ans += i - bt.sum(u[i]);\n      bt.add(u[i], 1);\n    }\n    return ans;\n  }\n} // namespace std\n\nnamespace n91 {\n\n  void main_() {\n    const usize n = scan<usize>();\n    const usize k = scan<usize>();\n    std::vector<int> p(n);\n    for (auto& e : p) {\n      std::cin >> e;\n      --e;\n    }\n    if (k != n) {\n      const auto inv = std::inv_count(p);\n      std::cout << ((inv % 2 == 0 || k % 2 == 0) ? \"Yes\" : \"No\") << std::endl;\n      return;\n    }\n    for (const auto i : rep(1_z, n)) {\n      if ((p[i - 1_z] + 1_z - p[i]) % n != 0_z) {\n        std::cout << \"No\" << std::endl;\n        return;\n      }\n    }\n    std::cout << \"Yes\" << std::endl;\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <array>\n#include <utility>\n#include <algorithm>\n\nclass bit_vector {\n  size_t n;\n  static constexpr size_t nbit = 64;\n  std::vector<intmax_t> raw;\n  std::vector<int> acc;\n\n  int popcount(uintmax_t x) const {\n    return __builtin_popcountll(x);\n  }\n\npublic:\n  bit_vector() {}\n\n  bit_vector(const std::vector<bool>& b): n(b.size()) {\n    raw.assign(n/nbit+1, 0);\n    for (size_t i = 0; i < n; ++i)\n      if (b[i]) raw[i/nbit] |= intmax_t(1) << (i % nbit);\n\n    acc.assign(n/nbit+1, 0);\n    for (size_t i = 1; i < acc.size(); ++i)\n      acc[i] = acc[i-1] + popcount(raw[i-1]);\n  }\n\n  size_t rank1(size_t k) const {\n    size_t large = k / nbit;\n    size_t small = k % nbit;\n    size_t res = acc[large];\n    if (small > 0) res += popcount(raw[large] & ((uintmax_t(1) << small) - 1));\n    return res;\n  }\n\n  size_t rank0(size_t k) const {\n    return k - rank1(k);\n  }\n\n  size_t select1(size_t k) const {\n    if (k == 0) return 0;\n    size_t lb = 0;\n    size_t ub = n;\n    while (ub-lb > 1) {\n      size_t mid = (lb+ub) >> 1;\n      ((rank1(mid) < k)? lb:ub) = mid;\n    }\n    if (rank1(ub) < k) return -1;\n    return ub;\n  }\n\n  size_t select0(size_t k) const {\n    if (k == 0) return 0;\n    size_t lb = 0;\n    size_t ub = n;\n    while (ub-lb > 1) {\n      size_t mid = (lb+ub) >> 1;\n      ((rank0(mid) < k)? lb:ub) = mid;\n    }\n    if (rank0(ub) < k) return -1;\n    return ub;\n  }\n\n  size_t rank(int x, size_t k) const {\n    return x? rank1(k) : rank0(k);\n  }\n\n  size_t select(int x, size_t k) const {\n    return x? select1(k) : select0(k);\n  }\n\n  bool operator [](size_t k) const {\n    size_t large = k / nbit;\n    size_t small = k % nbit;\n    return raw[large] >> small & 1;\n  }\n};\n\ntemplate <class Tp, size_t bitlen = 8 * sizeof(Tp)>\nclass wavelet_matrix {\npublic:\n  using value_type = typename std::make_unsigned<Tp>::type;\n\nprivate:\n  std::vector<value_type> c;\n  std::vector<size_t> zeros;\n  size_t n;\n  std::array<bit_vector, bitlen> a;\n\n  size_t start_index(value_type x) const {\n    size_t s = 0;\n    size_t t = 0;\n    for (size_t i = bitlen; i-- > 1;) {\n      size_t j = bitlen-i-1;\n      if (x >> i & 1) {\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n      } else {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n      }\n    }\n    return s;\n  }\n\npublic:\n  template <class InputIt>\n  wavelet_matrix(InputIt first, InputIt last):\n    c(first, last), zeros(bitlen), n(c.size())\n  {\n    std::vector<value_type> whole = c;\n    for (size_t i = bitlen; i--;) {\n      std::vector<value_type> zero, one;\n      std::vector<bool> vb(n);\n      for (size_t j = 0; j < n; ++j) {\n        ((whole[j] >> i & 1)? one:zero).push_back(whole[j]);\n        vb[j] = (whole[j] >> i & 1);\n      }\n\n      zeros[bitlen-i-1] = zero.size();\n      a[bitlen-i-1] = bit_vector(vb);\n      if (i == 0) break;\n      whole = std::move(zero);\n      whole.insert(whole.end(), one.begin(), one.end());\n    }\n  }\n\n  size_t rank(value_type x, size_t t) const {\n    if (t == 0) return 0;\n    size_t s = 0;\n    for (size_t i = bitlen; i--;) {\n      size_t j = bitlen-i-1;\n      if (x >> i & 1) {\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n      } else {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n      }\n    }\n    return t - s;\n  }\n\n  std::pair<bool, value_type> max_lt(value_type x, size_t s, size_t t) const {\n    return max_le(x-1, s, t);\n  }\n  std::pair<bool, value_type> max_le(value_type x, size_t s, size_t t) const {\n    if (s == t) return {false, 0};\n    size_t ri = bitlen+1;\n    size_t rs = -1;\n    size_t rt = -1;\n    bool tight = true;\n    bool reverted = false;\n    value_type res = 0;\n    for (size_t i = bitlen; i--;) {\n      size_t j = bitlen-i-1;\n      size_t z = a[j].rank0(t) - a[j].rank0(s);\n      size_t tg = (tight? (x >> i & 1) : 1);\n      if (reverted) tg = 0;\n\n      bool ok0 = (z > 0);\n      bool ok1 = (z < t-s);\n      size_t ch = 0;\n\n      reverted = false;\n      if (tg == 1) {\n        if (ok0) {\n          ri = i;\n          rs = s;\n          rt = t;\n        }\n        if (ok1) {\n          ch = 1;\n        } else {\n          tight = false;\n        }\n      } else if (!ok0 && tight) {\n        if (ri > bitlen) return {false, 0};\n        i = ri+1;\n        s = rs;\n        t = rt;\n        tight = false;\n        value_type mask = (static_cast<value_type>(1) << i) - 1;\n        res |= mask;\n        res ^= mask;\n        reverted = true;\n        continue;\n      }\n\n      if (ch == 0) {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n      } else {\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n        res |= static_cast<value_type>(1) << i;\n      }\n    }\n    return {true, res};\n  }\n  std::pair<bool, value_type> min_gt(value_type x, size_t s, size_t t) const {\n    return min_ge(x+1, s, t);\n  }\n  std::pair<bool, value_type> min_ge(value_type x, size_t s, size_t t) const {\n    if (s == t) return {false, 0};\n    size_t ri = bitlen+1;\n    size_t rs = -1;\n    size_t rt = -1;\n    bool tight = true;\n    bool reverted = false;\n    value_type res = 0;\n    for (size_t i = bitlen; i--;) {\n      size_t j = bitlen-i-1;\n      size_t z = a[j].rank0(t) - a[j].rank0(s);\n      size_t tg = (tight? (x >> i & 1) : 0);\n      if (reverted) tg = 1;\n\n      bool ok0 = (z > 0);\n      bool ok1 = (z < t-s);\n      size_t ch = 1;\n\n      reverted = false;\n      if (tg == 0) {\n        if (ok1) {\n          ri = i;\n          rs = s;\n          rt = t;\n        }\n        if (ok0) {\n          ch = 0;\n        } else {\n          tight = false;\n        }\n      } else if (!ok1 && tight) {\n        if (ri > bitlen) return {false, 0};\n        i = ri+1;\n        s = rs;\n        t = rt;\n        tight = false;\n        value_type mask = (static_cast<value_type>(1) << ri) - 1;\n        res |= mask;\n        res ^= mask;\n        reverted = true;\n        continue;\n      }\n\n      if (ch == 0) {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n      } else {\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n        res |= static_cast<value_type>(1) << i;\n      }\n    }\n    return {true, res};\n  }\n\n  value_type quantile(size_t k, size_t s, size_t t) const {\n    value_type res = 0;\n    for (size_t i = bitlen; i--;) {\n      size_t j = bitlen-i-1;\n      size_t z = a[j].rank0(t) - a[j].rank0(s);\n      if (k < z) {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n      } else {\n        res |= static_cast<value_type>(1) << i;\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n        k -= z;\n      }\n    }\n    return res;\n  }\n\n  std::array<size_t, 3> rank_three_way(value_type x, size_t t) const {\n    if (t == 0) return {0, 0, 0};\n\n    size_t lt = 0;\n    size_t eq = t;\n    size_t gt = 0;\n\n    size_t s = 0;\n    for (size_t i = bitlen; i--;) {\n      size_t j = bitlen-i-1;\n      size_t tmp = (t - s);\n      if (x >> i & 1) {\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n        size_t d = tmp - (t-s);\n        eq -= d;\n        lt += d;\n      } else {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n        size_t d = tmp - (t-s);\n        eq -= d;\n        gt += d;\n      }\n    }\n    return {lt, eq, gt};\n  }\n\n  std::array<size_t, 3> xored_rank_three_way(value_type x, value_type y, size_t t) const {\n    if (t == 0) return {0, 0, 0};\n\n    size_t lt = 0;\n    size_t eq = t;\n    size_t gt = 0;\n\n    size_t s = 0;\n    for (size_t i = bitlen; i--;) {\n      size_t j = bitlen-i-1;\n      size_t tmp = (t - s);\n      if ((x ^ y) >> i & 1) {\n        s = zeros[j] + a[j].rank1(s);\n        t = zeros[j] + a[j].rank1(t);\n      } else {\n        s = a[j].rank0(s);\n        t = a[j].rank0(t);\n      }\n\n      size_t d = tmp - (t-s);\n      eq -= d;\n      if (y >> i & 1) {\n        lt += d;\n      } else {\n        gt += d;\n      }\n    }\n    return {lt, eq, gt};\n  }\n\n  size_t select(value_type x, size_t t) const {\n    if (t == 0) return 0;\n    size_t si = start_index(x);\n    t += a[bitlen-1].rank(x & 1, si);\n    t = a[bitlen-1].select(x & 1, t);\n\n    for (size_t i = 1; i < bitlen; ++i) {\n      size_t j = bitlen-i-1;\n      if (x >> i & 1) t -= zeros[j];\n      t = a[j].select(x >> i & 1, t);\n    }\n\n    return t;\n  }\n\n  value_type operator [](size_t t) const { return c[t]; }\n\n  void inspect() const {\n    for (size_t i = 0; i < bitlen; ++i) {\n      fprintf(stderr, \"%zu (%zu): \", i, zeros[i]);\n      for (size_t j = 0; j < n; ++j)\n        fprintf(stderr, \"%d%c\", a[i][j], j+1<n? ' ':'\\n');\n    }\n  }\n};\n\n\nint main() {\n  size_t n, k;\n  scanf(\"%zu %zu\", &n, &k);\n\n  std::vector<size_t> p(n);\n  for (auto& pi: p) scanf(\"%zu\", &pi), --pi;\n\n  if (n == k) {\n    intmax_t a = p[0];\n    for (size_t i = 1; i < n; ++i) {\n      intmax_t b = (p[i] + n - i) % n;\n      if (b < 0) b += n;\n      if (a != b) return puts(\"No\"), 0;\n    }\n    puts(\"Yes\");\n    return 0;\n  }\n\n  wavelet_matrix<size_t, 20> wm(p.begin(), p.end());\n  intmax_t res = 0;\n  for (size_t i = 0; i < n; ++i) {\n    res += wm.rank_three_way(p[i], i)[2];\n  }\n  // fprintf(stderr, \"%jd\\n\", res);\n\n  if (res % 2 == 0) {\n    puts(\"Yes\");\n  } else if (k % 2 == 0) {\n    puts(\"Yes\");\n  } else {\n    puts(\"No\");\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <stdio.h>\n#include <math.h>\n#include <algorithm>\n#include <vector>\n#define llint long long\n#define mod 998244353\n#define eps 1e-8\n\nusing namespace std;\n\nstruct BIT{\n\tint size;\n\tvector<int> bit;\n\tBIT(){size = 0;}\n\tBIT(int s){\n\t\tsize = s;\n\t\tbit.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) bit[i] = 0;\n\t}\n\tint query(int i){\n\t\tint ret = 0;\n\t\twhile(i > 0){\n\t\t\tret += bit[i];\n\t\t\ti -= i&(-i);\n\t\t}\n\t\treturn ret;\n\t}\n\tvoid add(int i, int x){\n\t\twhile(i <= size){\n\t\t\tbit[i] += x;\n\t\t\ti += i&(-i);\n\t\t}\n\t}\n};\n\nllint n, k;\nllint p[100005];\nBIT bit(100005);\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n >> k;\n\tfor(int i = 1; i <= n; i++) cin >> p[i];\n\t\n\tif(n == k){\n\t\tfor(int i = 0; i < n; i++) p[i] = p[i+1]-1;\n\t\tint x;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(p[i] == 0){\n\t\t\t\tx = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(p[(x+i)%n] != i){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tint inv = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tinv += (i-1) - bit.query(p[i]);\n\t\tbit.add(p[i], 1);\n\t}\n\t///cout << inv << endl;\n\t\n\tif(k % 2 == 0) cout << \"Yes\" << endl;\n\telse{\n\t\tif(inv % 2 == 0) cout << \"Yes\" << endl;\n\t\telse cout << \"No\" << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 100005\n\nint N,K;\nint P[SIZE];\nint BIT[SIZE];\n\nvoid add(int loc,int value){\n\n\tBIT[loc] += value;\n\n\tloc += loc & -loc;\n\n\twhile(loc <= N){\n\t\tBIT[loc] += value;\n\t\tloc += loc & -loc;\n\t}\n}\n\nint getSum(int loc){\n\n\tint sum = BIT[loc];\n\n\tloc -= loc & -loc;\n\n\twhile(loc > 0){\n\t\tsum += BIT[loc];\n\t\tloc -= loc & -loc;\n\t}\n\treturn sum;\n}\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&K);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%d\",&P[i]);\n\t}\n\n\tif(K == N){\n\n\t\tint start;\n\n\t\tfor(int i = 0; i < N; i++){\n\n\t\t\tif(P[i] == 1){\n\n\t\t\t\tstart = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tbool FLG = true;\n\n\t\tfor(int i = 1; i <= N; i++){\n\n\t\t\tint loc = (start+(i-1))%N;\n\t\t\tif(P[loc] != i){\n\t\t\t\tFLG = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(FLG){\n\n\t\t\tprintf(\"Yes\\n\");\n\n\t\t}else{\n\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\n\t}else{\n\n\t\tif(K%2 == 0){\n\n\t\t\tprintf(\"Yes\\n\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tll rev_num = 0;\n\n\t\tfor(int i = 0; i <= N; i++)BIT[i] = 0;\n\n\t\tfor(int i = 0; i < N; i++){\n\t\t\trev_num += i-getSum(P[i]);\n\t\t\tadd(P[i],1);\n\t\t}\n\n\t\tif(rev_num%2 == 0){\n\n\t\t\tprintf(\"Yes\\n\");\n\t\t}else{\n\n\t\t\tprintf(\"No\\n\");\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it = v.begin(); it != v.end(); it++)\n#define vrepr(v,it) for(auto it = v.rbegin(); it != v.rend(); it++)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,...) do { cerr << #v << \" = \"; array_out(v , __VA_ARGS__ );} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\n \nconstexpr int MOD = /** 1000000007; //*/ 998244353;\n/////////////////\n\n/*\nvvi g;\n#define pow nyapow\ninline ll nyapow(ll b,ll n){\n  ll ret = 1;\n  while(n){\n    if(n & 1) ret *= b;\n    b *= b;\n    n >>= 1;\n  }\n  return ret;\n}\nint cnt = 0;\nconstexpr int N = 5;\nconstexpr int K = 3;\nint idx(vi &v){\n  int ret = 0;\n  rep(i,N) ret += v[i] * pow(10 , i);\n  return ret;\n}\nvi inv(int idx){\n  vi ret(N,0);\n  rep(i,N){\n    ret[i] = idx % 10;\n    idx /= 10;\n  }\n  return ret;\n}\n\nvoid rot(vi &v , int start , int K){\n  int ushiro = v[start + K - 1];\n  repr(i , K - 1){\n    v[start + i + 1] = v[start + i];\n  }\n  v[start] = ushiro;\n}\n\nvi visited(pow(10,N) , 0);\n\nvoid dfs(int idx , int par){\n  out(inv(idx));\n  cnt++;\n  visited[idx] = 1;\n  each(x,g[idx]){\n    if(visited[x]) continue;\n    dfs(x , idx);\n  }\n}\n\n\nvoid solve(){\n  vi v(N); iota(all(v) , 0);\n  g.resize(pow(10,N));\n  trc(v);\n  do{\n    int curidx = idx(v);\n    rep(i , N - K + 1){\n      vi nxtv = v;\n      rot(nxtv , i , K);\n      g[idx(nxtv)].pb(curidx);\n    }\n  }while(next_permutation(all(v)));\n  sort(all(v));\n  dfs(idx(v) , -1);\n  out(cnt);\n} */\n\n// BIT\n\ntemplate< typename T >\nstruct BIT {\n  int N; int max_2beki;\n\n  vector< T > data;\n  // 初期化 1-indexedでデータを管理する 0で初期化\n  BIT(int size){\n      N = ++size;\n      data.assign(N, 0);\n      max_2beki = 1;\n      while(max_2beki * 2 <= N) max_2beki *= 2;\n  }\n\n  // [0,k](閉区間)の総和 閉区間に注意！\n  T sum(int k) {\n    if(k < 0) return 0; // k<0のとき0を返す\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n\n  // [l,r](閉区間)の総和\n  inline T sum(int l,int r){\n    return sum(r) - sum(l-1);\n  }\n\n  // 一点取得 更新はできないことに注意\n  inline T operator[](int k){\n    return sum(k) - sum(k-1);\n  }\n\n  // data[k] += x;\n  void add(int k, T x) {\n    for(++k; k < N; k += k & -k) data[k] += x;\n  }\n\n  // imos法 [l,r]にxを加算\n  void imos(int l,int r,T x){\n    add(l , x); add(r + 1 , -x);\n  }\n\n  // lower_bound sum(i)がval以上となる最小のi\n  int lower_bound(T w){\n    if(w <= 0) return 0;\n    int x = 0;\n    for(int k = max_2beki; k > 0; k /= 2){\n      if(x+k <= N - 1 && data[x + k] < w){\n        w -= data[x + k];\n        x += k;\n      }\n    }\n    return x;\n  }\n\n  // upper_bound sum(i)がvalより大きくなる最小のi\n  int upper_bound(T w){\n    if(w < 0) return 0;\n    int x = 0;\n    for(int k = max_2beki; k > 0; k /= 2){\n      if(x+k <= N - 1 && data[x + k] <= w){\n        w -= data[x + k];\n        x += k;\n      }\n    }\n    return x;\n  }\n\n};\n\nint p[100010];\nvoid solve(){\n  int N, K; cin >> N >> K;\n\tbool sorted = true;\n\tbool sorted2 = true;\n\tint cnt = 0;\n\trep(i, N) {\n\t\tcin >> p[i];\n\t}\n\trep(i, N - 1) {\n\t\tint tmp = p[i + 1] + N - p[i]; tmp %= N;\n\t\tif (tmp != 1)sorted2 = false;\n\t\tif (p[i] > p[i + 1]) {\n\t\t\tcnt++;\n\t\t\tsorted = false;\n\t\t}\n\t}\n\tif (K == 1) {\n\t\tif (sorted) {\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t\telse printf(\"No\\n\");\n\t}\n\telse if (K == N) {\n\t\tif (sorted2) {\n\t\t\tprintf(\"Yes\\n\");\n\t\t}\n\t\telse printf(\"No\\n\");\n\t}\n  else if(K % 2 == 1){\n    BIT<int> bit(100010);\n    ll tentou = 0;\n    rep(i,N){\n      tentou += bit.sum(p[i] + 1 , N);\n      bit.add(p[i] , 1);\n    }\n    if(tentou % 2 == 0) printf(\"Yes\\n\");\n    else printf(\"No\\n\");\n  }\n\telse printf(\"Yes\\n\");\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename T>\nstruct BIT{\n  Int n;\n  vector<T> bit;\n  //1-indexed\n  BIT():n(-1){}\n  BIT(Int n_,T d):n(n_),bit(n_+1,d){}\n\n  T sum(Int i){\n    T s=bit[0];\n    for(Int x=i;x>0;x-=(x&-x))\n      s+=bit[x];\n    return s;\n  }\n  void add(Int i,T a){\n    if(i==0) return;\n    for(Int x=i;x<=n;x+=(x&-x))\n      bit[x]+=a;\n  }\n};\n\n\ntemplate<typename T> void drop(const T &x){cout<<x<<endl;exit(0);}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,k;\n  cin>>n>>k;\n  vector<Int> ps(n);\n  for(Int i=0;i<n;i++) cin>>ps[i];\n\n  if(n==k){\n    vector<Int> vs;\n    for(Int p:ps) vs.emplace_back(p);\n    for(Int p:ps) vs.emplace_back(p);\n\n    for(Int i=0;i<n;i++){\n      if(vs[i]!=1) continue;\n      Int flg=1;\n      for(Int j=0;j<n;j++)\n        flg&=vs[i+j]==j+1;\n      cout<<(flg?\"Yes\":\"No\")<<endl;\n      break;\n    }\n    return 0;\n  }\n\n  if(k%2==0) drop(\"Yes\");\n\n  BIT<Int> bit(n+10,0);\n  Int sum=0;\n  for(Int i=0;i<n;i++){\n    sum+=i-bit.sum(ps[i]);\n    sum%=2;\n    bit.add(ps[i],1);\n  }\n  cout<<(sum?\"No\":\"Yes\")<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nset<vector<int> > st;\n\nvoid dfs(vector<int> a,int n,int k){\n    for(int i=0;i<=n-k;i++){\n        for(int t = 1;t<=k-1;t++){\n            vector<int>b(n);\n            rep(j,n){\n                b[j] = a[j];\n            }  \n        \n            rep(j,k){\n                b[i+j] = a[i+j+t];\n                if(i+j+t >= i+k){\n                    b[i+j] = a[i+j+t-k];\n                } \n            }\n            if(st.count(b)){\n\n            }else{\n                st.insert(b);\n                dfs(b,n,k);\n            }\n        }\n    }\n\n}\ntemplate<typename T> class BIT {\nprivate:\n\tint n;\n\tvector<T> bit;\npublic:\n\t// 0_indexed で i 番目の要素に x を加える\n\tvoid add(int i, T x){\n\t\ti++;\n\t\twhile(i < n){\n\t\t\tbit[i] += x, i += i & -i;\n\t\t}\n\t}\n\t// 0_indexed で [0,i] の要素の和(両閉区間！！)\n\tT sum(int i){\n\t\ti++;\n\t\tT s = 0;\n\t\twhile(i > 0){\n\t\t\ts += bit[i], i -= i & -i;\n\t\t}\n\t\treturn s;\n\t}\n\tBIT(){}\n\t//初期値がすべて0の場合\n\tBIT(int sz) : n(sz+1), bit(n, 0){}\n\tBIT(const vector<T>& v) : n((int)v.size()+1), bit(n, 0){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tadd(i,v[i]);\n\t\t}\n\t}\n\tvoid print(){\n\t\tfor(int i = 0; i < n-1; i++){\n\t\t\tcout << sum(i) - sum(i-1) << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\t//-1スタート\n\tvoid print_sum(){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcout << sum(i-1) << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n};\n \n// u を昇順にソートするのに必要な交換回数(転倒数) (u は {0,..., n-1} からなる重複を許した長さ n の数列)\nlong long inv_count(const vector<int>& u)\n{\n\tint n = (int)u.size();\n\tBIT<int> bt(n);\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tans += i - bt.sum(u[i]);\n\t\tbt.add(u[i], 1);\n\t}\n\treturn ans;\n}\n \n// u を v に変換するのに必要な交換回数(転倒数)\n// (u, v は {0,..., n-1} からなる重複を許した長さ n の数列. ただし u, v 全体で各数字の個数は一致するものとする)\nlong long inv_count(const vector<int>& u, const vector<int>& v)\n{\n    int n = (int)u.size();\n    vector<vector<int> > p(n);\n    BIT<int> bt(n);\n    for(int i = n-1; i >= 0; --i){\n        p[u[i]].push_back(i);\n    }\n    long long ans = 0;\n    for(int i = 0; i < n; ++i){\n        int pos = p[v[i]].back();\n        p[v[i]].pop_back();\n        ans += pos - bt.sum(pos);\n        bt.add(pos, 1);\n    }\n    return ans;\n}\nint main(){\n    // for(int n = 2;n<=8;n++){\n    //     for(int k=2;k<=n;k++){\n    //         st.clear();\n    //         vector<int>v(n);\n    //         rep(i,n){\n    //             v[i] = i;\n    //         }\n    //         dfs(v,n,k);\n    //         int sm = 1;\n    //         rep(i,n){\n    //             sm *=(i+1);\n    //         }\n    //         cout << n << \" \" << k << endl;\n    //         cout << sm << endl;\n    //         cout << st.size() << endl;\n    //         // for(auto s:st){\n    //         //     for(auto x:s){\n    //         //         cout << x << \" \";\n    //         //     }\n    //         //     cout << endl;\n    //         // }\n    //     }\n    // }\n    int n,k;\n    cin >> n >> k;\n    vector<int>a(n);\n    rep(i,n){\n        cin >> a[i];\n        a[i]--;\n    }\n    if(n==k){\n        int id = 0;\n        rep(i,n){\n            if(a[i]==0){\n                id = i;\n            }\n        }\n        rep(i,n){\n            int k = id+i;\n            k%=n;\n            \n            if(a[k]!=i){\n                cout <<\"No\" << endl;\n                return 0;\n            }\n        }\n        cout << \"Yes\" << endl;\n    }else{\n        if(k%2==0){\n            cout << \"Yes\" << endl;\n        }else{\n            if(inv_count(a)%2){\n                cout << \"No\" << endl;\n            }else{\n                cout << \"Yes\" << endl;\n            }\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\n//int N,M,K,L,R,H,W;\nlong long int N,M,K,L,R,H,W;\n\n//constexpr long long int MOD=1000000007;\n//constexpr  int MOD=1000000007;\nconstexpr int MOD=998244353;\n//constexpr long long int MOD=998244353;\n\nclass Add_Segment_Tree {\n\tvector<long long int>v;\n\tvector<int>l;\n\tvector<int>r;\n\tlong long int ret;\n\tint num;\n\tlong long int Update(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\treturn v[place];\n\t\t}\n\t\tv[place] = Update(place * 2) + Update(place * 2 + 1);\n\t\treturn v[place];\n\t}\n\tvoid Sum(int a, int b, int place) {\n\t\tif (l[place] >= a&&r[place] <= b) {\n\t\t\tret += v[place];\n\t\t\treturn;\n\t\t}\n\t\tif (l[place] > b || r[place] < a) return;\n\t\tSum(a, b, place * 2);\n\t\tSum(a, b, place * 2 + 1);\n\t\treturn;\n\t}\npublic:\n\tvoid Left(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tl[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tLeft(place * 2);\n\t\tLeft(place * 2 + 1);\n\t\tl[place] = l[place * 2];\n\t\treturn;\n\t}\n\tvoid Right(int place) {\n\t\tif (place >= v.size() / 2) {\n\t\t\tr[place] = place - v.size() / 2;\n\t\t\treturn;\n\t\t}\n\t\tRight(place * 2);\n\t\tRight(place * 2 + 1);\n\t\tr[place] = r[place * 2 + 1];\n\t\treturn;\n\t}\n\tAdd_Segment_Tree(int n) {\n\t\tn++;\n\t\tnum = 1;\n\t\twhile (num < n * 2)num *= 2;\n\t\tl.resize(num);\n\t\tr.resize(num);\n\t\tv.resize(num, 0);\n\t\tLeft(1);\n\t\tRight(1);\n\t}\n\tvoid Add(int place, long long int num, bool update) {\n\t\tplace += v.size() / 2;\n\t\tv[place] += num;\n\t\tif (!update)return;\n\t\tplace /= 2;\n\t\twhile (place) {\n\t\t\tv[place] = v[place * 2] + v[place * 2 + 1];\n\t\t\tplace /= 2;\n\t\t}\n\t}\n\tvoid TopDown() {\n\t\tUpdate(1);\n\t}\n\tlong long int Sum(int a, int b) {\n\t\tret = 0;\n\t\tSum(a, b, 1);\n\t\treturn ret;\n\t}\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tcin>>N>>K;\n\tvector<int>v(N);\n\tfor(auto &i:v)cin>>i;\n\tlong long int box=0;\n\tAdd_Segment_Tree asg(N+1);\n\tfor(int i=0;i<N;i++){\n\t\tbox+=asg.Sum(v[i],N);\n\t\tasg.Add(v[i],1,true);\n\t}\n\tif(box%2&&K%2){\n\t\tcout<<\"No\\n\";\n\t\treturn 0;\n\t}\n\tif(N==K){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif((v[i]+1)%N!=(v[(i+1)%N])%N){\n\t\t\t\tcout<<\"No\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<\"Yes\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n/* ----- Type Alias ----- */\nusing Int = long long int;\nusing Real = long double;\nusing std::pair;\nusing std::string;\nusing std::tuple;\nusing std::vector;\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = vector<vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// const Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nstruct SegmentTree {\n    int length;\n    std::vector<int> dat;\n\n    int query(int ql, int qr, int nidx, int nl, int nr) {\n        if (nr <= ql || qr <= nl) return 0;\n        if (ql <= nl && nr <= qr) return dat[nidx];\n        int vl = query(ql, qr, nidx * 2, nl, (nl + nr) / 2);\n        int vr = query(ql, qr, nidx * 2 + 1, (nl + nr) / 2, nr);\n        return vl + vr;\n    }\n\n    SegmentTree(int N) : length(1) {\n        while (length < N) length <<= 1;\n        dat.assign(length * 2, 0);\n    }\n\n    // half-open interval [ql, qr)\n    int query(int ql, int qr) { return query(ql, qr, 1, 0, length); }\n\n    void update(int idx, int e) {\n        int nidx = idx + length;\n        dat[nidx] += e;\n        while (nidx > 0) {\n            nidx >>= 1;\n            dat[nidx] = dat[nidx * 2] + dat[nidx * 2 + 1];\n        }\n    }\n};\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    vector<int> p(n);\n    for (auto& x : p) {\n        std::cin >> x;\n        --x;\n    }\n\n    if (k == n) {\n        int i;\n        for (i = 0; p[i] != 0; ++i) {}\n        for (int j = 0; j < n; ++j) {\n            if (p[(i + j) % n] != j) {\n                std::cout << \"No\" << std::endl;\n                return 0;\n            }\n        }\n        std::cout << \"Yes\" << std::endl;\n        return 0;\n    }\n\n    Int rev = 0;\n    SegmentTree seg(n);\n    for (auto x : p) {\n        rev += seg.query(x + 1, n);\n        seg.update(x, 1);\n    }\n\n    if (k % 2 == 1 && rev % 2 == 1) {\n        std::cout << \"No\" << std::endl;\n    } else {\n        std::cout << \"Yes\" << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n#include <sys/types.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 1e-9\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef pair<int,pii> pip;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\n\nint gcd(int a, int b){if(b==0) return a;return gcd(b,a%b);}\nint lcm(int a, int b){return a/gcd(a,b)*b;}\n\n\nstruct BIT{\n  vector<int> bit;\n  int n;\n  //1-indexed\n  BIT(){init(-1);}\n  BIT(int n_){init(n_);}\n  void init(int n_){\n    n=n_;\n    bit.clear();\n    bit.resize(n+1,0);\n  }\n  int sum(int i){\n    int s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&-i;\n    }\n    return s;\n  }\n  void add(int i,int x){\n    if(i==0) return;\n    while(i<=n){\n      bit[i]+=x;\n      i+=i&-i;\n    }\n  }\n  int sum0(int i){\n    return sum(i+1);\n  }\n  void add0(int i,int x){\n    add(i+1,x);\n  }\n};\nsigned main(void) {\n    int n,k;\n    cin >> n >> k;\n    int a[n];\n  for(int i=0;i<n;i++) cin>>a[i];\n  if(n == k){\n      rep(i,n)if(a[i] == 1){\n          rep(j,n)if(a[(i+j)%n] != a[i]+j){\n              cout << \"No\" << endl;\n              return 0;\n          }\n      }\n      cout << \"Yes\" << endl;\n      return 0; \n  }\n  if(k%2 == 0){\n      cout << \"Yes\" << endl;\n      return 0;\n  }\n  reverse(a,a+n);\n  BIT bit(n+10);\n  int ans=0;\n  for(int i=0;i<n;i++){\n    ans+=bit.sum(a[i]);\n    bit.add(a[i],1);\n}\n  if(ans%2){\n      cout << \"No\" << endl;\n  }else{\n      cout << \"Yes\" << endl;\n  }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <fstream>\nclass Bit {\n\tstd::vector<int> vec;\npublic:\n\tBit(const int size) : vec(size, 0) {};\n\tint operator[](int position) const {\n\t\tint result = 0;\n\t\twhile (position >= 0) {\n\t\t\tresult += vec[position];\n\t\t\tposition -= ~position & (position + 1);\n\t\t}\n\t\treturn result;\n\t}\n\tvoid increment(int position) {\n\t\twhile (position < vec.size()) {\n\t\t\tvec[position]++;\n\t\t\tposition += ~position & (position + 1);\n\t\t}\n\t}\n};\nint main() {\n\tint n, k; std::cin >> n >> k;\n\tstd::vector<int> permutation(n); for (auto& p : permutation) std::cin >> p;\n\tif (n == k) {\n\t\tbool can_sort = true;\n\t\tfor (auto i = 1; i < n; ++i) {\n\t\t\tif (permutation[i - 1] > permutation[i]) {\n\t\t\t\tif (can_sort) {\n\t\t\t\t\tcan_sort = false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstd::cout << \"No\\n\";\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::cout << \"Yes\\n\";\n\t}\n\telse if (k % 2 == 0) {\n\t\tstd::cout << \"Yes\\n\";\n\t}\n\telse {\n\t\tBit bit(n);\n\t\tlong long int swap_count = 0;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tconst auto p = permutation[i];\n\t\t\tswap_count += i - bit[p - 1];\n\t\t\tbit.increment(p - 1);\n\t\t}\n\t\tif (swap_count % 2 == 0) {\n\t\t\tstd::cout << \"Yes\\n\";\n\t\t}\n\t\telse {\n\t\t\tstd::cout << \"No\\n\";\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nint N,K;\nvector<int> P;\n\nclass BIT{//1-indexed\npublic:\n\n  vector<ll> bit;\n  BIT(){}\n  BIT(int size){\n    bit.resize(size,0);\n  }\n\n  ll sum(int i){\n    ll s=0;\n    while(i>0){\n      s+=bit[i];\n      i-=i&(-i);\n    }\n    return s;\n  }\n\n  void add(int i,ll x){//i!=0\n    while(i<bit.size()){\n      bit[i]+=x;\n      i+=i&(-i);\n    }\n  }\n};\n\n\nint main(){\n  cin>>N>>K;\n  P.resize(N);\n  rep(i,N) cin>>P[i];\n\n  if(K==N){\n    for(int i=0;i+1<N;i++){\n      if(P[i]+1==P[i+1]||P[i]==N&&P[i+1]==1);\n      else {\n        cout<<\"No\"<<endl;\n        return 0;\n      }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n  }\n\n  BIT bit(N+1);\n  ll ans=0;\n  for(int i=0;i<N;i++){\n    ans+=i-bit.sum(P[i]);\n    bit.add(P[i],1);\n  }\n\n  if(K%2==0||ans%2==0) cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n#define NL <<\"\\n\"\n\nusing namespace std;\nusing ll=long long;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#include \"../benri.h\"\n#else\n#define out(args...)\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7; //998244353\n\nconst int nn=112345;\nll bit[nn+213];\nll sum(int i){ ++i;\n\tll s=0;\n\twhile(i>0){\n\t\ts+=bit[i];\n\t\ti-=i&-i;\n\t}\n\treturn s;\n}\nvoid add(int i,ll x){ ++i;\n\twhile(i<=nn){\n\t\tbit[i]+=x;\n\t\ti+=i&-i;\n\t}\n}\n\nint main(){\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  cout<<fixed<<setprecision(0);\n\tint n,t;\n\tcin>>n>>t;\n\tvector<int> a(n);\n\trep(i,n) cin>>a[i];\n\tll inv=0;\n\trep(i,n){\n\t\tinv+=i-sum(a[i]);\n\t\tadd(a[i],1);\n\t}\n\tint ok=1;\n\tif(n==t){\n\t\trep(i,n)if(a[i]%n!=(a[0]+i)%n) ok=0;\n\t}else{\n\t\tif(t%2 && inv%2) ok=0;\n\t}\n\tcout<<(ok?\"Yes\":\"No\")<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define YES \"YES\"\n#define NO \"NO\"\n#define Yes \"Yes\"\n#define No \"No\"\n#define ECHO OUT(solve())\n#define YESNO OUT(three(solve(),YES,NO))\n#define YesNo OUT(three(solve(),Yes,No))\n#define three(A,B,C) ((A)?(B):(C))\n#define FOR(i,a,b)  for(LL i=(a);i< (LL)(b);i++)\n#define EFOR(i,a,b) for(LL i=(a);i<=(LL)(b);i++)\n#define RFOR(i,a,b) for(LL i=(b);i>=(LL)(a);i--)\n#define REP(i,b) FOR(i,zero,b)\n#define rep REP\n#define EREP(i,b) EFOR(i,zero,b)\n#define RREP(i,b) RFOR(i,b,zero)\n#define ALL(c) c.begin(),c.end()\n#define UNIQUE(c) sort(ALL(c));c.erase(unique(ALL(c)),c.end())\n#define MAX(c) (*max_element(ALL(c)))\n#define MIN(c) (*min_element(ALL(c)))\n#define MP make_pair\n#define FI first\n#define SE second\n#define SI(x) (LL(x.size()))\n#define PB push_back\n#define DEBUG(a) OUT(a)\n#define DEBUG2(a,b) OUT2(a,b)\n#define cat cout << __LINE__ << endl\n#define OUT(a) cout << (a) << endl\n#define OUT2(a,b) cout << (a) <<\" \"<<(b) << endl\n#define zero 0LL\n#define all ALL\n#define pb emplace_back\n#define eb pb\n#define int long long\nusing namespace std;\ntemplate<typename T> inline void maximize(T &a, T b) { a = max(a, b); }\ntemplate<typename T> inline void minimize(T &a, T b) { a = min(a, b); }\ntemplate<typename T> inline bool middle(T a, T b, T c) { return b <= a && a <= c; }\ntemplate<class T> inline bool MX(T &l, const T &r) { return l < r ? l = r, 1 : 0; }\ntemplate<class T> inline bool MN(T &l, const T &r) { return l > r ? l = r, 1 : 0; }\ntypedef int LL;\ntypedef double ld;\ntypedef int ut;\ntypedef vector<ut> VI;\ntypedef vector<VI> VII;\ntypedef pair<ut, ut> pr;\ntypedef pair<ut, pr> ppr;\ntypedef vector<pr> Vpr;\ntypedef vector<ppr> Vppr;\ntypedef tuple<int, int, int, int> tapu;\ntypedef vector<tapu> Vtapu;\ntypedef priority_queue<tapu, Vtapu, greater<tapu> > PQ;\ninline void outputVI(VI x) { REP(i, SI(x)) { cout << three(i, \" \", \"\") << x[i]; }OUT(\"\"); }\nconst int SIZE1 = 3e5 + 1000;\nconst int SIZE2 = 5010;\nconst int SIZE3 = 430;\nconst int SIZE = SIZE1;\nconst int MAPSIZE = 40;\nconst LL p = 7 + 1e9;\nconst LL INF = 1LL << 60;\nconst long double EPS = 1e-7;\ntypedef pair<ld, ut> pld;\nLL BIT[SIZE];\nvoid add(int x,int t){\n  x++;\n  while(x<=SIZE){\n    BIT[x]+=t;\n    x+=x&-x;\n  }\n}\nLL sum(int x){\n  x++;\n  int ans=0;\n  while(x>0){\n    ans+=BIT[x];\n    x-=x&-x;\n  }\n  return ans;\n}\nLL sum(int a,int b){\n  return sum(b)-sum(a-1);\n}\nLL P[SIZE];\nLL solve(){\n\n \tLL N,K;\n  cin >> N >> K;\n  REP(i,N){\n    cin >> P[i];\n    add(i+1,1);\n  }\n  \n  if(K==N){\n    REP(i,N-1)\n      if(P[i]%N!=(P[i+1]+N-1)%N) return 0;\n    return 1;\n  }\n  if(K%2==0) return 1;\n  LL ans=0;\n  REP(i,N){\n    ans+=sum(1,P[i]-1);\n    add(P[i],-1);\n  }\n  if(ans%2) return 0;\n  return 1;\n}\nsigned main(){\n  YesNo;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\nusing namespace std;\n\nconst int MAXN = 100000, MOD = 1000000007;\n\nint t[MAXN + 10];\n\nvoid add(int v, int d)\n{\n    for (; v <= MAXN; v += (v & (-v)))\n        t[v] += d;\n}\n\nint sum(int r)\n{\n    int ans = 0;\n    for (; r > 0; r -= (r & (-r)))\n        ans += t[r];\n    return ans;\n}\n\nint sum(int l, int r)\n{\n    return sum(r) - sum(l - 1);\n}\n\nint index(vector<int> p, int mod)\n{\n    int n = p.size();\n    memset(t, 0, sizeof t);\n    for (int i = 1; i <= n; ++i)\n        add(i, 1);\n    int fact[MAXN + 10];\n    fact[0] = 1 % mod;\n    for (int i = 1; i <= n; ++i)\n        fact[i] = fact[i - 1] * 1ll * i % mod;\n    int ans = 0;\n    for (int i = 0; i < n; ++i)\n    {\n        int id = sum(p[i] - 1);\n        ans = (ans + id * 1ll * fact[n - 1 - i]) % mod;\n        add(p[i], -1);\n    }\n    return ans;\n}\n\nint parity(vector<int> p)\n{\n    int n = p.size();\n    memset(t, 0, sizeof t);\n    int ans = 0;\n    for (int i = n - 1; i >= 0; --i)\n    {\n        int smaller = sum(p[i] - 1);\n        ans = (ans + smaller) % 2;\n        add(p[i], 1);\n    }\n    return ans;\n}\n\nint main()\n{\n    cin.sync_with_stdio(false);\n    int CASE = 1;\n    int n, k;\n    vector<int> p, q;\n    cin >> n >> k;\n    p.resize(n);\n    q.resize(n);\n    for (int i = 0; i < n; ++i)\n        cin >> p[i];\n    for (int i = 0; i < n; ++i)\n        q[i] = i + 1;\n    if (k == n)\n    {\n        int start = -1;\n        for (int i = 0; i < n; ++i)\n        {\n            if (q[i] == p[0])\n            {\n                start = i;\n                break;\n            }\n        }\n        bool good = true;\n        for (int i = 0; i < n; ++i)\n        {\n            if (p[i] != q[(i + start) % n])\n            {\n                good = false;\n                break;\n            }\n        }\n        if (good)\n            cout << \"Yes\" << endl;\n        else\n            cout << \"No\" << endl;\n    }\n    else if (k % 2 == 0)\n    {\n        int id = index(q, MOD);\n        cout << \"Yes\" << endl;\n    }\n    else\n    {\n        if (parity(p) == parity(q))\n        {\n            int id = index(q, MOD);\n            if (index(q, 2) == 1)\n                id = (id + MOD - 1) % MOD;\n            id = id * 500000004ll % MOD;\n            cout << \"Yes\" << endl;\n        }\n        else\n        {\n            cout << \"No\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n//1-indexed\n#include<vector>\ntemplate<typename T>\nstruct BIT{\n\tint n;\n\tvector<T>bit;\n\tBIT(int n_=0):n(n_),bit(n_+1){}\n\tT sum(int i)\n\t{\n\t\tT ans=0;\n\t\tfor(;i>0;i-=i&-i)ans+=bit[i];\n\t\treturn ans;\n\t}\n\tvoid add(int i,T a)\n\t{\n\t\tif(i==0)return;\n\t\tfor(;i<=n;i+=i&-i)bit[i]+=a;\n\t}\n\tint lower_bound(T k)//k<=sum(ret)\n\t{\n\t\tif(k<=0)return 0;\n\t\tint ret=0,i=1;\n\t\twhile((i<<1)<=n)i<<=1;\n\t\tfor(;i;i>>=1)\n\t\t\tif(ret+i<=n&&bit[ret+i]<k)k-=bit[ret+=i];\n\t\treturn ret+1;\n\t}\n};\nint main(){\n    unsigned long N, K;\n    cin >> N >> K;\n    if(N == K){\n        vector<unsigned long> P(N);\n        for(auto& i : P)cin >> i;\n        P.push_back(P[0]);\n        for(unsigned long i = 0; i < N; ++i)if((P[i] + 1 + N - P[i + 1]) % N)return 0 & puts(\"No\");\n\t\tputs(\"Yes\");\n\t\treturn 0;\n    }\n    if(~K & 1)return 0 & puts(\"Yes\");\n    vector<unsigned long> P(N);\n    for(auto& i : P)cin >> i;\n    BIT<int>bit(N);\n\tlong long T=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tT+=i-bit.sum(P[i]);\n\t\tbit.add(P[i],1);\n\t}\n\tcout<<(T%2?\"No\":\"Yes\")<<endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n\nll inverse(int* A, int N) {\n\tll ans = 0;\n\tll a[N + 1000] = {};\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = A[i]; j; j -= (j & (-j))) ans -= a[j]; ans += i;\n\t\tfor (int j = A[i]; j <= N; j += (j & (-j))) a[j]++;\n\t}\n\treturn ans;\n}\n\nsigned main() {\n\tint n, k;\n\tcin >> n >> k;\n\n\tint p[n];\n\tfor (int i = 0; i < n; ++i) {\n\t\tint pi; cin >> pi;\n\t\tp[i] = pi;\n\t}\n\n\tbool is_sorted = true;\n\tfor (int i = 0; i < n; ++i)\n\t\tis_sorted = is_sorted && (p[i] == i + 1);\n\tif (is_sorted){\n\t\tcout << \"Yes\" << endl;\n\t\texit(0);\n\t}\n\n\tif (n == k){\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < n; ++i){\n\t\t\tif (p[(i + 1) % n] != (p[i] != n ? (p[i] + 1) : 1))\n\t\t\t\tok = false;\n\t\t}\n\t\tif (ok){\n\t\t\tcout << \"Yes\" << endl;\n\t\t\texit(0);\n\t\t}\n\t\telse{\n\t\t\tcout << \"No\" << endl;\n\t\t\texit(0);\n\t\t}\n\t}\n\n\tll inv = inverse(p, n);\n\n\tif (k % 2 == 1 && inv % 2 == 1) {\n\t\tcout << \"No\" << endl;\n\t}\n\telse {\n\t\tcout << \"Yes\" << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing Int = long long int;\nusing std::vector;\n\n// 加算と総和\nstruct SegmentTree {\n    int length;\n    vector<int> dat;\n\n    int query(int ql, int qr, int nidx, int nl, int nr) {\n        if (nr <= ql || qr <= nl) return 0;\n        if (ql <= nl && nr <= qr) return dat[nidx];\n        int vl = query(ql, qr, nidx * 2, nl, (nl + nr) / 2);\n        int vr = query(ql, qr, nidx * 2 + 1, (nl + nr) / 2, nr);\n        return vl + vr;\n    }\n\n    SegmentTree(int n) : length(1) {\n        while (length < n) length <<= 1;\n        dat.assign(length * 2, 0);\n    }\n\n    // half-open interval [ql, qr)\n    int query(int ql, int qr) { return query(ql, qr, 1, 0, length); }\n\n    void update(int idx, int e) {\n        int nidx = idx + length;\n        dat[nidx] += e;\n        while (nidx > 0) {\n            nidx >>= 1;\n            dat[nidx] = dat[nidx * 2] + dat[nidx * 2 + 1];\n        }\n    }\n};\n\nint main() {\n    int n, k;\n    std::cin >> n >> k;\n\n    vector<int> p(n);\n    for (auto& x : p) {\n        std::cin >> x;\n        --x;\n    }\n\n    if (k == n) {\n        int i;\n        for (i = 0; p[i] != 0; ++i) {}\n        for (int j = 0; j < n; ++j) {\n            if (p[(i + j) % n] != j) {\n                std::cout << \"No\" << std::endl;\n                return 0;\n            }\n        }\n    } else if (k % 2 == 1) {\n        Int rev = 0;\n        SegmentTree seg(n);\n        for (auto x : p) {\n            rev += seg.query(x + 1, n);\n            seg.update(x, 1);\n        }\n        if (rev % 2 == 1) {\n            std::cout << \"No\" << std::endl;\n            return 0;\n        }\n    }\n\n    std::cout << \"Yes\" << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\n#include<complex>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\nconst ld pi = acos(-1.0);\n\nstruct BIT {\nprivate:\n\tvector<ll> node; int n;\npublic:\n\tBIT(int n_) {\n\t\tn = n_; node.resize(n, 0);\n\t}\n\t//0-indexed\n\tvoid add(int a, ll w) {\n\t\tfor (int i = a; i < n; i |= i + 1)node[i] += w;\n\t}\n\t//[0,a)\n\tll sum(int a) {\n\t\tll ret = 0;\n\t\tfor (int i = a - 1; i >= 0; i = (i&(i + 1)) - 1)ret += node[i];\n\t\treturn ret;\n\t}\n\t//[a,b)\n\tll sum(int a, int b) {\n\t\treturn sum(b) - sum(a);\n\t}\n};\n\nvoid solve() {\n\tint n, k; cin >> n >> k;\n\tvector<int> p(n);\n\trep(i, n) {\n\t\tcin >> p[i];\n\t}\n\tif (n == k) {\n\t\trep(i, n) {\n\t\t\tif (p[i] == 1) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tint id = (i + j) % n;\n\t\t\t\t\tif (p[id] != 1 + j) {\n\t\t\t\t\t\tcout << \"No\" << endl; return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << \"Yes\" << endl;\n\t\treturn;\n\t}\n\tif (k % 2 == 0) {\n\t\tcout << \"Yes\" << endl;\n\t}\n\telse {\n\t\tBIT b(n + 1);\n\t\tll num = 0;\n\t\trep(i, n) {\n\t\t\tnum += i - b.sum(p[i]);\n\t\t\tb.add(p[i],1);\n\t\t}\n\t\tif (num % 2 == 0) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\n\t\t}\n\t}\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nstruct BIT {\n    int n;\n    vector<T> dat;\n\n    BIT(int n=0){\n        initialize(n);\n    }\n\n    void initialize(int nin){\n        n = nin;\n        dat.resize(n, 0);\n    }\n\n    T sum(int i){\n        T s = 0;\n        while(i >= 0){\n            s += dat[i];\n            i = (i & (i+1)) - 1;\n        }\n        return s;\n    }\n\n    T sum_between(int i, int j){\n        return sum(j) - sum(i-1);\n    }\n\n    void plus(int i, T x){\n        while(i < n){\n            dat[i] += x;\n            i |= i+1;\n        }\n    }\n\n    // a[0]+...+a[ret] >= x\n    int lower_bound(T x){\n        int ret = -1;\n        int k = 1;\n        while(2*k <= n) k <<= 1;\n        for( ;k>0; k>>=1){\n            if(ret+k < n && dat[ret+k] < x){\n                x -= dat[ret+k];\n                ret += k;\n            }\n        }\n        return ret + 1;\n    }\n};\n\nint main() {\n    int N, K, P[100000];\n    cin >> N >> K;\n    for(int i=0; i<N; i++) cin >> P[i];\n\n    bool ok = true;\n    if(K == N){\n        for(int i=0; i<N; i++) if((N+P[(i+1)%N]-P[i])%N != 1) ok = false;\n    }else{\n        int64_t s = 0;\n        BIT<int> bit(N+1);\n        for(int i=0; i<N; i++){\n            s += bit.sum_between(P[i], N);\n            bit.plus(P[i], 1);\n        }\n        ok = !(K%2) || !(s%2);\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint a[100010];\nvoid dfs(int n){\n\tint t=a[n];\n\twhile(a[t]!=-1){\n\t\tint temp=a[t];\n\t\ta[t]=-1;\n\t\tt=temp;\n\t}\n\treturn;\n}\nint main(){\n\tint n,k;\n\tscanf(\"%d%d\",&n,&k);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tif(n==k){\n\t\tint x=a[1]-1;\n\t\tint flag=1;\n\t\tfor(int i=1;i<=n;i++)flag&=(a[i]-i+n)%n==x;\n\t\tputs(flag?\"Yes\":\"No\");\n\t}else{\n\t\tint cnt=0;\n\t\tfor(int i=1;i<=n;i++)if(a[i]!=-1)dfs(i),cnt++;\n\t\tputs((n-cnt)%2&&k%2?\"No\":\"Yes\");\n\t}\n}\n\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n\ndef solve():\n    def add(i):\n        while i <= n:\n            bit[i] += 1\n            i += i&-i\n\n    def sum(i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i&-i\n        return res\n    n,k = LI()\n    p = LI()\n    if n > k:\n        if k%2 == 0:\n            print(\"Yes\")\n        else:\n            a = 0\n            bit = [0]*(n+1)\n            for i in range(n):\n                a ^= (i-sum(p[i]))&1\n                add(p[i])\n            if a:\n                print(\"No\")\n            else:\n                print(\"Yes\")\n        return\n\n    else:\n        for i in range(n):\n            if p[i] == 1:\n                break\n        for j in range(n):\n            if p[(j+i)%n] != j+1:\n                print(\"No\")\n                return\n        print(\"Yes\")\n    return\n\n\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nfn calc_inversion(a: &mut [u32]) -> usize {\n    if a.len() == 1 {\n        return 0;\n    }\n    let n = a.len();\n    let m = n / 2;\n    let mut ans = calc_inversion(&mut a[0..m]);\n    ans ^= calc_inversion(&mut a[m..n]);\n    let mut i = 0;\n    let mut j = m;\n    let mut b = vec![];\n    while i < m && j < n {\n        if a[i] <= a[j] {\n            b.push(a[i]);\n            i += 1;\n        } else {\n            ans ^= m - i;\n            b.push(a[j]);\n            j += 1;\n        }\n    }\n    while i < m {\n        b.push(a[i]);\n        i += 1;\n    }\n    for i in 0..b.len() {\n        a[i] = b[i];\n    }\n    ans\n}\n\nfn run() {\n    input! {\n        n: usize,\n        k: usize,\n        p: [u32; n],\n    }\n    if k < n {\n        if k % 2 == 0 {\n            println!(\"Yes\");\n            return;\n        }\n        let mut a = p.clone();\n        if calc_inversion(&mut a) % 2 != 0 {\n            println!(\"No\");\n        } else {\n            println!(\"Yes\");\n        }\n        return;\n    }\n    let mut a = vec![0; 2 * n];\n    for i in 0..n {\n        a[i] = p[i];\n        a[i + n] = p[i];\n    }\n    let mut cnt = vec![0; 2 * n + 1];\n    for i in 0..(2 * n - 1) {\n        if a[i] > a[i + 1] {\n            cnt[i] = 1;\n        }\n    }\n    for i in (0..(2 * n - 1)).rev() {\n        cnt[i] += cnt[i + 1];\n    }\n    for i in 0..n {\n        if cnt[i] == cnt[i + n - 1] {\n            println!(\"Yes\");\n            return;\n        }\n    }\n    println!(\"No\");\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]