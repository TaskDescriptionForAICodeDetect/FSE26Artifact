[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    int u, v;\n    double length;\n} Edge;\n\nint parent[1000];\n\nint find(int u) {\n    if (parent[u] != u)\n        parent[u] = find(parent[u]);\n    return parent[u];\n}\n\nvoid union_set(int u, int v) {\n    int root_u = find(u);\n    int root_v = find(v);\n    if (root_u != root_v)\n        parent[root_v] = root_u;\n}\n\nint compare(const void *a, const void *b) {\n    Edge *edgeA = (Edge *)a;\n    Edge *edgeB = (Edge *)b;\n    if (edgeA->length < edgeB->length) return -1;\n    if (edgeA->length > edgeB->length) return 1;\n    return 0;\n}\n\ndouble kruskal(Edge edges[], int M, int N) {\n    for (int i = 0; i < N; i++)\n        parent[i] = i;\n    \n    qsort(edges, M, sizeof(Edge), compare);\n    \n    double total = 0.0;\n    for (int i = 0; i < M; i++) {\n        int u = edges[i].u;\n        int v = edges[i].v;\n        if (find(u) != find(v)) {\n            union_set(u, v);\n            total += edges[i].length;\n        }\n    }\n    return total;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n    \n    Point points[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n    \n    Edge edges[M];\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        double dx = points[u].x - points[v].x;\n        double dy = points[u].y - points[v].y;\n        edges[i].u = u;\n        edges[i].v = v;\n        edges[i].length = sqrt(dx * dx + dy * dy);\n    }\n    \n    double min_holy_water = kruskal(edges, M, N);\n    printf(\"%.2lf\\n\", min_holy_water);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\ndouble calculateDistance(const Point& a, const Point& b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<Point> points(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n    \n    double totalLength = 0.0;\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b; // converting to 0-based index\n        totalLength += calculateDistance(points[a], points[b]);\n    }\n    \n    cout << fixed << setprecision(6) << totalLength << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n    int u, v;\n    double weight;\n\n    public Edge(int u, int v, double weight) {\n        this.u = u;\n        this.v = v;\n        this.weight = weight;\n    }\n\n    @Override\n    public int compareTo(Edge other) {\n        return Double.compare(this.weight, other.weight);\n    }\n}\n\nclass DisjointSet {\n    int[] parent;\n    int[] rank;\n\n    public DisjointSet(int size) {\n        parent = new int[size];\n        rank = new int[size];\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX == rootY) return;\n\n        if (rank[rootX] < rank[rootY]) {\n            parent[rootX] = rootY;\n        } else if (rank[rootX] > rank[rootY]) {\n            parent[rootY] = rootX;\n        } else {\n            parent[rootY] = rootX;\n            rank[rootX]++;\n        }\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        double[][] piles = new double[N][2];\n        for (int i = 0; i < N; i++) {\n            piles[i][0] = scanner.nextDouble();\n            piles[i][1] = scanner.nextDouble();\n        }\n\n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt() - 1;\n            int v = scanner.nextInt() - 1;\n            double dx = piles[u][0] - piles[v][0];\n            double dy = piles[u][1] - piles[v][1];\n            double weight = Math.sqrt(dx * dx + dy * dy);\n            edges.add(new Edge(u, v, weight));\n        }\n\n        Collections.sort(edges);\n\n        DisjointSet ds = new DisjointSet(N);\n        double total = 0.0;\n\n        for (Edge edge : edges) {\n            if (ds.find(edge.u) != ds.find(edge.v)) {\n                ds.union(edge.u, edge.v);\n                total += edge.weight;\n            }\n        }\n\n        System.out.printf(\"%.2f\\n\", total);\n    }\n}",
    "timestamp": "2025-08-05 21:16:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CatRescue {\n    static class Edge implements Comparable<Edge> {\n        int u, v;\n        double weight;\n        \n        Edge(int u, int v, double weight) {\n            this.u = u;\n            this.v = v;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Double.compare(this.weight, other.weight);\n        }\n    }\n    \n    static int[] parent;\n    \n    static int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n    \n    static void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX != rootY) {\n            parent[rootX] = rootY;\n        }\n    }\n    \n    public static double minimumHolyWater(int N, int[][] piles, int M, int[][] fences) {\n        parent = new int[N];\n        for (int i = 0; i < N; i++) {\n            parent[i] = i;\n        }\n        \n        List<Edge> edges = new ArrayList<>();\n        \n        for (int[] fence : fences) {\n            int u = fence[0], v = fence[1];\n            double dist = Math.sqrt(\n                Math.pow(piles[u][0] - piles[v][0], 2) + \n                Math.pow(piles[u][1] - piles[v][1], 2)\n            );\n            edges.add(new Edge(u, v, dist));\n        }\n        \n        Collections.sort(edges);\n        \n        double totalHolyWater = 0;\n        int edgesUsed = 0;\n        \n        for (Edge edge : edges) {\n            if (find(edge.u) != find(edge.v)) {\n                union(edge.u, edge.v);\n                totalHolyWater += edge.weight;\n                edgesUsed++;\n                \n                if (edgesUsed == N - 1) break;\n            }\n        }\n        \n        return totalHolyWater;\n    }\n    \n    public static void main(String[] args) {\n        int N = 4;\n        int[][] piles = {{0,0}, {1,1}, {2,2}, {3,3}};\n        int M = 5;\n        int[][] fences = {{0,1}, {1,2}, {2,3}, {3,0}, {0,2}};\n        \n        System.out.println(minimumHolyWater(N, piles, M, fences));\n    }\n}",
    "timestamp": "2025-08-05 21:16:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_PILES 1000\n\ntypedef struct {\n    int x, y;\n} Pile;\n\ntypedef struct {\n    int u, v;\n    double length;\n} Fence;\n\nint parent[MAX_PILES];\n\ndouble distance(Pile a, Pile b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint find(int x) {\n    if (parent[x] == x) return x;\n    return parent[x] = find(parent[x]);\n}\n\nvoid unionSet(int x, int y) {\n    parent[find(x)] = find(y);\n}\n\nint compareFence(const void* a, const void* b) {\n    Fence* f1 = (Fence*)a;\n    Fence* f2 = (Fence*)b;\n    return (f1->length > f2->length) - (f1->length < f2->length);\n}\n\ndouble minimumHolyWater(Pile* piles, Fence* fences, int n, int m) {\n    for (int i = 0; i < n; i++) parent[i] = i;\n    \n    qsort(fences, m, sizeof(Fence), compareFence);\n    \n    double totalLength = 0;\n    int edgesUsed = 0;\n    \n    for (int i = 0; i < m; i++) {\n        int u = fences[i].u;\n        int v = fences[i].v;\n        \n        if (find(u) != find(v)) {\n            unionSet(u, v);\n            totalLength += fences[i].length;\n            edgesUsed++;\n            \n            if (edgesUsed == n - 1) break;\n        }\n    }\n    \n    return totalLength;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    Pile piles[MAX_PILES];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &piles[i].x, &piles[i].y);\n    }\n    \n    Fence fences[MAX_PILES * MAX_PILES];\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        fences[i].u = u;\n        fences[i].v = v;\n        fences[i].length = distance(piles[u], piles[v]);\n    }\n    \n    double result = minimumHolyWater(piles, fences, n, m);\n    printf(\"%.2f\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nclass UnionFind {\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n\npublic:\n    UnionFind(int n) {\n        parent.resize(n);\n        rank.resize(n, 0);\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n        }\n    }\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    bool unionSet(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        \n        if (rootX == rootY) return false;\n        \n        if (rank[rootX] < rank[rootY]) {\n            swap(rootX, rootY);\n        }\n        \n        parent[rootY] = rootX;\n        \n        if (rank[rootX] == rank[rootY]) {\n            rank[rootX]++;\n        }\n        \n        return true;\n    }\n};\n\nstruct Edge {\n    int from;\n    int to;\n    double length;\n    \n    Edge(int f, int t, double l) : from(f), to(t), length(l) {}\n    \n    bool operator<(const Edge& other) const {\n        return length < other.length;\n    }\n};\n\ndouble calculateDistance(pair<int,int>& a, pair<int,int>& b) {\n    return sqrt(pow(a.first - b.first, 2.0) + pow(a.second - b.second, 2.0));\n}\n\ndouble minimumHolyWater(vector<pair<int,int>>& piles, vector<pair<int,int>>& fences) {\n    int n = piles.size();\n    vector<Edge> edges;\n    \n    // Create edges between all piles\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            double dist = calculateDistance(piles[i], piles[j]);\n            edges.push_back(Edge(i, j, dist));\n        }\n    }\n    \n    // Add fence lengths\n    for (auto& fence : fences) {\n        double dist = calculateDistance(piles[fence.first], piles[fence.second]);\n        edges.push_back(Edge(fence.first, fence.second, dist));\n    }\n    \n    // Sort edges\n    sort(edges.begin(), edges.end());\n    \n    // Kruskal's algorithm\n    UnionFind uf(n);\n    double totalLength = 0;\n    \n    for (auto& edge : edges) {\n        if (uf.unionSet(edge.from, edge.to)) {\n            totalLength += edge.length;\n        }\n    }\n    \n    return totalLength;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    \n    vector<pair<int,int>> piles(N);\n    for (int i = 0; i < N; i++) {\n        cin >> piles[i].first >> piles[i].second;\n    }\n    \n    vector<pair<int,int>> fences(M);\n    for (int i = 0; i < M; i++) {\n        cin >> fences[i].first >> fences[i].second;\n    }\n    \n    cout << fixed << setprecision(2) << minimumHolyWater(piles, fences) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:17:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_holy_water(N, piles, M, fences):\n    parent = list(range(N))\n\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n\n    def union(x, y):\n        rootX = find(x)\n        rootY = find(y)\n        if rootX != rootY:\n            parent[rootY] = rootX\n            return True\n        return False\n\n    edges = []\n    for a, b in fences:\n        x1, y1 = piles[a]\n        x2, y2 = piles[b]\n        length = ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n        edges.append((length, a, b))\n\n    edges.sort()\n    total_cost = 0\n\n    for length, a, b in edges:\n        if union(a, b):\n            total_cost += length\n\n    return total_cost\n\n# Example input\nN = 5\npiles = [(0, 0), (2, 2), (3, 3), (5, 1), (6, 0)]\nM = 3\nfences = [(0, 1), (1, 2), (3, 4)]\n\n# Function call\nprint(min_holy_water(N, piles, M, fences))",
    "timestamp": "2025-08-13 05:46:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MagicalFences {\n    private static class Edge implements Comparable<Edge> {\n        int u, v;\n        double weight;\n        \n        public Edge(int u, int v, double weight) {\n            this.u = u;\n            this.v = v;\n            this.weight = weight;\n        }\n        \n        public int compareTo(Edge other) {\n            return Double.compare(this.weight, other.weight);\n        }\n    }\n    \n    private static class UnionFind {\n        private int[] parent;\n        private int[] rank;\n        \n        public UnionFind(int size) {\n            parent = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n        \n        public int find(int u) {\n            if (parent[u] != u) {\n                parent[u] = find(parent[u]);\n            }\n            return parent[u];\n        }\n        \n        public boolean union(int u, int v) {\n            int rootU = find(u);\n            int rootV = find(v);\n            if (rootU == rootV) {\n                return false;\n            }\n            if (rank[rootU] > rank[rootV]) {\n                parent[rootV] = rootU;\n            } else if (rank[rootU] < rank[rootV]) {\n                parent[rootU] = rootV;\n            } else {\n                parent[rootV] = rootU;\n                rank[rootU]++;\n            }\n            return true;\n        }\n    }\n    \n    public static double calculateMinimumHolyWater(int[][] coordinates, int[][] fences) {\n        int N = coordinates.length;\n        int M = fences.length;\n        \n        List<Edge> edges = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            int u = fences[i][0];\n            int v = fences[i][1];\n            double distance = Math.sqrt(\n                    Math.pow(coordinates[u][0] - coordinates[v][0], 2) +\n                    Math.pow(coordinates[u][1] - coordinates[v][1], 2)\n            );\n            edges.add(new Edge(u, v, distance));\n        }\n        \n        Collections.sort(edges);\n        \n        UnionFind uf = new UnionFind(N);\n        double totalWeight = 0;\n        \n        for (Edge edge : edges) {\n            if (uf.union(edge.u, edge.v)) {\n                totalWeight += edge.weight;\n            }\n        }\n        \n        return totalWeight;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int[][] coordinates = new int[N][2];\n        for (int i = 0; i < N; i++) {\n            coordinates[i][0] = scanner.nextInt();\n            coordinates[i][1] = scanner.nextInt();\n        }\n\n        int M = scanner.nextInt();\n        int[][] fences = new int[M][2];\n        for (int i = 0; i < M; i++) {\n            fences[i][0] = scanner.nextInt();\n            fences[i][1] = scanner.nextInt();\n        }\n\n        double minimumHolyWater = calculateMinimumHolyWater(coordinates, fences);\n        System.out.println(minimumHolyWater);\n    }\n}",
    "timestamp": "2025-08-13 05:46:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// Structure to represent a pile with its x and y coordinates\ntypedef struct {\n    int x, y;\n} Pile;\n\n// Structure to represent a fence with two end piles and its length\ntypedef struct {\n    int u, v;\n    double length;\n} Fence;\n\n// Function to compare fences based on their length for sorting\nint compareFences(const void *a, const void *b) {\n    Fence *fenceA = (Fence *)a;\n    Fence *fenceB = (Fence *)b;\n    if (fenceA->length > fenceB->length) return 1;\n    else if (fenceA->length < fenceB->length) return -1;\n    else return 0;\n}\n\n// Function to find the parent of a node in the disjoint set\nint find(int parent[], int i) {\n    if (parent[i] == i) return i;\n    return parent[i] = find(parent, parent[i]);\n}\n\n// Function to unify two subsets into a single subset\nvoid unionSets(int parent[], int rank[], int u, int v) {\n    int rootU = find(parent, u);\n    int rootV = find(parent, v);\n    if (rank[rootU] < rank[rootV]) {\n        parent[rootU] = rootV;\n    } else if (rank[rootU] > rank[rootV]) {\n        parent[rootV] = rootU;\n    } else {\n        parent[rootV] = rootU;\n        rank[rootU]++;\n    }\n}\n\n// Function to calculate the Euclidean distance between two piles\ndouble calculateDistance(Pile a, Pile b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    Pile piles[N];\n    Fence fences[M];\n    \n    // Reading pile coordinates\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &piles[i].x, &piles[i].y);\n    }\n    \n    // Reading fence endpoints and calculating their lengths\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--, v--; // Adjusting to zero-based indexing\n        fences[i].u = u;\n        fences[i].v = v;\n        fences[i].length = calculateDistance(piles[u], piles[v]);\n    }\n    \n    // Sorting fences by length\n    qsort(fences, M, sizeof(Fence), compareFences);\n    \n    // Kruskal's algorithm to find the minimum spanning tree of the graph\n    int parent[N], rank[N];\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n    \n    double minHolyWater = 0.0;\n    for (int i = 0; i < M; i++) {\n        int u = fences[i].u;\n        int v = fences[i].v;\n        \n        if (find(parent, u) != find(parent, v)) {\n            minHolyWater += fences[i].length;\n            unionSets(parent, rank, u, v);\n        }\n    }\n    \n    // Output the total minimum holy water required\n    printf(\"%.2lf\\n\", minHolyWater);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:46:39"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_holy_water(N, piles, M, fences):\n    # Calculate distances between piles\n    def distance(p1, p2):\n        return ((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)**0.5\n    \n    # Initialize disjoint set data structure\n    parent = list(range(N))\n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(x, y):\n        px, py = find(x), find(y)\n        if px != py:\n            parent[px] = py\n            return True\n        return False\n    \n    # Sort fences by length\n    fence_lengths = []\n    for i in range(M):\n        start, end = fences[i]\n        fence_length = distance(piles[start], piles[end])\n        fence_lengths.append((fence_length, start, end))\n    fence_lengths.sort()\n    \n    # Kruskal's algorithm for minimum spanning tree\n    total_holy_water = 0\n    for length, start, end in fence_lengths:\n        if union(start, end):\n            total_holy_water += length\n    \n    return total_holy_water",
    "timestamp": "2025-08-13 05:46:53"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    piles = []\n    for _ in range(N):\n        x = float(data[idx])\n        y = float(data[idx + 1])\n        piles.append((x, y))\n        idx += 2\n    \n    M = int(data[idx])\n    idx += 1\n    total_length = 0.0\n    for _ in range(M):\n        a = int(data[idx]) - 1\n        b = int(data[idx + 1]) - 1\n        idx += 2\n        x1, y1 = piles[a]\n        x2, y2 = piles[b]\n        dx = x2 - x1\n        dy = y2 - y1\n        length = math.sqrt(dx * dx + dy * dy)\n        total_length += length\n    \n    print(\"{0:.3f}\".format(total_length))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:47:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    double length;\n    Edge(int u, int v, double length) : u(u), v(v), length(length) {}\n};\n\nint find(int u, vector<int>& parent) {\n    if (u != parent[u])\n        parent[u] = find(parent[u], parent);\n    return parent[u];\n}\n\nvoid unite(int u, int v, vector<int>& parent, vector<int>& rank) {\n    int rootU = find(u, parent);\n    int rootV = find(v, parent);\n    if (rootU != rootV) {\n        if (rank[rootU] > rank[rootV])\n            parent[rootV] = rootU;\n        else if (rank[rootU] < rank[rootV])\n            parent[rootU] = rootV;\n        else {\n            parent[rootV] = rootU;\n            rank[rootU]++;\n        }\n    }\n}\n\ndouble kruskal(int n, vector<Edge>& edges) {\n    sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b) {\n        return a.length < b.length;\n    });\n\n    vector<int> parent(n + 1);\n    iota(parent.begin(), parent.end(), 0);\n    vector<int> rank(n + 1, 0);\n\n    double total_cost = 0.0;\n    for (const Edge& edge : edges) {\n        if (find(edge.u, parent) != find(edge.v, parent)) {\n            total_cost += edge.length;\n            unite(edge.u, edge.v, parent, rank);\n        }\n    }\n\n    return total_cost;\n}\n\ndouble distance(int x1, int y1, int x2, int y2) {\n    return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<pair<int, int>> piles(N + 1);\n    for (int i = 1; i <= N; i++) {\n        cin >> piles[i].first >> piles[i].second;\n    }\n\n    vector<Edge> edges;\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        double dist = distance(piles[u].first, piles[u].second, piles[v].first, piles[v].second);\n        edges.emplace_back(u, v, dist);\n    }\n\n    cout.precision(10);\n    cout << fixed << kruskal(N, edges) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:28:00"
  }
]