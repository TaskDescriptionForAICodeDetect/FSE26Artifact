[
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 10000005\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tmemset(used,0,sizeof used);\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < M; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0) {\n\tif(links[i].node1 == forest[j][k]) {\n\t  t1 = j;\n\t} else if(links[i].node2 == forest[j][k]) {\n\t  t2 = j;\n\t}\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N; j++)\n\tif(forest[t1][j] == 0)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\nstruct edge{\n    int to;double cost;\n    edge(int a,double b):to(a),cost(b){}\n    edge(){}\n    bool operator<(const edge &d)const{\n        return cost<d.cost;\n    }\n};\nint main(){\n    int n,m;\n    cin>>n>>m;\n    int x[10000],y[10000];\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n\n    vector<vector<edge> >V(n);\n    double sum=0;\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;a--;b--;\n        double dis=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n        sum+=dis;\n        V[a].push_back(edge(b,dis));\n        V[b].push_back(edge(a,dis));\n    }\n    bool used[10000];fill(used,used+10000,false);\n    double res=0;\n    priority_queue<edge>Q;\n    for(int i=0;i<n;i++)Q.push(edge(i,0));\n    while(Q.size()){\n        int to=Q.top().to;double cost=Q.top().cost;\n        Q.pop();\n        if(used[to])continue;\n        used[to]=true;\n        res+=cost;\n        for(int i=0;i<V[to].size();i++){\n            Q.push(V[to][i]);\n        }\n    }\n    cout<<fixed<<sum-res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 100000000;\nusing namespace std;\n\n\nclass Edge {\n    public:\n        int to;\n        double cost;\n        Edge(int to, double cost) : to(to), cost(cost) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble prim(const Graph &g, vector<bool> &visited, int s) {\n    int n = g.size();\n    double total = 0;\n\n    //priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n    priority_queue<pair<double, int> > q;\n\n    q.push(make_pair(0,s));\n    while (not q.empty()) {\n        pair<double, int> u = q.top(); q.pop();\n        if (visited[u.second]) continue;\n        total += u.first;\n        visited[u.second] = true;\n        for(auto it : g[u.second]) {\n            if (not visited[it.to]) q.push(make_pair(it.cost, it.to));\n        }\n    }\n    return total;\n}\n\nint main(){\n    complex<double> p[10005];\n    int n, m;\n    cin >> n >> m;\n    rep(i,n){\n        double a, b;\n        cin >> a >> b;\n        p[i] = complex<double>(a,b);\n    }\n\n    Graph g(n);\n    vector<bool> visited(n, 0);\n    double sum = 0;\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n\n        double cost = abs(p[a] - p[b]);\n        g[a].emplace_back(b, abs(cost));\n        g[b].emplace_back(a, abs(cost));\n        sum += cost;\n    }\n\n    double usedsum = 0;\n    rep(i,n){\n        if(visited[i] == 0){\n        //cout << endl; rep(i,n) show(visited[i])\n            usedsum += prim(g, visited, i);\n        }\n    }\n    cout << fixed << setprecision(5) <<  sum - usedsum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct edge{\n    int u,v;\n    double cost;\n    edge(int a,int b,double c):u(a),v(b),cost(c){}\n    edge(){}\n    bool operator<(const edge &d)const{\n        return cost<d.cost;\n    }\n};\nint uf_par[10000],uf_rank[10000];\nvoid uf_init(int n){\n    for(int i=0;i<n;i++){\n        uf_par[i]=i;\n        uf_rank[i]=0;\n    }\n}\nint uf_find(int x){\n    return (uf_par[x]==x)?(x):(uf_par[x]=uf_find(uf_par[x]));\n}\nvoid uf_unite(int x,int y){\n    x=uf_find(x);\n    y=uf_find(y);\n    if(x==y)return;\n\n    if(uf_rank[x]<uf_rank[y])uf_par[y]=x;\n    else{\n        uf_par[x]=y;\n        if(uf_rank[x]==uf_rank[y])uf_rank[x]++;\n    }\n}\nbool uf_same(int x,int y){\n    return uf_find(x)==uf_find(y);\n}\nint main(){\n    int x[10000],y[10000];\n    int n,m;\n    vector<edge>es;\n    double sum=0.0,res=0.0;\n    cin>>n>>m;\n    uf_init(n);\n    es.resize(m);\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        double dis=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n        es[i]=edge(a,b,-dis);\n        sum+=dis;\n    }\n    sort(es.begin(),es.end());\n    for(int i=0;i<m;i++){\n        edge e=es[i];\n        if(uf_same(e.u,e.v))continue;\n        uf_unite(e.u,e.v);\n        res+=e.cost;\n    };\n    cout<<fixed<<sum+res<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n\nstruct edge { int u, v; double cost; };\nconst int MAXN = 10000 + 16;\nconst int MAXM = MAXN << 1;\n\nint N, M, x[MAXN], y[MAXN];\nedge es[MAXM];\n\nint p[MAXN];\nvoid init_union_find(int N) {\n    for (int i = 0; i <= N; i++) {\n        p[i] = i;\n    }\n}\nint find(int i) {\n    if (p[i] != i) p[i] = find(p[i]);\n    return p[i];\n}\nint unite(int i, int j) {\n    p[find(i)] = p[find(j)];\n}\n\nbool cmp(const edge & e1, const edge & e2) {\n    return e1.cost < e2.cost;\n}\n\nint main() {\n    //freopen(\"2224-in1.txt\", \"r\", stdin);\n    cin >> N >> M;\n    for (int i = 1; i <= N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    edge e;\n    for (int i = 0; i < M; i++) {\n        cin >> e.u >> e.v;\n        e.cost = sqrt(sqr(x[e.u]-x[e.v]) + sqr(y[e.u]-y[e.v]));\n        es[i] = e;\n    }\n    init_union_find(N);\n    sort(es, es + M, cmp);\n    double result = 0;\n    for (int i = M - 1; i >= 0; i--) { // descending\n        int u = es[i].u, v = es[i].v;\n        if (find(u) != find(v)) {\n            unite(u, v);\n        } else {\n            result += es[i].cost;\n        }\n    }\n    cout << fixed << setprecision(4) << result << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\nusing Float = double;\nusing Point = complex<Float>;\n\nstruct UnionFind{\n\tvector<int> rnk,par;\n\n\tUnionFind(int sz) : rnk(sz,0),par(sz){\n\t\tfor(int i = 0;i < sz;i++) par[i] = i;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\tif(rnk[x] < rnk[y]) swap(x,y);\n\t\tpar[y] = x;\n\t\tif(rnk[x] == rnk[y]) rnk[x]++;\n\t}\n\t\n\tbool same(int x,int y){\n\t\treturn (find(x) == find(y));\n\t}\n};\n\ntemplate <class T>\nT kruskal(int n,vector<Edge<T>> &edges){\n\tT ret = 0;\n\tsort(edges.begin(),edges.end(),[](const Edge<T> &e1,const Edge<T> &e2){\n\t\treturn e1.cost < e2.cost;\n\t});\n\tUnionFind uf(n);\n\tfor(const Edge<T> &e : edges){\n\t\tif(!uf.same(e.from,e.to)){\n\t\t\tret += e.cost;\n\t\t\tuf.unite(e.from,e.to);\n\t\t}\n\t}\n\treturn ret;\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tPoint ps[10010];\n\tvector<Edge<double>> es;\n\tfor(int i = 0;i < n;i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tps[i] = Point(x,y);\n\t}\n\tdouble sum = 0;\n\tfor(int i = 0;i < m;i++){\n\t\tint p,q;\n\t\tcin >> p >> q; p--;q--;\n\t\tes.emplace_back(p,q,-abs(ps[p] - ps[q]));\n\t\tsum += abs(ps[p] - ps[q]);\n\t}\n\tprintf(\"%.14lf\\n\",sum + kruskal(n,es));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ndouble zero(double d) {\n    return d < EPS ? 0.0 : d;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    return os << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    rep(i, a.size()) os << (i ? \" \" : \"\") << a[i];\n    return os << ']';\n}\n\n// to avoid error on mingw\nstring toString(int i) {\n    stringstream ss;\n    ss << i;\n    return ss.str();\n}\n\nconst int MOD = 1000000007;\n// a^k\nll fpow(ll a, ll k, int M) {\n    ll res = 1ll;\n    ll x = a;\n    while (k != 0) {\n        if ((k & 1) == 1)\n            res = (res * x) % M;\n        x = (x * x) % M;\n        k >>= 1;\n    }\n    return res;\n}\n\nclass UnionFind {\nprivate:\n    vi par;\n    vi rank;\n\n    int find(int x) {\n        if(par[x] == x)\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\npublic:\n    UnionFind(int n) {\n        rep(i,n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n\n        if(rank[x] < rank[y])\n            par[x] = y;\n        else {\n            par[y] = x;\n            if(rank[x] == rank[y])\n                rank[x]++;\n        }\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\n\n\nstruct edge {int from, to; double cost;};\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\nll twice(int t) {return t*t;}\n\nint main() {\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(8);\n    ios_base::sync_with_stdio(false);\n\n    int N, M;\n    cin >> N >> M;\n\n    vector< pii > piles(N);\n    rep(i, N)\n        cin >> piles[i].first >> piles[i].second;\n\n    vector<edge> edges(M);\n    double totalCost = 0.0;\n    rep(i, M) {\n        int p, q;\n        cin >> p >> q;\n        --p, --q;\n        double cost = sqrt( twice(piles[p].first - piles[q].first) + twice(piles[p].second - piles[q].second) );\n        edges[i] = edge{ p, q, -cost };\n        totalCost += cost;\n    }\n\n    // kruscal\n    sort(all(edges), comp);\n    UnionFind uf(N);\n\n    double res = 0;\n\n    tr(it, edges) {\n        if(!uf.same(it->from, it->to)) {\n            uf.unite(it->from, it->to);\n            cerr << it->cost << endl;\n            res += it->cost;\n        }\n    }\n\n    cerr << totalCost - (-res) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\n// double kruskal(){\n// \tsort(es,es+E);\n// \tinit(V);\n// \tdouble res = 0;\n// \tfor(int i=0; i<E; i++){\n// \t\tedge e = es[i];\n// \t\tif(!same(e.u,e.v))\n// \t\t\tunite(e.u,e.v);\n// \t\telse\n// \t\t\tres += e.cost;\n// \t}\n\n// \treturn res;\n// }\ndouble kruskal()\n{\n\tsort(es, es + E);    // ?????§??????????°???°??§??????\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n\nint main(int argc, char *argv[])\n{\n\tcin >> V >> E;\n\t\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tcin >> pile[i].first >> pile[i].second;\n\t}\n \n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t}\n \n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout << kruskal() << endl;\n\treturn 0;\n}\n// int main(){\n// \tscanf(\"%d%d\",&V,&E);\n// \tfor(int i=0; i<V; i++)\n// \t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n// \tfor(int i=0; i<E; i++){\n// \t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n// \t\t--es[i].u,--es[i].v;\n// \t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n// \t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n// \t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n// \t}\n\n// \tprintf(\"%.3lf\\n\",kruskal());\n// }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define N 10005\n#define P pair<int,int>\n#define ll long long\n#define mk(a, b) make_pair(a, b)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\nint inf = 0x3f3f3f3f;\nint n, m, pre[N];\n\nstruct ac{\n\tint u, v;\n\tdouble c;\n\tbool operator < (const ac &x)const {\n\t\treturn c > x.c;\n\t}\n};\nvector<P> a(N);\nvector<ac> g;\nvoid init() {\n\tfor (int i = 1; i <N; ++i) {\n\t\tpre[i] = i;\n\t}\n}\nint find(int x) {\n\tif (x == pre[x])\treturn x;\n\telse \treturn pre[x] = find(pre[x]);\n}\nbool join(int x, int y) {\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy)\treturn false;\n\telse if (fx < fy)\tpre[fy] = fx;\n\telse \tpre[fx] = fy;\n\treturn true;\n}\ndouble rm() {\n\tdouble sum = 0;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tac t = g[i];\n\t\tif (join(t.u, t.v))\tsum += t.c;\n\t}\n\treturn sum;\n\n}\n\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m) {\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tint dx = a[u].first - a[v].first;\n\t\t\tint dy = a[u].second - a[v].second;\n\t\t\tdouble temp = sqrt(dx * dx + dy * dy);\n\t\t\tans += temp;\n\t\t\tg.push_back((ac){u, v, temp});\n\t\t}\n\t\tsort(g.begin(), g.end());\n\t\tans -= rm();\n\n\n\t\tprintf(\"%.3lf\\n\",ans);\n\t\tg.clear();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\n/***********************/\n// ??±?????¨???\n/***********************/\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntypedef double Weight;\n\nstruct Edge {\n    ll src, dst;\n    Weight weight;\n    Edge(ll src, ll dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight < f.weight;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid addDirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); }\nvoid addUndirected(Graph& g, ll src, ll dst, Weight weight) { assert(src < g.size() && src >= 0 && dst < g.size() && dst >= 0); g[src].push_back(Edge(src, dst, weight)); g[dst].push_back(Edge(dst, src, weight)); }\nvoid addDirected(Graph& g, ll src, ll dst) { addDirected(g, src, dst, 1); }\nvoid addUndirected(Graph& g, ll src, ll dst) { addUndirected(g, src, dst, 1); }\n\nvoid printGraph(Graph& g) {\n    rep(i, g.size()) {\n        if (!g[i].size())\n            continue;\n        rep(j, g[i].size()) \n            cout << \"(\" << i << \", \" << g[i][j].dst << \"), \";\n        cout << endl;\n    }\n}\n\nstruct UnionFind {\n    vector<ll> data;\n    UnionFind(ll size) : data(size, -1) { }\n    bool unionSet(ll x, ll y) {\n        x = root(x); y = root(y);\n        if (x != y) { if (data[y] < data[x]) swap(x, y); data[x] += data[y]; data[y] = x; }\n        return x != y;\n    }\n    bool findSet(ll x, ll y) { return root(x) == root(y); }\n    ll root(ll x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    ll size(ll x) { return -data[root(x)]; }\n};\n\n// Kruskal\n// O(E log V + A(r) E)\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n    ll n = g.size();\n    UnionFind uf(n);\n    priority_queue<Edge> Q;\n    rep(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n    Weight total = 0;\n    Edges F;\n    while (F.size() < n-1 && !Q.empty()) {\n        Edge e = Q.top(); Q.pop();\n        if (uf.unionSet(e.src, e.dst)) {\n            F.push_back(e);\n            total += e.weight;\n        }\n    }\n    return pair<Weight, Edges>(total, F);\n}\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll n, m; cin >> n >> m;\n    vector<long double> x(n), y(n);\n    Graph g(n);\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n    }\n    double sum = 0;\n    rep(i, m) {\n        ll u, v; cin >> u >> v; u--, v--;\n        double tmp = sqrt(pow(x[u]-x[v], 2) + pow(y[u]-y[v], 2));\n        addUndirected(g, u, v, sqrt(pow(x[u]-x[v], 2) + pow(y[u]-y[v], 2)));\n//        cout << tmp << \"dist\" <<endl;\n        sum += tmp;\n    }\n    pair<Weight, Edges> ret = minimumSpanningForest(g);\n    /*\n    rep(i, ret.second.size()) {\n        cout << ret.second[i].src << \" \";\n        cout << ret.second[i].dst << \" \";\n        cout << ret.second[i].weight << endl;\n    }\n    */\n    cout << ldout << sum - ret.first << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*AOJ2224: Save your cat\n**問題概要\n[http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224:title]\nN個の頂点とM個の辺を持った無\b向グラフがある。グラフの閉路がすべてなくなるように辺を取り除きたい。辺のコストは辺の長さである。取り除く辺のコストの最小値を求めよ。\n2 <= N <= 10000\n1 <= M\n**解法\n辺を取り除くと考えるのではなく、残す辺で全域木を作ると考えれば、これも最大全域木問題になる。クラスカル法で解く。\n*/\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nstruct edge{ int u, v; float cost; };\nvector<edge> es;\nint V, E; // 頂点数と辺数\n\n//--------Union-Find木------------\nvector<int> par; // 親\nvector<int> rnk; // 深さ\n\n// Union-Find木の初期化\nvoid init_union_find(int n) {\n  par  = vector<int>(n);\n  rnk = vector<int>(n);\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n\n  if (rnk[x] < rnk[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (rnk[x] == rnk[y]) rnk[x]++;\n  }\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\n//----------クラスカル法------------\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost > e2.cost; // 大きい順\n}\ndouble kruskal() {\n  sort(es.begin(), es.end(), comp); // edge.costの大きい順\n  init_union_find(V); // Union-Findの初期化\n  double res = 0;\n  for (int i = 0; i < E; i++) {\n    edge e = es[i];\n    if (!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n      // cout << e.u+1 << \" \" << e.v+1 << endl;\n    }\n  }\n  return res;\n}\n\nint main() {\n  ifstream cin(\"../test.txt\");\n  // 初期化\n  cin >> V >> E;\n  vector<int> vx = vector<int>(V);\n  vector<int> vy = vector<int>(V);\n  es = vector<edge>(E);\n  for (int i = 0; i < V; i++) {\n    cin >> vx[i] >> vy[i];\n  }\n  float l;\n  int p, q;\n  double total_cost = 0;\n  for (int i = 0; i < E; i++) {\n    cin >> p >> q;\n    p--; q--;\n    l = sqrt((vx[p] - vx[q])*(vx[p] - vx[q]) + (vy[p] - vy[q])*(vy[p] - vy[q]));\n    edge e = {p, q, l};\n    es[i] = e;\n    total_cost += l;\n  }\n  // クラスカル法で最大全域木のコストを計算\n  double kr = kruskal();\n  // 出力\n  cout << total_cost - kr << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\n\nstruct UnionFind{\n  vector<int> r,p;\n  UnionFind(){}\n  UnionFind(int size){init(size);}\n  void init(int size){\n    r.resize(size,0);\n    p.resize(size,0);\n    for(int i=0;i<size;i++) r[i]=1,p[i]=i;\n  }\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\nstruct edge{\n  int from,to;\n  double cost;\n  edge(){}\n  edge(int from,int to,int cost):from(from),to(to),cost(cost){}\n  bool operator<(const edge& e) const{\n    return cost<e.cost;\n  }\n};\ndouble kruskal(int N,vector<edge> edges){\n  double res=0;\n  sort(edges.begin(),edges.end());\n  UnionFind uf(N+1);\n  for(int i=0;i<(int)edges.size();i++){\n    edge e=edges[i];\n    if(!uf.same(e.from,e.to)){\n      res+=e.cost;\n      uf.unite(e.from,e.to);\n    }\n  }\n  return res;\n}\n\n\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  vector<edge> edges(m);\n  double sum=0;\n  for(int i=0;i<m;i++){\n    cin>>edges[i].from>>edges[i].to;\n    edges[i].from--;edges[i].to--;\n    edges[i].cost=abs(p[edges[i].from]-p[edges[i].to]);\n    sum+=edges[i].cost;edges[i].cost*=-1;\n  }\n  printf(\"%.12f\\n\",sum+kruskal(n,edges));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P) \n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nconst int MAX = 21000;\nstruct UnionFind {    \n    int size_;\n    int par[MAX];\n    int rank[MAX];\n    \n    UnionFind(int n = 0) {size_ = n; for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;}\n    void init(int n) {size_ = n; for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;}\n    int root(int x) {return par[x] == x ? x : par[x] = root(par[x]);}    \n    bool same(int x, int y) {return root(x) == root(y);}\n    \n    void connect(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return;        \n        if (rank[x] < rank[y]) par[x] = y;\n        else {par[y] = x; if (rank[x] == rank[y]) ++rank[x];}\n    }\n};\n\ntemplate<class T> struct Edge {\n    int from, to;\n    T cost;\n    Edge() {};\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend bool operator < (const Edge &e1, const Edge &e2) {return e1.cost < e2.cost;}\n    friend bool operator > (const Edge &e1, const Edge &e2) {return e1.cost > e2.cost;}\n    friend ostream& operator << (ostream& s, const Edge<T>& E) {\n        return s << E.from << \"->\" << E.to << '(' << E.cost << ')';\n    }\n};\n\nUnionFind uf;\n\ntemplate<class T> T Kruskal(int V, vector<Edge<T> > edges) {\n    T res = 0.0;\n    uf.init(V);\n    sort(edges.begin(), edges.end(), greater<Edge<T> >());\n    for (int i = 0; i < edges.size(); ++i) {\n        Edge<T> e = edges[i];\n        if (!uf.same(e.from, e.to)) {\n            uf.connect(e.from, e.to);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint N, M;\ndouble x[MAX], y[MAX];\nint a, b;\n\ndouble sq(double x) {return x*x; }\n\nint main() {\n    while (cin >> N >> M) {\n        for (int i = 0; i < N; ++i) cin >> x[i] >> y[i];\n        vector<Edge<double> > edges(M);\n        double tot = 0;\n        for (int j = 0; j < M; ++j) {\n            cin >> a >> b; --a; --b;\n            double cost = sqrt(sq(x[a]-x[b]) + sq(y[a]-y[b]));\n            edges[j] = Edge<double>(a, b, cost);\n            tot += cost;\n        }\n        double res = Kruskal(N, edges);\n        cout << fixed << setprecision(9) << tot - res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define x first\n#define y second\n#define sqr(x) ((x) * (x))\n#define PII pair<int, int>\n#define SIZE(x) ((int) x.size())\nusing namespace std;\nconst int N = 1e4 + 5;\nPII p[N];\nint dis(PII a, PII b)\n{\n\treturn sqr(a.x - b.x) + sqr(a.y - b.y);\n}\nstruct edge\n{\n\tint u, v, r;\n\tedge(int u = 0, int v = 0, int r = 0) : u(u), v(v), r(r) {}\n};\nbool operator < (const edge &a, const edge &b)\n{\n\treturn dis(p[a.u], p[a.v]) < dis(p[b.u], p[b.v]);\n}\nvector<edge> G[N];\nvoid del_edge(int a, int idx)\n{\n\tint sz = SIZE(G[a]);\n\tswap(G[a][idx], G[a][sz - 1]);\n\tG[G[a][idx].v][G[a][idx].r].r = idx;\n\tG[a].pop_back();\n}\nint tick[N], xxx = 0;\nbool dfs(int x, int las)\n{\n\ttick[x] = xxx;\n\t//printf(\"at %d \", x);\n\tfor (int i = 0; i < SIZE(G[x]); ++ i)\n\t{\n\t\tif (i == las) continue;\n\t\tint u = G[x][i].v;\n\t\tif (tick[u] == xxx || dfs(u, G[x][i].r)) return true;\n\t}\n\treturn false;\n}\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d%d\", &p[i].x, &p[i].y);\n\tvector<edge> tot;\n\tfor (int i = 1; i <= m; ++ i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(edge(u, v, SIZE(G[v])));\n\t\tG[v].push_back(edge(v, u, SIZE(G[u]) - 1));\n\t\ttot.push_back(edge(u, v, SIZE(G[u]) - 1));\n\t}\n\tsort(tot.begin(), tot.end());\n\tdouble ans = 0;\n\tfor (int i = 0; i < m; ++ i)\n\t{\n\t\tint u = tot[i].u, v = tot[i].v, idx = tot[i].r, r = G[u][idx].r;\n\t\txxx ++;\n\t\ttick[u] = xxx;\n\t\tif (dfs(v, r))\n\t\t{\n\t\t\t//printf(\"\\n\");\n\t\t\tans += sqrt(1.0 * dis(p[u], p[v]));\n\t\t\t//printf(\"%.6f\\n\", ans);\n\t\t\t//printf(\"u sz = %d\\n\", G[u].size());\n\t\t\tdel_edge(u, idx);\n\t\t\tdel_edge(v, r);\n\t\t\t//printf(\"new u sz = %d\\n\", G[u].size());\n\t\t}\n\t}\n\tprintf(\"%.8f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int src, dst, w;\n  edge(int src, int dst, int w):src(src),dst(dst),w(w){}\n  bool operator<(const edge &t)const{\n    if( w != t.w ) return w > t.w;\n    if( src != t.src ) return src < t.src;\n    return dst < t.dst;\n  }\n};\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nconst int N = 10010;\nconst int INF = 800000010;\n\ndouble mst_prim(const graph &g, int r, bool ran[N]){\n  const int n = g.size();\n  double ret = 0;\n  bool vis[n];\n  \n  fill(vis,vis+n,false);\n  priority_queue<edge> Q;\n  Q.push( edge(-1,r,INF-0) );\n  ran[r] = true;\n  while(!Q.empty()){\n    edge e = Q.top(); Q.pop();\n    if( vis[e.dst] ) continue;\n    //cout << e.w << ' ' << -e.w + 10000 << ' ' << ret << endl;\n    ret += sqrt(-e.w+INF);\n    vis[e.dst] = true;\n    ran[e.dst] = true;\n    for(int i = 0; i < (int)g[e.dst].size(); ++i){\n      if( !vis[g[e.dst][i].dst] ) Q.push( g[e.dst][i] );\n    }\n  }\n  return ret;\n}\n\n#define SQ(a) ((a)*(a))\n\nint main()\n{\n  int n,m;\n  while(EOF!=scanf(\"%d%d\",&n,&m)){\n    int x[n],y[n];\n    bool ran[N];\n    double total = 0;\n    graph g(n);\n\n    for(int i = 0; i < n; ++i){\n      scanf(\"%d%d\", &x[i], &y[i]);\n    }\n    fill(ran,ran+n,false);\n    \n    for(int i = 0; i < m; ++i){\n      int p,q;\n      scanf(\"%d%d\", &p, &q);\n      --p;\n      --q;\n      int w = SQ(abs(x[p]-x[q])) + SQ(abs(y[p]-y[q]));\n      total += sqrt(w);\n      g[p].push_back( edge(p,q,INF-w) );\n      g[q].push_back( edge(q,p,INF-w) );\n    }\n\n    double rem = 0;\n    for(int i = 0; i < n; ++i){\n      if(!ran[i]){\n\tdouble tmp = mst_prim(g,i,ran);\n\t//cout << tmp << endl;\n\trem += tmp;\n      }\n    }\n    printf(\"%.12lf\\n\", total-rem);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n\nusing pii = pair<int, int>;\n\nstruct unionfind {\n    vector<int> par;\n    unionfind(int n) : par(n, -1) {}\n    void unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if (a == b) return;\n        if (size(a) > size(b)) swap(a, b);\n        par[b] += par[a];\n        par[a] = b;\n    }\n    int root(int x) {\n        if (par[x] < 0) return x;\n        return par[x] = root(par[x]);\n    }\n    int same(int a, int b) { return root(a) == root(b); }\n    int size(int x) { return -par[root(x)]; }\n};\n\nsigned main() {\n    int N, M;\n    cin >> N >> M;\n    vector<pii> p(N);\n    REP(i, N) {\n        int x, y;\n        cin >> x >> y;\n        p[i] = {x, y};\n    }\n    \n    vector<pair<double, pii>> edge(M);\n    REP(i, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        double dx = p[a].first - p[b].first;\n        double dy = p[a].second - p[b].second;\n        double cost = sqrt(dx * dx + dy * dy);\n        edge[i] = {-cost, {a, b}};\n    }\n    sort(begin(edge), end(edge));\n\n    unionfind uf(N);\n    double ans = 0;\n    REP(i, M) {\n        double cost = edge[i].first;\n        int a = edge[i].second.first;\n        int b = edge[i].second.second;\n        if (uf.same(a, b)) {\n            ans += -cost;\n        } else {\n            uf.unite(a, b);\n        }\n    }\n    cout << setprecision(20) << fixed << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii p(n);\n\trep(i, n)cin >> p[i].first >> p[i].second;\n\tvector<tuple<double, int, int>> f(m);\n\tunionfind uf(n);\n\trep(i, m) {\n\t\tint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tp1--;\n\t\tp2--;\n\t\tf[i] = tuple<double, int, int>{ p1,p2,hypot(p[p1].first - p[p2].first, p[p1].second - p[p2].second) };\n\t}\n\tsort(ALL(f), greater<tuple<double, int, int>>());\n\tdouble ans = 0;\n\trep(i, m) {\n\t\tif (!uf.same(get<1>(f[i]), get<2>(f[i])))uf.unite(get<1>(f[i]), get<2>(f[i]));\n\t\telse ans += get<0>(f[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct node\n{\n    int x,y,id;\n};\nstruct edge\n{\n    int u,v;\n    double cost;\n    edge() {}\n    edge(int x,int y,double z)\n    {\n        u=x;\n        v=y;\n        cost=z;\n    }\n    bool operator <(const edge& a) const\n    {\n        return cost>a.cost;\n    }\n};\n\nedge es[50010];\nint par[10010];\nnode p[10010];\nint n,m;\nvoid init()\n{\n    for(int i=1;i<=n;i++) par[i]=i;\n}\n\nint find(int x)\n{\n    return x==par[x]?x:par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y) par[x]=y;\n}\n\ndouble dis(int a,int b)\n{\n    return sqrt(1.0*(p[a].x-p[b].x)*(p[a].x-p[b].x)+1.0*(p[a].y-p[b].y)*(p[a].y-p[b].y));\n}\n\ndouble kruskal()\n{\n    sort(es,es+m);\n    //for(int i=0;i<m;i++) printf(\"%d %d %lf\\n\",es[i].u,es[i].v,es[i].cost);\n    double s=0;\n    for(int i=0;i<m;i++)\n    {\n        edge e=es[i];\n        if(find(e.u)!=find(e.v))\n        {\n            unite(e.u,e.v);\n        }\n        else\n        {\n            s+=e.cost;\n        }\n    }\n    return s;\n}\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    int a,b;\n    double c,sum;\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        sum=0;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            c=dis(a,b);\n            es[i]=edge(a,b,c);\n        }\n        printf(\"%.3lf\\n\",kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nstruct edge {\n  double l;\n  int a, b;\n  bool operator<(const edge &r) const {\n    return l > r.l;\n  }\n};\n\nclass UnionFind {\npublic:\n  const static int MAX_N = 10010;\n  int par[MAX_N];\n  int s[MAX_N];\n  UnionFind() { init(); }\n  UnionFind(int n) { init(n); }\n  void init() { for(int i=0; i<MAX_N; ++i) par[i] = i, s[i] = 1; }\n  void init(int n) { for(int i=0; i<n; ++i) par[i] = i, s[i] = 1; }\n  int find(int x) {\n    if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n  }\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    if(s[x] < s[y]) par[x] = y, s[y] = s[x] + s[y];\n    else par[y] = x, s[x] = s[x] + s[y];\n  }\n  bool same(int x, int y) { return find(x) == find(y);}\n};\nUnionFind uf;\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int n, m;\n  cin >> n >> m;\n  VI x(n), y(n);\n  REP(i, n) cin >> x[i] >> y[i];\n  double ret = 0;\n  vector<edge> v;\n  REP(i, m) {\n    int a, b;\n    cin >> a >> b; a--, b--;\n    double dist = sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));\n    v.PB({dist, a, b});\n    ret += dist;\n  }\n\n  // cout << ret << endl;\n  sort(ALL(v));\n\n  REP(i, m) {\n    if(!uf.same(v[i].a, v[i].b)) {\n      uf.unite(v[i].a, v[i].b);\n      ret -= v[i].l;\n    }\n  }\n\n  cout << fixed << setprecision(15) << ret << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt par[10000];\nstruct edge{lnt u,v,cost;};\nvector<edge> es;\nbool cmp(const edge& a,const edge& b){\n\treturn a.cost<b.cost;\n}\nP mat[10000];\nlnt n,m;\nvoid init(){\n\tfor(int i=0;i<n;i++) par[i]=i;\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\telse return par[x]=find(par[x]);\n}\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tpar[find(x)]=find(y);\n\treturn;\n}\ndouble ans=0;\nint main()\n{\n\tcin>>n>>m;\n\tinit();\n\tfor(lnt i=0;i<n;i++){\n\t\tcin>>mat[i].first>>mat[i].second;\n\t}\n\tlnt x,y;\n\tfor(lnt i=0;i<m;i++){\n\t\tcin>>x>>y;\n\t\tx--;\n\t\ty--;\n\t\tes.push_back({x,y,-(mat[x].first-mat[y].first)*(mat[x].first-mat[y].first)-(mat[x].second-mat[y].second)*(mat[x].second-mat[y].second)});\n\t\tans+=sqrt(-es[i].cost);\n\t}\n\tsort(es.begin(),es.end(),cmp);\n\tfor(lnt i=0;i<m;i++){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tans-=sqrt(-e.cost);\n\t\t}\n\t}\n\tcout<<fixed<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define eb emplace_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // 二要素間の距離\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n#define Decimal(x) printf(\"%.10f\\n\", x) // 小数点を10桁まで表示\n// debug用\n#define PrintVec(x) for (auto elementPrintVec: x) { cout << elementPrintVec << \" \"; } cout << endl;\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\n\nint POWINT(int x, int n) {\n  int ret = 1;\n  rep(i, 0, n) ret *= x;\n  return ret;\n};\n\nll POWLL(int x, int n) {\n  ll ret = 1;\n  rep(i, 0, n) ret *= x;\n  return ret;\n};\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\nclass Unionfind {\n  public:\n    vector<int> par; // 節点\n    vector<int> rank; // 木の高さ\n    vector<int> size; // 節点が属する木の節点数\n    int treeNum; // 木の数\n    Unionfind(int N) : par(N), rank(N, 0), size(N, 1) {\n      for (int i = 0; i < N; i++) {\n        par[i] = i;\n      }\n      treeNum = N;\n    }\n    // 節点(木)追加\n    void addNode(int x) {\n      par[x] = x;\n      rank[x] = 0;\n      size[x] = 1;\n      treeNum++;\n    }\n    // 根を探すと同時に経路上にある節点の親が根になるように代入\n    int root(int x) {\n      return par[x] == x ? x : par[x] = root(par[x]);\n    }\n    // 同じ木に属しているか\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n    // rankが低い方の木をrankが高い方の木の根に結びつける(結びつけた後の新しい木の高さが高くなることがないため)\n    void unite(int x, int y) {\n      x = root(x);\n      y = root(y);\n      treeNum--;\n      if (x == y) {\n        return;\n      }\n      if (rank[x] < rank[y]) {\n        par[x] = y;\n        size[y] += size[x];\n      } else {\n        par[y] = x;\n        size[x] += size[y];\n        if (rank[x] == rank[y]) {\n          rank[x] += 1;\n        }\n      }\n    }\n};\n\nclass Edge {\n  public:\n    int source, target;\n    double cost;\n    Edge() {}\n    Edge(int source, int target, double cost): source(source), target(target), cost(cost) {}\n    bool operator < (const Edge &e) const {\n      return cost < e.cost;\n    }\n};\n\ndouble Kruskal (int N, vector<Edge> &edges) {\n  double totalCost = 0ll;\n  sort(All(edges));\n  Unionfind uf = Unionfind(N);\n\n  rep(i, 0, edges.size()) {\n    Edge e = edges[i];\n    if (!uf.same(e.source, e.target)) {\n      totalCost += e.cost;\n      uf.unite(e.source, e.target);\n    }\n  }\n\n  return totalCost;\n};\n\nstruct Pile {\n  double x, y;\n};\n\ndouble dis(Pile p1, Pile p2) {\n  return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int N, M;\n  cin >> N >> M;\n  double total_cost = 0.0;\n  vector<Pile> piles(N);\n\n  rep(i, 0, N) {\n    cin >> piles[i].x >> piles[i].y;\n  }\n\n  int u, v;\n  double cost;\n  vector<Edge> edges;\n  rep(i, 0, M) {\n    cin >> u >> v;\n    u--; v--;\n    cost = dis(piles[u], piles[v]);\n    total_cost += cost;\n    Edge e1 = Edge(u, v, -cost);\n    Edge e2 = Edge(v, u, -cost);\n    edges.pb(e1);\n    edges.pb(e2);\n  }\n\n  double neg_cost = Kruskal(N, edges);\n  // Decimal(neg_cost);\n  double ans = total_cost + neg_cost;\n  Decimal(ans);\n\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nclass U {\npublic:\n  int n;\n  vector<int> p, s;\n\n  U(int _) {\n    n = _;\n    p.resize(n);\n    s.resize(n);\n    for (int i = 0; i < n; i++) {\n      p[i] = i;\n      s[i] = 1;\n    }\n  }\n\n  bool connect(int a, int b) {\n    int ap, bp;\n    for (ap = p[a]; ap != p[ap]; ap = p[ap]);\n    for (bp = p[b]; bp != p[bp]; bp = p[bp]);\n    if (ap == bp)\n      return true;\n    int mi = min(ap, bp), ma = max(ap, bp);\n    p[ma] = mi;\n    s[mi] += s[ma];\n    s[ma] = 0;\n    for (int pp = a; pp != mi;) {\n      int next = p[pp];\n      p[pp] = mi;\n      pp = next;\n    }\n    for (int pp = b; pp != mi;) {\n      int next = p[pp];\n      p[pp] = mi;\n      pp = next;\n    }\n    return false;\n  }\n\n  int q(int a) {\n    int ap;\n    for (ap = a; ap != p[ap]; ap = p[ap]);\n    return s[ap];\n  }\n\n  int parent(int a) {\n    int ap;\n    for (ap = a; ap != p[ap]; ap = p[ap]);\n    return p[ap];\n  }\n\n  bool query(int a, int b) { return parent(a) == parent(b); }\n};\n\nstruct N {\n  int i, s, t;\n  double ddist;\n};\n\nbool operator<(const N &l, const N &r) {\n  return l.ddist > r.ddist;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<double> xs(n), ys(n);\n  priority_queue<N> q;\n  for (int i = 0; i < n; i++) {\n    cin >> xs[i] >> ys[i];\n  }\n  U uf(n);\n  vector<N> ns(m);\n  for (int i = 0; i < m; i++) {\n    cin >> ns[i].s >> ns[i].t;\n    ns[i].s--;\n    ns[i].t--;\n    ns[i].i = i;\n    ns[i].ddist = (xs[ns[i].s] - xs[ns[i].t]) * (xs[ns[i].s] - xs[ns[i].t]) +\n                  (ys[ns[i].s] - ys[ns[i].t]) * (ys[ns[i].s] - ys[ns[i].t]);\n  }\n  sort(ns.begin(), ns.end());\n  double ans = 0.;\n  for (int i = 0; i < m; i++) {\n    if (uf.connect(ns[i].s, ns[i].t)) {\n      ans += sqrt(ns[i].ddist);\n    }\n  }\n  printf(\"%.12lf\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\n\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent;\n    vector<int> myrank;\n    //親は小さい\n    UnionFind(int n) : parent(n,-1), myrank(n,0) { }\n    bool Find(int x, int y){\n        return find_root(x) == find_root(y); \n    }\n    int find_root(int x){\n        if(parent[x] < 0){\n            return x;\n        }else{\n            return parent[x] = find_root(parent[x]);\n        }\n    }\n    bool Union(int x, int y){\n        x = find_root(x); y = find_root(y);\n\n        if(x != y){\n            if(myrank[y] < myrank[x]){\n                swap(x,y);\n            }\n            parent[x] += parent[y]; parent[y] = x;\n            if(myrank[x] == myrank[y]) myrank[x]++;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    int size(int x){\n        return -parent[find_root(x)];\n    }\n};\n\nstruct UEdge {\n    int a, b;\n    double len=1.0;\n    \n    UEdge(int a, int b, double len) : a(a), b(b), len(len) {}\n\n    bool operator <(const UEdge &rhs) const{\n        if (len != rhs.len) return len < rhs.len;\n        if (a != rhs.a) {return a < rhs.a;}\n        return b < rhs.b;\n    }\n    bool operator >(const UEdge &rhs) const{\n        if (len != rhs.len) return len > rhs.len;\n        if (a != rhs.a) {return a > rhs.a;}\n        return b > rhs.b;\n    }\n    bool operator <=(const UEdge &rhs) const{\n        if (len != rhs.len) return len < rhs.len;\n        if (a != rhs.a) {return a < rhs.a;}\n        return b <= rhs.b;\n    }\n    bool operator >=(const UEdge &rhs) const{\n        if (len != rhs.len) return len > rhs.len;\n        if (a != rhs.a) {return a > rhs.a;}\n        return b >= rhs.b;\n    }\n};\n\nstruct Point {\n    double a, b;\n\n    Point(double a, double b) : a(a), b(b) {}\n\n};\ndouble dist(Point &p1, Point &p2){\n    return sqrt((p1.a - p2.a)*(p1.a - p2.a) + (p1.b - p2.b)*(p1.b-p2.b));\n}\n\n\nint main(){\n    int N, M;\n    double x, y;\n    double tmp,total=0;\n    int a, b;\n    vector<UEdge> edges; \n    vector<Point> points;\n    cin >> N >> M;\n    for(int i=0; i< N; i++){\n        cin >> x >> y;\n        points.push_back(Point(x,y));\n    }\n    for(int i=0; i< M; i++){\n        cin >> a >> b;\n        a--;b--;\n        tmp = dist(points[a],points[b]);\n        total += tmp;\n        edges.push_back(UEdge(a,b,-tmp));\n    }\n    sort(edges.begin(), edges.end());\n    UnionFind uf(N);\n    int count = 0;\n    for(vector<UEdge>::iterator itr = edges.begin(); count < N-1 && itr != edges.end() ; itr++){\n        if( !uf.Find(itr->a, itr->b)){\n            uf.Union(itr->a, itr->b);\n            total += itr->len;\n            count++;\n        }\n    }\n    cout << fixed << setprecision(5) << total << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint par[10000];\nint rank[10000];\nvoid init(int n) {\n    for (int i=0; i<n; i++) {\n        par[i]=i;\n        rank[i]=0;\n    }\n}\nint find(int x) {\n    if (par[x]==x) {\n        return x;\n    } else {\n        return par[x]=find(par[x]);\n    }\n}\nvoid unite(int x, int y) {\n    x=find(x);\n    y=find(y);\n    if (x==y) return;\n    if (rank[x]<rank[y]) {\n        par[x]=y;\n    } else {\n        par[y]=x;\n        if (rank[x]==rank[y]) rank[x]++;\n    }\n}\nbool same(int x, int y) {\n    return find(x)==find(y);\n}\n\nstruct point { int x, y; };\nstruct edge {\n    int u, v;\n    double cost;\n};\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost>e2.cost;\n}\ndouble dist(point p1, point p2) {\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\npoint p[10000];\nvector<edge> es;\nint main() {\n    int n, m;\n    scanf(\"%d%d\",&n,&m);\n    init(n);\n    for (int i=0; i<n; i++) scanf(\"%d%d\",&p[i].x,&p[i].y);\n    double all=0.0;\n    for (int i=0; i<m; i++) {\n        int s, e; scanf(\"%d%d\",&s,&e);\n        edge ne=(edge){s-1,e-1,dist(p[s-1],p[e-1])};\n        es.push_back(ne);\n        all+=ne.cost;\n    }\n    sort(es.begin(), es.end(), comp);\n    double res=0.0;\n    for (int i=0; i<m; i++) {\n        edge e=es[i];\n        if (!same(e.u,e.v)) {\n            unite(e.u, e.v);\n            res+=e.cost;\n        }\n    }\n    printf(\"%.3f\\n\",all-res);\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n//#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n// #include <unordered_map>\n#include <map>\n#include <unordered_set>\n//#include <array>\n#include <set>\n#include <limits>\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224\n\nusing namespace std;\n\nusing ll = long long;\n\n#include <vector>\n\nstruct UnionFind {\n    vector<size_t> parent;\n    vector<size_t> rank;\n    size_t findParent(size_t x) {\n        if (parent[x] == x) {\n            return x;\n        } else {\n            parent[x] = findParent(parent[x]);\n            return parent[x];\n        }\n    }\n    explicit UnionFind(size_t size) {\n        parent.resize(size);\n        rank.resize(size);\n        for (size_t i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    virtual ~UnionFind() {}\n    void unite(size_t x, size_t y) {\n        size_t px = findParent(x);\n        size_t py = findParent(y);\n        if (px == py) {\n            return;\n        }\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else { // rank[px] == rank[py]\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n    bool isSame(size_t x, size_t y) {\n        return findParent(x) == findParent(y);\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    struct Pl {\n        int x;\n        int y;\n        Pl(int x, int y) : x(x), y(y) {}\n        double dist(const Pl& rhs) const {\n            return sqrt(pow((double)(x - rhs.x), 2.0) + pow((double)(y - rhs.y), 2.0));\n        }\n    };\n    vector<Pl> piles;\n    piles.reserve(N);\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        piles.emplace_back(x, y);\n    }\n    struct Fc {\n        int a;\n        int b;\n        double len;\n        Fc(int a, int b, double len) : a(a), b(b), len(len) {}\n        static bool compareLen(const Fc& lhs, const Fc& rhs) {\n            return lhs.len > rhs.len;\n        }\n    };\n    vector<Fc> fences;\n    fences.reserve(M);\n    double totalLen = 0.0;\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        double len = piles[a].dist(piles[b]);\n        fences.emplace_back(a, b, len);\n        totalLen += len;\n    }\n    sort(fences.begin(), fences.end(), Fc::compareLen);\n    UnionFind uf(N);\n    double lenSum = 0.0;\n    for (Fc fc : fences) {\n        if (!uf.isSame(fc.a, fc.b)) {\n            uf.unite(fc.a, fc.b);\n            lenSum += fc.len;\n        }\n    }\n    cout << totalLen - lenSum << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\nusing namespace std;\n#define REP(i, b, e) for ( int i = b; i < (int)e; i++ )\n#define rep(i, n) REP(i, 0, n)\nstatic const int MAX = 10000;\n\npair<int, int> P[MAX];\nvector<pair<int, double> > G[MAX];\nint N, M;\n\ndouble getDist(double x1, double y1, double x2, double y2){\n  return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble prim(){\n  double sum = 0.0;\n  priority_queue<pair<double, int> > PQ;\n  bool V[MAX];\n  rep(i, N) V[i] = false;\n\n  rep(s, N){\n    if ( V[s] ) continue;\n    PQ.push(make_pair(0, s));\n    pair<double, int> u;\n    while( !PQ.empty() ){\n      u = PQ.top(); PQ.pop();\n      if ( V[u.second] ) continue;\n      V[u.second] = true;\n      sum += u.first;\n      rep(i, G[u.second].size()){\n\tint v = G[u.second][i].first;\n\tdouble c = G[u.second][i].second;\n\tif ( V[v] ) continue;\n\tPQ.push(make_pair(c, v));\n      }\n    }\n  }\n  return sum;\n}\n\nmain(){\n  int s, t;\n  double sum = 0;\n  cin >> N >> M;\n  rep(i, N) cin >> P[i].first >> P[i].second;\n  rep(i, N) G[i].clear();\n  rep(i, M){\n    cin >> s >> t;\n    s--; t--;\n    double d = getDist(P[s].first, P[s].second, P[t].first, P[t].second);\n    sum += d;\n    G[s].push_back(make_pair(t, d));\n    G[t].push_back(make_pair(s, d));\n  }\n  printf(\"%.8lf\\n\", sum - prim());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint par[150010],r[150010];\nvoid init(){ rep(i,150010){ par[i]=i; r[i]=0; } }\nint find(int x){ if(x==par[x])return x; return par[x]=find(par[x]); }\nbool same(int x,int y){ return find(x)==find(y); }\nvoid unit(int x,int y){ if(same(x,y))return; x=find(x); y=find(y); if(r[x]<r[y])par[x]=y; else { par[y]=x; if(r[x]==r[y])r[x]++; } }\n\nint main(){\n\tint n,m;\n\tint x[10010],y[10010];\n\tvector<P1> G;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\trep1(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\trep(i,m){\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tG.pb(mp1((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]),p,q));\n\t}\n\t\n\tsor(G);\n\trev(G);\n\tinit();\n\t\n\tdouble ret=0.0;\n\trep(i,m){\n\t\tP1 ed=G[i];\n\t\tif(!same(ed.sc.fr,ed.sc.sc)){\n\t\t\tunit(ed.sc.fr,ed.sc.sc);\n\t\t}\n\t\telse ret+=sqrt((double)ed.fr);\n\t}\n\t\n\tprintf(\"%.3f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct Way{\n\tint p,q,cost;\n\tWay(){}\n\tWay(int _p,int _q,int _cost){\n\t\tp=_p; q=_q; cost=_cost;\n\t}\n\tbool operator<(const Way &a)const{\n\t\treturn cost>a.cost;\n\t}\n};\n\nstruct Node{\n\tint x,y;\n};\n\nint par[10000],_rank[10000];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++) par[i]=i,_rank[i]=1;\n}\n\nint find(int a){\n\tif(par[a]==a) return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int _a,int _b){\n\tint a = find(_a);\n\tint b = find(_b);\n\tif(a==b) return;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = a;\n\t}\n\telse{\n\t\tpar[a] = b;\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n}\n\nint main(){\n\tint N,M;\n\tNode node[10000];\n\tWay way[10000];\n\tcin>>N>>M;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>node[i].x>>node[i].y;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin>>way[i].p>>way[i].q;\n\t\ta = node[--way[i].p].x-node[--way[i].q].x;\n\t\tb = node[way[i].p].y-node[way[i].q].y;\n\t\tway[i].cost = a*a+b*b;\n\t\t//printf(\"\\t%d\\n\",way[i].cost);\n\t}\n\n\tdouble ans=0;\n\tsort(way,way+M);\n\tinit(N);\n\tfor(int i=0;i<M;i++){\n\t\tint a = find(way[i].p),\n\t\t\tb = find(way[i].q);\n\t\tif(a!=b) unite(a,b);\n\t\telse ans += sqrt(way[i].cost);\n\t}\n\tprintf(\"%lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<iterator>\n#include<numeric>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\nmultimap<double, Pair,greater<double>> m;\nvector<Pair> v2;\nbool b[10002] = {};\nint main()\n{\n\tint N, M;\n\tdouble sum = 0.0;\n\tcin >> N >> M;\t   \n\tfor (unsigned int i = 0; i < N; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv2.push_back(make_pair(x, y));\n\t}\n\tfor (unsigned int j = 0; j < M; j++)\n\t{\n\t\tint p, q;\n\t\tcin >> p >> q;\n\t\tdouble temp=sqrt((v2[p - 1].first - v2[q - 1].first)*(v2[p - 1].first - v2[q - 1].first) + (v2[p - 1].second - v2[q - 1].second)*(v2[p - 1].second - v2[q - 1].second));\n\t\tsum += temp;\n\t\tm.insert(make_pair(temp, make_pair(p - 1, q - 1)));\n\t}\n\twhile (!m.empty())\n\t{\n\t\tint l = (*m.begin()).second.first;\n\t\tint r = (*m.begin()).second.second;\n\t\tif (b[l]==false|| b[r]==false)\n\t\t{\n\t\t\tsum -= (*m.begin()).first;\n\t\t\tb[l] = true;\n\t\t\tb[r] = true;\n\t\t\tm.erase(m.begin());\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (b[i] == false)break;\n\t\t\t\telse if (i == N - 1)m.clear();\n\t\t\t}\n\t\t}\n\t\telse m.erase(m.begin());\n\n\t}\n\tcout << fixed<<setprecision(3) << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <algorithm>\n#include <stdlib.h>\n#include <string>\n#include <queue>\n#include <vector>\n#define maxn 20000\n#define oo 1000000000\n#define clearAll(a) memset(a,0,sizeof(a))\n#define sq(a) ((a)*(a))\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,m;\nint x[maxn],y[maxn];\nstruct edge\n{\n\tint x,y;\n\tll w;\n\tedge() {}\n\tedge(int x,int y,ll w) : x(x),y(y),w(w) {}\n};\nvector<edge> v;\n\nint set[maxn];\n\nint find(int x)\n{\n\treturn set[x]==x?x:set[x]=find(set[x]);\n}\n\nbool cmp(edge a,edge b)\n{\n\treturn a.w>b.w;\n}\n\nint main()\n{\n   // freopen(\"C:\\\\Users\\\\py\\\\Desktop\\\\input.txt\",\"r\",stdin);\n    //freopen(\"C:\\\\Users\\\\py\\\\Desktop\\\\output.txt\",\"w\",stdout);\n    scanf(\"%d%d\",&n,&m);\n\n    for (int i=1;i<=n;i++)\n    \tscanf(\"%d%d\",x+i,y+i);\n\n    int p1,p2;\n    double tot = 0;\n    for (int i=1;i<=m;i++)\n    {\n    \tscanf(\"%d%d\",&p1,&p2);\n    \tv.push_back(edge(p1,p2,sq((ll)x[p1]-x[p2])+sq((ll)y[p1]-y[p2])));\n    \ttot += sqrt(v[i-1].w);\n    }\n\n\n    for (int i=1;i<=n;i++)\n    \tset[i]=i;\n\n    sort(v.begin(),v.end(),cmp);\n\n\n    for (int i=0;i<m;i++)\n    {\n    \tint xx = find(v[i].x);\n    \tint yy = find(v[i].y);\n    \tif (xx!=yy)\n    \t{\n    \t\ttot-=sqrt(v[i].w);\n    \t\tset[xx]=yy;\n    \t}\n    }\t\n\n    printf(\"%.8f\\n\",tot);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#define min(a,b)    (((a) < (b)) ? (a) : (b))\n#define max(a,b)    (((a) > (b)) ? (a) : (b))\n#define abs(x)    ((x) < 0 ? -(x) : (x))\n#define INF 0x3f3f3f3f\n#define delta 0.85\n#define eps 1e-3\n#define PI 3.14159265358979323846\n#define MAX_V 10005\n#define MAX_E 10000000\nusing namespace std;\nstruct edge{\n\tint u, v;\n\tdouble cost;\n}es[MAX_E];\nint V, E;\nint X[MAX_V], Y[MAX_V];\n\nbool cmp(const edge& e1, const edge& e2){\n\treturn e1.cost > e2.cost;\n}\n\n/**** Union_find ****/\nint par[MAX_V], rank[MAX_V];\n\nvoid init_union_find(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i, rank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x, int y){\n\tx = find(x), y = find(y);\n\tif(x == y) return;\n\tif(rank[x] > rank[y]) par[y] = x;\n\telse{\n\t\tpar[x] = y;\n\t\tif(rank[x] == rank[y]) ++rank[y];\n\t}\n}\n/**** Union_find ****/\n\n// Kruskal\ndouble kruskal(){\n\tsort(es, es + E, cmp);\n\tinit_union_find(V);\n\tdouble res = 0;\n\tfor(int i = 0; i < E; i++){\n\t\tedge &e = es[i];\n\t\tif(!same(e.u, e.v)){\n\t\t\tres += e.cost;\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble dist(int u, int v){\n\tdouble dx = X[u] - X[v], dy = Y[u] - Y[v];\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nint main(){\n\twhile(~scanf(\"%d%d\", &V, &E) && V){\n\t\tfor(int i = 0; i < V; i++) scanf(\"%d%d\", X + i, Y + i);\n\t\tdouble sum = 0.0;\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v);\n\t\t\t--u, --v;\n\t\t\tes[i].u = u, es[i].v = v, es[i].cost = dist(u, v);\n\t\t\tsum += es[i].cost;\n\t\t}\n\t\tprintf(\"%.3f\\n\", sum - kruskal());\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int src, dst, w;\n  edge(int src, int dst, int w):src(src),dst(dst),w(w){}\n  bool operator<(const edge &t)const{\n    if( w != t.w ) return w > t.w;\n    if( src != t.src ) return src < t.src;\n    return dst < t.dst;\n  }\n};\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nconst int N = 10010;\nconst int INF = 800000010;\n\ndouble mst_prim(const graph &g, int r, bool ran[N]){\n  const int n = g.size();\n  double ret = 0;\n  bool vis[n];\n  \n  fill(vis,vis+n,false);\n  priority_queue<edge> Q;\n  Q.push( edge(-1,r,10000) );\n  ran[r] = true;\n  while(!Q.empty()){\n    edge e = Q.top(); Q.pop();\n    if( vis[e.dst] ) continue;\n    //cout << e.w << ' ' << -e.w + 10000 << ' ' << ret << endl;\n    ret += sqrt(-e.w+10000);\n    vis[e.dst] = true;\n    ran[e.dst] = true;\n    for(int i = 0; i < (int)g[e.dst].size(); ++i){\n      if( !vis[g[e.dst][i].dst] ) Q.push( g[e.dst][i] );\n    }\n  }\n  return ret;\n}\n\n#define SQ(a) ((a)*(a))\n\nint main()\n{\n  int n,m;\n  while(EOF!=scanf(\"%d%d\",&n,&m)){\n    int x[n],y[n];\n    bool ran[N];\n    double total = 0;\n    graph g(n);\n\n    for(int i = 0; i < n; ++i){\n      scanf(\"%d%d\", &x[i], &y[i]);\n    }\n    fill(ran,ran+n,false);\n    \n    for(int i = 0; i < m; ++i){\n      int p,q;\n      scanf(\"%d%d\", &p, &q);\n      --p;\n      --q;\n      int w = SQ(abs(x[p]-x[q])) + SQ(abs(y[p]-y[q]));\n      total += sqrt(w);\n      g[p].push_back( edge(p,q,10000-w) );\n      g[q].push_back( edge(q,p,10000-w) );\n    }\n\n    double rem = 0;\n    for(int i = 0; i < n; ++i){\n      if(!ran[i]){\n\tdouble tmp = mst_prim(g,i,ran);\n\t//cout << tmp << endl;\n\trem += tmp;\n      }\n    }\n    printf(\"%.12lf\\n\", total-rem);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst double EPS = 1.0e-10;\n\nclass Point\n{\npublic:\n    double y, x;\n    Point(){\n        y = x = 0.0;\n    }\n    Point(double y0, double x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(double a) const{\n        return Point(y * a, x * a);\n    }\n    Point operator/(double a) const{\n        return Point(y / a, x / a);\n    }\n    double length() const{\n        return sqrt(y * y + x * x);\n    }\n    double dist(const Point& p) const{\n        return sqrt(pow(y - p.y, 2) + pow(x - p.x, 2));\n    }\n};\n\nclass Edge\n{\npublic:\n    int to;\n    double cost;\n    Edge(){};\n    Edge(int to0, double cost0){to = to0; cost = cost0;}\n};\n\ndouble solve(const vector<vector<Edge> >& edges)\n{\n    int n = edges.size();\n    vector<bool> used(n, false);\n    vector<double> minCost(n, -1.0);\n    double ret = 0.0;\n    \n    for(int i=0; i<n; ++i){\n        if(used[i])\n            continue;\n\n        priority_queue<pair<double,int> > q;\n        q.push(make_pair(0.0, i));\n\n        while(!q.empty()){\n            pair<double, int> p = q.top();\n            q.pop();\n            int v = p.second;\n            if(used[v])\n                continue;\n            ret += p.first;\n            used[v] = true;\n            for(unsigned i=0; i<edges[v].size(); ++i){\n                Edge e = edges[v][i];\n                if(!used[e.to] && e.cost > minCost[e.to] + EPS){\n                    minCost[e.to] = e.cost;\n                    q.push(make_pair(e.cost, e.to));\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<Point> p(n);\n    for(int i=0; i<n; ++i)\n        cin >> p[i].x >> p[i].y;\n\n    vector<vector<Edge> > edges(n);\n    double sum = 0.0;\n    for(int i=0; i<m; ++i){\n        int a, b;\n        cin >> a >> b;\n        -- a;\n        -- b;\n\n        double cost = p[a].dist(p[b]);\n        sum += cost;\n        edges[a].push_back(Edge(b, cost));\n        edges[b].push_back(Edge(a, cost));\n    }\n\n    double ret = sum - solve(edges);\n    printf(\"%.10f\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nconst int maxn=10010;\nint M,N;\nfloat sum;\nfloat sssum;\nint f[maxn];\n\nstruct Node\n{\n    int x,y;\n}node[maxn];\n\nstruct Edge\n{\n    int u;\n    int v;\n    float cost;\n}e[maxn];\n\nbool cmp(const Edge&a,const Edge&b)\n{\n    return a.cost>b.cost;\n}\n\nint Find(int x)\n{\n    if(x!=f[x])\n        f[x]=Find(f[x]);\n    return f[x];\n}\n\nvoid read()\n{\n    for(int i=1;i<=N;i++)\n    {\n        scanf(\"%d%d\",&node[i].x,&node[i].y);\n    }\n    for(int i=1;i<=M;i++)\n    {\n        scanf(\"%d%d\",&e[i].u,&e[i].v);\n        e[i].cost=sqrt(pow(node[e[i].u].x-node[e[i].v].x,2)+pow(node[e[i].u].y-node[e[i].v].y,2));\n    }\n}\n\nvoid init()\n{\n    for(int i=1;i<=M;i++)\n        f[i]=i;\n    sum=0;\n    sssum=0;\n}\n\nvoid work()\n{\n    sort(e+1,e+1+M,cmp);\n    for(int i=1;i<=M;i++)\n    {\n        int fu=Find(e[i].u),fv=Find(e[i].v);\n        if(fu!=fv)\n        {\n            f[fu]=fv;\n            sum=sum+e[i].cost;\n        }\n        sssum=sssum+e[i].cost;\n    }\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\",&N,&M))\n    {\n        read();\n        init();\n        work();\n        printf(\"%.3f\\n\",sssum-sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nvector<int> g[10010];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<pair<double, pair<int,int>>> v;\n\tvector<int> h(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--, b--;\n\t\tdouble dist = sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b]));\n\t\tv.push_back({ dist, {a, b } });\n\t\th[a]++, h[b]++;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\t\n\tsort(v.begin(), v.end());\n\t\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (h[v[i].second.second] <= 1 || h[v[i].second.first] <= 1) continue;\n\t\tret += v[i].first;\n\t\th[v[i].second.second]--, h[v[i].second.first]--;\n\t\tint now = v[i].second.first;\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\tnow = v[i].second.first;\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << ret << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\ndouble dist(pii a, pii b){\n    return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n\nclass UnionFind{\nprivate:\n    vi par;\n    vi rank;\n    int find(int x){\n        if (par[x] == -1) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\npublic:\n    UnionFind(int size)\n        :par(size, -1)\n        ,rank(size, 0)\n    {\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x==y) return;\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same (int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct edge {\n    int from, to;\n    double length;\n    bool operator <(const edge& e) const {\n        return length < e.length;\n    }\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<pii> pile(n+1);\n    REP(i, 1, n+1){\n        int x, y;\n        cin >> x >> y;\n        pile[i] = {x, y};\n    }\n    priority_queue<edge> que;\n    rep(i, m){\n        int p, q;\n        cin >> p >> q;\n        que.push({p, q, dist(pile[p], pile[q])});\n    }\n    UnionFind u(n+1);\n    double cost = 0;\n    while(!que.empty()){\n        edge e = que.top(); que.pop();\n        if (!u.same(e.from, e.to))\n            u.unite(e.from, e.to);\n        else\n            cost += e.length;\n    }\n    cout << cost << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nclass union_find{\n\tprivate:\n\tvector<int> parent,rank,gs;\n    int size;\n\tpublic:\n    int count_group;\n    union_find()=default;\n    union_find(int n){ init(n); }\n\n    void init(int n){\n\t\tsize=n;\n\t\tcount_group=n;\n\t\tparent.resize(size);\n\t\trank.assign(size,0);\n        gs.assign(size,1);\n\t\tfor(int i=0; i<size; ++i) parent[i]=i;\n\t}\n\n\tint find(int x){\n\t\tif(parent[x]==x) return x;\n\t\telse return parent[x]=find(parent[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tparent[x]=y;\n            gs[y]+=gs[x];\n\t\t} else {\n\t\t\tparent[y]=x;\n            gs[x]+=gs[y];\n\t\t\tif(rank[x]==rank[y]) ++rank[x];\n\t\t}\n\t\t--count_group;\n\t}\n\n\tbool is_same_group(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\n    int group_size(int x){\n        return gs[find(x)];\n    };\n};\n\nvoid solve(){\n    typedef tuple<double,int,int> tup;\n    int n,m;\n    cin >> n >> m;\n    vector<complex<double>> ps;\n    vector<tup> edges;\n    rep(i,0,n){\n        int x,y;\n        cin >> x >> y;\n        ps.push_back(complex<double>(x,y));\n    }\n    double ans=0;\n    rep(i,0,m){\n        int p,q;\n        cin >> p >> q;\n        --p;\n        --q;\n        ans+=abs(ps[p]-ps[q]);\n        edges.push_back(make_tuple(abs(ps[p]-ps[q]),p,q));\n    }\n    sort(edges.rbegin(),edges.rend());\n    union_find uf(n);\n    for(const auto &edge:edges){\n        int p,q;\n        double d;\n        tie(d,p,q)=edge;\n        if(uf.is_same_group(p,q)) continue;\n        uf.unite(p,q);\n        ans-=d;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nstruct E\n{\n    int u,v;\n    double w;\n} e[50010005];\nint a[10005];\ndouble x[10005],y[10005];\nint cmp(E x,E y)\n{\n    return x.w>y.w;\n}\nint findx(int x)\n{\n    if(a[x]==x) return x;\n    return a[x]=findx(a[x]);\n}\nint main()\n{\n    int m,n,i;\n    while (scanf(\"%d%d\",&n,&m)!=-1)\n    {\n        for (i=1; i<=n; i++)\n            a[i]=i;\n        for (i=1; i<=n; i++)\n            scanf(\"%lf%lf\",&x[i],&y[i]);\n        int u,v;\n        double sum=0.0;\n        for (i=0; i<m; i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            e[i].u=u;\n            e[i].v=v;\n            e[i].w=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));\n            sum+=e[i].w;\n        }\n        sort(e,e+m,cmp);\n        double s=0;\n        for (i=0; i<m; i++)\n        {\n            int x=findx(e[i].u);\n            int y=findx(e[i].v);\n            if (x!=y)\n            {\n                a[x]=y;\n                s+=e[i].w;\n            }\n        }\n        printf(\"%.3f\\n\",sum-s);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass UnionFindTree{\nprivate:\n  int _size;\n  int* _parent;\n  int* _rank;\npublic:\n  UnionFindTree(int n){\n    _size = n;\n    _parent = new int[_size]();\n    _rank = new int[_size]();\n    for(int i = 0; i < _size; i++){\n      _parent[i] = i;\n      _rank[i] = 1;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] _parent;\n    delete[] _rank;\n  }\n\n  int find(int child){\n    int next = _parent[child];\n    if(next == child) return child;\n    else return find(next);\n  }\n\n  bool same(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    return (lhs == rhs);\n  }\n  \n  bool unite(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(same(lhs,rhs)) return false;\n    \n    if(_rank[lhs] < _rank[rhs]){\n      _parent[lhs] = rhs;\n    }\n    else {\n      _parent[rhs] = lhs;\n      if(_rank[rhs] == _rank[lhs]) _rank[lhs]++;\n    }\n    return true;\n  }\n\n};\n\nclass State {\npublic:\n  int _from,_to;\n  double _distance;\n  State(int from,int to,double distance)\n    : _from(from),_to(to),_distance(distance) {}\n  bool operator<(const State& s) const {\n    return _distance < s._distance;\n  }\n  bool operator>(const State& s) const {\n    return _distance > s._distance;\n  }\n};\n\nint main(){\n  int num_of_magical_piles;\n  int num_of_magical_fences;\n  while(~scanf(\"%d %d\",\n               &num_of_magical_piles,\n               &num_of_magical_fences)){\n    \n    vector<P> piles;\n    for(int pile_i = 0; pile_i < num_of_magical_piles; pile_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      piles.push_back(P(x,y));\n    }\n\n    double sum = 0;\n    priority_queue<State,vector<State>,less<State> > que;\n\n    for(int fence_i = 0; fence_i < num_of_magical_fences; fence_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      from--; to--;\n      int from_x = piles[from].first;\n      int from_y = piles[from].second;\n\n      int to_x = piles[to].first;\n      int to_y = piles[to].second;\n\n      double distance = sqrt((double)((from_x - to_x) * (from_x - to_x)\n                                      + (from_y - to_y) * (from_y - to_y)));\n      sum += distance;\n      que.push(State(from,to,distance));\n    }\n\n    UnionFindTree uft(num_of_magical_piles);\n    double after_ruined = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(uft.same(s._from ,s._to)){\n        continue;\n      }\n      uft.unite(s._from,s._to);\n      after_ruined += s._distance;\n    }\n    printf(\"%lf\\n\",sum - after_ruined);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nstruct UnionFind{\n   vector<int> par;\n   UnionFind(int n):par(n,-1){}\n   int find(int x){\n       if(par[x]<0)return x;\n       return par[x]=find(par[x]);\n   }\n   bool unite(int x,int y){\n       x=find(x);\n       y=find(y);\n       if(x==y)return false;\n       if(par[x]>par[y]){\n           par[y]+=par[x];\n           par[x]=y;\n       }\n       else{\n           par[x]+=par[y];\n           par[y]=x;\n       }\n       return true;\n   }\n\n   bool same(int x,int y){\n       return find(x)==find(y);\n   }\n   int size(int x){\n       return -par[find(x)];\n   }\n};\n\ndouble x[12345],y[12345];\ndouble dist(int i,int j){\n    return sqrt(pow(x[i]-x[j],2)+pow(y[i]-y[j],2));\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    rep(i,n){\n        cin>>x[i]>>y[i];\n    }\n    int u[m],v[m];\n    double d[m];\n    rep(i,m){\n        cin>>u[i]>>v[i];\n        --u[i];--v[i];\n        d[i]=dist(u[i],v[i]);\n    }\n    vector<int> ord(m);\n    iota(ord.begin(),ord.end(),0);\n    sort(ord.begin(),ord.end(),[&](int i,int j){\n        return d[i]>d[j];\n    });\n    double ans=0;\n    UnionFind uf(n);\n    for(auto i : ord){\n        if(uf.unite(u[i],v[i])){\n            continue;\n        }\n        else ans+=d[i];\n    }\n    cout<<fixed<<setprecision(12)<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\nconst double EPS = 1e-9;\nconst double INF = 1e18;\nconst double base = 3*1e4;\nvector<double> mincost((int)1e4, INF);\n\ndouble prim(int s, vector<vector<pair<int, double> > > &adj){\n    int n = adj.size();\n    //vector<double> mincost(n, INF);\n    priority_queue<pair<double, int> > wait;\n    wait.push(make_pair(0, s));\n    \n    int v = 0;\n    double ret = 0;\n    while(!wait.empty() && v<n){\n        double cost = -wait.top().first;\n        int idx = wait.top().second;\n        wait.pop();\n        if(cost > mincost[idx] +EPS) continue;\n        ret += cost;\n        v++;\n        mincost[idx] = -INF;\n        for(int i=0; i<(int)adj[idx].size(); i++){\n            int nidx = adj[idx][i].first;\n            double ncost = adj[idx][i].second;\n            if(ncost +EPS < mincost[nidx]){\n                wait.push(make_pair(-ncost, nidx));\n                mincost[nidx] = ncost;\n            }\n        }\n    }\n    \n    for(int i=0; i<n; i++){\n        if(mincost[i] == INF){\n            ret += prim(i, adj);\n        }\n    }\n    return ret -(v-1)*base;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<double> px(n), py(n);\n    for(int i=0; i<n; i++){\n        cin >> px[i] >> py[i];\n    }\n    vector<vector<pair<int, double> > > adj(n);\n    double sum = 0;\n    for(int i=0; i<m; i++){\n        int p,q;\n        cin >> p >> q;\n        p--; q--;\n        double d = sqrt((px[p]-px[q])*(px[p]-px[q]) +(py[p]-py[q])*(py[p]-py[q]));\n        sum += d;\n        adj[p].push_back(make_pair(q, base -d));\n        adj[q].push_back(make_pair(p, base -d));\n    }\n    cout << fixed;\n    cout << setprecision(3);\n    cout << sum +prim(0, adj) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint const MAX_N  = 10000;\nint N, M;\nP piles[MAX_N];\n\ndouble distance(int x0, int y0, int x1, int y1) {\n    return hypot(x1-x0, y1-y0);\n}\n\n// O(E*log(V))\nstruct Edge {\n    Edge(int a, int b, double c) {\n        u = a; v = b; cost = c;\n    }\n    int u, v;\n    double cost;\n};\n\nbool comp(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nstruct UF{\n    vector<int> par;\n    UF(int m) : par(m){\n        for(int i = 0; i < m; i++){\n            par[i] = i;\n        }\n    }\n    int find(int x){\n        return x != par[x] ? par[x] = find(par[x]) : x;\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    void unite(int x, int y){\n        // y is above\n        if(!same(x, y)) par[find(x)] = find(y);\n    }\n};\n\ndouble kruskal(int V, vector<Edge>& es) {\n    sort(es.begin(), es.end(), comp);\n    UF uf(V);\n    double res = 0;\n    for(int i = es.size()-1; i >= 0; i--) {\n        Edge e = es[i];\n        if(!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);\n        } else {\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvector<Edge> es;\n\nint main() {\n    cin >> N >> M;\n    int x, y;\n    for(int i = 0; i < N; i++) {\n        cin >> x >> y;\n        piles[i] = P(x, y);\n    }\n    int j, k;\n    double s = 0;\n    for(int i = 0; i < M; i++) {\n        cin >> j >> k;\n        j--; k--;\n        P p1 = piles[j], p2 = piles[k];\n        double d = distance(p1.first, p1.second, p2.first, p2.second);\n        s += d;\n        es.push_back(Edge(j, k, d));\n    }\n    printf(\"%.5f\\n\", kruskal(N, es));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconstexpr ll INF = 1e18;\nconstexpr ll M = 1e9 + 7;\n\nstruct edge {\n    int u, v;\n    double cost;\n    bool operator<(edge const& e) const {\n        return cost < e.cost;\n    }\n};\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<double> x(N), y(N);\n    vector<edge> es;\n    union_find uf(N);\n    for(int i=0; i<N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n    double sum = 0;\n    for(int i=0; i<M; ++i) {\n        int p, q;\n        cin >> p >> q;\n        p--; q--;\n        double d = hypot(x[p] - x[q], y[p] - y[q]);\n        sum += d;\n        es.push_back(edge{p, q, -d});\n    }\n    sort(es.begin(), es.end());\n    for(auto& e : es) {\n        if(uf.unite(e.u, e.v)) {\n            sum += e.cost;\n        }\n    }\n    cout << fixed << setprecision(10) << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int maxv = 10010;\nint V,E;\nint par[maxv], rank[maxv];\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint find(int x){\n\tif(par[x]==x) return par[x];\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rank[x] > rank[y]) par[y] = x;\n\telse par[x] = y;\n\tif(rank[x] == rank[y]) rank[x]++;\n}\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n}es[maxv*maxv];\nbool cmp(const edge & e1, const edge & e2){\n\treturn e1.cost > e2.cost;\n}\nstruct position{\n\tdouble x,y;\n}pos[maxv];\nint main(){\n\twhile(cin>>V>>E){\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tcin>>pos[i].x>>pos[i].y;\n\t\t}\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tcin>>es[i].u>>es[i].v;\n\t\t\tes[i].cost=sqrt((pos[es[i].u-1].x-pos[es[i].v-1].x)*(pos[es[i].u-1].x-pos[es[i].v-1].x)+(pos[es[i].u-1].y-pos[es[i].v-1].y)*(pos[es[i].u-1].y-pos[es[i].v-1].y));\n\t\t}\n\t\tsort(es,es+E,cmp);\n\t\tinit(V);\n\t\tdouble res = 0,sum=0;\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tedge e = es[i];\n\t\t\t//cout<<e.cost<<endl;\n\t\t\tsum+=e.cost;\n\t\t\tif(!same(e.u, e.v)){\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tres+=e.cost;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\",sum-res);\n\t//\tcout<<sum-res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n#include<map>\nusing namespace std;\n\nstruct Graph {\n\tint frm, to, w;\t\n};\nbool operator<(const Graph&g1, const Graph &g2) {return (g1.w<g2.w);}\n\nstruct node {\n\tint parent;\n\tint group;\n\tint x, y;\n\tnode() {}\n};\nnode N[10001];\nmap<int, int> M;\n\nint find(int v) {\n\tint ret;\n\tif(N[v].parent==-1) {\n\t\tN[v].parent = v;\n\t\treturn v;\n\t}\n\tif(v==N[v].parent) return v;\n\tret = find(N[v].parent);\n\tN[v].parent = ret;\n\treturn ret;\n}\n\nvoid union_node(int src, int dst) {\n\tN[find(src)].parent = find(dst);\n}\n\nvoid update(int n) {\n\tfor(int i=1; i<=n; ++i) {\n\t\tfind(i);\n\t}\n}\n\nbool check(int n) {\n\tM.clear();\n\tupdate(n);\n\tfor(int i=1; i<=n; ++i) {\n\t\tif(!M.count(N[i].group)) {\n\t\t\tM[N[i].group] = N[i].parent;\n\t\t}else {\n\t\t\tif(N[i].parent!=M[N[i].group]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n, m, xx, yy;\n\tdouble ans=0.0;\n\tpriority_queue<Graph> q;\n\tGraph g;\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; ++i) {\n\t\tcin >> N[i].x >> N[i].y;\n\t\tN[i].parent = i;\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> g.frm >> g.to;\n\t\txx = N[g.to].x-N[g.frm].x;\n\t\tyy = N[g.to].y-N[g.frm].y;\n\t\tg.w = xx*xx+yy*yy;\n\t\tq.push(g);\n\t\tunion_node(g.frm, g.to);\n\t}\n\tupdate(n);\n\tfor(int i=1; i<=n; ++i) {\n\t\tN[i].group = N[i].parent;\n\t\tN[i].parent = -1;\n\t}\n\twhile(!q.empty()) {\n\t\tg = q.top(); q.pop();\n\t\tif(find(g.frm)!=find(g.to)) union_node(g.frm, g.to);\n\t\telse ans += sqrt((double)g.w);\n\t\tif(check(n)) break;\n\t}\n\twhile(!q.empty()) {\n\t\tg = q.top(); q.pop();\n\t\tans += sqrt((double)g.w);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define N 100005\n#define P pair<int,int>\n#define ll long long\n#define mk(a, b) make_pair(a, b)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\nint inf = 0x3f3f3f3f;\nint n, m, pre[N];\ndouble sum;\nbool vis[N];\ndouble dis[N];\nstruct ac{\n\tint v;\n\tdouble c;\n};\nvector<P> a(N);\nvector<ac> g[N];\nvoid init() {\n\tfor (int i = 1; i <N; ++i) {\n\t\tpre[i] = i;\n\t}\n}\nint find(int x) {\n\tif (x == pre[x])\treturn x;\n\telse \treturn pre[x] = find(pre[x]);\n}\nvoid join(int x, int y) {\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy)\treturn;\n\telse if (fx < fy)\tpre[fy] = fx;\n\telse \tpre[fx] = fy;\n}\n\n// 求最大生成树\nvoid prim(int x) {\n\tmem(dis, 0);\n\tmem(vis, false);\n\tfor (int i = 0; i < g[x].size(); ++i) {\n\t\tac t = g[x][i];\n\t\tdis[t.v] = t.c;\n\t}\n\tvis[x] = true;\n\tfor (int i = 1; i < n; ++i) {\n\t\tdouble MAX = 0;\n\t\tint u = -1;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (vis[j])\tcontinue;\n\t\t\tif (dis[j] > MAX) {\n\t\t\t\tMAX = dis[j];\n\t\t\t\tu = j;\n\t\t\t}\n\t\t}\n\t\tif (u == -1)\treturn;\n\t\tvis[u] = true;\n\t\tsum += MAX;\n\t\tfor (int j = 0; j < g[u].size(); ++j) {\n\t\t\tac t = g[u][j];\n\t\t\tif (vis[t.v])\tcontinue;\n\t\t\tif (dis[t.v] < t.c ) {\n\t\t\t\tdis[t.v] = t.c;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n// #ifndef ONLINE_JUDGE\n//     freopen(\"in.txt\", \"r\", stdin);\n// #endif\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m) {\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tint dx = a[u].first - a[v].first;\n\t\t\tint dy = a[u].second - a[v].second;\n\t\t\tdouble temp = sqrt(dx * dx + dy * dy);\n\t\t\tans += temp;\n\t\t\t// 建图\n\t\t\tg[u].push_back((ac){v, temp});\n\t\t\tg[v].push_back((ac){u, temp});\n\t\t\tjoin(u, v);\n\t\t}\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\t// 求这个并查集的最大生成树\n\t\t\tif (pre[i] == i) {\n\t\t\t\tsum = 0;\n\t\t\t\tprim(i);\n\t\t\t\tans -= sum;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\",ans);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#define _CRT_SBCURE_NO_DEPRECATE\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n//#define UP(i,x,y) for(int i=x;i<=y;i++)\n//#define DOWN(i,x,y) for(int i=x;i>=y;i--)\n#define sdddd(x,y,z,k) scanf(\"%d%d%d%d\", &x, &y, &z, &k)\n#define sddd(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define sdd(x,y) scanf(\"%d%d\", &x, &y)\n#define sd(x) scanf(\"%d\", &x)\n#define mp make_pair\n#define pb push_back\n#define lson k<<1\n#define rson k<<1|1\n#define mid (l+r)/2\n#define ms(x, y) memset(x, y, sizeof x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define MOD 1000000007\nconst int maxn = 10050;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\nint n, m, s, t;\nint len;\nstruct road\n{\n    int u, v;\n    double cost;\n};\nint arr[maxn][2];\nroad G[maxn];\nint par[maxn<<1];\nvoid init()\n{\n    for(int i = 0; i < maxn<<1; i++) par[i] = i;\n}\n\nint Find(int x)\n{\n    return par[x]==x? x : par[x] = Find(par[x]);\n}\nbool same(int x, int y)\n{\n    int fx = Find(x), fy = Find(y);\n    if(fx == fy)return true;\n    else        return false;\n}\nvoid unite(int x, int y)\n{\n    int fx = Find(x), fy = Find(y);\n    if(fx == fy) return;\n    else{\n        par[fx] = fy;\n        return;\n    }\n}\nbool cmp(road a, road b)\n{\n    return a.cost>b.cost;\n}\ndouble kruskal()\n{\n    sort(G, G+len, cmp);\n    init();\n    double res = 0;\n    int cnt = 1;\n    for(int i = 0; i < len; i++)\n    {\n        road e = G[i];\n        if(!same(e.u, e.v))\n        {\n            unite(e.u, e.v);\n            res+=e.cost;\n            cnt++;\n        }\n    }\n    return res;\n}\ndouble dist(double x, double y, double u, double v)\n{\n    return sqrt(abs(x-u)*abs(x-u) + abs(y-v)*abs(y-v));\n}\nset<pair<int,int> > st;\nint main()\n{\n\t//freopen(\"out.txt\", \"w\", stdout);\n    while(~sdd(n,m))\n    {\n        ms(G,0);\n        len = 0;\n        int ta, tb;\n        for(int i = 1; i <= n; i++)\n        {\n            sdd(arr[i][0], arr[i][1]);\n        }\n        double sum = 0;\n        for(int i = 1; i <= m; i++)\n        {\n            sdd(ta, tb);\n            if(!st.count(mp(ta, tb)))\n            {\n                G[len].u = ta;\n                G[len].v = tb;\n                G[len].cost = dist(arr[ta][0],arr[ta][1],arr[tb][0],arr[tb][1]);\n                sum += G[len].cost;\n                len++;\n                st.insert(mp(ta, tb));\n            }\n        }\n        double ans = sum - kruskal();\n        printf(\"%.3f\\n\", ans);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <assert.h>\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define SZ(a) (int)(a).size()\n#define FOR(i,a,b) for (int i=(a); i<=(b); ++i)\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define ALL(c) c.begin(), c.end()\n#define CLR(c,n) memset(c, n, sizeof(c))\n#define TR(it, c) for(typeof(c.begin()) it = c.begin();it != c.end(); ++it)\n#define CONTAIN(it, c) (c.find(it) != c.end())\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntemplate <class T> void checkmin(T &a, T b) { if (b<a) a=b; }\ntemplate <class T> void checkmax(T &a, T b) { if (b>a) a=b; }\nconst int INF=0x3F3F3F3F;\n\ntypedef pair<double, int> P;\nconst int N=10000;\nint n, m;\nint x[N], y[N];\nvector<P> edge[N];\ndouble best[N];\nbool v[N];\nint main(int argc, char *argv[]) {\n  while (scanf(\"%d %d\", &n, &m) == 2) {\n    REP(i, n) scanf(\"%d %d\", &x[i], &y[i]);\n    vector<PII> e(m);\n    REP(i, m) {\n      scanf(\"%d %d\", &e[i].first, &e[i].second);\n      --e[i].first;\n      --e[i].second;\n      if (e[i].first > e[i].second) swap(e[i].first, e[i].second);\n    }\n    sort(e.begin(), e.end());\n    REP(i, n) edge[i].clear();\n    double ans = 0;\n    for (int start = 0; start < SZ(e); ) {\n      int end = start;\n      while (end < SZ(e) && e[end] == e[start]) ++end;\n      int i = e[start].first, j = e[start].second;\n      double dist = hypot(x[j] - x[i], y[j] - y[i]) * (end - start);\n      ans += dist;\n      edge[i].push_back(P(dist, j));\n      edge[j].push_back(P(dist, i));\n      start = end;\n    }\n    CLR(best, 0);\n    CLR(v, 0);\n    REP(id, n) if (!v[id]) {\n      priority_queue<P> q;\n      q.push(P(0.0, id));\n      while (!q.empty()) {\n        int idx = q.top().second;\n        q.pop();\n        if (v[idx]) continue;\n        v[idx] = true;\n        ans -= best[idx];\n        REP(i, SZ(edge[idx])) {\n          int next = edge[idx][i].second;\n          if (!v[next] && best[next] < edge[idx][i].first) {\n            best[next] = edge[idx][i].first;\n            q.push(P(best[next], next));\n          }\n        }\n      }\n    }\n    printf(\"%.3f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<functional>\n#define mem(a) memset(a,0,sizeof(a))\n#define pi acos(-1)\nusing namespace std;\n//并?集部分\nint par[10005],ran[10005];\nvoid init(int n)\n{\n    for(int i=0;i<n;i++)\n    {\n        par[i]=i;\n        ran[i]=0;\n    }\n}\nint find(int x)\n{\n    if(par[x]==x)return x;\n    else {\n        return par[x]=find(par[x]);\n    }\n}\nvoid unite(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(ran[x]<ran[y])\n    {\n        par[x]=y;\n    }\n    else par[y]=x;\n    if(ran[x]==ran[y])\n        ran[x]++;\n}\nbool same(int x,int y)\n{\n    return find(x)==find(y);\n}\n//\n//克?斯????\nstruct edge\n{\n    int u, v;\n    double cost;\n    edge(int u = 0, int v = 0, double cost = 0) : u(u), v(v), cost(cost) {}\n    bool operator < (const edge & e2) const\n    {\n        return cost > e2.cost;\n    }\n};\n\nedge es[50000005];\nint V, E;\ndouble kruskal()\n{\n    sort(es, es + E);    // 按照??从小到大排序\n    init(V);\n    double res = 0;\n    for (int i = 0; i < E; ++i)\n    {\n        edge e = es[i];\n        if (!same(e.u, e.v))\n        {\n            unite(e.u, e.v);\n        }\n        else\n        {\n            res += e.cost;\n        }\n    }\n    \n    return res;\n}\n\npair<int, int> pile[10005];\n//\n//主程序\nint main()\n{\n    cin>>V>>E;\n    for(int i=0;i<V;i++)\n    {\n        cin>>pile[i].first>>pile[i].second;\n    }\n    for(int i=0;i<E;i++)\n    {\n        cin >> es[i].u >> es[i].v;\n        --es[i].u; --es[i].v;\n        int dx = pile[es[i].u].first - pile[es[i].v].first;\n        int dy = pile[es[i].u].second - pile[es[i].v].second;\n        es[i].cost=sqrt(dx * dx + dy * dy);\n    }\n    cout.setf(ios::showpoint);\n    cout.precision(3);\n    cout.setf(ios::fixed);\n    cout << kruskal() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nstruct node{\n    int x,y;\n}no[10005];\nstruct edge{\n    int from,to;\n    double dis;\n}ed[200000];\nbool cmp(const edge &a,const edge &b){\n    return a.dis>b.dis;\n}\nint father[10005];\nint find(int who){\n    if(who==father[who]) return who;\n    else return father[who]=find(father[who]);\n}\nint main(void){\n    int n,m;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>no[i].x>>no[i].y;\n        father[i]=i;\n    }\n    double ans=0;\n    for(int i=1;i<=m;i++){\n        int a,b;\n        cin>>a>>b;\n        ed[i].from=a;\n        ed[i].to=b;\n        ed[i].dis= pow(pow(no[a].x-no[b].x,2)+pow(no[a].y-no[b].y,2),0.5);\n        ans+=ed[i].dis;\n    }\n    //cout<<ans<<endl;\n    sort(ed+1,ed+1+m,cmp);\n    for(int i=1;i<=m;i++){\n        int x=find(ed[i].from);\n        int y=find(ed[i].to);\n        if(x!=y){\n            if(x<y)\n                father[x]=father[y];\n            else\n                father[y]=father[x];\n            ans-=ed[i].dis;\n            //cout<<ed[i].dis<<\":  \"<<ed[i].from<<\"---\"<<ed[i].to<<endl;\n            //for(int j=1;j<=n;j++)\n            //    cout<<father[j]<<\" \";\n            //cout<<endl;\n        }\n    }\n    printf(\"%.3lf\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\ndouble dist(double x, double y){\n  return sqrt(x*x + y*y);\n}\n\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int x[10000], y[10000];\n    REP(i, N)cin>>x[i]>>y[i];\n    vector<int> edges[10000];\n    double ans = 0;\n    REP(i, M){\n      int u, v; cin>>u>>v; u--; v--;\n      edges[u].push_back(v);\n      edges[v].push_back(u);\n      ans += dist(x[u]-x[v], y[u]-y[v]);\n    }\n    vector<bool> used(N);\n    priority_queue<P> que;\n    REP(i, N)if(!used[i]){\n      que.push(P(0, i));\n      while(!que.empty()){\n        P p = que.top(); que.pop();\n        if(used[p.second]) continue;\n        used[p.second] = true;\n        ans -= p.first;\n        REP(j, edges[p.second].size()){\n          int to = edges[p.second][j];\n          double d = dist(x[p.second]-x[to], y[p.second]-y[to]);\n          que.push(P(d, to));\n        }\n      }\n    }\n    printf(\"%.3lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  double kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  printf(\"%.3lf\\n\", g.sum - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\nstruct edge{\n    int to;double cost;\n    edge(int a,double b):to(a),cost(b){}\n    edge(){}\n    bool operator<(const edge &d)const{\n        return cost<d.cost;\n    }\n};\nint main(){\n    int n,m;\n    cin>>n>>m;\n    int x[10000],y[10000];\n    for(int i=0;i<n;i++)\n        cin>>x[i]>>y[i];\n\n    vector<vector<edge> >V(n);\n    double sum=0;\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;a--;b--;\n        double dis=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n        sum+=dis;\n        V[a].push_back(edge(b,dis));\n        V[b].push_back(edge(a,dis));\n    }\n    bool used[10000];fill(used,used+10000,false);\n    double res=0;\n    priority_queue<edge>Q;\n    Q.push(edge(0,0));\n    while(Q.size()){\n        int to=Q.top().to;double cost=Q.top().cost;\n        Q.pop();\n        if(used[to])continue;\n        used[to]=true;\n        res+=cost;\n        for(int i=0;i<V[to].size();i++){\n            Q.push(V[to][i]);\n        }\n    }\n    cout<<fixed<<sum-res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nstruct edge{int u, v; double cost; };\nint n, m;\nint rank[10000], par[10000];\nedge es[100000];\ndouble a;\n\nvoid init(int x){\n\trep(i,x){\n\t\trank[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\t\n\tif(rank[x] < rank[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost > e2.cost;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> n >> m;\n\tVp node(n);\n\trep(i,n) cin >> node[i].fi >> node[i].sec;\n\trep(i,m){\n\t\tint tmp1, tmp2;\n\t\tcin >> tmp1 >> tmp2;\n\t\ttmp1--; tmp2--;\n\t\tedge e;\n\t\te.u = tmp1; e.v = tmp2;\n\t\te.cost = sqrt((node[tmp1].fi-node[tmp2].fi)*(node[tmp1].fi-node[tmp2].fi)+(node[tmp1].sec-node[tmp2].sec)*(node[tmp1].sec-node[tmp2].sec));\n\t\tes[i] = e;\n\t\ta += e.cost;\n\t}\n\tsort(es, es+m, comp);\n\tinit(n);\n\tdouble ans = 0.0;\n\trep(i,m){\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tans += e.cost;\n\t\t}\n\t}\n\tcout << a-ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[12000];\nint N, M, a, b; double x[12000], y[12000], d[12000]; int g[12000];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\tfor (int t = 1; t <= N; t++) {\n\t\tif (g[t] >= 2)continue;\n\t\td[t] = 0; g[t] = 1;\n\t\twhile (true) {\n\t\t\tint OK = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1)OK = 0;\n\t\t\t}\n\t\t\tif (OK == 1)break;\n\t\t\tdouble maxn = -1; int maxid = 0;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[maxid] = 2;\n\t\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to;\n\t\tdouble cost;\n\t};\n\tvector<edge>G;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,double c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tdouble krk(){\n\t\tdouble sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost>b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\tvi x(n),y(n);\n\trep(i,n)cin>>x[i]>>y[i];\n\tdouble sum=0;\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tdouble cost=hypot(x[a]-x[b],y[a]-y[b]);\n\t\tsum+=cost;\n\t\tkrk.add_edge(a,b,cost);\n\t}\n\tcout<<shosu(9)<<sum-krk.krk()<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\ndouble distance( PII a, PII b )\n{\n\treturn sqrt( pow( a.fst - b.fst, 2. ) + pow( a.snd - b.snd, 2. ) );\n}\n\nstruct Edge\n{\n\tint from, to;\n\tdouble cost;\n\n\tEdge( int f, int t, double c ) : from( f ), to( t ), cost( c )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator > ( const Edge &a ) const\n\t{\n\t\treturn cost > a.cost;\n\t}\n};\n\nclass UnionFind\n{\nprivate:\n\tvector<int> ary;\n\tvector<int> rank;\n\npublic:\n\tUnionFind( int n ) : ary( n ), rank( n, 0 )\n\t{\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tary[i] = i;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( ary[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ary[x] = find( ary[x] );\n\t\t}\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tvoid unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tary[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tary[y] = x;\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector< PII > piles( n );\n\n\tEACH( pile, piles )\n\t{\n\t\tcin >> pile.fst >> pile.snd;\n\t}\n\n\tvector< Edge > E;\n\n\tREP( i, 0, m )\n\t{\n\t\tint p, q;\n\t\tcin >> p >> q;\n\n\t\tp--;\n\t\tq--;\n\n\t\tE.PB( Edge( p, q, distance( piles[p], piles[q] ) ) );\n\t}\n\n\tsort( ALL( E ), greater< Edge >() );\n\n\tUnionFind uf( n );\n\n\tdouble res = 0;\n\n\tREP( i, 0, E.size() )\n\t{\n\t\tif ( uf.same( E[i].from, E[i].to ) )\n\t\t{\n\t\t\tres += E[i].cost;\n\t\t\tcontinue;\n\t\t}\n\n\t\tuf.unite( E[i].from, E[i].to );\n\t}\n\n\tcout.precision( 5 );\n\tcout << fixed;\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\n\n\ntypedef pair<int,int> pi;\ntypedef pair<double,pi> pdi;\n#define MK make_pair\n#define F first\n#define S second\nconst int MX=1e9+7;\nvector<int> a[16000];\nbool done[20000]={};\n\ndouble dis(pi c,pi b){\n    return (double)pow((c.F-b.F)*(c.F-b.F)+(c.S-b.S)*(c.S-b.S),1.0/2);\n}\n\nint DFS(int s,int g){\n    done[s]=true;\n    int count=0;\n    for(int i=0;i<a[s].size();i++){\n        if(!done[a[s][i]]){\n            if(a[s][i]==g){count++; continue;}\n            count+=DFS(a[s][i],g);\n            if(count>=2){break;}\n        }\n    }\n    return count;\n}\n\nint main(){\n    cout<<fixed<<setprecision(12);\n    int n,m;\n    vector<pi> point;\n    \n    priority_queue<pdi> q;\n    point.push_back(MK(0,0));\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n        int s,g;\n        cin>>s>>g;\n        point.push_back(MK(s,g));\n    }\n    for(int i=0;i<m;i++){\n        int s,g;\n        cin>>s>>g;\n        a[s].push_back(g);\n        a[g].push_back(s);\n        q.push(MK(-1.0*dis(point[s],point[g]),MK(s,g)));\n    }\n    double count=0;\n    \n    while(!q.empty()){\n        pdi di=q.top();\n        q.pop();\n        int l=DFS(di.S.F,di.S.S);\n        fill(&done[0],&done[15000],false);\n        for(int i=0;i<a[di.S.F].size();i++){\n            if(a[di.S.F][i]==di.S.S){a[di.S.F].erase(a[di.S.F].begin()+i);}\n        }\n        for(int i=0;i<a[di.S.S].size();i++){\n            if(a[di.S.S][i]==di.S.F){a[di.S.S].erase(a[di.S.S].begin()+i);}\n        }\n        if(l<2){continue;}\n        //cout<<count<<\" + \"<<di.F<<\" \"<<di.S.F<<\" \"<<di.S.S<<endl;\n        count-=di.F;\n    }\n     \n    cout<<count<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#define MAX_N 10005\n\nusing namespace std;\n\ntypedef pair<int, int> P;\nstruct edge {\n  int u, v;\n  double cost;\n  edge() {}\n  edge(int U, int V, double C): u(U), v(V), cost(C) {}\n};\nvector<edge> G;\nP cord[MAX_N];\nint par[MAX_N];\nint N, M;\n\nbool compare(edge a, edge b) {\n  return a.cost < b.cost;\n}\nvoid init() {\n  for (int i = 1; i <= N; i++) par[i] = i;\n}\nint find(int x) {\n  if (par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n  par[x] = y;\n}\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\ndouble get_dis(P a, P b) {\n  return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\ndouble kruscal() {\n  init();\n  sort(G.begin(), G.end(), compare);\n  double res = 0.0;\n  for (int i = 0; i < G.size(); i++) {\n    edge e = G[i];\n    if (!same(e.u, e.v)) {\n      res += e.cost;\n      unite(e.u, e.v);\n    }\n  }\n  return res;\n}\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  double total_cost = 0.0;\n  for (int i = 1; i <= N; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    cord[i] = make_pair(x, y);\n  }\n  for (int i = 0; i < M; i++) {\n    int p, q;\n    scanf(\"%d%d\", &p, &q);\n    double d = get_dis(cord[p], cord[q]);\n    total_cost += d;\n    G.push_back(edge(p, q, -d));\n  }\n  printf(\"%.3lf\\n\", total_cost + kruscal());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n\nstruct edge\n{\n\tint f,t;\n\tdouble v;\n}edg[20010];\n\nstruct xy\n{\n\tint x,y;\n}mypoint[1000010];\n\nint pre[20010];\nint n,m;\n\nvoid init()\n{\n\tfor(int i=0;i<=n;i++)\n\t\tpre[i]=i;\n}\nint find(int x)\n{\n\tif(pre[x]==x)\n\t\treturn x;\n\telse\n\t\treturn pre[x]=find(pre[x]);\n}\nvoid join(int x,int y)\n{\n\tint fx=find(x);\n\tint fy=find(y);\n\tpre[fx]=fy;\n}\nbool cmp(edge a,edge b)\n{\n\treturn a.v>b.v;\n}\ndouble Kruskal()\n{\n\tsort(edg,edg+m,cmp);\n\tdouble ans=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=find(edg[i].f);\n\t\tint v=find(edg[i].t);\n\t\tif(u!=v)\n\t\t{\n\t\t\tjoin(u,v);\n\t\t\tans+=edg[i].v;\n\t\t}\n\t}\n\treturn ans;\n}\ndouble distance(int a,int b)\n{\n\treturn sqrt((double)((mypoint[a].x-mypoint[b].x)*(mypoint[a].x-mypoint[b].x)+(mypoint[a].y-mypoint[b].y)*(mypoint[a].y-mypoint[b].y)));\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d\",&mypoint[i].x,&mypoint[i].y);\n\tdouble sum=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tedg[i].f=x;\n\t\tedg[i].t=y;\n\t\tedg[i].v=distance(x,y);\n\t\tsum+=edg[i].v;\n\t}\n\tdouble res=Kruskal();\n\tprintf(\"%.3f\\n\",sum-res);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint p[40002],p2[502];\nint r[40002],r2[502];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<pair<double,double> > v;\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\tpriority_queue<pair<double,pair<int,int> > >node;\n\tdouble ans = 0;\n\trep(i,m){\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tp--;\n\t\tq--;\n\t\tdouble w;\n\t\tdouble x,y;\n\t\tx = v[p].first - v[q].first;\n\t\ty = v[p].second - v[q].second;\n\t\tw = sqrt(x*x+y*y);\n\t\tans += w;\n\t\tnode.push(MP(w,MP(p,q)));\n\t}\n\tinit(n+2);\n\twhile(!node.empty()){\n\t\tpair<double,pair<int,int> > k = node.top();\n\t\tnode.pop();\n\t\tdouble w1 = k.first;\n\t\tint x,y;\n\t\tx = k.second.first;\n\t\ty = k.second.second;\n\t\tif(find(x)==find(y))continue;\n\t\tunion_set(x,y);\n\t\tans -=w1;\n\t}\n\tcout.precision(15);\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <string.h>\n\nusing namespace std;\ndouble cost[10001][10001];\ndouble mincost[10001];\nbool used[10001];\nconst double INF=100000000;\nint x[10001],y[10001];\n\ndouble prim(int V){\n  for(int i=1; i<=V; ++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n\n  mincost[1]=0;\n  double res=0;\n\n while(true){\n  int v = -1;\n  for(int u=1; u<=V; u++){\n    if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n  }\n\n  if(v==-1) break;\n  used[v]=true;\n  res+=mincost[v];\n\n  for(int u=1; u<=V; u++){\n    mincost[u]=min(mincost[u],cost[v][u]);\n  }\n }\n return res;\n}\n\nint main(){\n\n   int N,M; cin>>N>>M;\n\n   fill(cost[0],cost[10001],0);\n\n   for(int i=1; i<=N; i++){\n\n     cin>>x[i]>>y[i];\n\n     }\n\n    double mx=0;\n\n   for(int i=0; i<M; i++){\n\n     int a,b; cin>>a>>b;\n\n     int u = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n     cost[a][b]=-sqrt(u);\n     int v = (x[b]-x[a])*(x[b]-x[a])+(y[b]-y[a])*(y[b]-y[a]);\n     cost[b][a]=-sqrt(v);\n\n     mx+=-cost[a][b];\n\n     }\n\n     cout<<mx+prim(N)<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define all(x) begin(x),end(x)\n\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld EPS = 1e-9;\n\ntemplate<class T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream &operator<<(ostream &os, const edge &e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    const int n;\n    UnionFind(int n) : n(n), par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return sz[root(x)];\n    }\n\n    friend ostream& operator<<(ostream& os, UnionFind& uf) {\n        os << \"[\";\n        for (int i = 0; i < uf.n; ++i) {\n            if (i > 0) os << \" \";\n            os << uf.root(i);\n        }\n        return os << \"]\" << endl;\n    }\n};\n\n\ntemplate<typename T>\nT kruskal(const vector<edge<T>> &es, int V) {\n\n    UnionFind uf(V);\n    T ret = 0;\n\n    vector<int> ord(es.size());\n    iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](int i,int j){\n        return es[i].cost > es[j].cost;\n    });\n\n    for (auto i : ord) {\n        auto &e = es[i];\n        if (!uf.issame(e.src, e.to)) {\n            ret += e.cost;\n            uf.merge(e.src, e.to);\n        }\n    }\n\n    return ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m; cin >> n >> m;\n    vector<complex<double>> p(n);\n    REP(i, n)  {\n        double x, y; cin >> x >> y;\n        p[i] = { x, y };\n    }\n\n    vector<edge<double>> edges(m);\n    REP(i, m) {\n        int u, v; cin >> u >> v; --u, --v;\n        edges[i] = { u, v, abs(p[u] - p[v]) };\n    }\n\n    double sum = 0;\n    REP(i, m) sum += edges[i].cost;\n\n    sum -= kruskal(edges, n);\n    cout << sum << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<cmath>\n#define MAX 10000\n#define MP make_pair\n#define INF (1<<21)\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\nint parent[MAX];\n\nint findRoot(int x)\n{\n\tif (parent[x] != x)\n\t{\n\t\tparent[x] = findRoot(parent[x]);\n\t}\n\telse\n\t{\n\t\treturn x;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn findRoot(x) == findRoot(y);\n}\n\nvoid unite(int x, int y)\n{\n\tint root1 = findRoot(x);\n\tint root2 = findRoot(y);\n\tparent[root1] = root2;\n}\n\ntypedef double Weight;\ntypedef pair<int, int> Pair;\ntypedef pair<Weight, Pair> Edge;\n\npriority_queue<Edge> q;\n\ndouble kruskal()\n{\n\tREP(i, MAX)\n\t{\n\t\tparent[i] = i;\n\t}\n\tdouble total = 0.0;\n\tdouble total_ans = 0.0;\n\twhile (!q.empty())\n\t{\n\t\tEdge top = q.top();\n\t\tint X = top.second.first;\n\t\tint Y = top.second.second;\n\t\tif (same(X, Y) == false)\n\t\t{\n\t\t\tunite(X, Y);\n\t\t\ttotal += top.first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotal_ans += top.first;\n\t\t}\n\t\tq.pop();\n\t}\n\treturn total_ans;\n}\n\npair<int,int> Z[MAX];\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tREP(i, N)\n\t{\n\t\tint px, py;\n\t\tcin >> px >> py;\n\t\tZ[i] = MP(px, py);\n\t}\n\tREP(i, M)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tdouble tmp_x = Z[x-1].first - Z[y-1].first;\n\t\tdouble tmp_y = Z[x-1].second - Z[y-1].second;\n\t\tdouble w = sqrt(tmp_x*tmp_x + tmp_y*tmp_y);\n\t\tq.push(MP(w, MP(x, y)));\n\t}\n\n\t//cout << fixed << setprecision(10) << kruskal() << endl;\n\t\n\tprintf(\"%lf\\n\",kruskal());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int u,v; double cost;\n  Edge(){}\n  Edge(int u, int v, double cost):u(u),v(v),cost(cost){}\n  bool operator<(const Edge &a)const{\n    return cost < a.cost;\n  }\n};\n\nstruct UnionFind{\n  int par[10005];\n  int rank[10005];\n  UnionFind(int n){ init(n); }\n  void init(int n){\n    for(int i=0;i<n;i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  int same(int x, int y){\n    return find(x) == find(y);\n  }\n  void unite(int x, int y){\n    x = find(x); y = find(y);\n    if(x==y) return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n};\n\nEdge es[50000000];\nint N,M;\nint x[10005],y[10005];\n\ndouble kruskal(){\n  UnionFind uf(N);\n  double res = 0;\n  sort(es, es+M);\n  for(int i=0;i<M;i++){\n    Edge e = es[i];\n    if(!uf.same(e.u, e.v)){\n      uf.unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n  \nint main(){\n  double sum = 0.0;\n\n  scanf(\"%d%d\",&N,&M);\n  rep(i,N) scanf(\"%d%d\", &x[i],&y[i]);\n  rep(i,M){\n    int p,q;\n    scanf(\"%d%d\",&p,&q); p--; q--;\n    es[i] = Edge(p,q, -sqrt(SQ(x[p]-x[q])+SQ(y[p]-y[q])));\n    sum += sqrt(SQ(x[p]-x[q])+SQ(y[p]-y[q]));\n  }\n  //  printf(\"%lf %lf\\n\",sum,kruskal());\n  printf(\"%lf\\n\", sum+kruskal());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\ntypedef struct {\n    int x, y;\n} Pile;\n\ntypedef struct {\n    int a, b;\n    double cost;\n} Edge;\n\nbool operator < (const Edge& l, const Edge& r){\n    return l.cost < r.cost;\n}\n\nint _par[MAX_N];\nint _rank[MAX_N];\n\nvoid init(int n){\n    for(int i=0; i<n; i++){\n        _par[i] = i;\n        _rank[i] = 0;\n    }\n}\n\nint root(int x){\n    if(x == _par[x])\n        return x;\n    return _par[x] = root(_par[x]);\n}\n\nvoid unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    \n    if(_rank[x] < _rank[y]){\n        _par[x] = y;\n    }else{\n        _par[y] = x;\n        if(_rank[x] == _rank[y])\n            _rank[x]++;\n    }\n}\n\nbool is_same_group(int x, int y){\n    return root(x) == root(y);\n}\n\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Pile> piles(n);\n    for(int i=0; i<n; i++){\n        auto & pile = piles[i];\n        cin >> pile.x >> pile.y;\n    }\n    \n    priority_queue<Edge> edges;\n    for(int i=0; i<m; i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        \n        double cost = sqrt((piles[a].x-piles[b].x)*(piles[a].x-piles[b].x) + (piles[a].y-piles[b].y)*(piles[a].y-piles[b].y));\n        \n        Edge edge;\n        edge.a = a; edge.b = b; edge.cost = cost;\n        \n        edges.push(edge);\n    }\n    \n    double ans = 0;\n    \n    init(n);\n    while(!edges.empty()){\n        Edge edge = edges.top(); edges.pop();\n        \n        if(is_same_group(edge.a, edge.b)){\n            ans += edge.cost;\n        }else{\n            unite(edge.a, edge.b);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef double Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight < f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n};\n\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\ntypedef complex<double> P;\nP p[10000];\n\nint main() {\n  int n,m;\n  while(cin>>n>>m) {\n    REP(i,n) {\n      cin >> p[i].real() >> p[i].imag();\n    }\n    Graph g(n);\n    double ans = 0;\n    REP(i,m) {\n      int a, b;\n      cin >> a >> b;\n      a--; b--;\n      g[a].push_back(Edge(a,b,abs(p[a]-p[b])));\n      //cout << a << \" \" << b << \"!\" << abs(p[a]-p[b]) << endl;\n      ans += abs(p[a]-p[b]);\n      g[b].push_back(Edge(b,a,abs(p[a]-p[b])));\n    }\n    ans -= minimumSpanningForest(g).first;\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef double Weight;\n\nconst double INF = 1e+10;\nint N;\n\nstruct Edge{\n  int src, dest; Weight weight;\n  bool operator < (const Edge &rhs) const {return weight < rhs.weight;}\n};\n\nstruct UnionFind {\n  vector<int> p;\n  UnionFind (int n) { p.assign(n, -1); }\n  int root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n  void merge(int x, int y) { if (root(x) != root(y)) p[root(y)] = x; }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nEdges kruskal(Edges &es) {\n\tsort(es.begin(), es.end()); \n\tUnionFind uf(N);\n\tEdges res;\n\tREP(i, es.size()) {\n\t\tEdge e = es[i];\n\t\tif(uf.root(e.src) != uf.root(e.dest)) {\n\t\t\tuf.merge(e.src, e.dest);\n\t\t\tres.push_back(e);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<int> x(n);\n  vector<int> y(n);\n  REP(i,n)cin>>x[i]>>y[i];\n  Edges g;\n  double wsum = 0;\n  REP(i,m){\n    int p,q;\n    cin>>p>>q;\n    --p;--q;\n    int dx = x[p]-x[q];\n    int dy = y[p]-y[q];\n    g.push_back({p,q,40000-sqrt(dx*dx+dy*dy)});\n    wsum += sqrt(dx*dx+dy*dy);\n  }\n  N = n;\n  auto trr = kruskal(g);\n  for(auto e:trr)\n    wsum -= 40000-e.weight;\n  cout << setprecision(8) << fixed << wsum << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct fence{\n  int u,v;\n  double cost;\n};\n\n#define N 10000\n\nint par[N];\nint urank[N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i] = i;\n    urank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x==y)return;\n\n  if(urank[x]<urank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(urank[x]==urank[y])urank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\ndouble distance(int x1,int y1,int x2,int y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool cmp(const fence &a,const fence &b){\n  return a.cost > b.cost;\n}\n\nint main(){\n  int n,m;\n  P piles[N];\n  vector<fence> fences;\n\n  scanf(\"%d%d\",&n,&m);\n  for(int i=0;i<n;i++){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    piles[i] = P(x,y);\n  }\n  for(int i=0;i<m;i++){\n    int p,q;\n    scanf(\"%d%d\",&p,&q);\n    p--;q--;\n    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);\n    fences.push_back((fence){p,q,c});\n  }\n\n  double sum = 0;\n  init(n);\n  sort(fences.begin(),fences.end(),cmp);\n  for(int i=0;i<m;i++){\n    int u = fences[i].u;\n    int v = fences[i].v;\n    if(same(u,v)){\n      sum += fences[i].cost;\n    }else{\n      unite(u,v);\n    }\n  }\n\n  printf(\"%.3f\\n\",sum);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll; \n#define PI 3.14159265\n\nstruct edge {\n\tint from, to;\n\tdouble cost;\n\tedge() {};\n\tedge(int a, int b, double c) {from=a, to=b, cost=c;}\n\n\tbool operator<(edge& rhs) {\n\t\treturn cost > rhs.cost;\n\t}\n};\nvector<edge> e;\n\nint x[10101];\nint y[10101];\nint n, m;\nint par[10101];\nint cnt[10101];\n\nvoid init(int n)\n{\n\trep(i,0,n) {\n\t\tpar[i] = i;\n\t\tcnt[i] = 1;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) \n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (cnt[x] > cnt[y]) swap(x,y);\n\tpar[x] = y;\n\tcnt[y] += cnt[x];\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\ndouble kruskal()\n{\n\tsort(all(e));\n\tinit(n);\n\tdouble ret = 0;\n\trep(i,0,len(e)) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tret += e[i].cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tdouble sum = 0;\n\tcin >> n >> m;\n\trep(i,0,n) cin >> x[i] >> y[i];\n\trep(i,0,m) {\n\t\tint a,b; cin>>a>>b;\n\t\ta--; b--;\n\t\tif (a>b) swap(a,b);\n\t\tdouble c = sqrt(abs(x[a]-x[b])*abs(x[a]-x[b]) + abs(y[a]-y[b])*abs(y[a]-y[b]));\n\t\te.pb(edge(a,b,c));\n\t\t// printf(\"edge%d : a=%d b=%d c=%lf\\n\",i,a,b,c);\n\t\tsum += c;\n\t}\n\tdouble t = kruskal();\n\tcout << sum-t << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\n#define inf 1<<30\n#define ll long long\n#define db double\n#define c233 cout<<\"233\"<<endl\n#define mem(s) memset(s,0,sizeof(s))\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\nconst int N=10050;\nusing namespace std;\n\nstruct lll{\n  int x,y;\n}p[N];\nstruct hhh{\n  int a,b;\n  db len;\n  bool operator <(const hhh &a)const{\n    return len>a.len;\n  }\n}e[N*10];\nint fa[N];\nint n,m;\ndb sum,mst;\n\nvoid fre(){\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n}\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=(x<<1)+(x<<3)+ch-48,ch=getchar();\n  return x*res;\n}\n\ndb len(lll x,lll y){\n  return sqrt((1.0*(x.x-y.x)*(x.x-y.x)+1.0*(x.y-y.y)*(x.y-y.y)));\n}\n\nvoid init(){\n  n=gi();m=gi();\n  for(int i=1;i<=n;i++)\n    p[i].x=gi(),p[i].y=gi();\n  for(int i=1;i<=m;i++){\n    e[i].a=gi(),e[i].b=gi();\n    e[i].len=len(p[e[i].a],p[e[i].b]);\n    sum+=e[i].len;\n  }\n}\n\nint getfa(int x){\n  return fa[x]==x?fa[x]:fa[x]=getfa(fa[x]);\n}\n\nvoid merge(int a,int b){\n  int f1=getfa(a),f2=getfa(b);\n  fa[f1]=f2;\n}\n\nvoid work(){\n  for(int i=1;i<=n;i++)fa[i]=i;\n  for(int i=1;i<=m;i++){\n    if(getfa(e[i].a)!=getfa(e[i].b))\n      merge(e[i].a,e[i].b),mst+=e[i].len;\n  }\n  printf(\"%.3lf\\n\",sum-mst);\n}\n\nint main(){\n  //fre();\n  init();\n  sort(e+1,e+1+n);\n  work();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 10000\n\nint N, M;\nint par[MAX], rank[MAX];\ntypedef pair<double,double> P;\nvoid init(){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nstruct edge{\n  int u,v;\n  double cost;\n};\n\nbool comp(const edge &e1,const edge &e2){\n  return e1.cost > e2.cost;\n}\n\nedge es[MAX];\n\ndouble kruskal(){\n  init(); sort(es , es + M, comp);\n  double res = 0;\n  for(int i = 0 ; i < M ; i++){\n    edge e = es[i];\n    if(!same(e.u , e.v)){\n      unite(e.u , e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2));\n}\n\nint main(){\n  int a,b;\n  P p[MAX];\n\n  scanf(\"%d %d\" ,&N ,&M);\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&p[i].first, &p[i].second);\n  }\n  double total = 0;\n  for(int i = 0 ; i < M ; i++){\n    scanf(\"%d %d\" ,&a ,&b);  \n    a--, b--;\n    double d = dist(p[a], p[b]);\n    es[i].u = a; es[i].v = b; es[i].cost = d;\n    total += d;\n  }\n  printf(\"%.5f\\n\",total-kruskal());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 10000;\n\n/* typedef */\n\ntypedef pair<double,double> pdd;\n\nstruct Edge {\n  double d;\n  int i, j;\n  Edge() {}\n  Edge(double _d, int _i, int _j): d(_d), i(_i), j(_j) {}\n  bool operator>(const Edge& e) const { return d > e.d; }\n};\n\ntypedef vector<Edge> ve;\n\nstruct UFT {\n  int links[MAX_N], ranks[MAX_N], sizes[MAX_N];\n  UFT() {}\n\n  void clear(int n) {\n    for (int i = 0; i < n; i++)\n      links[i] = i, ranks[i] = sizes[i] = 1;\n  }\n\n  int root(int i) {\n    int i0 = i;\n    while (links[i0] != i0) i0 = links[i0];\n    return (links[i] = i0);\n  }\n\n  int rank(int i) { return ranks[root(i)]; }\n  int size(int i) { return sizes[root(i)]; }\n  bool same(int i, int j) { return root(i) == root(j); }\n  \n  int merge(int i0, int i1) {\n    int r0 = root(i0), r1 = root(i1);\n    int mr;\n    if (ranks[r0] == ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      ranks[r0]++;\n      mr = r0;\n    }\n    else if (ranks[r0] > ranks[r1]) {\n      links[r1] = r0;\n      sizes[r0] += sizes[r1];\n      mr = r0;\n    }\n    else {\n      links[r0] = r1;\n      sizes[r1] += sizes[r0];\n      mr = r1;\n    }\n    return mr;\n  }\n};\n\n/* global variables */\n\nint n, m;\npdd pts[MAX_N];\nve edges;\nUFT uft;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  cin >> n >> m;\n\n  for (int i = 0; i < n; i++) cin >> pts[i].first >> pts[i].second;\n\n  for (int k = 0; k < m; k++) {\n    int i, j;\n    cin >> i >> j;\n    i--, j--;\n\n    double dx = pts[j].first - pts[i].first;\n    double dy = pts[j].second - pts[i].second;\n    double d = sqrt(dx * dx + dy * dy);\n\n    edges.push_back(Edge(d, i, j));\n  }\n  sort(edges.begin(), edges.end(), greater<Edge>());\n\n  uft.clear(n);\n\n  double sum = 0.0;\n\n  for (int k = 0; k < m; k++) {\n    Edge& e = edges[k];\n\n    if (uft.same(e.i, e.j))\n      sum += e.d;\n    else\n      uft.merge(e.i, e.j);\n  }\n\n  printf(\"%.3lf\\n\", sum);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SQ(X) ((X)*(X))\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[10010],rank[10010];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t\tpar[x]=y;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint a,b;\n\tdouble len;\n\tedge(){a=b=0;len=0.0;}\n\tedge(int a,int b,double len):a(a),b(b),len(len){};\n\tbool operator<(const edge& a) const{\n\t\treturn len > a.len;\n\t}\n};\nint N,M;\ndouble x[10010],y[10010];\nint p[10010],q[10010];\ndouble dist(int a,int b){\n\treturn sqrt(SQ(x[a]-x[b])+SQ(y[a]-y[b]));\n}\nvector<edge> es;\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tdouble ans = 0.0;\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d %d\",&p[i],&q[i]);\n\t\tp[i]--;\n\t\tq[i]--;\n\t\tes.pb(edge(p[i],q[i],dist(p[i],q[i])));\n\t}\n\tsort(all(es));\n\tuf.init(N);\n\tfor(int i=0;i<es.size();i++){\n\t\tint a = es[i].a;\n\t\tint b = es[i].b;\n\t\tif(uf.same(a,b))ans += es[i].len;\n\t\telse{\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N + 1], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N + 1; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N; j++)\n\tif(forest[t1][j] == 0)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 1000005\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\n#include<stdio.h>\n#include<queue>\n#define INF 0x3f3f3f3f\ntypedef long long ll;\nusing namespace std;\n\n#define  N 11000\n\nstruct Edge\n{\n    int u,v;\n    double d;\n}edge[N*N/2+10];\n\nstruct node\n{\n    double x,y;\n}p[N];\n\nint n,m;\nint father[N];\n\nint cmp(struct Edge h,struct Edge f)\n{\n    return h.d>f.d;\n}\n\ndouble Dist(node a,node b)\n{\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nint Find(int x)\n{\n    while(x!=father[x])\n        x=father[x];\n    return x;\n}\n\nint main()\n{\n    int i,a,b;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        for(i=1;i<=n;i++)\n            father[i]=i;\n\n        for(i=1;i<=n;i++)\n        {\n            scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n        }\n\n        double sum=0.0;   ///sum是巫婆?得??和\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            edge[i].u=a;\n            edge[i].v=b;\n            edge[i].d=Dist(p[a],p[b]);\n            sum=sum+edge[i].d;\n        }\n\n        sort(edge,edge+m,cmp);\n\n        double s=0.0;   ///??不用抹去的?，?似Kruskal求最小生成?\n        for(i=0;i<m;i++)\n        {\n            int x,y;\n            x=Find(edge[i].u);\n            y=Find(edge[i].v);\n            if(x!=y)\n            {\n                if(x>y)\n                    father[x]=y;\n                else\n                    father[y]=x;\n\n                s=s+edge[i].d;\n            }\n            else\n                continue;\n        }\n        double ans=0.0;\n        ans=sum-s;  \n        printf(\"%.3f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<queue>\nusing namespace std;\nconst int maxn = 1e4+7;\nint N,M;\npair <int,int> piles[maxn];\n\ndouble cal(int a, int b){\n\treturn sqrt( (piles[a].first-piles[b].first)*(piles[a].first-piles[b].first) +\n\t\t\t\t (piles[a].second-piles[b].second)*(piles[a].second-piles[b].second) );\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tbool operator> (const edge &e1)const{\n\t\treturn cost>e1.cost;\n\t}\n};\nedge es[20500];\n\nint par[1500];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y)\n\t\tpar[x]=y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(~scanf(\"%d%d\",&N,&M)){\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tcin>>piles[i].first>>piles[i].second;\n\t\t}\n\t\tdouble tot = 0;\n\t\tint a,b;\n\t\tfor(int i=0; i<M; i++){\n\t\t\tcin>>es[i].u>>es[i].v;\n\t\t\tes[i].cost=cal(es[i].u,es[i].v);\n\t\t\ttot+=es[i].cost;\n\t\t}\n\t\tsort(es,es+M,greater<edge>());\n\t\tinit(N);\n\t\tdouble remain=0;\n\t\tint cur=0;\n\t\tfor(int i=0; i<M; ++i){\n\t\t\tif(find(es[i].u)==find(es[i].v))\n\t\t\t\tcontinue;\n\t\t\t++cur;\n\t\t\tremain+=es[i].cost;\n\t\t\tunite(es[i].u,es[i].v);\n\t\t\tif(cur==N-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%.3f\\n\",tot-remain);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\nusing namespace std;\nstruct edge {\n    int to;\n    double cost;\n};\nconst int MAX_N = 10005;\nint N, M;\nint X[MAX_N], Y[MAX_N];\ndouble d[MAX_N];\nbool used[MAX_N];\nvector<edge> G[MAX_N];\n\n//2点間の距離を返す\ndouble dist(int a, int b) {\n    unsigned int num = (X[a]-X[b]) * (X[a]-X[b]) + (Y[a]-Y[b])*(Y[a]-Y[b]);\n    double ret = sqrt(num);\n    return ret;\n}\n\nint main(int argc, const char * argv[])\n{\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n    }\n    double ret = 0;\n    for (int i = 0; i < M; i++) {\n        int a,b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        double d = dist(a, b);\n        //printf(\"%d-%d:%f\\n\",a,b,d);\n        ret += d;\n        edge e1, e2;\n        e1.to = b;\n        e2.to = a;\n        e1.cost = e2.cost = -d;  //負にすることで最大全域木を計算\n        G[a].push_back(e1);\n        G[b].push_back(e2);\n    }\n    for (int i = 0; i < N; i++) d[i] = 0;\n    fill(used, used+N, false);\n    //プリム法\n    while (true) {\n        int v = -1;\n        for (int i = 0; i < N; i++) {\n            if (!used[i] && (v == -1 || d[v] > d[i])) v = i;\n        }\n        if (v == -1) break;\n        //頂点vを集合xに加える\n        used[v] = true;\n        ret += v[d];\n        //集合xまでの最短距離を更新\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            edge e = G[v][i];\n            if (d[e.to] > e.cost) {\n                d[e.to] = e.cost;\n            }\n        }\n    }\n    printf(\"%.3f\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define _for(i,a,b) for(int i=(a);i<(b);i++)\n#define _rep(i,a,b) for(int i=(a);i>(b);i--)\n#define _for1(i,a,b) for(int i=(a);i<=(b);i++)\n#define _rep1(i,a,b) for(int i=(a);i>=(b);i--)\nusing namespace std;\nconst int MAXN=10000;   //  最大点数\nint F[MAXN+10];    //  并查集使用\nstruct Edge\n{\n    int u;      //  起点\n    int v;      //  终点\n    double w;      //  权值\n} edge[MAXN+10];   // 存储边的信息\nstruct node{\nint x,y;\n};\nstruct node T[MAXN+10];\nint tol; //  边数，加边前赋值为0\nvoid addEdge(int u,int v,double w)\n{\n    edge[tol].u=u;\n    edge[tol].v=v;\n    edge[tol++].w=w;\n}\nbool cmp(Edge a,Edge b)\n{\n    //  排序函数，将边按照权值从小到大排序\n    return a.w > b.w;\n}\nint find(int x)\n{\n    if(F[x]==x)\n        return x;\n    else\n        return F[x]=find(F[x]);\n}\ndouble Kruskal(int n)  //  传入点数，返回最小生成树的权值，如果不连通则返回-1\n{\n    for(int i=0;i<=n;i++)\n        F[i]=i;\n    sort(edge,edge+tol,cmp);\n    int cnt=0;    //  计算加入的边数\n    double ans=0;\n    for(int i=0;i<tol;i++)\n    {\n        int u=edge[i].u;\n        int v=edge[i].v;\n        double w=edge[i].w;\n        int tOne=find(u);\n        int tTwo=find(v);\n        if(tOne!=tTwo)\n        {\n            ans+=w;\n            F[tOne]=tTwo;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    int n,m;\n    while(~scanf(\"%d%d\",&n,&m)){\n        memset(edge,0,sizeof(edge));\n        _for(i,0,n)\n            scanf(\"%d%d\",&T[i].x,&T[i].y);\n        double sum=0.0;\n        _for(i,0,m){\n            int p,q;\n            scanf(\"%d%d\",&p,&q);\n            double distant=sqrt((T[p-1].x-T[q-1].x)*(T[p-1].x-T[q-1].x)\n                                +(T[p-1].y-T[q-1].y)*(T[p-1].y-T[q-1].y));\n            addEdge(p,q,distant);\n            sum+=distant;\n        }\n        sum-=Kruskal(n);\n        printf(\"%.3lf\\n\",sum);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0 && k < N) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N; j++)\n\tif(forest[t1][j] == 0)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0 && k < N) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll; \n#define PI 3.14159265\n\nstruct edge {\n\tint from, to;\n\tdouble cost;\n\tedge() {};\n\tedge(int a, int b, double c) {from=a, to=b, cost=c;}\n\n\tbool operator<(edge& rhs) {\n\t\treturn cost > rhs.cost;\n\t}\n};\nvector<edge> e;\n\nint x[10101];\nint y[10101];\nint n, m;\nint par[10101];\nint cnt[10101];\n\nvoid init(int n)\n{\n\trep(i,0,n) {\n\t\tpar[i] = i;\n\t\tcnt[i] = 1;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) \n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (cnt[x] > cnt[y]) swap(x,y);\n\tpar[x] = y;\n\tcnt[y] += cnt[x];\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\ndouble kruskal()\n{\n\tsort(all(e));\n\tinit(n);\n\tdouble ret = 0;\n\trep(i,0,len(e)) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tret += e[i].cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tdouble sum = 0;\n\tcin >> n >> m;\n\trep(i,0,n) cin >> x[i] >> y[i];\n\trep(i,0,m) {\n\t\tint a,b; cin>>a>>b;\n\t\ta--; b--;\n\t\tif (a>b) swap(a,b);\n\t\tdouble c = sqrt(abs(x[a]-x[b])*abs(x[a]-x[b]) + abs(y[a]-y[b])*abs(y[a]-y[b]));\n\t\te.pb(edge(a,b,c));\n\t\t// printf(\"edge%d : a=%d b=%d c=%lf\\n\",i,a,b,c);\n\t\tsum += c;\n\t}\n\tdouble t = kruskal();\n\tcout << sum-t << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<queue>\n#include<cmath>\nusing namespace std;\nint n,m,i,j,uu,o;\ndouble ans;\nbool b[10005];\nstruct zb\n{\n\tint x,y;\n}d[10005];\nstruct edge\n{\n\tint u;\n\tdouble c;\n\tedge(int uu,double cc)\n\t{\n\t\tu=uu,c=cc;\n\t}\n\tbool operator<(const edge &a)const\n\t{\n\t\treturn c < a.c;\n\t}\n};\ndouble jl(int a,int b)\n{\n\treturn sqrt((d[a].x-d[b].x)*(d[a].x-d[b].x)+(d[a].y-d[b].y)*(d[a].y-d[b].y));\n}\nvector<edge> e[10005];\npriority_queue<edge> q;\nint main()\n{\n\tint x,y,a,b1;\n\tscanf(\"%d %d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d %d\",&x,&y);\n\t\td[i].x=x,d[i].y=y;\n\t}\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d %d\",&a,&b1);\n\t\tans=ans+jl(a,b1);\n\t\te[a].push_back(edge(b1,jl(a,b1)));\n\t\te[b1].push_back(edge(a,jl(a,b1)));\n\t}\n\twhile(uu<n)\n\t{\n\t\to=1;\n\t\twhile(b[o]!=0)\n\t\t\to++;\n\t\tb[o]=1;\n\t\tfor(i=0;i<int(e[o].size());i++)\n\t\tq.push(e[o][i]);\n\t\tuu++;\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tedge k=q.top();\n\t\t\tq.pop();\n\t\t\tif(b[k.u]==1)continue;\n\t\t\tuu++;\n\t\t\tb[k.u]=1;\n\t\t\tans=ans-k.c;\n\t\t\tfor(i=0;i<int(e[k.u].size());i++)\n\t\t\t{\n\t\t\t\tq.push(e[k.u][i]);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.3f\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nstruct edge{int u, v; double cost; };\nint n, m;\nint rank[10000], par[10000];\nedge es[100000];\ndouble a;\n\nvoid init(int x){\n\trep(i,x){\n\t\trank[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\t\n\tif(rank[x] < rank[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost > e2.cost;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\tVp node(n);\n\trep(i,n) scanf(\"%d%d\", &node[i].fi, &node[i].sec);\n\trep(i,m){\n\t\tint tmp1, tmp2;\n\t\tscanf(\"%d%d\", &tmp1, &tmp2);\n\t\ttmp1--; tmp2--;\n\t\tedge e;\n\t\te.u = tmp1; e.v = tmp2;\n\t\te.cost = sqrt((node[tmp1].fi-node[tmp2].fi)*(node[tmp1].fi-node[tmp2].fi)+(node[tmp1].sec-node[tmp2].sec)*(node[tmp1].sec-node[tmp2].sec));\n\t\tes[i] = e;\n\t\ta += e.cost;\n\t}\n\tsort(es, es+m, comp);\n\tinit(n);\n\tdouble ans = 0.0;\n\trep(i,m){\n\t\tedge e = es[i];\n\t\tif(!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tans += e.cost;\n\t\t}\n\t}\n\tprintf(\"%0.5f\\n\", a-ans); \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<queue>\nusing namespace std;\nconst int maxn = 10010;\nint N,M;\npair <int,int> piles[maxn];\n\ndouble cal(int a, int b){\n\treturn sqrt( (piles[a].first-piles[b].first)*(piles[a].first-piles[b].first) +\n\t\t\t\t (piles[a].second-piles[b].second)*(piles[a].second-piles[b].second) );\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tbool operator> (const edge &e1)const{\n\t\treturn cost>e1.cost;\n\t}\n};\nedge es[100500];\n\nint par[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<=n; i++){\n\t\tpar[i]=i;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x!=y)\n\t\tpar[x]=y;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(~scanf(\"%d%d\",&N,&M)){\n\t\tfor(int i=1; i<=N; i++){\n\t\t\tcin>>piles[i].first>>piles[i].second;\n\t\t}\n\t\tdouble tot = 0;\n\t\tint a,b;\n\t\tfor(int i=0; i<M; i++){\n\t\t\tcin>>es[i].u>>es[i].v;\n\t\t\tes[i].cost=cal(es[i].u,es[i].v);\n\t\t\ttot+=es[i].cost;\n\t\t}\n\t\tsort(es,es+M,greater<edge>());\n\t\tinit(N);\n\t\tdouble remain=0;\n\t\tint cur=0;\n\t\tfor(int i=0; i<M; ++i){\n\t\t\tif(find(es[i].u)==find(es[i].v))\n\t\t\t\tcontinue;\n\t\t\t++cur;\n\t\t\tremain+=es[i].cost;\n\t\t\tunite(es[i].u,es[i].v);\n\t\t\tif(cur==N-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tprintf(\"%.3f\\n\",tot-remain);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"cmath\"\n#include \"cstdio\"\n#include \"algorithm\"\nusing namespace std;\n\nconst int maxn=10100;\nstruct edge {int u,v;double w;};\nedge edges[maxn*maxn];\nint f[maxn],n,m,p;\ndouble tot,res;\nint wx[maxn],wy[maxn];\n\ndouble dis(int i,int j){return sqrt( 1.0*(wx[i]-wx[j])*(wx[i]-wx[j]) + (wy[i]-wy[j])*(wy[i]-wy[j]) );}\n\nint find(int x){return f[x]==x?f[x]:f[x]=find(f[x]);}\nint cmp(edge a,edge b){return a.w>b.w;}\n\n\nvoid add(int u,int v,double w)\n{\n\tedges[++p].u=u;\n\tedges[p].v=v;\n\tedges[p].w=w;\n}\n\nint main()\n{\n\t//freopen(\"v.txt\",\"r\",stdin);\n\t//tot=res=.0;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&wx[i],&wy[i]);\n\t\tf[i]=i;\n\t}\n\t\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tadd(u,v,dis(u,v));\n\t\ttot=tot+dis(u,v);\n\t}\n\t\n\tsort(edges+1,edges+p+1,cmp);\n\tfor(int i=1;i<=p;i++)\n\t{\n\t\tedge &e=edges[i];\n\t\tif(find(e.u)!=find(e.v))\n\t\t{\n\t\t\tres=res+e.w;\n\t\t\tf[find(e.u)]=find(e.v);\n\t\t}\n\t}\n\t\n\tprintf(\"%.3f\\n\",tot-res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(const int& n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\n// int find(const int& x){\n// \tif(pa[x]==x) return x;\n// \telse pa[x] = find(pa[x]);\n// }\nint find(const int& x)\n{\n\tif (pa[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn pa[x] = find(pa[x]);\n\t}\n}\n\n// void unite(int x,int y){\n// \tx = find(x); y = find(y);\n\n// \tif(x==y) return;\n// \tif(ran[x] < ran[y]){\n// \t\tpa[x] = y;\n// \t}else{\n// \t\tpa[y] = x;\n// \t\tif(ran[x] == ran[y])\n// \t\t\t++ran[x];\n// \t}\n// }\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (ran[x] < ran[y])\n\t{\n\t\tpa[x] = y;\n\t}\n\telse\n\t{\n\t\tpa[y] = x;\n\t\tif (ran[x] == ran[y])\n\t\t{\n\t\t\t++ran[x];\n\t\t}\n\t}\n}\n\nbool same(const int& x,const int& y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<iomanip>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n#define MAX 1000000\n\nusing namespace std;\ntypedef pair<double,double> dd;\nint N,M;\nint par[MAX];\n\nvoid init()\n{\n  rep(i,MAX)par[i] = i;\n}\n\nint find(int x)\n{\n  if(x == par[x])return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x!=y)par[x] = y;\n}\n\nbool same(int x,int y)\n{\n  return find(x) == find(y);\n}\n\nstruct Pox\n{\n  int from,to;\n  double cost;\n  Pox(int from=-1,int to=-1,double cost=0):from(from),to(to),cost(cost){}\n};\n\n\n\nbool cmp(const Pox &p1, const Pox& p2)\n{\n  return p1.cost > p2.cost;\n}\n\ndouble kruskal(vector<Pox> &G)\n{\n  sort(G.begin(),G.end(),cmp);\n  double res = 0;\n  rep(i,G.size())\n    {\n      Pox pox = G[i];\n      if(!same(pox.from,pox.to))\n\t{\n\t  unit(pox.from,pox.to);\n\t  res += pox.cost;\n\t}\n    }\n  return res;\n}\n\n\nint main()\n{\n  while(cin >> N >> M)\n    {\n      init();\n      vector<Pox> G;\n      vector<dd> coor(N+1);\n      REP(i,1,N+1)cin >> coor[i].F >> coor[i].S;\n\n      double totalCost = 0;\n      rep(i,M)\n\t{\n\t  int f,t;\n\t  cin >> f >> t;\n\t  double cost = sqrt(pow(coor[f].F-coor[t].F,2)+pow(coor[f].S-coor[t].S,2));\n\t  totalCost += cost;\n\t  G.push_back(Pox(f,t,cost));\n\n\t}\n\n      cout << setiosflags(ios::fixed) << setprecision(10) << totalCost - kruskal(G) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint n,m;\nstruct edge{\n    int u,v;\n    double w;\n    edge(int _u,int _v,double _w):u(_u),v(_v),w(_w){}\n    bool operator<(const edge& b)const{\n        return w > b.w;\n    }\n};\nvector<edge> ve;\nint parent[1005];\nint findSet(int u)\n{\n    if(parent[u]==u)\n        return u;\n    return parent[u] = findSet(parent[u]);\n}\nvoid Union(int x,int y)\n{\n    int px = findSet(x);\n    int py = findSet(y);\n    if(px!=py)\n        parent[px]=py;\n}\nbool isSameSet(int x,int y){\n    return findSet(x) == findSet(y);\n}\nvector<pii> vp;\n\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&n,&m)){\n        for(int i=0;i<=n;i++) parent[i]=i;\n        ve.clear();\n        vp.clear();\n        for(int i=0;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            vp.push_back(make_pair(x,y));\n        }\n        double ori=0;\n        for(int i=0;i<m;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            u--,v--;\n            pii p1 = vp[u];\n            pii p2 = vp[v];\n            double w = sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n            ori += w;\n            ve.push_back(edge(u,v,w));\n        }\n        sort(ve.begin(),ve.end());\n        double MaxST = 0;\n        for(int i=0;i<ve.size();i++){\n            edge e = ve[i];\n            if(!isSameSet(e.u,e.v)){\n                Union(e.u,e.v);\n                MaxST += e.w;\n            }\n        }\n        printf(\"%.3lf\\n\",ori-MaxST);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <sstream>\n#include <iostream>\n#include <cassert>\n#include <complex>\n#include <queue>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define FOR(i, k, n) for (int i = (k); i < (int)(n); ++i)\n#define FOREQ(i, k, n) for (int i = (k); i <= (int)(n); ++i)\n#define DEC(i, k) for (int i = (k); i >= 0; --i)\n#define FORIT(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define SZ(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), (h), sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef complex<double> Point;\n\nstruct UnionFind {\n  int parent[10010];\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) { return true; }\n    if (parent[x] > parent[y]) { swap(x, y); }\n    parent[x] += parent[y];\n    parent[y] = x;\n    return false;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) { return parent[x] < 0 ? x : parent[x] = root(parent[x]); }\n};\n\nstruct Edge {\n  int from;\n  int to;\n  double cost;\n  Edge() {;}\n  Edge(int from, int to, double cost) : from(from), to(to), cost(cost) {;}\n  bool operator<(const Edge &rhs) const {\n    return cost < rhs.cost;\n  }\n};\n\nint n, m;\nPoint pile[10100];\nvector<Edge> edges;\nUnionFind uset;\n\nint main()\n{\n  memset(&uset, -1, sizeof(uset));\n  scanf(\"%d %d\", &n, &m);\n  REP(i, n) {\n    double x, y;\n    scanf(\"%lf %lf\", &x, &y);\n    pile[i] = Point(x, y);\n  }\n  edges.resize(m);\n  REP(i, m) {\n    int from, to;\n    scanf(\"%d %d\", &from, &to);\n    from--; to--;\n    edges[i] = Edge(from, to, abs(pile[from] - pile[to]));\n  }\n  sort(edges.begin(), edges.end());\n  reverse(edges.begin(), edges.end());\n  double ans = 0.0;\n  REP(i, m) {\n    if (uset.unionSet(edges[i].from, edges[i].to)) {\n      ans += edges[i].cost;\n    }\n  }\n  printf(\"%.3lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nvector<int> g[10010];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<vector<double>> v;\n\tvector<int> h(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--, b--;\n\t\tdouble dist = sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b]));\n\t\tv.push_back({ dist, (double)a, (double)b });\n\t\th[a]++, h[b]++;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\t\n\tsort(v.begin(), v.end());\n\t\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (h[v[i][1]] <= 1 || h[v[i][2]] <= 1) continue;\n\t\tret += v[i][0];\n\t\th[v[i][1]]--, h[v[i][2]]--;\n\t\tint now = v[i][1];\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\tnow = v[i][2];\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(5) << ret << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = maxn*maxn/2+1;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nclass union_find{\n\tvector<int> a;\npublic:\n\tunion_find(int n):a(n,-1){}\n\tint find(int x){\n\t\tif(a[x]<0) return x;\n\t\treturn a[x]=find(a[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y){ a[x]+=a[y]; a[y]=x; }\n\t}\n\tint size(int x){ return -a[find(x)]; }\n};\n\ntemplate<class T>\nstruct edge{\n\tint u,v;\n\tT cost;\n\tbool operator<(const edge &e)const{ return cost>e.cost; }\n};\n\ntemplate<class T>\nT Kruskal(int n,int m,edge<T> *E){\n\tif(n<=1) return 0;\n\n\tT tot=0;\n\tunion_find U(n);\n\tsort(E,E+m);\n\trep(i,m){\n\t\tif(U.find(E[i].u)!=U.find(E[i].v)){\n\t\t\tU.unite(E[i].u,E[i].v);\n\t\t\ttot+=E[i].cost;\n\t\t\tif(U.size(E[i].u)==n) return tot;\n\t\t}\n\t}\n\treturn tot;\n}\n\nint main(){\n\tint n,m; scanf(\"%d%d\",&n,&m);\n\tint x[10000],y[10000];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\tdouble ans=0;\n\tstatic edge<double> E[100000];\n\trep(i,m){\n\t\tint u,v; scanf(\"%d%d\",&u,&v); u--; v--;\n\t\tdouble cost=sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));\n\t\tE[i]=(edge<double>){u,v,cost};\n\t\tans+=cost;\n\t}\n\n\tans-=Kruskal(n,m,E);\n\n\tprintf(\"%.9f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nstruct Edge {\n    int p,q;\n    double c;\n    Edge(int p,int q,double c) {\n        this->p=p;\n        this->q=q;\n        this->c=c;\n    }\n    bool operator<(const Edge &a) const {\n        return (this->c)<a.c;\n    } \n};\nstruct UnionFind {\n    int *par;\n    int *rank;\n    UnionFind(int n) {\n        par=new int[n];\n        rank=new int[n];\n        for(int i=0;i<n;i++) {\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x) {\n        if(x==par[x]) {\n            return x;\n        }else {\n            return par[x]=find(par[x]);\n        }\n    }\n    void unite(int a,int b) {\n        a=find(a);\n        b=find(b);\n        if(a==b) return;\n        if(rank[a]<rank[b]) {\n            par[a]=b;\n        }else {\n            par[b]=a;\n            if(rank[a]==rank[b]) {\n                rank[a]++;\n            }\n        }\n    }\n    bool same(int a,int b) {\n        return find(a)==find(b);\n    }\n};\nint x[10000],y[10000];\nint main() {\n    int N,M;\n    scanf(\"%d %d\",&N,&M);\n    for(int i=0;i<N;i++) {\n        scanf(\"%d %d\",&x[i],&y[i]);\n    }\n    priority_queue<Edge> Q;\n    double sum=0;\n    for(int i=0;i<M;i++) {\n        int p,q;\n        scanf(\"%d %d\",&p,&q);p--;q--;\n        double len=sqrt(pow(x[p]-x[q],2)+pow(y[p]-y[q],2));\n        sum+=len;\n        Q.push(Edge(p,q,len));\n    }\n    UnionFind U(N);\n    double ans=0;\n    while(!Q.empty()) {\n        Edge e=Q.top();Q.pop();\n        if(!U.same(e.p,e.q)) {\n            U.unite(e.p,e.q);\n            ans+=e.c;\n        }\n    }\n    printf(\"%lf\\n\",sum-ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef pair<double, P> E;\nconst int NN=10001;\nint rep[NN];\nint weight[NN];\nP pos[NN];\nint Find(int i){\n\twhile(i!=rep[i]){\n\t\ti=rep[i]=rep[rep[i]];\n\t}\n\treturn i;\n}\nint Union(int i, int j){\n\tif(weight[i]<weight[j]){\n\t\tswap(i,j);\n\t}\n\trep[j]=i;\n\tweight[i]+=weight[j];\n}\ninline double len(P a, P b){\n\tdouble s=a.first-b.first;\n\tdouble t=a.second-b.second;\n\treturn sqrt(s*s+t*t);\n}\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=1;i<=N;i++){\n\t\trep[i]=i;\n\t\tweight[i]=1;\n\t\tcin >> pos[i].first >> pos[i].second;\n\t}\n\tvector<E> edge(M);\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedge[i]=E(len(pos[a],pos[b]),P(a,b));\n\t}\n\tdouble ret=0;\n\tsort(edge.begin(),edge.end(),greater<E>());\n\tfor(int i=0;i<edge.size();i++){\n\t\tint a=edge[i].second.first;\n\t\tint b=edge[i].second.second;\n\t\ta=Find(a);\n\t\tb=Find(b);\n\t\tif(a!=b){\n\t\t\tUnion(a,b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret+=edge[i].first;\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <stack>\n#include <string>\n#include <cmath>\n#include <cstdlib>\n#include <set>\nusing namespace std;\n\n#define M 1e9+7\ntypedef long long ll;\n#define  mem(a) memset(a,0,sizeof a)\n#define pi acos(-1.0)\n#define inf 0x3f3f3f\nstruct node\n{\n        int u,v;double w;\n}mp[100000];\nstruct node1\n{\n        double x,y;\n}c[10005];\nint n,m;\nint f[10005];\nbool cmp(node a,node b)\n{\n        return a.w > b.w;\n}\nint find(int x)\n{\n        while(x != f[x])\n                x = f[x];\n        return x;\n}\nint main()\n{\n        while(~scanf(\"%d %d\",&n,&m))\n        {\n                for(int i = 1 ; i <= n ; i ++)\n                        scanf(\"%lf %lf\",&c[i].x,&c[i].y);\n                for(int i = 0 ; i < m ; i ++)\n                {\n                        int a,b;\n                        scanf(\"%d %d\",&a,&b);\n                        mp[i].u = a;\n                        mp[i].v = b;\n                        mp[i].w = sqrt ((c[a].x-c[b].x )*(c[a].x-c[b].x) + (c[a].y-c[b].y)*(c[a].y - c[b].y));\n                }\n                sort(mp,mp+m,cmp);\n                double ans = 0;\n                for(int i = 1 ; i <= n ; i ++)\n                        f[i] = i;\n                for(int i = 0 ; i < m ; i ++)\n                {\n                        int a = mp[i].u;\n                        int b = mp[i].v;\n                        int fa = find(a);\n                        int fb = find(b);\n                        if(fa == fb)\n                                ans += mp[i].w;\n                        else\n                        {\n                                int mi = min(fa,fb);\n                                int ma = max(fa,fb);\n                                f[ma] = mi;\n                        }\n                }\n                printf(\"%.3f\\n\",ans);\n        }\n\n\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <set>\n\nusing namespace std;\n\nconst int INF = 1000000;\nconst int N_MAX = 10000;\n\nstruct edge {\n  double cost;\n  int from, to; \n  bool operator<(const edge &right) const {\n    if (cost == right.cost) {\n      if (from == right.from) return to < right.to;\n      else return from < right.from;\n    } else return cost < right.cost;\n  }\n};\n\nint main() {\n\n  int N, M;\n  double total = 0;\n  scanf(\"%d %d\", &N, &M);\n\n  bool used[N_MAX];\n  set<edge> edges;\n  int x[N_MAX];\n  int y[N_MAX];\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d %d\", &x[i], &y[i]);\n    used[i] = false;\n  }\n\n  for (int i = 0; i < M; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    a--; b--;\n    int dx = x[a] - x[b];\n    int dy = y[a] - y[b];\n    double cost = sqrt(dx*dx+dy*dy);\n    edge e1 = { -cost, a, b };\n    edges.insert(e1);\n    edge e2 = { -cost, b, a };\n    edges.insert(e2);\n    total += cost;\n  }\n\n  double cost = 0;\n  used[0] = true;\n  for (int i = 0; i < N; i++) {\n    bool flag = true;\n    for (set<edge>::iterator it = edges.begin(); it != edges.end(); it++) {\n      if (used[it->from] == true && used[it->to] == false) {\n        cost += it->cost;\n        used[it->to] = true;\n        flag = false;\n        break;\n      }\n    }\n    // new tree\n    if (flag) {\n      for (int i = 1; i < N; i++) {\n        if (!used[i]) {\n          used[i] = true;\n          break;\n        }\n      }\n    }\n  }\n  printf(\"%.4f\\n\", total+cost);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<queue>\n#include<string>\n#include<algorithm>\n#define MAXSIZE 1005\n#define LL long long\n#define INF 0x3f3f3f\nusing namespace std;\n\n/*一个邪?的女巫因?嫉?Nicholas家的猫可?，\n就施了魔法?他家的猫?困在卷子里出不来了（要不然??邪??）。\n?在?出?施魔法?出来的?的坐?，\n??i与??j（是一个整体，也就是?出了一条?，?的?度是第i个?与第j个??的?度）。\n?在??求最少需要破坏多?的??才能?可?的猫?都出来。*/\n\nint father[MAXSIZE];\n\nstruct node\n{\n    double x,y;\n}p[MAXSIZE];\n\nstruct node1\n{\n    double d;\n    int p1,p2;\n    bool operator > (const node1 &a)\n    {\n        return d > a.d;\n    }\n}l[MAXSIZE];\n\nbool cmp(struct node1 A,struct node1 B)\n{\n    return A.d > B.d;\n}\n\nint Find(int x)\n{\n    if(x!=father[x])\n        father[x] = Find(father[x]);\n    return father[x];\n}\n\ndouble Dist(double x1,double y1,double x2,double y2)\n{\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\nvoid Init(int n)\n{\n    for(int i=0;i<=n;i++)\n        father[i] = i;\n}\n\nint main()\n{\n    int u,v,n,m,cns;\n    double sum1,sum2;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        Init(n);\n        cns = 0;\n        sum1 = 0;\n        sum2 = 0;\n        for(int i=1;i<=n;i++)\n            scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&u,&v);\n            double d = Dist(p[u].x,p[u].y,p[v].x,p[v].y);\n            l[cns].p1 = u;\n            l[cns].p2 = v;\n            l[cns++].d = d;\n            sum1 += d;\n        }\n        sort(l,l+cns,cmp);\n        for(int i=0;i<cns;i++)\n        {\n            u = l[i].p1;\n            v = l[i].p2;\n            double d = l[i].d;\n            int fu = Find(u);\n            int fv = Find(v);\n            if(fu != fv)\n            {\n                sum2 += d;\n                father[fv] = fu;\n            }\n        }\n        printf(\"%.3f\\n\",sum1 - sum2);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii p(n);\n\trep(i, n)cin >> p[i].first >> p[i].second;\n\tvector<tuple<double, int, int>> f(m);\n\tunionfind uf(n);\n\trep(i, m) {\n\t\tint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tp1--;\n\t\tp2--;\n\t\tf[i] = tuple<double, int, int>{ hypot(p[p1].first - p[p2].first, p[p1].second - p[p2].second),p1,p2 };\n\t}\n\tsort(ALL(f), greater<tuple<double, int, int>>());\n\tdouble ans = 0;\n\trep(i, m) {\n\t\tif (!uf.same(get<1>(f[i]), get<2>(f[i])))uf.unite(get<1>(f[i]), get<2>(f[i]));\n\t\telse ans += get<0>(f[i]);\n\t}\n\tcout << fixed << setprecision(5) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2017/12/28  Problem: AOJ 2224 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224  ----- */\n/* ------問題------\n\n\n\n-----問題ここまで----- */\n/* -----解説等-----\n\n\n\n----解説ここまで---- */\n\n\n/*--------------\nkuraskal法(ElogE)\n最小全域木を最小の重みの辺を用いて作成する。\nその際集合の連結判定を高速に行いたいのでUFをつかう\n----------------*/\n/* Union Find */\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\nstruct edge {\n\tint f, t; long double c;\n\tedge(int x = 0, int y = 0, long double z = 0) :f(x), t(y), c(z) {}\n\tbool operator < (const edge &e) const { return c > e.c; };// max spanning tree\n};\nstruct KRUSKAL {\n\n\tlong double kruskal(int V, int E, vector<edge>& es, UnionFind & uf) {\n\t\tsort(es.begin(), es.end());\n\t\t//UnionFind uf(V);\n\t\tlong double min_cost = 0;\n\t\tFOR(i, 0, E) {\n\t\t\tif (!uf.same(es[i].f, es[i].t)) {\n\t\t\t\tmin_cost += es[i].c;\n\t\t\t\tuf.unionSet(es[i].f, es[i].t);\n\t\t\t}\n\t\t}\n\t\treturn min_cost;\n\t}\n};\n\n\nLL N;\n\ndouble ans = 0.0;\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tcin >> N;\n\tint M; cin >> M;\n\tvector<edge>ed(M);\n\tvector<double>x(N), y(N);\n\tFOR(i, 0, N) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tdouble csum = 0.0;\n\tFOR(i, 0, M) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tdouble c = sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b]));\n\t\t//debug(c);\n\t\ted[i] = edge(a, b, c);\n\t\tcsum += c;\n\t}\n\n\n\n\tUnionFind uf(N);\n\tKRUSKAL k;\n\tans = (csum) -(k.kruskal(N, M, ed, uf));\n\n\tcout << fixed<<setprecision(10)<<ans << \"\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nstruct Unionfind {\n  vector<int> size;\n  vector<int> par;\n\n  Unionfind( int n ) :  size(n, 1), par(n) {\n    iota( par.begin() , par.end() , 0 );\n  }\n\n  int find( int x ) {\n    if ( par[x] == x ) return x;\n    return par[x] = find( par[x] );\n  }\n\n  bool unite( int x , int y ) {\n    x = find(x);\n    y = find(y);\n    if ( x == y ) return false;\n\n    if ( size[y] < size[x] ) swap( x , y );\n\n    par[x] = y;\n    size[y] += size[x];\n\n    return true;\n  }\n\n  bool same( int x , int y ) {\n    return find(x) == find(y);\n  }\n};\ndouble dist(pair<int,int> a,pair<int,int> b)\n{\n  int x=a.first-b.first,y=a.second-b.second;\n  double answer=x*x+y*y;\n  answer=sqrt(answer);\n  return answer;\n}\nint main(void)\n{\n  int n,m;\n  cin >> n >> m;\n  vector<pair<int,int> > pos(n);\n  REP(i,n) cin >> pos[i].first >> pos[i].second;\n  Unionfind uf(n);\n  vector<tuple<double,int,int> > fence(m);\n  REP(i,m){\n    int p,q;\n    cin >> p >> q;\n    --p,--q;\n    fence[i]=make_tuple(-dist(pos[p],pos[q]),p,q);\n  }\n  SORT(fence);\n  double answer=0.0;\n  for(auto x:fence){\n    double negc,a,b;\n    tie(negc,a,b)=x;\n    if(!uf.unite(a,b)) answer+=-negc;\n  }\n  cout << fixed << setprecision(10) << answer << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\n/*\n <url:>\n 問題文============================================================\n \n =================================================================\n \n 解説=============================================================\n \n ================================================================\n */\n\nstruct UnionFind {\n    vector<int> par;\n    int n, cnt;\n    UnionFind(const int& x = 0) { init(x); }\n    void init(const int& x) { par.assign(cnt = n = x, -1); }\n    inline int find(const int& x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n    inline bool same(const int& x, const int& y) { return find(x) == find(y); }\n    inline bool unite(int x, int y) {\n        if ((x = find(x)) == (y = find(y))) return false;\n        --cnt;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    inline int count() const { return cnt; }\n    inline int count(int x) { return -par[find(x)]; }\n};\n\nstruct edge {\n    ll u;\n    ll v;\n    double cost;\n    edge() {}\n    edge(ll u, ll v, double c) :u(u), v(v), cost(c) {}\n    bool operator < (const edge& o) const {\n        return cost < o.cost;\n    }\n    bool operator > (const edge& o)const {\n        return cost > o.cost;\n    }\n};\ndouble hyp(ll x1,ll y1,ll x2,ll y2){\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    ll V, E; cin >> V >> E;\n    UnionFind uf(V);\n    vector<pll> ps(V);\n    for(auto& in:ps){\n        cin >> in.first >> in.second;\n    }\n    priority_queue<edge> G;\n    double all_sum = 0;\n    for (int i = 0; i < E;i++) {\n        ll s, t, w; cin >> s >> t;\n        s--; t--;\n        w = hyp(ps[s].first,ps[s].second,ps[t].first,ps[t].second);\n        all_sum += w;\n        G.push(edge(s, t, w));\n    }\n    double sum = 0;\n    while (!G.empty()) {\n        auto e = G.top(); G.pop();\n        if (uf.same(e.u, e.v)) continue;\n        uf.unite(e.u, e.v);\n        sum += e.cost;\n    }\n    cout << fixed << setprecision(10) << all_sum-sum << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<double, P> PP;\nint x[10000], y[10000];\nstruct UnionFind {\n\tint *par;\n\tint *rank;\n\tint size;\n\tUnionFind(int n) :size(n) {\n\t\tpar = new int[size];\n\t\trank = new int[size];\n\t\tfor (int i = 0; i < size; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n};\n\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tUnionFind U(N);\n\tvector<PP> e;\n\tdouble sum = 0;\n\tfor (int i = 0; i < M; i++) {\n\t\tint p, q;\n\t\tcin >> p >> q; p--; q--;\n\t\tdouble d = sqrt(pow(x[p] - x[q], 2) + pow(y[p] - y[q], 2));\n\t\tsum += d;\n\t\te.emplace_back(d, P(p, q));\n\t}\n\tsort(e.begin(), e.end());\n\tfor (auto itr = e.rbegin(); itr != e.rend(); itr++) {\n\t\tif (U.same(itr->second.first, itr->second.second)) continue;\n\t\tU.unite(itr->second.first, itr->second.second);\n\t\tsum -= itr->first;\n\t}\n\tprintf(\"%.15lf\\n\", sum);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int maxn=10100;\nconst int maxm=10000*10000/2;\nint par[maxn],rankl[maxn];\n\n//??¶??\\???\nvoid init(int n)\n{\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tpar[i]=i;\n\t\trankl[i]=0;\n\t}\n}\nint findl(int x)\n{\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=findl(par[x]);\n}\nvoid unite(int x,int y)\n{\n\tx=findl(x);\n\ty=findl(y);\n\tif(x==y)  return;\n\tif(rankl[x]<rankl[y]){\n\t\tpar[x]=y;\n\t}else\n\t{\n\t\tpar[y]=x;\n\t\tif(rankl[x]==rankl[y])  rankl[x]++;\n\t}\n}\nbool same(int x,int y)\n{\n\treturn findl(x)==findl(y);\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n};\nbool cmp(const edge e1,const edge e2)\n{\n\treturn e1.cost<e2.cost;\n}\nedge es[maxm];\nint n,m;\ndouble kruskal()\n{\n\tsort(es+1,es+m+1,cmp);\n\tinit(n);\n\tdouble res=0;\n\tfor(int i=1;i<=m;i++){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\ndouble  a[maxn],b[maxn];\nstruct app\n{\n\tint x,y;\n};\napp s[maxm];\ndouble distance(double x1,double y1,double  x2,double  y2)\n{\n\tdouble t1=(x1-x2)*(x1-x2);\n\tdouble t2=(y1-y2)*(y1-y2);\n\treturn sqrt(t1+t2);\n}\nint main()\n{\n    while(cin>>n>>m)\n\t{\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(b,9,sizeof(b));\n\t\tfor(int i=1;i<=n;i++)     //?????\\????????????\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&a[i],&b[i]);\n\t\t}\n\t\tdouble hh=0.0;\n\t\tfor(int i=1;i<=m;i++)   //?????\\????????????\n\t\t{\n\t\t\tscanf(\"%d%d\",&s[i].x,&s[i].y);\n\t\t\tint x=s[i].x,y=s[i].y;\n\t\t\tes[i].u=x,es[i].v=y;\n\t\t\tes[i].cost=-distance(a[x],b[x],a[y],b[y]);\n\t\t\t hh+=-es[i].cost;\n\t\t}\n\t\tdouble tt=0-kruskal();\n\t\tprintf(\"%.3lf\\n\",hh-tt);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\ntypedef struct {\n    int x, y;\n} Pile;\n\ntypedef struct {\n    int a, b;\n    double cost;\n} Edge;\n\nbool operator < (const Edge& l, const Edge& r){\n    return l.cost < r.cost;\n}\n\nint _par[MAX_N];\nint _rank[MAX_N];\n\nvoid init(int n){\n    for(int i=0; i<n; i++){\n        _par[i] = i;\n        _rank[i] = 0;\n    }\n}\n\nint root(int x){\n    if(x == _par[x])\n        return x;\n    return _par[x] = root(_par[x]);\n}\n\nvoid unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    \n    if(_rank[x] < _rank[y]){\n        _par[x] = y;\n    }else{\n        _par[y] = x;\n        if(_rank[x] == _rank[y])\n            _rank[x]++;\n    }\n}\n\nbool is_same_group(int x, int y){\n    return root(x) == root(y);\n}\n\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Pile> piles(n);\n    for(int i=0; i<n; i++){\n        Pile & pile = piles[i];\n        cin >> pile.x >> pile.y;\n    }\n    \n    priority_queue<Edge> edges;\n    for(int i=0; i<m; i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        \n        double cost = sqrt((piles[a].x-piles[b].x)*(piles[a].x-piles[b].x) + (piles[a].y-piles[b].y)*(piles[a].y-piles[b].y));\n        \n        Edge edge;\n        edge.a = a; edge.b = b; edge.cost = cost;\n        \n        edges.push(edge);\n    }\n    \n    double ans = 0;\n    \n    init(n);\n    while(!edges.empty()){\n        Edge edge = edges.top(); edges.pop();\n        \n        if(is_same_group(edge.a, edge.b)){\n            ans += edge.cost;\n        }else{\n            unite(edge.a, edge.b);\n        }\n    }\n    \n    printf(\"%.3lf\\n\", ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  vector<int> array[N];\n  int forest[N][N], i, j, k, t1, t2, s, t;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    array[i].push_back(i + 1);\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      for(k = 0; k < array[j].size(); k++) {\n\tif(links[i].node1 == array[j].at(k))\n\t  t1 = j;\n\telse if(links[i].node2 == array[j].at(k))\n\t  t2 = j;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      while(!array[t2].empty()) {\n\tarray[t1].push_back(array[t2].back());\n\tarray[t2].pop_back();\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstudio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint const MAX_N  = 10000;\nint N, M;\nP piles[MAX_N];\n\ndouble distance(int x0, int y0, int x1, int y1) {\n    return hypot(x1-x0, y1-y0);\n}\n\n// O(E*log(V))\nstruct Edge {\n    Edge(int a, int b, double c) {\n        u = a; v = b; cost = c;\n    }\n    int u, v;\n    double cost;\n};\n\nbool comp(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nstruct UF{\n    vector<int> par;\n    UF(int m) : par(m){\n        for(int i = 0; i < m; i++){\n            par[i] = i;\n        }\n    }\n    int find(int x){\n        return x != par[x] ? par[x] = find(par[x]) : x;\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    void unite(int x, int y){\n        // y is above\n        if(!same(x, y)) par[find(x)] = find(y);\n    }\n};\n\ndouble kruskal(int V, vector<Edge>& es) {\n    sort(es.begin(), es.end(), comp);\n    UF uf(V);\n    double res = 0;\n    for(int i = es.size()-1; i >= 0; i--) {\n        Edge e = es[i];\n        if(!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);\n        } else {\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvector<Edge> es;\n\nint main() {\n    cin >> N >> M;\n    int x, y;\n    for(int i = 0; i < N; i++) {\n        cin >> x >> y;\n        piles[i] = P(x, y);\n    }\n    int j, k;\n    double s = 0;\n    for(int i = 0; i < M; i++) {\n        cin >> j >> k;\n        j--; k--;\n        P p1 = piles[j], p2 = piles[k];\n        double d = distance(p1.first, p1.second, p2.first, p2.second);\n        s += d;\n        es.push_back(Edge(j, k, d));\n    }\n    printf(\"%.5f\\n\", kruskal(N, es));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nÁ·Ï°Ìâ£ºSave your cats_AOJ 2224 \n\t¼õÈ¥×îÉÙ¡¢Ð¡µÄ±ß£¬Ê¹µÃÕû¸öÆ½ÃæÁ¬Í¨£»\n\t¼´ÎªÇó×î´óÉú³ÉÊ÷ÎÊÌâ£¬µ«×¢ÒâÇóµÄÊÇ²ÃÈ¥µÄÂ·¾¶¡£ \n*/\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_E=10007, MAX_V=10007;\nint mark[MAX_E];\npair<int, int> ver[MAX_V];\n\nstruct edge{\n\tint u, v, cost;\n}; \nbool cmp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V, E;\n\n\n//DUS start line\n\nint par[MAX_V];//¸¸Ç× \nint hight[MAX_V];//Ê÷µÄ¸ß¶È\n\n//³õÊ¼»¯n¸öÔªËØ\nvoid init(int n)\n{\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tpar[i]=i;\n\t\thight[i]=0;\n\t}\n}\n\n//²éÑ¯Ê÷µÄ¸ù\nint find(int x)\n{\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=find(par[x]);\n}\n\n//ºÏ²¢xºÍyËùÊôµÄ¼¯ºÏ\nvoid unite(int x, int y)\n{\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)\n\t\treturn ;\n\tif(hight[x]<hight[y])\n\t\tpar[x]=y;\n\telse\n\t{\n\t\tpar[y]=x;\n\t\tif(hight[x]==hight[y])\n\t\t\thight[x]++;\n\t}\n}\n\n//ÅÐ¶ÏxºÍyÊÇ·ñÊôÓÚÍ¬Ò»¸ö¼¯ºÏ\nbool same(int x, int y)\n{\n\treturn find(x)==find(y);\n}\n\n//DUS end line \n\n\ndouble kruskal()\n{\n\tsort(es, es+E, cmp);\n\t\n\tinit(V);\n\t\n\n\tdouble res=0;\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tedge e=es[i];\n\t\tif(!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t\tmark[i]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tif(mark[i]==0)\n\t\t\tres+=sqrt(-es[i].cost);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i=0;  i<V; i++)\n\t{\n\t\tscanf(\"%d%d\", &ver[i].first, &ver[i].second);\n\t}\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tedge ed;\n\t\tscanf(\"%d%d\", &ed.u, &ed.v);\n\t\ted.u--;\n\t\ted.v--;\n\t\ted.cost=-((ver[ed.u].first-ver[ed.v].first)*(ver[ed.u].first-ver[ed.v].first)+(ver[ed.u].second-ver[ed.v].second)*(ver[ed.u].second-ver[ed.v].second));\n\t\tes[i]=ed;\n\t}\n\t\n\tdouble ans=kruskal();\n\tprintf(\"%.3lf\\n\", ans);\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nstruct UnionFind{\n\tvector<int> par,rank;\n\tUnionFind(int n) :par(n + 1),rank(n + 1,1){\n\t\tfor(int i = 1;i <= n;i++) par [i] = i;\n\t}\n\tint find(int x){\n\t\treturn par [x] == x ? x : par [x] = find(par [x]);\n\t}\n\tbool unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return false;\n\t\tif(rank [x] < rank [y]) swap(x,y);\n\t\trank [x] += rank [x] == rank [y];\n\t\tpar [y] = x;\n\t\treturn true;\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint N,M;\nint X [10000],Y [10000];\nstruct E{\n\tint from,to,len;\n\tbool operator<(const E& other){\n\t\treturn len > other.len;\n\t}\n};\n\nint distance(int a,int b)\n{\n\treturn (X [a] - X [b]) * (X [a] - X [b]) + (Y [a] - Y [b]) * (Y [a] - Y [b]);\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tFOR(i,0,N){\n\t\tscanf(\"%d%d\",&X [i],&Y [i]);\n\t}\n\tvector<E> edge;\n\tFOR(i,0,M){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tu--; v--;\n\t\tedge.push_back(E{u,v,distance(u,v)});\n\t}\n\tsort(edge.begin(),edge.end());\n\n\tdouble ans = 0.0;\n\tUnionFind uf(N);\n\tFOR(i,0,M){\n\t\tif(uf.same(edge [i].from,edge [i].to)){\n\t\t\tans += sqrt(edge [i].len);\n\t\t\tcontinue;\n\t\t}\n\t\tuf.unite(edge [i].from,edge [i].to);\n\t}\n\tprintf(\"%.10f\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef double D;\n\nclass edge{\npublic:\n  int s,t;\n  D cost;\n  edge(int a,int b,D c):s(a),t(b),cost(c){}\n  bool operator<(const edge &e)const{return cost<e.cost;}\n};\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\ninline D dis(D x1, D y1, D x2, D y2){\n  return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );\n}\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  \n  vector<D> x(n),y(n);\n  for(int i=0;i<n;i++)cin >> x[i] >> y[i];\n\n  vector<edge> e;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b; a--; b--;\n    e.push_back(edge(a,b,dis(x[a],y[a],x[b],y[b])));\n  }\n\n  sort(e.begin(), e.end());\n  reverse(e.begin(), e.end());\n  \n  UF uf(n);\n  D ans = 0;\n  rep(i,m){\n    if(uf.same(e[i].s,e[i].t))ans += e[i].cost;\n    else uf.unite(e[i].s,e[i].t);\n  }\n  cout << fixed << setprecision(9) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define N 100005\n#define P pair<int,int>\n#define ll long long\n#define mk(a, b) make_pair(a, b)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\nint inf = 0x3f3f3f3f;\nint n, m, pre[N];\nstruct ac{\n\tint v;\n\tdouble c;\n};\nvoid init() {\n\tfor (int i = 1; i <N; ++i) {\n\t\tpre[i] = i;\n\t}\n}\nint find(int x) {\n\tif (x == pre[x])\treturn x;\n\telse \treturn pre[x] = find(pre[x]);\n}\nvoid join(int x, int y) {\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy)\treturn;\n\telse if (fx < fy)\tpre[fy] = fx;\n\telse \tpre[fx] = fy;\n}\ndouble sum;\nbool vis[N];\ndouble dis[N];\nvector<P> a(N);\nvector<ac> g[N];\nvoid prime(int x) {\n\tmem(dis, 0);\n\tmem(vis, false);\n\tdis[x] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble MAX = 0;\n\t\tint u = -1;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (vis[j])\tcontinue;\n\t\t\tif (dis[j] > MAX) {\n\t\t\t\tMAX = dis[j];\n\t\t\t\tu = j;\n\t\t\t}\n\t\t}\n\t\tif (u == -1)\treturn;\n\t\tvis[u] = true;\n\t\tif (u == x)\tMAX = 0;\n\t\tsum += MAX;\n\t\t// cout << \"u = \" << u << \" \" << MAX << endl;\n\t\tfor (int j = 0; j < g[u].size(); ++j) {\n\t\t\tac t = g[u][j];\n\t\t\tif (vis[t.v])\tcontinue;\n\t\t\tif (dis[t.v] < t.c ) {\n\t\t\t\tdis[t.v] = t.c;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\nint main(){\n// #ifndef ONLINE_JUDGE\n//     freopen(\"in.txt\", \"r\", stdin);\n// #endif\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m) {\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tint dx = a[u].first - a[v].first;\n\t\t\tint dy = a[u].second - a[v].second;\n\t\t\tdouble temp = sqrt(dx * dx + dy * dy);\n\t\t\t// cout << \"temp = \" << temp << endl;\n\t\t\tans += temp;\n\t\t\tg[u].push_back((ac){v, temp});\n\t\t\tg[v].push_back((ac){u, temp});\n\t\t\tjoin(u, v);\n\t\t}\n\t\t// cout << ans << endl;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (pre[i] == i) {\n\t\t\t\tsum = 0;\n\t\t\t\tprime(i);\n\t\t\t\tans -= sum;\n\t\t\t\t// cout << i << \"::\" << sum << endl;\n\t\t\t}\n\t\t}\n\t\t// ans += 1;\n\t\tcout << ans << endl;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<deque> \nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long LL;\ntypedef pair<int,int> ppp;\nconst int maxn = 10010;\nint n,m;\nstruct lalala{\n\tint x,y;\n}mood[maxn];\nstruct node{\n\tint u,v;\n\tdouble dis;\n}mp[2*maxn];\ndouble work(int u,int v){\n\treturn (double)sqrt((mood[u].x-mood[v].x)*(mood[u].x-mood[v].x) + (mood[u].y-mood[v].y)*(mood[u].y-mood[v].y));\n}\nbool cmp(node a,node b){\n\treturn a.dis > b.dis;\n}\nint fa[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\n\ndouble kruskal(){\n\tsort(mp+1,mp+1+m,cmp);\n\tdouble ans = 0;\n\tmemset(fa,0,sizeof fa); \n\tfor (int i=1 ; i<=n ; i++) fa[i] = i;\n\tfor (int i=1 ; i<=m ; i++){\n\t\tint cnt1 = find(mp[i].u),cnt2 = find(mp[i].v);\n\t\tif (cnt1 != cnt2){\n\t\t\t//ans += mp[i].w;\n\t\t\tfa[cnt1] = cnt2;\n\t\t}\n\t\telse ans += mp[i].dis;\n\t}\n\treturn ans;\n}\nint main(){\n\twhile (~scanf(\"%d%d\",&n,&m)){\n\t\tfor (int i=1 ; i<=n ; i++)\n\t\t\tscanf(\"%d%d\",&mood[i].x,&mood[i].y);\n\t\tint u,v;\n\t\tfor (int i=1 ; i<=m ; i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tmp[i].u = u; mp[i].v = v; mp[i].dis = work(u,v);\n\t\t\t//mp[i+m].u = v; mp[i+m].v = u; mp[i+m].dis = work(v,u);\n\t\t}\n\t\tdouble ans = kruskal();\n\t\tprintf(\"%.3f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define MAX 10005\n\nstruct edge { int u , v; long double cost; };\nstruct node { long double x , y; };\nbool comp(const edge& e1 , const edge& e2){\n    return e1.cost > e2.cost;\n}\n\nint V , E;\nint par[MAX], rank[MAX];\nnode node[MAX];\nstd::vector <edge> vec;\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++){\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]){ \n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n    }\n}\n\nlong double kruskal(){\n    std::sort(vec.begin() , vec.end() , comp);\n    init(V);\n    long double res = 0;\n    for(int i = 0;i < E;i++){\n        edge e = vec[i];\n        if(find(e.u) != find(e.v)){\n            unite(e.u , e.v);\n        }else{\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    std::cin >> V >> E;\n    for(int i = 1;i <= V;i++){\n        std::cin >> node[i].x >> node[i].y;\n    }\n    for(int i = 0;i < E;i++){\n        int p , q;\n        std::cin >> p >> q;\n        edge e0;\n        e0.u = p , e0.v = q , e0.cost = std::sqrt(std::pow((node[p].x - node[q].x) , 2) + std::pow((node[p].y - node[q].y) , 2));\n        vec.push_back(e0);\n    }\n    std::cout << kruskal() << \"\\n\";\n    vec.clear();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint par[10001],rank[10001];\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=i,rank[i]=1;\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x]=find(par[x]);\n}\nvoid unit(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\nstruct edge{int u,v;double cost;};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost>e2.cost;\n}\nedge es[1000001];\nint V,E;\ndouble kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  double res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unit(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  cin>>V>>E;\n  double p[V][2],sum=0;\n  r(i,V)cin>>p[i][0]>>p[i][1];\n  r(i,E){\n    int a,b;\n    cin>>a>>b;a--;b--;\n    es[i].u=a;es[i].v=b;\n    es[i].cost=sqrt((p[a][0]-p[b][0])*(p[a][0]-p[b][0])+(p[a][1]-p[b][1])*(p[a][1]-p[b][1]));\n    sum+=es[i].cost;\n  }\n  printf(\"%.10f\\n\",sum-kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      k = 0;\n      while(forest[j][k] != 0 && k < N) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      j = 0;\n      while(forest[t1][j] != 0 && j < N - 1)\n\tj++;\n      k = 0;\n      while(forest[t2][k] != 0 && j < N && k < N) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = 1e7;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\twhile (!que.empty())\n\t{\n\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\tint v = r.second;\n\n\t\tif (u[v]) { continue; }\n\n\t\tres += r.second; u[v] = true;\n\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tif (!u[i])\n\t\t\t{\n\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\", 100000.0 * (V - 1) - res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n//double???2?¬????????????????\nstruct vec{\n    long double x,y;\n    vec(double x, double y): x(x), y(y){};\n    //eps??????????????´???????????¨\n    inline double add(double a, double b){\n        return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n    }\n    vec operator-(vec b){\n        return vec(add(x,-b.x),add(y,-b.y));\n    }\n    vec operator+(vec b){\n        return vec(add(x,b.x),add(y,b.y));\n    }\n    vec operator*(long double d){\n        return vec(x*d,y*d);\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){//??????\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){//??????\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){//?????????\n        return hypot(x,y);\n    }\n};\n\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n        init(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\ntypedef tuple<double,int,int> T;\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    vector<vec> V;\n    vector<T> E;\n    union_find U(N);\n\n    for(int i=0;i<N;i++){\n        int x,y;\n        cin>>x>>y;\n        V.emplace_back(x,y);\n    }\n    double ans = 0;\n    for(int i=0;i<M;i++){\n        int p,q;\n        cin>>p>>q;\n        p--; q--;\n        double l = (V[p]-V[q]).norm();\n        ans+=l;\n        E.emplace_back(l,p,q);\n    }\n    sort(E.begin(),E.end(),greater<T>());\n    for(auto e:E){\n        int p,q;\n        double l;\n        tie(l,p,q)=e;\n        if(!U.same(p,q)){\n            ans-=l;\n            U.unite(p,q);\n        }\n    }\n    cout<<fixed;\n    cout.precision(3);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nint p[40002],p2[502];\nint r[40002],r2[502];\n\nvoid init(int n){\n    for (int i = 0; i < n; ++i) {\n        p[i]=i;\n        r[i]=0;\n    }\n}\n\n\nint find(int x){\n\tif(x != p[x]){\n\t\tp[x] = find(p[x]);\n    }\n   \treturn p[x];\n}\n     \nvoid union_set(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y) return;\n\tif(r[x] < r[y]){\n\t\tp[x] = y;\t\n\t}else{\n\t\tp[y] = x;\n\t\tif(r[x] == r[y])r[x]++;\n\t}\n\treturn ;\n}\n\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<pair<double,double> > v;\n\trep(i,n){\n\t\tdouble a,b;\n\t\tcin >> a >> b;\n\t\tv.PB(MP(a,b));\n\t}\n\tpriority_queue<pair<double,pair<int,int> > >node;\n\tdouble ans = 0;\n\trep(i,m){\n\t\tint p,q;\n\t\tcin >> p >> q;\n\t\tp--;\n\t\tq--;\n\t\tdouble w;\n\t\tdouble x,y;\n\t\tx = v[p].first - v[q].first;\n\t\ty = v[p].second - v[q].second;\n\t\tw = sqrt(x*x+y*y);\n\t\tans += w;\n\t\tnode.push(MP(w,MP(p,q)));\n\t}\n\tinit(n+2);\n\twhile(!node.empty()){\n\t\tpair<double,pair<int,int> > k = node.top();\n\t\tnode.pop();\n\t\tdouble w1 = k.first;\n\t\tint x,y;\n\t\tx = k.second.first;\n\t\ty = k.second.second;\n\t\tif(find(x)==find(y))continue;\n\t\tunion_set(x,y);\n\t\tans -=w1;\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\nint N,M;\n\nstruct uni {\n  int d[10005];\n  void init(){\n    memset(d,-1,sizeof( d ) );\n  }\n  int find( int a ){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void merge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a] += d[b]; d[b] = a;\n  }\n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n};\n\nvector<P> v;\nuni U;\n\nstruct edge{\n  int a,b;\n  double c;\n  bool operator<(const edge& e) const{\n    return c < e.c;\n  }\n};\n\nvector<edge> E;\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    int x,y; cin >> x >> y;\n    v.push_back( P( x, y ) );\n  }\n  for(int i=0;i<M;i++){\n    int p,q; cin >> p >> q; p--; q--;\n    E.push_back( (edge){ p, q, abs( v[p] - v[q] ) } );\n  }\n  sort( E.rbegin(), E.rend() );\n  double res = 0.0;\n  U.init();\n  for(int i=0;i<M;i++){\n    if( !U.same( E[i].a , E[i].b ) ){\n      U.merge(E[i].a,E[i].b);\n    } else {\n      res += E[i].c;\n    }\n  }\n  printf(\"%.3lf\\n\",res);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii p(n);\n\trep(i, n)cin >> p[i].first >> p[i].second;\n\tvector<uset<int>> pf(n);\n\tvpii f(m);\n\tsegtree<pair<double,int>,min> st(m,make_pair(1e9,1e9));\n\trep(i, m) {\n\t\tint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tp1--;\n\t\tp2--;\n\t\tf[i] = { p1,p2 };\n\t\tst[i] = { hypot(p[p1].first - p[p2].first, p[p1].second - p[p2].second),i };\n\t\tpf[p1].insert(i);\n\t\tpf[p2].insert(i);\n\t}\n\trep(i, n) {\n\t\tint prev = i;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst[fn].first = 1e9;\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t}\n\tst.updateall();\n\tdouble ans = 0;\n\tpair<double,int> remove;\n\twhile(remove = st.query(0, m),remove.first<1e9) {\n\t\tans += remove.first;\n\t\tint fn = remove.second;\n\t\tst.update(fn, { 1e9,fn });\n\t\tpf[f[fn].first].erase(fn);\n\t\tpf[f[fn].second].erase(fn);\n\t\tint prev = f[fn].first;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst.update(fn, { 1e9,fn });\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t\tprev = f[fn].second;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst.update(fn, { 1e9,fn });\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t}\n\tcout << fixed << setprecision(5) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef pair<double, P> E;\nconst int NN=10001;\nint rep[NN];\nint weight[NN];\nP pos[NN];\nint Find(int i){\n\twhile(i!=rep[i]){\n\t\ti=rep[i]=rep[rep[i]];\n\t}\n\treturn i;\n}\nvoid Union(int i, int j){\n\tif(weight[i]<weight[j]){\n\t\tswap(i,j);\n\t}\n\trep[j]=i;\n\tweight[i]+=weight[j];\n}\ninline double len(P a, P b){\n\tdouble s=a.first-b.first;\n\tdouble t=a.second-b.second;\n\treturn sqrt(s*s+t*t);\n}\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=1;i<=N;i++){\n\t\trep[i]=i;\n\t\tweight[i]=1;\n\t\tcin >> pos[i].first >> pos[i].second;\n\t}\n\tvector<E> edge(M);\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedge[i]=E(len(pos[a],pos[b]),P(a,b));\n\t}\n\tdouble ret=0;\n\tsort(edge.begin(),edge.end(),greater<E>());\n\tfor(int i=0;i<edge.size();i++){\n\t\tint a=edge[i].second.first;\n\t\tint b=edge[i].second.second;\n\t\ta=Find(a);\n\t\tb=Find(b);\n\t\tif(a!=b){\n\t\t\tUnion(a,b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret+=edge[i].first;\n\t\t}\n\t}\n\tprintf(\"%.3lf\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5+5;\nconst int mod = 1e9+7;\nconst double eps = 1e-8;\nconst double pi = asin(1.0)*2;\nconst double e = 2.718281828459;\nbool Finish_read;\ntemplate<class T>inline void read(T &x){Finish_read=0;x=0;int f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-1;if(ch==EOF)return;ch=getchar();}while(isdigit(ch))x=x*10+ch-'0',ch=getchar();x*=f;Finish_read=1;}\n\nstruct edge {\n\tdouble u;\n\tdouble v;\n\tdouble d;\n\tedge(double _u = 0, double _v = 0, double _d = 0): u(_u), v(_v), d(_d) {}\n\tbool operator < (const edge &a) const {\n\t\treturn d > a.d;\n\t}\n};\n\nint n, m;\nint tu, tv;\ndouble ans;\nPDD co[maxn];\nint pre[maxn];\nvector<edge> q;\n\nvoid init() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpre[i] = i;\n\t}\n}\n\nint find(int x) {\n\tif (x == pre[x]) {\n\t\treturn pre[x];\n\t}\n\telse {\n\t\tpre[x] = find(pre[x]);\n\t\treturn pre[x];\n\t}\n}\n\ndouble caldis(PDD a, PDD b) {\n\treturn sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));\n}\n\nint main(int argc, char *argv[]) {\n//#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n//#endif\n\tread(n); read(m);\n\tinit();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(co[i].first);\n\t\tread(co[i].second);\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tread(tu); read(tv);\n\t\tq.pb(edge(tu, tv, caldis(co[tu], co[tv])));\n\t}\n\tsort(q.begin(), q.end());\n\tans = 0;\n\tfor (int i = 0; i < int (q.size()); ++i) {\n\t\tint x = find(q[i].u), y = find(q[i].v);\n\t\tif (x != y) {\n\t\t\tpre[x] = y;\n\t\t}\n\t\telse {\n\t\t\tans += q[i].d;\n\t\t}\n\t}\n\tprintf(\"%.3lf\\n\", ans);\n//#ifndef ONLINE_JUDGE\n//\tfclose(stdin);\n//\tfclose(stdout);\n//\tsystem(\"gedit out.txt\");\n//#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <set>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) ((abs((a)-(b)))<EPS)\n\ntypedef complex<double> P;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\nint n,m;\nvector<edge> G[10001];\nvector<edge> G2[10001];\nP points[10001];\nconst double INF=1000000000;\ndouble mincost[10001];\nbool used[10001];\n\n// _s©çÅ¬SæØðì¬\ndouble prim(int s,int V){\n\tfor(int i=0;i<V;i++)mincost[i]=INF;\n\tmincost[s]=0;\n\tdouble res=0;\n\tpriority_queue<pair<double,int> ,vector<pair<double,int> >,greater<pair<double,int> > > pq;\n\tpq.push(make_pair(0,s));\n\twhile(pq.size()){\n\t\t// xÉ®³È¢¸_Ì¤¿,x©çÌÓÌRXgªÅ¬ÆÈé_ð³ª·\n\t\tdouble mc=pq.top().first;\n\t\tint v=pq.top().second;\n\t\tpq.pop();\n\t\tif(used[v])continue;\n\t\t// xÉvðÇÁ\n\t\tused[v]=true;\n\t\t// vÖÌRXgðÁ¦é\n\t\tres+=mc;\n\t\t// »ê¼êÌÓÖÌÅ¬RXgðXV\n\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\tint u=G[v][i].to;\n\t\t\tif(!used[u])pq.push(make_pair(G[v][i].cost,u));\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpoints[i]=P(x,y);\n\t}\n\tdouble sum=0;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tb--;a--;\n\t\tedge e;\n\t\te.to=b;\n\t\te.cost=-abs(points[a]-points[b]);\n\t\tsum+=-e.cost;\n\t\tG[a].push_back(e);\n\t\te.to=a;\n\t\tG[b].push_back(e);\n\t}\n\tdouble res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(used[i])continue;\n\t\tres+=prim(i,n);\n\t}\n\tprintf(\"%.10f\\n\",sum+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define M 99999\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tdouble s=0;\n\tint i,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tvector<pair<double,double> >v(n);\n\tfor(i=0;i<n;i++)scanf(\"%lf%lf\",&v[i].first,&v[i].second);\n\tfor(i=0;i<m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y),x--,y--;\n\t\ta[i]=x,b[i]=y;\n\t\tnode[i].first=-hypot(v[x].first-v[y].first,v[x].second-v[y].second);\n\t\ts-=node[i].first;\n\t\tnode[i].second=i;\n\t}\n\tsort(node,node+m);\n\tfor(i=0;i<n;i++)parent[i]=i;\n\tfor(i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\tprintf(\"%f\\n\",s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct edge{\n\tint from;\n\tint to;\n\tdouble cost;\n};\n\nint a[10000], rank[10000];\n\nvoid init(){\n\tfor(int i = 0;i < 10000;i++){\n\t\ta[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(a[x] == x)\n\t\treturn x;\n\telse\n\t\treturn find(a[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(rank[x] < rank[y])\n\t\ta[x] = y;\n\telse{\n\t\ta[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\ndouble dist(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));\n}\n\nint cmp(const void* a,const void* b){\n\tstruct edge *ea = (struct edge *)a;\n\tstruct edge *eb = (struct edge *)b;\n\tif(eb->cost - ea->cost > 0)\n\t\treturn 1;\n\telse if(eb->cost - ea->cost < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nint main(void){\n\tint n, m, x[10000], y[10000], p, q, i, j, c;\n\tdouble s;\n\tedge e[10000000];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\ts = 0;\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d\",&p,&q);\n\t\te[i].from = p - 1,e[i].to = q - 1;\n\t\ts += e[i].cost = dist(x[p - 1],y[p - 1],x[q - 1],y[q - 1]);\n\t}\n\tqsort(e,m + 1,sizeof(e[0]),cmp);\n\tfor(i = 0;i < m;i++)\n\t\tprintf(\"%d:%f\\n\",i + 1,e[i].cost);\n\tc = 0;\n\tinit();\n\tfor(i = 0;i < n;i++)\n\t\tif(i == a[i]) c++;\n\tfor(i = 0;i < m && c != 1;i++){\n\t\tif(find(e[i].from) != find(e[i].to)){\n\t\t\tunite(e[i].from,e[i].to);\n\t\t\ts -= e[i].cost;\n\t\t}\n\t\tc = 0;\n\t\tfor(j = 0;j < n;j++)\n\t\t\tif(j == a[j]) c++;\n\t}\n\tprintf(\"%.3f\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sd(x) scanf(\"%d\",&x)\n#define ss(x) scanf(\"%s\",x)\n#define sc(x) scanf(\"%c\",&x)\n#define sf(x) scanf(\"%f\",&x)\n#define slf(x) scanf(\"%lf\",&x)\n#define slld(x) scanf(\"%lld\",&x)\n#define me(x,b) memset(x,b,sizeof(x))\n#define pd(d) printf(\"%d\\n\",d);\n#define plld(d) printf(\"%lld\\n\",d);\n#define eps 1.0E-8\n// #define Reast1nPeace\n\ntypedef long long ll;\n\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint n,m; \n\nstruct no{\n\tint a,b;\n\tdouble c;\n}edge[10010<<1];\n\nbool cmp(no a,no b){\n\treturn a.c > b.c;\n}\n\nint fa[10010];\n\nint get(int x){\n\treturn x==fa[x]? x:fa[x] = get(fa[x]); \n}\n\nvoid unions(int x ,int y){\n\tx = get(x);\n\ty = get(y);\n\tif(x!=y){\n\t\tfa[x] = y;\n\t}\n}\n\nstruct nod{\n\tdouble x,y;\n}node[10010];\n\ndouble getlen(int i , int j){\n\treturn sqrt((node[i].x-node[j].x)*(node[i].x-node[j].x) + (node[i].y-node[j].y)*(node[i].y-node[j].y));\n}\n\nint main(){\n#ifdef Reast1nPeace\n\tfreopen(\"in.txt\", \"r\", stdin);\n\tfreopen(\"out.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d %d\",&n,&m);\n\tfor(int i = 1 ; i<=n ; i++){\n\t\tfa[i] = i;\n\t\tscanf(\"%lf %lf\",&node[i].x,&node[i].y);\n\t}\n\t\n\tdouble sum = 0;\n\tfor(int i = 0 ; i<m ; i++){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tedge[i].a = a , edge[i].b = b;\n\t\tedge[i].c = getlen(a,b);\n\t\tsum += edge[i].c;\n\t}\n\tsort(edge,edge+m,cmp);\n\tdouble maxtree = 0;\n\tfor(int i = 0 ; i<m ; i++){\n\t\tint a = edge[i].a ; int b = edge[i].b;\n\t\tif(get(a)!=get(b)){\n\t\t\tmaxtree += edge[i].c;\n\t\t\tunions(a,b);\n\t\t}\n\t}\t\n\tprintf(\"%.3lf\\n\",sum-maxtree);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_N = 10000;\n\nstruct UnionFind{\n\tstatic const int MAX_UF = MAX_N;\n\n\tint pars[MAX_UF];\n\tint ranks[MAX_UF];\n\n\tvoid init(int n){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tpars[i] = i;\n\t\t\tranks[i] = 0;\n\t\t}\n\t}\n\n\tint get_root(int x){\n\t\tif(pars[x] == x){\n\t\t\treturn x;\n\t\t}\n\t\telse{\n\t\t\treturn pars[x] = get_root(pars[x]);\n\t\t}\n\t}\n\n\tvoid merge(int x, int y){\n\t\tx = get_root(x);\n\t\ty = get_root(y);\n\t\tif( x == y ){\n\t\t\treturn ;\n\t\t}\n\n\t\tif(ranks[x] < ranks[y]){\n\t\t\tpars[x] = y;\n\t\t}\n\t\telse if(ranks[y] < ranks[x]){\n\t\t\tpars[y] = x;\n\t\t}\n\t\telse{\n\t\t\tpars[x] = y;\n\t\t\tranks[y]++;\n\t\t}\n\t}\n\n\tbool is_same(int x, int y){\n\t\treturn get_root(x) == get_root(y);\n\t}\n};\n\nUnionFind uf;\n\nint N, M;\nint xs[MAX_N], ys[MAX_N];\n\nint sq(int x){\n\treturn x*x;\n}\n\nint sq_dist(int x1, int y1, int x2, int y2){\n\treturn sq(x1-x2) + sq(y1-y2);\n}\n\nvoid init(){\n\tscanf(\"%d%d\", &N, &M);\n\tfor(int i=0; i<N; i++){\n\t\tscanf(\"%d%d\", xs+i, ys+i);\n\t}\n}\n\nstruct edge{\n\tint v, u, dist;\n};\n\nbool operator<(const edge& lhs, const edge& rhs){\n\treturn lhs.dist < rhs.dist;\n}\n\ndouble solve(){\n\tvector<edge> es;\n\tes.reserve(M);\n\n\tfor(int i=0; i<M; i++){\n\t\tint v, u;\n\t\tscanf(\"%d%d\", &v, &u);\n\t\tv--; u--;\n\t\tes.push_back((edge){v, u, sq_dist(xs[v],ys[v],xs[u],ys[u])});\n\t}\n\n\tsort(es.rbegin(), es.rend());\n\n\tuf.init(N);\n\n\tdouble ans = 0.0;\n\tfor(int i=0; i<M; i++){\n\t\tedge e = es[i];\n\t\tif(uf.is_same(e.v, e.u)){\n\t\t\tans += sqrt(e.dist);\n\t\t}\n\t\telse{\n\t\t\tuf.merge(e.v, e.u);\n\t\t}\n\t}\n\n\treturn ans;\n}\n\nint main(){\n\tinit();\n\tprintf(\"%.8f\\n\", solve());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T] - X[S]) * (X[T] - X[S]) + (Y[T] - Y[S]) * (Y[T] - Y[S]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T] - X[S]) * (X[T] - X[S]) + (Y[T] - Y[S]) * (Y[T] - Y[S]))));\n\t}\n\n\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\twhile (!que.empty())\n\t{\n\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\tint v = r.second;\n\n\t\tif (u[v]) { continue; }\n\n\t\tres += r.second; u[v] = true;\n\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tif (!u[i])\n\t\t\t{\n\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\", 100000.0 * (V - 1) - res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nstatic const int MAX_N = 10000;\n \nclass DisjointSet{\n    public:\n        vector<int> rank, p;\n \n        DisjointSet(){}\n        DisjointSet(int size){\n            rank.resize(size,0);\n            p.resize(size,0);\n            for(int i = 0;i < size;i++) makeSet(i);\n        }\n \n        void makeSet(int x){\n            p[x] = x;\n            rank[x] = 0;\n        }\n \n        bool same(int x, int y){\n            return findSet(x) == findSet(y);\n        }\n        void unite(int x, int y){\n            link(findSet(x), findSet(y));\n        }\n \n        void link(int x, int y){\n            if(rank[x] > rank[y]){\n                p[y] = x;\n            }else{\n                p[x] = y;\n                if(rank[x] == rank[y]){\n                    rank[y]++;\n                }\n            }\n        }\n \n        int findSet(int x){\n            if(x != p[x]){\n                p[x] = findSet(p[x]);\n            }\n            return p[x];\n        }\n};\n \nclass Edge{\npublic:\n    int source, target; double cost;\n    Edge(int source = 0, int target = 0, double cost = 0.0):\n    source(source), target(target), cost(cost){}\n    bool operator < (const Edge &e) const{\n        return cost < e.cost;\n    }\n};\n \ndouble kruskal(int N, vector<Edge> edges){\n    double totalCost = 0.0;\n    sort(edges.begin(), edges.end());\n \n    DisjointSet dset = DisjointSet(N + 1);\n \n    for(int i = 0; i < N; i++) dset.makeSet(i);\n \n    int source, target;\n    for(int i = 0; i < edges.size(); i++){\n        Edge e = edges[i];\n        if(!dset.same(e.source, e.target)){\n \n            totalCost += e.cost;\n            dset.unite(e.source, e.target);\n        }\n    }\n    return totalCost;\n}\n \n \nint main(){\n    int N, M;\n    int source, target; double cost;\n    double x[MAX_N], y[MAX_N];\n    \n    scanf(\"%d %d\", &N, &M);\n    for(int i = 0; i < N; i++) scanf(\"%lf %lf\", &x[i], &y[i]);\n    vector<Edge> edges;\n    double sum = 0.0;\n    for(int i = 0; i < M; i++){\n        scanf(\"%d %d\", &source, &target);\n        source--; target--;\n        cost = sqrt(pow(x[source] - x[target], 2.0) + pow(y[source] - y[target], 2.0));\n        edges.push_back(Edge(source, target, -cost));\n        sum += cost;\n    }\n    printf(\"%.10lf\\n\", sum + kruskal(N, edges));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <vector>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tint size_; vector<int> g; vector<vector<int> > v;\npublic:\n\tUnionFind() : size_(0), g(vector<int>()), v(vector<vector<int> >()) {};\n\tUnionFind(int size__) : size_(size__) { g.resize(size_), v.resize(size_); for (int i = 0; i < size_; i++) g[i] = i, v[i] = { i }; };\n\tint size() { return size_; }\n\tint root(int x) { return g[x]; }\n\tint size(int x) { return v[x].size(); }\n\tbool same(int x, int y) { return g[x] == g[y]; }\n\tvoid unite(int x, int y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const UnionFind& u) { return g == u.g; }\n\tbool operator!=(const UnionFind& u) { return g != u.g; }\n\tint operator[](int x) { return g[x]; }\n};\nstruct edge { int s, to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint V, E, x[10009], y[10009], s, t; edge e[99999];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int i = 0; i < V; i++) scanf(\"%d%d\", x + i, y + i);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tint dist = (x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]);\n\t\te[i] = edge{ s, t, dist };\n\t}\n\tsort(e, e + E);\n\treverse(e, e + E);\n\tUnionFind u(V);\n\tdouble ret = 0;\n\tfor (auto &v: e) {\n\t\tif (u.same(v.s, v.to)) ret += sqrt(v.cost);\n\t\telse u.unite(v.s, v.to);\n\t}\n\tprintf(\"%.9f\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  xzppp  */\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\n#include <cmath>\n#include <set>\n#include <iomanip>\nusing namespace std;\n#define FFF freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define MP make_pair\n#define PB push_back\ntypedef long long  LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int > pii;\ntypedef pair<double,double > pdd;\ntypedef pair<double,int > pdi;\nconst int MAXN = 1e4+17;\nconst int MAXM = 20;\nconst int MAXV = 1e4+17;\nconst int INF = 0x7fffffff;\nconst int MOD = 1e9+7;\npdd all[MAXV];\nvector<pdi > G[MAXV];\ndouble s;\nbool vis1[MAXV];\nvoid dfs(int x)\n{\n\tvis1[x]=1;\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\ts+=G[x][i].first;\n\t\t}\n\t}\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\tdfs(G[x][i].second);\n\t\t}\n\t}\n}\nbool vis[MAXV];\ndouble minc[MAXV];\ndouble prim(int x)\n{\n    for (int i = 0; i < MAXV; ++i)\n    {\n        minc[i] = 0;\n        vis[i] = 0;\n    }\n    double res = 0;\n    priority_queue<pdi> q;\n    q.push(MP(0,x));\n    while(!q.empty())\n    {\n        int v = q.top().second;\n        double temp = q.top().first;\n        q.pop();\n        if(vis[v]) continue;\n       // cout<<\"???\"<<v<<endl;\n        vis[v] = 1;\n        res += temp;\n        for (int i = 0; i < G[v].size(); ++i)\n        {\n            double d = G[v][i].first;\n            int to = G[v][i].second;\n            if(!vis[to]&&minc[to]<d)\n            {\n                q.push(MP(d,to));\n                minc[to] = d;\n            }\n        }\n    }\n    return  res;\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE \n    FFF\n    #endif\n    int n,m;\n    cin>>n>>m;\n    for (int i = 0; i < n; ++i)\n    {\n    \tdouble x,y;\n    \tscanf(\"%lf%lf\",&x,&y);\n    \tall[i].first = x;\n    \tall[i].second = y;\n    }\n    for (int i = 0; i < m; ++i)\n    {\n    \tint u,v;\n    \tscanf(\"%d%d\",&u,&v);\n    \tu--;v--;\n    \tdouble dis = sqrt((all[u].first-all[v].first)*(all[u].first-all[v].first)\n    \t\t+(all[u].second-all[v].second)*(all[u].second-all[v].second));\n    \tG[u].push_back(MP(dis,v));\n    \tG[v].push_back(MP(dis,u));\n    }\n    double ans = 0;\n    for (int i = 0; i < n; ++i)\n    {\n    \tif(!vis1[i])\n    \t{\n    \t\t//cout<<i<<endl;\n    \t\ts = 0;\n    \t\tdfs(i);\n    \t\t//cout<<s<<endl;\n    \t\tdouble left = prim(i);\n    \t\tans += s-left;\n    \t\t//cout<<\" ans\"<<s-left<<endl;\n    \t}\n    }\n    cout<<fixed<<setprecision(4)<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224>\n 問題文============================================================\n \n \n \n =================================================================\n 解説=============================================================\n \n これ蟻本の問題にあるよな？\n ================================================================\n */\n\nstruct UnionFind{\n    vector<int> parent, rank;\n    UnionFind(int n) : parent(n, -1), rank(n, 0) { }\n    int find(int x){\n        if(parent[x] == -1) return x;\n        else return (parent[x] = find(parent[x]));\n    }\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(rank[x] < rank[y])\n            parent[x] = y;\n        else\n            parent[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n        return true;\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\ntypedef long double ld;\nstruct edge{\n    int u,v; ld cost;\n    edge(int u = 0,int v = 0,ld cost = 0):u(u),v(v),cost(cost){}\n    bool operator < (const edge& e) const{\n        return cost < e.cost;\n    }\n};\nld solve(){\n    ld res = 0;\n    int N,M; cin >> N >> M;\n    vector<complex<ld>> ps(N);\n    for(int i = 0; i < N;i++){\n        ld x,y; cin >> x >> y;\n        ps[i] = complex<ld>(x,y);\n    }\n    priority_queue<edge> pq;\n    for(int i = 0; i < M;i++){\n        int p,q; cin >> p >> q;\n        p--; q--;\n        ld cost = abs(ps[p]-ps[q]);\n        res += cost;\n        pq.push(edge(p,q,cost));\n    }\n    UnionFind UF(N);\n    while(pq.size()){\n        auto e = pq.top(); pq.pop();\n        if(UF.same(e.u,e.v)) continue;\n        res -= e.cost;\n        UF.unite(e.u,e.v);\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(12) << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    REP(i, n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(int x, int y) {\n    // ?????????????????????????????????\n    x = find(x);\n    y = find(y);\n\n    // ??¢???????????¨????±?????????????????????????????????????\n    if (x == y) return;\n\n    // x?????¨???y?????¨????????§???????????????????????????\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // x???y??????????????????????????£?????????\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]????????????????????¨???????????§0?????\\????????????????????????\n  }\n\n  // 2???????????????x, y????±?????????¨???????????????true?????????\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // ?????????x?????????????????¨?????§???????????????\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// ??????a, b?????????????????????cost??????????????????\nstruct Edge\n{\n  int a, b;\n  float cost;\n\n  // ??????????????§?°???§????????????\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// ????????°??¨?????????????????¨????????????????????°??????\nstruct Graph\n{\n  int n;  // ????????°\n  vector<Edge> es;  // ?????????\n\n  // ????????????????????§??????????°???¨?????¨??????????????????????¨??????????\n  // ??°??????????????£????????¨??????????°???¨????£?????????????????????¨??????\n  float kruskal() {\n    // ?????????????°??????????????????????\n    RSORT(es);\n\n    UnionFind uf(n);\n    float min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // ????????????????????????????????§???????????????????????????????????¨??????\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    Graph g;\n    g.n = n;\n\n    float cost = 0;\n    vector<pii> piles;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        piles.push_back({x, y});\n    }\n    REP(i, m) {\n        int p, q;\n        cin >> p >> q;\n        p--;\n        q--;\n        pii P = piles[p], Q = piles[q];\n        float c = hypot(P.first - Q.first, P.second - Q.second);\n        cost += c;\n        g.es.push_back({p, q, c});\n    }\n    printf(\"%.03f\\n\", cost - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10;\n#define maxe maxn*maxn/2+1;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int u, v; double w; };\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nbool kr_cmp(const edge& l, const edge& r) { return l.w < r.w; }\n\ndouble kruskal(int n, vector<edge>& E) {\n\tsort(E.begin(), E.end(), kr_cmp);\n\tunion_find uf(n);\n\tdouble res = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tedge e = E[i];\n\t\tif (uf.same(e.u, e.v)) continue;\n\t\tuf.unite(e.u, e.v);\n\t\tres += e.w;\n\t}\n\treturn res;\n}\n\nint x[10000], y[10000];\n\nint main() {\n\tint N, M; scanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < N; i++)\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\tvector<edge> E;\n\tdouble ans = 0;\n\tfor (; M > 0; M--) {\n\t\tint p, q; scanf(\"%d%d\", &p, &q);\n\t\tint dx = x[p - 1] - x[q - 1];\n\t\tint dy = y[p - 1] - y[q - 1];\n\t\tdouble l = sqrt((double)(dx * dx + dy * dy));\n\t\tans += l;\n\t\tedge e = {p - 1, q - 1, -l}; E.push_back(e);\n\t}\n\tprintf(\"%lf\\n\", ans + kruskal(N, E));\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      k = 0;\n      while(forest[j][k] != 0 && k < N) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      j = 0;\n      while(forest[t1][j] != 0 && j < N)\n\tj++;\n      k = 0;\n      while(forest[t2][k] != 0 && j < N && k < N) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <iomanip>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\nusing namespace std;\nconst double EPS = 1e-9;\nconst double INF = 1e18;\nvector<double> mincost((int)1e4, INF);\n\ndouble prim(int s, vector<vector<pair<int, double> > > &adj){\n    int n = adj.size();\n    //vector<double> mincost(n, INF);\n    priority_queue<pair<double, int> > wait;\n    wait.push(make_pair(0, s));\n    \n    int v = 0;\n    double ret = 0;\n    while(!wait.empty() && v<n){\n        double cost = -wait.top().first;\n        int idx = wait.top().second;\n        wait.pop();\n        if(cost > mincost[idx] +EPS) continue;\n        ret += cost;\n        v++;\n        mincost[idx] = -INF;\n        for(int i=0; i<(int)adj[idx].size(); i++){\n            int nidx = adj[idx][i].first;\n            double ncost = adj[idx][i].second;\n            if(ncost +EPS < mincost[nidx]){\n                wait.push(make_pair(-ncost, nidx));\n                mincost[nidx] = ncost;\n            }\n        }\n    }\n    \n    for(int i=0; i<n; i++){\n        if(mincost[i] == INF){\n            ret += prim(i, adj);\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<double> px(n), py(n);\n    for(int i=0; i<n; i++){\n        cin >> px[i] >> py[i];\n    }\n    vector<vector<pair<int, double> > > adj(n);\n    double sum = 0;\n    for(int i=0; i<m; i++){\n        int p,q;\n        cin >> p >> q;\n        p--; q--;\n        double d = sqrt((px[p]-px[q])*(px[p]-px[q]) +(py[p]-py[q])*(py[p]-py[q]));\n        sum += d;\n        adj[p].push_back(make_pair(q, -d));\n        adj[q].push_back(make_pair(p, -d));\n    }\n    cout << fixed;\n    cout << setprecision(3);\n    cout << sum +prim(0, adj) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n \n// 并查集相关数据与算法\n#define MAX_N 10000 + 16\nint parent[MAX_N];\nint height[MAX_N];\n \nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n// End Of 并查集\n \n#define MAX_E MAX_N * MAX_N / 2 + 1\nstruct edge\n{\n\tint u, v;\n\tdouble cost;\n\tedge(int u = 0, int v = 0, double cost = 0) : u(u), v(v), cost(cost) {}\n\tbool operator < (const edge & e2) const\n\t{\n\t\treturn cost > e2.cost;\n\t}\n};\n \nedge es[MAX_E];\nint V, E;\ndouble kruskal()\n{\n\tsort(es, es + E);    // 按照权值从小到大排序\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n \npair<int, int> pile[MAX_N];\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n\tcin >> V >> E;\n\t\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tcin >> pile[i].first >> pile[i].second;\n\t}\n \n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t}\n \n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout << kruskal() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#define LL long long\nusing namespace std;\n\nint n,m,pos[10010][2],f[10010];\n\nstruct edge{\n    int u,v;\n    double cost;\n}es[1000010];\n\nbool cmp(const edge& e1,const edge& e2){\n    return e1.cost-e2.cost>1e-6;\n}\n\nint find(int x){\n    return x==f[x]?x:f[x]=find(f[x]);\n}\n\nvoid join(int x,int y){\n    int fx=find(x);\n    int fy=find(y);\n    if(fx!=fy) f[fx]=fy;\n}\n\nbool same(int x,int y){\n    return find(x)==find(y);\n}\n\nint main(void){\n    scanf(\"%d %d\",&n,&m);\n    int i;\n    for(i=1;i<=n;i++){\n        scanf(\"%d %d\",&pos[i][0],&pos[i][1]);\n    }\n    double s=0;\n    for(i=1;i<=m;i++){\n        scanf(\"%d %d\",&es[i].u,&es[i].v);\n        int u=es[i].u,v=es[i].v;\n        es[i].cost=sqrt((pos[u][0]-pos[v][0])*(pos[u][0]-pos[v][0])+(pos[u][1]-pos[v][1])*(pos[u][1]-pos[v][1]));\n        s+=es[i].cost;\n    }\n    sort(es+1,es+1+m,cmp);\n    for(i=1;i<=n;i++) f[i]=i;\n    double sum=0;\n    for(i=1;i<=m;i++){\n        edge e=es[i];\n        if(!same(e.u,e.v)){\n            join(e.u,e.v);\n            sum+=e.cost;\n        }\n    }\n    printf(\"%.6lf\\n\",s-sum);\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> P1;\nint n,m,x[N],y[N],p,q;\ndouble cost,ans;\nvector<P1> e;\nint rank[N];\nint par[N];\n\nvoid init(){\n  for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n}\n\nint find(int u){\n  if(par[u]==u)return u;\n  return par[u]=find(par[u]);\n}\n\nvoid unite(int u,int v){\n  u=find(u);\n  v=find(v);\n  if(u==v)return;\n  if(rank[u]<rank[v])par[u]=v;\n  else{\n    par[v]=u;\n    if(rank[u]==rank[v])rank[u]++;\n  }\n}\n\nbool same(int u,int v){\n  return find(u)==find(v);\n}\n\ndouble getlen(int a,int b){\n  double X=x[a]-x[b],Y=y[a]-y[b];\n  return sqrt(X*X+Y*Y);\n}\n\ndouble kruskal(){\n  sort(e.begin(),e.end());\n  init();\n  double res=0;\n  for(int i=0;i<(int)e.size();i++){\n    int u=e[i].second.first;\n    int v=e[i].second.second;\n    if(!same(u,v))unite(u,v),res+=e[i].first;\n  }\n  return -res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<m;i++){\n    cin>>p>>q;\n    e.push_back(P1(-getlen(--p,--q),P(p,q)));\n    ans+=getlen(p,q);\n  }\n  ans-=kruskal();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct Way{\n\tint p,q,cost;\n\tWay(){}\n\tWay(int _p,int _q,int _cost){\n\t\tp=_p; q=_q; cost=_cost;\n\t}\n\tbool operator<(const Way &a){\n\t\treturn cost>a.cost;\n\t}\n};\n\nstruct Node{\n\tint x,y;\n};\n\nint par[10000],_rank[10000];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++) par[i]=i,_rank[i]=1;\n}\n\nint find(int a){\n\tif(par[a]==a) return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int _a,int _b){\n\tint a = find(_a);\n\tint b = find(_b);\n\tif(a==b) return;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = a;\n\t}\n\telse{\n\t\tpar[a] = b;\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n}\n\nint main(){\n\tint N,M;\n\tNode node[10000];\n\tWay way[10000];\n\tcin>>N>>M;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>node[i].x>>node[i].y;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin>>way[i].p>>way[i].q;\n\t\ta = node[--way[i].p].x-node[--way[i].q].x;\n\t\tb = node[way[i].p].y-node[way[i].q].y;\n\t\tway[i].cost = a*a+b*b;\n\t\t//printf(\"\\t%d\\n\",way[i].cost);\n\t}\n\n\tdouble ans=0;\n\tsort(way,way+M);\n\tinit(N);\n\tfor(int i=0;i<M;i++){\n\t\tint a = find(way[i].p),\n\t\t\tb = find(way[i].q);\n\t\tif(a!=b) unite(a,b);\n\t\telse ans += sqrt(way[i].cost);\n\t}\n\tprintf(\"%lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\n\nconst int MAX_N = 10001;\n\nusing namespace std;\n//先搞并查集:\nint fa[MAX_N];\nint Rank[MAX_N];\n//一共n个元素\n//初始化大小为n的并查集\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        fa[i] = i;\n    }\n}\n//查询树的根\nint find(int x) {\n       //这是使用了路径压缩的写法\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n       //如果不用路径压缩的话:\n       //return x == fa[x] ? x : find(fa[x]);\n}\n//合并x与y所在的集合\nvoid unite(int x, int y) {\n       //先找祖宗\n        x = find(x);\n        y = find(y);\n        if (x == y)return;//如果本来就一组,就什么都不用干了\n        if (Rank[x] < Rank[y]) {\n                fa[x] = y;\n        }\n        else {\n            fa[y] = x;\n            if (Rank[x] == Rank[y])Rank[x]++;//如果一颗高一棵矮,最后的高度一定是原来高的那棵树的高度.如果两颗一样高,高度会变成原高度+1\n        }\n}\n//判断x与y是否属于同一集合\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nstruct edge{\n    int from, to;\n    double cost;\n};\nstruct point{\n    int x, y;\n};\n\nbool cmp(edge a,edge b){\n    return a.cost > b.cost;\n}\n\nint main(){\n    \n    int n,m;\n    vector<edge> es;\n    vector<point> p;\n    cin >> n >> m;\n\n    \n    for(int i=0;i<n;i++){\n        point temp;\n        scanf(\"%d%d\", &temp.x, &temp.y);\n        p.push_back(temp);\n    }\n\n    for(int i=0;i<m;i++){\n        edge e;\n        scanf(\"%d%d\", &e.from, &e.to);\n        int a = e.from - 1, b = e.to - 1;\n        e.cost = sqrt((p[a].x - p[b].x) * (p[a].x - p[b].x) + (p[a].y - p[b].y) * (p[a].y - p[b].y));\n        es.push_back(e);\n    }\n    \n    init(n );\n    \n    sort(es.begin(), es.end(), cmp);\n    /*\n    for (int i = 0; i < es.size();i++){\n        cout << es[i].cost << \" \";\n    }\n    cout << endl;\n    */\n    \n\n\n    double ans = 0;\n    for (int i = 0; i < es.size(); i++){\n        edge e = es[i];\n        if(!same(e.from,e.to)){\n            unite(e.from, e.to);\n        }else{\n            ans += e.cost;\n        }\n    }\n    printf(\"%.3lf\", ans);\n\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(const int& n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(const int& x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\n// void unite(int x,int y){\n// \tx = find(x); y = find(y);\n\n// \tif(x==y) return;\n// \tif(ran[x] < ran[y]){\n// \t\tpa[x] = y;\n// \t}else{\n// \t\tpa[y] = x;\n// \t\tif(ran[x] == ran[y])\n// \t\t\t++ran[x];\n// \t}\n// }\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (ran[x] < ran[y])\n\t{\n\t\tpa[x] = y;\n\t}\n\telse\n\t{\n\t\tpa[y] = x;\n\t\tif (ran[x] == ran[y])\n\t\t{\n\t\t\t++ran[x];\n\t\t}\n\t}\n}\n\nbool same(const int& x,const int& y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 1000005\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n//\nint par_uf[100010],rank_uf[100010];\n\nvoid init(int n){for(int i=0;i<n;i++){par_uf[i]=i;rank_uf[i]=0;}}\nint find(int x){if(par_uf[x]==x)return x;else return par_uf[x]=find(par_uf[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank_uf[x]<rank_uf[y])par_uf[x]=y;else{par_uf[y]=x;if(rank_uf[x]==rank_uf[y])rank_uf[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n//\n\nint N,M,x[10010],y[10010];\npair<double,pi> e[100010];\n\n#define sq(x) ((x)*(x))\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M;\n\trep(i,N)cin>>x[i]>>y[i];\n\tdouble ans=0;\n\trep(i,M){\n\t\tint p,q;\n\t\tcin>>p>>q;\n\t\tp--;q--;\n\t\tdouble len=sqrt(sq(x[p]-x[q])+sq(y[p]-y[q]));\n\t\tans+=len;\n\t\te[i]=mp(-len,mp(p,q));\n\t}\n\tsort(e,e+M);\n\tinit(N);\n\trep(i,M){\n\t\tint p=e[i].sec.fir,q=e[i].sec.sec;\n\t\tif(!same(p,q)){\n\t\t\tans+=e[i].fir;\n\t\t\tunite(p,q);\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(16)<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <stack>\n#include <array>\n#include <fstream>\n\n#define REP(i,n) for(int (i) = 0;(i) < (n) ; ++(i))\n#define REPA(a,i,n) for(int (i) = (a) ; (i) < (n) ; ++(i))\n#if defined(_MSC_VER)||__cplusplus > 199711L\n#define AUTO(r,v) auto r = (v)\n#else\n#define AUTO(r,v) typeof(v) r = (v)\n#endif\n#define ALL(c) (c).begin() , (c).end()\n#define EACH(it,c) for(AUTO(it,(c).begin());it != (c).end();++it)\n#define LL signed long  \n#define int LL\n#define INF  99999999\n#define DEV 1000000007\n#define QUICK_CIN ios::sync_with_stdio(false); cin.tie(0);\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size,-10) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\n};\n\nint n, m;\n\ntypedef pair<int, int> point;\n\npoint points[10010];\n\nstruct  edge{\n\tint to, from;\n\tdouble cost;\n};\n\nvector<edge> graph;\n\nUnionFind uf(10010);\n\nsigned main()\n{\n\t//QUICK_CIN;\n\t//ifstream cin(\"debug.txt\");\n\n\tcin >> n >> m;\n\n\tREP(i, n){\n\t\tcin >> points[i].first >> points[i].second;\n\t}\n\n\tauto dist = [](point a, point b)->double\n\t{\n\t\tauto dx = (a.first - b.first);\n\t\tauto dy = (a.second - b.second);\n\t\treturn (double)sqrt(dx*dx + dy*dy);\n\t};\n\n\tedge p;\n\tREP(i, m){\n\t\tcin >> p.from >> p.to;\n\t\t--p.from; --p.to;\n\t\tp.cost = dist(points[p.from], points[p.to]);\n\t\tgraph.push_back(p);\n\t}\n\n\tsort(graph.begin(), graph.end(), [](edge a, edge b){return a.cost > b.cost; });\n\n\tdouble res(0);\n\n\n\tREP(i, m){\n\t\tauto e = graph[i];\n\n\t\tif (!uf.findSet(e.from, e.to)){\n\t\t\tuf.unionSet(e.from, e.to);\n\t\t}\n\t\telse{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\tprintf(\"%.3lf\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[12000];\nint N, M, a, b; double x[12000], y[12000], d[12000]; int g[12000];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\tfor (int t = 1; t <= N; t++) {\n\t\tif (g[t] >= 2)continue;\n\t\td[t] = 0; g[t] = 1;\n\t\twhile (true) {\n\t\t\tint OK = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1)OK = 0;\n\t\t\t}\n\t\t\tif (OK == 1)break;\n\t\t\tdouble maxn = -1; int maxid = 0;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[maxid] = 2;\n\t\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 10000 + 1\nusing namespace std;\n\nstruct node{\n\tint x, y;\n};\n\nstruct edge{\n\tint from, to;\n\tdouble cost;\n\t\n\tbool operator < (const edge &other) const{\n\t\treturn cost > other.cost;\n\t}\n};\n\nint V, E;\nint root[MAX_V];\nnode n[MAX_V];\nvector<edge> G;\n\nvoid init(){\n\tfor(int i = 1; i <= V; i++)\n\t\troot[i] = i;\n}\n\nint find(int x){\n\tif(x == root[x]) return x;\n\treturn find(root[x]);\n}\n\nbool same(int a, int b){\n\ta = find(a);\n\tb = find(b);\n\tif(a != b){\n\t\troot[a] = b;\n\t\treturn true;\n\t}\n\telse return false;\n}\n\ndouble Kruskal(){\n\tinit();\n\tdouble sum = 0;\n\tsort(G.begin(), G.end());\n\t\t\n\tfor(int i = 0; i < G.size(); i++){\n\t\tedge e = G[i];\n\t\tif(same(e.from, e.to))\n\t\t\tsum += e.cost;\n\t}\n\t\n\treturn sum;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t\n\tdouble all = 0, ans = 0;\n\t\n\tcin >> V >> E;\n\t\n\tfor(int i = 1; i <= V; i++)\n\t\tcin >> n[i].x >> n[i].y;\n\t\n\tfor(int i = 0; i < E; i++){\n\t\tedge e;\n\t\tint from, to;\n\t\tcin >> from >> to;\n\t\te.from = from, e.to = to;\n\t\te.cost = sqrt((n[from].x - n[to].x) * (n[from].x - n[to].x) + (n[from].y - n[to].y) * (n[from].y - n[to].y));\n\t\tG.push_back(e);\n\t\tall += e.cost;\n\t}\n\t\n\tans = Kruskal();\n\tans = all - ans;\n\tprintf(\"%.3lf\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nvector<int> g[10010];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<vector<double>> v;\n\tvector<int> h(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--, b--;\n\t\tdouble dist = sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b]));\n\t\tv.push_back({ dist, (double)a, (double)b });\n\t\th[a]++, h[b]++;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\t\n\tsort(v.begin(), v.end());\n\t\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (h[v[i][1]] <= 1 || h[v[i][2]] <= 1) continue;\n\t\tret += v[i][0];\n\t\th[v[i][1]]--, h[v[i][2]]--;\n\t\tint now = v[i][1];\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\tnow = v[i][2];\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << ret << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  vector<vector<int> > array;\n  int i, j, k, t1, t2, s, t;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++) {\n    vector<int> temp;\n    temp.push_back(i + 1);\n    array.push_back(temp);\n  }\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < array.size(); j++){\n      for(k = 0; k < array.at(j).size(); k++) {\n\tif(links[i].node1 == array.at(j).at(k))\n\t  t1 = j;\n\telse if(links[i].node2 == array.at(j).at(k))\n\t  t2 = j;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      while(!array.at(t2).empty()) {\n\tarray.at(t1).push_back(array.at(t2).back());\n\tarray.at(t2).pop_back();\n      }\n      array.erase(array.begin() + t2);\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct fence{\n  int u,v;\n  double cost;\n};\n\n#define N 10000\n\n//2点間の距離を求める\ndouble distance(int x1,int y1,int x2,int y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\n//fenceはcostの大きさで降順ソートしたいので不等号はこの向き\nbool cmp(const fence &a,const fence &b){\n  return a.cost > b.cost;\n}\n\nint main(){\n  int n,m;\n  P piles[N];\n  vector<fence> fences;\n\n  scanf(\"%d%d\",&n,&m);\n  for(int i=0;i<n;i++){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    piles[i] = P(x,y);\n  }\n  for(int i=0;i<m;i++){\n    int p,q;\n    scanf(\"%d%d\",&p,&q);\n    p--;q--;\n    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);\n    fences.push_back((fence){p,q,c});\n  }\n\n  double sum = 0;\n  bool used[N];\n  fill(used,used+n,false);\n  sort(fences.begin(),fences.end(),cmp);\n  for(int i=0;i<m;i++){\n    int u = fences[i].u;\n    int v = fences[i].v;\n    if(used[u]&&used[v]){\n      sum += fences[i].cost;\n    }else{\n      used[u] = true; used[v] = true;\n    }\n  }\n\n  printf(\"%.3f\\n\",sum);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint fa[2002];\nint n, m;\nint num;\nstruct edge{\n\tint u;\n\tint v;\n\tdouble cost;\n};\nbool cmp(edge a, edge b){\n\treturn a.cost < b.cost;\n}\nedge es[1000000];\nint find(int a){\n\tif (a == fa[a]) return a;\n\telse return fa[a] = find(fa[a]);\n}\nbool same(int a, int b){\n\tint aa = find(a);\n\tint bb = find(b);\n\tif (aa==bb) return true;\n\telse return false;\n}\n\nvoid unite(int a, int b){\n\tint aa = fa[a];\n\tint bb = fa[b];\n\tif (aa != bb){\n\t\tfa[aa] = bb;\n\t}\n}\nint max(int a, int b){\n\tif (a > b)return a;\n\telse return b;\n\n}\nint krusal(){\n\t\n\tsort(es, es + num, cmp);\n\tint res = -10;\n\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\tfor (int i = 0; i < num; i++){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres=max(res,e.cost);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\t\n\tcin >> n >> m;\n\t\n\tnum = 0;\n\tint u, v,d;\n\t\n\t\n\twhile (m--){\n\t\tcin >> u >> v >> d;\n\t\t\n\t\t\tes[num].u = u;\n\t\t\tes[num].v = v;\n\t\t\tes[num++].cost = d;\n\t\t\t\n\t}\n\t\n\tprintf(\"%ld\\n\", krusal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,int> Pdi;\n#define N 10000\nstruct fence{\n  int to;\n  double cost;\n};\n\n//2点間の距離を求める\ndouble distance(int x1,int y1,int x2,int y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint main(){\n  int n,m;\n  P piles[N];\n  vector<fence> fences[N];\n  double costsum = 0;\n\n  scanf(\"%d%d\",&n,&m);\n  for(int i=0;i<n;i++){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    piles[i] = P(x,y);\n  }\n  for(int i=0;i<m;i++){\n    int p,q;\n    scanf(\"%d%d\",&p,&q);\n    p--;q--;\n    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);\n    fences[p].push_back((fence){q,c});\n    fences[q].push_back((fence){p,c});\n    costsum += c;\n  }\n\n  double sum = 0;\n  bool used[N];\n  fill(used,used+n,false);\n\n  priority_queue<Pdi> que;\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      que.push(Pdi(0,i));\n      while(que.size()){\n        Pdi p = que.top(); que.pop();\n        int pos = p.second;\n        if(used[pos]) continue;\n        used[pos] = true;\n        sum += p.first;\n        for(int j=0;j<fences[pos].size();j++){\n          que.push(Pdi(fences[pos][j].cost,fences[pos][j].to));\n        }\n      }\n    }\n  }\n\n  printf(\"%.3f\\n\",costsum-sum);\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nint n,m;\nint pa[20000];\n\nvoid init()\n{\n    for(int i=1;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x] != x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return (t.w - w) < 1e-6;\n    }\n}e[20000];\n\nstruct point\n{\n    double x,y;\n}p[20000];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\n\nint main()\n{\n    //freopen(\"C:in.txt\",\"r\",stdin);\n    //freopen(\"C:out.txt\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(p,0,sizeof(p));\n        memset(e,0,sizeof(e));\n\n        init();\n        double sum = 0;\n\n        for(int i=1;i<=n;i++)\n            scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty;\n            e[i].w = sqrt((p[tx].x - p[ty].x)*(p[tx].x - p[ty].x) + (p[tx].y - p[ty].y)*(p[tx].y - p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct Edge {\n  int to;\n  double cost;\n  Edge() {}\n  Edge(int to, double cost) : to(to), cost(cost) {}\n};\n\nconst int MAX_N = 10005;\nint N;\nP Ps[MAX_N];\nvector<Edge> E[MAX_N];\ndouble allEdge;\n\nvoid init() {\n  for(int i = 0; i < MAX_N; ++i)\n    E[i].clear();\n  allEdge = 0.0;\n}\n\nvoid addEdge(int p, int q) {\n  double cost = abs(Ps[p]-Ps[q]);\n  E[p].push_back(Edge(q,cost));\n  E[q].push_back(Edge(p,cost));\n  allEdge += cost;\n}\n\ndouble mst(int st) {\n  priority_queue<pair<double,int> > que;\n  bool vis[MAX_N];\n  double sum = 0.0;\n  fill(vis, vis+N, false);\n  que.push(make_pair(0.0, st));\n  while(!que.empty()) {\n    pair<double,int> p = que.top();\n    que.pop();\n    if(vis[p.second]) continue;\n    vis[p.second] = true;\n    sum += p.first;\n    for(int i = 0; i < E[p.second].size(); ++i) {\n      Edge& e = E[p.second][i];\n      if(vis[e.to]) continue;\n      que.push(make_pair(e.cost, e.to));\n    }\n  }\n  return sum;\n}\n\nvoid dfs(int p, bool vis[]) {\n  vis[p] = true;\n  for(int i = 0; i < E[p].size(); ++i) {\n    Edge& e = E[p][i];\n    if(vis[e.to]) continue;\n    dfs(e.to, vis);\n  }\n}\n\ndouble solve() {\n  bool vis[MAX_N];\n  double sum = 0.0;\n  fill(vis,vis+MAX_N,false);\n  for(int i = 0; i < N; ++i) {\n    if(vis[i]) continue;\n    dfs(i, vis);\n    sum += mst(i);\n  }\n  return allEdge - sum;\n}\n\nint main() {\n  init();\n  int m;\n  cin >> N >> m;\n  for(int i = 0; i < N; ++i)\n    cin >> Ps[i].real() >> Ps[i].imag();\n  for(int i = 0; i < m; ++i) {\n    int p, q;\n    cin >> p >> q;\n    --p; --q;\n    addEdge(p,q);\n  }\n  printf(\"%.3f\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <queue>\n#include <stack>\nusing namespace std;\nconst int maxn=10100;\nint par[maxn],rankl[maxn];\n\n//??¶??\\???\nvoid init(int n)\n{\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tpar[i]=i;\n\t\trankl[i]=0;\n\t}\n}\nint findl(int x)\n{\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=findl(par[x]);\n}\nvoid unite(int x,int y)\n{\n\tx=findl(x);\n\ty=findl(y);\n\tif(x==y)  return;\n\tif(rankl[x]<rankl[y]){\n\t\tpar[x]=y;\n\t}else\n\t{\n\t\tpar[y]=x;\n\t\tif(rankl[x]==rankl[y])  rankl[x]++;\n\t}\n}\nbool same(int x,int y)\n{\n\treturn findl(x)==findl(y);\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n};\nbool cmp(const edge e1,const edge e2)\n{\n\treturn e1.cost<e2.cost;\n}\nedge es[maxn];\nint n,m;\ndouble kruskal()\n{\n\tsort(es+1,es+m+1,cmp);\n\tinit(n);\n\tdouble res=0;\n\tfor(int i=1;i<=m;i++){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\ndouble  a[maxn],b[maxn];\nstruct app\n{\n\tint x,y;\n};\napp s[maxn];\ndouble distance(double x1,double y1,double  x2,double  y2)\n{\n\tdouble t1=(x1-x2)*(x1-x2);\n\tdouble t2=(y1-y2)*(y1-y2);\n\treturn sqrt(t1+t2);\n}\nint main()\n{\n    while(cin>>n>>m)\n\t{\n\t\tmemset(a,0,sizeof(a));\n\t\tmemset(b,9,sizeof(b));\n\t\tfor(int i=1;i<=n;i++)     //?????\\????????????\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&a[i],&b[i]);\n\t\t}\n\t\tdouble hh=0.0;\n\t\tfor(int i=1;i<=m;i++)   //?????\\????????????\n\t\t{\n\t\t\tscanf(\"%d%d\",&s[i].x,&s[i].y);\n\t\t\tint x=s[i].x,y=s[i].y;\n\t\t\tes[i].u=x,es[i].v=y;\n\t\t\tes[i].cost=-distance(a[x],b[x],a[y],b[y]);\n\t\t\t hh+=-es[i].cost;\n\t\t}\n\t\tdouble tt=0-kruskal();\n\t\tprintf(\"%.3lf\\n\",hh-tt);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n#define INF 0x3fffffff\n#define maxn 10001\nint n, m;//頂點個數  邊的個數\nstruct edge {\n\tint u, v;\n\tdouble w;\n}e[50001];\nstruct node {\n\tint x, y;\n}list[maxn];\nbool cmp(edge a, edge b) { return a.w > b.w; }\nint tree[maxn];\nint findroot(int a) {\n\tif (tree[a] == -1)return a;\n\telse {\n\t\tint tmp = findroot(tree[a]);\n\t\ttree[a] = tmp;//路徑壓縮\n\t\treturn tmp;\n\t}\n}\ndouble compute(node a, node b) {\n\treturn sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n}\nbool hebing(int a, int b) {\n\ta = findroot(a);\n\tb = findroot(b);\n\tif (a != b) {\n\t\ttree[a] = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\nvoid init(int x) {\n\tfor (int i = 1; i <= x; i++) {\n\t\ttree[i] = -1;\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m) != EOF) {\n\t\tinit(n);\n\t\tdouble all = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tscanf(\"%d%d\", &list[i].x, &list[i].y);\n\t\t}\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\te[i].u = a; e[i].v = b;\n\t\t\te[i].w = compute(list[a], list[b]);\n\t\t\tall += e[i].w;\n\t\t}\n\t\tsort(e + 1, e + 1 + m, cmp);\n\t\tdouble ans = 0;\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (hebing(e[i].u, e[i].v)) {\n\t\t\t\tans += e[i].w;\n\t\t\t}\n\t\t}\n\t\tans = all - ans;\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct nodeI\n{\n    double x;\n    double y;\n};\n\nstruct nodeII\n{\n    int u;\n    int v;\n    double w;\n};\n\nnodeI point[10010];\nnodeII edge[1000010];\nint f[10010];\nint n,m;\n\ndouble cal(int u,int v)\n{\n    double sum;\n    sum=sqrt((point[u].x-point[v].x)*(point[u].x-point[v].x)+(point[u].y-point[v].y)*(point[u].y-point[v].y));\n    return sum;\n}\n\nint cmp(nodeII n1,nodeII n2)\n{\n    return n1.w>n2.w;\n}\n\nint getf(int p)\n{\n    if(f[p]==p)\n    {\n        return p;\n    }\n    else\n    {\n        f[p]=getf(f[p]);\n        return f[p];\n    }\n}\n\nint unite(int u,int v)\n{\n    int fu,fv;\n    fu=getf(u);\n    fv=getf(v);\n    if(fu!=fv)\n    {\n        f[fv]=fu;\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nint main()\n{\n    double sum1,sum2;\n    int i,cnt;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        for(i=1;i<=n;i++)\n        {\n            scanf(\"%lf%lf\",&point[i].x,&point[i].y);\n        }\n        sum1=0;\n        for(i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&edge[i].u,&edge[i].v);\n            edge[i].w=cal(edge[i].u,edge[i].v);\n            sum1+=edge[i].w;\n        }\n        for(i=1;i<=n;i++)\n        {\n            f[i]=i;\n        }\n        sort(edge+1,edge+m+1,cmp);\n        sum2=0,cnt=0;\n        for(i=1;i<=m;i++)\n        {\n            if(unite(edge[i].u,edge[i].v))\n            {\n                sum2+=edge[i].w;\n                cnt++;\n            }\n            if(cnt==n-1) break;\n        }\n        printf(\"%.3f\\n\",sum1-sum2);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ld=long double;\nstruct Edge{\n    int from,to;\n    ld cost;\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\nld mst(int n,Graph& g){\n    vector<int> used(n,false);\n    priority_queue<pair<ld,int>> que;\n    que.push({0,0});\n    ld res=0;\n    while(!que.empty()){\n        auto ret=que.top();\n        que.pop();\n        int v=ret.second;;\n        ld cost=ret.first;\n        if(used[v]) continue;\n        used[v]=true;\n        res+=cost;\n        for(int i=0;i<g[v].size();i++){\n            que.push({g[v][i].cost,g[v][i].to});\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<ld> x(n),y(n);\n    for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n    Graph g(n);\n    ld sum=0;\n    for(int i=0;i<m;i++){\n        int p,q;\n        cin>>p>>q;\n        p--,q--;\n        ld dist=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n        sum+=dist;\n        g[p].push_back(Edge{p,q,dist});\n        g[q].push_back(Edge{q,p,dist});\n    }\n    for(int i=1;i<n;i++){\n        g[0].push_back(Edge{0,i,0});\n        g[1].push_back(Edge{i,0,0});\n    }\n    cout<<setprecision(10)<<fixed;\n    cout<<sum-mst(n,g)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0; int C = 0;\n\n\tfor (int p = 0; p < V; p++)\n\t{\n\t\tif (u[p]) { continue; }\n\n\t\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\t\tque.push(make_pair(0.0, p)); C++;\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\t\tint v = r.second;\n\n\t\t\tif (u[v]) { continue; }\n\n\t\t\tres += r.first; u[v] = true;\n\n\t\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t\t{\n\t\t\t\tif (!u[G[v][i].first])\n\t\t\t\t{\n\t\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ret = 0.0;\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret += G[i][j].second;\n\t\t}\n\t}\n\n\tret = ret / 2 - res;\n\n\tprintf(\"%.9f\\n\", 100000.0 * (E - V + C) - ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//worst O(E*log(V))\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 0x7fffffff;\nconst int MAXV=10000+5;\n\nstruct edge{ int to; double cost; };\nstruct Point { int x,y; };\ntypedef pair<double, int> P; //first is max distance, second is vertex id\n\nint V,M;\nvector<edge> G[MAXV];\nPoint pts[MAXV];\ndouble maxcost[MAXV];    //min cost from set X to other vertices\nbool used[MAXV]; //used = true means in set X\n\ndouble prim(int ss)\n{\n    //make priority queue sort bigger integer first\n    priority_queue<P, vector<P> > que;\n    \n    maxcost[ss]=0.0;\n    double res = 0.0;\n    que.push(P(0.0,ss));\n\n    while(!que.empty())\n    {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(used[v]) continue;\n        used[v] = true;\n        res += maxcost[v];\n        for(int i=0;i<G[v].size();++i)\n        {\n            edge e = G[v][i];\n            if(maxcost[e.to] < e.cost)\n            {\n                maxcost[e.to] = e.cost;\n                if(!used[e.to])\n                    que.push(P(e.cost, e.to));\n            }\n        }\n    }\n\n    return res;\n}\n\ndouble getDistance(const Point &p1, const Point &p2)\n{\n    return sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\nint main()\n{\n    scanf(\"%d%d\",&V,&M);\n    {\n        for(int i=0;i<V;++i) G[i].clear();\n        for(int i=0;i<V;++i)\n            scanf(\"%d%d\",&pts[i].x,&pts[i].y);\n        int from,to;\n        double all=0.0;\n        for(int i=0;i<M;++i){\n            scanf(\"%d%d\",&from,&to);\n            from--; to--;\n            double dis = getDistance(pts[from], pts[to]);\n            all += dis;\n            G[from].push_back(edge{to, dis});\n            G[to].push_back(edge{from, dis});\n        }\n\n        fill(maxcost, maxcost+V, 0);\n        fill(used, used+V, false);\n\n        for(int i=0;i<V;++i) {\n            if(!used[i]) {\n                double res = prim(i);\n                all -= res;\n            }\n        }\n        printf(\"%lf\\n\", all);\n        //cout<<all<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<memory>\n#include<functional>\n\nusing namespace std;\n\n#define ALL(g) (g).begin(),(g).end()\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i,n) REP(i,0,n)\n#define F(i,j,k) fill(i[0],i[0]+j*j,k)\n#define P(p) cout<<(p)<<endl;\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define INF 1<<25\n#define pb push_back\n\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef vector<double> vd;\ntypedef pair<int,int> pii;\ntypedef pair<long,long> pll;\ntypedef long long ll;\n\ndouble dist(pii a, pii b){\n    return sqrt((a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second));\n}\n\nclass UnionFind{\nprivate:\n    vi par;\n    vi rank;\n    int find(int x){\n        if (par[x] == -1) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\npublic:\n    UnionFind(int size)\n        :par(size, -1)\n        ,rank(size, 0)\n    {\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x==y) return;\n\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n\n    bool same (int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct edge {\n    int from, to;\n    double length;\n    bool operator <(const edge& e) const {\n        return length < e.length;\n    }\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    vector<pii> pile(n+1);\n    REP(i, 1, n+1){\n        int x, y;\n        cin >> x >> y;\n        pile[i] = {x, y};\n    }\n    priority_queue<edge> que;\n    rep(i, m){\n        int p, q;\n        cin >> p >> q;\n        que.push({p, q, dist(pile[p], pile[q])});\n    }\n    UnionFind u(n+1);\n    double cost = 0;\n    while(!que.empty()){\n        edge e = que.top(); que.pop();\n        if (!u.same(e.from, e.to))\n            u.unite(e.from, e.to);\n        else\n            cost += e.length;\n    }\n    printf(\"%.3f\\n\", cost);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXV = 10001;\nconst int MAXE =  MAXV * (MAXV);\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair<int, int> P; // 坐标点\nP p[MAXV];\n//int cost[MAXV][MAXV];\n//int mincost[MAXV];\n//bool visited[MAXV];\nint N, M;\nint V, E;\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tEdge(int _from=0, int _to=0, double _cost = 0.0) :from(_from), to(_to), cost(_cost){}\n};\nEdge edge[MAXE];\nint father[MAXV];\nbool cmp(const Edge& a, const Edge& b) {\n\treturn a.cost > b.cost;\n}\nvoid Init(int n) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfather[i] = i;\n\t}\n}\nint Find(int x) {\n\tif (father[x] == x)\n\t\treturn x;\n\telse\n\t\treturn father[x] = Find(father[x]);\n}\nvoid Unite(int x, int y) {\n\tx = Find(x);\n\ty = Find(y);\n\tif (x == y)\n\t\treturn;\n\telse\n\t\tfather[y] = x;\n}\nbool same(int x, int y) {\n\treturn Find(x) == Find(y);\n}\ndouble Kruskal() {\n\tInit(MAXV);\n\tsort(edge, edge + E, cmp);\n\tdouble res = 0;\n\tint cnt = 0;\n\tfor (int i = 0; i < E; ++i) {\n\t\tEdge e = edge[i];\n\t\tif (!same(e.from, e.to)) {\n\t\t\tUnite(e.from, e.to);\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tres += e.cost;\n\t\t}\n\t\t//if (cnt == V - 1)\n\t\t//\tbreak;\n\t}\n\t//if (cnt < V - 1)\n\t//\treturn -1;\n\t//else\n\t\treturn res;\n}\n//struct Edge {\n//\tint to, cost;\n//\tEdge(int _to = 0, int _cost = 0) :to(_to), cost(_cost){}\n//};\n//vector<Edge> edge[MAXE];\n//int Prim() {\n//\tfill(mincost, mincost + MAXV, 0);\n//\tfill(visited, visited + MAXV, false);\n//\tmincost[0] = 0;\n//\tint res = 0;\n//\tint cnt = 0;\n//\tpriority_queue<P> que;\n//\tque.push(P(0, 0));\n//\twhile (!que.empty()) {\n//\t\tP p = que.top(); que.pop();\n//\t\tint v = p.second;\n//\t\tif (visited[v] || mincost[v] > p.first)\n//\t\t\tcontinue;\n//\t\tres += mincost[v];\n//\t\tvisited[v] = true;\n//\t\tcnt++;\n//\t\tfor (int i = 0; i < edge[v].size(); ++i) {\n//\t\t\tEdge e = edge[v][i];\n//\t\t\tif (mincost[e.to] < e.cost) {\n//\t\t\t\tmincost[e.to] = e.cost;\n//\t\t\t\tque.push(P(mincost[e.to], e.to));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tif (cnt < V)\n//\t\treturn -1;\n//\telse if (cnt)\n//\t\treturn res;\n//}\nvoid solve() {\n\tdouble res = Kruskal();\n\tprintf(\"%.3f\\n\", res);\n}\nint main(int argc, char const *argv[])\n{\n\t//std::ios::sync_with_stdio(false);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &N, &M) != EOF) {\n\t\tV = N; E = 0;\n\t\tmemset(edge, 0, sizeof(edge));\n\t\tint x, y;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp[i].first = x;\n\t\t\tp[i].second = y;\n\t\t}\n\t\tint from, to, cost;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tscanf(\"%d%d\", &from, &to);\n\t\t\t--from; --to;\n\t\t\tint dx = abs(p[from].first - p[to].first);\n\t\t\tint dy = abs(p[from].second - p[to].second);\n\t\t\tdouble dist = sqrt(dx * dx + dy * dy);\n\t\t\tedge[E++] = Edge(from, to, dist);\n\t\t}\n\t\tsolve();\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define db double\n#define ll long long\n#define RG register\n\ninline int gi()\n{\n\tRG int ret; RG bool flag; RG char ch;\n\tret=0, flag=true, ch=getchar();\n\twhile (ch < '0' || ch > '9')\n\t\tch == '-' ? flag=false : 0, ch=getchar();\n\twhile (ch >= '0' && ch <= '9')\n\t\tret=(ret<<3)+(ret<<1)+ch-'0', ch=getchar();\n\treturn flag ? ret : -ret;\n}\n\nconst db pi = acos(-1.0);\nconst int N = 1e4+5, inf = 1<<30;\n\nstruct poi\n{\n\tint x,y;\n}p[N];\nstruct edge\n{\n\tint fr,to;\n\tdb dis;\n\tinline bool operator <(const edge &E) const { return dis > E.dis; }\n}e[N<<1];\nint fa[N];\n\ninline db Dis(int a,int b)\n{\n\treturn sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y));\n}\n\ninline int find(int o)\n{\n\treturn fa[o] == o ? o : fa[o]=find(fa[o]);\n}\n\nint main()\n{\n\tint n,m,i,x,y;\n\tdb ans,len;\n\tn=gi(), m=gi();\n\tfor (i=1; i<=n; ++i)\n\t\tp[i].x=gi(), p[i].y=gi();\n\tans=0;\n\tfor (i=1; i<=m; ++i)\n\t\te[i].fr=x=gi(), e[i].to=y=gi(), e[i].dis=len=Dis(x,y), ans+=len;\n\tsort(e+1,e+m+1);\n\tfor (i=1; i<=n; ++i)\n\t\tfa[i]=i;\n\tfor (i=1; n>1 && i<=m; ++i)\n\t\t{\n\t\t\tx=e[i].fr, y=e[i].to;\n\t\t\tx=find(x), y=find(y);\n\t\t\tif (x != y)\n\t\t\t\tans-=e[i].dis, fa[x]=y, n--;\n\t\t}\n\tprintf(\"%.3f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <functional>\n\nusing namespace std;\n\nint par[10016], rank[10016];\n\nvoid init(int x)\n{\n\tint i;\n\tfor (i = 0; i < x; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unit(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t\treturn;\n\tif (rank[x] < rank[y])\n\t\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nint same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\ntypedef struct\n{\n\tint u, v;\n\tdouble d;\n}EDG;\ntypedef struct\n{\n\tint x, y;\n}P;\n\nP p[10016];\nEDG e, G[20032];\nint n, m;\ndouble res = 0;\n\ninline int doub(int x)\n{\n\treturn x * x;\n}\n\nint mycmp(EDG e1, EDG e2)\n{\n\treturn e1.d > e2.d;\n}\n\nvoid krus()\n{\n\tint i;\n\tsort(G, G + m, mycmp);\n\tinit(n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\te = G[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunit(e.u, e.v);\n\t\t\tres += e.d;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, x, y;\n\tdouble sum = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &p[i].x, &p[i].y);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d%d\", &x, &y);\n\t\te.d = sqrt(1.0 * doub(p[x].x - p[y].x) + doub(p[x].y - p[y].y));\n\t\tsum += e.d;\n\t\te.u = x; e.v = y;\n\t\tG[i] = e;\n\t}\n\tkrus();\n\tprintf(\"%.3lf\\n\", sum - res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  xzppp  */\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\n#include <cmath>\n#include <set>\n#include <iomanip>\nusing namespace std;\n#define FFF freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define MP make_pair\n#define PB push_back\ntypedef long long  LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int > pii;\ntypedef pair<double,double > pdd;\ntypedef pair<double,int > pdi;\nconst int MAXN = 1e4+17;\nconst int MAXM = 20;\nconst int MAXV = 1e4+17;\nconst int INF = 0x7fffffff;\nconst int MOD = 1e9+7;\npdd all[MAXV];\nvector<pdi > G[MAXV];\ndouble s;\nbool vis1[MAXV];\nvoid dfs(int x)\n{\n\tvis1[x]=1;\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\ts+=G[x][i].first;\n\t\t}\n\t}\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\tdfs(G[x][i].second);\n\t\t}\n\t}\n}\nbool vis[MAXV];\ndouble minc[MAXV];\ndouble prim(int x)\n{\n    for (int i = 0; i < MAXV; ++i)\n    {\n        minc[i] = 0;\n        vis[i] = 0;\n    }\n    double res = 0;\n    priority_queue<pdi> q;\n    q.push(MP(0,x));\n    while(!q.empty())\n    {\n        int v = q.top().second;\n        double temp = q.top().first;\n        q.pop();\n        if(vis[v]) continue;\n       // cout<<\"???\"<<v<<endl;\n        vis[v] = 1;\n        res += temp;\n        for (int i = 0; i < G[v].size(); ++i)\n        {\n            double d = G[v][i].first;\n            int to = G[v][i].second;\n            if(!vis[to]&&minc[to]<d)\n            {\n                q.push(MP(d,to));\n                minc[to] = d;\n            }\n        }\n    }\n    return  res;\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE \n    FFF\n    #endif\n    int n,m;\n    cin>>n>>m;\n    for (int i = 0; i < n; ++i)\n    {\n    \tdouble x,y;\n    \tscanf(\"%lf%lf\",&x,&y);\n    \tall[i].first = x;\n    \tall[i].second = y;\n    }\n    for (int i = 0; i < m; ++i)\n    {\n    \tint u,v;\n    \tscanf(\"%d%d\",&u,&v);\n    \tu--;v--;\n    \tdouble dis = sqrt((all[u].first-all[v].first)*(all[u].first-all[v].first)\n    \t\t+(all[u].second-all[v].second)*(all[u].second-all[v].second));\n    \tG[u].push_back(MP(dis,v));\n    \tG[v].push_back(MP(dis,u));\n    }\n    double ans = 0;\n    for (int i = 0; i < n; ++i)\n    {\n    \tif(!vis1[i])\n    \t{\n    \t\t//cout<<i<<endl;\n    \t\ts = 0;\n    \t\tdfs(i);\n    \t\t//cout<<s<<endl;\n    \t\tdouble left = prim(i);\n    \t\tans += s-left;\n    \t\t//cout<<\" ans\"<<s-left<<endl;\n    \t}\n    }\n    cout<<fixed<<setprecision(4)<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct edge\n{\n  int u, v, cost;\n\n  bool operator<(const edge &e) const\n  {\n    return (cost < e.cost);\n  }\n};\n\n#define SQR(x) ((x)*(x))\n\nint main()\n{\n  int N, M, X[10000], Y[10000];\n\n  scanf(\"%d %d\", &N, &M);\n  vector< edge > edges(M);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d %d\", X + i, Y + i);\n  }\n  for(int i = 0; i < M; i++) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    --U, --V;\n    edges.push_back((edge) {U, V, SQR(X[U] - X[V]) + SQR(Y[U] - Y[V])});\n  }\n  sort(begin(edges), end(edges));\n  reverse(begin(edges), end(edges));\n\n  double all = 0;\n  UnionFind tree(N);\n  for(auto &e : edges) {\n    if(!tree.unite(e.u, e.v)) all += sqrt(e.cost);\n  }\n  printf(\"%.10lf\\n\", all);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<deque> \nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long LL;\ntypedef pair<int,int> ppp;\nconst int maxn = 10010;\nint n,m;\nstruct lalala{\n\tint x,y;\n}mood[maxn];\nstruct node{\n\tint u,v;\n\tdouble dis;\n}mp[2*maxn];\ndouble work(int u,int v){\n\treturn (double)sqrt((mood[u].x-mood[v].x)*(mood[u].x-mood[v].x) + (mood[u].y-mood[v].y)*(mood[u].y-mood[v].y));\n}\nbool cmp(node a,node b){\n\treturn a.dis > b.dis;\n}\nint fa[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\n\ndouble kruskal(){\n\tsort(mp+1,mp+1+2*m,cmp);\n\tdouble ans = 0;\n\tmemset(fa,0,sizeof fa); \n\tfor (int i=1 ; i<=n ; i++) fa[i] = i;\n\tfor (int i=1 ; i<=2*m ; i++){\n\t\tint cnt1 = find(mp[i].u),cnt2 = find(mp[i].v);\n\t\tif (cnt1 != cnt2){\n\t\t\t//ans += mp[i].w;\n\t\t\tfa[cnt1] = cnt2;\n\t\t}\n\t\telse ans += mp[i].dis;\n\t}\n\treturn ans;\n}\nint main(){\n\twhile (~scanf(\"%d%d\",&n,&m)){\n\t\tfor (int i=1 ; i<=n ; i++)\n\t\t\tscanf(\"%d%d\",&mood[i].x,&mood[i].y);\n\t\tint u,v;\n\t\tfor (int i=1 ; i<=m ; i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tmp[i].u = u; mp[i].v = v; mp[i].dis = work(u,v);\n\t\t\tmp[i+m].u = v; mp[i+m].v = u; mp[i+m].dis = work(v,u);\n\t\t}\n\t\tdouble ans = kruskal();\n\t\tprintf(\"%.3f\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2224: Save Your Cats\n * ?¢?????????????????????????????????????????????±?´????????????????????±???¨????°??????±?´?????????¨???????????????????????????\n * ?±???????????°??????????\n * ?????????????±?????????????????????????????????????????£????????????????????????§????????§???????£????????¢?????°?Kruskal???????????¢???????¬?????????§???????????¨??¶??\\??????????????????\n */\n\n#include <cstdio>\n#include <queue>\n#include <iostream>\n#include <cmath>\n\nusing namespace std;\n\nstruct E{\n  E() {}\n  E(int uu, int vv, double cc): u(uu), v(vv), c(cc) {}\n  bool operator > (const E& e) const {\n    return c < e.c;\n  }\n  int u, v;\n  double c;\n};\n\nint fa[10010];\npriority_queue<E, vector<E>, greater<E> > pq;\n\nint find(int x) {\n  if(x == fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\n\ndouble Kruskal(int n) {\n  for(int i = 1; i <= n; ++i) {\n    fa[i] = i;\n  }\n  int cnt = 1;\n  double ans = 0;\n\n  while(cnt < n && !pq.empty()) {\n    const E& e = pq.top();\n    int u, v;\n    double c;\n    u = e.u;\n    v = e.v;\n    c = e.c;\n    pq.pop();\n\n    u = find(u);\n    v = find(v);\n    if(u == v) continue;\n    fa[u] = v;\n    ans += c;\n    ++cnt;\n  }\n  return ans;\n}\n\ndouble x[10010], y[10010];\n\nint main() {\n  int n, m;\n  double ans = 0;\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= n; ++i) {\n    scanf(\"%lf%lf\", &x[i], &y[i]);\n  }\n  while(m--) {\n    int u, v;\n    double c;\n    scanf(\"%d%d\", &u, &v);\n    c = sqrt((x[u]-x[v])*(x[u]-x[v]) + (y[u]-y[v])*(y[u]-y[v]));\n    ans += c;\n    pq.push(E(u, v ,c));\n  }\n  ans -= Kruskal(n);\n  printf(\"%.3f\\n\", ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n#define MAX_N 10000+5\n\n//Begin\n#define MAX_E MAX_N * MAX_N / 2 + 1\nint parent[MAX_N];\nint height[MAX_N];\n\nvoid init(const int& n){\n\tfor (int i = 0; i < n; ++i){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint find(const int& x){\n\treturn parent[x] == x ? x : parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t\treturn;\n\tif (height[x] < height[y]){\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y]){\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n\nbool same(const int& x, const int& y){\n\treturn find(x) == find(y);\n}\n//End of \n\nstruct edge{\n\tint u, v;\n\tdouble cost;\n\tedge(int u = 0, int v = 0, double cost = 0.0)\n\t\t: u(u), v(v), cost(cost) {}\n\tbool operator < (const edge & e2) const{\n\t\treturn cost > e2.cost;\n\t}\n};\n\nedge es[MAX_E];\nint V, E;\ndouble kruskal()\n{\n\tsort(es, es + E);//按照&#26435;排序\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\ntypedef pair<int, int>ip;\nip dis[MAX_N];\nint main()\n{\n\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; ++i){\n\t\tcin >> dis[i].first >> dis[i].second;\n\t}\n\tdouble sum = 0.0;\n\tfor (int i = 0; i < E; ++i){\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = dis[es[i].u].first - dis[es[i].v].first;\n\t\tint dy = dis[es[i].u].second - dis[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t\tsum += es[i].cost;\n\t}\n\tprintf(\"%.3lf\", sum - kruskal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <cstdio>\nusing namespace std;\nconst double eps = 1e-4;\nconst int max_v = 1e4;\nstruct edge {int u, v; double cost;};\nbool comp(const edge &e1, const edge &e2) {\n    return e1.cost > e2.cost;\n}\nstruct Point{int x, y;};\nPoint p[max_v + 10];\nvector <edge> es;\nint n, m;\nint par[max_v + 10], ranks[max_v + 10];\ninline double dst(Point p1, Point p2) {\n    int x1 = p1.x, y1 = p1.y;\n    int x2 = p2.x, y2 = p2.y;\n    int d1 = x1 - x2, d2 = y1 - y2;\n    return sqrt(d1 * d1 * 1.0 + d2 * d2 * 1.0);\n};\nint find(int a) {\n    if (par[a] == a) return a;\n    int r = find(par[a]);\n    par[a] = r;\n    return r;\n}\n\nvoid unite(int a, int b) {\n    int r1 = find(a);\n    int r2 = find(b);\n    if (r1 == r2) return ;\n    if (ranks[r1] > ranks[r2]) {\n        par[r2] = r1;\n        ranks[r1] += ranks[r2];\n    } else {\n        par[r1] = r2;\n        ranks[r2] += ranks[r1];\n    }\n}\nbool same(int a, int b) {\n    return find(a) == find(b);\n}\ndouble Kruskal() {\n    sort(es.begin(), es.end(), comp);\n    for (int i = 1; i <= n; i++) {\n        par[i] = i;\n        ranks[i] = 0;\n    }\n    double res = 0;\n    for (auto e : es) {\n        if (!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            res += e.cost;\n        }    \n    }\n    return res;\n}\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    for (int i = 1; i <= n; i++) \n        scanf(\"%d%d\", &p[i].x, &p[i].y);\n    \n    double totW = 0;\n    for (int i = 0; i < m; i++) {\n        int p1, p2;\n        scanf(\"%d%d\", &p1, &p2);\n        double d = dst(p[p1], p[p2]);\n        es.push_back(edge{p1, p2, d});\n        totW += d;\n    }\n    printf(\"%.3lf\\n\", totW - Kruskal());\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nvector<int> g[10010];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<pair<double, pair<int,int>>> v;\n\tvector<int> h(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--, b--;\n\t\tdouble dist = sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b]));\n\t\tv.push_back({ dist, {a, b } });\n\t\th[a]++, h[b]++;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\t\n\tsort(v.begin(), v.end());\n\t\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (h[v[i].second.second] <= 1 || h[v[i].second.first] <= 1) continue;\n\t\tret += v[i][0];\n\t\th[v[i].second.second]--, h[v[i].second.first]--;\n\t\tint now = v[i].second.first;\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\tnow = v[i].second.first;\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << ret << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// Union-Find 木 (Verified: AtCoder Typical Contest 001 B)\nstruct UnionFind {\nprivate:\n    const int n;\n    int __size;\n    vector<int> uf;\npublic:\n    // 初期化 UnionFind uni(n) のように宣言すれば良い\n    UnionFind(int _n) : n(_n), __size(_n), uf(_n, -1) {}\n    // find (木の根を求める)\n    int find(int x) {return (uf[x] < 0) ? x : uf[x] = find(uf[x]);}\n    // x と y が同じ集合に属するかどうか\n    bool same(int x, int y) {return find(x) == find(y);}\n    // x が属する集合の要素数\n    int size(int x) {return -uf[find(x)];}\n    // 集合はいくつあるか\n    int size()      {return __size;}\n    // x と y の属する集合を併合\n    void unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return;\n        __size--;\n        if(uf[y] < uf[x]) swap(x, y);\n        uf[x] += uf[y]; uf[y] = x;\n    }\n};\n\nstruct Edge {\n    int from, to;\n    double cost;\n    Edge(int a, int b, double c) : from(a), to(b), cost(c) {}\n    bool operator<(const Edge &x) const {\n        return cost > x.cost;\n    }\n};\n\nint x[10010], y[10010];\nsigned main() {\n    int N, M; scanf(\"%lld%lld\", &N, &M);\n    rep(i,0,N) {\n        scanf(\"%lld%lld\", &x[i], &y[i]);\n    }\n\n    vector<Edge> edges;\n    double ans = 0;\n    rep(i,0,M) {\n        int u, v; scanf(\"%lld%lld\", &u, &v);\n        u--; v--;\n        int x_diff = x[u] - x[v];\n        int y_diff = y[u] - y[v];\n        double cost = sqrt(x_diff*x_diff + y_diff*y_diff);\n        edges.push_back(Edge(u, v, cost));\n        ans += cost;\n    }\n\n    sort(edges.begin(), edges.end());\n    UnionFind uf(N);\n    rep(i,0,M) {\n        int u = edges[i].from, v = edges[i].to;\n        if(uf.same(u, v)) continue;\n        uf.unite(u, v);\n        ans -= edges[i].cost;\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N + 1; i++)\n    for(j = 0; j < N + 1; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      k = 0;\n      while(forest[j][k] != 0 && k < N) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      j = 0;\n      while(forest[t1][j] != 0)\n\tj++;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\ninline double sq(double x) { return x*x; }\n\ntemplate <typename Weight>\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight): src(src), dst(dst), weight(weight) {}\n    bool operator<(const Edge<Weight>& other) const { return weight < other.weight; }\n};\ntemplate <typename Weight> using Vertex = vector<Edge<Weight>>;\ntemplate <typename Weight> using Graph = vector<Vertex<Weight>>;\n\nstruct UnionFind {\n    vector<int> data;\n    explicit UnionFind(int size): data(size, -1) {}\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y];\n            data[y] = x;\n        }\n        return x != y;\n    }\n    bool find(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n};\n\ntemplate <typename Weight>\ndouble kruskal(const Graph<Weight>& g) {\n    UnionFind uf(g.size());\n\n    vector<Edge<Weight>> edges;\n    for (auto& v : g) edges.insert(edges.end(), v.begin(), v.end());\n    sort(edges.begin(), edges.end());\n\n    Weight total = 0;\n    for (auto& e : edges) {\n        if (uf.merge(e.src, e.dst)) {\n            total += e.weight;\n        }\n    }\n    return total;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M;\n    while (cin>>N>>M) {\n        vector<pair<int, int>> piles(N), fances(M);\n        REP(i, N) cin >> piles[i].first >> piles[i].second;\n        REP(i, M) {\n            cin >> fances[i].first >> fances[i].second;\n            --fances[i].first; --fances[i].second;\n        }\n\n        Graph<double> g(N);\n        double total = 0;\n        REP(i, M) {\n            auto& p1 = piles[fances[i].first];\n            auto& p2 = piles[fances[i].second];\n            double length = sqrt(sq(p1.first - p2.first) + sq(p1.second - p2.second));\n            g[fances[i].first].emplace_back(fances[i].first, fances[i].second, -length);\n            total += length;\n        }\n\n        double w = -kruskal(g);\n        cout << setprecision(10) << total - w << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = maxn*(maxn-1)/2;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<cmath>\n#define MAX 10000\n#define MP make_pair\n#define INF (1<<21)\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\nint parent[MAX];\n\nint findRoot(int x)\n{\n\tif (parent[x] != x)\n\t{\n\t\tparent[x] = findRoot(parent[x]);\n\t}\n\telse\n\t{\n\t\treturn x;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn findRoot(x) == findRoot(y);\n}\n\nvoid unite(int x, int y)\n{\n\tint root1 = findRoot(x);\n\tint root2 = findRoot(y);\n\tparent[root1] = root2;\n}\n\ntypedef double Weight;\ntypedef pair<int, int> Pair;\ntypedef pair<Weight, Pair> Edge;\n\npriority_queue<Edge> q;\n\ndouble kruskal()\n{\n\tREP(i, MAX)\n\t{\n\t\tparent[i] = i;\n\t}\n\tdouble total = 0.0;\n\tdouble total_ans = 0.0;\n\twhile (!q.empty())\n\t{\n\t\tEdge top = q.top();\n\t\tint X = top.second.first;\n\t\tint Y = top.second.second;\n\t\tif (same(X, Y) == false)\n\t\t{\n\t\t\tunite(X, Y);\n\t\t\ttotal += top.first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotal_ans += top.first;\n\t\t}\n\t\tq.pop();\n\t}\n\treturn total_ans;\n}\n\npair<int,int> Z[MAX];\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tREP(i, N)\n\t{\n\t\tint px, py;\n\t\tcin >> px >> py;\n\t\tZ[i] = MP(px, py);\n\t}\n\tREP(i, M)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tdouble tmp_x = Z[x-1].first - Z[y-1].first;\n\t\tdouble tmp_y = Z[x-1].second - Z[y-1].second;\n\t\tdouble w = sqrt(tmp_x*tmp_x + tmp_y*tmp_y);\n\t\tq.push(MP(w, MP(x, y)));\n\t}\n\n\tcout << fixed << setprecision(10) << kruskal() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define fi first\n#define se second\n#define pi acos(-1)\n#define inf 0x3f3f3f3f\n#define lson l,mid,rt<<1\n#define rson mid+1,r,rt<<1|1\n#define rep(i,x,n) for(int i=x;i<n;i++)\n#define per(i,n,x) for(int i=n;i>=x;i--)\nusing namespace std;\ntypedef pair<int,int>P;\nconst int MAXN=100010;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nP p[MAXN];\ndouble Dis(P &a, P &b)\n{\n\treturn sqrt((a.fi - b.fi) * (a.fi - b.fi) + (a.se - b.se) * (a.se - b.se));\n}\nstruct node{\n\tint u,v;\n\tdouble w;\n\tnode(int _u = 0, int _v = 0, double _w = 0) : u(_u), v(_v), w(_w){\n\t}\n\tbool operator < (node a) const\n\t{\n\t\treturn w > a.w;\n\t}\n}mp[MAXN*1000];\nint f[MAXN];\nint getf(int k)\n{\n\treturn k == f[k] ? k : f[k] = getf(f[k]);\n}\ndouble kruskal(int n)\n{\n\tint i = 0, cnt = 1;\n\tdouble sum = 0;\n\twhile(i < n && cnt < n)\n\t{\n\t\tint u = getf(mp[i].u);\n\t\tint v = getf(mp[i].v);\n\t\tif(u != v)\n\t\t{\n\t\t\tf[u] = v;\n\t\t\tcnt++;\n\t\t\tsum += mp[i].w;\n\t\t}\n\t\ti++;\n\t}\n\treturn sum;\n}\nint main()\n{\n\tint n, m, u, v;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d %d\", &p[i].fi, &p[i].se);\n\t\tf[i] = i;\n\t}\n\tdouble sum = 0;\n\tfor(int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tmp[i] = node(u, v, Dis(p[u], p[v]));\n\t\tsum += Dis(p[u], p[v]);\n\t}\n\tsort(mp, mp + m);\n\tcout << fixed << setprecision(3) << sum - kruskal(n) << endl;\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\tque.push(make_pair(0.0, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\tint v = r.second;\n\n\t\tif (u[v]) { continue; }\n\n\t\tres += r.second; u[v] = true;\n\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tif (!u[i])\n\t\t\t{\n\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\", 100000.0 * (V - 1) - res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  int kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  printf(\"%.3lf\\n\", g.sum - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#define MAX 10005\n#define MAXE MAX * (MAX - 1) / 2 + 1\n\nstruct edge { int u , v; double cost; };\nstruct node { double x , y; };\nbool comp(const edge& e1 , const edge& e2){\n    return e1.cost > e2.cost;\n}\n\nint V , E;\nint par[MAX], rank[MAX];\nnode node[MAX];\nedge es[MAXE];\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++){\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]){ \n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ndouble kruskal(){\n    std::sort(es , es + E , comp);\n    init(V);\n    double res = 0;\n    for(int i = 0;i < E;i++){\n        edge e = es[i];\n        if(find(e.u) != find(e.v)){\n            unite(e.u , e.v);\n        }else{\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    std::cin >> V >> E;\n    for(int i = 1;i <= V;i++){\n        std::cin >> node[i].x >> node[i].y;\n    }\n    for(int i = 0;i < E;i++){\n        std::cin >> es[i].u >> es[i].v;\n        es[i].cost = std::sqrt(std::pow((node[es[i].u].x - node[es[i].v].x) , 2) + std::pow((node[es[i].u].y - node[es[i].v].y) , 2));\n    }\n    std::cout << kruskal() << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n#define ll long long\n#define inf 0x3f3f3f3f\nconst int  maxv= 10010;\n\nint n, m, f[maxv];\ndouble  x[maxv], y[maxv];\nstruct E {\n    int u, v;\n    double d;\n    bool operator < (const E &e) const {\n        return d > e.d;\n    }\n}e[maxv * maxv];\n\ndouble getdis(int u, int v) {\n    return sqrt((double)(x[u]-x[v]) * (x[u]-x[v]) + (double)(y[u]-y[v]) * (y[u]-y[v]));\n}\n\nint find(int x) { return f[x] = (f[x]==x ? x : find(f[x])); }\n\nint main() {\n#ifndef ONLINE_JUDGE\n    freopen(\"F:\\\\ACM\\\\input\\\\in.txt\", \"r\", stdin);\n //   freopen(\"F:\\\\ACM\\\\input\\\\out.txt\", \"w\", stdout);\n #endif // ONLINE_JUDGE\n    while(scanf(\"%d%d\", &n, &m)!=EOF) {\n        for(int i=1; i<=n; i++) scanf(\"%lf%lf\", x+i, y+i), f[i] = i;\n        double sum = 0;\n        for(int i=0; i<m; i++) {\n            scanf(\"%d%d\", &e[i].u, &e[i].v);\n            e[i].d = getdis(e[i].u, e[i].v);\n            sum += e[i].d;\n        }\n        sort(e, e+m);\n        for(int i=0; i<m; i++) {\n            int u = e[i].u, v = e[i].v;\n            int fu = find(u), fv = find(v);\n            if(fu != fv) {\n                sum -= e[i].d;\n                f[fu] = fv;\n            }\n        }\n        printf(\"%.3f\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint parent[maxn],height[maxn];\n\n// void init(int n){\n// \tfor(int i=0; i<n; i++){\n// \t\tpa[i] = i;\n// \t\tran[i] = 0;\n// \t}\n// }\n\n// int find(int x){\n// \tif(pa[x]==x) return x;\n// \telse pa[x] = find(pa[x]);\n// }\n\n// void unite(int x,int y){\n// \tx = find(x); y = find(y);\n\n// \tif(x==y) return ;\n// \tif(ran[x] < ran[y]){\n// \t\tpa[x] = y;\n// \t}else{\n// \t\tpa[y] = x;\n// \t\tif(ran[x] == ran[y])\n// \t\t\t++ran[x];\n// \t}\n// }\n\n// bool same(int x,int y){\n// \treturn find(x) == find(y);\n// }\nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\n// double kruskal(){\n// \tsort(es,es+E);\n// \tinit(V);\n// \tdouble res = 0;\n// \tfor(int i=0; i<E; i++){\n// \t\tedge e = es[i];\n// \t\tif(!same(e.u,e.v))\n// \t\t\tunite(e.u,e.v);\n// \t\telse\n// \t\t\tres += e.cost;\n// \t}\n\n// \treturn res;\n// }\ndouble kruskal()\n{\n\tsort(es, es + E);    // ?????§??????????°???°??§??????\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n\nint main(int argc, char *argv[])\n{\n\tcin >> V >> E;\n\t\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tcin >> pile[i].first >> pile[i].second;\n\t}\n \n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t}\n \n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout << kruskal() << endl;\n\treturn 0;\n}\n// int main(){\n// \tscanf(\"%d%d\",&V,&E);\n// \tfor(int i=0; i<V; i++)\n// \t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n// \tfor(int i=0; i<E; i++){\n// \t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n// \t\t--es[i].u,--es[i].v;\n// \t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n// \t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n// \t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n// \t}\n\n// \tprintf(\"%.3lf\\n\",kruskal());\n// }"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define MAX_N 10005\nusing namespace std;\n\ntypedef struct edge\n{\n\tint from,to,cost;\n} edge;\n\nbool mcmp(edge x,edge y)\n{\n\treturn x.cost<y.cost;\n}\n\nint uft[MAX_N];\nvector<edge>e;\n\nvoid init(int n)\n{\n\tint i;\n\tfor (i=0;i<=n;i++)\n\tuft[i]=i;\n}\n\nint parent(int n)\n{\n\tif (uft[n]==n)\n\t\treturn n;\n\telse\n\t\treturn uft[n]=parent(uft[n]);\n}\n\nvoid unit(int p, int q)\n{\n\tuft[parent(p)]=parent(q);\n}\n\nint same(int p, int q)\n{\n\treturn parent(p)==parent(q);\n}\n\nint kruskal(int n,int r)\n{\n\tint res=0;\n\tsort(e.begin(),e.end(),mcmp);\n\tinit(n);\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tedge tmp=e[i];\n\t\tif(!same(tmp.from,tmp.to))\n\t\t{\n\t\t\tres+=tmp.cost;\n\t\t\tunit(tmp.from,tmp.to);\n\t\t\te[i].cost=0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint piles[10001][2];\nint m_distance(int f,int t)\n{\n\treturn pow((double)piles[f][0]-piles[t][0],2)+pow((double)piles[f][1]-piles[t][1],2);\n}\n\nint main()\n{\n\tint N,M;\n\tint all_cost=0;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&piles[i][0],&piles[i][1]);\n\tfor(int j=0;j<M;j++)\n\t{\n\t\tedge tmp;\n\t\tscanf(\"%d%d\",&tmp.from,&tmp.to);\n\t\ttmp.cost=-m_distance(tmp.from,tmp.to);\n\t\te.push_back(tmp);\n\t}\n\tkruskal(N,M);\n\tdouble res=0.0;\n\tfor(int i=0;i<M;i++)\n\t\tres+=sqrt(-(double)e[i].cost);\n\tprintf(\"%.3lf\\n\",res);\n\te.clear();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n \n// 并查集相关数据与算法\n#define MAX_N 10000 + 16\nint parent[MAX_N];\nint height[MAX_N];\n \nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n// End Of 并查集\n \n#define MAX_E MAX_N * MAX_N / 2 + 1\nstruct edge\n{\n\tint u, v;\n\tdouble cost;\n\tedge(int u = 0, int v = 0, double cost = 0) : u(u), v(v), cost(cost) {}\n\tbool operator < (const edge & e2) const\n\t{\n\t\treturn cost > e2.cost;\n\t}\n};\n \nedge es[MAX_E];\nint V, E;\ndouble kruskal()\n{\n\tsort(es, es + E);    // 按照权值从小到大排序\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n \npair<int, int> pile[MAX_N];\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n\tcin >> V >> E;\n\t\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tcin >> pile[i].first >> pile[i].second;\n\t}\n \n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t}\n \n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout << kruskal() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\ntypedef pair<double, int> P;\ndouble dist(double x, double y){\n  return sqrt(x*x + y*y);\n}\n\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int x[10000], y[10000];\n    REP(i, N)cin>>x[i]>>y[i];\n    vector<int> edges[10000];\n    double ans = 0;\n    REP(i, M){\n      int u, v; cin>>u>>v; u--; v--;\n      edges[u].push_back(v);\n      edges[v].push_back(u);\n      ans += dist(x[u]-x[v], y[u]-y[v]);\n    }\n    vector<bool> used(N);\n    priority_queue<P> que;\n    REP(i, N)if(!used[i]){\n      que.push(P(0, i));\n      while(!que.empty()){\n        P p = que.top(); que.pop();\n        if(used[p.second]) continue;\n        used[p.second] = true;\n        ans -= p.first;\n        REP(j, edges[p.second].size()){\n          int to = edges[p.second][j];\n          double d = dist(x[p.second]-x[to], y[p.second]-y[to]);\n          que.push(P(d, to));\n        }\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Problem:\n//Date:\n//Skill:\n\n#define CLR(a) memset((a),0,sizeof(a))\n#define MAX 2140000000;\n#define RE(i,n)  for(i=0;i<n;i++)\n#define RE2(i,n) for(i=1;i<=n;i++)\n#include<algorithm>\n#include<iostream>\n#include<time.h>\n#include<string.h>\n#include<math.h>\n#include<stdio.h>\nusing namespace std;\n\nstruct Edge\n{\n\tint from, to, w;\n}es[11000];\n\nint dis[110][110];\nint x[10010];\nint y[10010];\ninline int delta_sq(int i, int j)\n{\n\tint dx, dy;\n\tdx = x[i] - x[j];\n\tdy = y[i] - y[j];\n\treturn dx * dx + dy * dy;\n}\ninline int find(int x,int father[])\n{return father[x] == x ? x : father[x] = find(father[x], father);}\nint cmp(int a, int b)\n{\n\treturn es[a].w > es[b].w;\n}\ndouble kruscal(int n,int m)\n{\n\tdouble ans(0);\n\tint i, j, k;\n\tint r[11000];\n\tint father[11000];\n\n\tRE2(i,n )father[i] = i;\n\tRE2(i, m) r[i] = i;\n\n\tsort(r+1, r+1 + m, cmp);\n\tRE2(i, m)\n\t{\n\t\tEdge e = es[r[i]];\n\t\tint x = find(e.from,father), y = find(e.to,father);\n\t\tif (x != y)\n\t\t{\n\t\t\tfather[x] = y;\n//\t\t\tans = max(ans, e.w);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans += sqrt((double)e.w);\n\t\t}\n\t}\n\t/*\n\tint dif(0);\n\tint temp(-1);\n\tRE2(i, n)\n\t{\n\t\tif (find(i,father)!= temp)\n\t\t{\n\t\t\ttemp = father[i];\n\t\t\tdif++;\n\t\t}\n\t}\n\tif (dif > 1)return -1;*/\n\treturn ans;\n}\n\n//#define LOCAL\nint main()\n{\n#ifdef LOCAL\n\n\tfreopen(\"C:\\\\Users\\\\VULCAN\\\\Desktop\\\\data.in\", \"r\", stdin);\n\t//\tfreopen(\"C:\\\\Users\\\\VULCAN\\\\Desktop\\\\data.out\", \"w\", stdout);\n#endif\n\t//这是一条帅气的分界线，写程序从这里开始吧\n\tint i, j, k;\n\tint vn, en;\n\n\twhile (cin >>en>>vn) \n\t{\n\n\t\tint sumw(0);\n\t\tRE2(i, en)\n\t\t{\n\t\t\tcin >> x[i] >> y[i];\n\t\t}\n\n\n\t\t{\n\t\t\tint cnt(1);\n\t\t\tint a, b, c;\n\t\t\tRE2(i, vn)\n\t\t\t{\n\t\t\t\tcin >> es[cnt].from >> es[cnt].to;\n\t\t\t\tes[cnt].w = delta_sq(es[cnt].from, es[cnt].to);\n\t\t\t\t\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tdouble ans;\n\t\tans = kruscal(en,vn);\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\n\n\n\n\n\n\n\t//这是一条可爱的分界线\n#ifdef LOCAL\n\tprintf(\"用时%.3f秒\\n\", (double)clock() / CLOCKS_PER_SEC);\n#endif\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <vector>\n\nusing namespace std;\n\nstruct edge{\n\tint from;\n\tint to;\n\tdouble cost;\n};\n\nint a[10000], rank[10000];\n\nvoid init(){\n\tfor(int i = 0;i < 10000;i++){\n\t\ta[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(a[x] == x)\n\t\treturn x;\n\telse\n\t\treturn find(a[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(rank[x] < rank[y])\n\t\ta[x] = y;\n\telse{\n\t\ta[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\ndouble dist(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));\n}\n\nint cmp(const void* a,const void* b){\n\tstruct edge *ea = (struct edge *)a;\n\tstruct edge *eb = (struct edge *)b;\n\tif(eb->cost - ea->cost > 0)\n\t\treturn 1;\n\telse if(eb->cost - ea->cost < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nint main(void){\n\tint n, m, x[10000], y[10000], p, q, i, j, c;\n\tdouble s;\n\tstruct edge e[1000000];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\ts = 0;\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d\",&p,&q);\n\t\te[i].from = p - 1,e[i].to = q - 1;\n\t\ts += e[i].cost = dist(x[p - 1],y[p - 1],x[q - 1],y[q - 1]);\n\t}\n\tqsort(e,m,sizeof(e[0]),cmp);\n\tc = 0;\n\tinit();\n\tfor(i = 0;i < n;i++)\n\t\tif(i == a[i]) c++;\n\tfor(i = 0;i < m && c != 1;i++){\n\t\tif(find(e[i].from) != find(e[i].to)){\n\t\t\tunite(e[i].from,e[i].to);\n\t\t\ts -= e[i].cost;\n\t\t}\n\t\tc = 0;\n\t\tfor(j = 0;j < n;j++)\n\t\t\tif(j == a[j]) c++;\n\t}\n\tprintf(\"%.3f\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*AOJ2224: Save your cat\n**問題概要\n[http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224:title]\nN個の頂点とM個の辺を持った無\b向グラフがある。グラフの閉路がすべてなくなるように辺を取り除きたい。辺のコストは辺の長さである。取り除く辺のコストの最小値を求めよ。\n2 <= N <= 10000\n1 <= M\n**解法\n辺を取り除くと考えるのではなく、残す辺で全域木を作ると考えれば、これも最大全域木問題になる。クラスカル法で解く。\n*/\n#include <typeinfo>\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nstruct edge{ int u, v; double cost; };\nvector<edge> es;\nint V, E; // 頂点数と辺数\n\n//--------Union-Find木------------\nvector<int> par; // 親\nvector<int> rnk; // 深さ\n\n// Union-Find木の初期化\nvoid init_union_find(int n) {\n  par  = vector<int>(n);\n  rnk = vector<int>(n);\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n\n  if (rnk[x] < rnk[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (rnk[x] == rnk[y]) rnk[x]++;\n  }\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\n//----------クラスカル法------------\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost > e2.cost; // 大きい順\n}\ndouble kruskal() {\n  sort(es.begin(), es.end(), comp); // edge.costの大きい順\n  init_union_find(V); // Union-Findの初期化\n  double res = 0;\n  for (int i = 0; i < E; i++) {\n    edge e = es[i];\n    if (!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n      // cout << e.u+1 << \" \" << e.v+1 << endl;\n    }\n  }\n  return res;\n}\n\nint main() {\n  ifstream cin(\"../test.txt\");\n  // 初期化\n  cin >> V >> E;\n  vector<int> vx = vector<int>(V);\n  vector<int> vy = vector<int>(V);\n  es = vector<edge>(E);\n  for (int i = 0; i < V; i++) {\n    cin >> vx[i] >> vy[i];\n  }\n  double l;\n  int p, q;\n  double total_cost = 0;\n  for (int i = 0; i < E; i++) {\n    cin >> p >> q;\n    p--; q--;\n    l = sqrt(static_cast<double>((vx[p] - vx[q])*(vx[p] - vx[q]) + (vy[p] - vy[q])*(vy[p] - vy[q])));\n    // cout << typeid(l).name() << \" \";\n    // cout << l << endl;\n    edge e = {p, q, l};\n    es[i] = e;\n    total_cost += l;\n  }\n  // クラスカル法で最大全域木のコストを計算\n  double kr = kruskal();\n  // 出力\n  printf(\"%.4f\\n\", total_cost - kr);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<iomanip>\n\nusing namespace std;\n\ntypedef pair<double,int> PDI;\nint N,M;\n\nint pos[10000][2];\nvector<int> edge[10000];\nint visited[10000];\n\ndouble solve(int s){\n\n    visited[s]=1;\n\n    int cnt=1;\n\n    priority_queue<PDI> pq;\n    for(unsigned int i=0;i<edge[s].size();++i){\n\n        int x0 = pos[s][0];\n        int y0 = pos[s][1];\n        int x1 = pos[edge[s][i]][0];\n        int y1 = pos[edge[s][i]][1];\n\n        double cost = sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));\n\n        pq.push(make_pair(cost,edge[s][i]));\n\n    }\n\n    double sum=0;\n\n    while(!pq.empty()){\n\n        PDI p = pq.top(); pq.pop();\n\n        double cost = p.first;\n        int    node = p.second;\n\n        if(visited[node])continue;\n        visited[node]=1;\n        sum += cost;\n        ++cnt;\n\n        for(unsigned int i=0;i<edge[node].size();++i){\n\n            int next = edge[node][i];\n\n            if(visited[next])continue;\n\n            int x0 = pos[node][0];\n            int y0 = pos[node][1];\n            int x1 = pos[next][0];\n            int y1 = pos[next][1];\n\n            double cost = sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));\n\n            pq.push(make_pair(cost,next));\n        }\n\n    }\n\n    return sum;\n\n}\n\nint main(){\n\n    cin.sync_with_stdio(false);\n\n    cin >> N >> M;\n\n    for(int i=0;i<N;++i) cin >> pos[i][0] >> pos[i][1];\n\n    double sum=0;\n\n    for(int i=0;i<M;++i){\n\n        int a,b;\n\n        cin >> a >> b;\n\n        edge[a-1].push_back(b-1);\n        edge[b-1].push_back(a-1);\n\n        int x0 = pos[a-1][0];\n        int y0 = pos[a-1][1];\n        int x1 = pos[b-1][0];\n        int y1 = pos[b-1][1];\n\n        sum += sqrt((x0-x1)*(x0-x1) + (y0-y1)*(y0-y1));\n\n    }\n\n    for(int i=0;i<N;++i){\n\n        if(visited[i]==0)\n            sum -= solve(i);\n\n    }\n\n    cout << setprecision(3) << fixed << sum << endl;\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n\nusing namespace std;\n\nconst int INF = (1<<25);\nconst int MAX = 10001;\nint N,M;\ndouble ans;\n\nstruct Pile{\n  int x,y;\n  Pile(){}\n  Pile(int x,int y):x(x),y(y){}\n};\n\nstruct State{\n  int pos;\n  double t;\n  State(){}\n  State(int pos, double t):pos(pos),t(t){}\n  bool operator < (const State& s) const { return t < s.t;}\n};\n\nvector<int> Edge[MAX];\nvector<Pile> P;\ndouble T[MAX];\nbool used[MAX];\n\nvoid init(){\n  fill(T,T+MAX,-1);\n  fill(used,used+MAX,false);\n  for(int i = 0; i < MAX; i++) Edge[i].clear();\n  P.clear();\n  ans = 0;\n}\n\ndouble getDis(int p, int q){\n  return sqrt((P[p].x-P[q].x)*(P[p].x-P[q].x)+(P[p].y-P[q].y)*(P[p].y-P[q].y));\n}\n\nvoid input(){\n  for(int i = 0; i < N; i++){\n    Pile in;\n    cin >> in.x >> in.y;\n    P.push_back(in);\n  }\n\n  for(int i = 0; i < M; i++){\n    int p,q;\n    cin >> p >> q;\n    p--;\n    q--;\n    Edge[p].push_back(q);\n    Edge[q].push_back(p);\n    ans += getDis(p,q);\n  }\n}\n\n\nvoid prim(int start){\n  priority_queue<State> Q;\n  Q.push(State(start,0));\n  T[start] = 0;\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n     \n    if(used[now.pos]) continue;\n    used[now.pos] = true;\n\n    ans -= now.t;\n\n\n    for(int i = 0; i < (int)Edge[now.pos].size(); i++){\n      int nex = Edge[now.pos][i];\n      if(T[nex] < getDis(now.pos,nex)){\n\tT[nex] = getDis(now.pos,nex);\n\tQ.push(State(nex,getDis(now.pos,nex)));\n      }\n    }\n  }\n}\n\nvoid solve(){\n\n  for(int i = 0; i < N; i++){\n    if(!used[i]) prim(i);\n  }\n\n\n  printf(\"%.3f\\n\",ans);\n}\n\nint main(){\n  \n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\ntemplate <typename T> struct Edge {\n    int f, t;\n    T c;\n    Edge() {}\n    Edge(int f, int t, T c) : f(f), t(t), c(c) {}\n};\n\nstruct UF {\n\tint n, c;\n\tvector<int> p;\n\n\tUF(int n): n(n), c(n), p(n, -1) {}\n\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return false;\n\t\tif (p[x] > p[y]) swap(x, y);\n\t\tp[x] += p[y];\n\t\tp[y] = x;\n\t\tc--;\n\t\treturn true;\n\t}\n\tint find(int x) { return (p[x] < 0 ? x : p[x] = find(p[x])); }\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -p[find(x)]; }\n\tint count() { return c; }\n};\n\n// the cost of MST\ntemplate <typename T> T kruskal(vector<Edge<T>>& es, int n) {\n    sort(es.begin(), es.end(), [](const Edge<T>& a, const Edge<T>& b) {\n        return (a.c < b.c);\n    });\n    UF uf(n);\n    T res = 0;\n    for (auto& e : es) {\n        if (uf.unite(e.f, e.t)) res += e.c;\n    }\n    return res;\n}\n\nint N, M;\nint x[10010], y[10010];\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout << fixed << setprecision(10);\n\n    cin >> N >> M;\n    REP (i, N) cin >> x[i] >> y[i];\n    vector<Edge<double>> es;\n    double sum = 0;\n    REP (i, M) {\n        int p, q;\n        cin >> p >> q;\n        p--; q--;\n        double dis = hypot(x[p] - x[q], y[p] - y[q]);\n        es.emplace_back(p, q, -dis);\n        sum += dis;\n    }\n    sum += kruskal<double>(es, N);\n    cout << sum << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = maxn*maxn/2+1;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<cmath>\n#define MAX 10000\n#define MP make_pair\n#define INF (1<<21)\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\nint parent[MAX];\n\nint findRoot(int x)\n{\n\tif (parent[x] != x)\n\t{\n\t\tparent[x] = findRoot(parent[x]);\n\t}\n\telse\n\t{\n\t\treturn x;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn findRoot(x) == findRoot(y);\n}\n\nvoid unite(int x, int y)\n{\n\tint root1 = findRoot(x);\n\tint root2 = findRoot(y);\n\tparent[root1] = root2;\n}\n\ntypedef double Weight;\ntypedef pair<int, int> Pair;\ntypedef pair<Weight, Pair> Edge;\n\npriority_queue<Edge> q;\n\ndouble kruskal()\n{\n\tREP(i, MAX)\n\t{\n\t\tparent[i] = i;\n\t}\n\tdouble total = 0.0;\n\tdouble total_ans = 0.0;\n\twhile (!q.empty())\n\t{\n\t\tEdge top = q.top();\n\t\tint X = top.second.first;\n\t\tint Y = top.second.second;\n\t\tif (same(X, Y) == false)\n\t\t{\n\t\t\tunite(X, Y);\n\t\t\ttotal += top.first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotal_ans += top.first;\n\t\t}\n\t\tq.pop();\n\t}\n\treturn total_ans;\n}\n\npair<int,int> Z[MAX];\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tREP(i, N)\n\t{\n\t\tint px, py;\n\t\tcin >> px >> py;\n\t\tZ[i] = MP(px, py);\n\t}\n\tREP(i, M)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tdouble tmp_x = Z[x-1].first - Z[y-1].first;\n\t\tdouble tmp_y = Z[x-1].second - Z[y-1].second;\n\t\tdouble w = sqrt(tmp_x*tmp_x + tmp_y*tmp_y);\n\t\tq.push(MP(w, MP(x, y)));\n\t}\n\n\tcout << fixed << setprecision(8) << kruskal() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\n\n/*\n    AOJ 2224 Save your cats\n*/\n\n/*\n3 3\n0 0\n3 0\n0 4\n1 2\n2 3\n3 1\n\n3.000\n\n\n4 3\n0 0\n-100 0\n100 0\n0 100\n1 2\n1 3\n1 4\n\n0.000\n\n\n6 7\n2 0\n6 0\n8 2\n6 3\n0 5\n1 7\n1 2\n2 3\n3 4\n4 1\n5 1\n5 4\n5 6\n\n7.236\n\n\n\n6 6\n0 0\n0 1\n1 0\n30 0\n0 40\n30 40\n1 2\n2 3\n3 1\n4 5\n5 6\n6 4\n\n\n31.000\n*/\n\nstruct edge {\n    int from;\n    int to;\n    double cost;\n\n    edge(int from = 0, int to = 0, double cost = 0): from(from), to(to), cost(cost) {}\n\n    bool operator < (const edge &b) const {\n        return cost < b.cost;\n    }\n};\n\nconst int MAX_N = 1e4 + 10;\n\nint N = 0;\nint M = 0;\nint X[MAX_N];\nint Y[MAX_N];\n\n// 实现并查集\nint par[MAX_N + 1];\nint rnk[MAX_N + 1];\n\nvoid init(int n) {\n    for (int i = 0; i <= n; i++) {\n        par[i] = i;\n        rnk[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    }\n\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n\n    if (x == y) {\n        return;\n    }\n\n    if (rnk[x] < rnk[y]) {\n        par[x] = y;\n    }\n    else {\n        par[y] = x;\n        if (rnk[x] == rnk[y]) {\n            rnk[x]++;\n        }\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvector<edge> es;\n\ndouble kruskal() {\n    sort(es.begin(), es.end());\n    double res = 0;\n    for (int i = 0; i < es.size(); i++) {\n        edge e = es[i];\n        if (!same(e.from, e.to)) {\n            res += e.cost;\n            unite(e.from, e.to);\n        }\n    }\n\n    return res;\n}\n\nvoid solve() {\n    // 本质是最大生成树问题\n    init(N);\n    double res = kruskal();\n\n    for (int i = 0; i < es.size(); i++) {\n        res -= es[i].cost;\n    }\n\n    printf(\"%.3f\\n\", res);\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d\", &X[i], &Y[i]);\n    }\n    int from = 0;\n    int to = 0;\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &from, &to);\n        int x = X[from] - X[to];\n        int y = Y[from] - Y[to];\n        double cost = sqrt(x * x + y * y);\n\n        es.push_back(edge(from, to, -cost));\n    }\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct union_find {\n  vector<int> rank_, size_, rid_;\n  union_find(int n) { rank_.resize(n); rid_.assign(n, -1); size_.resize(n, 1); }\n  void operator()(int u, int v) {\n    u = operator[](u), v = operator[](v);\n    if(u == v) { return; }\n    size_[u] = size_[v] = size_[u] + size_[v];\n    if(rank_[u] < rank_[v]) { rid_[u] = v; }\n    else { rid_[v] = u; if(rank_[u] == rank_[v]) { rank_[u]++; } }    \n  }\n  int operator[](int x) { if(rid_[x] < 0) return x; else return rid_[x] = operator[](rid_[x]); }\n  int size_of(int x) { return size_[x]; }\n};\n\nusing edge = tuple<int, int, double>;\nvector<edge> edges;\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<complex<double>> pts;\n  rep(i, N) {\n    double x, y; cin >> x >> y;\n    pts.emplace_back(x, y);\n  }\n  rep(i, M) {\n    int x, y; cin >> x >> y; x--, y--;\n    edges.emplace_back(x, y, abs(pts[x] - pts[y]));\n  }\n\n  union_find uf(N);\n\n  sort(all(edges), [&](const edge& a, const edge& b){ return get<2>(a) > get<2>(b); });\n\n  double cost = 0.0;\n\n  rep(i, M) {\n    int x, y; double c; tie(x, y, c) = edges[i];\n    if(uf[x] == uf[y])\n      cost += c;\n    else \n      uf(x, y);\n  }\n\n  printf(\"%.10f\\n\", cost);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#define MAXN 50100\nusing namespace std;\nint x[MAXN],y[MAXN];\nstruct edge{\n\tint from,to;double quan;\n}e[MAXN*2];\nint n,m;int fa[MAXN];\n\nint find(int x){\n\tif(fa[x]!=x) fa[x]=find(fa[x]);\n\treturn fa[x];\n}\n\ndouble getdis(int f,int s){\n\treturn sqrt((x[f]-x[s])*(x[f]-x[s])+(y[f]-y[s])*(y[f]-y[s]));\n}\n\nbool cmp(edge x,edge y){\n\treturn x.quan>y.quan;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++) cin>>x[i]>>y[i];//scanf(\"%f%f\",&x[i],&y[i]);\n\tdouble ans=0;\n\tfor(int i=1;i<=n;i++) fa[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tint xx,yy;scanf(\"%d%d\",&xx,&yy);\n\t\tdouble dis=getdis(xx,yy);\n\t\te[i].from=xx,e[i].to=yy,e[i].quan=dis;\n\t\tans+=dis;\n\t}\n\tsort(e+1,e+m+1,cmp);\n\tfor(int i=1;i<=m;i++){\n\t\tint xx=find(e[i].from),yy=find(e[i].to);\n\t\tif(fa[xx]!=fa[yy]){\n\t\t\tfa[xx]=yy;\n\t\t\tans-=e[i].quan;\n\t\t}\n\t}\n\tprintf(\"%0.3f\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = 1e8;\nint pa[maxn],rank[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(rank[x] < rank[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\t++rank[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nusing namespace std;\nstruct node{\n    int x,y;\n}no[10005];\nstruct edge{\n    int from,to;\n    double dis;\n}ed[200000];\nbool cmp(const edge &a,const edge &b){\n    return a.dis>b.dis;\n}\nint father[10005];\nint find(int who){\n    if(who==father[who]) return who;\n    else return father[who]=find(father[who]);\n}\nint main(void){\n    int n,m;\n    cin>>n>>m;\n    for(int i=1;i<=n;i++){\n        cin>>no[i].x>>no[i].y;\n        father[i]=i;\n    }\n    double ans=0;\n    for(int i=1;i<=m;i++){\n        int a,b;\n        cin>>a>>b;\n        ed[i].from=a;\n        ed[i].to=b;\n        ed[i].dis= pow(pow(no[a].x-no[b].x,2)+pow(no[a].y-no[b].y,2),0.5);\n        ans+=ed[i].dis;\n    }\n    sort(ed+1,ed+1+m,cmp);\n    int flag=0;\n    for(int i=1;i<=m;i++){\n        if(find(ed[i].from)!=find(ed[i].to)){\n            father[ed[i].to]=find(ed[i].from);\n            ans-=ed[i].dis;\n            flag+=1;\n        }\n        if(flag==n-1) break;\n    }\n    printf(\"%.3lf\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <functional>\n\nusing namespace std;\n\nint par[10016], rank[10016];\n\nvoid init(int x)\n{\n\tint i;\n\tfor (i = 0; i < x; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x)\n\t\treturn x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unit(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t\treturn;\n\tif (rank[x] < rank[y])\n\t\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nint same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\ntypedef struct\n{\n\tint u, v;\n\tdouble d;\n}EDG;\ntypedef struct\n{\n\tint x, y;\n}P;\n\nP p[10016];\nEDG e, G[200320];\nint n, m;\ndouble res = 0;\n\ninline int doub(int x)\n{\n\treturn x * x;\n}\n\nint mycmp(EDG e1, EDG e2)\n{\n\treturn e1.d > e2.d;\n}\n\nvoid krus()\n{\n\tint i;\n\tsort(G, G + m, mycmp);\n\tinit(n);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\te = G[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunit(e.u, e.v);\n\t\t\tres += e.d;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint i, j, x, y;\n\tdouble sum = 0;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (i = 1; i <= n; i++)\n\t\tscanf(\"%d%d\", &p[i].x, &p[i].y);\n\tfor (i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d%d\", &x, &y);\n\t\te.d = sqrt(1.0 * doub(p[x].x - p[y].x) + doub(p[x].y - p[y].y));\n\t\tsum += e.d;\n\t\te.u = x; e.v = y;\n\t\tG[i] = e;\n\t}\n\tkrus();\n\tprintf(\"%.3lf\\n\", sum - res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn=10005;\n\nstruct point\n{\n    double x,y;\n    void input()\n    {\n        scanf(\"%lf%lf\",&x,&y);\n    }\n}f[maxn];\n\nstruct node\n{\n    int u,v;\n    double len;\n}s[maxn*3];\n\nint set[maxn];\nint n,m;\n\ninline double dis(const point &a,const point &b)\n{\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool operator <(const node &a,const node &b)\n{\n    return a.len>b.len;\n}\n\ninline int find(const int &x)\n{\n    if(x==set[x])return x;\n    else return set[x]=find(set[x]);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        f[i].input();\n        set[i]=i;\n    }\n    for(int i=0;i<m;i++)\n    {\n        scanf(\"%d%d\",&s[i].u,&s[i].v);\n        s[i].len=dis(f[s[i].u],f[s[i].v]);\n    }\n    sort(s,s+m);\n    double ans=0;\n    for(int i=0;i<m;i++)\n        if(find(s[i].u)!=find(s[i].v))set[find(s[i].u)]=find(s[i].v);\n        else ans+=s[i].len;\n    printf(\"%.3f\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct edge\n{\n\tint s, t;\n\tdouble w;\n\tedge(int s, int t, double w) :s(s), w(w), t(t) {}\n\tedge() { s = -1, w = -1, t = -1; }\n\tbool operator<(const edge& e)const\n\t{\n\t\treturn w < e.w;\n\t}\n};\n\nstruct UnionFind\n{\n\tvector<int> parent;\n\tvector<int> rank;\n\n\tUnionFind(int N) :parent(N, 0), rank(N, 0)\n\t{\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\n\tint find(int x)\n\t{\n\t\tif (parent[x] == x)\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\n\t\tif (x == y)\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif (rank[x] < rank[y])\n\t\t{\n\t\t\tparent[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\nedge edges[100010];\npdd piles[10000];\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M,a,b;\n\tdouble x, y;\n\tcin >> N >> M;\n\trep(i, 0, N)\n\t{\n\t\tcin >> x >> y ;\n\t\tpiles[i] = mp(x, y);\n\t}\n\n\tdouble ans = 0.0;\n\trep(i, 0, M)\n\t{\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tedges[i] = edge(a, b, -sqrt((piles[a].first - piles[b].first)*(piles[a].first - piles[b].first) + (piles[a].second - piles[b].second)*(piles[a].second - piles[b].second)));\n\t\tans += (-edges[i].w);\n\t}\n\n\tsort(edges, edges + M);\n\tUnionFind uf(N);\n\n\trep(i, 0, M)\n\t{\n\t\tif (!uf.same(edges[i].s, edges[i].t))\n\t\t{\n\t\t\tans += edges[i].w;\n\t\t\tuf.unite(edges[i].s, edges[i].t);\n\t\t}\n\t}\n\n\tprintf(\"%.3lf\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\nstruct ed\n{\n\tint be;\n\tint to;\n\tdouble dist;\n}G[100005];\n\ndouble px[100005];\ndouble py[100005];\nint father[100005];\n\nstruct cmp\n{\n\tbool operator()(const ed &a, const ed &b)\n\t{\n\t\treturn a.dist > b.dist;\n\t}\n};\n\ninline double mdist(int a, int b)\n{\n\treturn sqrt(pow(px[a] - px[b], 2) + pow(py[a] - py[b], 2));\n}\n\nint find(int x)\n{\n\tif(father[x] != x)\n\t\treturn find(father[x]);\n\treturn father[x];\n}\n\nint main()\n{\n\t//用总数减最大 \n\tdouble sum = 0.0;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%lf%lf\", &px[i], &py[i]);\n\t\tfather[i] = i;\n\t}\t\n\t\t\n\tint tx, ty;\n\t//ed tmp;\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tscanf(\"%d%d\", &tx, &ty);\n\t\tG[i].be = tx;\n\t\tG[i].to = ty;\n\t\tG[i].dist = mdist(tx, ty);\n\t\tsum += G[i].dist;\n\t}\n\t\n\tdouble f = 0.0;\n\tsort(G + 1, G + m + 1, cmp());\n\tfor(int i = 1; i <= m; ++i)\n\t{\n\t\tint x = find(G[i].be);\n\t\tint y = find(G[i].to);\n\t\tif(x != y)\n\t\t{\n\t\t\tfather[x] = y;\n\t\t\t//printf(\"%.3lf\\n\", G[i].dist);\n\t\t\t//break;\n\t\t\tf += G[i].dist;\n\t\t}\n\t}\n\tprintf(\"%.3lf\\n\", sum-f);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N; j++)\n\tif(forest[t1][j] == 0)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = maxn*maxn/2 + 10;\ntypedef pair<int,int> Point;\nstruct edge{\n\tint u,v;\n\tdouble dis;\t\n\tbool operator<(const edge &e)const\n\t{\n\t\treturn \tdis > e.dis;\n\t}\n\t\n};\nPoint p[maxn];\nedge e[maxe];\nint s[maxn];\nint N,M;\n\ndouble getdis(Point a, Point b)\n{\n\tdouble x = a.first - b.first;\n\tdouble y = a.second - b.second;\n\tdouble dis = sqrt(x*x + y*y);\n\treturn\tdis;\n}\n\n\nint find(int x)\n{\n\tif(s[x] < 0)\n\t\treturn x;\n\treturn s[x] = find(s[x]);\n}\n\nbool same(int x, int y)\n{\n\tint a= find(x);\n\tint b= find(y);\n\t\n\treturn a==b;\n}\n\n\nvoid unite(int x, int y)\n{\n\tint a= find(x);\n\tint b= find(y);\n\tif(a==b)\n\t\treturn;\n\t\n\tif(s[b] < s[a])\n\t{\n\t\ts[a] = b;\n\t\treturn;\n\t}\t\t\n\tif(s[b] == s[a])\n\t\ts[a]--;\n\t\t\n\ts[b] = a;\t\n\t\n}\ndouble kruskal(double tot)\n{\n\tmemset(s,-1,sizeof(s));\n\t\n\tsort(e,e+M);\n\t\n\tdouble res = 0;\n\tfor(int i =0 ; i< M; i++)\n\t{\n\t\tif(!same(e[i].u,e[i].v))\n\t\t{\n\t\t\tunite(e[i].u,e[i].v);\n\t\t\tres += e[i].dis;\n\t\t}\n\t}\n\t\n\treturn tot-res;\n\t \n}\n\nint main()\n{\n\t//freopen(\"c:\\\\users\\\\administrator\\\\desktop\\\\in.txt\",\"r\",stdin);\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i++)\n\t{\n\t\tint x,y;\n\t\tcin >> x  >> y;\n\t\t\n\t\tp[i].first  =x; p[i].second= y;\t\t\t\t\n\t\n\t}\t\n\tdouble tot = 0;\n  \tfor(int i = 0; i < M; i++)\n\t{\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tu--;v--;\n\t\te[i].u = u;\n\t\te[i].v= v;\n\t\te[i].dis = getdis(p[u],p[v]);\n\t\ttot+= e[i].dis;\n\t}\n\t\n\t\n\tdouble res = kruskal(tot);\n\tprintf(\"%0.3f\\n\",res);\n\t\n\t\n} "
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define N 10000+10\nint per[N];\nstruct Point\n{\n\tdouble x,y;\n}p[N];\nstruct Edge\n{\n\tint s,e;\n\tdouble w;\n}a[N*N];\ndouble ma(Point a,Point b)\n{\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nbool cmp(Edge a,Edge b)\n{\n\treturn a.w>b.w;\n}\nint Find(int x)\n{\n\twhile(x!=per[x])\n\t\tx=per[x];\n\treturn x;\n}\nint Judge(int x,int y)\n{\n\tint fx=Find(x);\n\tint fy=Find(y);\n\tif(fx!=fy)\n\t{\n\t\tper[fx]=fy;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint main()\n{\n\tint i,n,m,x,y;\n\twhile(~scanf(\"%d%d\",&n,&m))\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tper[i]=i;\n\t\t\tscanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\ta[i].s=x;a[i].e=y;\n\t\t\ta[i].w=ma(p[x],p[y]);\n\t\t\tsum+=a[i].w;\n\t\t}\n\t\tsort(a,a+m,cmp);\n\t\tdouble tmp=0;\n\t\tfor(i=0;i<m;i++)\n\t\t{\n\t\t\tif(Judge(a[i].s,a[i].e))\n\t\t\t\ttmp+=a[i].w;\n\t\t}\n\t\tprintf(\"%.3lf\\n\",sum-tmp);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint const MAX_N  = 10000;\nint N, M;\nP piles[MAX_N];\n\ndouble distance(int x0, int y0, int x1, int y1) {\n    return hypot(x1-x0, y1-y0);\n}\n\n// O(E*log(V))\nstruct Edge {\n    Edge(int a, int b, double c) {\n        u = a; v = b; cost = c;\n    }\n    int u, v;\n    double cost;\n};\n\nbool comp(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nstruct UF{\n    vector<int> par;\n    UF(int m) : par(m){\n        for(int i = 0; i < m; i++){\n            par[i] = i;\n        }\n    }\n    int find(int x){\n        return x != par[x] ? par[x] = find(par[x]) : x;\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    void unite(int x, int y){\n        // y is above\n        if(!same(x, y)) par[find(x)] = find(y);\n    }\n};\n\ndouble kruskal(int V, vector<Edge>& es) {\n    sort(es.begin(), es.end(), comp);\n    UF uf(V);\n    double res = 0;\n    for(int i = es.size()-1; i >= 0; i--) {\n        Edge e = es[i];\n        if(!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);\n        } else {\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvector<Edge> es;\n\nint main() {\n    cin >> N >> M;\n    int x, y;\n    for(int i = 0; i < N; i++) {\n        cin >> x >> y;\n        piles[i] = P(x, y);\n    }\n    int j, k;\n    double s = 0;\n    for(int i = 0; i < M; i++) {\n        cin >> j >> k;\n        j--; k--;\n        P p1 = piles[j], p2 = piles[k];\n        double d = distance(p1.first, p1.second, p2.first, p2.second);\n        s += d;\n        es.push_back(Edge(j, k, d));\n    }\n    printf(\"%.5f\\n\", kruskal(N, es));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef pair<double, int> pdi;\nconst int M = 1000000007;\n\ndouble prim_cost(vector<vector<pdi>> edge) {\n    int n = edge.size();\n    vector<int> vis(n, 0);\n    double c = 0;\n    priority_queue<pdi> q;\n    q.push(pdi(0, 0));\n    while (!q.empty()) {\n        pdi p = q.top();\n        q.pop();\n        if (vis[p.second]) continue;\n        vis[p.second] = 1;\n        c += p.first;\n        for (auto& e : edge[p.second]) {\n            if (!vis[e.second]) {\n                q.push(pdi(e.first, e.second));\n            }\n        }\n    }\n    return c;\n}\n\ndouble norm(int x, int y) {\n    return sqrt(x * x + y * y);\n}\n\ndouble dist(pii& p, pii& q) {\n    return norm(p.first - q.first, p.second - q.second);\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<pii> coord(n);\n    vector<vector<pdi>> edge(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> coord[i].first >> coord[i].second;\n        edge[i].push_back(pdi(0, (i + 1) % n));\n    }\n    double sum = 0;\n    for (int i = 0; i < m; ++i) {\n        int p, q;\n        cin >> p >> q;\n        --p;\n        --q;\n        double d = dist(coord[p], coord[q]);\n        edge[p].push_back(pdi(d, q));\n        edge[q].push_back(pdi(d, p));\n        sum += d;\n    }\n    printf(\"%.9lf\\n\", sum - prim_cost(edge));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<cmath>\n#define MAX 10000\n#define MP make_pair\n#define INF (1<<21)\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\nint parent[MAX];\n\nint findRoot(int x)\n{\n\tif (parent[x] != x)\n\t{\n\t\tparent[x] = findRoot(parent[x]);\n\t}\n\telse\n\t{\n\t\treturn x;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn findRoot(x) == findRoot(y);\n}\n\nvoid unite(int x, int y)\n{\n\tint root1 = findRoot(x);\n\tint root2 = findRoot(y);\n\tparent[root1] = root2;\n}\n\ntypedef double Weight;\ntypedef pair<int, int> Pair;\ntypedef pair<Weight, Pair> Edge;\n\npriority_queue<Edge> q;\n\ndouble kruskal()\n{\n\tREP(i, MAX)\n\t{\n\t\tparent[i] = i;\n\t}\n\tdouble total = 0.0;\n\tdouble total_ans = 0.0;\n\twhile (!q.empty())\n\t{\n\t\tEdge top = q.top();\n\t\tint X = top.second.first;\n\t\tint Y = top.second.second;\n\t\tif (same(X, Y) == false)\n\t\t{\n\t\t\tunite(X, Y);\n\t\t\ttotal += top.first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\ttotal_ans += top.first;\n\t\t}\n\t\tq.pop();\n\t}\n\treturn total_ans;\n}\n\npair<int,int> Z[MAX];\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tREP(i, N)\n\t{\n\t\tint px, py;\n\t\tcin >> px >> py;\n\t\tZ[i] = MP(px, py);\n\t}\n\tREP(i, M)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tdouble tmp_x = Z[x-1].first - Z[y-1].first;\n\t\tdouble tmp_y = Z[x-1].second - Z[y-1].second;\n\t\tdouble w = sqrt(tmp_x*tmp_x + tmp_y*tmp_y);\n\t\tq.push(MP(w, MP(x, y)));\n\t}\n\n\t//cout << fixed << setprecision(10) << kruskal() << endl;\n\t\n\tprintf(\"%lf\\n\",kruskal());\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nstruct UnionFind {\n    vector<int> par;\n    int n, cnt;\n    UnionFind(const int& x = 0) {init(x);}\n    void init(const int& x) {par.assign(cnt=n=x, -1);}\n    inline int find(const int& x) {return par[x] < 0 ? x : par[x] = find(par[x]);}\n    inline bool same(const int& x, const int& y) {return find(x) == find(y);}\n    inline bool unite(int x, int y) {\n        if ((x = find(x)) == (y = find(y))) return false;\n        --cnt;\n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    inline int count() const {return cnt;}\n    inline int count(int x) {return -par[find(x)];}\n};\n\nstruct Edge {\n    int u;\n    int v;\n    double cost;\n    Edge() {}\n    Edge(int u, int v, double cost) : u(u), v(v), cost(cost) {}\n    bool operator<(const Edge& rhs) const {return cost < rhs.cost;}\n};\n\nint square(int x) {return x*x;}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> X(N), Y(N);\n    for (int i = 0; i < N; i++)\n        cin >> X[i] >> Y[i];\n    vector<Edge> es;\n    double sum = 0;\n    for (int i = 0; i < M; i++) {\n        int p, q;\n        cin >> p >> q;\n        p--; q--;\n        es.emplace_back(p, q, sqrt(square(X[p]-X[q])+square(Y[p]-Y[q])));\n        sum += es.back().cost;\n    }\n    sort(es.rbegin(), es.rend());\n    double minus = 0;\n    UnionFind uf(N);\n    for (int i = 0; i < M; i++) {\n        Edge e = es[i];\n        if (uf.same(e.u, e.v)) continue;\n        uf.unite(e.u, e.v);\n        minus += e.cost;\n    }\n    printf(\"%.10lf\\n\", sum-minus);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      k = 0;\n      while(forest[j][k] != 0 && k < N) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      j = 0;\n      while(forest[t1][j] != 0)\n\tj++;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define INF 1e9\nusing namespace std;\ntypedef pair <double,int> P;\nvector <P> G[10001];\n \nint used[10001];\ndouble prim(int start){\n  double res=0;\n  priority_queue <P> Q;\n  Q.push(P(0,start));\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    double cost=t.f;\n    int pos=t.s;\n    if(used[pos])continue;\n    used[pos]=1;\n    res+=cost;\n    for(int i=0;i<G[pos].size();i++)Q.push(P(G[pos][i]));\n    }\n  return res;\n}\n \nint main(){\n  int n,m;\n  cin>>n>>m;\n  complex <double>  p[10001];\n  for(int i=0,a,b;i<n;i++)cin>>a>>b,p[i].real()=a,p[i].imag()=b;\n \n  double sum=0;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    G[a].push_back(P(abs(p[a]-p[b]),b));\n    G[b].push_back(P(abs(p[a]-p[b]),a));\n    sum+=abs(p[a]-p[b]);\n  }\n \n  double ans=0;\n  for(int i=0;i<n;i++) if(!used[i]) ans+=prim(i);\n  printf(\"%f\\n\",sum-ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXV = 10001;\nconst int MAXE =  MAXV * (MAXV);\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair<int, int> P; // 坐标点\nP p[MAXV];\n//int cost[MAXV][MAXV];\n//int mincost[MAXV];\n//bool visited[MAXV];\nint N, M;\nint V, E;\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tEdge(int _from=0, int _to=0, double _cost = 0.0) :from(_from), to(_to), cost(_cost){}\n};\nEdge edge[MAXE];\nint father[MAXV];\nbool cmp(const Edge& a, const Edge& b) {\n\treturn a.cost > b.cost;\n}\nvoid Init(int n) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfather[i] = i;\n\t}\n}\nint Find(int x) {\n\tif (father[x] == x)\n\t\treturn x;\n\telse\n\t\treturn father[x] = Find(father[x]);\n}\nvoid Unite(int x, int y) {\n\tx = Find(x);\n\ty = Find(y);\n\tif (x == y)\n\t\treturn;\n\telse\n\t\tfather[y] = x;\n}\nbool same(int x, int y) {\n\treturn Find(x) == Find(y);\n}\ndouble Kruskal() {\n\tInit(MAXV);\n\tsort(edge, edge + E, cmp);\n\tdouble res = 0;\n\tint cnt = 0;\n\tfor (int i = 0; i < E; ++i) {\n\t\tEdge e = edge[i];\n\t\tif (!same(e.from, e.to)) {\n\t\t\tUnite(e.from, e.to);\n\t\t\tcnt++;\n\t\t}\n\t\telse {\n\t\t\tres += e.cost;\n\t\t}\n\t\t//if (cnt == V - 1)\n\t\t//\tbreak;\n\t}\n\t//if (cnt < V - 1)\n\t//\treturn -1;\n\t//else\n\t\treturn res;\n}\n//struct Edge {\n//\tint to, cost;\n//\tEdge(int _to = 0, int _cost = 0) :to(_to), cost(_cost){}\n//};\n//vector<Edge> edge[MAXE];\n//int Prim() {\n//\tfill(mincost, mincost + MAXV, 0);\n//\tfill(visited, visited + MAXV, false);\n//\tmincost[0] = 0;\n//\tint res = 0;\n//\tint cnt = 0;\n//\tpriority_queue<P> que;\n//\tque.push(P(0, 0));\n//\twhile (!que.empty()) {\n//\t\tP p = que.top(); que.pop();\n//\t\tint v = p.second;\n//\t\tif (visited[v] || mincost[v] > p.first)\n//\t\t\tcontinue;\n//\t\tres += mincost[v];\n//\t\tvisited[v] = true;\n//\t\tcnt++;\n//\t\tfor (int i = 0; i < edge[v].size(); ++i) {\n//\t\t\tEdge e = edge[v][i];\n//\t\t\tif (mincost[e.to] < e.cost) {\n//\t\t\t\tmincost[e.to] = e.cost;\n//\t\t\t\tque.push(P(mincost[e.to], e.to));\n//\t\t\t}\n//\t\t}\n//\t}\n//\tif (cnt < V)\n//\t\treturn -1;\n//\telse if (cnt)\n//\t\treturn res;\n//}\nvoid solve() {\n\tdouble res = Kruskal();\n\tprintf(\"%.3f\\n\", res);\n}\nint main(int argc, char const *argv[])\n{\n\t//std::ios::sync_with_stdio(false);\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &N, &M) != EOF) {\n\t\tV = N; E = 0;\n\t\tmemset(edge, 0, sizeof(edge));\n\t\tint x, y;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tscanf(\"%d%d\", &x, &y);\n\t\t\tp[i].first = x;\n\t\t\tp[i].second = y;\n\t\t}\n\t\tint from, to, cost;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tscanf(\"%d%d\", &from, &to);\n\t\t\t--from; --to;\n\t\t\tint dx = abs(p[from].first - p[to].first);\n\t\t\tint dy = abs(p[from].second - p[to].second);\n\t\t\tdouble dist = sqrt(dx * dx + dy * dy);\n\t\t\tedge[E++] = Edge(from, to, dist);\n\t\t}\n\t\tsolve();\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+7;\ntypedef long long LL;\nstruct Eg{\n    int u,v;\n    LL c;\n}E[maxn*100];\n\nint par[maxn];\nint rk[maxn];\nvoid init(int n){\n    int len=min(n,maxn);\n    for(int i=0;i<len;i++){\n        par[i]=i;\n        rk[i]=0;\n    }\n}\nint fd(int x){\n    if(x==par[x]) return x;\n    return par[x]=fd(par[x]);\n}\n\nvoid mg(int x,int y){\n    x=fd(x);\n    y=fd(y);\n    if(x==y) return ;\n    if(rk[x]<rk[y]){\n        par[x]=y;\n    }else {\n        par[y]=x;\n        if(rk[x]==rk[y]) rk[x]++;\n    }\n}\nbool same(int x,int y){\n    return fd(x)==fd(y);\n}\nbool cmp(Eg e1,Eg e2){\n    return e1.c>e2.c;\n}\nint X[maxn];\nint Y[maxn];\n\nint N,M;\nbool vis[maxn*100];\nint main(){\n\n    scanf(\"%d%d\",&N,&M);\n    for(int i=1;i<=N;i++){\n        scanf(\"%d%d\",X+i,Y+i);\n    }\n\n    int u,v;\n    for(int i=1;i<=M;i++){\n        scanf(\"%d%d\",&u,&v);\n        LL dis=((LL)X[u]-X[v])*(X[u]-X[v])+((LL)Y[u]-Y[v])*(Y[u]-Y[v]);\n        E[i].u=u;\n        E[i].v=v;\n        E[i].c=dis;\n    }\n    init(N+3);\n    sort(E+1,E+M+1,cmp);\n    int res=0;\n    for(int i=1;i<=M;i++){\n        Eg e=E[i];\n        if(!same(e.u,e.v)){\n            mg(e.u,e.v);\n            vis[i]=1;\n        }\n    }\n    double ans=0;\n    for(int i=1;i<=M;i++){\n        if(!vis[i]){\n            ans+=(sqrt(1.0*E[i].c));\n        }\n    }\n    printf(\"%.4f\\n\",ans);\nreturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n//typedef complex<double> Point;\n//typedef complex<double> Vector;\ntypedef long long LL;\n\nint n,m;\nint pa[20000];\n\nvoid init()\n{\n    for(int i=0;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x]!= x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return w > t.w;\n    }\n}e[20000];\n\nstruct point\n{\n    int x,y;\n}p[20000];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(p,0,sizeof(p));\n        memset(e,0,sizeof(e));\n        init();\n        double sum = 0;\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty, e[i].w = sqrt(1.0*(p[tx].x - p[ty].x)*(p[tx].x - p[ty].x) + 1.0*(p[tx].y - p[ty].y)*(p[tx].y - p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n    > File Name: aoj2224.cpp\n    > Author:    WArobot \n    > Blog:      http://www.cnblogs.com/WArobot/ \n    > Created Time: 2017??´06???19??\\ ????????? 19??¶52???17?§?\n ************************************************************************/\n\n#include<bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_N = 10010;\nconst int MAX_M = 200000;\nstruct point{\n\tint x, y;\n}P[MAX_N];\nstruct edge{\n\tint from , to;\n\tdouble cost;\n}E[MAX_M];\n\nint n , m;\nint par[MAX_N];\n\nvoid init_union_find_set()\t{ for(int i = 0 ; i <= n ; i++)\tpar[i] = i; }\nint  find(int x)\t\t\t{ return x == par[x] ? x : par[x] = find(par[x]); }\nbool same(int x,int y)\t\t{ return find(x) == find(y); }\nvoid union_set(int x,int y) { x = find(x); y = find(y); if(x!=y) par[y] = x; }\n\nbool cmp(edge a,edge b){\n\treturn a.cost < b.cost;\n}\ndouble Kruskal(){\n\tinit_union_find_set();\n\tsort(E,E+m,cmp);\n\tdouble ret = 0;\n\tfor(int i = 0 ; i < m ; i++){\n\t\tif( !same(E[i].from,E[i].to) ){\n\t\t\tunion_set(E[i].from,E[i].to);\n\t\t\tret += E[i].cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\ndouble Distence(point a,point b){\n\treturn sqrt( (a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y) );\n}\n\nint main(){\n\tint from , to;\n\tdouble cost , sum;\n\twhile(~scanf(\"%d%d\",&n,&m)){\n\t\tsum = 0;\n\t\tfor(int i = 1 ; i <= n ; i++){\n\t\t\tscanf(\"%d%d\",&P[i].x,&P[i].y);\n\t\t}\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tscanf(\"%d%d\",&E[i].from , &E[i].to);\n\t\t\tE[i].cost = Distence( P[E[i].from] , P[E[i].to] ) * -1;\n\t\t\tsum += ( E[i].cost * -1 );\n\t\t}\n\t\tdouble ret = Kruskal();\n\t\tprintf(\"%.3lf\\n\",sum + ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass UnionFindTree{\nprivate:\n  int _size;\n  int* _parent;\n  int* _rank;\npublic:\n  UnionFindTree(int n){\n    _size = n;\n    _parent = new int[_size]();\n    _rank = new int[_size]();\n    for(int i = 0; i < _size; i++){\n      _parent[i] = i;\n      _rank[i] = 1;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] _parent;\n    delete[] _rank;\n  }\n\n  int find(int child){\n    int next = _parent[child];\n    if(next == child) return child;\n    else return find(next);\n  }\n\n  bool same(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    return (lhs == rhs);\n  }\n  \n  bool unite(int lhs,int rhs){\n    if(same(lhs,rhs)) return false;\n    \n    if(_rank[lhs] < _rank[rhs]){\n      _parent[rhs] = lhs;\n      _rank[lhs] += _rank[rhs];\n    }\n    else {\n      _parent[lhs] = rhs;\n      _rank[rhs] += _rank[lhs];\n    }\n    return true;\n  }\n\n};\n\nclass State {\npublic:\n  int _from,_to;\n  double _distance;\n  State(int from,int to,double distance)\n    : _from(from),_to(to),_distance(distance) {}\n  bool operator<(const State& s) const {\n    return _distance < s._distance;\n  }\n  bool operator>(const State& s) const {\n    return _distance > s._distance;\n  }\n};\n\nint main(){\n  int num_of_magical_piles;\n  int num_of_magical_fences;\n  while(~scanf(\"%d %d\",\n               &num_of_magical_piles,\n               &num_of_magical_fences)){\n    \n    vector<P> piles;\n    for(int pile_i = 0; pile_i < num_of_magical_piles; pile_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      piles.push_back(P(x,y));\n    }\n\n    double sum = 0;\n    priority_queue<State,vector<State> > que;\n\n    for(int fence_i = 0; fence_i < num_of_magical_fences; fence_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      from--; to--;\n      int from_x = piles[from].first;\n      int from_y = piles[from].second;\n\n      int to_x = piles[to].first;\n      int to_y = piles[to].second;\n\n      double distance = sqrt((double)((from_x - to_x) * (from_x - to_x)\n                                      + (from_y - to_y) * (from_y - to_y)));\n      sum += distance;\n      que.push(State(from,to,distance));\n    }\n\n    UnionFindTree uft(num_of_magical_piles);\n    double after_ruined = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(uft.same(s._from ,s._to)) continue;\n      uft.unite(s._from,s._to);\n      after_ruined += s._distance;\n    }\n    printf(\"%lf\\n\",sum - after_ruined);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct UnionFind {\nprivate:\n\tstd::vector<int> value;\npublic:\n\tUnionFind(int size): value(size, -1){}\n\tint find(int x){\n\t\treturn value[x] < 0 ? x : value[x] = find(value[x]);\n\t}\n\tint size(int x){\n\t\treturn -value[find(x)];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tbool unite(int x, int y){\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\tif (value[x] > value[y]) std::swap(x, y);\n\t\tvalue[x] += value[y];\n\t\tvalue[y] = x;\n\t\treturn true;\n\t}\n};\n\nusing namespace std;\n\nstruct Edge {\n\tint src, dst, cost;\n\tEdge(){}\n\tEdge(int src, int dst, int cost): src(src), dst(dst), cost(cost){}\n};\n\nint n, m;\nint x[10000], y[10000];\nvector<Edge> es;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\", x + i, y + i);\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t); --s; --t;\n\t\tdouble d = sqrt((x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]));\n\t\tes.push_back(Edge(s, t, d));\n\t}\n\t\n\tsort(begin(es), end(es), [](const Edge &a, const Edge &b){return a.cost > b.cost;});\n\tUnionFind uf(n);\n\tdouble res = 0;\n\tfor (auto &e : es){\n\t\tif (!uf.unite(e.src, e.dst)) res += e.cost;\n\t}\n\tprintf(\"%.20f\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\ntypedef pair<double,P> PP;\n\ndouble D(P a,P b){return sqrt((a.F-b.F)*(a.F-b.F)+(a.S-b.S)*(a.S-b.S));}\nint p[10001],r[10001];\nvoid init(){for(int i=0;i<10001;i++)p[i]=i,r[i]=0;}\nint find(int x){return (p[x]==x)?x:(p[x]=find(p[x]));}\nvoid unite(int x,int y) {\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(r[x]<r[y])p[x]=y;\n  else{p[y]=x;if(r[x]==r[y])r[x]++;}\n}\nbool same(int x,int y){return find(x)==find(y);}\n\nint main() {\n  int n,m;\n  cin >> n >> m;\n  P a[n];\n  for(int i=0;i<n;i++) cin >> a[i].F >> a[i].S;\n  priority_queue<PP> que;\n  double sum=0;\n  for(int i=0;i<m;i++) {\n    int x,y;\n    cin >> x >> y;\n    x--,y--;\n    sum+=D(a[x],a[y]);\n    que.push(PP(D(a[x],a[y]),P(x,y)));\n  }\n  init();\n  double ans=0;\n  while(!que.empty()) {\n    PP p=que.top();que.pop();\n    int x=p.S.F,y=p.S.S;\n    double d=p.F;\n    if(same(x,y)) continue;\n    unite(x,y);\n    ans+=d;\n  }\n  printf(\"%.10f\\n\",sum-ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1<<29\nusing namespace std;\n\nvector<pair<int,double> > v[10001];\nint x[10001],y[10001];\nint n,m;\ndouble ans=0.0;\nbool visited[10001]={};\n\ndouble getdis(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\n\nvoid prim(int start){\n  double d[10001];\n  for(int i=0;i<n;i++)d[i]=-1;\n\n  priority_queue<pair<double,int> > pq;\n  pq.push(mp(0,start));\n  d[start]=0;\n\n  while(!pq.empty()){\n    pair<double,int> u=pq.top();\n    pq.pop();\n    double dis=u.f;\n    int now=u.s;\n    if(dis<d[u.s])continue;\n\n    for(int i=0;i<v[now].size();i++){\n      pair<int,double> e=v[now][i];\n      if(d[e.f]<e.s && !visited[e.f]){\n\td[e.f]=e.s;\n\tpq.push(mp(e.s,e.f));\n      }\n    }\n    visited[now]=true;\n  }\n  double sum=0.0;\n  for(int i=0;i<n;i++){\n    if(d[i]!=-1)sum+=d[i];\n  }\n  ans-=sum;\n}\n\nint main()\n{\n  int a,b;\n\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--;b--;\n    double dis=getdis(a,b);\n    ans+=dis;\n    v[a].push_back(mp(b,dis));\n    v[b].push_back(mp(a,dis));\n  }\n\n  for(int i=0;i<n;i++){\n    if(!visited[i])prim(i);\n  }\n\n  printf(\"%.5f\\n\",ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n//typedef complex<double> Point;\n//typedef complex<double> Vector;\ntypedef long long LL;\n\nint n,m;\nint pa[10005];\n\nvoid init()\n{\n    for(int i=0;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x]!= x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return w > t.w;\n    }\n}e[10005];\n\nstruct point\n{\n    int x,y;\n}p[10005];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        double sum = 0;\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty, e[i].w = sqrt(1.0*(p[tx].x - p[ty].x)*(p[tx].x - p[ty].x) + 1.0*(p[tx].y - p[ty].y)*(p[tx].y - p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <fstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n#define inf 2147480000\nstruct hammer\n{\n   double x;\n   double y;\n}box[10001];\nstruct heaven\n{\n   int start;\n   int end;\n   double data;\n}map[10000001];\nint n,m;\nint o=0;\ndouble total;\ndouble add(hammer a,hammer b)\n{\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint set[10001];\nint size[10001];\nvoid ini()\n{\n   for(int i=1;i<=n;i++)\n   {\n      set[i]=i;\n      size[i]=1;\n   }\n}\nint find(int a)\n{\n    if(set[a]==a) return a;\n    set[a]=find(set[a]);\n    return set[a];\n}\nvoid uni(int a,int b)\n{\n   if(size[a]>=size[b])\n   {\n      size[a]+=size[b];set[b]=a;\n   }\n   else \n   {\n      size[b]+=size[a];set[a]=b;\n   }\n}\nint cmp(const heaven & a,const heaven & b)\n{\n    if(a.data>b.data) return 1;\n    else return 0;\n}\nint main(int argc, char *argv[])\n{\n    cin>>n>>m;\n    ini();\n    for(int i=1;i<=n;i++)\n    {\n       double a,b;\n       scanf(\"%lf%lf\",&a,&b);\n       box[i].x=a;box[i].y=b;\n    }\n    for(int i=1;i<=m;i++)\n    {\n       int a,b;\n       scanf(\"%d%d\",&a,&b);\n       o++;\n       map[o].start=a;map[o].end=b;\n       map[o].data=add(box[a],box[b]);\n       total+=map[o].data;\n    }\n    sort(map+1,map+1+o,cmp);\n    double sum=0;\n    for(int i=1;i<=o;i++)\n    {\n        int a=find(map[i].start);int b=find(map[i].end);\n        if(a!=b)\n        {\n            uni(a,b);\n            sum+=map[i].data;\n        }\n    }\n    sum=total-sum;\n    printf(\"%.3lf\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint i,j,k,n,m,x,y,z,xx,yy;\nstruct node{\n\tint x,y;\n} a[20000];\nstruct egde{\n\tint x,y;\n\tdouble z;\n} b[500000];\n\nint fa[20000];\ndouble sum,now;\n\ndouble dist(int x,int y)\n{\n\treturn  sqrt( (a[x].x-a[y].x)*(a[x].x-a[y].x)*1.0+  (a[x].y-a[y].y)*(a[x].y-a[y].y)*1.0 );\n}\n\nbool cmp(struct egde a,struct egde b)\n{\n\tif (a.z>b.z) return true;\n \treturn false;\n}\n\nint getf(int x)\n{\n\tif (x==fa[x]) return x;\n\treturn (fa[x]=getf(fa[x]));\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\t\n\tfor(i=1;i<=n;i++) fa[i]=i;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t}\n\tsum=0;\n\tfor(i=0;i<m;i++)\n\t{\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tb[i].x=x;\n\t\tb[i].y=y;\n\t\tb[i].z=dist(x,y);\n\t\tsum+=b[i].z;\n\t}\n\tnow=0;\n\tsort(b,b+m,cmp);\n\t\n\tfor(i=0;i<m;i++)\n\t{\n\t\txx=getf(b[i].x);\n\t\tyy=getf(b[i].y);\n\t\tif (xx!=yy)\n\t\t{\n\t\t\tnow+=b[i].z;\n\t\t\tfa[xx]=yy;\n\t\t}\n\t}\n\t\n\tprintf(\"%.3lf\\n\",sum-now);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include  <bits/stdc++.h>\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\nusing namespace std;\n\nconst int vmax=10010;\nconst int inf=1023456789;\n\nint N,M;\ntypedef tuple<double,int,int> node;\nvector<node> graph;\n\nint par[vmax];\nvoid init(){rep(i,vmax) par[i]=i;}\nint find(int x){return (par[x]==x)?x:par[x]=find(par[x]);}\nvoid unite(int a,int b){a=find(a),b=find(b);par[a]=b;}\nbool same(int a,int b){return find(a)==find(b);}\n\ndouble kruskal(){\n\tinit();\n\tsort(begin(graph),end(graph));\n\treverse(begin(graph),end(graph));\n\tdouble res=0;\n\tfor(auto &e:graph){\n\t\tint a,b;\n\t\tdouble c;\n\t\ttie(c,a,b)=e;\n\t\tif(!same(a,b)) unite(a,b),res+=c;\n\t}\n\treturn res;\n}\n\ncomplex<double> p[vmax];\n\nint main(void){\n\tcin >> N >> M;\n\trep(i,N){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tp[i]={x,y};\n\t}\n\tdouble sum=0.0;\n\trep(i,M){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\tdouble c=abs(p[a]-p[b]);\n\t\tsum+=c;\n\t\tgraph.push_back(node(c,a,b));\n\t}\n\tcout.precision(10);\n\tcout << fixed << sum-kruskal() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<set>\nusing namespace std;\n\nconst int maxn=50005;\nstruct edge{\n\tint u,v;\n\tdouble cost;\n}es[maxn];\nint n,m;\nint x[maxn],y[maxn],f[maxn];\nbool cmp(edge a,edge b){\n\treturn a.cost>b.cost;\n}\nint find(int x){\n\tif(f[x]==x) return x;\n\treturn f[x]=find(f[x]);\n}\nbool unite(int a,int b){\n\tint x=find(a),y=find(b);\n\tif(x==y) return 0;\n\telse f[x]=y;\n\treturn 1;\n}\ndouble K(){\n\tsort(es,es+m,cmp);\n\tdouble ans=0;\n\tfor(int i=0;i<m;i++){\n\t\tif(unite(es[i].u,es[i].v)) ans+=es[i].cost;\n\t}\n\treturn ans;\n\n}\nint main(){\n\twhile(cin>>n>>m){\n\t\tfor(int i=1;i<=n;i++) f[i]=i,cin>>x[i]>>y[i];\n\t\tint p,q;\n\t\tdouble sum=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>p>>q;\n\t\t\tes[i].u=p,es[i].v=q;\n\t\t\tes[i].cost=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n\t\t\tsum+=es[i].cost;\n\t\t}\n\t\tdouble ans=sum-K();\n\t\tprintf(\"%.3lf\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, x[10000], y[10000], p[10000];\nint root(int x){\n\tif(p[x] == x) return x;\n\treturn p[x] = root(p[x]);\n}\ninline double d(int dx, int dy){\n\treturn sqrt(dx * dx + dy * dy);\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) scanf(\"%d%d\", x + i, y + i), p[i] = i;\n\tvector<pair<double, pi> > es;\n\tdouble ans = 0;\n\t\n\trep(i, m){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\ta--; b--;\n\t\tdouble t = d(x[a] - x[b], y[a] - y[b]); \n\t\tes.pb(mp(t, mp(a, b)));\n\t\tans += t;\n\t}\n\tsort(all(es));\n\tfor(int i = es.size() - 1; i >= 0; i--){\n\t\tint a = root(es[i].second.first), b = root(es[i].second.second);\n\t\tif(a == b) continue;\n\t\tp[a] = b;\n\t\tans -= es[i].first;\n\t}\n\tprintf(\"%.9f\\n\", ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<math.h>\n#define maxn 10010\n#define INF 0x7fffffff\nusing namespace std;\nstruct node\n{\n    double x,y;\n}mapp[maxn];\nstruct point\n{\n    double egde;\n    int x,y;\n}Map[maxn];\nint m,n,pre[maxn];\ndouble dis[maxn*maxn],sum1=0.0;\nbool vis[maxn];\nint Find(int x)\n{\n    int r=x;\n    while(r!=pre[r])\n        r=pre[r];\n    int i=x,j;\n    while(i!=r)\n    {\n        j=pre[i];\n        pre[i]=r;\n        i=j;\n    }\n    return r;\n}\nint join(int x,int y)\n{\n    int fx=Find(x),fy=Find(y);\n    if(fx!=fy)\n    {\n        pre[fx]=fy;\n        return 1;\n    }\n    return 0;\n}\nint cmp(point a,point b)\n{\n    return a.egde>b.egde;\n}\ndouble kru()\n{\n    sort(Map,Map+1,cmp);\n    int cnt=0;\n    double ans=0;\n    for(int i=0;i<m&&cnt<n-1;i++)\n    {\n        if(join(Map[i].x,Map[i].y))\n        {\n            ans+=Map[i].egde;\n            ++cnt;\n        }\n    }\n    return ans;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    {\n        for(int i=1;i<=n;i++)\n            pre[i]=i;\n        for(int i=1;i<=n;i++)\n            scanf(\"%lf%lf\",&mapp[i].x,&mapp[i].y);\n        double sum=0;\n        for(int i=0;i<m;i++)\n        {\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            Map[i].x=a,Map[i].y=b;\n            Map[i].egde=sqrt((mapp[a].x-mapp[b].x)*(mapp[a].x-mapp[b].x)+(mapp[a].y-mapp[b].y)*(mapp[a].y-mapp[b].y));\n            sum=sum+Map[i].egde;\n        }\n        printf(\"%.4f\\n\",sum-kru());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nclass UnionFind {\nprivate:\n    const int n;\n    vector<int> uni;\npublic:\n    UnionFind(int _n) : n(_n), uni(_n, -1) {}\n    int root(int x) {\n        if (uni[x] < 0) return x;\n        return uni[x] = root(uni[x]);\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (uni[x] > uni[y]) swap(x, y);\n        uni[x] += uni[y];\n        uni[y] = x;\n        return true;\n    }\n    void print() {\n        for (auto x : uni) cout << x << \" \";\n        cout << endl;\n    }\n};\n\nstruct edge {\n    int from, to;\n    double cost;\n    edge(){}\n    edge(int _from, int _to, double _cost) : from(_from), to(_to), cost(_cost) {}\n    bool operator< (const edge& e) const {\n        return cost == e.cost ? (from == e.from ? to < e.to : from < e.from) : cost < e.cost;\n    }\n    void print() {\n        output(from, to, cost);\n    }\n};\n\nclass Kruskal {\nprivate:\n    int n;\n    vector<edge> edges;\n    UnionFind uf;\npublic:\n    Kruskal(int _n) : n(_n), uf(_n) {}\n    void addEdge(int _from, int _to, double _cost) {\n        edges.emplace_back(_from, _to, _cost);\n    }\n    double calc() {\n        sort(rall(edges));\n        double res = 0;\n        rep(i, edges.size()) {\n            if (uf.unite(edges[i].from, edges[i].to)) {\n                res += edges[i].cost;\n            }\n        }\n        return res;\n    }\n};\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vi x(n), y(n);\n    rep(i, n) cin >> x[i] >> y[i];\n\n    Kruskal kr(n);\n    double ans = 0;\n    rep(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        double c = sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));\n        kr.addEdge(a, b, c);\n        ans += c;\n    }\n\n    ans -= kr.calc();\n    cout << fixed << setprecision(10) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\n#define int ll\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nint union_tree[200000];\nint union_find(int a) {\n    if (union_tree[a] == a) return a;\n    return union_tree[a] = union_find(union_tree[a]);\n}\nint union_merge(int a, int b) {\n    a = union_find(a);\n    b = union_find(b);\n    if (a == b) return 0;\n    union_tree[a] = b;\n    return 1;\n}\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    vector<complex<long double>> inputs;\n    REP(i, n) {\n        union_tree[i] = i;\n        long double a, b;\n        cin >> a >> b;\n        inputs.push_back(complex<long double>{a, b});\n    }\n    vector<tuple<long double, int, int>> edges;\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        edges.push_back(make_tuple(abs(inputs[a] - inputs[b]), a, b));\n    }\n    sort(ALL(edges));\n    long double ans = 0;\n    for (int i = m - 1; i >= 0; --i) {\n        ans += (long double)(1 - union_merge(get<1>(edges[i]), get<2>(edges[i]))) * get<0>(edges[i]);\n    }\n    cout << ans << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\ntypedef pair<double,pi> edge;\n\ninline double dist(int x1, int y1, int x2, int y2)\n{\n    return sqrt(pow(x1-x2,2)+pow(y1-y2,2));\n}\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nint main()\n{\n    int n,m;\n    scanf(\" %d %d\", &n, &m);\n\n    vector<int> x(n),y(n);\n    rep(i,n) scanf(\" %d %d\", &x[i], &y[i]);\n\n    vector<edge> e(m);\n    double sum=0;\n    rep(i,m)\n    {\n        int p,q;\n        scanf(\" %d %d\", &p, &q);\n        --p;\n        --q;\n\n        e[i] = edge(dist(x[p],y[p],x[q],y[q]), pi(p,q));\n        sum += e[i].fi;\n    }\n\n    sort(all(e),greater<edge>());\n\n    UF uf(n);\n    double mst_max_cost=0;\n    rep(i,m)\n    {\n        int p=e[i].se.fi, q=e[i].se.se;\n        if(!uf.same(p,q))\n        {\n            uf.unite(p,q);\n            mst_max_cost += e[i].fi;\n        }\n    }\n\n    printf(\"%.10f\\n\", sum - mst_max_cost);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nstruct node{\n    double x,y;\n}ver[10010];\nstruct Edge{\n    int u,v;\n    double l;\n}e[1000000];\nint n,m;\nint pre[10010];\nint Find(int x){\n    if(x == pre[x])\n        return x;\n    else return pre[x] = Find(pre[x]);\n}\nint Union(int x,int y){\n    int fx = Find(x),fy = Find(y);\n    if(fx == fy)\n        return 0;\n    else{\n        pre[fy] = fx;\n        return 1;\n    }\n}\nbool cmp(Edge a,Edge b){\n    return a.l > b.l;\n}\nint main(){\n    int i,j;\n    cin >> n >> m;\n    for(i = 0; i < 10010; i++)\n        pre[i] = i;\n    for(i = 1; i <= n; i++){\n        cin >> ver[i].x >> ver[i].y;\n    }\n    double allsum = 0.0;\n    for(i = 0; i < m; i++){\n        int u,v;\n        double len;\n        cin >> u >> v;\n        len = sqrt((ver[u].x-ver[v].x)*(ver[u].x-ver[v].x)+(ver[u].y-ver[v].y)*(ver[u].y-ver[v].y));\n        e[i].u = u;\n        e[i].v = v;\n        e[i].l = len;\n        allsum += len;\n    }\n    //cout << allsum << endl;\n    sort(e,e+m,cmp);\n    double sum = 0.0;\n    int num = 0;\n    for(i = 0; i < m; i++){\n        if(Union(e[i].u,e[i].v)){\n            sum += e[i].l;\n            num++;\n        }\n        if(num == n-1)\n            break;\n    }\n    //cout << sum << endl;\n    printf(\"%.3f\\n\",allsum-sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#pragma warning(disable : 4996)\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nstruct edge\n{\n\tint from, to;\n\tdouble cost;\n\tedge() {};\n\tedge(int a, int b,double c) {\n\t\tfrom = a, to = b, cost = c;\n\t}\n};\nbool cmp(edge e1, edge e2) {\n\treturn e1.cost > e2.cost;\n}\nconst int MAX_N = 10005;\nconst int MAX_C = 100000;\nint N, M;\nint A[MAX_C], B[MAX_C], C[MAX_C], D[MAX_C];\nedge es[MAX_C];\nint par[MAX_N];\nint ranks[MAX_N];\n\n#define loop(i,N) for(int i=1;i<=N;i++)\nvoid init(int X) {\n\tfor (int i = 0; i <=N; i++)\n\t{\n\t\tpar[i] = i;\n\t\tranks[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (par[x] == x)\n\t\treturn x;\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t\treturn;\n\tif (ranks[x] < ranks[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (ranks[x] == ranks[y])\n\t\t\tranks[x]++;\n\t}\n}\ndouble kruskal() {\n\tinit(N);\n\tsort(es+1, es + M+1, cmp);\n\tdouble res = 0;\n\tloop(u, M) {\n\t\tedge  e = es[u];\n\t\tif (!same(e.from, e.to)) {\n\t\t\tunite(e.from, e.to);\n\t\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nint main() {\n\twhile (scanf(\"%d%d\",&N,&M)!=EOF)\n\t{\n\t\tdouble ans=0;\n\t\tloop(i, N) {\n\t\t\tscanf(\"%d%d\", &A[i], &B[i]);\n\t\t}\n\t\tloop(j, M) {\n\t\t\tscanf(\"%d%d\", &C[j], &D[j]);\n\t\t\tdouble dis = sqrt((A[C[j]] - A[D[j]])*(A[C[j]] - A[D[j]]) + (B[C[j]] - B[D[j]])*(B[C[j]] - B[D[j]]));\n\t\t\tes[j] = edge(C[j], D[j], dis);\n\t\t\tans += dis;\n\t\t}\n\t\tans -= kruskal();\n\t\tprintf(\"%.3lf\\n\", ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct fence{\n  int u,v;\n  double cost;\n};\n\n#define N 10000\n\nint par[N];\nint urank[N];\n\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i] = i;\n    urank[i] = 0;\n  }\n}\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x==y)return;\n\n  if(urank[x]<urank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n    if(urank[x]==urank[y])urank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\ndouble distance(int x1,int y1,int x2,int y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nbool cmp(const fence &a,const fence &b){\n  return a.cost > b.cost;\n}\n\nint main(){\n  int n,m;\n  P piles[N];\n  vector<fence> fences;\n\n  scanf(\"%d%d\",&n,&m);\n  for(int i=0;i<n;i++){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    piles[i] = P(x,y);\n  }\n  for(int i=0;i<m;i++){\n    int p,q;\n    scanf(\"%d%d\",&p,&q);\n    p--;q--;\n    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);\n    fences.push_back((fence){p,q,c});\n  }\n\n  double sum = 0;\n  init(n);\n  sort(fences.begin(),fences.end(),cmp);\n  for(int i=0;i<m;i++){\n    int u = fences[i].u;\n    int v = fences[i].v;\n    if(same(u,v)){\n      sum += fences[i].cost;\n    }else{\n      unite(u,v);\n    }\n  }\n\n  cout << sum << endl;\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = pair<int,int>;\n#define fir first\n#define sec second\n#define all(v) begin(v),end(v)\n\nint par[11111];\nint siz[11111];\n\nvoid init(int n) {\n    for(int i=0; i<n; ++i) {\n        par[i]=i;\n        siz[i]=0;\n    }\n}\n\nint find(int v) {\n    if(par[v]==v) return v;\n    return par[v]=find(par[v]);\n}\n\n\nbool unite(int u,int v) {\n    u=find(u);\n    v=find(v);\n    if(u==v) return false;\n    if(siz[u]<siz[v]) swap(u,v);\n    siz[u]+=siz[v];\n    par[v]=u;\n    return true;\n}\n\nint n,m;\npii crd[11111];\ndouble ans;\nvector<tuple<double,int,int>> egs;\n\nsigned main() {\n    cin>>n>>m;\n    init(n);\n    for(int i=0; i<n; ++i) {\n        cin>>crd[i].fir>>crd[i].sec;\n    }\n    for(int i=0; i<m; ++i) {\n        int u,v; cin>>u>>v;\n        u--,v--;\n        double len=sqrt(pow(crd[u].fir-crd[v].fir,2)+pow(crd[u].sec-crd[v].sec,2));\n        egs.emplace_back(len,u,v);\n        ans+=len;\n    }\n    sort(all(egs),greater<>());\n    for(auto &e:egs) {\n        int a,b; double c;\n        tie(c,a,b)=e;\n        if(unite(a,b)) {\n            ans-=c;\n        }\n    }\n    cout<<setprecision(10)<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> P1;\nint n,m,x[N],y[N],p,q;\ndouble cost,ans;\nvector<P1> e;\nint rank[N];\nint par[N];\n \nvoid init(){\n  for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n}\n \nint find(int u){\n  if(par[u]==u)return u;\n  return par[u]=find(par[u]);\n}\n \nvoid unite(int u,int v){\n  u=find(u);\n  v=find(v);\n  if(u==v)return;\n  if(rank[u]<rank[v])par[u]=v;\n  else{\n    par[v]=u;\n    if(rank[u]==rank[v])rank[u]++;\n  }\n}\n \nbool same(int u,int v){\n  return find(u)==find(v);\n}\n \ndouble getlen(int a,int b){\n  double X=x[a]-x[b],Y=y[a]-y[b];\n  return sqrt(X*X+Y*Y);\n}\n \ndouble kruskal(){\n  sort(e.begin(),e.end());\n  init();\n  double res=0;\n  for(int i=0;i<(int)e.size();i++){\n    int u=e[i].second.first;\n    int v=e[i].second.second;\n    if(!same(u,v))unite(u,v),res+=e[i].first;\n  }\n  return -res;\n}\n \nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<m;i++){\n    cin>>p>>q;\n    e.push_back(P1(-getlen(--p,--q),P(p,q)));\n    ans+=getlen(p,q);\n  }\n  ans-=kruskal();\n  printf(\"%.8f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include <iomanip>\n#include<cstring>\nusing namespace std;\n\nclass unionfind\n{\n\tpublic:\n\t\t//初始化n个元素 \n\t\tvoid init(int n)\n\t\t{\n\t\t\tpar = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\tfor(int i = 0;i <= n;i++)\n\t\t\t{\n\t\t\t\tpar[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\t//查询树的根 \n\t\tint find(int x)\n\t\t{\n\t\t\tif(par[x] == x)\n\t\t\t{\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\t//合并x和y所属的集合\n\t\tvoid unite(int x,int y)\n\t\t{\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y)\n\t\t\t    return;\n\t\t\tif(rank[x] < rank[y])\n\t\t\t{\n\t\t\t\tpar[x] = y;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y])\n\t\t\t\t{\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint *par;\n\t\tint *rank;\n};\n\nstruct edge\n{\n\tint u;\n\tint v;\n\tdouble cost;\n}; \nbool comp(const edge& e1,const edge& e2)\n{\n\treturn e1.cost > e2.cost;\n}\n\nint n,m,p,q;\nint xi[10010];\nint yi[10010];\ndouble all = 0;\nedge es[50100050];\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i = 0;i < n;i++)\n\t{\n\t\tscanf(\"%d%d\",&xi[i],&yi[i]);\n\t}\n\tfor(int i = 0;i < m;i++)\n\t{\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\tes[i].u--;\n\t\tes[i].v--;\n\t\tint dx = xi[es[i].u] - xi[es[i].v];\n\t\tint dy = yi[es[i].u] - yi[es[i].v];\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t\tall = all + es[i].cost;\n\t}\n\tsort(es,es + m,comp);\n\tunionfind A;\n\tA.init(n);\n\tdouble res = 0;\n\tfor(int i = 0;i < m;i++)\n\t{\n\t\tedge e = es[i];\n\t\tif(A.find(es[i].u) != A.find(es[i].v) )\n\t\t{\n\t\t\tA.unite(es[i].u,es[i].v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres = res + es[i].cost;\n\t\t}\n\t}\n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout<<res<<endl;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\nstruct edge{\n    int u,v;\n    double cost;\n}es[1000005];\nstruct dot{\n    int x,y;\n};\nint n,m;\ndot dd[10005];\nint par[10005],rrank[10005];\nvoid init(int n)\n{\n    for(int i=1;i<=n;i++)\n    {\n        par[i]=i;\n        rrank[i]=0;\n    }\n    return;\n}\nint ffind(int x)\n{\n    if(x==par[x]) return x;\n    else return par[x]=ffind(par[x]);\n}\nvoid unite(int x,int y)\n{\n    x=ffind(x);\n    y=ffind(y);\n    if(x==y) return;\n    if(rrank[x]<rrank[y]) par[x]=y;\n    else {\n        par[y]=x;\n        if(rrank[x]==rrank[y]) rrank[x]++;\n    }\n    return;\n}\nbool same(int x,int y)\n{\n    return ffind(x)==ffind(y);\n}\ndouble dis(int s,int t)\n{\n    int p=dd[s].x-dd[t].x;\n    int q=dd[s].y-dd[t].y;\n    return sqrt(p*p+q*q);\n}\nbool comp(const edge& a,const edge& b)\n{\n    return a.cost>b.cost;\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i=1;i<=n;i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        dd[i].x=s;dd[i].y=t;\n    }\n    double ssum=0,psum=0;\n    for(int i=0;i<m;i++) {\n        int s,t;\n        scanf(\"%d%d\",&s,&t);\n        edge e;\n        e.u=s;e.v=t;\n        e.cost=dis(s,t);\n        es[i]=e;\n        ssum+=e.cost;\n    }\n    sort(es,es+m,comp);\n    init(n);\n\n    for(int i=0;i<m;i++) {\n            edge e=es[i];\n        if(!same(e.u,e.v)) {\n            unite(e.u,e.v);\n            psum+=e.cost;\n        }\n    }\n    printf(\"%.3lf\\n\",ssum-psum);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n \nint N, M;\nint par[MAX], rank[MAX];\ntypedef pair<double,double> P;\nvoid init(){\n    for(int i = 0 ; i < N ; i++){\n\tpar[i] = i;\n\trank[i] = 0;\n    }\n}\n \nint find(int x){\n    if(par[x] == x){\n\treturn x;\n    }else{\n\treturn par[x] = find(par[x]);\n    }\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n \n    if(x == y) return;\n \n    if(rank[x] < rank[y]){\n\tpar[x] = y;\n    }else{\n\tpar[y] = x;\n \n\tif(rank[x] == rank[y]){\n\t    rank[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return find(x) == find(y);\n}\n \nstruct edge{\n    int u,v;\n    double cost;\n};\n \nbool comp(const edge &e1,const edge &e2){\n    return e1.cost > e2.cost;\n}\n \nedge es[MAX];\n \ndouble kruskal(){\n    init(); sort(es , es + M, comp);\n    double res = 0;\n    for(int i = 0 ; i < M ; i++){\n\tedge e = es[i];\n\tif(!same(e.u , e.v)){\n\t    unite(e.u , e.v);\n\t    res += e.cost;\n\t}\n    }\n    return res;\n}\n \ndouble dist(P p1, P p2){\n    return sqrt(pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2));\n}\n \nint main(){\n    int a,b;\n    P p[MAX];\n \n    scanf(\"%d %d\" ,&N ,&M);\n    for(int i = 0 ; i < N ; i++){\n\tscanf(\"%lf%lf\",&p[i].first, &p[i].second);\n    }\n    double total = 0;\n    for(int i = 0 ; i < M ; i++){\n\tscanf(\"%d %d\" ,&a ,&b);  \n\ta--, b--;\n\tdouble d = dist(p[a], p[b]);\n\tes[i].u = a; es[i].v = b; es[i].cost = d;\n\ttotal += d;\n    }\n    printf(\"%.5f\\n\",total-kruskal());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\n#define X real()\n#define Y imag()\n\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\ntypedef complex<double> P;\nint n, m;\n\nmain(){\n\tscanf(\"%d%d\", &n, &m);\n\tvector<P> p(n);\n\tREP(i, n) scanf(\"%lf%lf\", &p[i].X, &p[i].Y);\n\tvector<pair<double, pii> > e;\n\tREP(i, m){\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);u--;v--;\n\t\te.push_back(pair<double, pii>(abs(p[u]-p[v]), pii(u, v)));\n\t}\n\tsort(RALL(e));\n\tUnionFind uf(n);\n\tdouble ans = 0;\n\tFOR(it, e)\n\t\tif(!uf.unionSet(it->second.first, it->second.second)) ans += it->first;\n\tprintf(\"%.9f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <string>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <vector>\n#define UP(i,x,y) for(i=x;i<=y;i++)\n#define DOWN(i,x,y) for(i=x;i>=y;i--)\n#define MEM(a,x) memset(a,x,sizeof(a))\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define lson rt<<1, l, mid\n#define rson rt<<1|1, mid + 1, r\n#define lowbit(x) (x&-x)\nusing namespace std;\nstruct point\n{\n    int x,y;\n}p[10050];\nstruct edge\n{\n    int u;\n    int v;\n    double len;\n}e[10000*200];\nint n,m;\nbool vis[20005];\nbool cmp(const edge &e1, const edge &e2)\n{\n    return e1.len > e2.len;\n}\nint par[20005];\nint ran[20005];\nvoid init(int n)\n{\n    for(int i = 0; i <= n; i++) {\n        par[i] = i;\n        ran[i] = 0;\n    }\n}\nint find(int x)\n{\n    if(par[x] == x)\n        return x;\n    return par[x] = find(par[x]);\n}\nvoid unite(int x, int y)\n{\n    int fx = find(x);\n    int fy = find(y);\n    if(fx == fy)\n        return;\n    if(ran[fx] > ran[fy])\n        par[fy] = fx;\n    else {\n        par[fx] = fy;\n        if(ran[fx] == ran[fy])\n            ran[fy]++;\n    }\n}\ndouble kruskal()\n{\n    sort(e,e+m,cmp);\n    init(n);\n    double res = 0;\n    for(int i = 0; i < m; i++) {\n        if(find(e[i].u)!=find(e[i].v)){\n            unite(e[i].u,e[i].v);\n            res += e[i].len;\n        }\n    }\n    return res;\n}\ndouble calc(double x1, double y1, double x2, double y2)\n{\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\nint main()\n{\n    cin>>n>>m;\n    for(int i = 1; i <= n; i++)\n        scanf(\"%d%d\",&p[i].x,&p[i].y);\n    double sum = 0;\n    for(int i = 0; i < m; i++) {\n        int x, y;\n        scanf(\"%d%d\",&x,&y);\n        e[i].len = calc(p[x].x,p[x].y,p[y].x,p[y].y);\n        e[i].u = x;\n        e[i].v = y;\n        sum += e[i].len;\n    }\n    double res = kruskal();\n    printf(\"%.3lf\",sum-res);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#define Max 10010\nusing namespace std;\n\nint unit[Max*2],n,m;\n\nstruct st{\n    int from, to;\n    double cost;\n}edge[Max*Max];\n\npair<int, int> ch[Max*2];\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++)\n        unit[i] = i;\n}\n\nint cmp(st a, st b){\n    return a.cost > b.cost;\n}\n\nint find(int k){\n    if(unit[k] == k) return k;\n    return unit[k] = find(unit[k]);\n}\n\nint isthesame(int a, int b){\n    int x = find(a), y = find(b);\n    if(x == y) return false;\n    else\n    {\n        //cout<<x<<\"  \"<<y<<endl;\n        unit[x] = y;\n        return true;\n    }\n}\n\ndouble kruskal(){\n    sort(edge+1, edge + m + 1, cmp);\n    init(n);\n    double ans = 0;\n    for(int i = 1; i <= m; i++)\n    {\n        if(isthesame(edge[i].from, edge[i].to))\n        {\n            ans += edge[i].cost;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int a,b,x,y;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> a >> b;\n        ch[i] = {a,b};\n    }\n    double allcost = 0;\n    for(int i = 1; i <= m; i++)\n    {\n        cin >> x >> y;//genhao x-x1^2+y-y1^2\n        double cost = sqrt((ch[x].first-ch[y].first)*(ch[x].first-ch[y].first)\n                           +(ch[x].second-ch[y].second)*(ch[x].second-ch[y].second));\n        allcost += cost;\n        edge[i] = {x, y, cost};\n       // cout << cost<<endl;\n    }\n    printf(\"%.3f\\n\", allcost - kruskal());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:102400000,102400000\")\n//#include <bits/stdc++.h>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <stdlib.h>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <fstream>\n#include <ctime>\n#include <stdexcept>\nusing namespace std;\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PII;\ntypedef pair<double,double> PDD;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 1e5+5;\nconst int mod = 1e9+7;\nconst double eps = 1e-8;\nconst double pi = asin(1.0)*2;\nconst double e = 2.718281828459;\nbool Finish_read;\ntemplate<class T>inline void read(T &x){Finish_read=0;x=0;int f=1;char ch=getchar();while(!isdigit(ch)){if(ch=='-')f=-1;if(ch==EOF)return;ch=getchar();}while(isdigit(ch))x=x*10+ch-'0',ch=getchar();x*=f;Finish_read=1;}\n\nstruct edge {\n\tdouble u;\n\tdouble v;\n\tdouble d;\n\tedge(double _u = 0, double _v = 0, double _d = 0): u(_u), v(_v), d(_d) {}\n\tbool operator < (const edge &a) const {\n\t\treturn d > a.d;\n\t}\n};\n\nint n, m;\nint tu, tv;\ndouble ans;\nPDD co[maxn];\nint pre[maxn];\nvector<edge> q;\n\nvoid init() {\n\tfor (int i = 1; i <= n; ++i) {\n\t\tpre[i] = i;\n\t}\n}\n\nint find(int x) {\n\tif (x == pre[x]) {\n\t\treturn pre[x];\n\t}\n\telse {\n\t\tpre[x] = find(pre[x]);\n\t\treturn pre[x];\n\t}\n}\n\ndouble caldis(PDD a, PDD b) {\n\treturn sqrt((a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second));\n}\n\nint main(int argc, char *argv[]) {\n//#ifndef ONLINE_JUDGE\n//\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\", \"w\", stdout);\n//#endif\n\tread(n); read(m);\n\tinit();\n\tfor (int i = 1; i <= n; ++i) {\n\t\tread(co[i].first);\n\t\tread(co[i].second);\n\t}\n\tfor (int i = 1; i <= m; ++i) {\n\t\tread(tu); read(tv);\n\t\tq.pb(edge(tu, tv, caldis(co[tu], co[tv])));\n\t}\n\tsort(q.begin(), q.end());\n\tans = 0;\n\tfor (int i = 0; i < int (q.size()); ++i) {\n\t\tint x = find(q[i].u), y = find(q[i].v);\n\t\tif (x != y) {\n\t\t\tpre[x] = y;\n\t\t}\n\t\telse {\n\t\t\tans += q[i].d;\n\t\t}\n\t}\n\tprintf(\"%.3lf\\n\", ans);\n//#ifndef ONLINE_JUDGE\n//\tfclose(stdin);\n//\tfclose(stdout);\n//\tsystem(\"gedit out.txt\");\n//#endif\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//created by sfailsthy 2016/11/27 13:21\n#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nconst int maxn =10000+10;\nint X[maxn];\nint Y[maxn];\nstruct edge{\n    int u,v;\n    double cost;\n};\nedge es[maxn*maxn];\n\nbool cmp(const edge& e1,const edge& e2){\n    return e1.cost>e2.cost;\n}\n\nint V,E;\n\nint par[maxn];\nint rank[maxn];\n\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        rank[i]=0;\n    }\n}\n\nint find(int x){\n    if(par[x]==x){\n        return x;\n    }\n    else{\n        return par[x]=find(par[x]);\n    }\n}\n\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n\n    if(x==y) return;\n\n    if(rank[x]<rank[y]){\n        par[x]=y;\n    }\n    else{\n        par[y]=x;\n        if(rank[x]==rank[y]){\n            rank[x]++;\n        }\n    }\n}\n\nbool same(int x,int y){\n    return find(x)==find(y);\n}\n\ndouble kruscal(){\n    sort(es,es+E,cmp);\n    init(V);\n\n    double res=0;\n    for(int i=0;i<E;i++){\n        edge e=es[i];\n        if(!same(e.u,e.v)){\n            unite(e.u,e.v);\n            res+=e.cost;\n        }\n    }\n\n    return res;\n}\n\nint main(){\n    //freopen(\"in.txt\",\"r\",stdin);\n    //freopen(\"out.txt\",\"w\",stdout);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin>>V>>E){\n        for(int i=0;i<V;i++){\n            cin>>X[i]>>Y[i];\n        }\n        double sum=0;\n        for(int i=0;i<E;i++){\n            int p,q;\n            cin>>p>>q;\n            p--;\n            q--;\n            int dx=X[p]-X[q];\n            int dy=Y[p]-Y[q];\n            double cost=sqrt(dx*dx+dy*dy);\n            sum+=cost;\n            es[i]=(edge){p,q,cost};\n        }\n\n        printf(\"%.3f\\n\", sum-kruscal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tvector<int> data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int x){\n\t\treturn data[x]<0?x:data[x]=Find(data[x]);\n\t}\n\tbool Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra==rb) return false;\n\t\tif(-data[ra]<-data[rb]) swap(ra,rb);\n\t\tdata[ra]+=data[rb],data[rb]=ra;\n\t\treturn true;\n\t}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m;){\n\t\tvector<int> x(n),y(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>x[i]>>y[i];\n\t\tvector<int> s(m),d(m);\n\t\tvector<double> w(m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>s[i]>>d[i]; s[i]--,d[i]--;\n\t\t\tw[i]=hypot(x[d[i]]-x[s[i]],y[d[i]]-y[s[i]]);\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<pair<double,pair<int,int>>> p(m);\n\t\t\tfor(int i=0;i<m;i++) p[i]=make_pair(w[i],make_pair(s[i],d[i]));\n\t\t\tsort(begin(p),end(p));\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tw[m-1-i]=p[i].first;\n\t\t\t\ts[m-1-i]=p[i].second.first;\n\t\t\t\td[m-1-i]=p[i].second.second;\n\t\t\t}\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tdouble res=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tif(!uf.Unite(s[i],d[i]))\n\t\t\t\tres+=w[i];\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\n#include <cmath>\nusing namespace std;\ntypedef pair<int,int> P;\n\nstruct fence{\n  int u,v;\n  double cost;\n};\n\n#define N 10000\n\n//2点間の距離を求める\ndouble distance(int x1,int y1,int x2,int y2){\n  return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\n//fenceはcostの大きさで降順ソートしたいので不等号はこの向き\nbool cmp(const fence &a,const fence &b){\n  return a.cost > b.cost;\n}\n\nint main(){\n  int n,m;\n  P piles[N];\n  vector<fence> fences;\n\n  scanf(\"%d%d\",&n,&m);\n  for(int i=0;i<n;i++){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    piles[i] = P(x,y);\n  }\n  for(int i=0;i<m;i++){\n    int p,q;\n    scanf(\"%d%d\",&p,&q);\n    p--;q--;\n    double c = distance(piles[p].first,piles[p].second,piles[q].first,piles[q].second);\n    fences.push_back((fence){p,q,c});\n  }\n\n  double sum = 0;\n  bool used[N];\n  fill(used,used+n,false);\n  sort(fences.begin(),fences.end(),cmp);\n  for(int i=0;i<m;i++){\n    int u = fences[i].u;\n    int v = fences[i].v;\n    if(used[u]&&used[v]){\n      sum += fences[i].cost;\n    }else{\n      used[u] = true; used[v] = true;\n    }\n  }\n\n  printf(\"%.3f\\n\",sum);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\n\nstruct point{\n    int first, second;\n    point(){first=second=0;}\n    point(int xx, int yy){ first=xx; second=yy;}\n};\nconst int MAX_N=10001;\n//pair<int, int> points[MAX_N];\nconst int MAX_M=MAX_N*(MAX_N-1)/2;\nedge edges[MAX_M];\npoint points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    int N, M; \n    cin>>N>>M;\n    point* points=new point[2*N];\n    edge* edges=new edge[M];\n        for(int i=1; i<=N; i++){\n            cin>>points[i].first>>points[i].second;\n        }\n        int p, q;\n        int x1, x2, y1, y2;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n        \tx1=points[p].first; x2=points[q].first;\n        \ty1=points[p].second; y2=points[q].second;\n            edges[i].w=sqrt((x1-x2)*(x1-x2)\n                          +(y1-y2)*(y1-y2));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    delete[] points;\n    delete[] edges;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\n\nusing namespace std;\n\nclass edge\n{\npublic:\n\tint source,target;\n\tdouble cost;\n\tedge(int insource=0,int intarget=0,double incost=0):\n\tsource(insource),target(intarget),cost(incost){}\n\tbool operator<(const edge &e)const{return cost>e.cost;}\n};\n\nclass disjointset\n{\npublic:\n\tvector<int> rank;\n\tvector<int> p;\n\t\n\tvoid makeset(int x)\n\t{\n\t\tp[x]=x;\n\t\trank[x]=0;\n\t\treturn;\n\t}\n\tdisjointset(int s)\n\t{\n\t\trank.resize(s);\n\t\tp.resize(s);\n\t\tfor(int i=0;i<s;i++)makeset(i);\n\t\treturn;\n\t}\n\tint findset(int x)\n\t{\n\t\tif(x!=p[x])p[x]=findset(p[x]);\n\t\treturn p[x];\n\t}\n\tvoid link(int x,int y)\n\t{\n\t\tif(rank[x]>rank[y])p[y]=x;\n\t\telse\n\t\t{\n\t\t\tp[x]=y;\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t}\n\t\treturn;\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn findset(x)==findset(y);\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tlink(findset(x),findset(y));\n\t\treturn;\n\t}\n};\n\nint n;\n\ndouble kruskal(vector<edge> e)\n{\n\tsort(e.begin(),e.end());\n\tdisjointset d=disjointset(n);\n\tedge ne;\n\tdouble allcost=0.0;\n\t\n\tfor(int i=0;i<e.size();i++)\n\t{\n\t\tne=e[i];\n\t\tif(!d.same(ne.source,ne.target))\n\t\t{\n\t\t\tallcost+=ne.cost;\n\t\t\td.unite(ne.source,ne.target);\n\t\t}\n\t}\n\t\n\treturn allcost;\n}\n\ndouble distance(double x1,double y1,double x2,double y2)\n{\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint main()\n{\n\tint m;cin>>n>>m;\n\tdouble px[10000],py[10000];\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>px[i]>>py[i];\n\t}\n\tvector<edge> e;\n\tdouble all=0.0,now;\n\tint a,b;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tnow=distance(px[a],py[a],px[b],py[b]);\n\t\te.push_back(edge(a,b,now));\n\t\te.push_back(edge(a,b,now));\n\t\tall+=now;\n\t}\n\t\n\tcout<<fixed<<setprecision(3)<<all-kruskal(e)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  double kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  printf(\"%.3lf\\n\", g.sum - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint* parent,*height;\n\nstruct Info{\n\tdouble x,y;\n};\n\nstruct Data{\n\tbool operator<(const struct Data &arg) const{\n\t\t\treturn cost > arg.cost;\n\t}\n\tdouble cost;\n\tint from,to;\n};\n\ndouble calc(Info left,Info right){\n\treturn sqrt((left.x-right.x)*(left.x-right.x)+(left.y-right.y)*(left.y-right.y));\n}\n\nint getParent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = getParent(parent[id]);\n\t}\n}\n\nbool isSame(int left,int right){\n\treturn getParent(left) == getParent(right);\n}\n\nvoid unite(int left,int right){\n\tint left_parent = getParent(left);\n\tint right_parent = getParent(right);\n\n\tif(left_parent == right_parent)return;\n\n\tif(height[left_parent] >= height[right_parent]){\n\t\tif(height[left_parent] == height[right_parent]){\n\t\t\theight[left_parent]++;\n\t\t}\n\t\tparent[right_parent] = left_parent;\n\t}else{\n\t\tparent[left_parent] = right_parent;\n\t}\n}\n\nint main(){\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\n\tInfo* info = (Info*)malloc(sizeof(Info)*(N));\n\tData* data = (Data*)malloc(sizeof(Data)*(M));\n\tparent = new int[N];\n\theight = new int[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&info[i].x,&info[i].y);\n\t}\n\n\tdouble sum = 0;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\",&data[i].from,&data[i].to);\n\t\tdata[i].from--;\n\t\tdata[i].to--;\n\t\tdata[i].cost = calc(info[data[i].from],info[data[i].to]);\n\t\tsum += data[i].cost;\n\t}\n\n\tsort(data,data+M);\n\n\tdouble used = 0;\n\n\tfor(int i = 0; i < M; i++){\n\t\tif(!isSame(data[i].from,data[i].to)){\n\t\t\tunite(data[i].from,data[i].to);\n\t\t\tused += data[i].cost;\n\t\t}\n\t}\n\n\tprintf(\"%.3lf\\n\",sum-used);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <math.h>\n#include <vector>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=10005;\nint n,m,p,q;\ndb x[N],y[N];\nstruct edge {\n    int x,y;\n    db val;\n    bool operator<(const edge& rhs) const {\n        return val<rhs.val;\n    }\n};\nint dsu[N];\n\nint fi(int x) {\n    return x==dsu[x]?x:(dsu[x]=fi(dsu[x]));\n}\n\ndb dis(int i,int j) {\n    db dx=x[i]-x[j];\n    db dy=y[i]-y[j];\n    return sqrt(dx*dx+dy*dy);\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for (int i=1;i<=n;i++) {\n        scanf(\"%lf%lf\",x+i,y+i);\n    }\n    vector<edge> vec;\n    for (int i=1;i<=m;i++) {\n        scanf(\"%d%d\",&p,&q);\n        vec.pb({p,q,-dis(p,q)});\n    }\n    sort(vec.begin(),vec.end());\n    for (int i=1;i<=n;i++) {\n        dsu[i]=i;\n    }\n    db ans=0;\n    for (auto e:vec) {\n        int r1=fi(e.x);\n        int r2=fi(e.y);\n        if (r1==r2) {\n            ans-=e.val;\n        } else {\n            dsu[r1]=r2;\n        }\n    }\n    printf(\"%.4lf\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstdio>\n#include<cmath>\n#include<map>\nusing namespace std;\n\nstruct Graph {\n\tint frm, to, w;\t\n};\nbool operator<(const Graph&g1, const Graph &g2) {return (g1.w<g2.w);}\n\nstruct node {\n\tint parent;\n\tint group;\n\tint x, y;\n\tnode() {}\n};\nnode N[10001];\nmap<int, int> M;\n\nint find(int v) {\n\tint ret;\n\tif(N[v].parent==-1) {\n\t\tN[v].parent = v;\n\t\treturn v;\n\t}\n\tif(v==N[v].parent) return v;\n\tret = find(N[v].parent);\n\tN[v].parent = ret;\n\treturn ret;\n}\n\nvoid union_node(int src, int dst) {\n\tN[find(src)].parent = find(dst);\n}\n\nvoid update(int n) {\n\tfor(int i=1; i<=n; ++i) {\n\t\tfind(i);\n\t}\n}\n\nbool check(int n) {\n\tM.clear();\n\tupdate(n);\n\tfor(int i=1; i<=n; ++i) {\n\t\tif(!M.count(N[i].group)) {\n\t\t\tM[N[i].group] = N[i].parent;\n\t\t}else {\n\t\t\tif(N[i].parent!=M[N[i].group]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n, m, xx, yy;\n\tdouble ans=0.0;\n\tpriority_queue<Graph> q;\n\tGraph g;\n\tcin >> n >> m;\n\tfor(int i=1; i<=n; ++i) {\n\t\tcin >> N[i].x >> N[i].y;\n\t\tN[i].parent = i;\n\t}\n\tfor(int i=0; i<m; ++i) {\n\t\tcin >> g.frm >> g.to;\n\t\txx = N[g.to].x-N[g.frm].x;\n\t\tyy = N[g.to].y-N[g.frm].y;\n\t\tg.w = xx*xx+yy*yy;\n\t\tq.push(g);\n\t\tunion_node(g.frm, g.to);\n\t}\n\tupdate(n);\n\tfor(int i=1; i<=n; ++i) {\n\t\tN[i].group = N[i].parent;\n\t\tN[i].parent = -1;\n\t}\n\twhile(!q.empty()) {\n\t\tg = q.top(); q.pop();\n\t\tif(find(g.frm)!=find(g.to)) union_node(g.frm, g.to);\n\t\telse ans += sqrt((double)g.w);\n\t\tif(check(n)) break;\n\t}\n\twhile(!q.empty()) {\n\t\tg = q.top(); q.pop();\n\t\tans += sqrt((double)g.w);\n\t}\n\tprintf(\"%lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass UnionFindTree{\nprivate:\n  int _size;\n  int* _parent;\n  int* _rank;\npublic:\n  UnionFindTree(int n){\n    _size = n;\n    _parent = new int[_size]();\n    _rank = new int[_size]();\n    for(int i = 0; i < _size; i++){\n      _parent[i] = i;\n      _rank[i] = 0;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] _parent;\n    delete[] _rank;\n  }\n\n  int find(int child){\n    int next = _parent[child];\n    if(next == child) return child;\n    else return find(next);\n  }\n\n  bool same(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    return (lhs == rhs);\n  }\n  \n  bool unite(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(same(lhs,rhs)) return false;\n    \n    if(_rank[lhs] < _rank[rhs]){\n      _parent[rhs] = lhs;\n      _rank[lhs] += _rank[rhs];\n    }\n    else {\n      _parent[lhs] = rhs;\n      _rank[rhs] += _rank[lhs];\n    }\n    return true;\n  }\n\n};\n\nclass State {\npublic:\n  int _from,_to;\n  double _distance;\n  State(int from,int to,double distance)\n    : _from(from),_to(to),_distance(distance) {}\n  bool operator<(const State& s) const {\n    return _distance < s._distance;\n  }\n  bool operator>(const State& s) const {\n    return _distance > s._distance;\n  }\n};\n\nint main(){\n  int num_of_magical_piles;\n  int num_of_magical_fences;\n  while(~scanf(\"%d %d\",\n               &num_of_magical_piles,\n               &num_of_magical_fences)){\n    \n    vector<P> piles;\n    for(int pile_i = 0; pile_i < num_of_magical_piles; pile_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      piles.push_back(P(x,y));\n    }\n\n    double sum = 0;\n    priority_queue<State,vector<State>,less<State> > que;\n\n    for(int fence_i = 0; fence_i < num_of_magical_fences; fence_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      from--; to--;\n      int from_x = piles[from].first;\n      int from_y = piles[from].second;\n\n      int to_x = piles[to].first;\n      int to_y = piles[to].second;\n\n      double distance = sqrt((double)((from_x - to_x) * (from_x - to_x)\n                                      + (from_y - to_y) * (from_y - to_y)));\n      sum += distance;\n      que.push(State(from,to,distance));\n    }\n\n    UnionFindTree uft(num_of_magical_piles);\n    double after_ruined = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(uft.same(s._from ,s._to)){\n        continue;\n      }\n      uft.unite(s._from,s._to);\n      after_ruined += s._distance;\n    }\n    printf(\"%lf\\n\",sum - after_ruined);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <queue>\nusing namespace std;\ndouble s;\nint n,m,set[11000];\nstruct point\n{\n    double x,y;\n}p[11000];\nstruct edge\n{\n    int x,y;\n    double w;\n}e[510000];\nbool cmp(const struct edge &a,const struct edge &b){return b.w<a.w;}\ndouble dis(point&a,point&b)\n{\n    return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nint findset(int x)\n{\n    if(x!=set[x]) set[x]=findset(set[x]);\n    return set[x];\n}\nvoid unionset(int x,int y)\n{\n    int fx=findset(x),fy=findset(y);\n    if(fx!=fy) set[fx]=fy;\n}\nvoid Krusal()\n{\n    for(int i=0;i<=n;i++) set[i]=i;\n    sort(e,e+m,cmp);\n    for(int i=0;i<m;i++)\n    {\n        int a=findset(e[i].x),b=findset(e[i].y);\n        if(a==b) continue;\n        s-=e[i].w;\n        unionset(a,b);\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++) scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n    s=0.0;\n    for(int i=0;i<m;i++)\n    {\n        int u,v;\n        scanf(\"%d%d\",&u,&v);\n        u--;v--;\n        e[i].x=u;e[i].y=v;\n        e[i].w=dis(p[u],p[v]);\n        s+=e[i].w;\n    }\n    Krusal();\n    printf(\"%.3lf\",s);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define LATTE 1000000000\n\nstruct Way{\n\tint p,q,cost;\n\tWay(){}\n\tWay(int _p,int _q,int _cost){\n\t\tp=_p; q=_q; cost=_cost;\n\t}\n\tbool operator<(const Way &a){\n\t\treturn cost>a.cost;\n\t}\n};\n\nstruct Node{\n\tint x,y;\n};\n\nint par[10000],_rank[10000];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++) par[i]=i,_rank[i]=1;\n}\n\nint find(int a){\n\tif(par[a]==a) return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int _a,int _b){\n\tint a = find(_a);\n\tint b = find(_b);\n\tif(a==b) return;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = a;\n\t}\n\telse{\n\t\tpar[a] = b;\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n}\n\nint main(){\n\tint N,M;\n\tNode node[10000];\n\tWay way[10000];\n\tcin>>N>>M;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>node[i].x>>node[i].y;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin>>way[i].p>>way[i].q;\n\t\ta = node[--way[i].p].x-node[--way[i].q].x;\n\t\tb = node[way[i].p].y-node[way[i].q].y;\n\t\tway[i].cost = a*a+b*b;\n\t\t//printf(\"\\t%d\\n\",way[i].cost);\n\t}\n\n\tdouble ans=0;\n\tsort(way,way+M);\n\tinit(N);\n\tfor(int i=0;i<M;i++){\n\t\tint a = find(way[i].p),\n\t\t\tb = find(way[i].q);\n\t\tif(a!=b) unite(a,b);\n\t\telse ans += sqrt(way[i].cost);\n\t}\n\tprintf(\"%lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint n,m,xx[10005],yy[10005],ff[10005];\ndouble ans;\nstruct pt\n{\n\tint a,b;\n\tdouble ds;\t\n}c;\nbool cmp(pt r,pt s)\n{\n\treturn r.ds>s.ds;\n}\nint ft(int x)\n{\n\tif(ff[x]==x) return x;\n\treturn ff[x]=ft(ff[x]);\n}\nvector<pt>p;\nint main()\n{\n\tint i;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++) { scanf(\"%d%d\",&xx[i],&yy[i]);ff[i]=i;}\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&c.a,&c.b);\n\t\tc.ds=sqrt((xx[c.a]-xx[c.b])*(xx[c.a]-xx[c.b])+(yy[c.a]-yy[c.b])*(yy[c.a]-yy[c.b])+0.0);\n\t\tp.push_back(c);\n\t}\n\tsort(p.begin(),p.end(),cmp);\n\tfor(i=0;i<m;i++)\n\t\tif(ft(p[i].a)!=ft(p[i].b)) ff[ft(p[i].b)]=ft(p[i].a);\n\t\telse ans+=p[i].ds;\n\tprintf(\"%.3f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2224 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224)\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define all(a) (a).begin(), (a).end()\n\nstruct edge\n{\n\tint from, to;\n\tdouble cost;\n\n\tedge( int from, int to, double cost )\n\t:\tfrom(from), to(to), cost(cost)\n\t{}\n\n\tbool operator< ( const edge &e ) const\n\t{ return cost < e.cost; }\n};\n\nstruct UnionFind\n{\n\tstd::vector<int> par, rank;\n\n\tUnionFind( std::size_t sz )\n\t:\tpar(sz), rank(sz)\n\t{\n\t\trep( i, sz )\n\t\t\tpar[i] = i;\n\t}\n\n\tint find( int x )\n\t{ return x==par[x]?x:par[x]=find(par[x]); }\n\n\tvoid unite( int x, int y )\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif( x == y )\n\t\t\treturn;\n\n\t\tif( rank[x] < rank[y] )\n\t\t\tpar[x] = y;\n\t\telse\n\t\t{\n\t\t\tpar[y] = x;\n\n\t\t\tif( rank[x] == rank[y] )\n\t\t\t\t++rank[x];\n\t\t}\n\n\t\treturn;\n\t}\n\n\tbool same( int x, int y )\n\t{ return find(x)==find(y); }\n};\n\nconst int MAX_N = 10000;\n\nint N, M;\nint x[MAX_N], y[MAX_N];\nstd::vector<edge> es;\ndouble ans;\n\nint main()\n{\n\tscanf( \"%d%d\", &N, &M );\n\trep( i, N )\n\t\tscanf( \"%d%d\", x+i, y+i );\n\trep( i, M )\n\t{\n\t\tint p, q;\n\t\tscanf( \"%d%d\", &p, &q );\n\t\t--p; --q;\n\t\t\n\t\tdouble c = sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n\t\tes.push_back( edge( p, q, -c ) );\n\t\tans += c;\n\t}\n\n\tstd::sort( all(es) );\n\n\tUnionFind uf( N );\n\trep( i, M ) if( !uf.same( es[i].from, es[i].to ) )\n\t{\n\t\tans += es[i].cost;\n\t\tuf.unite( es[i].from, es[i].to );\n\t}\n\n\tprintf( \"%.3f\\n\", ans );\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n\nusing namespace std;\n\nint parent[10005];\n\nvoid init()\n{\n\tfor(int i = 0; i < 10005; i++) parent[i] = i;\n}\n\nint root(int n)\n{\n\tif(parent[n] == n) return n;\n\telse return parent[n] = root( parent[n] );\n}\n\nbool same(int a, int b)\n{\n\treturn root(a) == root(b);\n}\n\nvoid unite(int a, int b)\n{\n\tint root_a = root(a);\n\tint root_b = root(b);\n\tparent[root_a] = root_b;\n}\n\nstruct edge{\n\tint s;\n\tint e;\n\tdouble cost;\n\tedge(int s, int e, double cost){\n\t\tthis->s = s, this->e = e, this->cost = cost;\n\t}\n\tbool operator<(const edge &obj){\n\t\treturn this->cost < obj.cost;\n\t}\n};\n\nint N, M;\nlong long posX[10005], posY[10005];\nvector<edge> G;\n\nint main(void)\n{\n\tcin >> N >> M;\n\tfor(int i = 1; i <= N; i++){\n\t\tcin >> posX[i] >> posY[i];\n\t}\n\tint s, e;\n\tdouble dist, sum = 0;\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> s >> e;\n\t\tdist = (posX[s] - posX[e]) * (posX[s] - posX[e]) + (posY[s] - posY[e]) * (posY[s] - posY[e]);\n\t\tdist = sqrt(dist);\n\t\tsum += dist;\n\t\tG.push_back( edge(s, e, dist) );\n\t}\n\t\n\tsort(G.begin(), G.end());\n\treverse(G.begin(), G.end());\n\t\n\tinit();\n\t\n\tfor(int i = 0; i < M; i++){\n\t\tif(!same(G[i].s, G[i].e)){\n\t\t\tsum -= G[i].cost;\n\t\t\tunite(G[i].s, G[i].e);\n\t\t}\n\t}\n\t\n\tprintf(\"%.8f\\n\", sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nstruct edge{\n  int from,to;\n  double cost;\n};\nbool operator<(const edge& a,const edge& b){ return a.cost > b.cost; }\n\nstruct UnionFind{ // tuyoi\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool same(int x,int y){ return find(x)==find(y); }\n};\n\nint n,m;\ndouble x[11111],y[11111];\nedge es[111111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>n>>m;\n  rep(i,n){\n    cin>>x[i]>>y[i];\n  }\n  double sum=0;\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--; b--;\n    es[i]=(edge){a,b,sqrt(pow(x[a]-x[b],2)+pow(y[a]-y[b],2))};\n    sum+=es[i].cost;\n  }\n  sort(es,es+m);\n  UnionFind uf(n);\n  double mst=0;\n  rep(i,m){\n    if(!uf.same(es[i].from,es[i].to)){\n      uf.unite(es[i].from,es[i].to); mst+=es[i].cost;\n    }\n  }\n  printf(\"%.10f\\n\", sum-mst);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint N,M;\nint pre[10010];\nstruct node1{\n\tdouble x,y;\n}point[10010]; \nstruct node2{\n\tint u,v;\n\tdouble cost;\n}rode[100010];\nbool cmp(node2 x,node2 y){\n\treturn x.cost>y.cost;\n}\ndouble dis(int x,int y){\n   double sum;\n   sum=sqrt((point[x].x-point[y].x)*(point[x].x-point[y].x)+(point[y].y-point[x].y)*(point[y].y-point[x].y));\n   return sum;\n}\nvoid init(){\n\tfor(int i=0;i<10010;i++){\n\t\tpre[i]=i;\n\t}\n}\nint  find(int x){\n\tif(pre[x]==x)\n\t  return x;\n\treturn pre[x]=find(pre[x]);\n}\nvoid mar(int x,int y){\n\tint xx=find(x);\n\tint yy=find(y);\n\tif(xx!=yy);\n\tpre[xx]=yy;\n}\ndouble kruskra(){\n\tdouble ans=0;\n\tint num=0;\n\tsort(rode,rode+M,cmp);\n\tfor(int i=0;i<M;i++){\n\t\tif(find(rode[i].v)!=find(rode[i].u)){\n\t\t\tmar(rode[i].u,rode[i].v);\n\t\t\tans=ans+rode[i].cost;\n\t\t\tnum++;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(cin>>N>>M){\n\tdouble sum1=0,sum2=0;\n\t   for(int i=1;i<=N;i++){\n\t\t  cin>>point[i].x>>point[i].y;\n\t   }\n\t    for(int i=0;i<M;i++){\n\t\t  cin>>rode[i].u>>rode[i].v;\n\t\t  rode[i].cost=dis(rode[i].u,rode[i].v);\n\t\t  sum1=rode[i].cost+sum1;\n\t   }\n\t   init();\n\t   sum2=kruskra();\n\t   printf(\"%.3lf\\n\",sum1-sum2);\n   }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  xzppp  */\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\n#include <cmath>\n#include <set>\n#include <iomanip>\nusing namespace std;\n#define FFF freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define MP make_pair\n#define PB push_back\ntypedef long long  LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int > pii;\ntypedef pair<double,double > pdd;\ntypedef pair<double,int > pdi;\nconst int MAXN = 1e4+17;\nconst int MAXM = 20;\nconst int MAXV = 1e4+17;\nconst int INF = 0x7fffffff;\nconst int MOD = 1e9+7;\npdd all[MAXV];\nvector<pdi > G[MAXV];\ndouble s;\nbool vis1[MAXV];\nvoid dfs(int x)\n{\n\tvis1[x]=1;\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\ts+=G[x][i].first;\n\t\t}\n\t}\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\tdfs(G[x][i].second);\n\t\t}\n\t}\n}\nbool vis[MAXV];\ndouble minc[MAXV];\ndouble prim(int x)\n{\n    for (int i = 0; i < MAXV; ++i)\n    {\n        minc[i] = 0;\n        vis[i] = 0;\n    }\n    double res = 0;\n    priority_queue<pdi> q;\n    q.push(MP(0,x));\n    while(!q.empty())\n    {\n        int v = q.top().second;\n        double temp = q.top().first;\n        q.pop();\n        if(vis[v]) continue;\n       // cout<<\"???\"<<v<<endl;\n        vis[v] = 1;\n        res += temp;\n        for (int i = 0; i < G[v].size(); ++i)\n        {\n            double d = G[v][i].first;\n            int to = G[v][i].second;\n            if(!vis[to]&&minc[to]<d)\n            {\n                q.push(MP(d,to));\n                minc[to] = d;\n            }\n        }\n    }\n    return  res;\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE \n    FFF\n    #endif\n    int n,m;\n    cin>>n>>m;\n    for (int i = 0; i < n; ++i)\n    {\n    \tdouble x,y;\n    \tscanf(\"%lf%lf\",&x,&y);\n    \tall[i].first = x;\n    \tall[i].second = y;\n    }\n    for (int i = 0; i < m; ++i)\n    {\n    \tint u,v;\n    \tscanf(\"%d%d\",&u,&v);\n    \tu--;v--;\n    \tdouble dis = sqrt((all[u].first-all[v].first)*(all[u].first-all[v].first)\n    \t\t+(all[u].second-all[v].second)*(all[u].second-all[v].second));\n    \tG[u].push_back(MP(dis,v));\n    \tG[v].push_back(MP(dis,u));\n    }\n    double ans = 0;\n    for (int i = 0; i < n; ++i)\n    {\n    \tif(!vis1[i])\n    \t{\n    \t\t//cout<<i<<endl;\n    \t\ts = 0;\n    \t\tdfs(i);\n    \t\t//cout<<s<<endl;\n    \t\tdouble left = prim(i);\n    \t\tans += s-left;\n    \t\t//cout<<\" ans\"<<s-left<<endl;\n    \t}\n    }\n    cout<<fixed<<setprecision(4)<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint N,M;\nint pre[10010];\nstruct node1{\n\tdouble x,y;\n}point[10010]; \nstruct node2{\n\tint u,v;\n\tdouble cost;\n}rode[100010];\nbool cmp(node2 x,node2 y){\n\treturn x.cost>y.cost;\n}\ndouble dis(int x,int y){\n   double sum;\n   sum=sqrt((point[x].x-point[y].x)*(point[x].x-point[y].x)+(point[y].y-point[x].y)*(point[y].y-point[x].y));\n   return sum;\n}\nvoid init(){\n\tfor(int i=0;i<=10010;i++){\n\t\tpre[i]=i;\n\t}\n}\nint  find(int x){\n\tif(pre[x]==x)\n\t  return x;\n\treturn pre[x]=find(pre[x]);\n}\nvoid mar(int x,int y){\n\tint xx=find(x);\n\tint yy=find(y);\n\tif(xx!=yy);\n\tpre[xx]=yy;\n}\ndouble kruskra(){\n\tdouble ans=0;\n\tint num=0;\n\tsort(rode,rode+M,cmp);\n\tfor(int i=0;i<M;i++){\n\t\tif(find(rode[i].v)!=find(rode[i].u)){\n\t\t\tmar(rode[i].u,rode[i].v);\n\t\t\tans=ans+rode[i].cost;\n\t\t\tnum++;\n\t\t}\n\t\tif(num==N-1) break;\n\t}\n\treturn ans;\n}\nint main(){\n\twhile(cin>>N>>M&&N&&M){\n\tdouble sum1=0,sum2=0;\n\t   for(int i=1;i<=N;i++){\n\t\t  cin>>point[i].x>>point[i].y;\n\t   }\n\t    for(int i=0;i<M;i++){\n\t\t  cin>>rode[i].u>>rode[i].v;\n\t\t  rode[i].cost=dis(rode[i].u,rode[i].v);\n\t\t  sum1=rode[i].cost+sum1;\n\t   }\n\t   init();\n\t   sum2=kruskra();\n\t   printf(\"%.3lf\\n\",sum1-sum2);\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tint size_; vector<int> g; vector<vector<int> > v;\npublic:\n\tUnionFind() : size_(0), g(vector<int>()), v(vector<vector<int> >()) {};\n\tUnionFind(int size__) : size_(size__) { g.resize(size_), v.resize(size_); for (int i = 0; i < size_; i++) g[i] = i, v[i] = { i }; };\n\tint size() { return size_; }\n\tint root(int x) { return g[x]; }\n\tint size(int x) { return v[x].size(); }\n\tbool same(int x, int y) { return g[x] == g[y]; }\n\tvoid unite(int x, int y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const UnionFind& u) { return g == u.g; }\n\tbool operator!=(const UnionFind& u) { return g != u.g; }\n\tint operator[](int x) { return g[x]; }\n};\nstruct edge { int s, to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint V, E, x[10009], y[10009], s, t; edge e[99999];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int i = 0; i < V; i++) scanf(\"%d%d\", x + i, y + i);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tint dist = (x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]);\n\t\te[i] = edge{ s, t, dist };\n\t}\n\tsort(e, e + E);\n\treverse(e, e + E);\n\tUnionFind u(V);\n\tdouble ret = 0;\n\tfor (auto &v: e) {\n\t\tif (u.same(v.s, v.to)) ret += sqrt(v.cost);\n\t\telse u.unite(v.s, v.to);\n\t}\n\tprintf(\"%.9f\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N + 1], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N + 1; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N + 1; j++)\n\tif(forest[t1][j] == 0)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse return pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n\nusing namespace std;\n\nconst int INF = (1<<25);\nconst int MAX = 10001;\nint N,M;\ndouble ans;\n\nstruct Pile{\n  int x,y;\n  Pile(){}\n  Pile(int x,int y):x(x),y(y){}\n};\n\nstruct State{\n  int pos;\n  double t;\n  State(){}\n  State(int pos, double t):pos(pos),t(t){}\n  bool operator < (const State& s) const { return t < s.t;}\n};\n\nvector<int> Edge[MAX];\nvector<Pile> P;\ndouble T[MAX];\nbool used[MAX];\n\nvoid init(){\n  fill(T,T+MAX,-1);\n  memset(used,false,sizeof(used));\n\n  for(int i = 0; i < MAX; i++) Edge[i].clear();\n  P.clear();\n  ans = 0;\n}\n\ndouble getDis(int p, int q){\n  return sqrt((P[p].x-P[q].x)*(P[p].x-P[q].x)+(P[p].y-P[q].y)*(P[p].y-P[q].y));\n}\n\nvoid input(){\n  for(int i = 0; i < N; i++){\n    Pile in;\n    // cin >> in.x >> in.y;\n    scanf(\"%d %d\",&in.x, &in.y);\n    P.push_back(in);\n  }\n\n  for(int i = 0; i < M; i++){\n    int p,q;\n    //  cin >> p >> q;\n    scanf(\"%d %d\",&p,&q);\n    p--;\n    q--;\n    Edge[p].push_back(q);\n    Edge[q].push_back(p);\n    ans += getDis(p,q);\n  }\n}\n\n\nvoid prim(int start){\n  priority_queue<State> Q;\n  Q.push(State(start,0));\n  T[start] = 0;\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n     \n    if(used[now.pos]) continue;\n    used[now.pos] = true;\n\n    ans -= now.t;\n\n\n    for(int i = 0; i < (int)Edge[now.pos].size(); i++){\n      int nex = Edge[now.pos][i];\n      double cos = getDis(now.pos,nex);\n      if(T[nex] < cos){\n\tT[nex] = cos;\n\tQ.push(State(nex,cos));\n      }\n    }\n  }\n}\n\nvoid solve(){\n\n  for(int i = 0; i < N; i++){\n    if(!used[i]) prim(i);\n  }\n\n  printf(\"%.3f\\n\",ans);\n}\n\nint main(){\n  \n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<functional>\n#include<iomanip>\n#define MP(a,b) make_pair((a),(b))\nusing namespace std;\n\ntypedef pair<int, int> XY;\ntypedef pair<int, int> Piles;\n\nclass Node\n{\npublic:\n\tNode* getRoot()\n\t{\n\t\tif (parent != this)\n\t\t{\n\t\t\treturn parent->getRoot();\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this;\n\t\t}\n\t}\n\tNode* parent = this;\n\tbool isDone = false;\n\tXY p;\n};\n\ntypedef pair<double, Piles> Edge;\npriority_queue<Edge> q1, q2;\nNode node[10001];\n\nint main()\n{\n\tdouble sumA = 0.0;\n\tdouble sumB = 0.0;\n\tint N, M;\n\tcin >> N >> M;\n\tfor (unsigned int i = 1; i <= N; i++)\n\t{\n\t\tint t1, t2;\n\t\tcin >> t1 >> t2;\n\t\tnode[i].p = MP(t1, t2);\n\t}\n\tfor (unsigned int i = 1; i <= M; i++)\n\t{\n\t\tint t1, t2;\n\t\tcin >> t1 >> t2;\n\t\tint a = node[t1].p.first - node[t2].p.first;\n\t\tint b = node[t1].p.second - node[t2].p.second;\n\t\tq1.push(MP(sqrt(a*a+ b*b), MP(t1, t2)));\n\t}\n\n\twhile (q1.empty() == false)\n\t{\n\t\tint l = q1.top().second.first;\n\t\tint r = q1.top().second.second;\n\t\tif (node[l].isDone == false && node[r].isDone==false)\n\t\t{\n\t\t\tnode[l].parent = &node[l];\n\t\t\tnode[r].parent = &node[l];\n\t\t\tnode[l].isDone = true;\n\t\t\tnode[r].isDone = true;\n\t\t\tsumB += q1.top().first;\n\t\t}\n\t\telse if (node[l].isDone == false && node[r].isDone==true)\n\t\t{\n\t\t\tnode[l].parent = &node[r];\n\t\t\tnode[l].isDone = true;\n\t\t\tsumB += q1.top().first;\n\t\t}\n\t\telse if (node[l].isDone == true && node[r].isDone==false)\n\t\t{\n\t\t\tnode[r].parent = &node[l];\n\t\t\tnode[r].isDone = true;\n\t\t\tsumB += q1.top().first;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tq2.push(MP(q1.top().first, MP(l, r)));\n\t\t}\n\t\tsumA += q1.top().first;\n\t\tq1.pop();\n\t}\n\twhile (q2.empty() == false)\n\t{\n\t\tEdge top = q2.top();\n\t\tint l = top.second.first;\n\t\tint r = top.second.second;\n\t\tif (node[l].getRoot() == node[l].getRoot())\n\t\t{\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsumB += top.first;\n\t\t\tnode[r].getRoot()->parent = &node[l];\n\t\t}\n\t\tq2.pop();\n\t}\n\tcout << fixed << setprecision(8) << sumA - sumB << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n \n// ??¶??\\???????????°????????????\n#define MAX_N 10000 + 16\nint parent[MAX_N];\nint height[MAX_N];\n \nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n// End Of ??¶??\\???\n \n#define MAX_E MAX_N * MAX_N / 2 + 1\nstruct edge\n{\n\tint u, v;\n\tdouble cost;\n\tedge(int u = 0, int v = 0, double cost = 0) : u(u), v(v), cost(cost) {}\n\tbool operator < (const edge & e2) const\n\t{\n\t\treturn cost > e2.cost;\n\t}\n};\n \nedge es[MAX_E];\nint V, E;\ndouble kruskal()\n{\n\tsort(es, es + E);    // ?????§??????????°???°??§??????\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n \npair<int, int> pile[MAX_N];\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n\tcin >> V >> E;\n\t\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tcin >> pile[i].first >> pile[i].second;\n\t}\n \n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t}\n \n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout << kruskal() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\n//double???2?¬????????????????\nstruct vec{\n    long double x,y;\n    vec(double x, double y): x(x), y(y){};\n    //eps??????????????´???????????¨\n    inline double add(double a, double b){\n        return abs(a+b)<(1e-10)*(abs(a)+abs(b)) ? 0.0 : a+b;\n    }\n    vec operator-(vec b){\n        return vec(add(x,-b.x),add(y,-b.y));\n    }\n    vec operator+(vec b){\n        return vec(add(x,b.x),add(y,b.y));\n    }\n    vec operator*(long double d){\n        return vec(x*d,y*d);\n    }\n    bool operator==(vec b){\n        return x==b.x&&y==b.y;\n    }\n    bool operator!=(vec b){\n        return x!=b.x||y!=b.y;\n    }\n    bool operator<(const vec&r) const{\n    return this->x==r.x?this->y<r.y:this->x<r.x;\n    }\n    long double dot(vec v){//??????\n        return add(x*v.x,y*v.y);\n    }\n    long double cross(vec v){//??????\n        return add(x*v.y,-y*v.x);\n    }\n    long double norm(){//?????????\n        return hypot(x,y);\n    }\n};\n\nstruct union_find{\n    vector<int> par, rank;\n    union_find(int n){\n        par = vector<int>(n);\n        rank = vector<int>(n);\n        init(n);\n    }\n    void init(int n){\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x){\n        if(par[x]==x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\ntypedef tuple<double,int,int> T;\n\nint main(){\n    int N,M;\n    cin>>N>>M;\n    vector<vec> V;\n    vector<T> E;\n    union_find U(N);\n\n    for(int i=0;i<N;i++){\n        int x,y;\n        cin>>x>>y;\n        V.emplace_back(x,y);\n    }\n    double ans = 0;\n    for(int i=0;i<M;i++){\n        int p,q;\n        cin>>p>>q;\n        p--; q--;\n        double l = (V[p]-V[q]).norm();\n        ans+=l;\n        E.emplace_back(l,p,q);\n    }\n    sort(E.begin(),E.end(),greater<T>());\n    for(auto e:E){\n        int p,q;\n        double l;\n        tie(l,p,q)=e;\n        if(!U.same(p,q)){\n            ans-=l;\n            U.unite(p,q);\n        }\n    }\n    cout<<fixed;\n    cout.precision(3);\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <complex>\n#include <cmath>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\nstruct edge{\n\tint u,v;\n\tD dist;\n};\nbool comp(const edge &l,const edge &r){\n\treturn l.dist>r.dist;\n}\nvector<edge> es;\nint N,M;\nP p[10000];\nint par[10000];\nvoid init(int n){rep(i,n) par[i]=i;}\nint find(int x){\n\tif(x==par[x]) return x;\n\treturn par[x]=find(par[x]);\n}\nbool same(int x,int y){return find(x)==find(y);}\nvoid unite(int x,int y){\n\tx=find(x),y=find(y);\n\tpar[x]=y;\n}\nint main(){\n\tcin>>N>>M;\n\trep(i,N){\n\t\tD x,y;\n\t\tcin>>x>>y;\n\t\tp[i]=P(x,y);\n\t}\n\trep(i,M){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tes.pb({a,b,abs(p[a]-p[b])});\n\t}\n\tsort(all(es),comp);\n\tinit(N);\n\tD ans=0;\n\tfor(edge e:es){\n\t\tif(same(e.u,e.v)) ans+=e.dist;\n\t\telse unite(e.u,e.v);\n\t}\n\tprintf(\"%.12f\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\ntypedef pair<double, int>DI;\nint N, M;\nint X[10010], Y[10010], F[10010];\nvector<int>vec[10010];\ndouble ans = 0.0;\nint main(){\n    cin>>N>>M;\n    for(int i=1;i<=N;i++){\n        cin>>X[i]>>Y[i];\n    }\n    for(int i=0;i<M;i++){\n        int p, q;\n        cin>>p>>q;\n        vec[p].push_back(q);\n        vec[q].push_back(p);\n        ans += hypot(X[p]-X[q], Y[p]-Y[q]);\n    }\n    for(int i=1;i<=N;i++){\n        if(F[i])continue;\n        priority_queue<DI>Q;\n        F[i] = 1;\n        for(int j=0;j<vec[i].size();j++){\n            Q.push(DI(hypot(X[i]-X[vec[i][j]], Y[i]-Y[vec[i][j]]), vec[i][j]));\n        }\n        while(!Q.empty()){\n            double cost = Q.top().first;\n            int id = Q.top().second;\n            Q.pop();\n            if(F[id])continue;\n            F[id] = 1;\n            ans -= cost;\n            for(int j=0;j<vec[id].size();j++){\n                if(F[vec[id][j]])continue;\n                Q.push(DI(hypot(X[id]-X[vec[id][j]], Y[id]-Y[vec[id][j]]), vec[id][j]));\n            }\n        }\n    }\n    printf(\"%.9f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#define N 10100\n#define inf\n#define mod\n#define rg register\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nint n,m,fa[N],x[N],y[N];\ndb tot=0,ans=0;\nstruct data{\n\tint x,y;\n\tdb z;\n}q[N*10];\nbool cmp(data a,data b){ return a.z>b.z; }\nint find(int k){ return fa[k]==k?fa[k]:fa[k]=find(fa[k]); }\ndb get_dis(int a,int b){ return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b])); }\nint main(){\n//\tfreopen (\"2224.in\",\"r\",stdin);\n//\tfreopen (\"2224.out\",\"w\",stdout);\n\tscanf (\"%d%d\",&n,&m);\n\tfor (int i=1;i<=n;++i) scanf (\"%d%d\",&x[i],&y[i]),fa[i]=i;\n\tfor (int i=1;i<=m;++i){\n\t\tscanf (\"%d%d\",&q[i].x,&q[i].y);\n\t\tq[i].z=get_dis(q[i].x,q[i].y);tot+=q[i].z;\n\t}\n\tsort(q+1,q+m+1,cmp);\n\tint cnt=0;\n\tfor (int i=1;i<=m;++i){\n\t\tint f1=find(q[i].x),f2=find(q[i].y);\n\t\tif (f1==f2) continue;\n\t\tfa[f1]=f2;\n\t\tcnt++;ans+=q[i].z;\n\t\tif (cnt==n-1) break;\n\t}\n\tprintf (\"%.3lf\\n\",tot-ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct node\n{\n    int x,y,id;\n};\nstruct edge\n{\n    int u,v;\n    double cost;\n    edge() {}\n    edge(int x,int y,double z)\n    {\n        u=x;\n        v=y;\n        cost=z;\n    }\n    bool operator <(const edge& a) const\n    {\n        return cost>a.cost;\n    }\n};\n\nedge es[50010];\nint par[10010];\nnode p[10010];\nint n,m;\nvoid init()\n{\n    for(int i=1;i<=n;i++) par[i]=i;\n}\n\nint find(int x)\n{\n    return x==par[x]?x:par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y) par[x]=y;\n}\n\ndouble dis(int a,int b)\n{\n    return sqrt(1.0*(p[a].x-p[b].x)*(p[a].x-p[b].x)+1.0*(p[a].y-p[b].y)*(p[a].y-p[b].y));\n}\n\ndouble kruskal()\n{\n    sort(es,es+m);\n    //for(int i=0;i<m;i++) printf(\"%d %d %lf\\n\",es[i].u,es[i].v,es[i].cost);\n    double s=0;\n    for(int i=0;i<m;i++)\n    {\n        edge e=es[i];\n        if(find(e.u)!=find(e.v))\n        {\n            unite(e.u,e.v);\n        }\n        else\n        {\n            s+=e.cost;\n        }\n    }\n    return s;\n}\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    int a,b;\n    double c,sum;\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        sum=0;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            c=dis(a,b);\n            es[i]=edge(a,b,c);\n        }\n        printf(\"%.3lf\\n\",kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<cmath>\n\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent;\n    vector<int> myrank;\n    //親は小さい\n    UnionFind(int n) : parent(n,-1), myrank(n,0) { }\n    bool Find(int x, int y){\n        return find_root(x) == find_root(y); \n    }\n    int find_root(int x){\n        if(parent[x] < 0){\n            return x;\n        }else{\n            return parent[x] = find_root(parent[x]);\n        }\n    }\n    bool Union(int x, int y){\n        x = find_root(x); y = find_root(y);\n\n        if(x != y){\n            if(myrank[y] < myrank[x]){\n                swap(x,y);\n            }\n            parent[x] += parent[y]; parent[y] = x;\n            if(myrank[x] == myrank[y]) myrank[x]++;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    int size(int x){\n        return -parent[find_root(x)];\n    }\n};\n\nstruct UEdge {\n    int a, b;\n    double len=1.0;\n    \n    UEdge(int a, int b, double len) : a(a), b(b), len(len) {}\n\n    bool operator <(const UEdge &rhs) const{\n        if (len != rhs.len) return len < rhs.len;\n        if (a != rhs.a) {return a < rhs.a;}\n        return b < rhs.b;\n    }\n    bool operator >(const UEdge &rhs) const{\n        if (len != rhs.len) return len > rhs.len;\n        if (a != rhs.a) {return a > rhs.a;}\n        return b > rhs.b;\n    }\n    bool operator <=(const UEdge &rhs) const{\n        if (len != rhs.len) return len < rhs.len;\n        if (a != rhs.a) {return a < rhs.a;}\n        return b <= rhs.b;\n    }\n    bool operator >=(const UEdge &rhs) const{\n        if (len != rhs.len) return len > rhs.len;\n        if (a != rhs.a) {return a > rhs.a;}\n        return b >= rhs.b;\n    }\n};\n\nstruct Point {\n    double a, b;\n\n    Point(double a, double b) : a(a), b(b) {}\n\n};\ndouble dist(Point &p1, Point &p2){\n    return sqrt((p1.a - p2.a)*(p1.a - p2.a) + (p1.b - p2.b)*(p1.b-p2.b));\n}\n\n\nint main(){\n    int N, M;\n    double x, y;\n    double tmp,total=0;\n    int a, b;\n    vector<UEdge> edges; \n    vector<Point> points;\n    cin >> N >> M;\n    for(int i=0; i< N; i++){\n        cin >> x >> y;\n        points.push_back(Point(x,y));\n    }\n    for(int i=0; i< M; i++){\n        cin >> a >> b;\n        a--;b--;\n        tmp = dist(points[a],points[b]);\n        total += tmp;\n        edges.push_back(UEdge(a,b,-tmp));\n    }\n    sort(edges.begin(), edges.end());\n    UnionFind uf(N);\n    int count = 0;\n    for(vector<UEdge>::iterator itr = edges.begin(); count < N-1 && itr != edges.end() ; itr++){\n        if( !uf.Find(itr->a, itr->b)){\n            uf.Union(itr->a, itr->b);\n            total += itr->len;\n            count++;\n        }\n    }\n    cout << setprecision(5) << total << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  vector<int> array[N];\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    array[i].push_back(i + 1);\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      for(k = 0; k < array[j].size(); k++) {\n\tif(links[i].node1 == array[j].at(k))\n\t  t1 = j;\n\telse if(links[i].node2 == array[j].at(k))\n\t  t2 = j;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      while(!array[t2].empty()) {\n\tarray[t1].push_back(array[t2].back());\n\tarray[t2].pop_back();\n      }\n    }\n  }\n\n  for(i = 0; i < N; i++) {\n    for(j = 0; j < array[i].size(); j++)\n      cout << array[i].at(j) << \" \";\n    cout << endl;\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef double D;\n\nclass edge{\npublic:\n  int s,t;\n  int cost;\n  edge(int a,int b,int c):s(a),t(b),cost(c){}\n  bool operator<(const edge &e)const{return cost<e.cost;}\n};\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\ninline int dis2(int x1, int y1, int x2, int y2){\n  return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  int n,m;\n  cin >> n >> m;\n  \n  vector<D> x(n),y(n);\n  for(int i=0;i<n;i++)cin >> x[i] >> y[i];\n\n  vector<edge> e;\n  for(int i=0;i<m;i++){\n    int a,b;\n    cin >> a >> b; a--; b--;\n    e.push_back(edge(a,b,dis2(x[a],y[a],x[b],y[b])));\n  }\n\n  sort(e.begin(), e.end());\n  reverse(e.begin(), e.end());\n  \n  UF uf(n);\n  D ans = 0;\n  rep(i,m){\n    if(uf.same(e[i].s,e[i].t))ans += sqrt(e[i].cost);\n    else uf.unite(e[i].s,e[i].t);\n  }\n  cout << fixed << setprecision(9) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=10005;\nconst int MAXM=100000005;\nconst int INF=1000000005;\nint k,n,m,l,fa[MAXN];\ndouble ans,sum;\nint x[MAXN],y[MAXN];\nstruct node{\n\tint x,y;\n\tdouble z;\n}s[MAXM];\nbool cmp(const node A,const node B){\n\treturn A.z>B.z;\n}\nvoid Add(int x,int y,double z){\n\ts[++l].x=x,s[l].y=y,s[l].z=z;\n}\nint find(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=find(fa[x]);\n}\nvoid Kruskal(){\n\tsort(s+1,s+m+1,cmp);\n\tfor(int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tint i,j;\n\tfor(i=1,j=1;i<=m&&j<=n-1;i++){\n\t\tint x=find(s[i].x),y=find(s[i].y);\n\t\tif(x!=y){\n\t\t\tfa[x]=y;\n\t\t\tans+=s[i].z;\n\t\t\tj++;\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tdouble c=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n\t\tsum+=c;\n\t\tAdd(a,b,c);\n\t}\n\tKruskal();\n\tprintf(\"%.3lf\\n\",sum-ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#define x first\n#define y second\n#define sqr(x) ((x) * (x))\n#define PII pair<int, int>\n#define SIZE(x) ((int) x.size())\nusing namespace std;\nconst int N = 1e4 + 5;\nPII p[N];\nint dis(PII a, PII b)\n{\n\treturn sqr(a.x - b.x) + sqr(a.y - b.y);\n}\nstruct edge\n{\n\tint u, v, r;\n\tedge(int u = 0, int v = 0, int r = 0) : u(u), v(v), r(r) {}\n};\nbool operator < (const edge &a, const edge &b)\n{\n\treturn dis(p[a.u], p[a.v]) < dis(p[b.u], p[b.v]);\n}\nvector<edge> G[N];\nvoid del_edge(int a, int idx)\n{\n\tint sz = SIZE(G[a]);\n\tswap(G[a][idx], G[a][sz - 1]);\n\tG[G[a][idx].v][G[a][idx].r].r = idx;\n\tG[a].pop_back();\n}\nint tick[N], xxx = 0;\nbool dfs(int x, int las)\n{\n\ttick[x] = xxx;\n\t//printf(\"at %d \", x);\n\tfor (int i = 0; i < SIZE(G[x]); ++ i)\n\t{\n\t\tif (i == las) continue;\n\t\tint u = G[x][i].v;\n\t\tif (tick[u] == xxx || dfs(u, G[x][i].r)) return true;\n\t}\n\treturn false;\n}\nint main()\n{\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d%d\", &p[i].x, &p[i].y);\n\tvector<edge> tot;\n\tfor (int i = 1; i <= m; ++ i)\n\t{\n\t\tint u, v;\n\t\tscanf(\"%d%d\", &u, &v);\n\t\tG[u].push_back(edge(u, v, SIZE(G[v])));\n\t\tG[v].push_back(edge(v, u, SIZE(G[u]) - 1));\n\t\ttot.push_back(edge(u, v, SIZE(G[u]) - 1));\n\t}\n\tsort(tot.begin(), tot.end());\n\tdouble ans = 0;\n\tfor (int i = 0; i < m; ++ i)\n\t{\n\t\tint u = tot[i].u, v = tot[i].v, idx = tot[i].r, r = G[u][idx].r;\n\t\txxx ++;\n\t\ttick[u] = xxx;\n\t\tif (dfs(v, r))\n\t\t{\n\t\t\t//printf(\"\\n\");\n\t\t\tans += sqrt(1.0 * dis(p[u], p[v]));\n\t\t\t//printf(\"%.6f\\n\", ans);\n\t\t\t//printf(\"u sz = %d\\n\", G[u].size());\n\t\t\tdel_edge(u, idx);\n\t\t\tdel_edge(v, r);\n\t\t\t//printf(\"new u sz = %d\\n\", G[u].size());\n\t\t}\n\t}\n\tprintf(\"%.8f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\n\t> File Name: c.cpp\n\t> Author:AI_sun \n\t> Mail:13437181134@163.com \n\t> Created Time: Sun 08 Nov 2015 01:28:37 PM CST\n ************************************************************************/\n\n#include<iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int max_n = 10000;\nint fa[max_n];\nstruct Point\n{\n    int x,y;\n}p[max_n];\nstruct Edge\n{\n    int idu,idv;\n    double cost;\n    bool operator<(const Edge &a) const\n    {\n        return cost>a.cost;\n    }\n}e[max_n];\nint n,m;\nvoid init()\n{\n    for(int i = 0;i<=n;i++)\n    {\n        fa[i] = i;\n    }\n}\nint find(int x)\n{\n    return fa[x]==x?x:fa[x] = find(fa[x]);\n}\ndouble ans = 0;\nvoid kruskal()\n{\n    ans = 0;\n    sort(e+1,e+m+1);\n    for(int i = 1;i<=m;i++)\n    {\n        int x = find(e[i].idu),y = find(e[i].idv);\n        if(x!=y)\n        {\n            fa[x] = y;\n        }\n        else\n        {\n            ans+=e[i].cost;\n        }\n    }\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cout.precision(4);\n    cout.setf(ios_base::showpoint);\n    cin.tie(NULL);\n    while(cin>>n>>m)\n    {\n        for(int i = 1;i<=n;i++)\n        {\n            cin>>p[i].x>>p[i].y;\n        }\n        for(int i = 1;i<=m;i++)\n        {\n            int a,b;\n            cin>>a>>b;\n            e[i].idu = a;\n            e[i].idv = b;\n            e[i].cost = (p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y);\n            e[i].cost = sqrt(1.0*e[i].cost);\n\n        }\n        init();\n        kruskal();\n        cout<<ans<<endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair <int, double> Edge;\ntypedef vector <Edge> Graph;\ntypedef pair <double, int> Node;\ntypedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\nconst int size = 10001;\nPoint P[size];\nbool used[size];\nGraph G[size];\n\ndouble solve( int s ) {\n    double answer = 0.0;\n    Queue Q;\n    Node start( 0.0, s );\n    Q.push( start );\n\n    while ( ! Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        double c = node.first;\n        int t = node.second;\n        \n        if ( used[t] ) continue;\n        used[t] = true;\n        answer += c;\n\n        for ( Graph::iterator it_i = G[t].begin();\n              it_i != G[t].end(); ++ it_i ) {\n            Edge e = *it_i;\n            double nc = e.second;\n            int nt = e.first;\n            Node next( nc, nt );\n            Q.push( next );\n        }\n    }\n\n    return answer;\n}\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        for ( int i = 0; i < n; ++ i ) {\n            used[i] = false;\n            G[i].clear();\n        }\n        \n        for ( int i = 0; i < n; ++ i ) {\n            int x, y;\n            cin >> x >> y;\n            P[i] = Point( x, y );\n        }\n        \n        double sum1 = 0.0;\n        for ( int i = 0; i < m; ++ i ) {\n            int p, q;\n            cin >> p >> q;\n            p --;\n            q --;\n            double d = abs( P[p] - P[q] );\n            G[p].push_back( Edge( q, d * -1 ) );\n            G[q].push_back( Edge( p, d * -1 ) );\n            sum1 += d;\n        }\n        \n        double sum2 = 0.0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( used[i] ) continue;\n            sum2 += solve( i );\n        }\n\n        printf( \"%.3f\\n\", sum1 + sum2 );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n\tint x, y;\n};\n\nstruct Node {\n\tint a, b;\n\tdouble d;\n};\n\nPoint piles[10001];\n\nint N, M;\n\nint s[10001];\n\ndouble distanc(int i, int j)\n{\n\tint dx = piles[i].x - piles[j].x;\n\tint dy = piles[i].y - piles[j].y;\n\treturn sqrt(dx*dx+dy*dy);\n}\n\nbool compare_node(const Node &n1, const Node &n2)\n{\n\tif (n1.d != n2.d)\n\t\treturn n1.d < n2.d;\n\tif (n1.a != n2.a)\n\t\treturn n1.a < n2.a;\n\treturn n1.b < n2.b;\n}\n\nint find_root(int i)\n{\n\tif (s[i]!=i)\n\t\ts[i] = find_root(s[i]);\n\treturn s[i];\n}\n\nbool same_set(int i, int j)\n{\n\treturn find_root(i)==find_root(j);\n}\n\nvoid union_set(int i, int j)\n{\n\tint root1 = find_root(i);\n\tint root2 = find_root(j);\n\ts[root1] = root2;\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tscanf(\"%d%d\", &piles[i].x, &piles[i].y);\n\t\t}\n\n\t\tvector<Node> v;\n\t\tNode node;\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tscanf(\"%d%d\", &node.a, &node.b);\n\t\t\tnode.d = distanc(node.a, node.b);\n\t\t\tv.push_back(node);\n\t\t}\n\t\tsort(v.begin(), v.end(), compare_node);\n\n\t\tvector<int> remove_v;\n\t\tfor (i=1; i<=N; i++)\n\t\t\ts[i] = i;\n\t\tfor (i=M-1; i>=0; i--) {\n\t\t\tif (!same_set(v[i].a, v[i].b)) {\n\t\t\t\tunion_set(v[i].a, v[i].b);\n\t\t\t\tremove_v.push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tdouble sum = 0.0;\n\t\tj = remove_v.size()-1;\n\t\tfor (i=0; i<M; i++) {\n\t\t\tif (j>=0 && i==remove_v[j]) {\n\t\t\t\tj--; continue;\n\t\t\t}\n\t\t\tsum += v[i].d;\n\t\t}\n\t\tprintf(\"%.3lf\\n\", sum);\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX 10005\n\nstruct edge{\n  int from,to;\n  double cost;\n  bool operator < (const edge &e)const{\n    return cost < e.cost;\n  }\n};\n  \nint n,m,a,b;\ndouble x[MAX],y[MAX];\nvector<edge> G;\n\nint par[MAX];\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\ndouble dist(int i,int j){\n  double X=x[i]-x[j];\n  double Y=y[i]-y[j];\n  return sqrt(X*X+Y*Y);\n}\n\nint main(){\n  cin>>n>>m;\n  \n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    par[i]=i;\n  }\n  \n  for(int i=0;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    G.push_back((edge){a,b,dist(a,b)});\n  }\n  sort(G.begin(),G.end());\n  reverse(G.begin(),G.end());\n  double ans=0;\n  for(int i=0;i<m;i++){\n    edge e=G[i];\n    e.from=find(e.from);\n    e.to=find(e.to);\n    if(e.from==e.to){\n      ans+=e.cost;\n    }else{\n      par[e.from]=e.to;\n    }\n  }\n  printf(\"%.3f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define X first\n#define Y second\n\nclass union_find {\nprivate:\n\tvector<int> uf;\n\npublic:\n\tunion_find(int n) {\n\t\tuf.resize(n, -1);\n\t}\n\t\n\tinline int find(int x) {\n\t\treturn uf[x] < 0 ? x : uf[x] = find(uf[x]);\n\t}\n\t\n\tinline bool unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)\n\t\t\treturn false;\n\t\t\n\t\tif(uf[x] > uf[y])\n\t\t\tswap(x, y);\n\t\t\n\t\telse if(uf[x] == uf[y])\n\t\t\t--uf[x];\n\t\t\n\t\tuf[y] = x;\n\n\t\treturn true;\n\t}\n};\n\nstruct edge {\n\tint u, v;\n\tdouble cost;\n\tedge(int u_, int v_, double c):u(u_), v(v_), cost(c){}\n\n\tbool operator> (const edge& o) const {\n\t\treturn cost > o.cost;\n\t}\n};\n\n\nvector<edge> es;\n\ndouble kruskal(int V) {\n\tsort(es.begin(), es.end(), greater<edge>());\n\tunion_find uf(V);\n\n\tdouble res = 0.0;\n\tfor(int i = 0; i < es.size(); ++i)\n\t\tif(uf.unite(es[i].u, es[i].v))\n\t\t\tres += es[i].cost;\n\n\treturn res;\n}\n\ntemplate<typename T> inline T square(T x) {\n\treturn x * x;\n}\n\ninline double dist(pair<int, int> u, pair<int, int> v) {\n\treturn sqrt(square(u.X - v.X) + square(u.Y - v.Y));\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tvector<pair<int, int> > piles(n);\n\tfor(int i = 0; i < n; ++i)\n\t\tscanf(\"%d %d\", &piles[i].X, &piles[i].Y);\n\n\tdouble sum = 0.0;\n\tfor(int i = 0; i < m; ++i) {\n\t\tint p, q;\n\t\tscanf(\"%d %d\", &p, &q);\n\t\t--p;\n\t\t--q;\n\n\t\tconst double d = dist(piles[p], piles[q]);\n\t\tsum += d;\n\t\tes.push_back(edge(p, q, d));\n\t}\n\n\tprintf(\"%.3lf\\n\", sum - kruskal(n));\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\ntypedef complex<double> Point;\nstruct union_find\n{\n\tvector<int> par;\n\tunion_find(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<Point> ps(n);\n\tREP(i, n)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[i] = Point(x, y);\n\t}\n\tvector<edge> es;\n\tdouble ans = 0;\n\tREP(i, m)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tdouble d = abs(ps[a] - ps[b]);\n\t\tans += d;\n\t\tes.push_back(edge{ a, b, d });\n\t}\n\tsort(es.rbegin(), es.rend());\n\tunion_find uf(n);\n\tREP(i, es.size())\n\t{\n\t\tif (uf.same(es[i].from, es[i].to)) continue;\n\t\tans -= es[i].cost;\n\t\tuf.unite(es[i].from, es[i].to);\n\t}\n\tcout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\nusing namespace std;\n\nstruct load{\n  pair<int, int> pos1;\n  pair<int, int> pos2;\n  int cost2;\n  load(){}\n};\n\nvector< pair<int, bool> > g[10000];\npair<int, int> pos[10000];\nvector<load> loads;\n\nbool operator < (const load &lhs, const load &rhs){\n  return lhs.cost2 < rhs.cost2;\n}\n\ninline int dbl(int x){ return x * x; }\nint dist(int i, int j){\n  return dbl(pos[i].first - pos[j].first)\n    + dbl(pos[i].second - pos[j].second);\n}\n\nload createLoad(int i, int j){\n  load ret;\n  ret.pos1.first  = i;\n  ret.pos1.second = g[i].size();\n  g[i].push_back(make_pair(j, true));\n\n  ret.pos2.first  = j;\n  ret.pos2.second = g[j].size();\n  g[j].push_back(make_pair(i, true));\n\n  ret.cost2 = dist(i, j);\n  return ret;\n}\n\nint n;\nint m;\n\nbool memo[10000];\n\nbool check(int pos, int start){\n  if(pos == start) return true;\n  memo[pos] = true;\n  REP(i, g[pos].size()) if(g[pos][i].second){\n    int dst = g[pos][i].first;\n    if(!memo[dst] && check(dst, start)) return true;\n  }\n  return false;\n}\n\nint main(){\n  double ans = 0.0;\n\n  n = getInt();\n  m = getInt();\n\n  loads = vector<load>(m);\n\n  REP(i,n){\n    pos[i].first  = getInt();\n    pos[i].second = getInt();\n  }\n\n  REP(i,m){\n    int a = getInt();\n    int b = getInt();\n    loads[i] = createLoad(a - 1, b - 1);\n  }\n\n  sort(loads.begin(), loads.end());\n\n  REP(i,m){\n    int a = loads[i].pos1.first;\n    int b = loads[i].pos2.first;\n    memset(memo, 0, sizeof(memo));\n    g[a][loads[i].pos1.second].second = false;\n    g[b][loads[i].pos2.second].second = false;\n    if(check(b, a)){\n      ans += sqrt(loads[i].cost2);\n    }else{\n      g[a][loads[i].pos1.second].second = true;\n      g[b][loads[i].pos2.second].second = true;\n    }\n  }\n\n  printf(\"%.5f\\n\", ans);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<string>\n#include<cmath>\nusing namespace std;\nint x[10002];\nint y[10002];\nint fa[10002];\nint n, m;\nint num;\nstruct edge{\n\tint u;\n\tint v;\n\tdouble cost;\n};\nbool cmp(edge a, edge b){\n\treturn a.cost < b.cost;\n}\nedge es[1000000];\nint find(int a){\n\tif (a == fa[a]) return a;\n\telse return fa[a] = find(fa[a]);\n}\nbool same(int a, int b){\n\tint aa = find(a);\n\tint bb = find(b);\n\tif (aa==bb) return true;\n\telse return false;\n}\n\nvoid unite(int a, int b){\n\tint aa = fa[a];\n\tint bb = fa[b];\n\tif (aa != bb){\n\t\tfa[aa] = bb;\n\t}\n}\ndouble krusal(){\n\tsort(es, es + num, cmp);\n\tdouble res = 0;\n\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\tfor (int i = 0; i < num; i++){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\t\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)cin >> x[i] >> y[i];\n\tnum = 0;\n\tint u, v;\n\tdouble d;\n\tdouble  sum = 0;\n\twhile (m--){\n\t\tcin >> u >> v;\n\t\td = (x[u] - x[v])*(x[u] - x[v]) + (y[u] - y[v])*(y[u] - y[v]);\n\t\t\td = sqrt(d);\n\t\t\tes[num].u = u;\n\t\t\tes[num].v = v;\n\t\t\tes[num++].cost = -d;\n\t\t\tsum += d;\n\t}\n\tdouble ans = sum + krusal();\n\tprintf(\"%.3lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#include<math.h>\n#define maxn 11000\n#define oo 0xfffffff\nusing namespace std;\nint father[maxn], n, m;\n\nstruct node\n{\n    int u, v;\n    double w;\n\n} s[maxn*100];///数?大小\n\nstruct point\n{\n    int x, y;\n} a[maxn];\n\ndouble Len(int p, int q)\n{\n    double d = sqrt((a[p].x-a[q].x)*(a[p].x-a[q].x)+(a[p].y-a[q].y)*(a[p].y-a[q].y));\n    return d;\n}\n\nint Find(int x)\n{\n   while(x!=father[x])\n     x=father[x];\n\n     return x;\n}\n\nint cmp(node p, node q)\n{\n    return p.w>q.w;\n}\n\ndouble solve()\n{\n    double ans = 0;\n\n    for(int i=0; i<m; i++)\n    {\n        int ru = Find(s[i].u);\n        int rv = Find(s[i].v);\n\n        if(ru != rv)\n        {\n            father[ru] = rv;\n            ans += s[i].w;\n        }\n\n    }\n\n    return ans;\n}\n\n\nint main()\n{\n    int u, v;\n\n    while(scanf(\"%d %d\",&n, &m)!=EOF)\n    {\n        double sum = 0;\n\n        for(int i=1; i<=n; i++)\n            scanf(\"%d %d\", &a[i].x, &a[i].y);\n\n        for(int i=1; i<=n; i++)\n            father[i] = i;\n\n        for(int i=0; i<m; i++)\n        {\n            scanf(\"%d %d\", &u, &v);\n            s[i].u = u;\n            s[i].v = v;\n            s[i].w = Len(u, v);\n\n            sum += s[i].w;\n        }\n\n        sort(s, s+m, cmp);\n\n        double l = solve();\n\n        printf(\"%.3f\\n\", sum-l);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define inf 0x3f3f3f\n#define N 10000\nint fa[2*N+5],t,n,m,k;\ndouble s[N+5][2],s1;\nstruct mzls\n{\n\tint u,v;\n\tdouble w;\n\tbool operator<(const mzls &a)const\n\t{\n\t\treturn a.w<w;\n\t}\n}g[N*N+5],as;\ninline int find(int x)\n{\n\tif(fa[x]==-1)\n\t\treturn x;\n\treturn fa[x]=find(fa[x]);\n}\ninline double K()\n{\n\tdouble sum=0.0;\n\tsort(g+1,g+t+1);\n\tmemset(fa,-1,sizeof(fa));\n\tint j=0;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tint u=g[i].u,v=g[i].v;\n\t\tint r1=find(u),r2=find(v);\n\t\tif(r1!=r2)\n\t\t{\n\t\t\tfa[r2]=r1;\n\t\t\tsum+=g[i].w;\n\t\t\tj++;\n\t\t\tif(j>=n-1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum;\n}\ninline void insert(int x,int y,double z)\n{\n\tas.u=x,as.v=y,as.w=z;\n\tg[++t]=as;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf\",&s[i][0],&s[i][1]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tdouble z;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tz=sqrt((s[x][1]-s[y][1])*(s[x][1]-s[y][1])+(s[x][0]-s[y][0])*(s[x][0]-s[y][0]));\n\t\ts1+=z;\n\t\tinsert(x,y,z);\n\t}\n\tprintf(\"%lf\\n\",s1-K());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<iostream>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\n\nstruct edge\n{\n\tint f,t;\n\tdouble v;\n}edg[2000010];\n\nstruct xy\n{\n\tint x,y;\n}aa[10010];\n\nint pre[20010];\nint n,m;\n\nvoid init()\n{\n\tfor(int i=0;i<=n;i++)\n\t\tpre[i]=i;\n}\nint find(int x)\n{\n\tif(pre[x]==x)\n\t\treturn x;\n\telse\n\t\treturn pre[x]=find(pre[x]);\n}\nvoid join(int x,int y)\n{\n\tint fx=find(x);\n\tint fy=find(y);\n\tpre[fx]=fy;\n}\nbool cmp(edge a,edge b)\n{\n\treturn a.v>b.v;\n}\ndouble Kruskal()\n{\n\tsort(edg,edg+m,cmp);\n\tdouble ans=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint u=find(edg[i].f);\n\t\tint v=find(edg[i].t);\n\t\tif(u!=v)\n\t\t{\n\t\t\tjoin(u,v);\n\t\t\tans+=edg[i].v;\n\t\t}\n\t}\n\treturn ans;\n}\ndouble distance(int a,int b)\n{\n\tdouble d=sqrt(double((aa[a].x-aa[b].x)*(aa[a].x-aa[b].x)+(aa[a].y-aa[b].y)*(aa[a].y-aa[b].y)));\n\treturn d;\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&m);\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d %d\",&aa[i].x,&aa[i].y);\n\tdouble sum=0;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tedg[i].f=x;\n\t\tedg[i].t=y;\n\t\tedg[i].v=distance(x,y);\n\t\tsum+=edg[i].v;\n\t}\n\tdouble res=Kruskal();\n\tprintf(\"%.3f\\n\",sum-res);\n\treturn 0; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<queue>\n#include<string>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define pb push_back\n#define fi first\n#define sc second\n#define mp make_pair\ntypedef pair<double,double> pdd;\n#define UNION_FIND_MAX_N 10000\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n};\n\nbool cmp(edge e,edge f){\n\treturn e.cost<f.cost;\n}\n\nint par[UNION_FIND_MAX_N],rank[UNION_FIND_MAX_N];\n\nvoid union_find_init(int n){\n\tfor(int i=0;i<n;++i){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y){\n\t\treturn;\n\t}else if(rank[x]<rank[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rank[x]==rank[y]){\n\t\t\t++rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\n\ndouble dist(pdd p,pdd q){\n\treturn sqrt((p.fi-q.fi)*(p.fi-q.fi)+(p.sc-q.sc)*(p.sc-q.sc));\n}\n\nedge e[30000];\nint n,m;\n\ndouble kruskal(){\n\tsort(e,e+m,cmp);\n\tunion_find_init(n);\n\tdouble r=0;\n\tfor(int j=0;j<m;++j){\n\t\tif(!same(e[j].u,e[j].v)){\n\t\t\tunite(e[j].u,e[j].v);\n\t\t\tr+=e[j].cost;\n\t\t}\n\t}\n\treturn r;\n}\n\nint main(){\n\tdouble cs=0;\n\tpdd p[10000];\n\tcin>>n>>m;\n\tfor(int i=0;i<n;++i){\n\t\tcin>>p[i].fi>>p[i].sc;\n\t}\n\tfor(int j=0;j<m;++j){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tdouble c=dist(p[--s],p[--t]);\n\t\te[j]=((edge){s,t,-c});\n\t\tcs+=c;\n\t}\n\tcout<<fixed<<setprecision(3)<<cs+kruskal()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint par[150010],r[150010];\nvoid init(){ rep(i,150010){ par[i]=i; r[i]=0; } }\nint find(int x){ if(x==par[x])return x; return par[x]=find(par[x]); }\nbool same(int x,int y){ return find(x)==find(y); }\nvoid unit(int x,int y){ if(same(x,y))return; x=find(x); y=find(y); if(r[x]<r[y])par[x]=y; else { par[y]=x; if(r[x]==r[y])r[x]++; } }\n\nint main(){\n\tint n,m;\n\tint x[10010],y[10010];\n\tvector<P1> G;\n\t\n\tscanf(\"%d%d\",&n,&m);\n\trep1(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\trep(i,m){\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tG.pb(mp1((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]),p,q));\n\t}\n\t\n\tsor(G);\n\trev(G);\n\tinit();\n\t\n\tlong double ret=0.0;\n\trep(i,m){\n\t\tP1 ed=G[i];\n\t\tif(!same(ed.sc.fr,ed.sc.sc)){\n\t\t\tunit(ed.sc.fr,ed.sc.sc);\n\t\t}\n\t\telse ret+=sqrt((long double)ed.fr);\n\t}\n\t\n\tprintf(\"%.3lf\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define N 100005\n#define P pair<int,int>\n#define ll long long\n#define mk(a, b) make_pair(a, b)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\nint inf = 0x3f3f3f3f;\nint n, m, pre[N];\nstruct ac{\n\tint v;\n\tdouble c;\n};\nvoid init() {\n\tfor (int i = 1; i <N; ++i) {\n\t\tpre[i] = i;\n\t}\n}\nint find(int x) {\n\tif (x == pre[x])\treturn x;\n\telse \treturn pre[x] = find(pre[x]);\n}\nvoid join(int x, int y) {\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy)\treturn;\n\telse if (fx < fy)\tpre[fy] = fx;\n\telse \tpre[fx] = fy;\n}\ndouble sum;\nbool vis[N];\ndouble dis[N];\nvector<P> a(N);\nvector<ac> g[N];\nvoid prime(int x) {\n\tmem(dis, 0);\n\tmem(vis, false);\n\tdis[x] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble MAX = 0;\n\t\tint u = -1;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (vis[j])\tcontinue;\n\t\t\tif (dis[j] > MAX) {\n\t\t\t\tMAX = dis[j];\n\t\t\t\tu = j;\n\t\t\t}\n\t\t}\n\t\tif (u == -1)\treturn;\n\t\tvis[u] = true;\n\t\tif (u == x)\tMAX = 0;\n\t\tsum += MAX;\n\t\t// cout << \"u = \" << u << \" \" << MAX << endl;\n\t\tfor (int j = 0; j < g[u].size(); ++j) {\n\t\t\tac t = g[u][j];\n\t\t\tif (vis[t.v])\tcontinue;\n\t\t\tif (dis[t.v] < t.c ) {\n\t\t\t\tdis[t.v] = t.c;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\nint main(){\n#ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m) {\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tint dx = a[u].first - a[v].first;\n\t\t\tint dy = a[u].second - a[v].second;\n\t\t\tdouble temp = sqrt(dx * dx + dy * dy);\n\t\t\t// cout << \"temp = \" << temp << endl;\n\t\t\tans += temp;\n\t\t\tg[u].push_back((ac){v, temp});\n\t\t\tg[v].push_back((ac){u, temp});\n\t\t\tjoin(u, v);\n\t\t}\n\t\t// cout << ans << endl;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (pre[i] == i) {\n\t\t\t\tsum = 0;\n\t\t\t\tprime(i);\n\t\t\t\tans -= sum;\n\t\t\t\t// cout << i << \"::\" << sum << endl;\n\t\t\t}\n\t\t}\n\t\t// ans += 1;\n\t\t// cout << ans << endl;\n\t\tprintf(\"%.3lf\\n\",ans);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define MAX_N 10000+5\n\n//Begin\n#define MAX_E MAX_N * MAX_N / 2 + 1\nint parent[MAX_N];\nint height[MAX_N];\n\nvoid init(const int& n){\n\tfor (int i = 0; i < n; ++i){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nint find(const int& x){\n\treturn parent[x] == x ? x : parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t\treturn;\n\tif (height[x] < height[y]){\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y]){\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n\nbool same(const int& x, const int& y){\n\treturn find(x) == find(y);\n}\n//End of \n\nstruct edge{\n\tint u, v;\n\tdouble cost;\n\tedge(int u = 0, int v = 0, double cost = 0.0)\n\t\t: u(u), v(v), cost(cost) {}\n\tbool operator < (const edge & e2) const{\n\t\treturn cost > e2.cost;\n\t}\n};\n\nedge es[MAX_E];\nint V, E;\ndouble kruskal()\n{\n\tsort(es, es + E);//按照&#26435;排序\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\ntypedef pair<int, int>ip;\nip dis[MAX_N];\nint main()\n{\n\tcin >> V >> E;\n\tfor (int i = 0; i < V; ++i){\n\t\tcin >> dis[i].first >> dis[i].second;\n\t}\n\tdouble sum = 0.0;\n\tfor (int i = 0; i < E; ++i){\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = dis[es[i].u].first - dis[es[i].v].first;\n\t\tint dy = dis[es[i].u].second - dis[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t\tsum += es[i].cost;\n\t}\n\tprintf(\"%.3lf\", sum - kruskal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 3604480\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tmemset(used,0,sizeof used);\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    if (par[x] == x)\n    {\n      return x;\n    }\n    else\n    {\n      return par[x] = root(par[x]);\n    }\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] % MOD * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\ntemplate <class TYPE>\nstruct Fenwick\n{\n  int N;\n  vector<ll> bit;\n\n  Fenwick() : N(0) {}\n  Fenwick(int n) : N(n), bit(N + 1, 0) {}\n\n  void add(int i, ll x)\n  {\n    ++i; //0-indexedを避けるために加算\n    while (i <= N)\n    {\n      bit[i] += x;\n      i += (i & -i);\n    }\n  }\n\n  ll sum(int i)\n  {\n    ll res = 0;\n    while (i > 0)\n    {\n      res += bit[i];\n      i -= (i & -i);\n    }\n    return res;\n  }\n\n  ll range(int i, int j)\n  {\n    return sum(j) - sum(i);\n  }\n\n  ll get(int i)\n  {\n    return sum(i) - sum(i - 1);\n  }\n};\n\ndouble dist(double x1, double y1, double x2, double y2)\n{\n  return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nbool used[101010];\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(4);\n\n  int N, M;\n  cin >> N >> M;\n\n  UnionFind uf(N + 10);\n  vector<pair<int, int>> vp;\n  REP(i, N)\n  {\n    int x, y;\n    cin >> x >> y;\n    vp.push_back(make_pair(x, y));\n  }\n\n  // 多角形を探す -> 最小全域森?\n  // 最大全域木をして使っていない辺だけ求めればよさそう\n  vector<pair<double, pair<int, int>>> c;\n  REP(i, M)\n  {\n    int p, q;\n    cin >> p >> q;\n    p--;\n    q--;\n    c.push_back(make_pair(dist(vp[p].first, vp[p].second, vp[q].first, vp[q].second), make_pair(p, q)));\n  }\n\n  sort(all(c));\n  reverse(all(c));\n\n  for (int i = 0; i < c.size(); i++)\n  {\n    double cost = c[i].first;\n    int p = c[i].second.first, q = c[i].second.second;\n\n    if (!uf.issame(p, q))\n    {\n      used[i] = true;\n      uf.merge(p, q);\n    }\n  }\n\n  double ans = 0.0;\n  for (int i = 0; i < c.size(); i++)\n  {\n\n    if (!used[i])\n    {\n\n      ans += c[i].first;\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 10000\n#define MAX_M 10000\n\nint N, M;\nint par[MAX_N],rank[MAX_N];\ntypedef pair<double,double> P;\nvoid init(){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nstruct edge{\n  int u,v;\n  double cost;\n};\n\nbool comp(const edge &e1,const edge &e2){\n  return e1.cost > e2.cost;\n}\n\nedge es[MAX_M];\n\ndouble kruskal(){\n  init(); sort(es , es + M, comp);\n  double res = 0;\n  for(int i = 0 ; i < M ; i++){\n    edge e = es[i];\n    if(!same(e.u , e.v)){\n      unite(e.u , e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2));\n}\n\nint main(){\n  int a,b;\n  P p[MAX_N];\n\n  scanf(\"%d %d\" ,&N ,&M);\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&p[i].first, &p[i].second);\n  }\n  double total = 0;\n  for(int i = 0 ; i < M ; i++){\n    scanf(\"%d %d\" ,&a ,&b);  \n    a--, b--;\n    double d = dist(p[a],p[b]);\n    es[i].u = a; es[i].v = b; es[i].cost = d;\n    total += d;\n  }\n  printf(\"%.3f\\n\",total-kruskal());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nint n, m, cnt;\nint f[10010];\nstruct Point{\n\tint x, y, id;\n}point[10010];\n\nstruct Edge{\n\tint form, to;\n\tdouble dis;\n}edge[10010 * 10010];\n\nint Find(int x){\n\treturn f[x] == x ? x : f[x] = Find(f[x]);\n}\n\nvoid Union(int x, int y){\n\tint fx = Find(x);\n\tint fy = Find(y);\n\tif(fx != fy)\n\tf[fy] = fx;\n}\nvoid Addedge(int form, int to, double dis){\n\tedge[cnt].form = form;\n\tedge[cnt].to = to;\n\tedge[cnt++].dis = dis;\n}\n\ndouble dis(Point x, Point y){\n\treturn sqrt(1.0*(x.x - y.x)*(x.x - y.x) + 1.0 * (x.y - y.y)*(x.y - y.y));\n}\nbool cmp1(Edge a, Edge b){\n\treturn a.dis > b.dis;\n}\n\nbool cmp2(double a, double b){\n\treturn a < b;\n}\n\ndouble Kruskal(){\n\tsort(edge, edge + cnt, cmp1);\n\tfor(int i = 1; i <= n; i++)\n\tf[i] = i;\n\tdouble sum = 0;\n\tint tot = 0;\n\tint i;\n\tfor(i = 0; i < cnt; i++){\n\t\tif(Find(edge[i].form) == Find(edge[i].to)){\n\t\t\tsum += edge[i].dis;\n\t\t\tcontinue;\t\n\t\t} \n\t\tUnion(edge[i].form, edge[i].to);\n\t}\n\treturn sum;\n}\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m)){\n\t\tcnt = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>point[i].x>>point[i].y;\n\t\t\tpoint[i].id = i;\n\t\t}\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint a, b;\n\t\t\tdouble w;\n\t\t\tcin>>a>>b;\n\t\t\tw = dis(point[a], point[b]);\n\t\t\tAddedge(a, b, w);\n\t\t}\n\t\tprintf(\"%.3f\\n\", Kruskal());\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\tfor (int p = 0; p < V; p++)\n\t{\n\t\tif (u[p]) { continue; }\n\n\t\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\t\tque.push(make_pair(0.0, p));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\t\tint v = r.second;\n\n\t\t\tif (u[v]) { continue; }\n\n\t\t\tres += r.first; u[v] = true;\n\n\t\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t\t{\n\t\t\t\tif (!u[G[v][i].first])\n\t\t\t\t{\n\t\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ret = 0.0;\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret += G[i][j].second;\n\t\t}\n\t}\n\n\tret = ret / 2 - res;\n\n\tprintf(\"%.9f\\n\", 100000.0 * (E - V + 1) - ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<cstdlib>\n#include<ctime>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#define mem(name,value) memset(name,value,sizeof(name))\n#define loop(i,from,to) for(int i=from;i<to;i++)\n#define loopr(i,from,to) for(int i=from;i>=to;i--)\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn=10000+5;\nint par[maxn],r[maxn],x[maxn],y[maxn],V,E;\ntypedef struct{int u,v; double cost;}edge;\nvector<edge> es;\n\nvoid init(int N)\n{\n    loop(i,0,N){\n        par[i]=i;\n        r[i]=0;\n    }\n}\n\nint Find(int x)\n{\n    if(par[x]==x) return x;\n    else return par[x]=Find(par[x]);\n}\n\nvoid unite(int x,int y)\n{\n    x=Find(x); y=Find(y);\n    if(x==y) return;\n\n    if(r[x]<r[y]) par[x]=y;\n    else par[y]=x;\n    if(r[x]==r[y]) r[x]++;\n}\n\nbool same(int x,int y)\n{\n    return Find(x)==Find(y);\n}\n\nbool cmp(const edge& e1,const edge& e2)\n{\n    return e1.cost>e2.cost;\n}\n\ndouble kruskal()\n{\n    sort(es.begin(),es.end(),cmp);\n    init(V+1);\n    double ans=0;\n    loop(i,0,E){\n        edge e=es[i];\n        if(!same(e.u , e.v)){\n            unite(e.u , e.v);\n            ans+=e.cost;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    double sum=0;\n    scanf(\"%d%d\",&V,&E);\n    loop(i,1,V+1)\n        scanf(\"%d%d\",&x[i],&y[i]);\n    loop(i,0,E){\n        int f,t;\n        double c;\n        scanf(\"%d%d\",&f,&t);\n        c=sqrt((x[f]-x[t])*(x[f]-x[t])+(y[f]-y[t])*(y[f]-y[t]));\n        edge e; e.u=f; e.v=t; e.cost=c; sum+=c;\n        es.pb(e);\n    }\n    printf(\"%.3f\\n\",sum-kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\nconst int maxn=1000100;\nstruct edge{\n    int from,to;\n    double cost;\n}es[maxn];\nstruct point{\n    int x,y;\n};\nint pre[maxn],rank1[maxn];\nint n,m;\nbool comp(const edge& e1,const edge& e2)\n    {\n        return e1.cost>e2.cost;\n    }\nvoid init(int n)\n    {\n        for (int i=1;i<=n;i++)\n            {\n                pre[i]=i;\n                rank1[i]=0;\n            }\n    }\nint find(int x)\n    {\n        if(pre[x]==x)\n            return x;\n        else return pre[x]=find(pre[x]);\n    }\n\nvoid unite(int x,int y)\n    {\n        x=find(x);\n        y=find(y);\n        if(x==y) return;\n        if(rank1[x]<rank1[y])\n            {\n                pre[x]=y;\n            }\n        else\n            {\n                pre[y]=x;\n                if(rank1[x]==rank1[y])\n                    ++rank1[x];\n            }\n    }\ndouble krukal()\n    {\n        sort(es,es+m,comp);\n        init(n);\n        double res=0;\n        for(int i=0;i<m;++i)\n            {\n                edge e=es[i];\n                if(find(e.from)!=find(e.to))\n                    {\n                        unite(e.from,e.to);\n                        res+=e.cost;\n                    }\n            }\n        return res;\n    }\ndouble dis(int x1,int y1,int x2,int y2)\n    {\n        return sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n    }\nint main()\n    {\n        while (cin>>n>>m)\n            {\n                point p[10010];\n                int a,b;\n                double sum=0;\n                for (int i=1;i<=n;++i)\n                    {\n                        cin>>p[i].x>>p[i].y;\n                    }\n                for (int i=0;i<m;i++)\n                    {\n\n                        cin>>a>>b;\n                        es[i].from=a;\n                        es[i].to=b;\n                        es[i].cost=dis(p[a].x,p[a].y,p[b].x,p[b].y);\n                        sum+=es[i].cost;\n                    }\n                double ans;\n                ans=krukal();\n                printf(\"%.3f\\n\",sum-ans);\n            }\n    }\n\n"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define M 10000\nint parent[M],a[M],b[M];\npair<double,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tdouble s=0;\n\tint i,n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tvector<pair<double,double> >v(n);\n\tfor(i=0;i<n;i++)scanf(\"%lf%lf\",&v[i].first,&v[i].second);\n\tfor(i=0;i<m;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y),x--,y--;\n\t\ta[i]=x,b[i]=y;\n\t\tnode[i].first=-hypot(v[x].first-v[y].first,v[x].second-v[y].second);\n\t\ts-=node[i].first;\n\t\tnode[i].second=i;\n\t}\n\tsort(node,node+m);\n\tfor(i=0;i<n;i++)parent[i]=i;\n\tfor(i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\tprintf(\"%f\\n\",s);\n}"
  },
  {
    "language": "C++",
    "code": "/*  xzppp  */\n#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <string.h>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <string>\n#include <cmath>\n#include <set>\n#include <iomanip>\nusing namespace std;\n#define FFF freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n#define lson l,m,rt<<1\n#define rson m+1,r,rt<<1|1\n#define MP make_pair\n#define PB push_back\ntypedef long long  LL;\ntypedef unsigned long long ULL;\ntypedef pair<int,int > pii;\ntypedef pair<double,double > pdd;\ntypedef pair<double,int > pdi;\nconst int MAXN = 1e4+17;\nconst int MAXM = 20;\nconst int MAXV = 1e4+17;\nconst int INF = 0x7fffffff;\nconst int MOD = 1e9+7;\npdd all[MAXV];\nvector<pdi > G[MAXV];\ndouble s;\nbool vis1[MAXV];\nvoid dfs(int x)\n{\n\tvis1[x]=1;\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\ts+=G[x][i].first;\n\t\t}\n\t}\n\tfor (int i = 0; i < G[x].size(); ++i)\n\t{\n\t\tif(!vis1[G[x][i].second])\n\t\t{\n\t\t\tdfs(G[x][i].second);\n\t\t}\n\t}\n}\nbool vis[MAXV];\ndouble minc[MAXV];\ndouble prim(int x)\n{\n    for (int i = 0; i < MAXV; ++i)\n    {\n        minc[i] = 0;\n        vis[i] = 0;\n    }\n    double res = 0;\n    priority_queue<pdi> q;\n    q.push(MP(0,x));\n    while(!q.empty())\n    {\n        int v = q.top().second;\n        double temp = q.top().first;\n        q.pop();\n        if(vis[v]) continue;\n       // cout<<\"???\"<<v<<endl;\n        vis[v] = 1;\n        res += temp;\n        for (int i = 0; i < G[v].size(); ++i)\n        {\n            double d = G[v][i].first;\n            int to = G[v][i].second;\n            if(!vis[to]&&minc[to]<d)\n            {\n                q.push(MP(d,to));\n                minc[to] = d;\n            }\n        }\n    }\n    return  res;\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE \n   // FFF\n    #endif\n    int n,m;\n    cin>>n>>m;\n    for (int i = 0; i < n; ++i)\n    {\n    \tdouble x,y;\n    \tscanf(\"%lf%lf\",&x,&y);\n    \tall[i].first = x;\n    \tall[i].second = y;\n    }\n    for (int i = 0; i < m; ++i)\n    {\n    \tint u,v;\n    \tscanf(\"%d%d\",&u,&v);\n    \tu--;v--;\n    \tdouble dis = sqrt((all[u].first-all[v].first)*(all[u].first-all[v].first)\n    \t\t+(all[u].second-all[v].second)*(all[u].second-all[v].second));\n    \tG[u].push_back(MP(dis,v));\n    \tG[v].push_back(MP(dis,u));\n    }\n    double ans = 0;\n    for (int i = 0; i < n; ++i)\n    {\n    \tif(!vis1[i])\n    \t{\n    \t\t//cout<<i<<endl;\n    \t\ts = 0;\n    \t\tdfs(i);\n    \t\t//cout<<s<<endl;\n    \t\tdouble left = prim(i);\n    \t\tans += s-left;\n    \t\t//cout<<\" ans\"<<s-left<<endl;\n    \t}\n    }\n    cout<<fixed<<setprecision(4)<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SQ(X) ((X)*(X))\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[10010],rank[10010];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t\tpar[x]=y;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint a,b;\n\tdouble len;\n\tedge(){a=b=0;len=0.0;}\n\tedge(int a,int b,double len):a(a),b(b),len(len){};\n\tbool operator<(const edge& a) const{\n\t\treturn len > a.len;\n\t}\n};\nint N,M;\ndouble x[10010],y[10010];\nint p[200010],q[200010];\ndouble dist(int a,int b){\n\treturn sqrt(SQ(x[a]-x[b])+SQ(y[a]-y[b]));\n}\nvector<edge> es;\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tdouble ans = 0.0;\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d %d\",&p[i],&q[i]);\n\t\tp[i]--;\n\t\tq[i]--;\n\t\tes.pb(edge(p[i],q[i],dist(p[i],q[i])));\n\t}\n\tsort(all(es));\n\tuf.init(N);\n\tfor(int i=0;i<es.size();i++){\n\t\tint a = es[i].a;\n\t\tint b = es[i].b;\n\t\tif(uf.same(a,b))ans += es[i].len;\n\t\telse{\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 2604480\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tmemset(used,0,sizeof used);\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nclass UnionFind {\nprivate:\n\tint size_; vector<int> g; vector<vector<int> > v;\npublic:\n\tUnionFind() : size_(0), g(vector<int>()), v(vector<vector<int> >()) {};\n\tUnionFind(int size__) : size_(size__) { g.resize(size_), v.resize(size_); for (int i = 0; i < size_; i++) g[i] = i, v[i] = { i }; };\n\tint size() { return size_; }\n\tint root(int x) { return g[x]; }\n\tint size(int x) { return v[x].size(); }\n\tbool same(int x, int y) { return g[x] == g[y]; }\n\tvoid unite(int x, int y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const UnionFind& u) { return g == u.g; }\n\tbool operator!=(const UnionFind& u) { return g != u.g; }\n\tint operator[](int x) { return g[x]; }\n};\nstruct edge { int s, to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint V, E, x[10009], y[10009], s, t; edge e[99999];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int i = 0; i < V; i++) scanf(\"%d%d\", x + i, y + i);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tint dist = (x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]);\n\t\te[i] = edge{ s, t, dist };\n\t}\n\tsort(e, e + E);\n\treverse(e, e + E);\n\tUnionFind u(V);\n\tdouble ret = 0;\n\tfor (auto &v: e) {\n\t\tif (u.same(v.s, v.to)) ret += sqrt(v.cost);\n\t\telse u.unite(v.s, v.to);\n\t}\n\tprintf(\"%.9f\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<cmath>\nusing namespace std;\nint N, M, fa[10005];\nstruct Edge {\n\tint u, v;\n\tdouble d;\n}edge[50000010];\nstruct Node {\n\tdouble x, y;\n}node[10005];\nbool cmp(Edge x1, Edge x2)\n{\n\treturn x1.d > x2.d;\n}\nint find(int x)\n{\n\tif (x == fa[x])\n\t\treturn x;\n\telse\n\t\treturn fa[x] = find(fa[x]);\n}\ndouble Dist(Node a, Node b)\n{\n\treturn sqrt((a.x - b.x)*(a.x - b.x) + (a.y - b.y)*(a.y - b.y));\n}\nint main()\n{\n\twhile (scanf(\"%d %d\", &N, &M) != EOF)\n\t{\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tfa[i] = i;\n\t\tfor (int i = 1; i <= N; i++)\n\t\t\tscanf(\"%lf %lf\", &node[i].x, &node[i].y);\n\t\tdouble sum = 0.0;\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tedge[i].u = a;\n\t\t\tedge[i].v = b;\n\t\t\tedge[i].d = Dist(node[a],node[b]);\n\t\t\tsum += edge[i].d;\n\t\t}\n\t\tsort(edge, edge + M, cmp);\n\t\tdouble s = 0.0;\n\t\tfor (int i = 0; i<M; i++)\n\t\t{\n\t\t\tint x, y;\n\t\t\tx = find(edge[i].u);\n\t\t\ty = find(edge[i].v);\n\t\t\tif (x != y)\n\t\t\t{\n\t\t\t\tif (x>y)\n\t\t\t\t\tfa[x] = y;\n\t\t\t\telse\n\t\t\t\t\tfa[y] = x;\n\t\t\t\ts = s + edge[i].d;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\t\tdouble ans = 0.0;\n\t\tans = sum - s;\n\t\tprintf(\"%.3f\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <string.h>\n\nusing namespace std;\n\nstruct edge{int u,v; double cost;};\n\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost<e2.cost;\n  }\n\nedge *es;\n\nint rak[10001],par[10001];\nint x[10001],y[10001];\n\nvoid init(int n){\n  for(int i=1; i<=n; i++){\n    par[i]=i;\n    }\n  }\n\nint find(int x){\n  if(par[x]==x){\n    return x;\n    }else{\n    return par[x]=find(par[x]);\n    }\n  }\n\nvoid unite(int x,int y){\n   x=find(x);\n   y=find(y);\n   if(x==y) return;\n\n   if(rak[x]<rak[y]){\n     par[x]=y;\n     }else{\n     par[y]=x;\n     if(rak[x]==rak[y]) rak[x]++;\n     }\n  }\n\nbool same(int x,int y){\n  return find(x)==find(y);\n  }\n\ndouble kruskal(int n,int r){\n  sort(es,es+r,comp);\n  init(n);\n  double res=0;\n  for(int i=0; i<r; i++){\n    edge e = es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n        res+=e.cost;\n      }\n    }\n    return res;\n  }\n\nint main(){\n\n   int N,M;\n   cin>>N>>M;\n\n   es=new edge[M];\n\n   for(int i=1; i<=N; i++){\n\n     cin>>x[i]>>y[i];\n\n     }\n\n   double mx=0;\n\n   for(int i=0; i<M; i++){\n\n     int a,b; cin>>a>>b;\n\n     int p = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n     double c = sqrt(p);\n\n     edge e1={a,b,-c}; es[i]=e1;\n\n     mx+=c;\n\n     }\n\n     printf(\"%.8f\\n\",mx+kruskal(N,M));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n\n//#define LOCAL\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int maxn=1e6+10;\nconst int inf=0x3f3f3f3f;\nint n,m,x[10010],y[10010];\nstruct edge{\n    int u,v;\n    float w;\n}e[maxn];\nint fa[10010];\nfloat dis(int x1,int y1,int x2,int y2)\n{\n    int tmp=(x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);\n    float ans=sqrt(tmp);\n    return ans;\n}\nbool cmp(edge e1,edge e2)\n{\n    return e1.w>e2.w;\n}\nvoid init()\n{\n    for(int i=1;i<=n;i++)\n    {\n        fa[i]=i;\n    }\n}\nint find(int x)\n{\n    if(fa[x]==x)\n    {\n        return x;\n    }\n    else{\n        return fa[x]=find(fa[x]);\n    }\n}\nbool unit(int a,int b)\n{\n    int x=find(a),y=find(b);\n    if(x!=y)\n    {\n        fa[x]=y;\n        return true;\n    }\n    return false;\n}\nfloat kruskal()\n{\n    int cnt=0;\n    float ans=0;\n    init();\n    sort(e+1,e+1+m,cmp);\n    for(int i=1;i<=m;i++)\n    {\n        edge tmp=e[i];\n        if(unit(tmp.u,tmp.v))\n        {\n            cnt++;\n            ans+=tmp.w;\n        }\n        if(cnt==n-1)\n        {\n            break;\n        }\n    }\n    return ans;\n}\nint main()\n{\n#ifdef LOCAL\n    freopen(\"in.txt\",\"r\",stdin);\n#endif\n//    ios_base::sync_with_stdio(false);\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&x[i],&y[i]);\n    }\n    float sum=0;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&e[i].u,&e[i].v);\n        e[i].w=dis(x[e[i].u],y[e[i].u],x[e[i].v],y[e[i].v]);\n        sum+=e[i].w;\n    }\n    printf(\"%.3f\\n\",sum-kruskal());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[12000];\nint N, M, a, b; double x[12000], y[12000], d[12000]; int g[12000];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\tfor (int t = 1; t <= N; t++) {\n\t\tif (g[t] >= 2)continue;\n\t\td[t] = 0; g[t] = 1;\n\t\twhile (true) {\n\t\t\tint OK = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1)OK = 0;\n\t\t\t}\n\t\t\tif (OK == 1)break;\n\t\t\tdouble maxn = -1; int maxid = 0;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[maxid] = 2;\n\t\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SQ(X) ((X)*(X))\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint N,M;\nint x[10010],y[10010];\nint p[10010],q[10010];\nstruct UnionFind{\n\tint par[50010],rank[50010];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t\tpar[x]=y;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint a,b;\n\tdouble len;\n\tedge(){}\n\tedge(int a,int b,double len):a(a),b(b),len(len){};\n\tbool operator<(const edge& a) const{\n\t\treturn len > a.len;\n\t}\n};\ndouble dist(int a,int b){\n\treturn sqrt(SQ(x[a]-x[b])+SQ(y[a]-y[b]));\n}\nvector<edge> es;\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tdouble ans = 0.0;\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d %d\",&p[i],&q[i]);\n\t\tp[i]--;\n\t\tq[i]--;\n\t\tes.pb(edge(p[i],q[i],dist(p[i],q[i])));\n\t}\n\tsort(all(es));\n\tuf.init(50000);\n\tfor(int i=0;i<es.size();i++){\n\t\tint a = es[i].a;\n\t\tint b = es[i].b;\n\t\tif(uf.same(a,b))ans += es[i].len;\n\t\telse{\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <queue>\n\nusing namespace std;\n\nconst int maxn=51;\n\nint p[maxn][maxn];\nint dis[maxn][maxn],ans,sum,w,h,n;\nconst int f[4][2]= {{1,0},{-1,0},{0,1},{0,-1}};\nint x1,x2,y1,y2;\nint sx,sy,tx,ty;\nint x,y;\nqueue<int> Q;\n\nvoid bfs()\n{\n    while(!Q.empty())Q.pop();\n    for(int i=0; i<w; i++)\n        for(int j=0; j<h; j++)\n            dis[i][j]=-1;\n    dis[sx][sy]=0;\n    Q.push(sx);\n    Q.push(sy);\n    while(!Q.empty())\n    {\n        x=Q.front();\n        Q.pop();\n        y=Q.front();\n        Q.pop();\n        for(int i=0; i<4; i++)\n            if((p[x][y]&(1<<i))&&dis[x+f[i][0]][y+f[i][1]]==-1)\n            {\n                dis[x+f[i][0]][y+f[i][1]]=dis[x][y]+1;\n                Q.push(x+f[i][0]);\n                Q.push(y+f[i][1]);\n            }\n    }\n    //printf(\"%d\\n\",dis[tx][ty]);\n}\n\nint main()\n{\n    while(scanf(\"%d%d%d\",&w,&h,&n)==3&&(w||h||n))\n    {\n        for(int i=0; i<w; i++)\n            for(int j=0; j<h; j++)\n            {\n                p[i][j]=0;\n                for(int k=0; k<4; k++)\n                    if(0<=i+f[k][0] && i+f[k][0]<w && 0<=j+f[k][1] && j+f[k][1]<h)\n                        p[i][j]|=1<<k;\n            }\n        while(n--)\n        {\n            scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n            if(x1==x2)\n            {\n                if(x1!=0&&x2!=w)\n                {\n                    for(int i=y1; i<y2; i++)\n                        p[x1-1][i]=p[x1-1][i]&(~1),p[x1][i]=p[x1][i]&(~2);\n                }\n            }\n            if(y1==y2)\n            {\n                if(y1!=0&&y2!=h)\n                {\n                    for(int i=x1; i<x2; i++)\n                        p[i][y1-1]=p[i][y1-1]&(~4),p[i][y1]=p[i][y]&(~8);\n                }\n            }\n        }\n        ans=0;\n        scanf(\"%d%d%d%d\",&sx,&sy,&tx,&ty);\n        bfs();\n        sum=dis[tx][ty];\n        ans=0;\n        for(x1=x2=1; x1<w; x1++,x2++)\n            for(y1=0,y2=1; y2<=h; y1++,y2++)\n            {\n                if((p[x1-1][y1]&1)==0)continue;\n                p[x1-1][y1]^=1;\n                p[x1][y1]^=2;\n                bfs();\n                if(dis[tx][ty]!=-1&&dis[tx][ty]-sum>ans)ans=dis[tx][ty]-sum;\n                p[x1-1][y1]^=1;\n                p[x1][y1]^=2;\n            }\n        for(y1=y2=1; y1<h; y1++,y2++)\n            for(x1=0,x2=1; x2<=w; x1++,x2++)\n            {\n                if((p[x1-1][y1]&4)==0)continue;\n                p[x1-1][y1]^=4;\n                p[x1][y1]^=8;\n                bfs();\n                if(dis[tx][ty]!=-1&&dis[tx][ty]-sum>ans)ans=dis[tx][ty]-sum;\n                p[x1][y1-1]^=4;\n                p[x1][y1]^=8;\n            }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    REP(i, n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(int x, int y) {\n    // ?????????????????????????????????\n    x = find(x);\n    y = find(y);\n\n    // ??¢???????????¨????±?????????????????????????????????????\n    if (x == y) return;\n\n    // x?????¨???y?????¨????????§???????????????????????????\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // x???y??????????????????????????£?????????\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]????????????????????¨???????????§0?????\\????????????????????????\n  }\n\n  // 2???????????????x, y????±?????????¨???????????????true?????????\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // ?????????x?????????????????¨?????§???????????????\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// ??????a, b?????????????????????cost??????????????????\nstruct Edge\n{\n  int a, b;\n  float cost;\n\n  // ??????????????§?°???§????????????\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// ????????°??¨?????????????????¨????????????????????°??????\nstruct Graph\n{\n  int n;  // ????????°\n  vector<Edge> es;  // ?????????\n\n  // ????????????????????§??????????°???¨?????¨??????????????????????¨??????????\n  // ??°??????????????£????????¨??????????°???¨????£?????????????????????¨??????\n  float kruskal() {\n    // ?????????????°??????????????????????\n    RSORT(es);\n\n    UnionFind uf(n);\n    float min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // ????????????????????????????????§???????????????????????????????????¨??????\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    Graph g;\n    g.n = n;\n\n    float cost = 0;\n    vector<pii> piles;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        piles.push_back({x, y});\n    }\n    REP(i, m) {\n        int p, q;\n        cin >> p >> q;\n        p--;\n        q--;\n        pii P = piles[p], Q = piles[q];\n        float c = hypot(P.first - Q.first, P.second - Q.second);\n        cost += c;\n        g.es.push_back({p, q, c});\n    }\n    printf(\"%.03f\", cost - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[120];\nint N, M, a, b; double x[120], y[120], d[120]; int g[120];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\td[1] = 0; g[1] = 1;\n\twhile (true) {\n\t\tint OK = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (g[i] <= 1)OK = 0;\n\t\t}\n\t\tif (OK == 1)break;\n\t\tdouble maxn = -1; int maxid = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t}\n\t\t}\n\t\tg[maxid] = 2;\n\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n//#include <limits>\n#include <math.h>\n//#include <queue>\n//#include <tuple>\n//#include <stdio.h>\n//#include <stdlib.h>\n//#include <string>\n//#include \"string.h\"\n// #include <unordered_map>\n#include <map>\n#include <unordered_set>\n//#include <array>\n#include <set>\n#include <limits>\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224\n\nusing namespace std;\n\nusing ll = long long;\n\n#include <vector>\n\nstruct UnionFind {\n    vector<size_t> parent;\n    vector<size_t> rank;\n    size_t findParent(size_t x) {\n        if (parent[x] == x) {\n            return x;\n        } else {\n            parent[x] = findParent(parent[x]);\n            return parent[x];\n        }\n    }\n    explicit UnionFind(size_t size) {\n        parent.resize(size);\n        rank.resize(size);\n        for (size_t i = 0; i < size; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    virtual ~UnionFind() {}\n    void unite(size_t x, size_t y) {\n        size_t px = findParent(x);\n        size_t py = findParent(y);\n        if (px == py) {\n            return;\n        }\n        if (rank[px] < rank[py]) {\n            parent[px] = py;\n        } else if (rank[px] > rank[py]) {\n            parent[py] = px;\n        } else { // rank[px] == rank[py]\n            parent[py] = px;\n            rank[px]++;\n        }\n    }\n    bool isSame(size_t x, size_t y) {\n        return findParent(x) == findParent(y);\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    struct Pl {\n        int x;\n        int y;\n        Pl(int x, int y) : x(x), y(y) {}\n        double dist(const Pl& rhs) const {\n            return sqrt(pow((double)(x - rhs.x), 2.0) + pow((double)(y - rhs.y), 2.0));\n        }\n    };\n    vector<Pl> piles;\n    piles.reserve(N);\n    for (int i = 0; i < N; i++) {\n        int x, y;\n        cin >> x >> y;\n        piles.emplace_back(x, y);\n    }\n    struct Fc {\n        int a;\n        int b;\n        double len;\n        Fc(int a, int b, double len) : a(a), b(b), len(len) {}\n        static bool compareLen(const Fc& lhs, const Fc& rhs) {\n            return lhs.len > rhs.len;\n        }\n    };\n    vector<Fc> fences;\n    fences.reserve(M);\n    double totalLen = 0.0;\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        double len = piles[a].dist(piles[b]);\n        fences.emplace_back(a, b, len);\n        totalLen += len;\n    }\n    sort(fences.begin(), fences.end(), Fc::compareLen);\n    UnionFind uf(N);\n    double lenSum = 0.0;\n    for (Fc fc : fences) {\n        if (!uf.isSame(fc.a, fc.b)) {\n            uf.unite(fc.a, fc.b);\n            lenSum += fc.len;\n        }\n    }\n    printf(\"%.10lf\\n\", totalLen - lenSum);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind {\nprivate:\n  vector<ll> data;\n\npublic:\n  UnionFind(ll n): data(n, -1) {}\n\n  ll size(ll i) { return -data[find(i)]; }\n  bool root(ll i) { return data[i] < 0; }\n  bool same(ll i, ll j) { return find(i) == find(j); }\n\n  ll find(ll i) { return root(i) ? i : (data[i] = find(data[i])); }\n\n  bool unite(ll i, ll j) {\n    if(same(i, j)) return false;\n    data[find(i)] += data[find(j)];\n    data[find(j)] = find(i);\n    return true;\n  }\n};\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> X(N), Y(N);\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n  vector<pair<double, pair<ll, ll>>> E(M);\n  REP(i, 0, M) {\n    ll P, Q; cin >> P >> Q; P--; Q--;\n    ll dx = X[Q] - X[P];\n    ll dy = Y[Q] - Y[P];\n    E[i] = make_pair(sqrt(dx * dx + dy * dy), make_pair(P, Q));\n  }\n\n  sort(E.begin(), E.end());\n  reverse(E.begin(), E.end());\n\n  double ans = 0;\n  UnionFind uf(N);\n  REP(i, 0, M) {\n    if(!uf.unite(E[i].second.first, E[i].second.second)) {\n      ans += E[i].first;\n    }\n  }\n  printf(\"%.15lf\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>  \n#include <cstdio>  \n#include <cstring>  \n#include <algorithm>  \n#include <cmath>  \n#include <string>  \n#include <map>  \n#include <stack>  \n#include <vector>  \n#include <set>  \n#include <queue>  \n#pragma comment (linker,\"/STACK:102400000,102400000\")  \n#define maxn 10000+10  \n#define MAXN 2005  \n#define mod 1000000009  \n#define INF 0x3f3f3f3f  \n#define pi acos(-1.0)  \n#define eps 1e-6  \n#define lson rt<<1,l,mid  \n#define rson rt<<1|1,mid+1,r  \ntypedef long long ll;  \nusing namespace std;  \n  \nstruct Edge  \n{  \n    int u,v;  \n    double dis;  \n}edge[maxn*maxn/2];  \n  \nint N,M;  \nint father[maxn];  \ndouble x[maxn],y[maxn];  \n  \nint cmp(Edge x,Edge y)  \n{  \n    return x.dis>y.dis;  \n}  \n  \nvoid init(int n)  \n{  \n    for (int i=1;i<=n;i++)  \n        father[i]=i;  \n}  \n  \nint find_father(int x)  \n{  \n    if (x!=father[x])  \n        father[x]=find_father(father[x]);  \n    return father[x];  \n}  \n  \ndouble Kruskal()  \n{  \n    double s=0;  \n    for (int i=0;i<M;i++)  \n    {  \n        int fu=find_father(edge[i].u);  \n        int fv=find_father(edge[i].v);  \n        if (fu!=fv)  \n        {  \n            father[fu]=fv;  \n            s+=edge[i].dis;     //不需要破?的?的?度之和  \n        }  \n    }  \n    return s;  \n}  \n  \nint main()  \n{  \n    while (~scanf(\"%d%d\",&N,&M))  \n    {  \n        init(N);  \n        for (int i=1;i<=N;i++)  \n            scanf(\"%lf%lf\",&x[i],&y[i]);  \n        int u,v;  \n        double sum=0.0;  \n        for (int i=0;i<M;i++)  \n        {  \n            scanf(\"%d%d\",&u,&v);  \n            edge[i].u=u;  \n            edge[i].v=v;  \n            edge[i].dis=sqrt( (x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]) );  \n            sum+=edge[i].dis;       //sum存下所有?的?度之和  \n        }  \n        sort(edge,edge+M,cmp);  \n        printf(\"%.3f\\n\",sum-Kruskal());  \n    }  \n    return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#define P pair<int,int>\n#define N 10005\n#define x first\n#define y second\nusing namespace std;\nint m, n;\nchar c;\nP cord[N];\nstruct edge {\n    int p, q;\n    double t;\n} e[N * N / 2];\nbool cmp(edge a, edge b) {\n    return a.t > b.t;\n}\nint p[N];\nint find(int x) {\n    return p[x] < 0 ? x : (p[x] = find(p[x]));\n}\ninline void merge(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (p[x] > p[y]) p[x] = y;\n    else {\n        p[y] = x;\n        if (p[x] == p[y])--p[x];\n    }\n}\ninline bool same(int x, int y) {\n    return find(x) == find(y);\n}\nint main() {\n    while ((~scanf(\"%d %d\", &n, &m)) && m && n) {\n        for (int i = 1; i <= n; ++i) scanf(\"%d %d\", &cord[i].x, &cord[i].y);\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", &e[i].p, &e[i].q);\n            e[i].t = sqrt((cord[e[i].p].x - cord[e[i].q].x) *\n                          (cord[e[i].p].x - cord[e[i].q].x) * 1.0\n                          + (cord[e[i].p].y - cord[e[i].q].y) *\n                          (cord[e[i].p].y - cord[e[i].q].y));\n        }\n        for (int i = 1; i <= n; ++i) p[i] = -1;\n        sort(e, e + m, cmp);\n        double ans = 0.0;\n        for (int i = 0; i < m; ++i) {\n            if (!same(e[i].p, e[i].q)) merge(e[i].p, e[i].q);\n            else ans += e[i].t;\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cmath>\nconst int maxn =10007;\nconst int mx   =2e6+7;\nusing namespace std;\nint n,m,fa[maxn];\nstruct node {\n\tint from;\n\tint to;\n\tdouble r;\n}a[mx];\nstruct nn{\n\tint x,y;\n}p[maxn];\n\nbool cmp(node a,node b)\n{\n\treturn a.r>b.r;\n}\nvoid init(){\n\tfor(int i=1;i<=n;i++)\n\t\tfa[i] = i;\n\tmemset(a,0,sizeof(a));\n\tmemset(p,0,sizeof(p));\n}\nint find(int x)\n{\n\tif(fa[x]==x)return x;\n\telse return fa[x] = find (fa[x]);\n}\nbool uni(int x,int y)\n{\n\tint px = find(x);\n\tint py = find (y);\n\tif(px==py)return false;\n\tfa[px] = py;\n\treturn true;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tinit();\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tp[i].x=x;\n\t\tp[i].y=y;\n\t}\n\tdouble sum = 0,res=0;\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tdouble tmp = sqrt((p[u].x-p[v].x)*(p[u].x-p[v].x)+(p[u].y-p[v].y)*(p[u].y-p[v].y));\n\t\ta[i].from=u;\n\t\ta[i].to=v;\n\t\ta[i].r = tmp;\n\t\tsum+=tmp;\n\t}\n\tsort(a+1,a+1+m,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint u = a[i].from;\n\t\tint v = a[i].to;\n\t\tif(uni(u,v))res+=a[i].r;\n\t}\n\tprintf(\"%.3lf\\n\",sum-res);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nstruct edge {\n  int from;\n  int to;\n  ld cost;\n};\nbool operator<(const edge&l, const edge&r) {\n  return l.cost < r.cost;\n}\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\nint main() {\n  int N, M; cin >> N >> M;\n  vector<pair<ld, ld>>ps;\n  for (int i = 0; i < N; ++i) {\n    ld x, y; cin >> x >> y;\n    ps.emplace_back(x, y);\n  }\n  vector < edge>edges;\n  \n  for (int i = 0; i < M; ++i) {\n    int a, b; cin >> a >> b; a--; b--;\n    ld dis = sqrt((ps[a].first - ps[b].first)*(ps[a].first - ps[b].first) + (ps[a].second - ps[b].second)*(ps[a].second - ps[b].second));\n    edges.push_back(edge{ a,b,dis });\n  }\n  sort(edges.begin(), edges.end());\n  reverse(edges.begin(), edges.end());\n  UnionFind uf(N);\n  ld ans = 0;\n  for (int i = 0; i < M; ++i) {\n    edge e(edges[i]);\n    if(uf.root(e.from) != uf.root(e.to)) {\n      uf.unionSet(e.from, e.to);\n    }\n    else {\n      ans += e.cost;\n    }\n  }\n  cout <<fixed<<setprecision(22)<< ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxm 100005\n#define maxn 10005\nusing namespace std;\ntypedef long long ll;\nstruct edge{\n\tint from,to;\n\tdouble cst;\n\tbool operator <(const edge e)const\n\t{\n\t\treturn cst > e.cst;\n\t}\n}el[maxm];\nint par[maxn],hei[maxn],E,n,m,x[maxn],y[maxn];\ndouble tot,ans;\ninline void ini(int x){\n\tfor(int i=1;i<=x;i++){\n\t\tpar[i] = i;\n\t\thei[i] = 1;\n\t}\n}\nint fin(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = fin(par[x]);\n}\ninline void uni(int x,int y){\n\tx = fin(x);y = fin(y);\n\tif(x==y) return;\n\tif(hei[x] < hei[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(hei[x] == hei[y]) hei[x]++;\n\t}\n}\ninline bool same(int x,int y){\n\treturn fin(x) == fin(y);\n}\ninline void kruskal(){\n\tini(n);\n\tsort(el+1,el+E+1);\n\tfor(int i=1;i<=E;i++){\n\t\tif(!same(el[i].from,el[i].to)){\n\t\t\tuni(el[i].from,el[i].to);\n\t\t\tans += el[i].cst;\n\t\t}\n\t}\n\tprintf(\"%.5lf\\n\",tot - ans);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tel[++E].from = u;\n\t\tel[E].to = v;\n\t\tel[E].cst = sqrt((x[u]-x[v])*(x[u]-x[v])+(y[u]-y[v])*(y[u]-y[v]));\n\t\ttot += el[E].cst;\n\t}\n\tkruskal();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[120];\nint N, M, a, b; double x[120], y[120], d[120]; int g[120];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\tfor (int t = 1; t <= N; t++) {\n\t\tif (g[t] >= 2)continue;\n\t\td[t] = 0; g[t] = 1;\n\t\twhile (true) {\n\t\t\tint OK = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1)OK = 0;\n\t\t\t}\n\t\t\tif (OK == 1)break;\n\t\t\tdouble maxn = -1; int maxid = 0;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[maxid] = 2;\n\t\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nclass UnionFind {\nprivate:\n\tint size_; vector<int> g; vector<vector<int> > v;\npublic:\n\tUnionFind() : size_(0), g(vector<int>()), v(vector<vector<int> >()) {};\n\tUnionFind(int size__) : size_(size__) { g.resize(size_), v.resize(size_); for (int i = 0; i < size_; i++) g[i] = i, v[i] = { i }; };\n\tint size() { return size_; }\n\tint root(int x) { return g[x]; }\n\tint size(int x) { return v[x].size(); }\n\tbool same(int x, int y) { return g[x] == g[y]; }\n\tvoid unite(int x, int y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const UnionFind& u) { return g == u.g; }\n\tbool operator!=(const UnionFind& u) { return g != u.g; }\n\tint operator[](int x) { return g[x]; }\n};\nstruct edge { int s, to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint V, E, x[10009], y[10009], s, t; edge e[99999];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int i = 0; i < V; i++) scanf(\"%d%d\", x + i, y + i);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tint dist = (x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]);\n\t\te[i] = edge{ s, t, dist };\n\t}\n\tsort(e, e + E);\n\treverse(e, e + E);\n\tUnionFind u(V);\n\tdouble ret = 0;\n\tfor (auto &v: e) {\n\t\tif (u.same(v.s, v.to)) ret += sqrt(v.cost);\n\t\telse u.unite(v.s, v.to);\n\t}\n\tprintf(\"%.9f\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nint n, m, cnt;\nint f[10010];\nstruct Point{\n\tint x, y, id;\n}point[10010];\n\nstruct Edge{\n\tint form, to;\n\tdouble dis;\n}edge[10010 * 10010];\n\nint Find(int x){\n\treturn f[x] == x ? x : f[x] = Find(f[x]);\n}\n\nvoid Union(int x, int y){\n\tint fx = Find(x);\n\tint fy = Find(y);\n\tif(fx != fy)\n\tf[fy] = fx;\n}\nvoid Addedge(int form, int to, double dis){\n\tedge[cnt].form = form;\n\tedge[cnt].to = to;\n\tedge[cnt++].dis = dis;\n}\n\ndouble dis(Point x, Point y){\n\treturn sqrt(1.0*(x.x - y.x)*(x.x - y.x) + 1.0 * (x.y - y.y)*(x.y - y.y));\n}\nbool cmp1(Edge a, Edge b){\n\treturn a.dis > b.dis;\n}\n\ndouble Kruskal(){\n\tsort(edge, edge + cnt, cmp1);\n\tfor(int i = 1; i <= n; i++)\n\tf[i] = i;\n\tdouble sum = 0;\n\tint tot = 0;\n\tint i;\n\tfor(i = 0; i < cnt; i++){\n\t\tif(Find(edge[i].form) == Find(edge[i].to)){\n\t\t\tsum += edge[i].dis;\n\t\t\tcontinue;\t\n\t\t} \n\t\tUnion(edge[i].form, edge[i].to);\n\t}\n\treturn sum;\n}\nint main(){\n\twhile(~scanf(\"%d%d\", &n, &m)){\n\t\tcnt = 0;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin>>point[i].x>>point[i].y;\n\t\t\tpoint[i].id = i;\n\t\t}\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint a, b;\n\t\t\tdouble w;\n\t\t\tcin>>a>>b;\n\t\t\tw = dis(point[a], point[b]);\n\t\t\tAddedge(a, b, w);\n\t\t}\n\t\tprintf(\"%.3f\\n\", Kruskal());\t\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> parent;\n    vector<int> myrank;\n    //親は小さい\n    UnionFind(int n) : parent(n,-1), myrank(n,0) { }\n    bool Find(int x, int y){\n        return find_root(x) == find_root(y); \n    }\n    int find_root(int x){\n        if(parent[x] < 0){\n            return x;\n        }else{\n            return parent[x] = find_root(parent[x]);\n        }\n    }\n    bool Union(int x, int y){\n        x = find_root(x); y = find_root(y);\n\n        if(x != y){\n            if(myrank[y] < myrank[x]){\n                swap(x,y);\n            }\n            parent[x] += parent[y]; parent[y] = x;\n            if(myrank[x] == myrank[y]) myrank[x]++;\n            return true;\n        }else{\n            return false;\n        }\n    }\n    int size(int x){\n        return -parent[find_root(x)];\n    }\n};\n\nstruct UEdge {\n    int a, b;\n    double len=1.0;\n    \n    UEdge(int a, int b, double len) : a(a), b(b), len(len) {}\n\n    bool operator <(const UEdge &rhs) const{\n        if (len != rhs.len) return len < rhs.len;\n        if (a != rhs.a) {return a < rhs.a;}\n        return b < rhs.b;\n    }\n    bool operator >(const UEdge &rhs) const{\n        if (len != rhs.len) return len > rhs.len;\n        if (a != rhs.a) {return a > rhs.a;}\n        return b > rhs.b;\n    }\n    bool operator <=(const UEdge &rhs) const{\n        if (len != rhs.len) return len < rhs.len;\n        if (a != rhs.a) {return a < rhs.a;}\n        return b <= rhs.b;\n    }\n    bool operator >=(const UEdge &rhs) const{\n        if (len != rhs.len) return len > rhs.len;\n        if (a != rhs.a) {return a > rhs.a;}\n        return b >= rhs.b;\n    }\n};\n\nstruct Point {\n    double a, b;\n\n    Point(double a, double b) : a(a), b(b) {}\n\n};\ndouble dist(Point &p1, Point &p2){\n    return sqrt((p1.a - p2.a)*(p1.a - p2.a) + (p1.b - p2.b)*(p1.b-p2.b));\n}\n\n\nint main(){\n    int N, M;\n    double x, y;\n    double tmp,total=0;\n    int a, b;\n    vector<UEdge> edges; \n    vector<Point> points;\n    cin >> N >> M;\n    for(int i=0; i< N; i++){\n        cin >> x >> y;\n        points.push_back(Point(x,y));\n    }\n    for(int i=0; i< M; i++){\n        cin >> a >> b;\n        a--;b--;\n        tmp = dist(points[a],points[b]);\n        total += tmp;\n        edges.push_back(UEdge(a,b,-tmp));\n    }\n    sort(edges.begin(), edges.end());\n    UnionFind uf(N);\n    int count = 0;\n    for(vector<UEdge>::iterator itr = edges.begin(); count < N-1 && itr != edges.end() ; itr++){\n        if( !uf.Find(itr->a, itr->b)){\n            uf.Union(itr->a, itr->b);\n            total += itr->len;\n            count++;\n        }\n    }\n    cout << total << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N + 1], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N + 1; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      k = 0;\n      while(forest[j][k] != 0 && k < N) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      j = 0;\n      while(forest[t1][j] != 0)\n\tj++;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nclass Point{\npublic:\n    double x,y;\n    Point();\n    Point(double _x,double _y);\n};\nconst int MAX = 10010;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-5;\nPoint p[MAX];\nint N,M;\nclass Edge{\npublic:\n    int u,v;\n    double w;\n    Edge();\n    Edge(int _u,int _v,double _w);\n};\nvector<Edge> vec;\nint pre[MAX];\nvoid init(){\n    for(int i=1;i<=N;++i){\n        pre[i] = i;\n    }\n}\ndouble getLen(int u,int v){\n    double res = (p[u].x-p[v].x)*(p[u].x-p[v].x) + (p[u].y-p[v].y)*(p[u].y-p[v].y);\n    return sqrt(res);\n}\nint F(int x){\n    int r = x;\n    while(pre[r] != r)\n        r = pre[r];\n    int i = x,j;\n    while(pre[i] != r){\n        j = pre[i];\n        pre[i] = r;\n        i = j;\n    }\n    return r;\n}\nbool cmp(Edge A,Edge B){\n    return (A.w - B.w > eps);\n}\nint main(void){\n    cin >> N >> M;\n    init();\n    for(int i=1;i<=N;++i){\n        cin >> p[i].x >> p[i].y;\n    }\n    double sum = 0;\n    int u,v;\n    for(int i=1;i<=M;++i){\n        cin >> u >> v;\n        double len = getLen(u,v);\n        sum += len;\n        vec.push_back(Edge(u,v,len));\n    }\n    sort(vec.begin(),vec.end(),cmp);\n    double res = 0;\n    int Count = 0;\n    for(vector<Edge>::iterator it = vec.begin();it != vec.end();++it){\n        int fx = F(it->u);\n        int fy = F(it->v);\n        if(fx != fy){\n            res += it->w;\n            pre[fx] = fy;\n            Count++;\n        }\n        if(Count == N-1)\n            break;\n    }\n    cout << fixed << setprecision(3) << sum-res << endl;\n    return 0;\n}\n\nPoint::Point(){\n    x = y = 0;\n}\nPoint::Point(double _x,double _y){\n    x = _x;\n    y = _y;\n}\nEdge::Edge(){\n    u = v = 0;\n    w = 0;\n}\nEdge::Edge(int _u,int _v,double _w){\n    u = _u;\n    v = _v;\n    w = _w;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par, rank;\n    \n    UnionFind(int n = 210000) { init(n); }\n    void init(int n = 210000) {\n        par.resize(n); rank.resize(n);\n        for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;\n    }\n    \n    int root(int x) {\n        if (par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        return true;\n    }\n};\n\ntypedef pair<int,int> pint;\ntypedef pair<double,pint> Edge;\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<double> x(N), y(N); for (int i = 0; i < N; ++i) cin >> x[i] >> y[i];\n    vector<Edge> edges;\n    double all = 0;\n    for (int i = 0; i < M; ++i) {\n        int u, v; cin >> u >> v; --u, --v;\n        double dis = sqrt((x[u]-x[v])*(x[u]-x[v]) + (y[u]-y[v])*(y[u]-y[v]));\n        edges.push_back(Edge(dis, pint(u, v)));\n        all += dis;\n    }\n    sort(edges.rbegin(), edges.rend());\n    UnionFind uf(N);\n    double hosyu = 0;\n    for (auto e : edges) {\n        int u = e.second.first, v = e.second.second;\n        if (uf.issame(u, v)) continue;\n        hosyu += e.first;\n        uf.merge(u, v);\n    }\n    cout << fixed << setprecision(10) << all - hosyu << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define INF 100000000000000000\n#define MAX_N 500000\npriority_queue<pair<long double, long long>, vector<pair<long double, long long>>, less<pair<long double, long long>>>Q;\nvector<pair<long long, long double>>X[MAX_N]; long long WHITE = 0, GRAY = 1, BLACK = 2;\nlong long COLOR[MAX_N], DIST[MAX_N], POINT[MAX_N], N, M, A, B;long double C, X1[MAX_N], Y1[MAX_N];\nlong long classcal() {\n\tfor (int i = 0; i < MAX_N; i++) { POINT[i] = INF; DIST[i] = 0; COLOR[i] = WHITE; }\n\tDIST[1] = 0; COLOR[1] = GRAY; Q.push(make_pair(0, 1));\n\twhile (!Q.empty()) {\n\t\tpair<long double, long long>pa = Q.top(); Q.pop();\n\t\tlong double a1 = pa.first;long long a2 = pa.second;\n\t\tCOLOR[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first; long double dist = X[a2][i].second;\n\t\t\tif (DIST[to] < dist && COLOR[to] < BLACK) {\n\t\t\t\tfor (int j = 0; j < X[to].size(); j++) {\n\t\t\t\t\tif (X[to][j].first == a2) { POINT[to] = j; }\n\t\t\t\t}\n\t\t\t\tDIST[to] = dist; Q.push(make_pair(DIST[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong double sum = 0;\n\tfor (int i = 1; i <= N; i++) { if (POINT[i] < INF) { sum += X[i][POINT[i]].second; } }\n\treturn sum;\n}\nint main() {\n\tcin >> N >> M; long double S = 0;\n\tfor (int i = 0; i < N; i++) { cin >> X1[i] >> Y1[i]; }\n\tfor (int i = 0; i < M; i++) { cin >> A >> B; C = sqrt(pow(X1[A] - X1[B], 2) + pow(Y1[A] - Y1[B], 2)); S += C; X[A].push_back(make_pair(B, C)); X[B].push_back(make_pair(A, C)); }\n\tcout << S - classcal() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\n\n\nclass UnionFind\n{\npublic:\n\tvector<int> data;\n\tUnionFind(int size):data(size, -1){}\n\t\n\tbool unionSet(int x, int y)\n\t{\n\t\tx = root(x); y=root(y);\n\t\tif(x != y)\n\t\t{\n\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\t\n\tint root(int x)\n\t{\n\t\treturn data[x] < 0 ? x:data[x]=root(data[x]);\n\t}\n};\n\nclass Edge\n{\npublic:\n\tint s,d;\n\tdouble c;\n\t\n\tEdge(int s, int d, double c)\n\t:s(s), d(d), c(c)\n\t{}\n\t\n\tbool operator<(const Edge& a) const\n\t{\n\t\treturn (c<a.c);\n\t}\n};\n\n\n\ndouble kruskal(int N, priority_queue<Edge>& q)\n{\n\tUnionFind uf(N);\n\tdouble res = 0;\n\twhile(!q.empty())\n\t{\n\t\tEdge e = q.top(); q.pop();\n\t\t\n\t\tif(!uf.unionSet(e.s, e.d))\n\t\t{\n\t\t\tres+=e.c;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\n\tvector<P> piles(N);\n\tfor(int i=0; i<N; i++){\n\t\tdouble a,b;\n\t\tcin >> a >> b;\n\n\t\tpiles[i] = P(a,b); \n\t}\n\n\tpriority_queue<Edge> q;\n\tfor(int i=0; i<M; i++) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tq.push(Edge(a,b,abs(piles[a]-piles[b])));\n\t}\n\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\tcout << kruskal(N,q) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <stdint.h>\n#define INF 0x3f3f3f3f\n\nusing namespace std;\n\nint n,m;\nconst int N = 10010;\nint a[N][2],book[N];\nstruct node\n{\n    int from,to;\n    double cost;\n}b[N*N/2];\n\nint cmp(struct node x,struct node y)\n{\n    return x.cost > y.cost;\n}\n\nint father(int x)\n{\n    int f = x;\n    while(f != book[f])\n        f = book[f];\n    int p = x;\n    while(p != book[p])\n    {\n        int q = book[p];\n        book[p] = f;\n        p = q;\n    }\n    return f;\n}\n\ndouble bellman()\n{\n    double ans = 0;\n    for(int i = 1; i <= n; i++)\n        book[i] = i;\n    for(int i = 1; i <= m; i++)\n    {\n        if(father(b[i].from) != father(b[i].to))\n            book[father(b[i].from)] = father(b[i].to);\n        else\n            ans += b[i].cost;\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>n>>m;\n    for(int i = 1; i <= n; i++)\n        cin>>a[i][0]>>a[i][1];\n    for(int i = 1; i <= m; i++)\n    {\n        cin>>b[i].from>>b[i].to;\n        int x1 = a[b[i].from][0],y1 = a[b[i].from][1];\n        int x2 = a[b[i].to][0],y2 = a[b[i].to][1];\n        b[i].cost = sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n    }\n    sort(b+1,b+1+m,cmp);\n    printf(\"%.3f\\n\",bellman());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nconst int MAXN=int(1e7)+5;\nint n,m;\nint fa[MAXN];\nstruct node {\n\tint u,v;\n\tdouble val;\n}e[MAXN];\nint cmp(node a,node b) {\n\treturn a.val>b.val;\n}\nvoid Init() {\n\tfor(int i=0;i<MAXN;i++)\n\t\tfa[i]=i;\n}\nint Find(int x) {\n\tif(x==fa[x])\n\t\treturn x;\n\treturn fa[x]=Find(fa[x]);\n}\nbool Merge(int x,int y) {\n\tint fx=Find(x),fy=Find(y);\n\tif(fx!=fy) {\n\t\tfa[fx]=fy;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint cor[MAXN][3];\nvoid Build(double &ans) {\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&cor[i][1],&cor[i][2]);\n\tfor(int i=1;i<=m;i++) {\n        int a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te[i].u=a-1,e[i].v=b-1;\n\t\te[i].val=sqrt((cor[a][1]-cor[b][1])*(cor[a][1]-cor[b][1])+(cor[a][2]-cor[b][2])*(cor[a][2]-cor[b][2]));\n\t\tans+=e[i].val;\n\t}\n}\nint main()\n{\n\twhile(~scanf(\"%d%d\",&n,&m)) {\n\t\tInit();\n\t\tdouble ans=-1;\n\t\tBuild(ans);\n\t\tsort(e+1,e+m+1,cmp);\n\t\tfor(int i=1;i<=m;i++)\n\t\t\tif(Merge(e[i].u,e[i].v))\n\t\t\t\tans-=e[i].val;\n\t\tprintf(\"%.3lf\\n\",ans+1.0);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int n):data(n, -1){}\n  int find(int x) { return data[x] < 0 ? x : data[x] = find(data[x]); }\n  bool same(int x, int y) { return find(x) == find(y); }\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return;\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y]; data[y] = x;\n  }\n};\n\nstruct Point {\n  double x, y;\n  Point(){}\n  Point(double x, double y):x(x), y(y){}\n  Point operator + (Point p) { return Point(x+p.x, y+p.y); }\n  Point operator - (Point p) { return Point(x-p.x, y-p.y); }\n};\n\ndouble norm(Point p) {\n  return p.x*p.x+p.y*p.y;\n}\ndouble abs(Point p) {\n  return sqrt(norm(p));\n}\ndouble dist(Point a, Point b) {\n  return abs(a-b);\n}\n\nstruct edge {\n  int u, v;\n  double w;\n  edge(){}\n  edge(int u, int v, double w):u(u), v(v), w(w){}\n  bool operator < (const edge& e) const {\n    return w > e.w;\n  }\n};\n\nint N, M;\nvector<Point> P;\nvector<edge> E;\n\ndouble kruskal() {\n  UnionFind uf(N);\n  sort(all(E));\n  double res = 0;\n  for(edge &e : E) {\n    if(!uf.same(e.u, e.v)) {\n      uf.unite(e.u, e.v);\n      res += e.w;\n    }\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M;\n  rep(i, N) {\n    Point p;\n    cin >> p.x >> p.y;\n    P.push_back(p);\n  }\n  double sum = 0;\n  rep(i, M) {\n    int p, q;\n    cin >> p >> q;\n    --p, --q;\n    double cost = dist(P[p], P[q]);\n    E.push_back(edge(p, q, cost));\n    sum += cost;\n  }\n  cout << sum - kruskal() << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\ntypedef pair<int, int> P;\n\nint const MAX_N  = 10000;\nint N, M;\nP piles[MAX_N];\n\ndouble distance(int x0, int y0, int x1, int y1) {\n    return hypot(x1-x0, y1-y0);\n}\n\n// O(E*log(V))\nstruct Edge {\n    Edge(int a, int b, double c) {\n        u = a; v = b; cost = c;\n    }\n    int u, v;\n    double cost;\n};\n\nbool comp(const Edge& e1, const Edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nstruct UF{\n    vector<int> par;\n    UF(int m) : par(m){\n        for(int i = 0; i < m; i++){\n            par[i] = i;\n        }\n    }\n    int find(int x){\n        return x != par[x] ? par[x] = find(par[x]) : x;\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    void unite(int x, int y){\n        // y is above\n        if(!same(x, y)) par[find(x)] = find(y);\n    }\n};\n\ndouble kruskal(int V, vector<Edge>& es) {\n    sort(es.begin(), es.end(), comp);\n    UF uf(V);\n    double res = 0;\n    for(int i = es.size()-1; i >= 0; i--) {\n        Edge e = es[i];\n        if(!uf.same(e.u, e.v)) {\n            uf.unite(e.u, e.v);\n        } else {\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvector<Edge> es;\n\nint main() {\n    cin >> N >> M;\n    int x, y;\n    for(int i = 0; i < N; i++) {\n        cin >> x >> y;\n        piles[i] = P(x, y);\n    }\n    int j, k;\n    double s = 0;\n    for(int i = 0; i < M; i++) {\n        cin >> j >> k;\n        j--; k--;\n        P p1 = piles[j], p2 = piles[k];\n        double d = distance(p1.first, p1.second, p2.first, p2.second);\n        s += d;\n        es.push_back(Edge(j, k, d));\n    }\n    printf(\"%.5f\\n\", kruskal(N, es));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define MAX 10005\n\nstruct edge { int u , v; double cost; };\nstruct node {double x , y; };\nbool comp(const edge& e1 , const edge& e2){\n    return e1.cost > e2.cost;\n}\n\nint V , E;\nint par[MAX], rank[MAX];\nnode node[MAX];\nstd::vector <edge> vec;\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++){\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]){ \n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ndouble kruskal(){\n    std::sort(vec.begin() , vec.end() , comp);\n    init(V);\n    double res = 0;\n    for(int i = 0;i < E;i++){\n        edge e = vec[i];\n        if(find(e.u) != find(e.v)){\n            unite(e.u , e.v);\n        }else{\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    std::cin >> V >> E;\n    for(int i = 1;i <= V;i++){\n        std::cin >> node[i].x >> node[i].y;\n    }\n    for(int i = 0;i < E;i++){\n        int p , q;\n        std::cin >> p >> q;\n        edge e0;\n        e0.u = p , e0.v = q , e0.cost = std::sqrt(std::pow((node[p].x - node[q].x) , 2) + std::pow((node[p].y - node[q].y) , 2));\n        vec.push_back(e0);\n    }\n    std::cout << kruskal() << \"\\n\";\n    vec.clear();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define MAX_N 1005\n#define MAX_R 20005\nusing namespace std;\n\ntypedef struct edge\n{\n\tint from,to,cost;\n} edge;\n\nbool mcmp(edge x,edge y)\n{\n\treturn x.cost<y.cost;\n}\n\nint uft[MAX_N];\nvector<edge>e;\n\nvoid init(int n)\n{\n\tint i;\n\tfor (i=0;i<=n;i++)\n\tuft[i]=i;\n}\n\nint parent(int n)\n{\n\tif (uft[n]==n)\n\t\treturn n;\n\telse\n\t\treturn uft[n]=parent(uft[n]);\n}\n\nvoid unit(int p, int q)\n{\n\tuft[parent(p)]=parent(q);\n}\n\nint same(int p, int q)\n{\n\treturn parent(p)==parent(q);\n}\n\nint kruskal(int n,int r)\n{\n\tint res=0;\n\tsort(e.begin(),e.end(),mcmp);\n\tinit(n);\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tedge tmp=e[i];\n\t\tif(!same(tmp.from,tmp.to))\n\t\t{\n\t\t\tres+=tmp.cost;\n\t\t\tunit(tmp.from,tmp.to);\n\t\t\te[i].cost=0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint piles[10001][2];\nint m_distance(int f,int t)\n{\n\treturn pow((double)piles[f][0]-piles[t][0],2)+pow((double)piles[f][1]-piles[t][1],2);\n}\n\nint main()\n{\n\tint N,M;\n\tint all_cost=0;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&piles[i][0],&piles[i][1]);\n\tfor(int j=0;j<M;j++)\n\t{\n\t\tedge tmp;\n\t\tscanf(\"%d%d\",&tmp.from,&tmp.to);\n\t\ttmp.cost=-m_distance(tmp.from,tmp.to);\n\t\te.push_back(tmp);\n\t}\n\tkruskal(N,M);\n\tdouble res=0.0;\n\tfor(int i=0;i<M;i++)\n\t\tres+=sqrt(-(double)e[i].cost);\n\tprintf(\"%.3lf\\n\",res);\n\te.clear();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint par[1001],rank[1001];\nvoid init(int n){\n  for(int i=0;i<n;i++)\n    par[i]=i,rank[i]=1;\n}\nint find(int x){\n  if(par[x]==x)return x;\n  else return par[x]=find(par[x]);\n}\nvoid unit(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y;\n  else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\nstruct edge{int u,v;double cost;};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost>e2.cost;\n}\nedge es[10001];\nint V,E;\ndouble kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  double res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unit(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}\nint main(){\n  cin>>V>>E;\n  double p[V][2],sum=0;\n  r(i,V)cin>>p[i][0]>>p[i][1];\n  r(i,E){\n    int a,b;\n    cin>>a>>b;a--;b--;\n    es[i].u=a;es[i].v=b;\n    es[i].cost=sqrt((p[a][0]-p[b][0])*(p[a][0]-p[b][0])+(p[a][1]-p[b][1])*(p[a][1]-p[b][1]));\n    sum+=es[i].cost;\n  }\n  printf(\"%.10f\\n\",sum-kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n#define MAX 10005\n#define MAXE MAX * (MAX - 1) / 2 + 1\n\nstruct edge { int u , v; double cost; };\nstruct node { double x , y; };\nbool comp(const edge& e1 , const edge& e2){\n    return e1.cost > e2.cost;\n}\n\nint V , E;\nint par[MAX], rank[MAX];\nnode node[MAX];\nedge es[MAXE];\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++){\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]){ \n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ndouble kruskal(){\n    std::sort(es , es + E , comp);\n    init(V);\n    double res = 0;\n    for(int i = 0;i < E;i++){\n        edge e = es[i];\n        if(find(e.u) != find(e.v)){\n            unite(e.u , e.v);\n        }else{\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    std::cin >> V >> E;\n    for(int i = 1;i <= V;i++){\n        std::cin >> node[i].x >> node[i].y;\n    }\n    for(int i = 0;i < E;i++){\n        std::cin >> es[i].u >> es[i].v;\n        es[i].cost = std::sqrt(std::pow((node[es[i].u].x - node[es[i].v].x) , 2) + std::pow((node[es[i].u].y - node[es[i].v].y) , 2));\n    }\n    std::cout << std::fixed << std::setprecision(3) << kruskal() << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\tfor (int p = 0; p < V; p++)\n\t{\n\t\tif (u[p] == true) { continue; }\n\n\t\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\t\tque.push(make_pair(0.0, 0));\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\t\tint v = r.second;\n\n\t\t\tif (u[v]) { continue; }\n\n\t\t\tres += r.first; u[v] = true;\n\n\t\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t\t{\n\t\t\t\tif (!u[G[v][i].first])\n\t\t\t\t{\n\t\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ret = 0.0;\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret += G[i][j].second;\n\t\t}\n\t}\n\n\tret = ret / 2 - res;\n\n\tprintf(\"%.9f\\n\", 100000.0 * (E - V + 1) - ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint N, M;\n\nstruct Edge {\n  int na, nb;  // Edge connects node a, node b, index in nodes.\n  double cost;\n};\n\n\nvector<Edge> edges;  // M\n\nstruct To {\n  int dx;\n  int dy;\n  int place;\n  int edge;\n  int other_node;\n};\n\nstruct Node {\n  int x, y;\n  vector<To> to;  // sorted edges.\n};\n\nvector<Node> nodes;  // N\n\nunordered_map<int, int> node_pos_map;\n\nbool compareEdge(const Edge& e1, const Edge& e2) {\n  return e1.cost < e2.cost;\n}\n\n/*\nplaces:\n\n  6  7   0\n 5 __| __  1\n   4 |  2\n     3\n*/\n\nint getPlace(int dx, int dy) {\n  if (dx > 0) {\n    if (dy > 0) {\n      return 0;\n    } else if (dy == 0) {\n      return 1;\n    } else {\n      return 2;\n    }\n  } else if (dx == 0) {\n    if (dy < 0) {\n      return 3;\n    } else {\n      return 7;\n    }\n  } else {\n    if (dy < 0) {\n      return 4;\n    } else if (dy == 0) {\n      return 5;\n    } else {\n      return 6;\n    }\n  }\n}\n\nbool compareTo(const To& t1, const To& t2) {\n  if (t1.place != t2.place) {\n    return t1.place < t2.place;\n  }\n  double k1 = (double)t1.dy / t1.dx;\n  double k2 = (double)t2.dy / t2.dx;\n  return k1 > k2;\n}\n\nvoid constructTo() {\n  for (int i = 0; i < M; ++i) {\n    int a = edges[i].na;\n    int b = edges[i].nb;\n    To to;\n    to.dx = nodes[b].x - nodes[a].x;\n    to.dy = nodes[b].y - nodes[a].y;\n    to.place = getPlace(to.dx, to.dy);\n    to.edge = i;\n    to.other_node = b;\n    nodes[a].to.push_back(to);\n    to.dx = -to.dx;\n    to.dy = -to.dy;\n    to.place = getPlace(to.dx, to.dy);\n    to.other_node = a;\n    nodes[b].to.push_back(to);\n  }\n  for (int i = 0; i < N; ++i) {\n    sort(nodes[i].to.begin(), nodes[i].to.end(), compareTo);\n  }\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < nodes[i].to.size(); ++j) {\n      int other = nodes[i].to[j].other_node;\n      node_pos_map[(i << 16) | other] = j;\n    }\n  }\n}\n\nvector<int> set;  // used for union set, 2 * M\n\nint findRoot(int p) {\n  int root = p;\n  while (set[root] != -1) {\n    root = set[root];\n  }\n  while (p != root) {\n    int t = set[p];\n    set[p] = root;\n    p = t;\n  }\n  return root;\n}\n\nvoid unionSet(int p, int q) {\n  //printf(\"unionSet(%d, %d)\\n\", p, q);\n  int root1 = findRoot(p);\n  int root2 = findRoot(q);\n  if (root1 != root2) {\n    set[root1] = root2;\n  }\n}\n\nvoid visitAllSides() {\n  vector<bool> visited(2 * M, false);\n  for (int side = 0; side < 2 * M; ++side) {\n    if (visited[side]) {\n      continue;\n    }\n    int edge = side / 2;\n    int start, prev, cur;\n    if (side % 2 == 0) {\n      start = prev = edges[edge].na;\n      cur = edges[edge].nb;\n    } else {\n      start = prev = edges[edge].nb;\n      cur = edges[edge].na;\n    }\n    int prev_side = side;\n    while (!visited[prev_side]) {\n      visited[prev_side] = true;\n      int pos = node_pos_map[(cur << 16) | prev];\n      int next_pos = pos - 1;\n      if (next_pos == -1) {\n        next_pos = nodes[cur].to.size() - 1;\n      }\n      const To& to = nodes[cur].to[next_pos];\n      int next_edge = to.edge;\n      int next_side = (cur == edges[next_edge].na) ? next_edge * 2 : next_edge * 2 + 1;\n      unionSet(prev_side, next_side);\n      prev = cur;\n      cur = (cur == edges[next_edge].na) ? edges[next_edge].nb : edges[next_edge].na;\n      prev_side = next_side;\n    }\n  }\n}\n\ndouble getMinLength() {\n  sort(edges.begin(), edges.end(), compareEdge);\n  constructTo();\n  set.clear();\n  set.resize(2 * M, -1);\n  //printf(\"visitAllSides\\n\");\n  visitAllSides();\n  //printf(\"getMinLength\\n\");\n  double total_length = 0.0;\n  for (int i = 0; i < M; ++i) {\n    int root1 = findRoot(i * 2);\n    int root2 = findRoot(i * 2 + 1);\n    if (root1 != root2) {\n      //printf(\"union(%d, %d), cost %lf\\n\", i * 2, i * 2 + 1, edges[i].cost);\n      total_length += edges[i].cost;\n      set[root1] = root2;\n    }\n  }\n  return total_length;\n}\n\nint main() {\n  //freopen(\"SaveYourCats.in\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &M) == 2 && !(N == 0 && M == 0)) {\n    nodes.clear();\n    nodes.resize(N);\n    for (int i = 0; i < N; ++i) {\n      scanf(\"%d%d\", &nodes[i].x, &nodes[i].y);\n    }\n    edges.clear();\n    edges.resize(M);\n    for (int i = 0; i < M; ++i) {\n      int a, b;\n      scanf(\"%d%d\", &a, &b);\n      a--;\n      b--;\n      edges[i].na = a;\n      edges[i].nb = b;\n      edges[i].cost = sqrt((nodes[a].x - nodes[b].x) * (nodes[a].x - nodes[b].x) +\n                           (nodes[a].y - nodes[b].y) * (nodes[a].y - nodes[b].y));\n    }\n    double result = getMinLength();\n    printf(\"%f\\n\", result);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n/*\n*/\n\nusing namespace std;\n\ntypedef pair<long double, pair<long long int, long long int>>onepath;\n\nint main() {\n\tlong long int N, M;\n\tcin >> N >> M;\n\tvector<pair<long long int, long long int>>D( N );\n\tfor( size_t i = 0; i < N; i++ ) {\n\t\tcin >> D[i].first >> D[i].second;\n\t}\n\tvector < vector<pair<long long int, long double>>>path( N );\n\tpriority_queue<onepath, vector<onepath>, greater<onepath>>que;\n\tfor( size_t i = 0; i < M; i++ ) {\n\t\tlong long int p, q;\n\t\tcin >> p >> q;\n\t\tp--; q--;\n\t\tlong double len = sqrtl( powl( D[p].first - D[q].first, 2 ) + powl( D[p].second - D[q].second, 2 ) );\n\t\tque.push( make_pair( len, make_pair( p, q ) ) );\n\t\tpath[p].push_back( make_pair( q, len ) );\n\t\tpath[q].push_back( make_pair( p, len ) );\n\t}\n\tlong double ans = 0;\n\twhile( que.size() ) {\n\t\tauto now = que.top(); que.pop();\n\t\tlong double len = now.first;\n\t\tfor( auto ite = path[now.second.first].begin(); ite < path[now.second.first].end(); ite++ ) {\n\t\t\tif( ( *ite ).first == now.second.second ) {\n\t\t\t\tpath[now.second.first].erase( ite );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor( auto ite = path[now.second.second].begin(); ite < path[now.second.second].end(); ite++ ) {\n\t\t\tif( ( *ite ).first == now.second.first ) {\n\t\t\t\tpath[now.second.second].erase( ite );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlong long int start = now.second.first, goal = now.second.second;\n\t\tqueue<long long int>pointqueue;\n\t\tvector<bool>flag( N, false );\n\t\tflag[start] = true;\n\t\tpointqueue.push( start );\n\t\twhile( pointqueue.size() ) {\n\t\t\tauto np = pointqueue.front(); pointqueue.pop();\n\t\t\tfor( auto nnp : path[np] ) {\n\t\t\t\tif( flag[nnp.first] == false ) {\n\t\t\t\t\tflag[nnp.first] = true;\n\t\t\t\t\tpointqueue.push( nnp.first );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif( flag[goal] ) {\n\t\t\tans += len;\n\t\t}\n\t}\n\tcout << fixed << setprecision( 20 ) << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<limits>\n#include<iomanip>\nusing namespace std;\n\n\ntypedef pair<int,int> pi;\ntypedef pair<double,pi> pdi;\n#define MK make_pair\n#define F first\n#define S second\nconst int MX=1e9+7;\nvector<int> a[16000];\nbool done[20000]={};\n\ndouble dis(pi c,pi b){\n    return (double)pow((c.F-b.F)*(c.F-b.F)+(c.S-b.S)*(c.S-b.S),1.0/2);\n}\n\nint DFS(int s,int g){\n    done[s]=true;\n    int count=0;\n    for(int i=0;i<a[s].size();i++){\n        if(!done[a[s][i]]){\n            if(a[s][i]==g){count++; continue;}\n            count+=DFS(a[s][i],g);\n            if(count>=2){break;}\n        }\n    }\n    return count;\n}\n\nint main(){\n    int n,m;\n    vector<pi> point;\n    \n    priority_queue<pdi> q;\n    point.push_back(MK(0,0));\n    cin>>n>>m;\n    for(int i=0;i<n;i++){\n        int s,g;\n        cin>>s>>g;\n        point.push_back(MK(s,g));\n    }\n    for(int i=0;i<m;i++){\n        int s,g;\n        cin>>s>>g;\n        a[s].push_back(g);\n        a[g].push_back(s);\n        q.push(MK(-1.0*dis(point[s],point[g]),MK(s,g)));\n    }\n    double count=0;\n    \n    while(!q.empty()){\n        pdi di=q.top();\n        q.pop();\n        int l=DFS(di.S.F,di.S.S);\n        fill(&done[0],&done[15000],false);\n        for(int i=0;i<a[di.S.F].size();i++){\n            if(a[di.S.F][i]==di.S.S){a[di.S.F].erase(a[di.S.F].begin()+i);}\n        }\n        for(int i=0;i<a[di.S.F].size();i++){\n            if(a[di.S.S][i]==di.S.F){a[di.S.S].erase(a[di.S.S].begin()+i);}\n        }\n        if(l<2){continue;}\n        //cout<<count<<\" + \"<<di.F<<endl;\n        count-=di.F;\n    }\n     \n    cout<<count<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SQ(X) ((X)*(X))\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nstruct UnionFind{\n\tint par[10010],rank[10010];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t\tpar[x]=y;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint a,b;\n\tdouble len;\n\tedge(){}\n\tedge(int a,int b,double len):a(a),b(b),len(len){};\n\tbool operator<(const edge& a) const{\n\t\treturn len > a.len;\n\t}\n};\nint N,M;\ndouble x[10010],y[10010];\nint p[10010],q[10010];\ndouble dist(int a,int b){\n\treturn sqrt(SQ(x[a]-x[b])+SQ(y[a]-y[b]));\n}\nvector<edge> es;\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%lf %lf\",&x[i],&y[i]);\n\t}\n\tdouble ans = 0.0;\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d %d\",&p[i],&q[i]);\n\t\tp[i]--;\n\t\tq[i]--;\n\t\tes.pb(edge(p[i],q[i],dist(p[i],q[i])));\n\t}\n\tsort(all(es));\n\tuf.init(N);\n\tfor(int i=0;i<es.size();i++){\n\t\tint a = es[i].a;\n\t\tint b = es[i].b;\n\t\tif(uf.same(a,b))ans += es[i].len;\n\t\telse{\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define RG register\n#define LL long long\n#define fre(a) freopen(a\".in\",\"r\",stdin);//freopen(a\".out\",\"w\",stdout);\nusing namespace std;\nconst int MAXN=300000;\nint n,m;\nint X[MAXN],Y[MAXN],fa[MAXN];\ndouble ans,ALL;\nstruct ed\n{\n   int from,to;\n   double len;\n}edge[MAXN];\nbool comp(ed x,ed y){ return x.len>y.len; }\nint find(int x)\n{\n   if(x!=fa[x])\n      fa[x]=find(fa[x]);\n   return fa[x];\n}\nvoid Union(int x,int y)\n{\n   x=find(x);\n   y=find(y);\n   fa[x]=y;\n}\nvoid work()\n{\n   int cnt=0;\n   for(int i=1;i<=m;i++)\n      {\n\t int A=edge[i].from,B=edge[i].to;\n\t if(find(A)!=find(B))\n\t    {\n\t       Union(A,B);\n\t       ans+=edge[i].len;\n\t       cnt++;\n\t    }\n\t if(cnt>=n-1)break;\n      }\n}\nint main()\n{\n   //fre(\"1\");\n   scanf(\"%d%d\",&n,&m);\n   for(int i=1;i<=n;i++)\n      {\n\t scanf(\"%d%d\",&X[i],&Y[i]);\n\t fa[i]=i;\n      }\n   for(int i=1,a,b;i<=m;i++)\n      {\n\t scanf(\"%d%d\",&a,&b);\n\t edge[i].from=a;\n\t edge[i].to=b;\n\t edge[i].len=sqrt((X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b]));\n\t ALL+=edge[i].len;\n      }\n   sort(edge+1,edge+1+m,comp);\n   work();\n   ans=ALL-ans;\n   printf(\"%.3lf\\n\",ans);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = 1e6;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*AOJ2224: Save your cat\n**問題概要\n[http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224:title]\nN個の頂点とM個の辺を持った無\b向グラフがある。グラフの閉路がすべてなくなるように辺を取り除きたい。辺のコストは辺の長さである。取り除く辺のコストの最小値を求めよ。\n2 <= N <= 10000\n1 <= M\n**解法\n辺を取り除くと考えるのではなく、残す辺で全域木を作ると考えれば、これも最大全域木問題になる。クラスカル法で解く。\n*/\n#include <typeinfo>\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nstruct edge{ int u, v; double cost; };\nvector<edge> es;\nint V, E; // 頂点数と辺数\n\n//--------Union-Find木------------\nvector<int> par; // 親\nvector<int> rnk; // 深さ\n\n// Union-Find木の初期化\nvoid init_union_find(int n) {\n  par  = vector<int>(n);\n  rnk = vector<int>(n);\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n\n  if (rnk[x] < rnk[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (rnk[x] == rnk[y]) rnk[x]++;\n  }\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\n//----------クラスカル法------------\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost > e2.cost; // 大きい順\n}\ndouble kruskal() {\n  sort(es.begin(), es.end(), comp); // edge.costの大きい順\n  init_union_find(V); // Union-Findの初期化\n  double res = 0;\n  for (int i = 0; i < E; i++) {\n    edge e = es[i];\n    if (!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n      // cout << e.u+1 << \" \" << e.v+1 << endl;\n    }\n  }\n  return res;\n}\n\nint main() {\n  // 初期化\n  cin >> V >> E;\n  vector<int> vx = vector<int>(V);\n  vector<int> vy = vector<int>(V);\n  es = vector<edge>(E);\n  for (int i = 0; i < V; i++) {\n    cin >> vx[i] >> vy[i];\n  }\n  double l;\n  int p, q;\n  double total_cost = 0;\n  for (int i = 0; i < E; i++) {\n    cin >> p >> q;\n    p--; q--;\n    l = sqrt(static_cast<double>((vx[p] - vx[q])*(vx[p] - vx[q]) + (vy[p] - vy[q])*(vy[p] - vy[q])));\n    // cout << typeid(l).name() << \" \";\n    // cout << l << endl;\n    edge e = {p, q, l};\n    es[i] = e;\n    total_cost += l;\n  }\n  // クラスカル法で最大全域木のコストを計算\n  double kr = kruskal();\n  // 出力\n  printf(\"%.4f\\n\", total_cost - kr);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 1e4+10;\nconst int maxe = 1e8;\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int N = 10000;\nconst int M = 10000*10000/2;\n\nstruct Node {\n    int x, y;\n    double d;\n};\n\nint n, m;\nNode node[M+1];\nint pre[N+1];\nint rank[N+1];\n\nbool cmp(const Node& a, const Node& b)\n{\n    return a.d > b.d;\n}\n\nvoid init()\n{\n    for (int i = 1; i <= n; i ++) {\n        pre[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int a)\n{\n    while (a != pre[a])\n        a = pre[a];\n    return a;\n}\nvoid unite(int a, int b)\n{\n    a = find(a);\n    b = find(b);\n    if (a == b) return;\n    if (rank[a] < rank[b]) {\n        pre[a] = b;\n    } else {\n        pre[b] = a;\n        if (rank[a] == rank[b])\n            rank[a] ++;\n    }\n}\n\nbool same(int a, int b)\n{\n    return find(a) == find(b);\n}\n\ndouble distance(int x1, int y1, int x2, int y2)\n{\n    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\n\ndouble kruskal()\n{\n    sort(node+1, node+m+1, cmp);\n    double res = 0;\n    for (int i = 1; i <= m; i ++) {\n        int x = node[i].x, y = node[i].y;\n        if (!same(x, y))\n            unite(x, y);\n        else\n            res += node[i].d;\n    }\n    return res;\n}\n\nint main(void)\n{\n    int a[N+1], b[N+1];\n    cin >> n >> m;\n    for (int i = 1; i <= n; i ++) {\n        scanf(\"%d%d\", &a[i], &b[i]);\n    }\n    for (int i = 1; i <= m; i ++) {\n        scanf(\"%d%d\", &node[i].x, &node[i].y);\n        int x = node[i].x, y = node[i].y;\n        node[i].d = distance(a[x], b[x], a[y], b[y]);\n    }\n    init();\n    printf(\"%.3lf\\n\", kruskal());\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inc(i, l, r) for (int i = l; i <= r; i++)\n#define pii pair<double, int>\n#define fi first\n#define se second\n#define pb push_back\n\nconst double inf = 1e9;\nconst int maxv = 1e5 + 5;\n\nstruct edge {\n    double cost;\n    int u, v;\n    bool operator<(const edge &o) const { return cost > o.cost; }\n};\n\ndouble x[maxv], y[maxv], tot;\nint n, m, a, b;\n\nint par[maxv];\nvoid init() { inc(i, 1, n) par[i] = i; }\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x != y) par[x] = y;\n}\nbool same(int x, int y) { return find(x) == find(y); }\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    vector<edge> g(m);\n    inc(i, 1, n) scanf(\"%lf %lf\", &x[i], &y[i]);\n    inc(i, 0, m - 1) {\n        scanf(\"%d %d\", &a, &b);\n        double dis =\n            sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));\n        g[i] = {dis, a, b};\n        tot += dis;\n    }\n    sort(g.begin(), g.end());\n    init();\n    inc(i, 0, m - 1) {\n        int u = g[i].u, v = g[i].v;\n        if (!same(u, v)) {\n            tot -= g[i].cost;\n            unite(u, v);\n        }\n    }\n    printf(\"%.3f\", tot);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  double kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  printf(\"%.3lf\\n\", g.sum - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<limits.h>\n#include<algorithm>\n#include<cstring>\n#include<math.h>\n#include<set>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stdlib.h>\n#include<time.h>\nusing namespace std;\ntypedef long long ll;\n#define inf\t0x3f3f3f3f\ntypedef pair<int,int>\tP;\nint n,m;\nP arr[10010];\nint parent[10010];\nint height[10010];\nvoid init(){\n\tfor(int i=1;i<=n;i++){\n\t\tparent[i]=i;\n\t}\n\tmemset(height,0,sizeof(height));\n}\nint find(int x){\n\tif(parent[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn parent[x]=find(parent[x]);\n\t}\n}\nvoid Unit(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(height[x]<height[y]){\n\t\tparent[x]=y;\n\t} else if(height[y]<height[x]){\n\t\tparent[y]=x;\n\t}else{\n\t\tparent[x]=y;\n\t\theight[y]++;\n\t}\n}\nstruct Edge{\n\tint from;\n\tint to;\n\tdouble cost;\n\tbool operator<(const Edge &y)const{\n\t\treturn cost<y.cost;\n\t}\n};\ndouble dis(int x,int y){\n\treturn sqrt(pow(arr[x].first-arr[y].first,2)+\n\t\t\tpow(arr[x].second-arr[y].second,2));\n}\nint main() {\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF){\n\t\tinit();\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%d%d\",&arr[i].first,&arr[i].second);\n\t\t}\n\t\tint p1,p2;\n\t\tpriority_queue<Edge>\tmyQ;\n\t\tEdge e;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d\",&p1,&p2); \n\t\t\te.from=p1;\n\t\t\te.to=p2;\n\t\t\te.cost=dis(p1,p2);\n\t\t\tmyQ.push(e);\n\t\t}\n\t\tdouble sum=0;\n\t\twhile(!myQ.empty()){\n\t\t\te=myQ.top();\n\t\t\tmyQ.pop();\n\t\t\tif(find(e.from)==find(e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t}else{\n\t\t\t\tUnit(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3f\\n\",sum);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: 王文宇\n* @Date:   2018-03-14 23:59:01\n* @Last Modified by:   王文宇\n* @Last Modified time: 2018-03-15 00:12:07\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 10007;\n#define _for(i,a,b) for(int i=a;i<=b;i++)\nint n,m,fa[maxn];\nstruct node\n{\t\n\tint x,y;\n\tdouble length;\n}a[maxn];\nstruct point\n{\n\tint x,y;\n}b[maxn];\nbool cmp(node a,node b)\n{\n\treturn a.length>b.length;\n}\nint find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\ndouble get(int x1,int x2,int y1,int y2)\n{\n\tdouble xx = (double)(x1-x2)*(double)(x1-x2);\n\tdouble yy = (double)(y1-y2)*(double)(y1-y2);\n\treturn sqrt(xx+yy);\n}\nint main(int argc, char const *argv[])\n{\n\tcin>>n>>m;\n\t_for(i,1,n)\n\t{\n\t\tfa[i]=i;\n\t\tint x,y;\n\t\tcin>>b[i].x>>b[i].y;\n\t}\n\tdouble sum = 0.0;\n\t_for(i,1,m)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ta[i].x=x;\n\t\ta[i].y=y;\n\t\ta[i].length = get(b[x].x,b[y].x,b[x].y,b[y].y);\n\t\tsum+=a[i].length;\n\t}\n\tsort(a+1,a+1+m,cmp);\n\t_for(i,1,m)\n\t{\n\t\tint p = find(a[i].x);\n\t\tint q = find(a[i].y);\n\t\tif(p!=q)\n\t\t{\n\t\t\tsum-=a[i].length;\n\t\t\tfa[p]=q;\n\t\t}\n\t}\n\tprintf(\"%.3f\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_N = 10000,MAX_V = 10000,MAX_E = 1000000;\nconst int INF = 1e+6;\n\nint par[MAX_N]; //父亲数组\nint rankh[MAX_N]; //树的高度\n\nvoid init(int n){\n    for(int i = 0;i < n;i++){\n        par[i] = i;  //初始化时让父亲等于自己,全部都是根\n        rankh[i] = 0;\n    }\n}\n\nint find(int x){  // 找x的根,并在找的过程中简化树(减小根节点某一子树的高度,对整棵树的高度有无影响是不知道的)\n    if(x == par[x])  return x; // 找父亲等于自己的点就是根\n    return par[x] = find(par[x]);  //不是根的话就继续从它的爸爸开始找,并且在找到根后把x的父亲改成根\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    //让高的根做矮的根\n    if(rankh[x] < rankh[y]) par[x] = y;\n    else{\n        par[y] = x;\n        if(rankh[x] == rankh[y]) rankh[x]++;\n    }\n}\n\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nstruct edge{\n    int u,v;\n    double cost;\n};\n\nint V, E;\nedge es[MAX_E];\n\nbool cmp(edge a, edge b){ return a.cost > b.cost;}\n\ndouble kruskal(){\n    //初始化\n    init(V);\n    sort(es, es+E, cmp);\n//    printf(\"_______________________________\\n\");\n//    for(int i = 0;i < E;i++){\n//        printf(\"%d %d %f\\n\", es[i].u,es[i].v, es[i].cost);\n//    }\n//    printf(\"_______________________________\\n\");\n    //按权值从小到大变量所有边(其实当连接边数==V-1就结束了,不过时间复杂度都在排序上,这里没太大影响)\n    double res = 0;\n//    int connum = 0;\n    for(int i = 0;i < E;i++){\n        edge e = es[i];\n        if(!same(e.u, e.v)){\n            unite(e.u, e.v);\n            res+=e.cost;\n//            printf(\"use:%d\\n\",i);\n//            connum++;\n        }\n    }\n\n//    if(connum == M) return 0;\n    double sum = 0;\n    for(int i = 0;i < E;i++){\n        sum+=es[i].cost;\n    }\n\n    return sum - res;\n}\n\ndouble dist(double x1, double y1, double x2, double  y2){\n    return sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint x[MAX_V];\nint y[MAX_V];\n\nint main() {\n\n    scanf(\"%d %d\", &V, &E);\n    for(int i = 0;i < V;i++){\n       scanf(\"%d %d\", &x[i], &y[i]);\n    }\n    for(int i = 0;i < E;i++){\n        int u,v;\n        scanf(\"%d %d\", &u, &v);\n        u--;v--;\n        es[i].cost = dist(x[u], y[u], x[v], y[v]);\n        es[i].u = u;\n        es[i].v = v;\n    }\n\n    printf(\"%.3f\", kruskal());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing pii = pair<int, int>;\n#define fst first\n#define snd second\n\nusing Edge  = tuple<int, double>;\nusing State = tuple<double, int>;\n\nconstexpr double inf = 1e20;\nconstexpr double ub  = 1e6;\n\nint main(void){\n    int n, m; cin >> n >> m;\n\n    vector<pii> pos(n);\n    for(auto & e : pos) cin >> e.fst >> e.snd;\n\n    vector<vector<Edge>> edge(n);\n    double res = 0.0;\n    rep(_, m){\n        int a, b; cin >> a >> b;\n        a--, b--;\n        double dist = sqrt(pow(pos[a].snd - pos[b].snd, 2) + pow(pos[a].fst - pos[b].fst, 2));\n        res += dist;\n\n        edge[a].push_back(Edge(b, ub - dist));\n        edge[b].push_back(Edge(a, ub - dist));\n    }\n\n    int start = 0;\n    vector<bool> used(n);\n    while(1){\n        while(start < n and (edge[start].size() == 0 or used[start])) start++;\n        if(start == n) break;\n\n        priority_queue<State, vector<State>, greater<State>> q;\n        q.push(State(ub, start));\n\n        while(q.size()){\n            double d; int v;\n            tie(d, v) = q.top(); q.pop();\n\n            if(used[v]) continue;\n            used[v] = true;\n\n            res -= (ub - d);\n\n            for(auto & e : edge[v]){\n                int nv; double nd;\n                tie(nv, nd) = e;\n\n                if(used[nv]) continue;\n                q.push(State(nd, nv));\n            }\n        }\n    }\n\n    cout.precision(12);\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UniFi {\n    vector<int> par;\n    UniFi (int n) {\n        par.resize(n);\n        for (int i = 0; i < n; i++) par[i] = i;\n    };\n\n    int is_par(int x) {\n        if (x == par[x]) return x;\n        else return (par[x] = is_par(par[x]));\n    }\n\n    void unite(int x, int y) {\n        x = is_par(x);\n        y = is_par(y);\n\n        if (x < y) par[y] = x;\n        else par[x] = y;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<double> x(N), y(N);\n    for (int i = 0; i < N; i++) cin >> x[i] >> y[i];\n    vector<int> p(M), q(M);\n    vector<pair<double,int> > len(M);\n    for (int i = 0; i < M; i++) {\n        cin >> p[i] >> q[i];\n        p[i]--, q[i]--;\n        int a = p[i];\n        int b = q[i];\n        len[i] = pair<double,int>(-sqrt(pow(x[a] - x[b], 2.) + pow(y[a] - y[b], 2.)), i);\n    }\n    sort(len.begin(),len.end());\n\n    UniFi ff(N);\n    double ans = 0.0;\n    for (int i = 0; i < M; i++) {\n        int a = p[len[i].second];\n        int b = q[len[i].second];\n        if (ff.is_par(a) != ff.is_par(b)) {\n            ff.unite(a, b);\n        } else {\n            ans -= len[i].first;\n        }\n    }\n\n    printf(\"%.8f\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\n\nconst int MAX_N=10001;\npair<int, int> points[MAX_N];\nconst int MAX_M=MAX_N*(MAX_N-1)/2;\nedge edges[MAX_M];\n//point points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n    int N, M; \n    cin>>N>>M;\n        for(int i=1; i<=N; i++){\n            cin>>points[i].first>>points[i].second;\n        }\n        int p, q;\n        int x1, x2, y1, y2;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n        \tx1=points[p].first; x2=points[q].first;\n        \ty1=points[p].second; y2=points[q].second;\n            edges[i].w=sqrt((x1-x2)*(x1-x2)\n                          +(y1-y2)*(y1-y2));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    \n    fclose(stdin);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\ntypedef pair<double, P> E;\nconst int NN=10001;\nint rep[NN];\nint weight[NN];\nP pos[NN];\nint Find(int i){\n\twhile(i!=rep[i]){\n\t\ti=rep[i]=rep[rep[i]];\n\t}\n\treturn i;\n}\nvoid Union(int i, int j){\n\tif(weight[i]<weight[j]){\n\t\tswap(i,j);\n\t}\n\trep[j]=i;\n\tweight[i]+=weight[j];\n}\ninline double len(P a, P b){\n\tdouble s=a.first-b.first;\n\tdouble t=a.second-b.second;\n\treturn sqrt(s*s+t*t);\n}\nint main() {\n\tint N,M;\n\tcin >> N >> M;\n\tfor(int i=1;i<=N;i++){\n\t\trep[i]=i;\n\t\tweight[i]=1;\n\t\tcin >> pos[i].first >> pos[i].second;\n\t}\n\tvector<E> edge(M);\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tedge[i]=E(len(pos[a],pos[b]),P(a,b));\n\t}\n\tdouble ret=0;\n\tsort(edge.begin(),edge.end(),greater<E>());\n\tfor(int i=0;i<edge.size();i++){\n\t\tint a=edge[i].second.first;\n\t\tint b=edge[i].second.second;\n\t\ta=Find(a);\n\t\tb=Find(b);\n\t\tif(a!=b){\n\t\t\tUnion(a,b);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret+=edge[i].first;\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <vector>\n\n//#define ONLINE_JUDGE\n\nusing namespace std;\n\nconst int MAX_N = 10000 + 4;\nint N;\nint M;\nstruct P {\n    int x, y;\n    P() {}\n    P(int x, int y): x(x), y(y) {}\n};\n\nstruct Edge {\n    int u, v;\n    double cost;\n    Edge() {}\n    Edge(int u, int v, double cost): u(u), v(v), cost(cost) {}\n};\n\nbool comp(Edge & e1, Edge & e2) {\n    return e1.cost < e2.cost;\n}\n\nP pile[MAX_N];\nvector<Edge> edge;\ndouble sum;\nint par[MAX_N];\nint rank[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (par[x] == x) {\n        return x;\n    }\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n        return;\n    }\n    if (rank[x] < rank[y]) {\n        par[x] = y;\n    }\n    else {\n        par[y] = x;\n        if (rank[x] == rank[y]) {\n            rank[x]++;\n        }\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nvoid kruskal() {\n    init(N);\n    sort(edge.begin(), edge.end(), comp);\n    for (int i = 0; i < edge.size(); i++) {\n        Edge e = edge[i];\n        if (!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            sum -= e.cost;\n        }        \n    }\n}\n\nint main() {\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    scanf(\"%d %d\", &N, &M);\n    int x, y;\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d\", &pile[i].x, &pile[i].y);\n    }\n    int u, v;\n    double cost;\n    sum = 0;\n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d\", &u, &v);\n        cost = -sqrt(pow((pile[u].x - pile[v].x), 2) + pow((pile[u].y - pile[v].y), 2));\n        sum += cost;\n        edge.push_back(Edge(u, v, cost));\n    }\n    kruskal();\n    \n    if (sum == 0.0) {\n        printf(\"0.000\");\n    }\n    else {\n        printf(\"%.3lf\", -sum);\n    }\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    #endif\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nstruct I{I(){ios::sync_with_stdio(false);cin.tie(0);cout<<setprecision(10);cout<<fixed;}}init;\n\nnamespace dsu{\n    #define SZ 500000\n    int mem[2][SZ];\n}\nclass UF{\npublic:\n    int *par,*rank;\n    int find(int x){\n        if(par[x]==x)return x;\n        else return par[x]=find(par[x]);\n    }\n    bool unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return false;\n        if(rank[x]<rank[y])par[x]=y;\n        else{\n            par[y]=x;\n            if(rank[x]==rank[y])rank[x]++;\n        }\n        return true;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n    UF(int n):par(dsu::mem[0]),rank(dsu::mem[1]){\n        for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n    }\n};\nint main(){\n    using P=complex<double>;\n    int N,M;\n    cin>>N>>M;\n    double total=0;\n    vector<P> xy(N);\n    for(int i=0;i<N;i++){\n        double x,y;cin>>x>>y;\n        xy[i]=P(x,y);\n    }\n    using T=tuple<double,int,int>;\n    vector<T> edge(M);\n    for(int i=0;i<M;i++){\n        int p,q;\n        cin>>p>>q;p--,q--;\n        double len=abs(xy[p]-xy[q]);\n        total+=len;\n        edge[i]=T(len,p,q);\n    }\n    sort(edge.begin(),edge.end());\n    reverse(edge.begin(),edge.end());\n    UF uf(N);\n    for(auto &e:edge){\n        double len;int p,q;\n        tie(len,p,q)=e;\n        if(uf.unite(p,q))\n            total-=len;\n    }\n    cout<<total<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ndouble maximum_spanning_tree(int n, vector< vector< pair<double,int> > > &G){\n  priority_queue< pair<double, int> > wait;\n  vector<bool> connected(n);\n  double ret = 0;\n  for(int i = 0; i < n; ++i){\n    wait.emplace(0,i);\n    while(!wait.empty()){\n      double cost = wait.top().first;\n      int v = wait.top().second;\n      wait.pop();\n      if(connected[v]) continue;\n      connected[v] = true;\n      ret += cost;\n      for(int i = 0; i < G[v].size(); ++i){\n        int t = G[v][i].second;\n        if(!connected[t]){\n          wait.push(G[v][i]);\n        }\n      }\n    }\n  }\n  return ret;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n  return hypot((x1-x2),(y1-y2));\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  double X[N], Y[N];\n  for(int i = 0; i < N; ++i){\n    cin >> X[i] >> Y[i];\n  }\n\n  vector< vector< pair<double,int> > > G(N);\n  int p, q;\n  double s = 0;\n  for(int i = 0; i < M; ++i){\n    cin >> p >> q;\n    --p;\n    --q;\n    double d = dist(X[p],Y[p],X[q],Y[q]);\n    s += d;\n    G[p].emplace_back(d,q);\n    G[q].emplace_back(d,p);\n  }\n  printf(\"%.12f\\n\",s - maximum_spanning_tree(N,G));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <string.h>\n\nusing namespace std;\nbool cost[10001][10001];\ndouble mincost[10001];\nbool used[10001];\nconst double INF=100000000;\nint x[10001],y[10001];\n\ndouble prim(int V){\n  for(int i=1; i<=V; ++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n\n  mincost[1]=0;\n  double res=0;\n\n while(true){\n  int v = -1;\n  for(int u=1; u<=V; u++){\n    if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n  }\n\n  if(v==-1) break;\n  used[v]=true;\n  res+=mincost[v];\n\n  for(int u=1; u<=V; u++){\n    int p = (x[v]-x[u])*(x[v]-x[u])+(y[v]-y[u])*(y[v]-y[u]);\n    if(cost[v][u]) mincost[u]=min(mincost[u],-sqrt(p));\n    else mincost[u]=min(mincost[u],0.0);\n  }\n }\n return res;\n}\n\nint main(){\n\n   int N,M; cin>>N>>M;\n\n   for(int i=1; i<=N; i++){\n\n     cin>>x[i]>>y[i];\n\n     }\n\n    double mx=0;\n\n   for(int i=0; i<M; i++){\n\n     int a,b; cin>>a>>b;\n\n     cost[a][b]=true;\n     cost[b][a]=true;\n\n     int p = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n     mx+=sqrt(p);\n\n     }\n\n     cout<<mx+prim(N)<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n\nstruct edge { int u, v; double cost; };\nconst int MAXN = 10000 + 16;\nconst int MAXM = MAXN << 1;\n\nint N, M, x[MAXN], y[MAXN];\nedge es[MAXM];\n\nint p[MAXN];\nvoid init_union_find(int N) {\n    for (int i = 0; i <= N; i++) {\n        p[i] = i;\n    }\n}\nint find(int i) {\n    if (p[i] != i) p[i] = find(p[i]);\n    return p[i];\n}\nint unite(int i, int j) {\n    p[find(i)] = p[find(j)];\n}\n\nbool cmp(const edge & e1, const edge & e2) {\n    return e1.cost < e2.cost;\n}\n\nint main() {\n    //freopen(\"2224.txt\", \"r\", stdin);\n    cin >> N >> M;\n    for (int i = 1; i <= N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    edge e;\n    for (int i = 0; i < M; i++) {\n        cin >> e.u >> e.v;\n        e.cost = sqrt(sqr(x[e.u]-x[e.v]) + sqr(y[e.u]-y[e.v]));\n        es[i] = e;\n    }\n    init_union_find(N);\n    sort(es, es + M, cmp);\n    double result = 0;\n    for (int i = M - 1; i >= 0; i--) { // descending\n        int u = es[i].u, v = es[i].v;\n        if (find(u) != find(v)) {\n            unite(u, v);\n        } else {\n            result += es[i].cost;\n        }\n    }\n    cout << result << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxv = 10000+16;\nint V, E;\n\ntypedef pair<double, double> p;\np ver[maxv];\nstruct edge {\n\tint u, v;\n\tdouble cost;\n\t\n\tedge(int x, int y) {\n\t\tu = x, v = y;\n\n\t\tdouble x1 = ver[x].first, y1 = ver[x].second;\n\t\tdouble x2 = ver[y].first, y2 = ver[y].second;\n\n\t\tcost = sqrt( pow(y2-y1, 2) + pow(x2-x1, 2) );\n\t}\n};\n\nbool cmp(const edge& e1, const edge& e2) {\n\treturn e1.cost > e2.cost;\n}\n\nvector<edge> g;\ndouble res = 0;\nvoid read_in() {\n\tscanf(\"%d%d\", &V, &E);\n\n\tint u, v;\n\tdouble x, y;\n\n\tfor(int i = 0; i < V; i++) {\n\t\tscanf(\"%lf%lf\", &x, &y);\n\n\t\tver[i] = p(x, y);\n\t}\n\n\tfor(int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\t//printf(\"\\n!!%d %d\\n\", u-1, v-1);\n\t\tg.push_back(edge(--u, --v));\n\t\tres += g[i].cost;\n\t}\n}\n\nint Rank[maxv];\nint par[maxv];\n \nint find(int x) {\n\tif (par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nbool same(int x, int y) {\n\t//printf(\"same 函数内 %d %d\\n\", x, y);\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y) return ;\n\tif(Rank[x] < Rank[y]) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif(Rank[x] == Rank[y])\n\t\t\tRank[x] ++;\n\t}\n}\n\nvoid init(int n) {\n\tfor(int i = 0; i < n; i++)\n\t\tRank[i] = 0, par[i] = i;\n}\n\nvoid kruskal() {\n\t//set<int> s;\n\tsort(g.begin(), g.end(), cmp);\n\t//puts(\"!\");\n\tinit(V);\n\t//puts(\"!\");\n\tfor(int i = 0; i < g.size(); i++) {\n\t\tif( !same(g[i].u, g[i].v) ) {\n\t\t\t//printf(\"same 函数结束\\n\");\n\t\t\tres -= g[i].cost;\n\t\t\t//puts(\"!\");\n\t\t\tunite(g[i].u, g[i].v);\n\t\t\t//puts(\"!\");\n\t\t}\n\t}\n}\n\nint main() {\n\tread_in();\n\tkruskal();\n\n\tprintf(\"%.3lf\\n\", res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//\n//  main.cpp\n//  22.C++\n//\n//  Created by 襍オ豈?on 8/9/13.\n//  Copyright (c) 2013 襍オ豈? All rights reserved.\n//\n\n#include <stdio.h>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nstruct Edge{\n    int use;\n    int a,b;\n    long long int d2;\n}edge[100000];\n\nstruct Point{\n    struct Point *parent;\n    int x,y;\n}point[100000];\n\nlong long int dsts(int a,int b){\n    long long int d1,d2;\n    d1=point[a].x-point[b].x;\n    d2=point[a].y-point[b].y;\n    return d1*d1+d2*d2;\n}\n\nbool cmp(struct Edge a,struct Edge b){\n    return a.d2>b.d2;\n}\n\nstruct Point *fant(struct Point *a){\n    if(a->parent){\n        a->parent=fant(a->parent);\n        return a->parent;\n    }else{\n        return a;\n    }\n}\n\nint main(void){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",&point[i].x,&point[i].y);\n    }\n    for(int i=0;i<m;i++){\n        scanf(\"%d%d\",&edge[i].a,&edge[i].b);\n        edge[i].a--;edge[i].b--;\n        edge[i].d2=dsts(edge[i].a,edge[i].b);\n    }\n    sort(edge,edge+m,cmp);\n    \n    for(int i=0;i<m;i++){\n        if(fant(point+edge[i].a)!=fant(point+edge[i].b)){\n            (fant(point+edge[i].a))->parent=fant(point+edge[i].b);\n            edge[i].use=1;\n        }\n    }\n    \n    \n    double totle=0;\n    for(int i=0;i<m;i++){\n        if(edge[i].use==0){\n            totle+=sqrt(edge[i].d2);\n        }\n    }\n    printf(\"%.3lf\\n\",totle);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<map>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<iterator>\n#include<numeric>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\nmultimap<double, Pair,greater<double>> m;\nvector<Pair> v2;\nbool b[10002] = {};\nint main()\n{\n\tint N, M;\n\tdouble sum = 0.0;\n\tcin >> N >> M;\t   \n\tfor (unsigned int i = 0; i < N; i++)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tv2.push_back(make_pair(x, y));\n\t}\n\tfor (unsigned int j = 0; j < M; j++)\n\t{\n\t\tint p, q;\n\t\tcin >> p >> q;\n\t\tdouble temp=sqrt((v2[p - 1].first - v2[q - 1].first)*(v2[p - 1].first - v2[q - 1].first) + (v2[p - 1].second - v2[q - 1].second)*(v2[p - 1].second - v2[q - 1].second));\n\t\tsum += temp;\n\t\tm.insert(make_pair(temp, make_pair(p - 1, q - 1)));\n\t}\n\twhile (!m.empty())\n\t{\n\t\tint l = (*m.begin()).second.first;\n\t\tint r = (*m.begin()).second.second;\n\t\tif (b[l]==false|| b[r]==false)\n\t\t{\n\t\t\tsum -= (*m.begin()).first;\n\t\t\tb[l] = true;\n\t\t\tb[r] = true;\n\t\t\tm.erase(m.begin());\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t{\n\t\t\t\tif (b[i] == false)break;\n\t\t\t\telse if (i == N - 1)m.clear();\n\t\t\t}\n\t\t}\n\t\telse m.erase(m.begin());\n\n\t}\n\tcout << fixed<<setprecision(3) << sum << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nlnt par[10000];\nstruct edge{lnt u,v,cost;};\nvector<edge> es;\nbool cmp(const edge& a,const edge& b){\n\treturn a.cost<b.cost;\n}\nP mat[10000];\nlnt n,m;\nvoid init(){\n\tfor(int i=0;i<n;i++) par[i]=i;\n}\n\nlnt find(lnt x){\n\tif(par[x]==x) return x;\n\telse return par[x]=find(par[x]);\n}\n\nbool same(lnt x,lnt y){\n\treturn find(x)==find(y);\n}\n\nvoid unite(lnt x,lnt y){\n\tpar[find(x)]=find(y);\n\treturn;\n}\ndouble ans=0;\nint main()\n{\n\tcin>>n>>m;\n\tinit();\n\tfor(lnt i=0;i<n;i++){\n\t\tcin>>mat[i].first>>mat[i].second;\n\t}\n\tlnt x,y;\n\tfor(lnt i=0;i<m;i++){\n\t\tcin>>x>>y;\n\t\tx--;\n\t\ty--;\n\t\tes.push_back({x,y,-(mat[x].first-mat[y].first)*(mat[x].first-mat[y].first)-(mat[x].second-mat[y].second)*(mat[x].second-mat[y].second)});\n\t\tans+=sqrt(-es[i].cost);\n\t}\n\tsort(es.begin(),es.end(),cmp);\n\tfor(lnt i=0;i<m;i++){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tans-=sqrt(-e.cost);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string>\ntemplate <class T> class Node {\npublic:\n\tNode()\n\t\t:parent(NULL), child(NULL)\n\t{};\n\tNode* parent;\n\tNode* child;\n\tT para;\n};\ntemplate <class T> class UnionFind {\npublic:\n\tvoid Connect(Node<T>* a, Node<T>* b) {\n\t\tVertex(a)->parent = Vertex(b);\n\t};\n\tbool Same(Node<T>* a, Node<T>* b) {\n\t\treturn Vertex(a) == Vertex(b);\n\t};\nprivate:\n\tNode<T>* Vertex(Node<T>* _obj) {\n\t\tif (_obj->parent == NULL) {\n\t\t\treturn _obj;\n\t\t}\n\t\telse {\n\t\t\treturn _obj->parent = Vertex(_obj->parent);\n\t\t}\n\t};\n};\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef priority_queue<int> PQ;\n#define _CRT_SECURE_NO_WARNINGS\nint N,M;\nint x[10010], y[10010];\nUnionFind<int> UF;\nstruct L{\n\tint s, g;\n\tdouble cost;\n\tbool operator < (const L& _l)const{\n\t\treturn cost < _l.cost;\n\t};\n\tbool operator > (const L& _l)const {\n\t\treturn cost > _l.cost;\n\t};\n\tvoid Set(int _x, int _y, float _c) {\n\t\ts = _x;\n\t\tg = _y;\n\t\tcost = _c;\n\t}\n}loads[10010 * 10010];\ndouble ans = 0;\nNode<int> n[10010];\n\nint main() {\n\tscanf(\"%d %d\", &N , &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tloads[i].Set(a, b, (double)sqrt( (double)((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) ) );\n\t}\n\tstd::sort(loads, &loads[M],std::greater<L>());\n\t\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!UF.Same(&n[loads[i].s], &n[loads[i].g])) {\n\t\t\tUF.Connect(&n[loads[i].s], &n[loads[i].g]);\n\t\t}\n\t\telse {\n\t\t\tans += loads[i].cost;\n\t\t}\n\t}\n\tprintf(\"%f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<queue>\nusing namespace std;\n\nstruct qnode{\n\tint v1,v2;\n\tdouble w;\n\tbool operator <(const qnode &b)const{\n\t\treturn w<b.w;\n\t}\n};\npriority_queue<qnode> q;\n\nint x[10001],y[10001],set[100001];\n\nint find(int x)\n{\n\tif(x==set[x])\n\t\treturn x;\n\telse\n\t\treturn set[x]=find(set[x]);\n}\n\ninline double dist(double x1,double x2,double y1,double y2)\n{\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\n\nint main()\n{\n\tint n,m,v1,v2,i;\n\tqnode z;\n\tdouble s=0;\n\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t\tset[i]=i;\n\t}\n\tfor(i=1;i<=m;i++)\n\t{\n\t\tscanf(\"%d%d\",&v1,&v2);\n\t\tz.v1=v1;\n\t\tz.v2=v2;\n\t\tz.w=dist(x[v1],x[v2],y[v1],y[v2]);\n\t\ts+=z.w;\n\t\tq.push(z);\n\t}\n\n\twhile(!q.empty())\n\t{\n\t\tz=q.top();\n\t\tq.pop();\n\t\tv1=z.v1;\n\t\tv2=z.v2;\n\t\tif((v1=find(v1))!=(v2=find(v2)))\n\t\t{\n\t\t\tset[v2]=v1;\n\t\t\ts-=z.w;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",s<0?0:s);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\ntypedef pair<long double, int> l_i;\n\nint N, M;\ndouble x[10000], y[10000];\nvector<i_i> e;\nvector<l_i> v;\n\nlong double dist(i_i a) {\n    auto dx = x[a.first] - x[a.second];\n    auto dy = y[a.first] - y[a.second];\n    dx = dx * dx;\n    dy = dy * dy;\n    return pow(dx + dy, 0.5);\n}\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    for(int i = 0; i < N; i++) cin >> x[i] >> y[i];\n    e.resize(M);\n    long double ans = 0;\n    for(int i = 0; i < M; i++) {\n        cin >> e[i].first >> e[i].second;\n        e[i].first--;\n        e[i].second--;\n        ans += dist(e[i]);\n        v.push_back({dist(e[i]), i});\n    }\n    sort(v.begin(), v.end(), greater<l_i>());\n    UnionFind uni(N);\n    for(auto tmp : v) {\n        int idx = tmp.second;\n        if(uni.merge(e[idx].first, e[idx].second)) {\n            ans -= tmp.first;\n        }\n    }\n    cout << fixed << setprecision(20) << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define inf 0x3f3f3f\n#define N 10000\nint fa[2*N+5],t,n,m,k;\ndouble s[N+5][2],s1;\nstruct mzls\n{\n\tint u,v;\n\tdouble w;\n\tbool operator<(const mzls &a)const\n\t{\n\t\treturn a.w<w;\n\t}\n}g[N*N+5],as;\ninline int find(int x)\n{\n\tif(fa[x]==-1)\n\t\treturn x;\n\treturn fa[x]=find(fa[x]);\n}\ninline double K()\n{\n\tdouble sum=0.0;\n\tsort(g+1,g+t+1);\n\tmemset(fa,-1,sizeof(fa));\n\tint j=0;\n\tfor(int i=1;i<=t;i++)\n\t{\n\t\tint u=g[i].u,v=g[i].v;\n\t\tint r1=find(u),r2=find(v);\n\t\tif(r1!=r2)\n\t\t{\n\t\t\tfa[r2]=r1;\n\t\t\tsum+=g[i].w;\n\t\t\tj++;\n\t\t\tif(j>=n-1)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\treturn sum;\n}\ninline void insert(int x,int y,double z)\n{\n\tas.u=x,as.v=y,as.w=z;\n\tg[++t]=as;\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%lf%lf\",&s[i][0],&s[i][1]);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x,y;\n\t\tdouble z;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tz=sqrt((s[x][1]-s[y][1])*(s[x][1]-s[y][1])+(s[x][0]-s[y][0])*(s[x][0]-s[y][0]));\n\t\ts1+=z;\n\t\tinsert(x,y,z);\n\t}\n\tprintf(\"%lf\\n\",s1-K());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\nint par[10000];\n\nint find(int x) {\n    if (par[x] == x) return x;\n    else return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    par[find(x)] = find(y);\n}\n\nint x[10000], y[10000];\n\ndouble length(double a, double b) {\n    return sqrt(a * a + b * b);\n}\n\nint main(void) {\n    int i, n, m;\n    cin >> n >> m;\n    REP (i,n) cin >> x[i] >> y[i];\n    priority_queue<pair<double,pair<int,int>>> que;\n    double ans = 0;\n    REP (i,m) {\n        int p, q;\n        cin >> p >> q;\n        p--; q--;\n        double len = length(x[p]-x[q],y[p]-y[q]);\n        que.push({len,{p,q}});\n        ans += len;\n    }\n    REP (i,n) par[i] = i;\n    while (!que.empty()) {\n        auto p = que.top(); que.pop();\n        double len = p.first;\n        int a = p.second.first;\n        int b = p.second.second;\n        if (find(a) != find(b)) {\n            unite(a,b);\n            ans -= len;\n        }\n    }\n    cout << fixed << setprecision(4);\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <functional>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\ndouble dist(pair<double, double> a, pair<double, double> b) {\n    double dx = a.first - b.first;\n    double dy = a.second - b.second;\n    return sqrt(dx * dx + dy * dy);\n}\n\nstruct UnionFind {\n    vector<int> parent; // 先祖. 親ではない\n    UnionFind(int size) : parent(size, -1) {}\n    int root(int x) {\n        if (parent[x] < 0) return x;\n        return parent[x] = root(parent[x]); \n    }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        parent[x] = y;\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nstruct Edge {\n    int from, to;\n    double cost;\n    Edge(int from, int to, double cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const Edge &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const Edge &o) const {\n        return (cost > o.cost);\n    }\n};\n\ntypedef vector<Edge> Vertex;\n\nstruct Graph {\n    vector<Vertex> g;\n    Graph(int vertex_count=0) : g(vertex_count) {}\n    Graph(vector<Vertex> g) : g(g) {}\n\n    inline Vertex& operator[](int index) {\n        return g[index];\n    }\n\n    inline void push_back(Vertex v) {\n        g.push_back(v);\n    }\n\n    inline void add_edge(int from, int to, double cost) {\n        g[from].push_back(Edge(from, to, cost));\n    }\n\n    double whole_cost() {\n        double ret = 0;\n        for (int i = 0; i < g.size(); i++) \n            for (int j = 0; j < g[i].size(); j++) \n                ret += g[i][j].cost;\n        return ret;\n    }\n\n    double kruskal() {\n        vector<Edge> edges;\n        for (int i = 0; i < g.size(); i++) \n            for (int j = 0; j < g[i].size(); j++) \n                edges.push_back(g[i][j]);\n        sort(edges.begin(), edges.end(), greater<Edge>());\n\n        UnionFind uf(g.size());\n\n        double ret = 0;\n        for (int i = 0; i < edges.size(); i++) {\n            Edge e = edges[i];\n            if (!uf.same(e.from, e.to)) {\n                uf.unite(e.from, e.to);\n                ret += e.cost;\n            }\n        }\n        return whole_cost() - ret;\n    }\n};\n\nint main() {\n    int N, M; cin >> N >> M;\n    Graph g(N);\n    vector< pair<double, double> > pile;\n    for (int i = 0; i < N; i++) {\n        double x, y;\n        cin >> x >> y;\n        pile.push_back(make_pair(x, y));\n    }\n    for (int i = 0; i < M; i++) {\n        int from, to;\n        cin >> from >> to; \n        from--, to--;\n        g.add_edge(from, to, dist(pile[from], pile[to]));\n    }\n    printf(\"%6f\\n\", g.kruskal());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 100000\n \nint N, M;\nint par[MAX], rank[MAX];\ntypedef pair<double,double> P;\nvoid init(){\n    for(int i = 0 ; i < N ; i++){\n\tpar[i] = i;\n\trank[i] = 0;\n    }\n}\n \nint find(int x){\n    if(par[x] == x){\n\treturn x;\n    }else{\n\treturn par[x] = find(par[x]);\n    }\n}\n \nvoid unite(int x,int y){\n    x = find(x);\n    y = find(y);\n \n    if(x == y) return;\n \n    if(rank[x] < rank[y]){\n\tpar[x] = y;\n    }else{\n\tpar[y] = x;\n \n\tif(rank[x] == rank[y]){\n\t    rank[x]++;\n\t}\n    }\n}\n \nbool same(int x,int y){\n    return find(x) == find(y);\n}\n \nstruct edge{\n    int u,v;\n    double cost;\n};\n \nbool comp(const edge &e1,const edge &e2){\n    return e1.cost > e2.cost;\n}\n \nedge es[MAX];\n \ndouble kruskal(){\n    init(); sort(es , es + M, comp);\n    double res = 0;\n    for(int i = 0 ; i < M ; i++){\n\tedge e = es[i];\n\tif(!same(e.u , e.v)){\n\t    unite(e.u , e.v);\n\t    res += e.cost;\n\t}\n    }\n    return res;\n}\n \ndouble dist(P p1, P p2){\n    return sqrt(pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2));\n}\n \nint main(){\n    int a,b;\n    P p[MAX];\n \n    scanf(\"%d %d\" ,&N ,&M);\n    for(int i = 0 ; i < N ; i++){\n\tscanf(\"%lf%lf\",&p[i].first, &p[i].second);\n    }\n    double total = 0;\n    for(int i = 0 ; i < M ; i++){\n\tscanf(\"%d %d\" ,&a ,&b);  \n\ta--, b--;\n\tdouble d = dist(p[a], p[b]);\n\tes[i].u = a; es[i].v = b; es[i].cost = d;\n\ttotal += d;\n    }\n    printf(\"%.5f\\n\",total-kruskal());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\ntypedef double Weight;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src_, int dst_, Weight weight_) :\n        src(src_), dst(dst_), weight(weight_) { }\n    Edge(){}\n};\nbool operator < (const Edge &e, const Edge &f) {\n    return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n        e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n    vector<int> par;\n    int cnt;\n    UnionFind(int size_) : par(size_, -1), cnt(size_) { }\n    bool merge(int x, int y){\n        x = find(x); y = find(y);\n        if (x != y) {\n            if (par[y] < par[x]) swap(x, y);\n            par[x] += par[y]; par[y] = x;\n            cnt--;\n        }\n        return x != y;\n    }\n    bool get(int x, int y){\n        return find(x) == find(y);\n    }\n    int find(int x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n    // optional\n    int size(int x){\n        return -par[find(x)];\n    }\n    // optional\n    int size(){\n        return cnt;\n    }\n};\n\nint main(){\n    int N,M;\n    cin >> N >> M;\n    vector<complex<double>> ps(N);\n    rep(i,N){\n        int x,y;\n        cin >> x >> y;\n        ps[i] = complex<double>(x,y);\n    }\n    Edges es(M);\n    double s = 0;\n    rep(i,M){\n        int a,b;\n        cin >> a >> b;\n        a--, b--;\n        double d = abs(ps[a]-ps[b]);\n        es[i] = Edge(a,b,d);\n        s += d;\n    }\n    sort(begin(es),end(es),[](const Edge & a, const Edge & b){\n            return a.weight > b.weight;\n        });\n    UnionFind uf(N);\n    rep(i,M){\n        int a = es[i].src, b = es[i].dst;\n        if(!uf.get(a,b)){\n            s -= es[i].weight;\n            uf.merge(a,b);\n        }\n    }\n    printf(\"%.20lf\\n\", s);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n#define inf 0x3f3f3f3f\ntypedef long long ll;\n#define N 12000\nint pre[N];\nint n,m;\nstruct Edge{\n\tint u,v;\n\tdouble len;\n}edge[N*N/2];\nstruct Node\n{\n\tdouble x,y;\n } node[N];\nint cmp(Edge a,Edge b)\n{\n\treturn a.len>b.len;\n}\ndouble dis(Node a,Node b)//两点的距离 \n{\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\nvoid init(int n)\n{\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpre[i]=i;\n\t}\n}\nint find(int x)\n{\n\tif(pre[x]==x)\n\treturn x;\n\telse return pre[x]=find(pre[x]);\n}\nvoid mix(int x,int y)\n{\n\tint fx=find(x);\n\tint fy=find(y);\n\tif(fx!=fy)\n\t{\n\t\tpre[fx]=fy;\n\t}\n}\ndouble kruskal()\n{\n\tinit(n);\n\tsort(edge,edge+m,cmp);\n\tdouble s=0.0;//记录不用抹去的边,求最大生成树 ，树没有环，树权值最大 说明去掉的就最少\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tEdge e=edge[i];\n\t\tif(find(e.u)!=find(e.v))\n\t\t{\n\t\t\tmix(e.u,e.v);\n\t\t\ts+=e.len;\n\t\t}\n\t } \n\t return s;\n}\nint main()\n{\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF)\n\t{\n\t\tint a,b;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%lf%lf\",&node[i].x,&node[i].y);\n\t\t}\n\t\tdouble sum=0.0;//巫婆围得的总边和\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tedge[i].u=a;\n\t\t\tedge[i].v=b;\n\t\t\tedge[i].len=dis(node[a],node[b]);\n\t\t\tsum+=edge[i].len;\n\t\t }\n\t\t double s=kruskal();\n\t\t double ans=0.0;\n\t\t ans=sum-s;\n\t\t printf(\"%.3lf\\n\",ans); \n\t}return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(ll i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(ll i=(a);i<(n);i++)\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI (3.1415926535897932384)\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S sum(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\n\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>void tf(bool b,S t,T f){if(b)puta(t);else puta(f);}\nvoid YN(bool b){tf(b,\"YES\",\"NO\");}\nvoid Yn(bool b){tf(b,\"Yes\",\"No\");}\nvoid yn(bool b){tf(b,\"yes\",\"no\");}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1;for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;}return os;}\ntemplate<class S>auto&operator>>(istream&is,vector<S>&t){for(S&a:t)cin>>a;return is;}\n\n/*他のライブラリを入れる場所*/\n\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tll n,m;\n\tcin>>n>>m;\n\tvector<complex<double>> pile;\n\trep(i,n){\n\t\tdouble a,b; cin>>a>>b;\n\t\tpile.emplace_back(a,b);\n\t}\n\n\tusing edge=tuple<double,ll,ll>;\n\tvector<vector<edge>> fence(n);\n\t\n\tdouble ans=0;\n\n\trep(i,m){\n\t\tint a,b; cin>>a>>b;\n\t\ta--, b--;\n\t\tfence[a].emplace_back(abs(pile[a]-pile[b]),a,b);\n\t\tfence[b].emplace_back(abs(pile[a]-pile[b]),a,b);\n\t\tans+=abs(pile[a]-pile[b]);\n\t}\n\n\tvb isVisited(n,false);\n\trep(i,n){\n\t\tif(isVisited[i])continue;\n\n\t\tpriority_queue<edge> q;\n\t\tset<int> s;\n\t\ts.insert(i);\n\t\tfor(auto&f:fence[i]){\n\t\t\tq.push(f);\n\t\t}\n\n\t\twhile(!q.empty()){\n\t\t\tdouble cost; ll a,b;\n\t\t\ttie(cost, a, b) = q.top();\n\t\t\tq.pop();\n\t\t\tisVisited[a]=isVisited[b]=true;\n\n\t\t\tif(s.find(a)!=s.end())swap(a,b);\n\t\t\tif(s.find(a)!=s.end())continue;\n\t\t\tans-=cost;\n\t\t\ts.insert(a);\n\t\t\tfor(auto&f:fence[a]){\n\t\t\t\tq.push(f);\n\t\t\t}\n\t\t}\n\t}\n\n\tfcout(10)<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nÁ·Ï°Ìâ£ºSave your cats_AOJ 2224 \n\t¼õÈ¥×îÉÙ¡¢Ð¡µÄ±ß£¬Ê¹µÃÕû¸öÆ½ÃæÁ¬Í¨£»\n\t¼´ÎªÇó×î´óÉú³ÉÊ÷ÎÊÌâ£¬µ«×¢ÒâÇóµÄÊÇ²ÃÈ¥µÄÂ·¾¶¡£ \n*/\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int MAX_E=49995007, MAX_V=10007;\nint mark[MAX_E];\npair<int, int> ver[MAX_V];\n\nstruct edge{\n\tint u, v, cost;\n}; \nbool cmp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V, E;\n\n\n//DUS start line\n\nint par[MAX_V];//¸¸Ç× \nint hight[MAX_V];//Ê÷µÄ¸ß¶È\n\n//³õÊ¼»¯n¸öÔªËØ\nvoid init(int n)\n{\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tpar[i]=i;\n\t\thight[i]=0;\n\t}\n}\n\n//²éÑ¯Ê÷µÄ¸ù\nint find(int x)\n{\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=find(par[x]);\n}\n\n//ºÏ²¢xºÍyËùÊôµÄ¼¯ºÏ\nvoid unite(int x, int y)\n{\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)\n\t\treturn ;\n\tif(hight[x]<hight[y])\n\t\tpar[x]=y;\n\telse\n\t{\n\t\tpar[y]=x;\n\t\tif(hight[x]==hight[y])\n\t\t\thight[x]++;\n\t}\n}\n\n//ÅÐ¶ÏxºÍyÊÇ·ñÊôÓÚÍ¬Ò»¸ö¼¯ºÏ\nbool same(int x, int y)\n{\n\treturn find(x)==find(y);\n}\n\n//DUS end line \n\n\ndouble kruskal()\n{\n\tsort(es, es+E, cmp);\n\t\n\tinit(V);\n\t\n\n\tdouble res=0;\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tedge e=es[i];\n\t\tif(!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t\tmark[i]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tif(mark[i]==0)\n\t\t\tres+=sqrt(-es[i].cost);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i=0;  i<V; i++)\n\t{\n\t\tscanf(\"%d%d\", &ver[i].first, &ver[i].second);\n\t}\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tedge ed;\n\t\tscanf(\"%d%d\", &ed.u, &ed.v);\n\t\ted.u--;\n\t\ted.v--;\n\t\ted.cost=-((ver[ed.u].first-ver[ed.v].first)*(ver[ed.u].first-ver[ed.v].first)+(ver[ed.u].second-ver[ed.v].second)*(ver[ed.u].second-ver[ed.v].second));\n\t\tes[i]=ed;\n\t}\n\t\n\tdouble ans=kruskal();\n\tprintf(\"%.3lf\\n\", ans);\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<stdio.h>\n#include<cmath>\nusing namespace std;\ntypedef long long int ll;\nint const MAX=10005;\nint const MAXM=100000005;\nint par[MAX];\nint rank[MAX];\nstruct Dian\n{\n    int x;int y;\n};\nstruct Edge\n{\n    int u,v;\n    double cost;\n}edge[MAXM];\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        rank[i]=0;\n    }\n}\nint find(int x){\n    if(par[x]==x)return x;\n    else return par[x]=find(par[x]);\n}\nvoid unite(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n        rank[x]=y;\n    }\n    else{\n        par[y]=x;\n        if(rank[x]==rank[y])rank[x]++;\n    }\n}\nbool same(int x,int y)\n{\n    return find(x)==find(y);\n}\nint N,M;\nDian dian[MAX];\ndouble dis(int a,int b)\n{\n    double l;\n    l=sqrt((dian[a].x-dian[b].x)*(dian[a].x-dian[b].x)+(dian[a].y-dian[b].y)*(dian[a].y-dian[b].y));\n    return l;\n}\nbool comp(const Edge e1,const Edge e2)\n{\n    return e1.cost<e2.cost;\n}\nint main()\n{\n    while(cin>>N>>M){\n    int a,b,c;\n    double sum=0;\n    for(int i=0;i<N;i++){\n        cin>>a>>b;\n        dian[i].x=a;\n        dian[i].y=b;\n    }\n    for(int i=0;i<M;i++){\n        cin>>a>>b;\n        a--;\n        b--;\n        edge[i].u=a;\n        edge[i].v=b;\n        edge[i].cost=-dis(a,b);\n        sum+=dis(a,b);\n    }\n    sort(edge,edge+M,comp);\n    init(N);\n    double res=0;\n    for(int i=0;i<M;i++){\n        Edge e=edge[i];\n        if(!same(e.u,e.v)){\n            unite(e.u,e.v);\n            res+=e.cost;\n        }\n    }\n    printf(\"%0.3f\\n\",sum+res);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nconst int maxn=50010;\nint pre[20010];\nint t,n,m,r;\nstruct edge\n{\n         int a,b,v;\n}ed[maxn];\nbool cmp(edge a,edge b)\n{\n         return a.v>b.v;\n}\nint Find(int x)\n{\n         int p,tmp;\n         p=x;\n         while(x!=pre[x])\n                  x=pre[x];\n         while(p!=x)\n         {\n                  tmp=pre[p];\n                  pre[p]=x;\n                  p=tmp;\n         }\n         return x;\n}\nvoid Union(int x,int y)\n{\n         int p=Find(x);\n         int q=Find(y);\n         if(p!=q)\n         pre[q]=p;\n}\nvoid init()\n{\n         for(int i=0;i<=m+n;i++)\n                  pre[i]=i;\n}\nvoid kruskal()\n{\n         long long int ans=10000*(m+n);\n         init();\n         for(int i=1;i<=r;i++)\n         {\n                  int x=ed[i].a,y=ed[i].b;\n                  if(Find(x)!=Find(y))\n                  {\n                           Union(x,y);\n                           ans-=ed[i].v;\n                  }\n         }\n         printf(\"%lld\\n\",ans);\n}\nint main()\n{\n         scanf(\"%d\",&t);\n         while(t--)\n         {\n                  scanf(\"%d%d%d\",&n,&m,&r);\n                  for(int i=1;i<=r;i++)\n                  {\n                           int x,y,d;\n                           scanf(\"%d%d%d\",&x,&y,&d);\n                           ed[i].a=x;\n                           ed[i].b=y+n;\n                           ed[i].v=d;\n                  }\n                  sort(ed+1,ed+m+1,cmp);\n                  kruskal();\n         }\n         return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> P1;\nint n,m,x[N],y[N],p,q;\ndouble cost,ans;\nvector<P1> e;\nint rank[N];\nint par[N];\n\nvoid init(){\n  for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n}\n\nint find(int u){\n  if(par[u]==u)return u;\n  return par[u]=find(par[u]);\n}\n\nvoid unite(int u,int v){\n  u=find(u);\n  v=find(v);\n  if(u==v)return;\n  if(rank[u]<rank[v])par[u]=v;\n  else{\n    par[v]=u;\n    if(rank[u]==rank[v])rank[u]++;\n  }\n}\n\nbool same(int u,int v){\n  return find(u)==find(v);\n}\n\ndouble getlen(int a,int b){\n  double X=x[a]-x[b],Y=y[a]-y[b];\n  return sqrt(X*X+Y*Y);\n}\n\ndouble kruskal(){\n  sort(e.begin(),e.end());\n  init();\n  double res=0;\n  for(int i=0;i<(int)e.size();i++){\n    int u=e[i].second.first;\n    int v=e[i].second.second;\n    if(!same(u,v))unite(u,v),res+=e[i].first;\n  }\n  return -res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<m;i++){\n    cin>>p>>q;\n    e.push_back(P1(-getlen(p,q),P(p,q)));\n    ans+=getlen(p,q);\n  }\n  ans-=kruskal();\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define DEBUG 1\n\n#define INF (1.0/0.0)\n#define EPS 1e-8\n#define PI 3.1415926535\n#define EQ(x, y) (abs((x)-(y))<EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> Point;\ntypedef pair<double, int> Pair;\n\nstruct Edge {\n  int to;\n  double len;\n};\n\nint n;\nint m;\npriority_queue<Pair> q;\nPoint ps[114514];\ndouble mind[114514];\nvector<Edge> es[114514];\n\nint main() {\n  scanf(\"%d%d\", &n, &m);\n  for (int i=0; i<n; i++) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    ps[i] = Point(x, y);\n  }\n\n  double sum = 0.0;\n  for (int i=0; i<m; i++) {\n    int a, b;\n    scanf(\"%d%d\", &a, &b);\n    --a;\n    --b;\n    double t = abs(ps[a]-ps[b]);\n    es[a].push_back(Edge{b, t});\n    es[b].push_back(Edge{a, t});\n    sum += t;\n  }\n\n  double total = 0.0;\n  fill(mind, mind+n, -INF);\n  for (int v=0; v<n; v++) {\n    if (mind[v] != -INF) continue;\n    mind[v] = 0;\n    q.push(Pair(0, v));\n    while (!q.empty()) {\n      Pair p = q.top(); q.pop();\n      double c = p.first;\n      int v = p.second;\n      if (mind[v] > c) continue;\n      total += mind[v];\n      mind[v] = INF;\n  \n      for (int i=0; i<es[v].size(); i++) {\n        int u = es[v][i].to;\n        double len = es[v][i].len;\n        if (mind[u] < len) {\n          mind[u] = len;\n          q.push(Pair(mind[u], u));\n        }\n      }\n    }\n  }\n  printf(\"%.10f\\n\", sum-total);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 10005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,P> P1;\nint n,m,x[N],y[N],p,q;\ndouble cost,ans;\nvector<P1> e;\nint rank[N];\nint par[N];\n\nvoid init(){\n  for(int i=0;i<n;i++)par[i]=i,rank[i]=0;\n}\n\nint find(int u){\n  if(par[u]==u)return u;\n  return par[u]=find(par[u]);\n}\n\nvoid unite(int u,int v){\n  u=find(u);\n  v=find(v);\n  if(u==v)return;\n  if(rank[u]<rank[v])par[u]=v;\n  else{\n    par[v]=u;\n    if(rank[u]==rank[v])rank[u]++;\n  }\n}\n\nbool same(int u,int v){\n  return find(u)==find(v);\n}\n\ndouble getlen(int a,int b){\n  double X=x[a]-x[b],Y=y[a]-y[b];\n  return sqrt(X*X+Y*Y);\n}\n\ndouble kruskal(){\n  sort(e.begin(),e.end());\n  init();\n  double res=0;\n  for(int i=0;i<(int)e.size();i++){\n    int u=e[i].second.first;\n    int v=e[i].second.second;\n    if(!same(u,v))unite(u,v),res+=e[i].first;\n  }\n  return -res;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  for(int i=0;i<m;i++){\n    cin>>p>>q;\n    e.push_back(P1(-getlen(--p,--q),P(p,q)));\n    ans+=getlen(p,q);\n  }\n  ans-=kruskal();\n  printf(\"%.8f\\n\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint n,m;\nstruct edge{\n    int u,v;\n    double w;\n    edge(int _u,int _v,double _w):u(_u),v(_v),w(_w){}\n    bool operator<(const edge& b)const{\n        return w > b.w;\n    }\n};\nvector<edge> ve;\nint parent[10005];\nint findSet(int u)\n{\n    if(parent[u]==u)\n        return u;\n    return parent[u] = findSet(parent[u]);\n}\nvoid Union(int x,int y)\n{\n    int px = findSet(x);\n    int py = findSet(y);\n    if(px!=py)\n        parent[px]=py;\n}\nbool isSameSet(int x,int y){\n    return findSet(x) == findSet(y);\n}\nvector<pii> vp;\n\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&n,&m)){\n        for(int i=0;i<=n;i++) parent[i]=i;\n        ve.clear();\n        vp.clear();\n        for(int i=0;i<n;i++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            vp.push_back(make_pair(x,y));\n        }\n        double ori=0;\n        for(int i=0;i<m;i++){\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            u--,v--;\n            pii p1 = vp[u];\n            pii p2 = vp[v];\n            double w = sqrt((p1.first-p2.first)*(p1.first-p2.first)+(p1.second-p2.second)*(p1.second-p2.second));\n            ori += w;\n            ve.push_back(edge(u,v,w));\n        }\n        sort(ve.begin(),ve.end());\n        double MaxST = 0;\n        for(int i=0;i<ve.size();i++){\n            edge e = ve[i];\n            if(!isSameSet(e.u,e.v)){\n                Union(e.u,e.v);\n                MaxST += e.w;\n            }\n        }\n        printf(\"%.3lf\\n\",ori-MaxST);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nstruct edge {\n  int to; double cost;\n  edge(int t, double c): to(t), cost(c) {}\n};\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  vector<int> x(N), y(N);\n  REP(i, N) cin >> x[i] >> y[i];\n\n  vector<vector<edge> > G(N);\n  \n  double totalfence = 0.0;\n  REP(i, M) {\n    int p, q; cin >> p >> q;\n    p--; q--;\n    double dist = sqrt((x[p]-x[q]) * (x[p]-x[q]) + (y[p]-y[q]) * (y[p]-y[q]));\n    G[p].push_back(edge(q, dist));\n    G[q].push_back(edge(p, dist));\n    totalfence += dist;\n  }\n\n  vector<bool> used(N, false);\n  priority_queue<pair<double, int> > que;\n  double usedfence = 0.0;\n\n  while (find(used.begin(), used.end(), false) != used.end()) {\n    int first_unused = find(used.begin(), used.end(), false) - used.begin();\n    que.push(make_pair(0, first_unused));\n\n    while (!que.empty()) {\n      pair<double, int> p = que.top(); que.pop();\n      if (!used[p.second]) {\n        used[p.second] = true;\n        usedfence += p.first;\n        REP(i, G[p.second].size()) {\n          edge& e = G[p.second][i];\n          if (!used[e.to]) que.push(make_pair(e.cost, e.to));\n        }\n      }\n    }\n  }\n  \n  cout << setprecision(3) << setiosflags(ios::fixed);\n  cout << (totalfence - usedfence) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <queue>\n#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <cctype>\n#include <cassert>\n#include <limits>\n#include <functional>\n#include <stack>\n#include <array>\n#include <fstream>\n\n#define REP(i,n) for(int (i) = 0;(i) < (n) ; ++(i))\n#define REPA(a,i,n) for(int (i) = (a) ; (i) < (n) ; ++(i))\n#if defined(_MSC_VER)||__cplusplus > 199711L\n#define AUTO(r,v) auto r = (v)\n#else\n#define AUTO(r,v) typeof(v) r = (v)\n#endif\n#define ALL(c) (c).begin() , (c).end()\n#define EACH(it,c) for(AUTO(it,(c).begin());it != (c).end();++it)\n#define LL signed long  \n#define int LL\n#define INF  99999999\n#define DEV 1000000007\n#define QUICK_CIN ios::sync_with_stdio(false); cin.tie(0);\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int size) : data(size,-10) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\n};\n\nint n, m;\n\ntypedef pair<int, int> point;\n\npoint points[10010];\n\nstruct  edge{\n\tint to, from;\n\tdouble cost;\n};\n\nvector<edge> graph;\n\nUnionFind uf(10010);\n\nsigned main()\n{\n\tQUICK_CIN;\n\t//ifstream cin(\"debug.txt\");\n\n\tcin >> n >> m;\n\n\tREP(i, n){\n\t\tcin >> points[i].first >> points[i].second;\n\t}\n\n\tauto dist = [](point a, point b)->double\n\t{\n\t\tauto dx = (a.first - b.first);\n\t\tauto dy = (a.second - b.second);\n\t\treturn (double)sqrt(dx*dx + dy*dy);\n\t};\n\n\tedge p;\n\tREP(i, m){\n\t\tcin >> p.from >> p.to;\n\t\t--p.from; --p.to;\n\t\tp.cost = dist(points[p.from], points[p.to]);\n\t\tgraph.push_back(p);\n\t}\n\n\tsort(graph.begin(), graph.end(), [](edge a, edge b){return a.cost > b.cost; });\n\n\tdouble res(0);\n\n\n\tREP(i, m){\n\t\tauto e = graph[i];\n\n\t\tif (!uf.findSet(e.from, e.to)){\n\t\t\tuf.unionSet(e.from, e.to);\n\t\t}\n\t\telse{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\n\tcout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n能把所有的猫放出来，即不存在?\n那?我?就要破?\n?个?留切最小?，?剩大?\n即求最大生成?，ans=sum-MST;\n*/\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define RG register int\n#define maxn 10005\n#define rep(i,a,b)\tfor(RG i=a;i<=b;i++)\n#define per(i,a,b)\tfor(RG i=a;i>=b;i--)\n#define inf (1<<30)\nusing namespace std;\nint n,m,fa[maxn];\ndouble ans;\nstruct Point{\n\tdouble x,y;\n}point[maxn];\nstruct E{\n\tint u,v;\n\tdouble dis;\n\tbool operator < (const E &a)const{\n\t\treturn dis>a.dis;\n\t}\n}e[maxn*maxn/2];\ninline int read()\n{\n\tint x=0,f=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*f;\n}\n\ninline double cal(const int &a,const int &b)\n{\n\treturn sqrt((point[a].x-point[b].x)*(point[a].x-point[b].x)+(point[a].y-point[b].y)*(point[a].y-point[b].y));\n}\n\nint find(int x)\n{\n\tif(x==fa[x])\treturn x;\n\treturn fa[x]=find(fa[x]);\n}\n\ninline void MST()\n{\n\tsort(e+1,e+1+m);\n\trep(i,1,n)\tfa[i]=i;\n\tint cnt=0;double sum=0;\n\trep(i,1,m)\n\t{\n\t\tint fu=find(e[i].u),fv=find(e[i].v);\n\t\tif(fu!=fv)\n\t\t{\n\t\t\tcnt++;\n\t\t\tfa[fu]=fv;\n\t\t\tsum+=e[i].dis;\n\t\t}\n\t\tif(cnt==n-1)break;\n\t}\n\tprintf(\"%.3lf\",ans-sum);\n}\n\nint main()\n{\n\tn=read(),m=read();\n\trep(i,1,n)\tpoint[i].x=read(),point[i].y=read();\n\tfor(RG i=1;i<=m;i++)\te[i].u=read(),e[i].v=read(),e[i].dis=cal(e[i].u,e[i].v),ans+=e[i].dis;\n\tMST();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nP135\nPOJ 2377 Out of Hay\nDifficult: 2\n*/\n\n#include <iostream>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <functional>\n#include <string.h>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 10010;\nconst int MAXE = 1000000;\n\nint uset[MAXN];\nclass UnionSet{\npublic:\n    void Init(int n){\n        for(int i=0; i<=n; ++i)\n            uset[i] = i;\n    }\n    int Find(int x){\n        if( uset[x] == x ) return x;\n        else return uset[x] = Find(uset[x]);\n    }\n    bool Union(int x, int y){\n        int fx = Find(x), fy = Find(y);\n        if(fx == fy) return false;\n        uset[fx] = fy;\n        return true;\n    }\n};\n\n\nint x[MAXN], y[MAXN];\n\ndouble sq(int x)\n{\n    return x*x;\n}\n\nstruct Edge{\n    int u,v; double d;\n    double input(){\n        scanf(\"%d%d\", &u, &v);\n        u--, v--;\n        d = sqrt(sq(x[u] - x[v]) + sq(y[u] - y[v]));\n        return d;\n    }\n\n    bool operator<(const Edge&e)const{\n        return d > e.d;\n    }\n}edge[MAXE];\n\nconst int INF = 1<<30;\nint M, N;\ndouble total = 0;\nbool read()\n{\n    total = 0;\n    scanf(\"%d%d\", &N, &M);\n    for(int i=0; i<N; ++i)\n        scanf(\"%d%d\", &x[i], &y[i]);\n    for(int i=0; i<M; ++i)\n        total += edge[i].input();\n    return true;\n}\n\ndouble Kruskal()\n{\n    sort(edge, edge+M);\n    UnionSet us;\n    us.Init(N);\n    double ans = 0;\n    for(int i=0; i<M; ++i){\n        int u = edge[i].u, v = edge[i].v;\n        if(us.Union(u, v)) {\n            ans += edge[i].d;\n        }\n    }\n    return total - ans;\n}\n\nvoid solve()\n{\n    double ans = Kruskal();\n    printf(\"%.5f\\n\", ans);\n}\n\nint main()\n{\n    read();\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[120];\nint N, M, a, b; double x[120], y[120], d[120]; int g[120];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\td[1] = 0; g[1] = 1;\n\twhile (true) {\n\t\tint OK = 1;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (g[i] <= 1)OK = 0;\n\t\t}\n\t\tif (OK == 1)break;\n\t\tdouble maxn = -1; int maxid = 0;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t}\n\t\t}\n\t\tg[maxid] = 2;\n\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <stdio.h>\n#include <algorithm>\n#define Max 10010\nusing namespace std;\n\nint unit[Max*2],n,m;\n\nstruct st{\n    int from, to;\n    double cost;\n}edge[Max*2];\n\npair<int, int> ch[Max*2];\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++)\n        unit[i] = i;\n}\n\nint cmp(st a, st b){\n    return a.cost > b.cost;\n}\n\nint find(int k){\n    if(unit[k] == k) return k;\n    return unit[k] = find(unit[k]);\n}\n\nint isthesame(int a, int b){\n    int x = find(a), y = find(b);\n    if(x == y) return false;\n    else\n    {\n        //cout<<x<<\"  \"<<y<<endl;\n        unit[x] = y;\n        return true;\n    }\n}\n\ndouble kruskal(){\n    sort(edge+1, edge + m + 1, cmp);\n    init(n);\n    double ans = 0;\n    for(int i = 1; i <= m; i++)\n    {\n        if(isthesame(edge[i].from, edge[i].to))\n        {\n            ans += edge[i].cost;\n        }\n    }\n    return ans;\n}\n\nint main()\n{\n    int a,b,x,y;\n    cin >> n >> m;\n    for(int i = 1; i <= n; i++)\n    {\n        cin >> a >> b;\n        ch[i] = {a,b};\n    }\n    double allcost = 0;\n    for(int i = 1; i <= m; i++)\n    {\n        cin >> x >> y;//genhao x-x1^2+y-y1^2\n        double cost = sqrt((ch[x].first-ch[y].first)*(ch[x].first-ch[y].first)\n                           +(ch[x].second-ch[y].second)*(ch[x].second-ch[y].second));\n        allcost += cost;\n        edge[i] = {x, y, cost};\n       // cout << cost<<endl;\n    }\n    printf(\"%.3f\\n\", allcost - kruskal());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  int kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  int v = g.kruskal();\n  cout << g.sum << endl;\n  cout << v << endl;\n  printf(\"%.3lf\\n\", g.sum - v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n, m, f[10010], x[10010], y[10010];\ndouble ans = 0.0;\n\nstruct edge {\n\tint u, v;\n\tdouble w;\n\tbool operator < (const edge &b) const { return w < b.w; }\n}e[1000010];\n\ndouble getdis(int u, int v) {\n\treturn sqrt((double)(x[u] - x[v]) * (x[u] - x[v]) + (double)(y[u] - y[v]) * (y[u] - y[v]));\n}\n\nint find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }\n\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; ++i) {\n\t\tf[i] = i;\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tint u, v;\n\tfor(int i = 1; i <= m; ++i) {\n\t\tscanf(\"%d%d\", &u, &v);\n\t\te[i].u = u;\n\t\te[i].v = v;\n\t\te[i].w = getdis(u, v);\n\t}\n\tsort(e + 1, e + m + 1);\n\tfor(int i = m; i >= 1; --i) {\n\t\tint fu = find(e[i].u);\n\t\tint fv = find(e[i].v);\n\t\tif(fu != fv) f[fu] = fv;\n\t\telse ans += e[i].w;\n\t}\n\tprintf(\"%.3lf\\n\", ans);\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n//typedef complex<double> Point;\n//typedef complex<double> Vector;\ntypedef long long LL;\n\nint n,m;\nint pa[20000];\n\nvoid init()\n{\n    for(int i=0;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x]!= x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return w > t.w;\n    }\n}e[20000];\n\nstruct point\n{\n    int x,y;\n}p[20000];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        double sum = 0;\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty, e[i].w = sqrt(1.0*(p[tx].x - p[ty].x)*(p[tx].x - p[ty].x) + 1.0*(p[tx].y - p[ty].y)*(p[tx].y - p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint x[10002];\nint y[10002];\nint fa[10002];\nint n, m;\nint num;\nstruct edge{\n\tint u;\n\tint v;\n\tdouble cost;\n};\nbool cmp(edge a, edge b){\n\treturn a.cost < b.cost;\n}\nedge es[1000000];\nint find(int a){\n\tif (a == fa[a]) return a;\n\telse return fa[a] = find(fa[a]);\n}\nbool same(int a, int b){\n\tint aa = find(a);\n\tint bb = find(b);\n\tif (aa==bb) return true;\n\telse return false;\n}\n\nvoid unite(int a, int b){\n\tint aa = fa[a];\n\tint bb = fa[b];\n\tif (aa != bb){\n\t\tfa[aa] = bb;\n\t}\n}\ndouble krusal(){\n\tsort(es, es + num, cmp);\n\tdouble res = 0;\n\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\tfor (int i = 0; i < num; i++){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\t\n\tcin >> n >> m;\n\tfor (int i = 1; i <= n; i++)cin >> x[i] >> y[i];\n\tnum = 0;\n\tint u, v;\n\tdouble d;\n\tdouble  sum = 0;\n\twhile (m--){\n\t\tcin >> u >> v;\n\t\td = (x[u] - x[v])*(x[u] - x[v]) + (y[u] - y[v])*(y[u] - y[v]);\n\t\t\td = sqrt(d);\n\t\t\tes[num].u = u;\n\t\t\tes[num].v = v;\n\t\t\tes[num++].cost = -d;\n\t\t\tsum += d;\n\t}\n\tdouble ans = sum + krusal();\n\tprintf(\"%.3lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cstring>\n#include <climits>\n#include <cmath>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, int> ll_i;\nstruct edge { int u, v; double w; };\n\nstruct union_find {\n\tvector<int> v;\n\tunion_find(int n) : v(n, -1) {}\n\tint find(int x) { return (v[x] < 0) ? x : (v[x] = find(v[x])); }\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x != y) {\n\t\t\tif (-v[x] < -v[y]) swap(x, y);\n\t\t\tv[x] += v[y]; v[y] = x;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint size(int x) { return -v[find(x)]; }\n};\n\nbool kr_cmp(edge& l, edge& r) { return l.w < r.w; }\n\ndouble kruskal(int n, vector<edge>& E) {\n\tsort(E.begin(), E.end(), kr_cmp);\n\tunion_find uf(n);\n\tdouble res = 0;\n\tfor (int i = 0; i < E.size(); i++) {\n\t\tedge e = E[i];\n\t\tif (uf.same(e.u, e.v)) continue;\n\t\tuf.unite(e.u, e.v);\n\t\tres += e.w;\n\t}\n\treturn res;\n}\n\nint x[10000], y[10000];\n\nint main() {\n\tint N, M; scanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < N; i++)\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\tvector<edge> E;\n\tdouble ans = 0;\n\tfor (; M > 0; M--) {\n\t\tint p, q; scanf(\"%d%d\", &p, &q);\n\t\tint dx = x[p - 1] - x[q - 1];\n\t\tint dy = y[p - 1] - y[q - 1];\n\t\tdouble l = sqrt((double)(dx * dx + dy * dy));\n\t\tans += l;\n\t\tedge e = {p - 1, q - 1, -l}; E.push_back(e);\n\t}\n\tprintf(\"%lf\\n\", ans + kruskal(N, E));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <class T>\nstruct Edge {\n  using w_type = T;\n  Edge(int u, int v, w_type w): u(u), v(v), w(w) { }\n  int u, v;\n  w_type w;\n  bool operator<(const Edge<w_type> & rhs) const {\n    if (w != rhs.w) { return w < rhs.w; }\n    if (u != rhs.u) { return u < rhs.u; }\n    return v < rhs.v;\n  }\n  bool operator>(const Edge<w_type> & rhs) const {\n    return rhs < *this;\n  }\n};\n\nclass DisjointSet {\npublic:\n  DisjointSet(const unsigned n_sets): n_sets_(n_sets) {\n    parent_.reserve(n_sets);\n    rank_.reserve(n_sets);\n  }\n  void MakeSet(const unsigned x) { parent_[x] = x; rank_[x] = 0; }\n  void Union(const unsigned lhs, const unsigned rhs) {\n    Link(FindSet(lhs), FindSet(rhs));\n  }\n  void Link(const unsigned lhs, const unsigned rhs) {\n    if (rank_[lhs] > rank_[rhs]) { parent_[rhs] = lhs; }\n    else {\n      parent_[lhs] = rhs;\n      if (rank_[lhs] == rank_[rhs]) { ++rank_[rhs]; }\n    }\n  }\n  unsigned FindSet(const unsigned x) {\n    if (x != parent_[x]) { parent_[x] = FindSet(parent_[x]); }\n    return parent_[x];\n  }\n\nprivate:\n  unsigned n_sets_;\n  vector<unsigned> parent_;\n  vector<unsigned> rank_;\n};\n\ntemplate <class Edge>\ndecltype(auto) Kruskal(vector<Edge> & edges,\n                 typename vector<Edge>::size_type node_num) {\n  using size_type = typename vector<Edge>::size_type;\n  using w_type = typename Edge::w_type;\n\n  w_type weight_sum{0};\n  size_type edge_num = 0;\n  DisjointSet dis_set(node_num);\n  for (size_type i = 0; i < node_num; ++i) { dis_set.MakeSet(i); }\n  sort(edges.begin(), edges.end(), greater<Edge>());\n  for (auto & e: edges) {\n    if (dis_set.FindSet(e.u) != dis_set.FindSet(e.v)) {\n      weight_sum += e.w;\n      dis_set.Union(e.u, e.v);\n      ++edge_num;\n    }\n    if (edge_num == node_num - 1) { break; }\n  }\n\n  // Impossible\n  // if (edge_num != node_num - 1) { cout << \"IMPOSSIBLE\\n\"; }\n  return weight_sum;\n}\n\nint main(int argc, char const *argv[]) {\n  using w_type = double;\n\n  const w_type kInf = numeric_limits<w_type>::max();\n\n  vector<pair<int, int>> nodes;\n  vector<Edge<w_type>> edges;\n  w_type len_total = 0;\n  unsigned V, E;\n  cin >> V >> E;\n  for (unsigned i = 0; i < V; ++i) {\n    int x, y;\n    cin >> x >> y;\n    nodes.emplace_back(x, y);\n  }\n  for (unsigned i = 0; i < E; ++i) {\n    unsigned u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    w_type w = hypot(nodes[u].first - nodes[v].first,\n                     nodes[u].second - nodes[v].second);\n    edges.emplace_back(u, v, w);\n    len_total += w;\n  }\n  cout << fixed << setprecision(3) << len_total - Kruskal(edges, V) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ndouble zero(double d) {\n    return d < EPS ? 0.0 : d;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    return os << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    rep(i, a.size()) os << (i ? \" \" : \"\") << a[i];\n    return os << ']';\n}\n\n// to avoid error on mingw\nstring toString(int i) {\n    stringstream ss;\n    ss << i;\n    return ss.str();\n}\n\nconst int MOD = 1000000007;\n// a^k\nll fpow(ll a, ll k, int M) {\n    ll res = 1ll;\n    ll x = a;\n    while (k != 0) {\n        if ((k & 1) == 1)\n            res = (res * x) % M;\n        x = (x * x) % M;\n        k >>= 1;\n    }\n    return res;\n}\n\nclass UnionFind {\nprivate:\n    vi par;\n    vi rank;\n\n    int find(int x) {\n        if(par[x] == x)\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\npublic:\n    UnionFind(int n) {\n        rep(i,n) {\n            par.push_back(i);\n            rank.push_back(0);\n        }\n    }\n\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x==y) return;\n\n        if(rank[x] < rank[y])\n            par[x] = y;\n        else {\n            par[y] = x;\n            if(rank[x] == rank[y])\n                rank[x]++;\n        }\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\n\n\nstruct edge {int from, to; double cost;};\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\nll twice(int t) {return t*t;}\n\nint main() {\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(8);\n    ios_base::sync_with_stdio(false);\n\n    int N, M;\n    cin >> N >> M;\n\n    vector< pii > piles(N);\n    rep(i, N)\n        cin >> piles[i].first >> piles[i].second;\n\n    vector<edge> edges(M);\n    double totalCost = 0.0;\n    rep(i, M) {\n        int p, q;\n        cin >> p >> q;\n        --p, --q;\n        double cost = sqrt( twice(piles[p].first - piles[q].first) + twice(piles[p].second - piles[q].second) );\n        edges[i] = edge{ p, q, -cost };\n        totalCost += cost;\n    }\n\n    // kruscal\n    sort(all(edges), comp);\n    UnionFind uf(N);\n\n    double res = 0;\n\n    tr(it, edges) {\n        if(!uf.same(it->from, it->to)) {\n            uf.unite(it->from, it->to);\n            res += it->cost;\n        }\n    }\n\n    cout << totalCost - (-res) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint fa[1000000];\nint n, m;\nint num;\nstruct edge{\n\tint u;\n\tint v;\n\tdouble cost;\n};\nbool cmp(edge a, edge b){\n\treturn a.cost < b.cost;\n}\nedge es[1000000];\nint find(int a){\n\tif (a == fa[a]) return a;\n\telse return fa[a] = find(fa[a]);\n}\nbool same(int a, int b){\n\tint aa = find(a);\n\tint bb = find(b);\n\tif (aa==bb) return true;\n\telse return false;\n}\n\nvoid unite(int a, int b){\n\tint aa = fa[a];\n\tint bb = fa[b];\n\tif (aa != bb){\n\t\tfa[aa] = bb;\n\t}\n}\nint max(int a, int b){\n\tif (a > b)return a;\n\telse return b;\n\n}\nint krusal(){\n\t\n\tsort(es, es + num, cmp);\n\tint res = -10;\n\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\tfor (int i = 0; i < num; i++){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres=max(res,e.cost);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\t\n\tcin >> n >> m;\n\t\n\tnum = 0;\n\tint u, v,d;\n\t\n\t\n\twhile (m--){\n\t\tcin >> u >> v >> d;\n\t\t\n\t\t\tes[num].u = u;\n\t\t\tes[num].v = v;\n\t\t\tes[num++].cost = d;\n\t\t\t\n\t}\n\t\n\tprintf(\"%ld\\n\", krusal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\npair<double,pair<int,int> > edge[1000000];\nint UF[10010];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);\n\tif(a==b)return;\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n}\nint x[10010];\nint y[10010];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tUF[i]=-1;\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t}\n\tdouble ret=0;\n\tfor(int i=0;i<b;i++){\n\t\tint p,q;\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tp--;q--;\n\t\tdouble D=sqrt((x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n\t\tret+=D;\n\t\tedge[i]=make_pair(-D,make_pair(p,q));\n\t}\n\tstd::sort(edge,edge+b);\n\tfor(int i=0;i<b;i++){\n\t\tif(FIND(edge[i].second.first)!=FIND(edge[i].second.second)){\n\t\t\tret+=edge[i].first;\n\t\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\t}\n\t}\n\tprintf(\"%f\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii p(n);\n\trep(i, n)cin >> p[i].first >> p[i].second;\n\tvector<uset<int>> pf(n);\n\tvpii f(m);\n\tsegtree<pair<double,int>,min> st(m,make_pair(1e9,1e9));\n\trep(i, m) {\n\t\tint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tp1--;\n\t\tp2--;\n\t\tf[i] = { p1,p2 };\n\t\tst[i] = { hypot(p[p1].first - p[p2].first, p[p1].second - p[p2].second),i };\n\t\tpf[p1].insert(i);\n\t\tpf[p2].insert(i);\n\t}\n\trep(i, n) {\n\t\tint prev = i;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst[fn].first = 1e9;\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t}\n\tst.updateall();\n\tdouble ans = 0;\n\tpair<double,int> remove;\n\twhile(remove = st.query(0, m),remove.first<1e9) {\n\t\tans += remove.first;\n\t\tint fn = remove.second;\n\t\tst.update(fn, { 1e9,fn });\n\t\tpf[f[fn].first].erase(fn);\n\t\tpf[f[fn].second].erase(fn);\n\t\tint prev = f[fn].first;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst.update(fn, { 1e9,fn });\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t\tprev = f[fn].second;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst.update(fn, { 1e9,fn });\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t}\n\tcout << fixed << setprecision(10) << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string> \n#include <stack>\n#include <utility>\n#include <set>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nvector<int> g[10010];\nint main() {\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> x(N), y(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tvector<pair<double, pair<int,int>>> v;\n\tvector<int> h(N);\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tcin >> a >> b; a--, b--;\n\t\tdouble dist = sqrt((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b]));\n\t\tv.push_back({ dist, {a, b } });\n\t\th[a]++, h[b]++;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\t\t\n\tsort(v.begin(), v.end());\n\t\t\n\tdouble ret = 0;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (h[v[i].second.second] <= 1 || h[v[i].second.first] <= 1) continue;\n\t\tret += v[i].first;\n\t\th[v[i].second.second]--, h[v[i].second.first]--;\n\t\tint now = v[i].second.first;\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t\tnow = v[i].second.first;\n\t\twhile (h[now] <= 1) {\n\t\t\tbool flag = true;\n\t\t\tfor (int j : g[now]) {\n\t\t\t\tif (h[j] <= 1) continue;\n\t\t\t\th[j]--;\n\t\t\t\tnow = j;\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (flag) break;\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(15) << ret << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#define rep(i, l, r) for(int i = l; i <= r; ++i)\nusing namespace std;\nconst int maxn = 2e4 + 10;\nstruct point{\n\tint x, y;\n\tpoint(){}\n\tpoint(int x, int y):x(x), y(y){}\n\tpoint operator + (const point &a)const{\n\t\treturn point(x + a.x, y + a.y); \n\t}\n\tpoint operator - (const point &a)const{\n\t\treturn point(x - a.x, y - a.y);\n\t}\n}p[maxn];\nstruct edge{\n\tint l, r;\n\tdouble value;\n\tbool operator < (const edge &a)const{\n\t\treturn value > a.value;\n\t}\n}e[maxn];\ndouble sqr(double x){\n\treturn x * x;\n}\ndouble dist(point a, point b){\n\treturn sqrt(sqr(a.x - b.x) + sqr(a.y - b.y));\n}\nint fa[maxn];\nint get(int x){\n\tif(fa[x] == x)return x;\n\treturn fa[x] = get(fa[x]);\n}\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\trep(i, 1, n)fa[i] = i;\n\trep(i, 1, n)scanf(\"%d%d\",&p[i].x, &p[i].y);\n\tdouble ans = 0;\n\trep(i, 1, m){\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &e[i].l, &e[i].r);\n\t\te[i].value = dist(p[e[i].l], p[e[i].r]);\n\t\tans += dist(p[e[i].l], p[e[i].r]);\n\t}\n\tsort(e + 1, e + m + 1);\n\trep(i, 1, m)\n\t\tif(get(e[i].l) == get(e[i].r))continue;\n\t\telse {\n\t\t\tfa[get(e[i].l)] = get(e[i].r);\n\t\t\tans -= e[i].value;\n\t\t}\n\tprintf(\"%.8f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  vector<int> array[N];\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    array[i].push_back(i + 1);\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      for(k = 0; k < array[j].size(); k++) {\n\tif(links[i].node1 == array[j].at(k))\n\t  t1 = j;\n\telse if(links[i].node2 == array[j].at(k))\n\t  t2 = j;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      while(!array[t2].empty()) {\n\tarray[t1].push_back(array[t2].back());\n\tarray[t2].pop_back();\n      }\n    }\n  }\n\n  for(i = 0; i < N; i++) {\n    for(j = 0; j < array[i].size(); j++)\n      cout << array[i].at(j) << \" \";\n    cout << endl;\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,double> id;\nint n,m;\ndouble ans;\nP a[10000];\nvector<int> G[10000];\nbool used[10000];\n\ndouble getl(P a,P b){\n  return sqrt((a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s));\n}\n\ndouble prin(){\n  for(int i=0;i<n;i++){\n    if(used[i])continue;\n    priority_queue<id> q;\n    q.push(P(i,0));\n    while(!q.empty()){\n      id t=q.top();\n      if(used[t.f])continue;\n      used[t.f]=1;\n      ans-=t.s;\n      for(int j=0;j<G[t.f].size();j++)\n\tq.push(id(G[i][j],getl(a[i],a[j])));\n    }   \n  }\n  printf(\"%f\\n\",ans);\n}\n\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)\n    cin>>a[i].f>>a[i].s;\n  for(int i=0,p,q;i<m;i++){\n    cin>>p>>q;\n    p--,q--;\n    G[p].push_back(q);\n    G[q].push_back(p);\n    ans+=getl(a[p],a[q]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define N 100005\n#define P pair<int,int>\n#define ll long long\n#define mk(a, b) make_pair(a, b)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\nint inf = 0x3f3f3f3f;\nint n, m, pre[N];\nstruct ac{\n\tint v;\n\tdouble c;\n};\nvoid init() {\n\tfor (int i = 1; i <N; ++i) {\n\t\tpre[i] = i;\n\t}\n}\nint find(int x) {\n\tif (x == pre[x])\treturn x;\n\telse \treturn pre[x] = find(pre[x]);\n}\nvoid join(int x, int y) {\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy)\treturn;\n\telse if (fx < fy)\tpre[fy] = fx;\n\telse \tpre[fx] = fy;\n}\ndouble sum;\nbool vis[N];\ndouble dis[N];\nvector<P> a(N);\nvector<ac> g[N];\nvoid prime(int x) {\n\tmem(dis, 0);\n\tmem(vis, false);\n\tdis[x] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble MAX = 0;\n\t\tint u = -1;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (vis[j])\tcontinue;\n\t\t\tif (dis[j] > MAX) {\n\t\t\t\tMAX = dis[j];\n\t\t\t\tu = j;\n\t\t\t}\n\t\t}\n\t\tif (u == -1)\treturn;\n\t\tvis[u] = true;\n\t\tif (u == x)\tMAX = 0;\n\t\tsum += MAX;\n\t\t// cout << \"u = \" << u << \" \" << MAX << endl;\n\t\tfor (int j = 0; j < g[u].size(); ++j) {\n\t\t\tac t = g[u][j];\n\t\t\tif (vis[t.v])\tcontinue;\n\t\t\tif (dis[t.v] < t.c ) {\n\t\t\t\tdis[t.v] = t.c;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\nint main(){\n// #ifndef ONLINE_JUDGE\n//     freopen(\"in.txt\", \"r\", stdin);\n// #endif\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m) {\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tint dx = a[u].first - a[v].first;\n\t\t\tint dy = a[u].second - a[v].second;\n\t\t\tdouble temp = sqrt(dx * dx + dy * dy);\n\t\t\t// cout << \"temp = \" << temp << endl;\n\t\t\tans += temp;\n\t\t\tg[u].push_back((ac){v, temp});\n\t\t\tg[v].push_back((ac){u, temp});\n\t\t\tjoin(u, v);\n\t\t}\n\t\t// cout << ans << endl;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (pre[i] == i) {\n\t\t\t\tsum = 0;\n\t\t\t\tprime(i);\n\t\t\t\tans -= sum;\n\t\t\t\t// cout << i << \"::\" << sum << endl;\n\t\t\t}\n\t\t}\n\t\t// ans += 1;\n\t\t// cout << ans << endl;\n\t\tprintf(\"%.3lf\\n\",ans);\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<math.h>\n#define maxn 10010\n#define INF 0x7fffffff\nusing namespace std;\nstruct node\n{\n    double x,y;\n}mapp[maxn];\nint m,n;\ndouble Map[10001][10001],dis[maxn*maxn],sum1=0.0;\nbool vis[maxn];\nvoid prim()\n{\n    memset(vis,false,sizeof(vis));\n    memset(dis,0,sizeof(dis));\n    int pt=1;\n    double mam;\n    vis[1]=1;\n    dis[1]=0.0;\n    while(1)\n    {\n        for(int i=1;i<=n;i++)\n            if(!vis[i]&&dis[i]<Map[pt][i])\n                dis[i]=Map[pt][i];\n        pt=-1;\n        mam=-1;\n        for(int i=1;i<=n;i++)\n        {\n            if(!vis[i]&&dis[i]>mam)\n            {\n                mam=dis[i];\n                pt=i;\n            }\n        }\n        if(pt==-1)\n            break;\n        sum1=sum1+mam;\n        vis[pt]=true;\n    }\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    {\n        memset(mapp,0,sizeof(mapp));\n        memset(Map,0,sizeof(Map));\n        sum1=0.0;\n        for(int i=1;i<=n;i++)\n            scanf(\"%lf%lf\",&mapp[i].x,&mapp[i].y);\n        int x,y;\n        double sum=0.0;\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&x,&y);\n            Map[x][y]=Map[y][x]=sqrt((mapp[x].x-mapp[y].x)*(mapp[x].x-mapp[y].x)+(mapp[x].y-mapp[y].y)*(mapp[x].y-mapp[y].y));\n            sum+=Map[x][y];\n           // printf(\"坐?：%d %d;?? %.3f\\n\",x,y,Map[x][y]);\n        }\n        prim();\n        printf(\"%.3f\\n\",sum-sum1);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//23\n#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n\n#define S(X) ((X)*(X))\n\nusing namespace std;\n\nstruct E{\n  double l;\n  double s,t;\n  bool operator<(E a)const{\n    return l>a.l;\n  }\n};\n\nint uf[10000];\n\nint find(int x){\n  return (x==uf[x])?x:uf[x]=find(uf[x]);\n}\n\nvoid unite(int a,int b){\n  uf[find(a)]=find(b);\n}\n\nint main(){\n  int N,M;\n  cin>>N>>M;\n  for(int i=0;i<N;i++){\n    uf[i]=i;\n  }\n  int x[10000],y[10000];\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n  }\n  vector<E> v(M);\n  double t=0;\n  for(int i=0;i<M;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;\n    q--;\n    E e;\n    e.s=p;\n    e.t=q;\n    e.l=sqrt(S(y[p]-y[q])+S(x[p]-x[q]));\n    t+=e.l;\n    v[i]=e;\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<M;i++){\n    if(find(v[i].s)!=find(v[i].t)){\n      unite(v[i].s,v[i].t);\n      t-=v[i].l;\n    }\n  }\n  cout<<fixed<<t<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string>\ntemplate <class T> class Node {\npublic:\n\tNode()\n\t\t:parent(NULL), child(NULL)\n\t{};\n\tNode* parent;\n\tNode* child;\n\tT para;\n};\ntemplate <class T> class UnionFind {\npublic:\n\tvoid Connect(Node<T>* a, Node<T>* b) {\n\t\tVertex(a)->parent = Vertex(b);\n\t};\n\tbool Same(Node<T>* a, Node<T>* b) {\n\t\treturn Vertex(a) == Vertex(b);\n\t};\nprivate:\n\tNode<T>* Vertex(Node<T>* _obj) {\n\t\tif (_obj->parent == NULL) {\n\t\t\treturn _obj;\n\t\t}\n\t\telse {\n\t\t\treturn _obj->parent = Vertex(_obj->parent);\n\t\t}\n\t};\n};\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef priority_queue<int> PQ;\n#define _CRT_SECURE_NO_WARNINGS\nint N,M;\nint x[10010], y[10010];\nUnionFind<int> UF;\nstruct L{\n\tint s, g;\n\tdouble cost;\n\tbool operator < (const L& _l)const{\n\t\treturn cost < _l.cost;\n\t};\n\tbool operator > (const L& _l)const {\n\t\treturn cost > _l.cost;\n\t};\n\tvoid Set(int _x, int _y, double _c) {\n\t\ts = _x;\n\t\tg = _y;\n\t\tcost = _c;\n\t}\n}loads[10010 * 10010];\ndouble ans = 0;\nNode<int> n[10010];\n\nint main() {\n\tscanf(\"%d %d\", &N , &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tloads[i].Set(a, b, (double)sqrt( (double)((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) ) );\n\t}\n\tstd::sort(loads, &loads[M],std::greater<L>());\n\t\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!UF.Same(&n[loads[i].s], &n[loads[i].g])) {\n\t\t\tUF.Connect(&n[loads[i].s], &n[loads[i].g]);\n\t\t}\n\t\telse {\n\t\t\tans += loads[i].cost;\n\t\t}\n\t}\n\tprintf(\"%lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n\n#include<iomanip>\n\n\n#define MAXN 10002\nusing namespace std;\n\nint par[MAXN];\n\nclass E{\n\tpublic:\n\tE(){\n\t\t\n\t}\n\tE(int u,int v,double c):from(u),to(v),cost(c){\n\t}\n\tpublic:\n\t\tint from,to;\n\t\tdouble cost;\n\t\t\n\tbool operator >(const class E&e) const\n\t{\n\t\treturn cost<e.cost;\n\t}\n};\npriority_queue<E,vector<E>,greater<E> > pq;\n\nint N,M,V;\n\nvoid init(int V)\n{\n\tfor(int i=1;i<=V;i++)\n\t par[i] = -1;\n\t return ;\n}\n\nint find(int x)\n{\n\tif(par[x]<0)\n\t  return x;\n\telse\n\t return par[x] = find(par[x]);\n}\nint same(int a,int b)\n{\n\treturn find(a)==find(b);\n}\nvoid unite(int x,int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(par[x]<par[y])\n\t par[y] = x;\n\telse\n\t{\n\t\tif(par[x]==par[y])\n\t\t  par[y]--;\n\t\tpar[x] = y;\n\t}\n\treturn ;\n}\ndouble kruskal()\n{\n\tdouble res = 0;\n\tinit(V);\n\twhile(!pq.empty())\n\t{\n\t\tclass E e = pq.top();\n\t\tpq.pop();\n\t\tif(!same(e.from,e.to))\n\t      {\n\t      \tunite(e.from,e.to);\n\t      \tres +=e.cost;\n\t\t  }\n\t}\n\treturn res;\n}\npair<int,int> pile[MAXN];\n\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t cin >> N >> M;\n\t V = N;\n\t double sum = 0;\n\tfor(int i=1;i<=N;i++)\n\t  cin>> pile[i].first >> pile[i].second;\n\tfor(int i=1;i<=M;i++)\n\t{\n\t\tint u,v;\n\t\tdouble c;\n\t\tcin >> u >> v;\n\t\tint x1 = pile[u].first,y1 = pile[u].second,x2 = pile[v].first,y2 = pile[v].second;\n\t\tdouble s2 = (x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n\t\tc = sqrt(s2);\n\t\tpq.push( E(u,v,c));\n\t\tsum+=c;\n\t}\n\tcout<<fixed;\n\tcout<<setprecision(3);\n\tcout << sum-kruskal()<<endl;\n\t \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string.h>\n#include<math.h>\n#include<string>\nusing namespace std;\nconst int N=1000100;\nstruct node\n{\n    int l,r;\n    double cost;\n}p[N];\ndouble  x[N],y[N];\nint f[N];\nint Find(int x)\n{\n    if(x==f[x])\n        return x;\n    else\n    {\n        f[x]=Find(f[x]);\n        return f[x];\n    }\n}\nint merg(int a,int b)\n{\n    int t1=Find(a);\n    int t2=Find(b);\n    if(t1!=t2)\n    {\n        f[t2]=t1;\n        return 0;\n    }\n    return 1;\n}\nint cmp(node a,node b)\n{\n    return a.cost>b.cost;//?是从大到小排的\n}\nint main()\n{\n    int n,m;\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        int i,j;\n        for(i=1;i<=n;i++)\n        {\n            scanf(\"%lf%lf\",&x[i],&y[i]);\n        }\n        double s=0;\n        for(i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&p[i].l,&p[i].r);\n            int a=p[i].l,b=p[i].r;\n            p[i].cost=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n            s+=p[i].cost;\n        }\n        for(i=1;i<=n;i++)\n        {\n            f[i]=i;\n        }\n        sort(p,p+m,cmp);\n        double sum=0;\n        for(i=0;i<m;i++)\n        {\n            if(!merg(p[i].l,p[i].r))\n                sum+=p[i].cost;\n        }\n        printf(\"%.3lf\\n\",s-sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#define _CRT_SBCURE_NO_DEPRECATE\n#include <set>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <string>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n//#define UP(i,x,y) for(int i=x;i<=y;i++)\n//#define DOWN(i,x,y) for(int i=x;i>=y;i--)\n#define sdddd(x,y,z,k) scanf(\"%d%d%d%d\", &x, &y, &z, &k)\n#define sddd(x,y,z) scanf(\"%d%d%d\", &x, &y, &z)\n#define sdd(x,y) scanf(\"%d%d\", &x, &y)\n#define sd(x) scanf(\"%d\", &x)\n#define mp make_pair\n#define pb push_back\n#define lson k<<1\n#define rson k<<1|1\n#define mid (l+r)/2\n#define ms(x, y) memset(x, y, sizeof x)\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ull;\n#define MOD 1000000007\nconst int maxn = 10050;\nconst int INF = 0x3f3f3f3f;\nconst ll LINF = 0x3f3f3f3f3f3f3f3f;\nint n, m, s, t;\nint len;\nstruct road\n{\n    int u, v;\n    double cost;\n};\nint arr[maxn][2];\nroad G[maxn<<2];\nint par[maxn];\nvoid init()\n{\n    for(int i = 0; i < maxn; i++) par[i] = i;\n}\n\nint Find(int x)\n{\n    return par[x]==x? x : par[x] = Find(par[x]);\n}\nbool same(int x, int y)\n{\n    int fx = Find(x), fy = Find(y);\n    if(fx == fy)return true;\n    else        return false;\n}\nvoid unite(int x, int y)\n{\n    int fx = Find(x), fy = Find(y);\n    if(fx == fy) return;\n    else{\n        par[fx] = fy;\n        return;\n    }\n}\nbool cmp(road a, road b)\n{\n    return a.cost>b.cost;\n}\ndouble kruskal()\n{\n    sort(G, G+len, cmp);\n    init();\n    double res = 0;\n    int cnt = 1;\n    for(int i = 0; i < len; i++)\n    {\n        road e = G[i];\n        if(!same(e.u, e.v))\n        {\n            unite(e.u, e.v);\n            res+=e.cost;\n            cnt++;\n        }\n    }\n    return res;\n}\ndouble dist(double x, double y, double u, double v)\n{\n    return sqrt(abs(x-u)*abs(x-u) + abs(y-v)*abs(y-v));\n}\nset<pair<int,int> > st;\nint main()\n{\n\t//freopen(\"out.txt\", \"w\", stdout);\n    while(~sdd(n,m))\n    {\n        ms(G,0);\n        len = 0;\n        int ta, tb;\n        for(int i = 1; i <= n; i++)\n        {\n            sdd(arr[i][0], arr[i][1]);\n        }\n        double sum = 0;\n        for(int i = 1; i <= m; i++)\n        {\n            sdd(ta, tb);\n            if(!st.count(mp(ta, tb)))\n            {\n                G[len].u = ta;\n                G[len].v = tb;\n                G[len].cost = dist(arr[ta][0],arr[ta][1],arr[tb][0],arr[tb][1]);\n                sum += G[len].cost;\n                len++;\n                st.insert(mp(ta, tb));\n                st.insert(mp(tb, ta));\n            }\n        }\n        double ans = sum - kruskal();\n        printf(\"%.3f\\n\", ans);\n    }\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\tque.push(make_pair(0.0, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\tint v = r.second;\n\n\t\tif (u[v]) { continue; }\n\n\t\tres += r.first; u[v] = true;\n\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tif (!u[i])\n\t\t\t{\n\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%.9f\\n\", 100000.0 * (V - 1) - res);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define MAX_V 10000+116\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;\npair<int,int> p[MAX_V];\ndouble prim(){\n    for(int i=0;i<V;i++){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    double res=0;\n\n    while(true){\n        int v=-1;\n        for(int u=0;u<V;u++){\n            if(!used[u]&&(v==-1||mincost[u]<mincost[v]))v=u;\n        }\n\n        if(v==-1)break;\n        used[v]=true;\n        res+=mincost[v];\n        //cout<<v<<endl;\n        for(int u=0;u<V;u++){\n            mincost[u]=min(mincost[u],cost[v][u]);\n        }\n    }\n    return res;\n}\ndouble dis(int a,int b){\n    return sqrt((p[a].first-p[b].first)*(p[a].first-p[b].first)+(p[a].second-p[b].second)*(p[a].second-p[b].second));\n}\nint main(){\n   // freopen(\"1.txt\",\"r\",stdin);\n    int M;\n    while(~scanf(\"%d%d\",&V,&M)){\n        for(int i=0;i<V;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            p[i].first=a;\n            p[i].second=b;\n        }\n        double total=0;\n        for(int i=0;i<M;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            a--;b--;\n            cost[a][b]=cost[b][a]=-dis(a,b);\n            total+=-cost[b][a];\n        }\n        printf(\"%.3f\",total+prim());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nint x[10000];\nint y[10000];\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  rep(i,n) scanf(\"%d %d\", x+i, y+i);\n  vector<pair<double, pair<int, int> > > vec(m);\n  rep(i,m){\n    int p,q;\n    scanf(\"%d %d\", &p, &q);\n    p--;q--;\n    double d = sqrt((x[p]-x[q])*(x[p]-x[q]) + (y[p]-y[q])*(y[p]-y[q]));\n    vec[i].fi = d;\n    vec[i].se = mp(p,q);\n  }\n  sort(all(vec));\n  reverse(all(vec));\n\n  UnionFind uf(n);\n  double res=0;\n  rep(i,m){\n    if(uf.same(vec[i].se.fi, vec[i].se.se)){\n      res += vec[i].fi;\n    } else {\n      uf.unite(vec[i].se.fi, vec[i].se.se);\n    }\n  }\n  printf(\"%.4f\\n\", res);\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> pi;\ntypedef pair<double,pi> pdi;\n#define MK make_pair\n#define F first\n#define S second\nconst int MX=1e9+7;\nvector<int> a[20000];\nbool done[20000]={};\n\ndouble dis(pi c,pi b){\n  return (double)pow((c.first-b.first)*(c.first-b.first)+(c.second-b.second)*(c.second-b.second),1.0/2);\n}\n\nint DFS(int s,int g){\n  done[s]=true;\n  int count=0;\n  for(int i=0;i<a[s].size();i++){\n    if(done[s]!=a[s][i]){\n      if(a[s][i]==g){count++;}\n      count+=DFS(a[s][i],g); if(count>=2){break;}\n    }\n  }\n  return count;\n}\n\nint main(){\n  int n,m;\n  vector<pi> point;\n\n  priority_queue<pdi> q;\n  point.push_back(MK(0,0));\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int s,g;\n    cin>>s>>g;\n    point.push_back(MK(s,g));\n  }\n  for(int i=0;i<m;i++){\n    int s,g;\n    cin>>s>>g;\n    a[s].push_back(g);\n    a[g].push_back(s);\n    q.push(MK(-1.0*dis(point[s],point[g]),MK(s,g)));\n  }\n  double count=0;\n  while(!q.empty()){\n    pdi di=q.top();\n    q.pop();\n    if(DFS(di.S.F,di.S.S)<2){fill(done,done+15000,0); continue;}\n    fill(done,done+15000,0);\n    count-=di.F;\n    for(int i=0;i<a[di.S.F].size();i++){\n      if(a[di.S.F][i]==di.S.S){a[di.S.F].erase(a[di.S.F].begin()+i);}\n    }\n    for(int i=0;i<a[di.S.F].size();i++){\n      if(a[di.S.S][i]==di.S.F){a[di.S.S].erase(a[di.S.S].begin()+i);}\n    }\n  }\n  cout<<count<<endl;\n  \n  return 0;\n}\n  \n  \n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string>\ntemplate <class T> class Node {\npublic:\n\tNode()\n\t\t:parent(NULL), child(NULL)\n\t{};\n\tNode* parent;\n\tNode* child;\n\tT para;\n};\ntemplate <class T> class UnionFind {\npublic:\n\tvoid Connect(Node<T>* a, Node<T>* b) {\n\t\tVertex(a)->parent = Vertex(b);\n\t};\n\tbool Same(Node<T>* a, Node<T>* b) {\n\t\treturn Vertex(a) == Vertex(b);\n\t};\nprivate:\n\tNode<T>* Vertex(Node<T>* _obj) {\n\t\tif (_obj->parent == NULL) {\n\t\t\treturn _obj;\n\t\t}\n\t\telse {\n\t\t\treturn _obj->parent = Vertex(_obj->parent);\n\t\t}\n\t};\n};\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef priority_queue<int> PQ;\n#define _CRT_SECURE_NO_WARNINGS\nint N,M;\nint x[10010], y[10010];\nUnionFind<int> UF;\nstruct L{\n\tint s, g;\n\tfloat cost;\n\tbool operator < (const L& _l)const{\n\t\treturn cost < _l.cost;\n\t};\n\tbool operator > (const L& _l)const {\n\t\treturn cost > _l.cost;\n\t};\n\tvoid Set(int _x, int _y, float _c) {\n\t\ts = _x;\n\t\tg = _y;\n\t\tcost = _c;\n\t}\n}loads[10010 * 10010];\nfloat ans = 0;\nfloat total=0;\nNode<int> n[10010];\n\nint main() {\n\tscanf(\"%d %d\", &N , &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tloads[i].Set(a, b, (float)sqrt( (float)((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) ) );\n\t}\n\tstd::sort(loads, &loads[M],std::greater<L>());\n\t\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!UF.Same(&n[loads[i].s], &n[loads[i].g])) {\n\t\t\tUF.Connect(&n[loads[i].s], &n[loads[i].g]);\n\t\t}\n\t\telse {\n\t\t\tans += loads[i].cost;\n\t\t}\n\t}\n\tprintf(\"%f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#define MAX_N 1005\n#define MAX_R 20005\nusing namespace std;\n\ntypedef struct edge\n{\n\tint from,to,cost;\n} edge;\n\nbool mcmp(edge x,edge y)\n{\n\treturn x.cost<y.cost;\n}\n\nint uft[MAX_N];\nvector<edge>e;\n\nvoid init(int n)\n{\n\tint i;\n\tfor (i=0;i<=n;i++)\n\tuft[i]=i;\n}\n\nint parent(int n)\n{\n\tif (uft[n]==n)\n\t\treturn n;\n\telse\n\t\treturn uft[n]=parent(uft[n]);\n}\n\nvoid unit(int p, int q)\n{\n\tuft[parent(p)]=parent(q);\n}\n\nint same(int p, int q)\n{\n\treturn parent(p)==parent(q);\n}\n\nint kruskal(int n,int r)\n{\n\tint res=0;\n\tsort(e.begin(),e.end(),mcmp);\n\tinit(n);\n\tfor(int i=0;i<r;i++)\n\t{\n\t\tedge tmp=e[i];\n\t\tif(!same(tmp.from,tmp.to))\n\t\t{\n\t\t\tres+=tmp.cost;\n\t\t\tunit(tmp.from,tmp.to);\n\t\t\te[i].cost=0;\n\t\t}\n\t}\n\treturn res;\n}\n\nint piles[10001][2];\nint distance(int f,int t)\n{\n\treturn pow((double)piles[f][0]-piles[t][0],2)+pow((double)piles[f][1]-piles[t][1],2);\n}\n\nint main()\n{\n\tint N,M;\n\tint all_cost=0;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&piles[i][0],&piles[i][1]);\n\tfor(int j=0;j<M;j++)\n\t{\n\t\tedge tmp;\n\t\tscanf(\"%d%d\",&tmp.from,&tmp.to);\n\t\ttmp.cost=-distance(tmp.from,tmp.to);\n\t\te.push_back(tmp);\n\t}\n\tkruskal(N,M);\n\tdouble res=0.0;\n\tfor(int i=0;i<M;i++)\n\t\tres+=sqrt(-(double)e[i].cost);\n\tprintf(\"%.3lf\\n\",res);\n\te.clear();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define RG register\n#define LL long long\n#define fre(a) freopen(a\".in\",\"r\",stdin);//freopen(a\".out\",\"w\",stdout);\nusing namespace std;\nconst int MAXN=300000;\nint n,m;\nint X[MAXN],Y[MAXN],fa[MAXN];\ndouble ans,ALL;\nstruct ed\n{\n   int from,to;\n   double len;\n}edge[MAXN];\nbool comp(ed x,ed y){ return x.len>y.len; }\nint find(int x)\n{\n   if(x!=fa[x])\n      fa[x]=find(fa[x]);\n   return fa[x];\n}\nvoid Union(int x,int y)\n{\n   x=find(x);\n   y=find(y);\n   fa[x]=y;\n}\nvoid work()\n{\n   int cnt=0;\n   for(int i=1;i<=m;i++)\n      {\n\t int A=edge[i].from,B=edge[i].to;\n\t if(find(A)!=find(B))\n\t    {\n\t       Union(A,B);\n\t       ans+=edge[i].len;\n\t       cnt++;\n\t    }\n\t if(cnt>=n-1)break;\n      }\n}\nint main()\n{\n   //fre(\"1\");\n   scanf(\"%d%d\",&n,&m);\n   for(int i=1;i<=n;i++)\n      {\n\t scanf(\"%d%d\",&X[i],&Y[i]);\n\t fa[i]=i;\n      }\n   for(int i=1,a,b;i<=m;i++)\n      {\n\t scanf(\"%d%d\",&a,&b);\n\t edge[i].from=a;\n\t edge[i].to=b;\n\t edge[i].len=sqrt((X[a]-X[b])*(X[a]-X[b])+(Y[a]-Y[b])*(Y[a]-Y[b]));\n\t ALL+=edge[i].len;\n      }\n   sort(edge+1,edge+1+m,comp);\n   work();\n   ans=ALL-ans;\n   printf(\"%.3lf\\n\",ans);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"cstdio\"\n#include \"algorithm\"\n#include \"cmath\"\nusing namespace std;\nconst int MAXN=10000+10;\nint  n,m;\nstruct node{\n    int a,b; double vi;\n}edge[MAXN*MAXN];\ndouble x[MAXN];\ndouble y[MAXN];\nint F[MAXN];\nint Found(int x){\n    if(F[x]==x) return x;\n    return F[x]=Found(F[x]);\n}\nbool Union(int x,int y){\n    int xn=Found(x);\n    int yn=Found(y);\n    if(xn!=yn){\n        F[yn]=xn;\n        return true;\n    }\n    return false;\n    \n}\ndouble dis(double x1,double y1,double x2,double y2){\n    return sqrt(pow(x1-x2,2.0)+pow(y1-y2,2.0));\n}\nbool cmp(node a,node b){\n    return a.vi>b.vi;\n}\nint main(){\n    scanf(\"%d %d\",&n,&m);\n    double sum=0;\n    for(int i=1;i<=n;i++){\n        scanf(\"%lf %lf\",&x[i],&y[i]);\n    }\n    for(int i=1;i<=m;i++){\n        int a,b; scanf(\"%d %d\",&a,&b);\n        edge[i].a=a; edge[i].b=b;\n        edge[i].vi=dis(x[a],y[a],x[b],y[b]);\n        sum+=edge[i].vi;\n    }\n    for(int i=1;i<=n;i++)\n        F[i]=i;\n    sort(edge+1,edge+1+m,cmp);\n    for(int i=1;i<=m;i++){\n        if(Union(edge[i].a,edge[i].b)){\n            sum-=edge[i].vi;\n        }\n    }\n    printf(\"%.3lf\\n\",sum);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct edge{\n\tint from;\n\tint to;\n\tdouble cost;\n};\n\nint a[10000];\nint r[10000];\n\nvoid init(){\n\tfor(int i = 0;i < 10000;i++){\n\t\ta[i] = i;\n\t\tr[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(a[x] == x)\n\t\treturn x;\n\telse\n\t\treturn find(a[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(r[x] < r[y])\n\t\ta[x] = y;\n\telse{\n\t\ta[y] = x;\n\t\tif(r[x] == r[y])\n\t\t\tr[x]++;\n\t}\n}\n\ndouble dist(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));\n}\n\n/*int cmp(const void* a,const void* b){\n\tstruct edge *ea = (struct edge *)a;\n\tstruct edge *eb = (struct edge *)b;\n\treturn eb->cost > ea->cost;\n}*/\n\nbool cmp(const edge& l,const edge& r){\n\treturn l.cost > r.cost;\n}\n\nint main(void){\n\tint n, m, x[10000], y[10000], p, q, i, j, c;\n\tdouble s;\n\tstruct edge one;\n\tvector<struct edge> e;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\ts = 0;\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d\",&p,&q);\n\t\te.push_back(one);\n\t\te[i].from = p - 1,e[i].to = q - 1;\n\t\ts += e[i].cost = dist(x[p - 1],y[p - 1],x[q - 1],y[q - 1]);\n\t}\n\tsort(e.begin(),e.end(),cmp);\n//\tqsort(e,m,sizeof(e[0]),cmp);\n\tc = 0;\n\tinit();\n\tfor(i = 0;i < n;i++)\n\t\tif(i == a[i]) c++;\n\tfor(i = 0;i < m && c != 1;i++){\n\t\tif(find(e[i].from) != find(e[i].to)){\n\t\t\tunite(e[i].from,e[i].to);\n\t\t\ts -= e[i].cost;\n\t\t}\n\t\tc = 0;\n\t\tfor(j = 0;j < n;j++)\n\t\t\tif(j == a[j]) c++;\n\t}\n\tprintf(\"%.3f\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\nstruct point{\n    int x, y;\n    point(){x=y=0;}\n    point(int xx, int yy){ x=xx; y=yy;}\n};\n\nconst int MAX_N=10001;\nconst int MAX_M=MAX_N*MAX_N;\nedge edges[MAX_M];\npoint points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n    int N, M; \n    cin>>N>>M;\n        for(int i=1; i<=N; i++){\n            cin>>points[i].x>>points[i].y;\n        }\n        int p, q;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n            edges[i].w=sqrt((points[p].x-points[q].x)*(points[p].x-points[q].x)\n                          +(points[p].y-points[q].y)*(points[p].y-points[q].y));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    \n    fclose(stdin);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint par[20000];\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);y=find(y);\n\tpar[x]=y;\n}\nstruct st{\n\tint a,b;double c;\n};\nint x[20000],y[20000];\nint main(){\n\tint n,m;scanf(\"%d%d\",&n,&m);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\tvector<st>v;\n\tdouble sum=0;\n\trep(i,m){\n\t\tint p,q;scanf(\"%d%d\",&p,&q);p--;q--;\n\t\tdouble d=sqrt(pow(x[p]-x[q],2)+pow(y[p]-y[q],2));\n\t\tsum+=d;\n\t\tv.push_back({p,q,d});\n\t}\n\tsort(v.begin(),v.end(),[](st a,st b){\n\t\treturn a.c>b.c;\n\t});\n\trep(i,n)par[i]=i;\n\tfor(st&p:v){\n\t\tif(find(p.a)==find(p.b))continue;\n\t\tsum-=p.c;\n\t\tunite(p.a,p.b);\n\t}\n\tprintf(\"%.12lf\\n\",sum);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#define pi acos(-1)\n#define LL long long\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int, int> P;\nconst int maxn = 1e5 + 5;\n\nstruct edge\n{\n    int a, b;\n    double len;\n}fenc[maxn];\nstruct Point\n{\n    int x, y;\n}p[maxn];\ndouble cal(int a, int b)\n{\n    double x = p[a].x*1.0 - p[b].x*1.0;\n    double y = p[a].y*1.0 - p[b].y*1.0;\n    return sqrt(x*x + y*y);\n}\nint cmp(edge a, edge b)\n{\n    if (a.len > b.len) return 1;\n    return 0;\n}\nint ret[maxn];\nint find(int a)\n{\n    if (ret[a] == -1) return a;\n    return ret[a] = find(ret[a]);\n}\nint main(void)\n{\n//\tfreopen(\"C:\\\\Users\\\\wave\\\\Desktop\\\\NULL.exe\\\\NULL\\\\in.txt\",\"r\", stdin);\n    int n, m, i, j, k, a, b;\n    double ans;\n    while (cin >> n >> m)\n    {\n        for (i = 1; i <= n; i++)\n            scanf(\"%d %d\", &p[i].x, &p[i].y);\n        for (i = 1; i <= m; i++){\n            scanf(\"%d %d\", &a, &b);\n            fenc[i].a = a;\n            fenc[i].b = b;\n            fenc[i].len = cal(a, b);\n        }\n        sort(fenc+1, fenc+1+m, cmp);\n        memset(ret, -1, sizeof(ret));\n        ans = 0;\n        for (i = 1; i <= m; i++){\n            int x = find(fenc[i].a);\n            int y = find(fenc[i].b);\n            if (x == y)\n                ans += fenc[i].len;\n            else ret[x] = y;\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\nstruct point{\n    int x, y;\n    point(){x=y=0;}\n    point(int xx, int yy){ x=xx; y=yy;}\n};\n\nconst int MAX_N=10001;\nconst int MAX_M=MAX_N*MAX_N;\n//edge edges[MAX_M];\n//point points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n    int N, M; \n    cin>>N>>M;\n    point* points=new point[N+1];\n    edge* edges=new edge[M];\n        for(int i=1; i<=N; i++){\n            cin>>points[i].x>>points[i].y;\n        }\n        int p, q;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n            edges[i].w=sqrt((points[p].x-points[q].x)*(points[p].x-points[q].x)\n                          +(points[p].y-points[q].y)*(points[p].y-points[q].y));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    \n    fclose(stdin);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nint n,m;\nint pa[20000];\n\nvoid init()\n{\n    for(int i=1;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x] != x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return (t.w - w) < 1e-6;\n    }\n}e[100000];\n\nstruct point\n{\n    double x,y;\n}p[100000];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\n\nint main()\n{\n    //freopen(\"C:in.txt\",\"r\",stdin);\n    //freopen(\"C:out.txt\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(p,0,sizeof(p));\n        memset(e,0,sizeof(e));\n\n        init();\n        double sum = 0;\n\n        for(int i=1;i<=n;i++)\n            scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty;\n            e[i].w = sqrt((p[tx].x - p[ty].x)*(p[tx].x - p[ty].x) + (p[tx].y - p[ty].y)*(p[tx].y - p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_V = 10010;\nconst int MAX_E = 100010;\nconst int INF = 100000000;\nstruct edge {\n    int to, next;\n    double cost;\n};\nedge es[MAX_E];\nint head[MAX_V];\n\n\ndouble d[MAX_V];\nint cnt, V, E, s;\ntypedef pair<double,int> P;\nbool visited[MAX_V];\n\ndouble x[MAX_V];\ndouble y[MAX_V];\n\nvoid init() {\n    cnt = 0;\n    fill(head, head + MAX_V, -1);\n    fill(visited, visited + MAX_V, false);\n    fill(d, d + MAX_V, INF);\n}\n\nvoid add(int from, int to, double cost) {\n    es[cnt].to = to;\n    es[cnt].cost = cost;\n    es[cnt].next = head[from];\n    head[from] = cnt++;\n}\n\ndouble prim() {\n    double ans = 0;\n    for(int i = 1; i <= V; i++) {\n        if(visited[i]) continue;\n        priority_queue<P, vector<P>, greater<P> > que;\n        d[i] = 0;\n        que.push(P(0,i));\n\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int from = p.second;\n            if(visited[from]) continue;\n            ans += p.first;\n            visited[from] = true;\n            for(int i = head[from]; ~i; i = es[i].next) {\n                if (es[i].cost < d[es[i].to]) {\n                    d[es[i].to] = es[i].cost;\n                    que.push(P(d[es[i].to], es[i].to));\n                }\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    init();\n    scanf(\"%d%d\", &V, &E);\n    for(int i = 0; i < V; i++) {\n        scanf(\"%lf%lf\", &x[i+1], &y[i+1]);\n    }\n    int u, v;\n    double cost, sum = 0;\n    for(int i = 0; i < E; i++) {\n        scanf(\"%d%d\", &u, &v);\n        cost = sqrt((x[u] - x[v]) * (x[u] - x[v]) + (y[u] - y[v]) * (y[u] - y[v]));\n        sum += cost;\n        add(u, v, -cost);\n        add(v, u, -cost);\n    }\n    double ans = sum + prim();\n    printf(\"%.3f\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nconst int MAXV = 10000 + 16;\nconst int MAXE =  MAXV * 10;\nconst int INF = 0x3f3f3f3f;\ntypedef long long LL;\ntypedef pair<int, int> P; // 坐标点\n\nint N, M;\nint V, E;\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tEdge(int _from=0, int _to=0, double _cost=0) :from(_from), to(_to), cost(_cost){}\n};\nP p[MAXV];\nEdge edge[MAXE];\nint father[MAXV];\nint height[MAXV];\nbool cmp(const Edge& a, const Edge& b) {\n\treturn a.cost > b.cost;\n}\nvoid Init(int n) {\n\tfor (int i = 0; i < n; ++i) {\n\t\tfather[i] = i;\n\t\theight[i] = 0;\n\t}\n}\nint Find(int x) {\n\tif (father[x] == x)\n\t\treturn x;\n\telse\n\t\treturn father[x] = Find(father[x]);\n}\nvoid Unite(int x, int y) {\n\tx = Find(x);\n\ty = Find(y);\n\tif (x == y)\n\t\treturn;\n\tif (height[x] < height[y]) {\n\t\tfather[x] = y;\n\t} else {\n\t\tfather[y] = x;\n\t\tif (height[x] == height[y])\n\t\t\t++height[x];\n\t}\n}\nbool same(int x, int y) {\n\treturn Find(x) == Find(y);\n}\ndouble Kruskal() {\n\tInit(MAXV);\n\tsort(edge, edge + E, cmp);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i) {\n\t\tEdge e = edge[i];\n\t\tif (!same(e.from, e.to)) {\n\t\t\tUnite(e.from, e.to);\n\t\t}\n\t\telse {\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nvoid solve() {\n\tdouble res = Kruskal();\n\tprintf(\"%.3f\\n\", res);\n}\n\n\nint main(int argc, char const *argv[])\n{\n#ifdef LOCAL\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &N, &M) != EOF) {\n\t\tV = N; E = M;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tscanf(\"%d%d\", &p[i].first, &p[i].second);\n\t\t}\n\t\tint from, to, cost;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tscanf(\"%d%d\", &from, &to);\n\t\t\t--from; --to;\n\t\t\tint dx = p[from].first - p[to].first;\n\t\t\tint dy = p[from].second - p[to].second;\n\t\t\tdouble dist = sqrt(dx * dx + dy * dy);\n\t\t\tedge[i] = Edge(from, to, dist);\n\t\t}\n\t\tsolve();\n\t}\n\t//system(\"pause\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n//\nint par_uf[100010],rank_uf[100010];\n\nvoid init(int n){for(int i=0;i<n;i++){par_uf[i]=i;rank_uf[i]=0;}}\nint find(int x){if(par_uf[x]==x)return x;else return par_uf[x]=find(par_uf[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank_uf[x]<rank_uf[y])par_uf[x]=y;else{par_uf[y]=x;if(rank_uf[x]==rank_uf[y])rank_uf[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n//\n\nint N,M,x[10010],y[10010];\npair<double,pi> e[10010];\n\n#define sq(x) ((x)*(x))\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M;\n\trep(i,N)cin>>x[i]>>y[i];\n\tdouble ans=0;\n\trep(i,M){\n\t\tint p,q;\n\t\tcin>>p>>q;\n\t\tp--;q--;\n\t\tdouble len=sqrt(sq(x[p]-x[q])+sq(y[p]-y[q]));\n\t\tans+=len;\n\t\te[i]=mp(-len,mp(p,q));\n\t}\n\tsort(e,e+M);\n\tinit(N);\n\trep(i,M){\n\t\tint p=e[i].sec.fir,q=e[i].sec.sec;\n\t\tif(!same(p,q)){\n\t\t\tans+=e[i].fir;\n\t\t\tunite(p,q);\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(16)<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  int kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  int v = g.kruskal();\n  // cout << g.sum << endl;\n  // cout << v << endl;\n  printf(\"%.3lf\\n\", g.sum - v);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()) {\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t) {\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\n\ntypedef complex<double> P;\n\nclass UF {\npublic:\n\tstatic const int ufmax = 10052;\n\tint ufpar[ufmax], ufrank[ufmax], ufcnt[ufmax];\n\tUF() { init();}\n\tvoid init() {int i; rep(i, ufmax) { ufpar[i] = i; ufrank[i] = 0; ufcnt[i] = 1; } }\n\tint find(int x) {\treturn (ufpar[x] == x) ? (x) : (ufpar[x] = find(ufpar[x]));}\n\tint operator[](int x) {return find(x);}\n\tint count(int x) {return ufcnt[find(x)];}\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif(x == y) return;\n\t\tif(ufrank[x] < ufrank[y]) ufpar[x] = y, ufcnt[y] += ufcnt[x];\n\t\telse {ufpar[y] = x; ufcnt[x] += ufcnt[y]; if(ufrank[x] == ufrank[y]) ufrank[x]++;}\n\t}\n};\nUF uf;\n\nvoid mainmain() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<P> v(n);\n\trep(i, n) {\n\t\tdouble a, b;\n\t\tcin >> a >> b;\n\t\tv[i] = P(a, b);\n\t}\n\tpriority_queue<pair<double, pii>> pq;\n\tdouble sum = 0;\n\trep(i, m) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tpq.push(mkp(abs(v[a] - v[b]), pii(a, b)));\n\t\tsum += abs(v[a] - v[b]);\n\t}\n\tdouble ans = 0;\n\twhile(pq.size()) {\n\t\tauto top = pq.top();\n\t\tpq.pop();\n\t\tif(uf[top.S.F] == uf[top.S.S]) continue;\n\t\tans += top.F;\n\t\tuf.unite(top.S.F, top.S.S);\n\t}\n\tcout << sum - ans << endl;\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(20);\n\tmainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(const int& n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\n// int find(const int& x){\n// \tif(pa[x]==x) return x;\n// \telse pa[x] = find(pa[x]);\n// }\nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n\n// void unite(int x,int y){\n// \tx = find(x); y = find(y);\n\n// \tif(x==y) return;\n// \tif(ran[x] < ran[y]){\n// \t\tpa[x] = y;\n// \t}else{\n// \t\tpa[y] = x;\n// \t\tif(ran[x] == ran[y])\n// \t\t\t++ran[x];\n// \t}\n// }\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (ran[x] < ran[y])\n\t{\n\t\tpa[x] = y;\n\t}\n\telse\n\t{\n\t\tpa[y] = x;\n\t\tif (ran[x] == ran[y])\n\t\t{\n\t\t\t++ran[x];\n\t\t}\n\t}\n}\n\nbool same(const int& x,const int& y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\n#define sqr(x) ((x) * (x))\n\nstruct edge { int u, v; double cost; };\nconst int MAXN = 10000 + 16;\nconst int MAXM = MAXN << 3;\n\nint N, M, x[MAXN], y[MAXN];\nedge es[MAXM];\n\nint p[MAXN];\nvoid init_union_find(int N) {\n    for (int i = 0; i <= N; i++) {\n        p[i] = i;\n    }\n}\nint find(int i) {\n    if (p[i] != i) p[i] = find(p[i]);\n    return p[i];\n}\nint unite(int i, int j) {\n    p[find(i)] = p[find(j)];\n}\n\nbool cmp(const edge & e1, const edge & e2) {\n    return e1.cost < e2.cost;\n}\n\nint main() {\n    //freopen(\"2224-in29.txt\", \"r\", stdin);\n    cin >> N >> M;\n    for (int i = 1; i <= N; i++) {\n        cin >> x[i] >> y[i];\n    }\n    edge e;\n    for (int i = 0; i < M; i++) {\n        cin >> e.u >> e.v;\n        e.cost = sqrt(sqr(x[e.u]-x[e.v]) + sqr(y[e.u]-y[e.v]));\n        es[i] = e;\n    }\n    init_union_find(N);\n    sort(es, es + M, cmp);\n    double result = 0;\n    for (int i = M - 1; i >= 0; i--) { // descending\n        int u = es[i].u, v = es[i].v;\n        if (find(u) != find(v)) {\n            unite(u, v);\n        } else {\n            result += es[i].cost;\n        }\n    }\n    cout << fixed << setprecision(4) << result << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/*\n* @Author: 王文宇\n* @Date:   2018-03-14 23:59:01\n* @Last Modified by:   王文宇\n* @Last Modified time: 2018-03-15 00:12:07\n*/\n#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1000007;\n#define _for(i,a,b) for(int i=a;i<=b;i++)\nint n,m,fa[maxn];\nstruct node\n{\t\n\tint x,y;\n\tdouble length;\n}a[maxn];\nstruct point\n{\n\tint x,y;\n}b[maxn];\nbool cmp(node a,node b)\n{\n\treturn a.length>b.length;\n}\nint find(int x)\n{\n\treturn x==fa[x]?x:fa[x]=find(fa[x]);\n}\ndouble get(int x1,int x2,int y1,int y2)\n{\n\tdouble xx = (double)(x1-x2)*(double)(x1-x2);\n\tdouble yy = (double)(y1-y2)*(double)(y1-y2);\n\treturn sqrt(xx+yy);\n}\nint main(int argc, char const *argv[])\n{\n\tcin>>n>>m;\n\t_for(i,1,n)\n\t{\n\t\tfa[i]=i;\n\t\tint x,y;\n\t\tcin>>b[i].x>>b[i].y;\n\t}\n\tdouble sum = 0.0;\n\t_for(i,1,m)\n\t{\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\ta[i].x=x;\n\t\ta[i].y=y;\n\t\ta[i].length = get(b[x].x,b[y].x,b[x].y,b[y].y);\n\t\tsum+=a[i].length;\n\t}\n\tsort(a+1,a+1+m,cmp);\n\t_for(i,1,m)\n\t{\n\t\tint p = find(a[i].x);\n\t\tint q = find(a[i].y);\n\t\tif(p!=q)\n\t\t{\n\t\t\tsum-=a[i].length;\n\t\t\tfa[p]=q;\n\t\t}\n\t}\n\tprintf(\"%.3f\\n\",sum);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int u,v; double cost;\n  Edge(){}\n  Edge(int u, int v, double cost):u(u),v(v),cost(cost){}\n  bool operator<(const Edge &a)const{\n    return cost < a.cost;\n  }\n};\n\nstruct UnionFind{\n  int par[10005];\n  int rank[10005];\n  UnionFind(int n){ init(n); }\n  void init(int n){\n    for(int i=0;i<n;i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  int same(int x, int y){\n    return find(x) == find(y);\n  }\n  void unite(int x, int y){\n    x = find(x); y = find(y);\n    if(x==y) return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n};\n\nEdge es[50000000];\nint N,M;\nint x[10005],y[10005];\n\ndouble kruskal(){\n  UnionFind uf(N);\n  double res = 0;\n  sort(es, es+M);\n  for(int i=0;i<M;i++){\n    Edge e = es[i];\n    if(!uf.same(e.u, e.v)){\n      uf.unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n  \nint main(){\n  double sum = 0.0;\n  scanf(\"%d%d\",&N,&M);\n  rep(i,N) scanf(\"%d%d\", &x[i],&y[i]);\n  rep(i,M){\n    int p,q;\n    scanf(\"%d%d\",&p,&q); p--; q--;\n    double d = sqrt(SQ(x[p]-x[q])+SQ(y[p]-y[q]));\n    es[i] = Edge(p,q, -d);\n    sum += d;\n  }\n  printf(\"%lf\\n\", sum+kruskal());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\ntypedef pair<int,double> P;\n\nconst int MAX_N=1e4;\n\nint N,M;\nint x[MAX_N],y[MAX_N];\n\nvector<P> G[MAX_N];\n\ndouble mincost[MAX_N];\nbool used[MAX_N];\n\ndouble prim(){\n\tfill(mincost,mincost+N,-1);\n\tmincost[0]=0;\n\tdouble ans=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tREP(i,N){\n\t\t\tif (!used[i] && (v==-1 || mincost[v]<mincost[i])){\n\t\t\t\tv=i;\n\t\t\t}\n\t\t}\n\t\tif (v==-1) break;\n\t\tused[v]=true;\n\t\tif (mincost[v]!=-1){\n\t\t\tans+=mincost[v];\n\t\t}\n\t\tREP(i,G[v].size()){\n\t\t\tP p=G[v][i];\n\t\t\tmincost[p.first]=max(mincost[p.first],p.second);\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tdouble sum=0;\n\tscanf(\"%d %d\",&N,&M);\n\tREP(i,N){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tREP(i,M){\n\t\tint p,q;\n\t\tscanf(\"%d %d\",&p,&q);\n\t\tp--;\n\t\tq--;\n\t\tdouble cost=sqrt((double)(x[p]-x[q])*(x[p]-x[q])+(y[p]-y[q])*(y[p]-y[q]));\n\t\tG[p].push_back(P(q,cost));\n\t\tG[q].push_back(P(p,cost));\n\t\tsum+=cost;\n\t}\n\tprintf(\"%.5f\\n\",sum-prim());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n    int u;\t//?????????\n    int v;\t//??°??????\n    double cost;\t//??????\n    //???????????????????????§?????§?°???¢????????????\n    bool operator<(const edge& another) const {\n        return cost > another.cost;\n    }\n};\n\nconst int MAX_N = 10002;\nconst int MAX_M = 500000;\n\nP a[MAX_N];\nint n,m;\nedge es[MAX_M];\nint par[MAX_N];\nint rrank[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trrank[i] = 0;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\t//x???????????¨??¨y???????????¨?????????\n\tx = find(x);\t//x???????????¨??????????????????x??¨??????\n\ty = find(y);\t//y???????????¨??????????????????y??¨??????\n\tif(x == y) return;\n\tif(rrank[x] < rrank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rrank[x] == rrank[y])\n\t\t\trrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\t//x,y???????????¨???????????§?????????\n\treturn find(x) == find(y);\n}\n\ndouble kruskal(int n,int m){\n\tinitial(n);\n\tdouble res = 0;\n\tfor(int i=0;i<m;i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble dir(P p1,P p2)\n{\n    return sqrt((p2.first - p1.first)*(p2.first - p1.first) + (p2.second - p1.second)*(p2.second - p1.second));\n}\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    rep(i,n){\n        scanf(\"%d%d\",&a[i].first,&a[i].second);\n    }\n    rep(i,m){\n        int p,q;\n        scanf(\"%d%d\",&p,&q);\n        es[i] = (edge){p-1,q-1,dir(a[p-1],a[q-1])};\n    }\n    double sm = 0.0;\n    rep(i,m){\n        sm += es[i].cost;\n    }\n    sort(es,es+m);\n    printf(\"%.3f\\n\",sm - kruskal(n,m));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstruct edge{\n    int u,v;\n    double cost;\n    edge(int a,int b,double c):u(a),v(b),cost(c){}\n    edge(){}\n    bool operator<(const edge &d)const{\n        return cost<d.cost;\n    }\n};\nint uf_par[10000],uf_rank[10000];\nvoid uf_init(int n){\n    for(int i=0;i<n;i++){\n        uf_par[i]=i;\n        uf_rank[i]=0;\n    }\n}\nint uf_find(int x){\n    return (uf_par[x]==x)?(x):(uf_par[x]=uf_find(uf_par[x]));\n}\nvoid uf_unite(int x,int y){\n    x=uf_find(x);\n    y=uf_find(y);\n    if(x==y)return;\n\n    if(uf_rank[x]<uf_rank[y])uf_par[y]=x;\n    else{\n        uf_par[x]=y;\n        if(uf_rank[x]==uf_rank[y])uf_rank[x]++;\n    }\n}\nbool uf_same(int x,int y){\n    return uf_find(x)==uf_find(y);\n}\nint main(){\n    int x[10000],y[10000];\n    int n,m;\n    vector<edge>es;\n    double sum=0.0,res=0.0;\n    cin>>n>>m;\n    uf_init(n);\n    es.resize(m);\n    for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n    for(int i=0;i<m;i++){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        double dis=sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n        es[i]=edge(a,b,-dis);\n        sum+=dis;\n    }\n    sort(es.begin(),es.end());\n    for(int i=0;i<m;i++){\n        edge e=es[i];\n        if(uf_same(e.u,e.v))continue;\n        uf_unite(e.u,e.v);\n        res+=e.cost;\n    };\n    cout<<fixed<<sum+res<<endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\n\nint par[500100],ranks[500100],kosuu[500100];     \n\nvoid shoki(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tranks[i]=0;\n\t\tkosuu[i]=1;\n\t}\n}\n\nint root(int x){\n\treturn par[x]==x ? x : par[x]=root(par[x]);\n}\n\nbool same(int x,int y){\nreturn root(x)==root(y);\n}\n\nvoid unite(int x,int y){\n x=root(x);\n y=root(y);\n\tint xx=kosuu[x],yy=kosuu[y];\n if(x==y) return;\n\tif(ranks[x]<ranks[y]){\n\t\tpar[x]=y;\n\t\tkosuu[y]=yy+xx;\n\t}\n else {\n\tpar[y]=x;\n\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n \tkosuu[x]=yy+xx;\n }\n\treturn;\n}\n\n\n/* ---memo---\nshoki(n)でn個の点に対する初期化を必ず。\nunite(a,b)でaとbを同じグループに入れる\nsame(a,b)がtrueなら同グループ,falseなら別。\n*/\nint x[10030],y[10030];\nvector<pal> ve;\n\ndouble dis(int i,int j){\n\treturn sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j]));\n}\n         signed main(){\nint n,m;\n         \tcin>>n>>m;\n         \tfor(int i=1;i<=n;i++)cin>>x[i]>>y[i];\n         \tshoki(11002);\n        double ans=0; \t\n         \tfor(int i=0;i<m;i++){\n         \t\tint s,t;\n         \t\tcin>>s>>t;\n         \t\tans+=dis(s,t);\n         \t\tve.pb(mp(dis(s,t),mp(s,t)));\n         \t}\n         \tsort(ve.begin(),ve.end());\n         \t\n         \tfor(int i=m-1;i>=0;i--){\n         \t\tif(same(ve[i].second.first,ve[i].second.second)) continue;\n         \t\tunite(ve[i].second.first,ve[i].second.second);\n         \t\tans-=ve[i].first;\n         \t}\n         \tprintf(\"%.10lf\\n\",ans);\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 3e4;\nint u[maxn], v[maxn], r[maxn];\ndouble w[maxn];\nint p[maxn], a[maxn], b[maxn];\n\nint find(int x) {return p[x] == x ? x : p[x] = find(p[x]);}\n\nbool cmp(int x, int y){\n\treturn w[x] > w[y];\n}\n\ndouble calc(int x1, int x2, int y1, int y2){\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\nint main(int argc, char const *argv[])\n{\n\t// freopen(\"in.txt\", \"r\", stdin);\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 1; i <= n; i++){\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t}\n\tdouble ans = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tw[i] = calc(a[u[i]], a[v[i]], b[u[i]], b[v[i]]);\n\t\tr[i] = i;\n\t\tans += w[i];\n\t\t// printf(\"%lf\\n\", w[i]);\n\t}\n\t// printf(\"%lf\\n\", ans);\n\tfor(int i = 1; i <= n; i++) p[i] = i;\n\tsort(r, r+m, cmp);\n\tfor(int i = 0; i < m; i++){\n\t\tint k = r[i];\n\t\tif(find(u[k]) == find(v[k])) continue;\n\t\tp[find(v[k])] = find(u[k]);\n\t\tans -= w[k];\n\t\t// printf(\"%lf\\n\", w[k]);\n\t}\n\tprintf(\"%lf\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n\nusing namespace std;\n\nstruct edge{\n  int src, dst, w;\n  edge(int src, int dst, int w):src(src),dst(dst),w(w){}\n  bool operator<(const edge &t)const{\n    if( w != t.w ) return w > t.w;\n    if( src != t.src ) return src < t.src;\n    return dst < t.dst;\n  }\n};\ntypedef vector<edge> edges;\ntypedef vector<edges> graph;\n\nconst int N = 10010;\nconst int INF = 800000010;\n\ndouble mst_prim(const graph &g, int r, bool ran[N]){\n  const int n = g.size();\n  double ret = 0;\n  bool vis[n];\n  \n  fill(vis,vis+n,false);\n  priority_queue<edge> Q;\n  Q.push( edge(-1,r,INF-0) );\n  ran[r] = true;\n  while(!Q.empty()){\n    edge e = Q.top(); Q.pop();\n    if( vis[e.dst] ) continue;\n    //cout << e.w << ' ' << -e.w + 10000 << ' ' << ret << endl;\n    ret += sqrt(-e.w+INF);\n    vis[e.dst] = true;\n    ran[e.dst] = true;\n    for(int i = 0; i < (int)g[e.dst].size(); ++i){\n      if( !vis[g[e.dst][i].dst] ) Q.push( g[e.dst][i] );\n    }\n  }\n  return ret;\n}\n\n#define SQ(a) ((a)*(a))\n\nint main()\n{\n  int n,m;\n  while(EOF!=scanf(\"%d%d\",&n,&m)){\n    int x[n],y[n];\n    bool ran[N];\n    double total = 0;\n    graph g(n);\n\n    for(int i = 0; i < n; ++i){\n      scanf(\"%d%d\", &x[i], &y[i]);\n    }\n    fill(ran,ran+n,false);\n    \n    for(int i = 0; i < m; ++i){\n      int p,q;\n      scanf(\"%d%d\", &p, &q);\n      --p;\n      --q;\n      int w = SQ(abs(x[p]-x[q])) + SQ(abs(y[p]-y[q]));\n      total += sqrt(w);\n      g[p].push_back( edge(p,q,INF-w) );\n      g[q].push_back( edge(q,p,INF-w) );\n    }\n\n    double rem = 0;\n    for(int i = 0; i < n; ++i){\n      if(!ran[i]){\n\tdouble tmp = mst_prim(g,i,ran);\n\t//cout << tmp << endl;\n\trem += tmp;\n      }\n    }\n    printf(\"%.12lf\\n\", total-rem);\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<iomanip>\n#include<cmath>\n#define MAX 10000\n#define MP make_pair\n#define INF (1<<21)\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n \nint parent[MAX];\n \nint findRoot(int x)\n{\n    if (parent[x] != x)\n    {\n        parent[x] = findRoot(parent[x]);\n    }\n    else\n    {\n        return x;\n    }\n}\n \nbool same(int x, int y)\n{\n    return findRoot(x) == findRoot(y);\n}\n \nvoid unite(int x, int y)\n{\n    int root1 = findRoot(x);\n    int root2 = findRoot(y);\n    parent[root1] = root2;\n}\n \ntypedef double Weight;\ntypedef pair<int, int> Pair;\ntypedef pair<Weight, Pair> Edge;\n \npriority_queue<Edge> q;\n \ndouble kruskal()\n{\n    REP(i, MAX)\n    {\n        parent[i] = i;\n    }\n    double total = 0.0;\n    double total_ans = 0.0;\n    while (!q.empty())\n    {\n        Edge top = q.top();\n        int X = top.second.first;\n        int Y = top.second.second;\n        if (same(X, Y) == false)\n        {\n            unite(X, Y);\n            total += top.first;\n        }\n        else\n        {\n            total_ans += top.first;\n        }\n        q.pop();\n    }\n    return total_ans;\n}\n \npair<int,int> Z[MAX];\n \nint main()\n{\n    cout<<1<<endl;\nreturn 0;\n    int N, M;\n    cin >> N >> M;\n    REP(i, N)\n    {\n        int px, py;\n        cin >> px >> py;\n        Z[i] = MP(px, py);\n    }\n    REP(i, M)\n    {\n        int x, y;\n        cin >> x >> y;\n        double tmp_x = Z[x-1].first - Z[y-1].first;\n        double tmp_y = Z[x-1].second - Z[y-1].second;\n        double w = sqrt(tmp_x*tmp_x + tmp_y*tmp_y);\n        q.push(MP(w, MP(x, y)));\n    }\n \n    cout << fixed << setprecision(10) << kruskal() << endl;\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nclass Point{\npublic:\n    double x,y;\n    Point();\n    Point(double _x,double _y);\n};\nconst int MAX = 10010;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-5;\nPoint p[MAX];\nint N,M;\nclass Node{\npublic:\n    int to;\n    double len;\n    Node();\n    Node(int _to,double _len);\n};\nvector<Node> G[MAX];\nbool used[MAX];\ndouble Dis[MAX];\ndouble getLen(int u,int v){\n    double res = (p[u].x-p[v].x)*(p[u].x-p[v].x) + (p[u].y-p[v].y)*(p[u].y-p[v].y);\n    return sqrt(res);\n}\n\ndouble Prim(){\n    memset(used,false,sizeof(used));\n    fill(Dis+1,Dis+1+N,-INF);\n    Dis[1] = 0;\n    double res = 0;\n    while(true){\n        int u = -1;\n        for(int i=1;i<=N;++i){\n            if(!used[i] && (u == -1 || Dis[i] - Dis[u] > eps))\n                u = i;\n        }\n        if(u == -1) break;\n        used[u] = true;\n        res += Dis[u];\n        for(vector<Node>::iterator it = G[u].begin();it != G[u].end();++it){\n            if(!used[it->to] && (it->len - Dis[it->to] > eps))\n                Dis[it->to] = it->len;\n        }\n    }\n    return res;\n}\nint main(void){\n    cin >> N >> M;\n    for(int i=1;i<=N;++i){\n        cin >> p[i].x >> p[i].y;\n    }\n    double sum = 0;\n    int u,v;\n    for(int i=1;i<=M;++i){\n        cin >> u >> v;\n        double len = getLen(u,v);\n        sum += len;\n        G[u].push_back(Node(v,len));\n        G[v].push_back(Node(u,len));\n    }\n    double res = sum - Prim();\n    cout << fixed << setprecision(3) << res << endl;\n    return 0;\n}\n\nPoint::Point(){\n    x = y = 0;\n}\nPoint::Point(double _x,double _y){\n    x = _x;\n    y = _y;\n}\nNode::Node(){\n    to = 0;\n    len = 0;\n}\nNode::Node(int _to,double _len){\n    to = _to;\n    len = _len;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\nstruct point{\n    int x, y;\n    point(){x=y=0;}\n    point(int xx, int yy){ x=xx; y=yy;}\n};\n\nconst int MAX_N=10001;\nconst int MAX_M=MAX_N*MAX_N/2;\nedge edges[MAX_M];\npoint points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n    int N, M; \n    cin>>N>>M;\n        for(int i=1; i<=N; i++){\n            cin>>points[i].x>>points[i].y;\n        }\n        int p, q;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n            edges[i].w=sqrt((points[p].x-points[q].x)*(points[p].x-points[q].x)\n                          +(points[p].y-points[q].y)*(points[p].y-points[q].y));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    \n    fclose(stdin);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define db double\n#define ll long long\n#define RG register\n\ninline int gi()\n{\n\tRG int ret; RG bool flag; RG char ch;\n\tret=0, flag=true, ch=getchar();\n\twhile (ch < '0' || ch > '9')\n\t\tch == '-' ? flag=false : 0, ch=getchar();\n\twhile (ch >= '0' && ch <= '9')\n\t\tret=(ret<<3)+(ret<<1)+ch-'0', ch=getchar();\n\treturn flag ? ret : -ret;\n}\n\nconst db pi = acos(-1.0);\nconst int N = 142857, inf = 1<<30;\n\nstruct poi\n{\n\tint x,y;\n}p[N];\nstruct edge\n{\n\tint fr,to;\n\tdb dis;\n\tinline bool operator <(const edge &E) const { return dis > E.dis; }\n}e[N*10];\nint fa[N];\n\ninline db Dis(int a,int b)\n{\n\treturn sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y));\n}\n\ninline int find(int o)\n{\n\treturn fa[o] == o ? o : fa[o]=find(fa[o]);\n}\n\nint main()\n{\n\tint n,m,i,x,y;\n\tdb ans,len;\n\tn=gi(), m=gi();\n\tfor (i=1; i<=n; ++i)\n\t\tp[i].x=gi(), p[i].y=gi();\n\tans=0;\n\tfor (i=1; i<=m; ++i)\n\t\te[i].fr=x=gi(), e[i].to=y=gi(), e[i].dis=len=Dis(x,y), ans+=len;\n\tsort(e+1,e+m+1);\n\tfor (i=1; i<=n; ++i)\n\t\tfa[i]=i;\n\tfor (i=1; n>1; ++i)\n\t\t{\n\t\t\tx=e[i].fr, y=e[i].to;\n\t\t\tx=find(x), y=find(y);\n\t\t\tif (x != y)\n\t\t\t\tans-=e[i].dis, fa[x]=y, n--;\n\t\t}\n\tprintf(\"%.3f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\n\nclass Edge{\npublic:\n  int from, to;\n  double cost;\n\n  Edge(){}\n  Edge(int _from, int _to, double _cost){\n    from = _from;\n    to = _to;\n    cost = _cost;\n  }\n\n  bool operator<(const Edge &e)const{\n    return cost > e.cost;\n  }\n};\n\nint n, m;\ndouble x[10002], y[10002];\nvector<Edge> es;\n\nint par[10002];\nint rank[10002];\n\ndouble dist(int a, int b){\n  return\n    sqrt( (x[a] - x[b]) * (x[a] - x[b]) +\n          (y[a] - y[b]) * (y[a] - y[b]) );\n}\n\nvoid init(void){\n  for(int i = 0; i < 10002; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }\n  else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n \n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }\n  else{\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\ndouble solve(){\n  sort(es.begin(), es.end());\n  init();\n\n  double res = 0;\n\n  for(int i = 0; i < es.size(); i++){\n    Edge e = es[i];\n\n    if(!same(e.from, e.to)){\n      unite(e.from, e.to);\n      res += e.cost;\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(cin >> n >> m){\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i];\n    }\n\n    double sum = 0;\n    es.clear();\n\n    for(int i = 0; i < m; i++){\n      int a, b;\n      cin >> a >> b;\n      a--;\n      b--;\n\n      double d = dist(a, b);\n\n      es.push_back(Edge(a, b, d));\n      sum += d;\n    }\n\n    printf(\"%.3f\\n\", sum - solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nclass UnionFind {\nprivate:\n\tint size_; vector<int> g; vector<vector<int> > v;\npublic:\n\tUnionFind() : size_(0), g(vector<int>()), v(vector<vector<int> >()) {};\n\tUnionFind(int size__) : size_(size__) { g.resize(size_), v.resize(size_); for (int i = 0; i < size_; i++) g[i] = i, v[i] = { i }; };\n\tint size() { return size_; }\n\tint root(int x) { return g[x]; }\n\tint size(int x) { return v[x].size(); }\n\tbool same(int x, int y) { return g[x] == g[y]; }\n\tvoid unite(int x, int y) {\n\t\tx = g[x], y = g[y];\n\t\tif (x == y) return;\n\t\tif (v[x].size() < v[y].size()) swap(x, y);\n\t\tv[x].insert(v[x].end(), v[y].begin(), v[y].end());\n\t\tfor (auto &e : v[y]) g[e] = x;\n\t\tv[y].clear();\n\t}\n\tbool operator==(const UnionFind& u) { return g == u.g; }\n\tbool operator!=(const UnionFind& u) { return g != u.g; }\n\tint operator[](int x) { return g[x]; }\n};\nstruct edge { int s, to, cost; };\nbool operator<(const edge& e1, const edge& e2) { return e1.cost < e2.cost; }\nint V, E, x[10009], y[10009], s, t; edge e[99999];\nint main() {\n\tscanf(\"%d%d\", &V, &E);\n\tfor (int i = 0; i < V; i++) scanf(\"%d%d\", x + i, y + i);\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d%d\", &s, &t); s--, t--;\n\t\tint dist = (x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]);\n\t\te[i] = edge{ s, t, dist };\n\t}\n\tsort(e, e + E);\n\treverse(e, e + E);\n\tUnionFind u(V);\n\tdouble ret = 0;\n\tfor (auto &v: e) {\n\t\tif (u.same(v.s, v.to)) ret += sqrt(v.cost);\n\t\telse u.unite(v.s, v.to);\n\t}\n\tprintf(\"%.9f\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long LL;\n\nint n,m;\nint pa[20000];\n\nvoid init()\n{\n    for(int i=1;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x] != x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return (t.w - w)< 1e-6;\n    }\n}e[20000];\n\nstruct point\n{\n    int x,y;\n}p[20000];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\n\nint main()\n{\n    freopen(\"C:in.txt\",\"r\",stdin);\n    freopen(\"C:out.txt\",\"w\",stdout);\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(p,0,sizeof(p));\n        memset(e,0,sizeof(e));\n\n        init();\n        double sum = 0;\n\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty, e[i].w = sqrt(1.0*(1.0*p[tx].x - 1.0*p[ty].x)*(1.0*p[tx].x - 1.0*p[ty].x)+ 1.0*(1.0*p[tx].y - 1.0*p[ty].y)*(1.0*p[tx].y - 1.0*p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\ntypedef struct {\n    int x, y;\n} Pile;\n\ntypedef struct {\n    int a, b;\n    double cost;\n} Edge;\n\nbool operator < (const Edge& l, const Edge& r){\n    return l.cost < r.cost;\n}\n\nint _par[MAX_N];\nint _rank[MAX_N];\n\nvoid init(int n){\n    for(int i=0; i<n; i++){\n        _par[i] = i;\n        _rank[i] = 0;\n    }\n}\n\nint root(int x){\n    if(x == _par[x])\n        return x;\n    return _par[x] = root(_par[x]);\n}\n\nvoid unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    \n    if(_rank[x] < _rank[y]){\n        _par[x] = y;\n    }else{\n        _par[y] = x;\n        if(_rank[x] == _rank[y])\n            _rank[x]++;\n    }\n}\n\nbool is_same_group(int x, int y){\n    return root(x) == root(y);\n}\n\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Pile> piles(n);\n    for(int i=0; i<n; i++){\n        auto & pile = piles[i];\n        cin >> pile.x >> pile.y;\n    }\n    \n    priority_queue<Edge> edges;\n    for(int i=0; i<m; i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        \n        double cost = sqrt((piles[a].x-piles[b].x)*(piles[a].x-piles[b].x) + (piles[a].y-piles[b].y)*(piles[a].y-piles[b].y));\n        \n        Edge edge;\n        edge.a = a; edge.b = b; edge.cost = cost;\n        \n        edges.push(edge);\n    }\n    \n    double ans = 0;\n    \n    init(n);\n    while(!edges.empty()){\n        Edge edge = edges.top(); edges.pop();\n        \n        if(is_same_group(edge.a, edge.b)){\n            ans += edge.cost;\n        }else{\n            unite(edge.a, edge.b);\n        }\n    }\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//mst\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<limits>\n#include<utility>\n\n//#define c11\n#ifdef c11\n#include<unordered_set>\n#include<unordered_map>\n#endif\n\nusing namespace std;\ntypedef long long ll;\n#define ull unsigned long long\n#define PI acos(-1.0)\n#define eps 1e-12\n#define initz(x) memset(x,0,sizeof(x))\n#define initm(x) memset(x,0x7f,sizeof(x))\n#define forn(i, n) for(int i = 0; i < (int) n; ++i)\n#define for1(i, n) for(int i = 1; i <= (int) n; ++i)\n#define fore(i, l, r) for(int i = (int) l; i <= (int) r; ++i)\n#define rforn(i, n) for(int i = (int) n - 1; i>= 0; --i)\n#define fi first\n#define se second\n\nint dx[4] = {1, 0 , -1, 0};\nint dy[4] = {0, 1 , 0, -1};\n\nconst int INF = 0x7f7f7f7f;\nconst int MAX_N = 30;\nconst int MAX_M = 50000;\n\ntypedef pair<int, int> P;\n\nstruct E{\n  E() {}\n  E(int uu, int vv, double cc): u(uu), v(vv), c(cc) {}\n  bool operator > (const E& e) const {\n    return c < e.c;\n  }\n  int u, v;\n  double c;\n};\n\nint fa[MAX_M];\n\npriority_queue<E, vector<E>, greater<E> > pq;\n\nint find(int x) {\n  if(x == fa[x]) return x;\n  return fa[x] = find(fa[x]);\n}\n\ndouble Kruskal(int n) {\n  for(int i = 1; i <= n; ++i) {\n    fa[i] = i;\n  }\n  int cnt = 1;\n  double ans = 0;\n\n  while(cnt < n && !pq.empty()) {\n    const E& e = pq.top();\n    int u, v;\n    double c;\n    u = e.u;\n    v = e.v;\n    c = e.c;\n    pq.pop();\n\n    u = find(u);\n    v = find(v);\n    if(u == v) continue;\n    fa[u] = v;\n    ans += c;\n    ++cnt;\n  }\n  return ans;\n}\n\ndouble x[MAX_M], y[MAX_M];\n\nint main() {\n\tint n, m;\n  double ans = 0;\n  scanf(\"%d%d\", &n, &m);\n  for(int i = 1; i <= n; ++i) {\n    scanf(\"%lf%lf\", &x[i], &y[i]);\n  }\n  while(m--) {\n    int u, v;\n    double c;\n    scanf(\"%d%d\", &u, &v);\n    c = sqrt((x[u]-x[v])*(x[u]-x[v]) + (y[u]-y[v])*(y[u]-y[v]));\n    ans += c;\n    pq.push(E(u, v ,c));\n  }\n  ans -= Kruskal(n);\n  printf(\"%.3f\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\nint par[100000];\nint rank1[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank1[i] = 0;\n\t}\n}\nint find1(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find1(par[x]);\n\t}\n}\nvoid unite1(int x, int y) {\n\tx = find1(x);\n\ty = find1(y);\n\tif (x == y)return;\n\tif (rank1[x] < rank1[y]) {\n\t\tpar[x] = y;\n\t}\n\telse {\n\t\tpar[y] = x;\n\t\tif (rank1[x] == rank1[y])rank1[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find1(x) == find1(y);\n}\nstruct edge { int u, v;double cost; };\nbool comp(const edge&e1, const edge&e2) {\n\treturn e1.cost > e2.cost;\n}\nedge es[100000];\nint V, E;\ndouble kruskal() {\n\tsort(es, es + E, comp);\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite1(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\ndouble dis(pair<double, double>x, pair<double, double> y) {\n\treturn sqrt(pow(x.first - y.first, 2) + pow(x.second - y.second, 2));\n}\nint main() {\n\tcin >> V >> E;\n\tpair<double, double> p[10000];\n\tdouble x, y;\n\trep(i, V) {\n\t\tcin >> x >> y;\n\t\tp[i] = { x,y };\n\t}\n\tint a, b; double sum = 0;\n\trep(i, E) {\n\t\tcin >> a >> b; a--; b--;\n\t\tes[i] = { a,b,dis(p[a],p[b]) };\n\t\tsum += dis(p[a], p[b]);\n\t}\n\tcout << fixed<<setprecision(4)<< sum-kruskal() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <functional>\n\nusing namespace std;\n\nint main()\n{\n\tint V, E, S, T;\n\n\tcin >> V >> E;\n\n\tvector<int> X(V), Y(X);\n\n\tvector<vector<pair<int, double> > > G(V, vector<pair<int, double> >());\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tscanf(\"%d\", &X[i]);\n\t\tscanf(\"%d\", &Y[i]);\n\t}\n\t\n\tfor (int i = 0; i < E; i++)\n\t{\n\t\tscanf(\"%d\", &S);\n\t\tscanf(\"%d\", &T);\n\n\t\tG[S - 1].push_back(make_pair(T - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t\tG[T - 1].push_back(make_pair(S - 1, 100000.0 - sqrt((X[T - 1] - X[S - 1]) * (X[T - 1] - X[S - 1]) + (Y[T - 1] - Y[S - 1]) * (Y[T - 1] - Y[S - 1]))));\n\t}\n\n\tpriority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n\n\tvector<bool> u(V, false);\n\n\tdouble res = 0.0;\n\n\tque.push(make_pair(0.0, 0));\n\n\twhile (!que.empty())\n\t{\n\t\tpair<double, int> r = que.top(); que.pop();\n\n\t\tint v = r.second;\n\n\t\tif (u[v]) { continue; }\n\n\t\tres += r.first; u[v] = true;\n\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tif (!u[G[v][i].first])\n\t\t\t{\n\t\t\t\tque.push(make_pair(G[v][i].second, G[v][i].first));\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ret = 0.0;\n\n\tfor (int i = 0; i < V; i++)\n\t{\n\t\tfor (int j = 0; j < G[i].size(); j++)\n\t\t{\n\t\t\tret += G[i][j].second;\n\t\t}\n\t}\n\n\tret = ret / 2 - res;\n\n\tprintf(\"%.9f\\n\", 100000.0 * (E - V + 1) - ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n*AOJ2224: Save your cat\n**問題概要\n[http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2224:title]\nN個の頂点とM個の辺を持った無\b向グラフがある。グラフの閉路がすべてなくなるように辺を取り除きたい。辺のコストは辺の長さである。取り除く辺のコストの最小値を求めよ。\n2 <= N <= 10000\n1 <= M\n**解法\n辺を取り除くと考えるのではなく、残す辺で全域木を作ると考えれば、これも最大全域木問題になる。クラスカル法で解く。\n*/\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nstruct edge{ int u, v; float cost; };\nvector<edge> es;\nint V, E; // 頂点数と辺数\n\n//--------Union-Find木------------\nvector<int> par; // 親\nvector<int> rnk; // 深さ\n\n// Union-Find木の初期化\nvoid init_union_find(int n) {\n  par  = vector<int>(n);\n  rnk = vector<int>(n);\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    rnk[i] = 0;\n  }\n}\n\n// 木の根を求める\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// xとyの属する集合を併合\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) return;\n\n  if (rnk[x] < rnk[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (rnk[x] == rnk[y]) rnk[x]++;\n  }\n}\n\n// xとyが同じ集合に属するか否か\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\n//----------クラスカル法------------\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost > e2.cost; // 大きい順\n}\ndouble kruskal() {\n  sort(es.begin(), es.end(), comp); // edge.costの大きい順\n  init_union_find(V); // Union-Findの初期化\n  double res = 0;\n  for (int i = 0; i < E; i++) {\n    edge e = es[i];\n    if (!same(e.u, e.v)) {\n      unite(e.u, e.v);\n      res += e.cost;\n      // cout << e.u+1 << \" \" << e.v+1 << endl;\n    }\n  }\n  return res;\n}\n\nint main() {\n  // 初期化\n  cin >> V >> E;\n  vector<int> vx = vector<int>(V);\n  vector<int> vy = vector<int>(V);\n  es = vector<edge>(E);\n  for (int i = 0; i < V; i++) {\n    cin >> vx[i] >> vy[i];\n  }\n  float l;\n  int p, q;\n  double total_cost = 0;\n  for (int i = 0; i < E; i++) {\n    cin >> p >> q;\n    p--; q--;\n    l = sqrt((vx[p] - vx[q])*(vx[p] - vx[q]) + (vy[p] - vy[q])*(vy[p] - vy[q]));\n    edge e = {p, q, l};\n    es[i] = e;\n    total_cost += l;\n  }\n  // クラスカル法で最大全域木のコストを計算\n  double kr = kruskal();\n  // 出力\n  cout << total_cost - kr << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\n#define inf 1<<30\n#define ll long long\n#define db double\n#define c233 cout<<\"233\"<<endl\n#define mem(s) memset(s,0,sizeof(s))\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\nconst int N=10050;\nusing namespace std;\n\nstruct lll{\n  int x,y;\n}p[N];\nstruct hhh{\n  int a,b;\n  db len;\n}e[N*10];\nint fa[N];\nint n,m;\ndb sum,mst;\n\nvoid fre(){\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n}\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=(x<<1)+(x<<3)+ch-48,ch=getchar();\n  return x*res;\n}\n\ndb len(lll x,lll y){\n  return sqrt((1.0*(x.x-y.x)*(x.x-y.x)+1.0*(x.y-y.y)*(x.y-y.y)));\n}\n\nvoid init(){\n  n=gi();m=gi();\n  for(int i=1;i<=n;i++)\n    p[i].x=gi(),p[i].y=gi();\n  for(int i=1;i<=m;i++){\n    e[i].a=gi(),e[i].b=gi();\n    e[i].len=len(p[e[i].a],p[e[i].b]);\n    sum+=e[i].len;\n  }\n}\n\nint getfa(int x){\n  return fa[x]==x?fa[x]:fa[x]=getfa(fa[x]);\n}\n\nvoid merge(int a,int b){\n  int f1=getfa(a),f2=getfa(b);\n  fa[f1]=f2;\n}\n\nvoid work(){\n  for(int i=1;i<=n;i++)fa[i]=i;\n  for(int i=1;i<=m;i++){\n    if(getfa(e[i].a)!=getfa(e[i].b))\n      merge(e[i].a,e[i].b),mst+=e[i].len;\n  }\n  printf(\"%.3lf\\n\",sum-mst);\n}\n\nbool mmp(hhh x,hhh y){\n  return x.len>y.len;\n}\n\nint main(){\n  //fre();\n  init();\n  sort(e+1,e+1+m,mmp);\n  work();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct UnionFind{\n\tvector<int> data;\n\tUnionFind(int n):data(n,-1){}\n\tint Find(int x){\n\t\treturn data[x]<0?x:data[x]=Find(data[x]);\n\t}\n\tbool Unite(int a,int b){\n\t\tint ra=Find(a),rb=Find(b);\n\t\tif(ra==rb) return false;\n\t\tif(-data[ra]<-data[rb]) swap(ra,rb);\n\t\tdata[ra]+=data[rb],data[rb]=ra;\n\t\treturn true;\n\t}\n};\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m;){\n\t\tvector<int> x(n),y(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tcin>>x[i]>>y[i];\n\t\tvector<int> s(m),d(m);\n\t\tvector<double> w(m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>s[i]>>d[i]; s[i]--,d[i]--;\n\t\t\tw[i]=hypot(x[d[i]]-x[s[i]],y[d[i]]-y[s[i]]);\n\t\t}\n\t\t\n\t\t{\n\t\t\tvector<pair<double,pair<int,int>>> p(m);\n\t\t\tfor(int i=0;i<m;i++) p[i]=make_pair(w[i],make_pair(s[i],d[i]));\n\t\t\tsort(begin(p),end(p));\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tw[m-1-i]=p[i].first;\n\t\t\t\ts[m-1-i]=p[i].second.first;\n\t\t\t\td[m-1-i]=p[i].second.second;\n\t\t\t}\n\t\t}\n\t\t\n\t\tUnionFind uf(n);\n\t\tdouble res=0;\n\t\tfor(int i=0;i<m;i++)\n\t\t\tif(!uf.Unite(s[i],d[i]))\n\t\t\t\tres+=w[i];\n\t\tprintf(\"%f\\n\",res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 3e4;\nint u[maxn], v[maxn], r[maxn];\ndouble w[maxn];\nint p[maxn], a[maxn], b[maxn];\n\nconst int inf = 1e5;\nint find(int x) {return p[x] == x ? x : p[x] = find(p[x]);}\n\nbool cmp(int x, int y){\n\treturn w[x] > w[y];\n}\n\ndouble calc(int x1, int x2, int y1, int y2){\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\nint main(int argc, char const *argv[])\n{\n\t// freopen(\"in.txt\", \"r\", stdin);\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tfor(int i = 0; i < n; i++){\n\t\tscanf(\"%d%d\", &a[i], &b[i]);\n\t}\n\tdouble ans = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d%d\", &u[i], &v[i]);\n\t\tw[i] = calc(a[u[i]], a[v[i]], b[u[i]], b[v[i]]);\n\t\tr[i] = i;\n\t\tans += w[i];\n\t}\n\tfor(int i = 1; i <= n; i++) p[i] = i;\n\tsort(r, r+m, cmp);\n\tfor(int i = 0; i < m; i++){\n\t\tint k = r[i];\n\t\tif(find(u[k]) == find(v[k])) continue;\n\t\tp[find(v[k])] = find(u[k]);\n\t\tans -= w[k];\n\t}\n\tprintf(\"%lf\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma  warning (disable:4996)\n#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint fa[1000000];\nint n, m;\nint num;\nstruct edge{\n\tint u;\n\tint v;\n\tdouble cost;\n};\nbool cmp(edge a, edge b){\n\treturn a.cost < b.cost;\n}\nedge es[1000000];\nint find(int a){\n\tif (a == fa[a]) return a;\n\telse return fa[a] = find(fa[a]);\n}\nbool same(int a, int b){\n\tint aa = find(a);\n\tint bb = find(b);\n\tif (aa==bb) return true;\n\telse return false;\n}\n\nvoid unite(int a, int b){\n\tint aa = fa[a];\n\tint bb = fa[b];\n\tif (aa != bb){\n\t\tfa[aa] = bb;\n\t}\n}\nint max(int a, int b){\n\tif (a > b)return a;\n\telse return b;\n\n}\nint krusal(){\n\t\n\tsort(es, es + num, cmp);\n\tint res = -10;\n\tfor (int i = 1; i <= n; i++) fa[i] = i;\n\tfor (int i = 0; i < num; i++){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres=max(res,e.cost);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\t\n\tcin >> n >> m;\n\t\n\tnum = 0;\n\tint u, v,d;\n\t\n\t\n\twhile (m--){\n\t\tcin >> u >> v >> d;\n\t\t\n\t\t\tes[num].u = u;\n\t\t\tes[num].v = v;\n\t\t\tes[num++].cost = d;\n\t\t\t\n\t}\n\t\n\tprintf(\"%ld\\n\", krusal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nclass UnionFind{\npublic:\n    vector<int> par;\n    vector<int> rank;\n    UnionFind(int n){\n        init(n);\n    }\n    void init(int n){\n        par.resize(n);\n        for(int i=0;i<n;i++){\n            par[i] = i;\n        }\n        rank.assign(n, 0);\n    }\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x,int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n\n        if(rank[x] < rank[y]){\n            par[x] = y;\n        }else{\n            par[y] = x;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\nstruct edge{\n    int u, v;\n    double c;\n    edge(int u, int v, double c) : u(u), v(v), c(c) {}\n    bool operator<(const edge& right) const {\n        return c > right.c;\n    }\n};\n\nint main(){\n    int N, M;\n    cin >> N >> M;\n\n    vector<int> x(N), y(N);\n    for(int i=0;i<N;i++){\n        cin >> x[i] >> y[i];\n    }\n\n    double total_cost = 0;\n    vector<edge> edges;\n    UnionFind uf(N);\n    for(int i=0;i<M;i++){\n        int p, q;\n        cin >> p >> q;\n        p--; q--;\n        uf.unite(p, q);\n        double cost = sqrt((x[p]-x[q]) * (x[p]-x[q]) + (y[p]-y[q]) * (y[p]-y[q]));\n        edges.emplace_back(p, q, cost);\n        total_cost += cost;\n    }\n\n    sort(edges.begin(), edges.end());\n\n    map<int, vector<int>> mp;\n    for(int i=0;i<N;i++){\n        mp[uf.find(i)].push_back(i);\n    }\n\n    uf.init(N);\n    for(const auto& p : mp){\n        const vector<int>& vs = p.second;\n        vector<bool> active(N, false);\n        for(int v : vs){\n            active[v] = true;\n        }\n        for(edge& e : edges){\n            if(active[e.u] && active[e.v] && !uf.same(e.u, e.v)){\n                uf.unite(e.u, e.v);\n                total_cost -= e.c;\n            }\n        }\n    }\n    printf(\"%.4f\\n\", total_cost);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 10005\n\ntypedef struct {\n\tdouble x, y;\n} point;\n\ntypedef struct {\n\tint from, to;\n\tdouble cost;\n} edge;\n\ntypedef pair<double, int> PDI;\n\npoint p[N];\nvector<edge> G[N];\n\ndouble d[N];\nbool used[N];\n\nint n, m;\ndouble ans;\n\ndouble calc_length(point& p1, point& p2){\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + \n\t\t\t(p1.y - p2.y) * (p1.y - p2.y));\n} \n\ndouble prim(){\n\tfill(d, d + N, 0);\n\tfill(used, used + N, false);\n\n\tpriority_queue<PDI, vector<PDI>, greater<PDI> > que;\n\td[0] = 0;\n\tdouble rst = 0.0;\n\tque.push(PDI(0.0, 0));\n\twhile (!que.empty()){\n\t\tPDI p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\trst += d[v];\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < G[v].size(); u++){\n\t\t\tedge& e = G[v][u];\n\t\t\tif (!used[e.to] && d[e.to] > e.cost){\n\t\t\t\td[e.to] = e.cost;\n\t\t\t\tque.push(PDI(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn rst;\n}\n\nvoid init(){\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\t}\n\tint from , to;\n\tdouble cost;\n\tans = 0.0;\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d\", &from, &to);\t\n\t\t--from, --to;\n\t\tcost = calc_length(p[from], p[to]);\n\t\tedge e1, e2;\n\t\te1.from = from, e1.to = to, e1.cost = -cost;\n\t\te2.from = to, e2.to = from, e2.cost = -cost;\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t\tans += cost;\n\t}\n}\n\nint main(){\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tinit();\n\tans += prim();\n\tprintf(\"%.3lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<assert.h>\n#include<math.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {\n\tcww() { CIN_ONLY{ ios::sync_with_stdio(false); cin.tie(0); } }\n}star;\n#define DEBUG if(0)\n#endif\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r) { bool a = l>r; if (a)l = r; return a; }\ntemplate <typename T>inline bool chmax(T &l, T r) { bool a = l<r; if (a)l = r; return a; }\n\nnamespace _DSU {\n\tconst int BUF = 212345 * 2;\n\tint ptr = 0;\n\tint mem[BUF];\n\tint* get(int size) {\n\t\tptr += size;\n\t\treturn mem + ptr - size;\n\t}\n\tvoid reset() {\n\t\tptr = 0;\n\t}\n}\nclass UF {\nprivate:\n\tint *par, *rank;\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\npublic:\n\tUF(int n) :par(_DSU::get(n + 10)), rank(_DSU::get(n + 10)) {\n\t\tREP(i, n)par[i] = i, rank[i] = 0;\n\t}\n\tbool unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\t\tif (x == y)return false;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\ndouble x[212345];\ndouble y[212345];\nint a[212345];\nint b[212345];\ntypedef pair<double, int> P;\ndouble dist(int i, int j) {\n\tdouble dx = x[i] - x[j];\n\tdouble dy = y[i] - y[j];\n\treturn sqrt(dx*dx + dy*dy);\n}\nint main() {\n\tcout << fixed;\n\tcout << setprecision(10);\n\tint N, M;\n\twhile (cin >> N >> M) {\n\t\tdouble all = 0;\n\t\tvector<P> edge;\n\t\tREP(i, N)cin >> x[i] >> y[i];\n\t\tREP(i, M) {\n\t\t\tcin >> a[i] >> b[i];\n\t\t\ta[i]--; b[i]--;\n\t\t\tdouble c = dist(a[i], b[i]);\n\t\t\tedge.push_back(P(-c, i));\n\t\t\tall += c;\n\t\t}\n\t\tsort(ALL(edge));\n\t\tUF uf(N);\n\t\tdouble ret = 0;\n\t\tREP(i, M)if (uf.unite(a[edge[i].second], b[edge[i].second]))ret += edge[i].first;\n\t\tcout << all + ret << endl;\n\t\t_DSU::reset();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> T;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define SQ(X) ((X)*(X))\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\nint N,M;\nint x[10010],y[10010];\nint p[10010],q[10010];\nstruct UnionFind{\n\tint par[200010],rank[200010];\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\telse return par[x]=find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]>rank[y])par[y]=x;\n\t\telse{\n\t\t\tif(rank[x]==rank[y])rank[y]++;\n\t\t\tpar[x]=y;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nstruct edge{\n\tint a,b;\n\tdouble len;\n\tedge(){}\n\tedge(int a,int b,double len):a(a),b(b),len(len){};\n\tbool operator<(const edge& a) const{\n\t\treturn len > a.len;\n\t}\n};\ndouble dist(int a,int b){\n\treturn sqrt(SQ(x[a]-x[b])+SQ(y[a]-y[b]));\n}\nvector<edge> es;\nint main(){\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i=0;i<N;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tdouble ans = 0.0;\n\tfor(int i=0;i<M;i++){\n\t\tscanf(\"%d %d\",&p[i],&q[i]);\n\t\tp[i]--;\n\t\tq[i]--;\n\t\tes.pb(edge(p[i],q[i],dist(p[i],q[i])));\n\t}\n\tsort(all(es));\n\tuf.init(200000);\n\tfor(int i=0;i<es.size();i++){\n\t\tint a = es[i].a;\n\t\tint b = es[i].b;\n\t\tif(uf.same(a,b))ans += es[i].len;\n\t\telse{\n\t\t\tuf.unite(a,b);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 1000005\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tmemset(used,0,sizeof used);\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n2.#include <algorithm>\n3.#include <vector>\n4.#include <utility>\n5.#include <cmath>\n6.#include <iomanip>\n7.using namespace std;\n8. \n9.// ?舵?????虫?鎹?????\n10.#define MAX_N 10000 + 16\n11.int parent[MAX_N];\n12.int height[MAX_N];\n13. \n14.void init(const int& n)\n15.{\n16.\tfor (int i = 0; i < n; ++i)\n17.\t{\n18.\t\tparent[i] = i;\n19.\t\theight[i] = 0;\n20.\t}\n21.}\n22. \n23.int find(const int& x)\n24.{\n25.\tif (parent[x] == x)\n26.\t{\n27.\t\treturn x;\n28.\t}\n29.\telse\n30.\t{\n31.\t\treturn parent[x] = find(parent[x]);\n32.\t}\n33.}\n34. \n35.void unite(int x, int y)\n36.{\n37.\tx = find(x);\n38.\ty = find(y);\n39.\tif (x == y)\n40.\t{\n41.\t\treturn;\n42.\t}\n43. \n44.\tif (height[x] < height[y])\n45.\t{\n46.\t\tparent[x] = y;\n47.\t}\n48.\telse\n49.\t{\n50.\t\tparent[y] = x;\n51.\t\tif (height[x] == height[y])\n52.\t\t{\n53.\t\t\t++height[x];\n54.\t\t}\n55.\t}\n56.}\n57. \n58.bool same(const int& x, const int& y)\n59.{\n60.\treturn find(x) == find(y);\n61.}\n62.// End Of ?舵???\n63. \n64.#define MAX_E MAX_N * MAX_N / 2 + 1\n65.struct edge\n66.{\n67.\tint u, v;\n68.\tdouble cost;\n69.\tedge(int u = 0, int v = 0, double cost = 0) : u(u), v(v), cost(cost) {}\n70.\tbool operator < (const edge & e2) const\n71.\t{\n72.\t\treturn cost > e2.cost;\n73.\t}\n74.};\n75. \n76.edge es[MAX_E];\n77.int V, E;\n78.double kruskal()\n79.{\n80.\tsort(es, es + E);    // ??収?冨???????ф?搴?\n81.\tinit(V);\n82.\tdouble res = 0;\n83.\tfor (int i = 0; i < E; ++i)\n84.\t{\n85.\t\tedge e = es[i];\n86.\t\tif (!same(e.u, e.v))\n87.\t\t{\n88.\t\t\tunite(e.u, e.v);\n89.\t\t}\n90.\t\telse\n91.\t\t{\n92.\t\t\tres += e.cost;\n93.\t\t}\n94.\t}\n95. \n96.\treturn res;\n97.}\n98. \n99.pair<int, int> pile[MAX_N];\n100. \n101.///////////////////////////SubMain//////////////////////////////////\n102.int main(int argc, char *argv[])\n103.{\n104.\tcin >> V >> E;\n105.\t\n106.\tfor (int i = 0; i < V; ++i)\n107.\t{\n108.\t\tcin >> pile[i].first >> pile[i].second;\n109.\t}\n110. \n111.\tfor (int i = 0; i < E; ++i)\n112.\t{\n113.\t\tcin >> es[i].u >> es[i].v;\n114.\t\t--es[i].u; --es[i].v;\n115.\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n116.\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n117.\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n118.\t}\n119. \n120.\tcout.setf(ios::showpoint);\n121.\tcout.precision(3);\n122.\tcout.setf(ios::fixed);\n123.\tcout << kruskal() << endl;\n124.\treturn 0;\n125.}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi Par,Rank,Size;\n\tUnion_Find_Tree(int n){\n\t\tPar=Rank=vi(n);\n\t\tSize=vi(n,1);\n\t\tfor(int i=0;i<n;i++) Par[i]=i;\n\t}\n\tint Find_Par(int x){\n\t\tif(Par[x]==x) return x;\n\t\treturn Par[x]=Find_Par(Par[x]);\n\t}\n\tint Find_Size(int x){\n\t\treturn Size[Find_Par(x)];\n\t}\n\tbool Unite(int x,int y){\n\t\tx=Find_Par(x);\n\t\ty=Find_Par(y);\n\t\tif(x==y) return 0;\n\t\tif(Rank[x]<Rank[y]){\n\t\t\tPar[x]=y;\n\t\t\tSize[y]+=Size[x];\n\t\t}\n\t\telse{\n\t\t\tPar[y]=x;\n\t\t\tSize[x]+=Size[y];\n\t\t\tif(Rank[x]==Rank[y]) Rank[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){\n\t\treturn Find_Par(x)==Find_Par(y);\n\t}\n};\n\nint n,m;\nvd x,y;\n\ndouble L(int i,int j){\n\tdouble A=fabs(x[i]-x[j]),B=fabs(y[i]-y[j]);\n\treturn sqrt(A*A+B*B);\n}\n\nint main(){\n\tcin>>n>>m;\n\tx=y=vd(n);\n\tvector<pair<double,P> > a(m);\n\tdouble res=0;\n\tfor(int i=0;i<n;i++) cin>>x[i]>>y[i];\n\tfor(int i=0;i<m;i++){\n\t\tint v,u;\n\t\tcin>>v>>u;\n\t\tv--;u--;\n\t\tdouble l=L(v,u);\n\t\tres+=l;\n\t\ta[i]={-l,{v,u}};\n\t}\n\tsort(a.begin(),a.end());\n\tUnion_Find_Tree uft(n);\n\tfor(int i=0;i<m;i++){\n\t\tP p=a[i].second;\n\t\tint v=p.first,u=p.second;\n\t\tif(!uft.Same(v,u)){\n\t\t\tuft.Unite(v,u);\n\t\t\tres+=a[i].first;\n\t\t}\n\t}\n\tcout<<syosu(5)<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 11111, M = 111111 * 4;\n\nstruct edge\n{\n\tint other[M], succ[M], last[M], sum;\n\tvoid clear(){\n\t\tmemset(last, -1, sizeof(last));\n\t\tsum = 0;\n\t}\n\tvoid Add(int a, int b) {\n\t\tother[sum] = b, succ[sum] = last[a], last[a] = sum ++;\n\t\tother[sum] = a, succ[sum] = last[b], last[b] = sum ++;\n\t}\n}e;\n\nint n, m;\nstruct point\n{\n\tint x, y;\n\tpoint(int x, int y) : x(x), y(y) {}\n\tpoint() {}\n\tfriend point operator - (point a, point b) {\n\t\treturn point(a.x - b.x, a.y - b.y); \n\t}\n\tdouble arg()\n\t{\n\t\treturn atan2(y, x);\n\t}\n}points[N];\n\nvector<pair<int, double> > vecs;\nvector<int > ee[M];\nvector<pair<double, pair<int, int> > > edges;\ndouble length[M];\nint tot, father[M], next[M], visit[M];\n\nint find(int x) { return father[x] == x ? x : father[x] = find(father[x]); }\n\nlong long det(point a, point b)\n{\n\treturn 1LL * a.x * b.y - 1LL * b.x * a.y;\n}\n\ndouble dist(point a, point b) {\n\treturn sqrt(1.0 * (a.x - b.x) * (a.x - b.x) + 1.0 * (a.y - b.y) * (a.y - b.y));\n}\n\nint main( )\n{\n\tscanf(\"%d %d\", &n, &m);\n\te.clear();\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf(\"%d %d\", &points[i].x, &points[i].y);\n\tfor (int i = 1; i <= m; i ++)\n\t{\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\te.Add(a, b);\n\t}\n\tfor (int x = 1; x <= n; x ++)\n\t{\n\t\tvector<pair<double, int> > pairs;\n\t\tfor (int i = e.last[x]; ~i; i = e.succ[i]) {\n\t\t\tint y = e.other[i];\n\t\t\tpairs.push_back(make_pair((points[y] - points[x]).arg(), i));\n\t\t}\n\t\tsort(pairs.begin(), pairs.end());\n\t\tfor (int i = 0; i < (int )(pairs.size()); i ++)\n\t\t\tnext[pairs[(i + 1) % (int )(pairs.size())].second ^ 1] = pairs[i].second;\n\t}\n\tmemset(visit, 0, sizeof(visit));\n\ttot = 0;\n\tfor (int start = 0; start < e.sum; start ++)\n\t{\n\t\tif (visit[start]) continue;\n\t\tlong long total = 0;\n\t\tint now = start;\n\t\tvecs.clear();\n\t\twhile (!visit[now])\n\t\t{\n\t\t\tvisit[now] = 1;\n\t\t\ttotal += det(points[e.other[now ^ 1]], points[e.other[now]]);\n\t\t\tvecs.push_back(make_pair(now / 2, dist(points[e.other[now ^ 1]], points[e.other[now]])));\n\t\t\tnow = next[now];\n\t\t}\n\t\tif (now == start && total > 0)\n\t\t{\n\t\t\t++ tot;\n\t\t\tfor (int i = 0; i < (int )(vecs.size()); i ++)\n\t\t\t\tee[vecs[i].first].push_back(tot);\n\t\t}\n\t}\n\tfor (int i = 0; i < e.sum / 2; i ++)\n\t{\n\t\tint a = 0, b = 0;\n\t\tif (ee[i].size() == 0) continue;\n\t\telse if (ee[i].size() == 1)a = ee[i][0];\n\t\telse if (ee[i].size() == 2) a = ee[i][0], b = ee[i][1];\n\t\tedges.push_back(make_pair(dist(points[e.other[i * 2]], points[e.other[i * 2 + 1]]), make_pair(a, b)));\n\t}\n\tsort(edges.begin(), edges.end());\n\tfor (int i = 0; i <= tot; i ++) father[i] = i;\n\tdouble ans = 0;\n\tfor (int i = 0; i < (int )(edges.size()); i ++)\n\t{\n\t\tint a = edges[i].second.first, b = edges[i].second.second;\n\t\tdouble v = edges[i].first;\n\t\tif (find(a) != find(b))\n\t\t{\n\t\t\tans += v;\n\t\t\tfather[father[a]] = father[b];\n\t\t}\n\t}\n\tprintf(\"%.5f\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\nclass Point{\npublic:\n    double x,y;\n    Point();\n    Point(double _x,double _y);\n};\nconst int MAX = 10010;\nconst int INF = 0x3f3f3f3f;\nconst double eps = 1e-5;\nPoint p[MAX];\nint N,M;\nclass Node{\npublic:\n    int to;\n    double len;\n    Node();\n    Node(int _to,double _len);\n};\nvector<Node> G[MAX];\nbool used[MAX];\ndouble Dis[MAX];\ndouble getLen(int u,int v){\n    double res = (p[u].x-p[v].x)*(p[u].x-p[v].x) + (p[u].y-p[v].y)*(p[u].y-p[v].y);\n    return sqrt(res);\n}\n\ndouble Prim(){\n    memset(used,false,sizeof(used));\n    fill(Dis+1,Dis+1+N,-INF);\n    Dis[1] = 0;\n    double res = 0;\n    while(true){\n        int u = -1;\n        for(int i=1;i<=N;++i){\n            if(!used[i] && (u == -1 || Dis[i] - Dis[u] > eps))\n                u = i;\n        }\n        if(u == -1) break;\n        used[u] = true;\n        res += Dis[u];\n        for(vector<Node>::iterator it = G[u].begin();it != G[u].end();++it){\n            if(!used[it->to] && (it->len - Dis[it->to] > eps))\n                Dis[it->to] = it->len;\n        }\n    }\n    return res;\n}\nint main(void){\n    cin >> N >> M;\n    for(int i=1;i<=N;++i){\n        cin >> p[i].x >> p[i].y;\n    }\n    double sum = 0;\n    int u,v;\n    for(int i=1;i<=M;++i){\n        cin >> u >> v;\n        double len = getLen(u,v);\n        sum += len;\n        G[u].push_back(Node(v,len));\n        G[v].push_back(Node(u,len));\n    }\n    double res = sum - Prim();\n    cout << fixed << setprecision(3) << res << endl;\n    return 0;\n}\n\nPoint::Point(){\n    x = y = 0;\n}\nPoint::Point(double _x,double _y){\n    x = _x;\n    y = _y;\n}\nNode::Node(){\n    to = 0;\n    len = 0;\n}\nNode::Node(int _to,double _len){\n    to = _to;\n    len = _len;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\nstruct point{\n    int x, y;\n    point(){x=y=0;}\n    point(int xx, int yy){ x=xx; y=yy;}\n};\n\nconst int MAX_N=10001;\nconst int MAX_M=MAX_N*MAX_N;\n//edge edges[MAX_M];\n//point points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n    int N, M; \n    cin>>N>>M;\n    point* points=new point[N+1];\n    edge* edges=new edge[M];\n        for(int i=1; i<=N; i++){\n            cin>>points[i].x>>points[i].y;\n        }\n        int p, q;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n            edges[i].w=sqrt((points[p].x-points[q].x)*(points[p].x-points[q].x)\n                          +(points[p].y-points[q].y)*(points[p].y-points[q].y));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    \n    fclose(stdin);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nstruct Edge{\n  int u,v; double cost;\n  Edge(){}\n  Edge(int u, int v, double cost):u(u),v(v),cost(cost){}\n  bool operator<(const Edge &a)const{\n    return cost < a.cost;\n  }\n};\n\nstruct UnionFind{\n  int par[10005];\n  int rank[10005];\n  UnionFind(int n){ init(n); }\n  void init(int n){\n    for(int i=0;i<n;i++){\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n  int find(int x){\n    if(x == par[x]) return x;\n    return par[x] = find(par[x]);\n  }\n  int same(int x, int y){\n    return find(x) == find(y);\n  }\n  void unite(int x, int y){\n    x = find(x); y = find(y);\n    if(x==y) return;\n    if(rank[x] < rank[y]){\n      par[x] = y;\n    }else{\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n};\n\nEdge es[50000000];\nint N,M;\nint x[10005],y[10005];\n\ndouble kruskal(){\n  UnionFind uf(N);\n  double res = 0;\n  sort(es, es+N);\n  for(int i=0;i<M;i++){\n    Edge e = es[i];\n    if(!uf.same(e.u, e.v)){\n      uf.unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n  \nint main(){\n  double sum = 0.0;\n\n  scanf(\"%d%d\",&N,&M);\n  rep(i,N) scanf(\"%d%d\", &x[i],&y[i]);\n  rep(i,M){\n    int p,q;\n    scanf(\"%d%d\",&p,&q); p--; q--;\n    es[i] = Edge(p,q, -sqrt(SQ(x[p]-x[q])+SQ(y[p]-y[q])));\n    sum -= es[i].cost;\n  }\n  printf(\"%lf\\n\", sum+kruskal());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\n\nstruct point{\n    int first, second;\n    point(){first=second=0;}\n    point(int xx, int yy){ first=xx; second=yy;}\n};\nconst int MAX_N=10001;\n//pair<int, int> points[MAX_N];\nconst int MAX_M=MAX_N*(MAX_N-1)/2;\n//edge edges[MAX_M];\n////point points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    int N, M; \n    cin>>N>>M;\n    point* points=new point[2*N];\n    edge* edges=new edge[M];\n        for(int i=1; i<=N; i++){\n            cin>>points[i].first>>points[i].second;\n        }\n        int p, q;\n        int x1, x2, y1, y2;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n        \tx1=points[p].first; x2=points[q].first;\n        \ty1=points[p].second; y2=points[q].second;\n            edges[i].w=sqrt((x1-x2)*(x1-x2)\n                          +(y1-y2)*(y1-y2));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    delete[] points;\n    delete[] edges;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n\nconst int N=10005,M=200005;\nstruct edge {\n\tint x,y;\n\tdouble c;\n} a[M];\nint n,m,u[N],x[N],y[N];\n\nint ufind(int x)\n{\n\tif(u[x]<0) return x;\n\telse return u[x]=ufind(u[x]);\n}\n\nvoid uunion(int x,int y)\n{\n\tx=ufind(x); y=ufind(y);\n\tif(x!=y) u[x]=y;\n}\n\nbool cmp(edge a,edge b) { return a.c>b.c; }\n\nint main()\n{\n\tint i,cnt;\n\tdouble ans=0;\n\tscanf(\"%d%d\",&n,&m);\n\tmemset(u,-1,sizeof(u));\n\tfor(i=1;i<=n;i++) scanf(\"%d%d\",x+i,y+i);\n\tfor(i=0;i<m;i++) {\n\t\tscanf(\"%d%d\",&a[i].x,&a[i].y);\n\t\ta[i].c=hypot(x[a[i].x]-x[a[i].y],y[a[i].x]-y[a[i].y]);\n\t\tans+=a[i].c;\n\t}\n\tstd::sort(a,a+m,cmp);\n\tcnt=1;\n\tfor(i=0;i<m&&cnt<n;i++) {\n\t\tif(ufind(a[i].x)==ufind(a[i].y)) continue;\n\t\tcnt++;\n\t\tans-=a[i].c;\n\t\tuunion(a[i].x,a[i].y);\n\t}\n\tprintf(\"%.3f\",ans);\n\treturn 0;\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string>\ntemplate <class T> class Node {\npublic:\n\tNode()\n\t\t:parent(NULL), child(NULL)\n\t{};\n\tNode* parent;\n\tNode* child;\n\tT para;\n};\ntemplate <class T> class UnionFind {\npublic:\n\tvoid Connect(Node<T>* a, Node<T>* b) {\n\t\tVertex(a)->parent = Vertex(b);\n\t};\n\tbool Same(Node<T>* a, Node<T>* b) {\n\t\treturn Vertex(a) == Vertex(b);\n\t};\nprivate:\n\tNode<T>* Vertex(Node<T>* _obj) {\n\t\tif (_obj->parent == NULL) {\n\t\t\treturn _obj;\n\t\t}\n\t\telse {\n\t\t\treturn _obj->parent = Vertex(_obj->parent);\n\t\t}\n\t};\n};\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef priority_queue<int> PQ;\n#define _CRT_SECURE_NO_WARNINGS\nint N,M;\nint x[10010], y[10010];\nUnionFind<int> UF;\nstruct L{\n\tint s, g;\n\tdouble cost;\n\tbool operator < (const L& _l)const{\n\t\treturn cost < _l.cost;\n\t};\n\tbool operator > (const L& _l)const {\n\t\treturn cost > _l.cost;\n\t};\n\tvoid Set(int _x, int _y, float _c) {\n\t\ts = _x;\n\t\tg = _y;\n\t\tcost = _c;\n\t}\n}loads[10010 * 10010];\ndouble ans = 0;\nNode<int> n[10010];\n\nint main() {\n\tscanf(\"%d %d\", &N , &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tloads[i].Set(a, b, (double)sqrt( (double)((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b])*(y[a] - y[b])) ) );\n\t}\n\tstd::sort(loads, &loads[M],std::greater<L>());\n\t\n\tfor (int i = 0; i < M; i++) {\n\t\tif (!UF.Same(&n[loads[i].s], &n[loads[i].g])) {\n\t\t\tUF.Connect(&n[loads[i].s], &n[loads[i].g]);\n\t\t}\n\t\telse {\n\t\t\tans += loads[i].cost;\n\t\t}\n\t}\n\tprintf(\"%.5lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#define INF 1000000000\n#define M 10005\n#define LL long long\nusing namespace std;\nstruct node{\n    int x,y;\n    double z;\n};\nnode B[M];\nvector<node>A;\nint fa[M];\ndouble dis(int x,int y){\n    int dx=B[x].x-B[y].x,dy=B[x].y-B[y].y;\n    return sqrt(dx*dx+dy*dy);\n}\nint get(int x){\n    if(fa[x]==x) return x;\n    else return fa[x]=get(fa[x]);\n}\nbool cmp(node a,node b){\n    return a.z>b.z;\n}\nint main(){\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF){\n        int j,k;\n        A.clear();\n        for(j=1;j<=n;j++){\n            fa[j]=j;\n        }\n        for(j=1;j<=n;j++) scanf(\"%d%d\",&B[j].x,&B[j].y);\n        double ans=0;\n        for(j=1;j<=m;j++){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            double z=dis(x,y);\n            //printf(\"%f\\n\",z);\n            ans+=z;\n            A.push_back((node){x,y,z});\n        }\n        sort(A.begin(),A.end(),cmp);\n        for(j=0;j<A.size();j++){\n            int a=get(A[j].x),b=get(A[j].y);\n            if(a!=b){\n                fa[a]=b;\n                ans-=A[j].z;\n            }\n        }\n        printf(\"%.3f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nstruct UnionFind {\nprivate:\n\tstd::vector<int> value;\npublic:\n\tUnionFind(int size): value(size, -1){}\n\tint find(int x){\n\t\treturn value[x] < 0 ? x : value[x] = find(value[x]);\n\t}\n\tint size(int x){\n\t\treturn -value[find(x)];\n\t}\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\tbool unite(int x, int y){\n\t\tif ((x = find(x)) == (y = find(y))) return false;\n\t\tif (value[x] > value[y]) std::swap(x, y);\n\t\tvalue[x] += value[y];\n\t\tvalue[y] = x;\n\t\treturn true;\n\t}\n};\n\nusing namespace std;\n\nstruct Edge {\n\tint src, dst;\n\tdouble cost;\n\tEdge(){}\n\tEdge(int src, int dst, double cost): src(src), dst(dst), cost(cost){}\n};\n\nint n, m;\nint x[10000], y[10000];\nvector<Edge> es;\n\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\", x + i, y + i);\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tint s, t;\n\t\tscanf(\"%d %d\", &s, &t); --s; --t;\n\t\tdouble d = sqrt((x[s] - x[t]) * (x[s] - x[t]) + (y[s] - y[t]) * (y[s] - y[t]));\n\t\tes.push_back(Edge(s, t, d));\n\t}\n\t\n\tsort(begin(es), end(es), [](const Edge &a, const Edge &b){return a.cost > b.cost;});\n\tUnionFind uf(n);\n\tdouble res = 0;\n\tfor (auto &e : es){\n\t\tif (!uf.unite(e.src, e.dst)) res += e.cost;\n\t}\n\tprintf(\"%.20f\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N + 1][N + 1], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N + 1; i++)\n    for(j = 0; j < N + 1; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N; j++)\n\tif(forest[t1][j] == 0)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n#define LOCAL0\n#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n#define xx first \n#define yy second\n#define INF 0x3f3f3f3f\nvoid read(int &p)\n{\n    p=0;int flag=1;char c=getchar();\n    while(!isdigit(c)) {if(c=='-') flag=-1;c=getchar();}\n    while(isdigit(c)) {p=p*10+c-'0';c=getchar();}p*=flag;\n}\n//O(ElogV)\nconst int max_e=100000000;\n\ndouble len(pair<double,double> p,pair<double,double> q){\n    return sqrt((p.xx-q.xx)*(p.xx-q.xx)+(p.yy-q.yy)*(p.yy-q.yy));\n}\nstruct edage\n{\n    int from;\n    int to;\n    double dis;\n    bool operator < (const edage& x) const{\n        return dis>x.dis;\n    }\n}e[max_e];\n\nint par[10005];\n\nint find(int x)\n{\n    return par[x]==x?x:par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y)\n{\n    x=find(x),y=find(y);\n    par[x]=y;\n}\nint V,m,E,cnt;\ndouble sum,ans;\n\nvoid kruskal()\n{\n    for(int i=1;i<=V;i++) par[i]=i;\n    sort(e+1,e+1+E);\n    for(int i=1;i<=E;i++)\n    {\n        if(find(e[i].from)==find(e[i].to)) continue;\n        ans+=e[i].dis;\n        unite(e[i].from,e[i].to);\n        if(++cnt==V-1) return;\n    }\n}\npair<double,double> point[10005];\nint main()\n{\n    #ifdef LOCAL\n    freopen(\"in.txt\",\"r\",stdin);\n    freopen(\"out.txt\",\"w\",stdout);\n    #endif\n    read(V),read(m);\n    for(int i=1;i<=V;i++){\n        scanf(\"%lf%lf\",&point[i].xx,&point[i].yy);\n    }\n    int p,q;\n    for(int i=1;i<=m;i++){\n        read(p),read(q);\n        e[++E].from=p;e[E].to=q;e[E].dis=len(point[p],point[q]);\n        e[++E].from=q;e[E].to=p;e[E].dis=len(point[p],point[q]);\n        sum+=len(point[p],point[q]);\n    }\n    kruskal();\n    printf(\"%.3f\",sum-ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100000\n\nint N, M;\nint par[MAX], rank[MAX];\ntypedef pair<double,double> P;\nvoid init(){\n  for(int i = 0 ; i < N ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x){\n    return x;\n  }else{\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else{\n    par[y] = x;\n\n    if(rank[x] == rank[y]){\n      rank[x]++;\n    }\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nstruct edge{\n  int u,v;\n  double cost;\n};\n\nbool comp(const edge &e1,const edge &e2){\n  return e1.cost > e2.cost;\n}\n\nedge es[MAX];\n\ndouble kruskal(){\n  init(); sort(es , es + M, comp);\n  double res = 0;\n  for(int i = 0 ; i < M ; i++){\n    edge e = es[i];\n    if(!same(e.u , e.v)){\n      unite(e.u , e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\ndouble dist(P p1, P p2){\n  return sqrt(pow(p1.first-p2.first,2)+pow(p1.second-p2.second,2));\n}\n\nint main(){\n  int a,b;\n  P p[MAX];\n\n  scanf(\"%d %d\" ,&N ,&M);\n  for(int i = 0 ; i < N ; i++){\n    scanf(\"%lf%lf\",&p[i].first, &p[i].second);\n  }\n  double total = 0;\n  for(int i = 0 ; i < M ; i++){\n    scanf(\"%d %d\" ,&a ,&b);  \n    a--, b--;\n    double d = dist(p[a], p[b]);\n    es[i].u = a; es[i].v = b; es[i].cost = d;\n    total += d;\n  }\n  printf(\"%.5f\\n\",total-kruskal());\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n// ?´?????????????????§????\nstruct UnionFind\n{\n  // par[i]????????????i????±?????????¨??????????????????i == par[i]?????¨???????????????i?????¨?????????????????§??????\n  vector<int> par;\n  // sizes[i]???????????????i?????¨?????????????????????????????°???i?????????????????§????????´???????????????????????¨??????\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // ???????????¨???????????????i?????°?????????i????????¨??????????????¨???????????????\n    REP(i, n) par[i] = i;\n  }\n\n  // ?????????x????±?????????¨???????????????\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // ????????????????????????????????°???????????????????????¢???\n  }\n\n  // 2???????????????x, y????±?????????¨??????????????????\n  void unite(int x, int y) {\n    // ?????????????????????????????????\n    x = find(x);\n    y = find(y);\n\n    // ??¢???????????¨????±?????????????????????????????????????\n    if (x == y) return;\n\n    // x?????¨???y?????¨????????§???????????????????????????\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // x???y??????????????????????????£?????????\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]????????????????????¨???????????§0?????\\????????????????????????\n  }\n\n  // 2???????????????x, y????±?????????¨???????????????true?????????\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // ?????????x?????????????????¨?????§???????????????\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// ??????a, b?????????????????????cost??????????????????\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // ??????????????§?°???§????????????\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// ????????°??¨?????????????????¨????????????????????°??????\nstruct Graph\n{\n  int n;  // ????????°\n  vector<Edge> es;  // ?????????\n\n  // ????????????????????§??????????°???¨?????¨??????????????????????¨??????????\n  // ??°??????????????£????????¨??????????°???¨????£?????????????????????¨??????\n  double kruskal() {\n    // ?????????????°??????????????????????\n    RSORT(es);\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // ????????????????????????????????§???????????????????????????????????¨??????\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n\n    Graph g;\n    g.n = n;\n\n    double cost = 0;\n    vector<pii> piles;\n    REP(i, n) {\n        int x, y;\n        cin >> x >> y;\n        piles.push_back({x, y});\n    }\n    REP(i, m) {\n        int p, q;\n        cin >> p >> q;\n        p--;\n        q--;\n        pii P = piles[p], Q = piles[q];\n        double c = hypot(P.first - Q.first, P.second - Q.second);\n        cost += c;\n        g.es.push_back({p, q, c});\n    }\n    printf(\"%.04f\\n\", cost - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<stack>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<deque> \nusing namespace std;\n#define INF 0x3f3f3f3f\ntypedef long long LL;\ntypedef pair<int,int> ppp;\nconst int maxn = 10010;\nint n,m;\nstruct lalala{\n\tint x,y;\n}mood[maxn];\nstruct node{\n\tint u,v;\n\tdouble dis;\n}mp[2*maxn];\ndouble work(int u,int v){\n\treturn (double)sqrt((mood[u].x-mood[v].x)*(mood[u].x-mood[v].x) + (mood[u].y-mood[v].y)*(mood[u].y-mood[v].y));\n}\nbool cmp(node a,node b){\n\treturn a.dis > b.dis;\n}\nint fa[maxn];\nint find(int x){\n\treturn fa[x]==x?x:fa[x]=find(fa[x]);\n}\n\ndouble kruskal(){\n\tsort(mp+1,mp+1+m,cmp);\n\tdouble ans = 0;\n\tmemset(fa,0,sizeof fa); \n\tfor (int i=1 ; i<=n ; i++) fa[i] = i;\n\tfor (int i=1 ; i<=m ; i++){\n\t\tint cnt1 = find(mp[i].u),cnt2 = find(mp[i].v);\n\t\tif (cnt1 != cnt2){\n\t\t\tans += mp[i].dis;\n\t\t\tfa[cnt1] = cnt2;\n\t\t}\n\t\t//else ans += mp[i].dis;\n\t}\n\treturn ans;\n}\nint main(){\n\tdouble sum;\n\twhile (~scanf(\"%d%d\",&n,&m)){\n\t\tfor (int i=1 ; i<=n ; i++)\n\t\t\tscanf(\"%d%d\",&mood[i].x,&mood[i].y);\n\t\tint u,v;\n\t\tsum = 0.0;\n\t\tfor (int i=1 ; i<=m ; i++){\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tmp[i].u = u; mp[i].v = v; mp[i].dis = work(u,v);\n\t\t\tsum += mp[i].dis;\n\t\t\t//mp[i+m].u = v; mp[i+m].v = u; mp[i+m].dis = work(v,u);\n\t\t}\n\t\tdouble ans = kruskal();\n\t\tprintf(\"%.3f\\n\",sum-ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<string.h>\n#include<string>\n#include<algorithm>\n#include<math.h>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nstruct dataNode\n{\n\tdouble start_point,end_point;\n\tdouble cost_value;\n}point[20000],Edge[20000];\nint parent[20000];\nint N,M;\n\nint Find_Parent (int x)\n{\n\twhile (x != parent[x])\n\t{\n\t\tx = parent[x];\n\t}\n\treturn parent[x];\n}\n\ndouble Get_distance (dataNode one_point ,dataNode two_point)\n{\n\tdouble temp_value1 = (one_point.start_point * 1.0 - two_point.start_point *1.0) * (one_point.start_point *1.0 - two_point.start_point*1.0);\n\tdouble temp_value2 = (one_point.end_point *1.0 - two_point.end_point * 1.0) * (one_point.end_point *1.0 - two_point.end_point * 1.0);\n\treturn sqrt(temp_value1 + temp_value2);\n}\nvoid Union_point (int one ,int two)\n{\n\tparent[one] = two;\n}\n\ndouble Krus ()\n{\n\tdouble sum_Tree = 0;\n\tint total_edge = 0;\n\tfor (int i=0;i<M && total_edge<N-1;i++)\n\t{\n\t\tint one = Edge[i].start_point;\n\t\tint two = Edge[i].end_point;\n\t\tint one_parent = Find_Parent(one);\n\t\tint two_parent = Find_Parent(two);\n\t\tif (one_parent != two_parent)\n\t\t{\n\t\t\tUnion_point(one_parent,two_parent);\n\t\t\tsum_Tree += Edge[i].cost_value;\n\t\t\ttotal_edge++;\n\t\t}\n\t}\n\treturn sum_Tree;\n}\nint cmp (const void *aa,const void *bb)\n{\n\tdataNode* a = (dataNode *) aa;\n\tdataNode* b = (dataNode *) bb;\n\treturn a->cost_value < b->cost_value ? 1 : -1;\n}\n\nint main()\n{\n\t\tcin>>N>>M;\n\t\tfor (int i=1;i<=N;i++)\n\t\t{\n\t\t\tparent[i] = i;\n\t\t}\n\t\tfor (int i=1;i<=N;i++)\n\t\t{\n\t\t\tcin>>point[i].start_point>>point[i].end_point;\n\t\t}\n\t\tdouble total_sum = 0;\n\t\tfor (int i=0;i<M;i++)\n\t\t{\n\t\t\tdataNode temp;\n\t\t\tint st_po,en_po;\n\t\t\tcin>>st_po>>en_po;\n\t\t\ttemp.start_point = st_po;\n\t\t\ttemp.end_point = en_po;\n\t\t\ttemp.cost_value = Get_distance(point[st_po],point[en_po]);\n\t\t\tEdge[i] = temp;\n\t\t\ttotal_sum += temp.cost_value;\n\t\t}\n\t\tqsort(Edge,M,sizeof(Edge[0]),cmp);\n\t\tdouble temp_krus = Krus();\n\t\tdouble result = total_sum - temp_krus;\n\t\tprintf(\"%.3lf\\n\",result);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\n// double kruskal(){\n// \tsort(es,es+E);\n// \tinit(V);\n// \tdouble res = 0;\n// \tfor(int i=0; i<E; i++){\n// \t\tedge e = es[i];\n// \t\tif(!same(e.u,e.v))\n// \t\t\tunite(e.u,e.v);\n// \t\telse\n// \t\t\tres += e.cost;\n// \t}\n\n// \treturn res;\n// }\ndouble kruskal()\n{\n\tsort(es, es + E);    // ?????§??????????°???°??§??????\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n\nint main(int argc, char *argv[])\n{\n\tcin >> V >> E;\n\t\n\tfor (int i = 0; i < V; ++i)\n\t{\n\t\tcin >> pile[i].first >> pile[i].second;\n\t}\n \n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tcin >> es[i].u >> es[i].v;\n\t\t--es[i].u; --es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx * dx + dy * dy);\n\t}\n \n\tcout.setf(ios::showpoint);\n\tcout.precision(3);\n\tcout.setf(ios::fixed);\n\tcout << kruskal() << endl;\n\treturn 0;\n}\n// int main(){\n// \tscanf(\"%d%d\",&V,&E);\n// \tfor(int i=0; i<V; i++)\n// \t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n// \tfor(int i=0; i<E; i++){\n// \t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n// \t\t--es[i].u,--es[i].v;\n// \t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n// \t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n// \t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n// \t}\n\n// \tprintf(\"%.3lf\\n\",kruskal());\n// }"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<complex>\n#include<algorithm>\nusing namespace std;\n//typedef complex<double> Point;\n//typedef complex<double> Vector;\ntypedef long long LL;\n\nint n,m;\nint pa[20000];\n\nvoid init()\n{\n    for(int i=1;i<=n;i++)\n        pa[i] = i;\n}\n\nint find(int x)\n{\n    if(pa[x]!= x) pa[x] = find(pa[x]);\n    return pa[x];\n}\n\nstruct edge\n{\n    int x,y;\n    double w;\n    bool operator < (struct edge t) const\n    {\n        return (t.w - w)<1e-6;\n    }\n}e[20000];\n\nstruct point\n{\n    int x,y;\n}p[20000];\n\ndouble kruskal()\n{\n    double res = 0;\n    int cnt = 0;\n    for(int i=1;i<=m;i++)\n    {\n        int a = find(e[i].x), b = find(e[i].y);\n        if(a != b)\n        {\n            pa[a] = b;\n            cnt++;\n            res += e[i].w;\n        }\n        if(cnt == n-1) break;\n    }\n    return res;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        memset(p,0,sizeof(p));\n        memset(e,0,sizeof(e));\n        init();\n        double sum = 0;\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        for(int i=1;i<=m;i++)\n        {\n            int tx,ty;\n            scanf(\"%d%d\",&tx,&ty);\n            e[i].x = tx, e[i].y = ty, e[i].w = sqrt(1.0*(p[tx].x - p[ty].x)*(p[tx].x - p[ty].x) + 1.0*(p[tx].y - p[ty].y)*(p[tx].y - p[ty].y));\n            sum += e[i].w;\n        }\n        sort(e+1,e+m+1);\n        printf(\"%.3f\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n#define MAXN 2000\n#define MAXM 10000\nstruct pos\n{\n    int x,y;\n}P[MAXN*2+5];\nstruct node\n{\n    int x,y;\n    double price;\n}a[MAXM*5+5];\nint n,m,T;\nint p,father[MAXN*2+5];\nint num,cont;\ndouble ans=0,sum;\nvoid fpush(int u,int v,double w)\n{\n    a[++num].price=w;\n    a[++num].price=w;\n    a[num-1].x=a[num].y=u;\n    a[num-1].y=a[num].x=v;\n}\nbool cmp(node s1,node s2)\n{\n    return s1.price>s2.price;\n}\nint xfind(int p)\n{\n    if(father[p]!=p)father[p]=xfind(father[p]);\n    return father[p];\n}\nint bin(int p1,int p2)\n{\n    father[p2]=p1;\n}\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    cont=0,num=0,ans=0;;\n    memset(father,0,sizeof(father));\n    bin(0,0);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d%d\",&P[i].x,&P[i].y);\n        bin(i,i);\n    }\n    for(int i=1;i<=m;i++)\n    {\n        int u,v;double dist;\n        scanf(\"%d%d\",&u,&v);\n        dist=sqrt((double)(P[u].x-P[v].x)*(P[u].x-P[v].x)+(double)(P[u].y-P[v].y)*(P[u].y-P[v].y));\n        sum+=dist;\n        fpush(u,v,dist);\n    }\n    sort(a+1,a+num+1,cmp);\n    for(int i=1;i<=num;i++)\n    {\n        if(cont==n-1)break;\n        int s1=xfind(a[i].x),s2=xfind(a[i].y);\n        if(s1!=s2)\n        {\n            bin(s1,s2);\n            ans+=a[i].price;\n            cont++;\n        }\n    }\n    printf(\"%.3lf\\n\",sum-ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//{Headers\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n\nusing namespace std;\ntypedef vector< int > vi;\ntypedef vector< vi > vvi;\ntypedef pair< int,int > pii;\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\n//}\n\nconst int MAXN=1e4,MAXM=1e8;\nint N,M,par[MAXN+1];\npair<int,int> pt[MAXN+1];\nstruct Edge{int from,to;double cost;} edge[MAXM];\n\nbool cmp(const Edge& a,const Edge& b){return a.cost>b.cost;}\n\ndouble dist(int from,int to){\n    return sqrt(pow(pt[from].first-pt[to].first,2)\n                +pow(pt[from].second-pt[to].second,2));\n}\n\nint root(int x){return x==par[x]?x:par[x]=root(par[x]);}\n\nbool unite(int x,int y){\n    int rx=root(x),ry=root(y);\n    if(rx>ry) par[rx]=ry;\n    else if(rx<ry) par[ry]=rx;\n    else return false;\n    return true;\n}\n\nvoid solve(){\n    double ans=0;\n    for(int i=0;i<M;i++) ans+=edge[i].cost;\n    sort(edge,edge+M,cmp);\n    for(int i=1;i<=N;i++) par[i]=i;\n    for(int i=0;i<M;i++) if(unite(edge[i].from,edge[i].to))\n        ans-=edge[i].cost;\n    printf(\"%.8f\\n\",ans);\n}\n\nint main(void){\n//    freopen(\"in.txt\",\"r\",stdin);\n    while(~scanf(\"%d%d\",&N,&M)){\n        for(int i=1;i<=N;i++) scanf(\"%d%d\",&pt[i].first,&pt[i].second);\n        for(int i=0;i<M;i++){\n            scanf(\"%d%d\",&edge[i].from,&edge[i].to);\n            edge[i].cost=dist(edge[i].from,edge[i].to);\n        }\n        solve();\n    }\n    return 0;\n}\n\n/*\nSample Input 1\n3 3\n0 0\n3 0\n0 4\n1 2\n2 3\n3 1\nOutput for the Sample Input 1\n3.000\nSample Input 2\n4 3\n0 0\n-100 0\n100 0\n0 100\n1 2\n1 3\n1 4\nOutput for the Sample Input 2\n0.000\nSample Input 3\n6 7\n2 0\n6 0\n8 2\n6 3\n0 5\n1 7\n1 2\n2 3\n3 4\n4 1\n5 1\n5 4\n5 6\nOutput for the Sample Input 3\n7.236\nSample Input 4\n6 6\n0 0\n0 1\n1 0\n30 0\n0 40\n30 40\n1 2\n2 3\n3 1\n4 5\n5 6\n6 4\nOutput for the Sample Input 4\n31.000\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n//\nint par_uf[100010],rank_uf[100010];\n\nvoid init(int n){for(int i=0;i<n;i++){par_uf[i]=i;rank_uf[i]=0;}}\nint find(int x){if(par_uf[x]==x)return x;else return par_uf[x]=find(par_uf[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank_uf[x]<rank_uf[y])par_uf[x]=y;else{par_uf[y]=x;if(rank_uf[x]==rank_uf[y])rank_uf[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n//\n\nint N,M,x[10010],y[10010];\npair<double,pi> e[10010];\n\n#define sq(x) ((x)*(x))\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N>>M;\n\trep(i,N)cin>>x[i]>>y[i];\n\tdouble ans=0;\n\trep(i,M){\n\t\tint p,q;\n\t\tcin>>p>>q;\n\t\tp--;q--;\n\t\tdouble len=sqrt(sq(x[p]-x[q])+sq(y[p]-y[q]));\n\t\tans+=len;\n\t\te[i]=mp(-len,mp(p,q));\n\t}\n\tsort(e,e+M);\n\tinit(N);\n\trep(i,M){\n\t\tint p=e[i].sec.fir,q=e[i].sec.sec;\n\t\tif(!same(p,q)){\n\t\t\tans+=e[i].fir;\n\t\t\tunite(p,q);\n\t\t}\n\t}\n\tcout<<setprecision(16)<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nstruct edge {\n    int u, v;\n    double cost;\n};\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) { }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool findSet(int x, int y) {\n        return root(x) == root(y);\n    }\n    int root(int x) {\n        return data[x] < 0 ? x : data[x] = root(data[x]);\n    }\n    int size(int x) {\n        return -data[root(x)];\n    }\n};\n\nbool comp(const edge &e1, const edge &e2)\n{\n    return e1.cost > e2.cost;\n}\n\nint N, M;\nvector<edge> es;\n\ndouble kruskal()\n{\n    sort(es.begin(), es.end(), comp);\n    UnionFind uf(N);\n    double res = 0;\n\n    for (int i = 0; i < M; i++) {\n        edge e = es[i];\n        if (!uf.findSet(e.u, e.v)) {\n            uf.unionSet(e.u, e.v);\n            res += e.cost;\n        }\n    }\n\n    return res;\n}\n\ninline double distance(double x1, double y1, double x2, double y2)\n{\n    return sqrt(abs(x1 - x2) * abs(x1 - x2) + abs(y1 - y2) * abs(y1 - y2));\n}\n\nint main()\n{\n    int p, q;\n    double all_distance = 0.0;\n\n    cin >> N >> M;\n    vector<int> x(N), y(N);\n    es.resize(M);\n\n    for (int i = 0; i < N; i++)\n        cin >> x[i] >> y[i];\n    for (int i = 0; i < M; i++) {\n        cin >> p >> q;\n        p--, q--;\n\n        es[i].u = p;\n        es[i].v = q;\n        all_distance += es[i].cost = distance(x[p], y[p], x[q], y[q]);\n    }\n    cout << setprecision(4) << setiosflags(ios::fixed);\n    cout << all_distance - kruskal() << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \nusing namespace std;\nclass UnionFind {\n  vector<int> p;\npublic:\n  UnionFind (int n) : p(n, -1) {}\n  int root(int x) {\n    return p[x] < 0 ? x : p[x] = root(p[x]);\n  }\n  bool same(int x, int y) {\n    return root(x) == root(y);\n  }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (p[y] < p[x]) swap(x, y);\n    if (p[x] == p[y]) --p[x];\n    p[y] = x;\n    return true;\n  }\n};\ndouble norm(double x, double y) { return sqrt(x*x+y*y); }\nint main(void)\n{\n  int n,m;\n  cin >> n >> m;\n  vector<double> x(n),y(n);\n  REP(i,n) cin >> x[i] >> y[i];\n  vector<tuple<double,int,int>> e(m);\n  REP(i,m) {\n    int l,r;\n    cin >> l >> r;\n    --l; --r;\n    double nlen = -norm(x[r]-x[l], y[r]-y[l]);\n    e[i]=make_tuple(nlen,l,r);\n  }\n  SORT(e);\n  UnionFind uf = UnionFind(n);\n  double answer=0.0;\n  REP(i,m) {\n    double nlen;\n    int l,r;\n    tie(nlen, l, r) = e[i];\n    if(!uf.unite(l,r)) answer-=nlen;\n  }\n  cout << fixed << answer << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<double,double> P;\nconst double EPS = 1e-12;\nconst int INF = numeric_limits<int>::max()/2;\nconst int MOD = 1e9+7;\n\nstruct Edge{\n    int from, to;\n    double cost;\n    Edge(int from, int to,double cost): from(from), to(to), cost(cost){}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nbool operator < (const Edge &e, const Edge &f){\n    return e.cost < f.cost;\n}\n\nstruct UF {\n\tvector<int> data;\n\tUF(int size) : data(size, -1) { }\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool find(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ndouble MST(const Graph &g){\n    int sz = g.size();\n    UF uf(sz);\n    priority_queue<Edge> q;\n    for(int i=0;i<sz;i++)for(int j=0;j<(int)g[i].size();j++) q.push(g[i][j]);\n\n    double res=0;\n    while(!q.empty()){\n        Edge e=q.top();q.pop();\n        if(!uf.find(e.from,e.to)){\n            res+=e.cost;\n            uf.unite(e.from,e.to);\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n,m;cin>>n>>m;\n    vector<P> v(n);\n    for(int i=0;i<n;i++){\n        double x,y;cin>>x>>y;\n        v[i]=P(x,y);\n    }\n    double sum=0;\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int st,gt;cin>>st>>gt;\n        st--;gt--;\n        double sx=v[st].first,sy=v[st].second,gx=v[gt].first,gy=v[gt].second;\n        double d=(sx-gx)*(sx-gx)+(sy-gy)*(sy-gy);\n        d=sqrt(d);\n        g[st].push_back(Edge(st,gt,d));\n        sum+=d;\n    }\n    cout<<fixed<<setprecision(10)<<sum-MST(g)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> data; int group;\n    UnionFind(int N) : data(N, -1), group(N) {}\n    void init(int N) {\n        data.assign(N, -1);\n        group = N;\n    }\n    void unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x != y){\n            data[x] += data[y];\n            data[y] = x;\n            --group;\n        }\n    }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]);}\n    bool same(int a, int b) { return root(a) == root(b);}\n};\n\ntypedef pair<int, int> pint;\ntypedef complex<double> P;\ntypedef tuple<double, int, int> Edge;\n\nint main() {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int N, M; cin >> N >> M;\n    vector<P> piles(N);\n    for(auto& p : piles) {\n        double x, y;\n        cin >> x >> y;\n        p = P(x, y);\n    }\n    vector<Edge> edges(M);\n    double sum = 0.0;\n    for(auto& e : edges) {\n        int p, q;\n        cin >> p >> q;\n        --p; --q;\n        double dist = abs(piles[p] - piles[q]);\n        e = Edge(dist, p, q);\n        sum += dist;\n    }\n    sort(edges.rbegin(), edges.rend());\n    UnionFind uf(N);\n    double ans = 0.0;\n    for(const auto& e : edges) {\n        double dist; int u, v;\n        tie(dist, u, v) = e;\n        if(uf.same(u, v) == false) {\n            uf.unite(u, v);\n            ans += dist;\n        }\n    }\n    ans = sum - ans;\n    cout << fixed << setprecision(3) << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\n// double kruskal(){\n// \tsort(es,es+E);\n// \tinit(V);\n// \tdouble res = 0;\n// \tfor(int i=0; i<E; i++){\n// \t\tedge e = es[i];\n// \t\tif(!same(e.u,e.v))\n// \t\t\tunite(e.u,e.v);\n// \t\telse\n// \t\t\tres += e.cost;\n// \t}\n\n// \treturn res;\n// }\ndouble kruskal()\n{\n\tsort(es, es + E);    // ?????§??????????°???°??§??????\n\tinit(V);\n\tdouble res = 0;\n\tfor (int i = 0; i < E; ++i)\n\t{\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tres += e.cost;\n\t\t}\n\t}\n \n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct edge{\n\tint from;\n\tint to;\n\tdouble cost;\n};\n\nint a[10000], rank[10000];\n\nvoid init(){\n\tfor(int i = 0;i < 10000;i++){\n\t\ta[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(a[x] == x)\n\t\treturn x;\n\telse\n\t\treturn find(a[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(rank[x] < rank[y])\n\t\ta[x] = y;\n\telse{\n\t\ta[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\ndouble dist(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));\n}\n\nint cmp(const void* a,const void* b){\n\tstruct edge *ea = (struct edge *)a;\n\tstruct edge *eb = (struct edge *)b;\n\tif(eb->cost - ea->cost > 0)\n\t\treturn 1;\n\telse if(eb->cost - ea->cost < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nint main(void){\n\tint n, m, x[10000], y[10000], p, q, i, j, c;\n\tdouble s;\n\tedge e[1000000];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\ts = 0;\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d\",&p,&q);\n\t\te[i].from = p - 1,e[i].to = q - 1;\n\t\ts += e[i].cost = dist(x[p - 1],y[p - 1],x[q - 1],y[q - 1]);\n\t}\n\tqsort(e,m + 1,sizeof(e[0]),cmp);\n\tc = 0;\n\tinit();\n\tfor(i = 0;i < n;i++)\n\t\tif(i == a[i]) c++;\n\tfor(i = 0;i < m && c != 1;i++){\n\t\tif(find(e[i].from) != find(e[i].to)){\n\t\t\tunite(e[i].from,e[i].to);\n\t\t\ts -= e[i].cost;\n\t\t}\n\t\tc = 0;\n\t\tfor(j = 0;j < n;j++)\n\t\t\tif(j == a[j]) c++;\n\t}\n\tprintf(\"%.3f\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <set>\n#include <cstdio>\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) ((abs((a)-(b)))<EPS)\n\ntypedef complex<double> P;\n\nstruct edge{\n\tint to;\n\tdouble cost;\n};\n\nint n,m;\nvector<edge> G[10001];\nvector<edge> G2[10001];\nP points[10001];\nconst double INF=1000000000;\ndouble mincost[10001];\nbool used[10001];\n\n// _s©çÅ¬SæØðì¬\ndouble prim(int s,int V){\n\tfor(int i=0;i<V;i++)mincost[i]=INF;\n\tmincost[s]=0;\n\tdouble res=0;\n\twhile(1){\n\t\tint v=-1;\n\t\t// xÉ®³È¢¸_Ì¤¿,x©çÌÓÌRXgªÅ¬ÆÈé_ð³ª·\n\t\tfor(int u=0;u<V;u++)\n\t\t\t// Ü¾IÎêÄ¢È¢©ÂA»±ÖÌRXgªÅ¬\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v]))v=u;\n\t\tif(v==-1||EQ(mincost[v],INF))break;\n\t\t// xÉvðÇÁ\n\t\tused[v]=true;\n\t\t// vÖÌRXgðÁ¦é\n\t\tres+=mincost[v];\n\t\t// »ê¼êÌÓÖÌÅ¬RXgðXV\n\t\tfor(int i=0;i<(int)G[v].size();i++){\n\t\t\tint u=G[v][i].to;\n\t\t\tmincost[u]=min(mincost[u],G[v][i].cost);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tpoints[i]=P(x,y);\n\t}\n\tdouble sum=0;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tb--;a--;\n\t\tedge e;\n\t\te.to=b;\n\t\te.cost=-abs(points[a]-points[b]);\n\t\tsum+=-e.cost;\n\t\tG[a].push_back(e);\n\t\te.to=a;\n\t\tG[b].push_back(e);\n\t}\n\tdouble res=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(used[i])continue;\n\t\tres+=prim(i,n);\n\t}\n\tprintf(\"%.10f\\n\",sum+res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\nconst int maxn=1e4+5;\ntypedef long long LL;\nstruct Point\n{\n    int x;\n    int y;\n};\n\nPoint a[maxn];\ndouble cost[maxn][maxn];\nbool used[maxn];\nint n,m;\ndouble maxcost[maxn];\ndouble cal_distance(Point a,Point b)\n{\n  return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\ndouble  prim(int p)\n{\n  memset(used,0,sizeof(used));\n  for(int i=0;i<=n;i++)\n    maxcost[i]=-1;\n  double ans=0.0;\n  maxcost[p]=0;\n  while(1)\n  {\n      int v=-1;\n      for(int u=1;u<=n;u++)\n        if(!used[u]&&(v==-1||maxcost[u]>maxcost[v]))\n        v=u;\n      if(v==-1)\n        break;\n      used[v]=1;\n      ans+=maxcost[v];\n      for(int u=1;u<=n;u++)\n        maxcost[u]=max(maxcost[u],cost[v][u]);\n  }\n  return ans;\n}\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n        for(int i=1;i<=n;i++)\n            scanf(\"%d%d\",&a[i].x,&a[i].y);\n        memset(cost,0,sizeof(cost));\n        int p1,p2;\n        double sum=0;\n        for(int i=1;i<=m;i++)\n        {\n            scanf(\"%d%d\",&p1,&p2);\n            sum+=cost[p1][p2]=cost[p2][p1]=cal_distance(a[p1],a[p2]);\n        }\n//        for(int i=1;i<=n;cout<<endl,i++)\n//            for(int j=1;j<=n;j++)\n//             cout<<cost[i][j]<<\" \";\n//        cout<<sum<<endl;\n         double ans=(double)10000*sqrt(2);\n         for(int u=1;u<=n;u++)\n          ans=min(ans,sum-prim(u));\n         printf(\"%.3f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nclass UnionFindTree{\nprivate:\n  int _size;\n  int* _parent;\n  int* _rank;\npublic:\n  UnionFindTree(int n){\n    _size = n;\n    _parent = new int[_size]();\n    _rank = new int[_size]();\n    for(int i = 0; i < _size; i++){\n      _parent[i] = i;\n      _rank[i] = 1;\n    }\n  }\n\n  ~UnionFindTree(){\n    delete[] _parent;\n    delete[] _rank;\n  }\n\n  int find(int child){\n    int next = _parent[child];\n    if(next == child) return child;\n    else return find(next);\n  }\n\n  bool same(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    return (lhs == rhs);\n  }\n  \n  bool unite(int lhs,int rhs){\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(same(lhs,rhs)) return false;\n    \n    if(_rank[lhs] < _rank[rhs]){\n      _parent[rhs] = lhs;\n      _rank[lhs] += _rank[rhs];\n    }\n    else {\n      _parent[lhs] = rhs;\n      _rank[rhs] += _rank[lhs];\n    }\n    return true;\n  }\n\n};\n\nclass State {\npublic:\n  int _from,_to;\n  double _distance;\n  State(int from,int to,double distance)\n    : _from(from),_to(to),_distance(distance) {}\n  bool operator<(const State& s) const {\n    return _distance < s._distance;\n  }\n  bool operator>(const State& s) const {\n    return _distance > s._distance;\n  }\n};\n\nint main(){\n  int num_of_magical_piles;\n  int num_of_magical_fences;\n  while(~scanf(\"%d %d\",\n               &num_of_magical_piles,\n               &num_of_magical_fences)){\n    \n    vector<P> piles;\n    for(int pile_i = 0; pile_i < num_of_magical_piles; pile_i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      piles.push_back(P(x,y));\n    }\n\n    double sum = 0;\n    priority_queue<State,vector<State>,less<State> > que;\n\n    for(int fence_i = 0; fence_i < num_of_magical_fences; fence_i++){\n      int from,to;\n      scanf(\"%d %d\",&from,&to);\n      from--; to--;\n      int from_x = piles[from].first;\n      int from_y = piles[from].second;\n\n      int to_x = piles[to].first;\n      int to_y = piles[to].second;\n\n      double distance = sqrt((double)((from_x - to_x) * (from_x - to_x)\n                                      + (from_y - to_y) * (from_y - to_y)));\n      sum += distance;\n      que.push(State(from,to,distance));\n    }\n\n    UnionFindTree uft(num_of_magical_piles);\n    double after_ruined = 0;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(uft.same(s._from ,s._to)){\n        continue;\n      }\n      uft.unite(s._from,s._to);\n      after_ruined += s._distance;\n    }\n    printf(\"%lf\\n\",sum - after_ruined);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst double INF = 0;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;\npair<int, int> data[MAX_V];\n\ndouble dist(pair<int, int> a, pair<int, int> b){\n  return sqrt((a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second));\n}\n\ndouble prim(){\n  for(int i=0;i<V;++i){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  double res = 0;\n  \n  for(;;){\n    int v = -1;\n    for(int u=0;u<V;++u){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u=0;u<V;++u){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && n|m){\n    fill(cost[0], cost[n], INF);\n    for(int i=0;i<n;++i){\n      cin >> data[i].first >> data[i].second;\n    }\n    double sum = 0.0;\n    for(int i=0;i<m;++i){\n      int a, b;\n      double tmp;\n      cin >> a >> b;\n      --a;\n      --b;\n      tmp = dist(data[a], data[b]);\n      sum += tmp;\n      cost[a][b] = cost[b][a] = -tmp;\n    }\n    V = n;\n    printf(\"%.3f\\n\", sum + prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\nusing ld = long double;\nclass DisjointSets\n{\npublic:\n    DisjointSets(const int v)\n    {\n        m_parent.resize(v);\n        m_rank.resize(v);\n        m_size.resize(v);\n        for (int i = 0; i < v; i++) {\n            m_parent[i] = i;\n            m_rank[i] = 0;\n            m_size[i] = 1;\n        }\n    }\n\n    bool same(const int a, const int b)\n    {\n        return find(a) == find(b);\n    }\n\n\n    int find(const int a)\n    {\n        if (m_parent[a] == a) {\n            return a;\n        } else {\n            return m_parent[a] = find(m_parent[a]);\n        }\n    }\n\n    void unite(const int a_, const int b_)\n    {\n        const int a = find(a_);\n        const int b = find(b_);\n        if (a == b) {\n            return;\n        }\n        if (m_rank[a] > m_rank[b]) {\n            m_parent[b] = a;\n            m_size[a] += m_size[b];\n        } else {\n            m_parent[a] = b;\n            m_size[b] += m_size[a];\n        }\n        if (m_rank[a] == m_rank[b]) {\n            m_rank[b]++;\n        }\n    }\n\n    int getSize(const int a)\n    {\n        return m_size[m_parent[a]];\n    }\n\nprivate:\n    vector<int> m_parent;\n    vector<int> m_rank;\n    vector<int> m_size;\n};\n\nstruct Edge {\n    int from;\n    int to;\n    ld cost;\n    bool operator<(const Edge& e) const\n    {\n        return cost < e.cost;\n    }\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n    using P = pair<ld, ld>;\n    vector<P> pos(n);\n    for (int i = 0; i < n; i++) {\n        cin >> pos[i].first >> pos[i].second;\n    }\n    priority_queue<Edge> Q;\n    DisjointSets uf(n);\n    ld total = 0;\n    for (int i = 0; i < m; i++) {\n        int from;\n        int to;\n        cin >> from >> to;\n        from--, to--;\n        const ld l = hypot(pos[from].first - pos[to].first, pos[from].second - pos[to].second);\n        total += l;\n        Q.push(Edge{from, to, l});\n    }\n\n    ld rest = 0;\n    for (int i = 0; i < m; i++) {\n        const auto& e = Q.top();\n        const int p = e.from;\n        const int q = e.to;\n        if (not uf.same(p, q)) {\n            uf.unite(p, q);\n            rest += e.cost;\n        }\n        Q.pop();\n    }\n    cout << fixed << setprecision(10) << total - rest << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,int> id;\nint n,m;\ndouble ans;\nP a[10000];\nvector<int> G[10000];\nbool used[10000];\n\ndouble getl(P a,P b){\n  return sqrt((a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s));\n}\n\nvoid prin(){\n  for(int i=0;i<n;i++){\n    if(used[i])continue;\n    priority_queue<id> q;\n    q.push(id(0,i));\n    while(!q.empty()){\n      id t=q.top();\n      q.pop();\n      if(used[t.s])continue;\n      used[t.s]=1;\n      ans-=t.f;\n      for(int j=0;j<G[t.s].size();j++)\n\tq.push(id(getl(a[i],a[G[t.s][j]]),G[t.s][j]));\n    }   \n  }\n  printf(\"%f\\n\",ans);\n}\n\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)\n    cin>>a[i].f>>a[i].s;\n  for(int i=0,p,q;i<m;i++){\n    cin>>p>>q;\n    p--,q--;\n    G[p].push_back(q);\n    G[q].push_back(p);\n    ans+=getl(a[p],a[q]);\n  }\n  prin();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<map>\n#include<cmath>\n#include<queue>\n#define LL long long \n#define For(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\nLL N,M,T;\nstruct road{\n\tint A,B;\n\tdouble V; \n}R[20101];\nint r[20001];\nstruct TT{\n\tint x,y;\n}H[11000];\nint t;\n\n\nint n,m,fa[20100];\ninline bool comp(const road &a,const road &b){\n\treturn a.V>b.V;\n}\nint getfather(int x){\n\tif(fa[x]==0) return x;\n\treturn fa[x]=getfather(fa[x]);\n}\nvoid init(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=m;i++) \n\t\tscanf(\"%d%d%d\",&R[i].A,&R[i].B,&R[i].V);\n}\ndouble solve(){\n\tint i,x,y,now=0;\n\tdouble ans=0.00000;\n\tsort(R+1,R+1+m,comp);\n\tfor(i=1;i<=m;i++){\n\t\tx=getfather(R[i].A);\n\t\ty=getfather(R[i].B);\n\t\tif(x!=y){\n\t\t\tfa[x]=y;\n\t\t\tr[i]=1;\n\t\t\tnow++;\n\t\t\tans+=R[i].V;\n\t\t\tif(now==n-1){\n\t\t\t\t//printf(\"%d %d\\n\",now,R[i].V);\n\t\t\t\treturn ans;\n\t\t\t}\n\t\t}\n\t\telse \n\t\t{\n\t\t\t\n\t\t}\n\t}\n\treturn 0.0;\n}\n\ndouble D(int i,int j)\n{\n\tdouble dd=(H[i].x-H[j].x)*(H[i].x-H[j].x) + (H[i].y-H[j].y)*(H[i].y-H[j].y);\n\treturn sqrt(dd*1.000000);\t\n}\n\n\nint main()\n{\n\tint a,b,c;\n\twhile(cin>>N>>M)\n\t{\n\t\tmemset(fa,0,sizeof(fa));\n\t\tmemset(r,0,sizeof(r));\n\t\tFor(i,N)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tH[i].x=a;\n\t\t\tH[i].y=b;\n\t\t}\n\t\tn=M;\n\t\tm=M;\n\t    t=0;\n\t    double sd=0.000;\n\t\tFor(i,M)\n\t\t{\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tdouble DD=D(a,b);\n\t\t\tR[i].A=a;\n\t\t\tR[i].B=b;\n\t\t\tR[i].V=DD;\n\t\t\tsd+=DD;\n\t\t}\n\n\t\t//\n\t\t\n\t\tdouble AA=solve();\n\t\t//cout<<AA<<endl;\n\t\tdouble sum=0.0;\n\t\tfor(int i=1;i<=m;i++)\n\t\t{\n\t\t\tif(!r[i])sum+=R[i].V;\n\t\t}\n\t\t\n\t\tprintf(\"%.8lf\\n\",sum);\n\t\t//else cout<<\"0.000000\\n\";\n\t\t\n\t}\n\n\treturn 0;\n}\n\n/*\n\n\n\n*/\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct Way{\n\tint p,q,cost;\n\tWay(){}\n\tWay(int _p,int _q,int _cost){\n\t\tp=_p; q=_q; cost=_cost;\n\t}\n\tbool operator<(const Way &a)const{\n\t\treturn cost>a.cost;\n\t}\n};\n\nstruct Node{\n\tint x,y;\n};\n\nint par[10000],_rank[10000];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++) par[i]=i,_rank[i]=1;\n}\n\nint find(int a){\n\tif(par[a]==a) return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int _a,int _b){\n\tint a = find(_a);\n\tint b = find(_b);\n\tif(a==b) return;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = a;\n\t}\n\telse{\n\t\tpar[a] = b;\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n}\n\nint main(){\n\tint N,M;\n\tNode node[10000];\n\tWay way[10000000];\n\tcin>>N>>M;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>node[i].x>>node[i].y;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin>>way[i].p>>way[i].q;\n\t\ta = node[--way[i].p].x-node[--way[i].q].x;\n\t\tb = node[way[i].p].y-node[way[i].q].y;\n\t\tway[i].cost = a*a+b*b;\n\t\t//printf(\"\\t%d\\n\",way[i].cost);\n\t}\n\n\tdouble ans=0;\n\tsort(way,way+M);\n\tinit(N);\n\tfor(int i=0;i<M;i++){\n\t\tint a = find(way[i].p),\n\t\t\tb = find(way[i].q);\n\t\tif(a!=b) unite(a,b);\n\t\telse ans += sqrt(way[i].cost);\n\t}\n\tprintf(\"%lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\nusing namespace std;\n#define INF 0x3f3f3f3f\n#define MAX_V 10000+10\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;\npair<int,int> p[MAX_V];\ndouble prim(){\n    for(int i=0;i<V;i++){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    double res=0;\n\n    while(true){\n        int v=-1;\n        for(int u=0;u<V;u++){\n            if(!used[u]&&(v==-1||mincost[u]<mincost[v]))v=u;\n        }\n\n        if(v==-1)break;\n        used[v]=true;\n        res+=mincost[v];\n        //cout<<v<<endl;\n        for(int u=0;u<V;u++){\n            mincost[u]=min(mincost[u],cost[v][u]);\n        }\n    }\n    return res;\n}\ndouble dis(int a,int b){\n    return sqrt((p[a].first-p[b].first)*(p[a].first-p[b].first)+(p[a].second-p[b].second)*(p[a].second-p[b].second));\n}\nint main(){\n    //freopen(\"1.txt\",\"r\",stdin);\n    int M;\n    while(~scanf(\"%d%d\",&V,&M)){\n        for(int i=0;i<V;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            p[i].first=a;\n            p[i].second=b;\n        }\n        double total=0;\n        for(int i=0;i<M;i++){\n            int a,b;\n            scanf(\"%d%d\",&a,&b);\n            a--;b--;\n            cost[a][b]=cost[b][a]=-dis(a,b);\n            total+=-cost[b][a];\n        }\n        printf(\"%.3f\",total+prim());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\nusing namespace std;\n\nstruct node\n{\n    int x,y,id;\n};\nstruct edge\n{\n    int u,v;\n    double cost;\n    edge() {}\n    edge(int x,int y,double z)\n    {\n        u=x;\n        v=y;\n        cost=z;\n    }\n    bool operator <(const edge& a) const\n    {\n        return cost>a.cost;\n    }\n};\n\nedge es[50010];\nint par[10010];\nnode p[10010];\nint n,m;\nvoid init()\n{\n    for(int i=1;i<=n;i++) par[i]=i;\n}\n\nint find(int x)\n{\n    return x==par[x]?x:par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y)\n{\n    x=find(x);\n    y=find(y);\n    if(x!=y) par[x]=y;\n}\n\ndouble dis(int a,int b)\n{\n    return sqrt(1.0*(p[a].x-p[b].x)*(p[a].x-p[b].x)+1.0*(p[a].y-p[b].y)*(p[a].y-p[b].y));\n}\n\ndouble kruskal()\n{\n    sort(es,es+m);\n    //for(int i=0;i<m;i++) printf(\"%d %d %lf\\n\",es[i].u,es[i].v,es[i].cost);\n    double s=0;\n    for(int i=0;i<m;i++)\n    {\n        edge e=es[i];\n        if(find(e.u)!=find(e.v))\n        {\n            unite(e.u,e.v);\n            s+=e.cost;\n        }\n    }\n    return s;\n}\nint main()\n{\n    //freopen(\"a.txt\",\"r\",stdin);\n    int a,b;\n    double c,sum;\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        init();\n        sum=0;\n        for(int i=1;i<=n;i++)\n        {\n            scanf(\"%d%d\",&p[i].x,&p[i].y);\n        }\n        for(int i=0;i<m;i++)\n        {\n            scanf(\"%d%d\",&a,&b);\n            c=dis(a,b);\n            sum+=c;\n            es[i]=edge(a,b,c);\n        }\n        printf(\"%.3lf\\n\",sum-kruskal());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int N=11111,M=111111<<2;\n\nstruct eglist{\n\tint other[M],succ[M],last[M],sum;\n\tvoid clear(){\n\t\tmemset(last,-1,sizeof last);\n\t\tsum=0;\n\t}\t\n\tvoid addEdge(int a,int b){\n\t\tother[sum]=b,succ[sum]=last[a],last[a]=sum++;\n\t\tother[sum]=a,succ[sum]=last[b],last[b]=sum++;\n\t}\n}e;\n\nint n,m;\n\nstruct point{\n\tint x,y;\n\tpoint(int x,int y):x(x),y(y){};\n\tpoint(){}\n\tfriend point operator -(point a,point b){\n\t\treturn\tpoint(a.x-b.x,a.y-b.y);\n\t}\n\tdouble arg(){\n\t\treturn\tatan2(y,x);\n\t}\n}points[N];\n\nvector<pair<int,double> > vecs;\nvector<int> ee[N];\nvector<pair<double,pair<int,int> > > edges;\ndouble length[M];\nint tot,father[M],next[M],visit[M];\n\nint find(int x){\n\treturn \tfather[x]==x?x:father[x]=find(father[x]);\n}\n\nlong long det(point a,point b){\n\treturn\t1LL*a.x*b.y-1LL*b.x*a.y;\n}\n\ndouble dist(point a,point b){\n\treturn\tsqrt(1.0*(a.x-b.x)*(a.x-b.x)+1.0*(a.y-b.y)*(a.y-b.y));\n}\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\te.clear();\n\tfor(int i=1;i<=n;++i){\n\t\tscanf(\"%d%d\",&points[i].x,&points[i].y);\n\t}\n\tfor\t(int i=1;i<=m;++i){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\te.addEdge(a,b);\n\t}\n\tfor\t(int x=1;x<=n;x++){\n\t\tvector<pair<double,int> > pairs;\n\t\tfor\t(int i=e.last[x];~i;i=e.succ[i]){\n\t\t\tint y=e.other[i];\n\t\t\tpairs.push_back(make_pair((points[y]-points[x]).arg(),i));\n\t\t}\n\t\tsort(pairs.begin(),pairs.end());\n\t\tfor\t(int i=0;i<pairs.size();++i)\n\t\t\tnext[pairs[(i+1)%pairs.size()].second^1]=pairs[i].second;\n\t}\n\tmemset(visit,0,sizeof visit);\n\ttot=0;\n\tfor\t(int start=0;start<e.sum;start++){\n\t\tif\t(visit[start])\tcontinue;\n\t\tlong long total=0;\n\t\tint now=start;\n\t\tvecs.clear();\n\t\twhile\t(!visit[now]){\n\t\t\tvisit[now]=1;\n\t\t\ttotal+=det(points[e.other[now^1]],points[e.other[now]]);\n\t\t\tvecs.push_back(make_pair(now/2,dist(points[e.other[now^1]],points[e.other[now]])));\n\t\t\tnow=next[now];\n\t\t\t//cout <<now <<endl;\n\t\t}\n\t\tif\t(now==start && total>0){\n\t\t\t//puts(\"*\");\n\t\t\t++tot;\n\t\t\tfor\t(int i=0;i<vecs.size();i++){\n\t\t\t\tee[vecs[i].first].push_back(tot);\n\t\t\t}\n\t\t}\n\t}\n\tfor\t(int i=0;i<e.sum/2;++i){\n\t\tint a=0,b=0;\n\t\tif\t(ee[i].size()==0)\tcontinue;\n\t\telse\t\n\t\t\tif\t(ee[i].size()==1){\n\t\t\t\ta=ee[i][0];\n\t\t\t}\n\t\t\telse\n\t\t\t\tif\t(ee[i].size()==2){\n\t\t\t\t\ta=ee[i][0];\n\t\t\t\t\tb=ee[i][1];\n\t\t\t\t}\n\t\tedges.push_back(make_pair(dist(points[e.other[i<<1]],points[e.other[i*2+1]]),make_pair(a,b)));\n\t}\n\t//printf(\"%d\\n\",edges.size());\n\tsort(edges.begin(),edges.end());\n\tfor\t(int i=0;i<=tot;i++)\tfather[i]=i;\n\tdouble ans=0;\n\tfor\t(int i=0;i<edges.size();i++){\n\t\tint a=edges[i].second.first,b=edges[i].second.second;\n\t\tdouble v=edges[i].first;\n\t\tif\t(find(a)!=find(b)){\n\t\t\tans+=v;\n\t\t\tfather[father[a]]=father[b];\n\t\t}\n\t}\n\tprintf(\"%.5f\\n\",ans);\n\treturn\t0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int maxn = 10005;\nstruct E{\n    int u,v;\n    double w;\n    bool operator<(const E& A) const\n    {\n        return w>A.w;\n    }\n    E(int _u=0,int _v=0,double _w=0)\n    {\n        u = _u;\n        v = _v;\n        w = _w;\n    }\n}edge[maxn];\n\nint x[maxn],y[maxn];\nint n,m;\ndouble Distance(int u,int v)\n{\n    return sqrt(1.0*(x[u]-x[v])*(x[u]-x[v]) + 1.0*(y[u]-y[v])*(y[u]-y[v]));\n}\nint fa[maxn];\nint Find(int x)\n{\n    if(fa[x]!=x) fa[x] = Find(fa[x]);\n    return fa[x];\n}\ndouble kruscal()\n{\n    for(int i=1;i<=n;i++)\n        fa[i] = i;\n    double mst=0;\n    for(int i=1;i<=m;i++)\n    {\n        int u=Find(edge[i].u),v=Find(edge[i].v);\n        if(u==v) continue;\n        fa[u] = v;\n        mst += edge[i].w;\n    }\n    return mst;\n}\nint main()\n{\n    while(~scanf(\"%d%d\",&n,&m))\n    {\n        for(int i=1;i<=n;i++)\n        scanf(\"%d%d\",&x[i],&y[i]);\n        double ans=0;\n        for(int i=1;i<=m;i++)\n        {\n            int u,v;\n            scanf(\"%d%d\",&u,&v);\n            double d = Distance(u,v);\n            edge[i] = E(u,v,d);\n            ans+=d;\n        }\n        sort(edge+1,edge+1+m);\n        ans-=kruscal();\n        printf(\"%.10f\\n\",ans);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <string.h>\n\nusing namespace std;\ndouble cost[10001][10001];\ndouble mincost[10001];\nbool used[10001];\nconst double INF=100000000;\nint x[10001],y[10001];\n\ndouble prim(int V){\n  for(int i=1; i<=V; ++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n\n  mincost[1]=0;\n  double res=0;\n\n while(true){\n  int v = -1;\n  for(int u=1; u<=V; u++){\n    if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n  }\n\n  if(v==-1) break;\n  used[v]=true;\n  res+=mincost[v];\n\n  for(int u=1; u<=V; u++){\n    mincost[u]=min(mincost[u],cost[v][u]);\n  }\n }\n return res;\n}\n\nint main(){\n\n   int N,M; cin>>N>>M;\n\n   fill(cost[0],cost[10001],0);\n\n   for(int i=1; i<=N; i++){\n\n     cin>>x[i]>>y[i];\n\n     }\n\n    double mx=0;\n\n   for(int i=0; i<M; i++){\n\n     int a,b; cin>>a>>b;\n\n     int u = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n     cost[a][b]=-sqrt(u);\n     int v = (x[b]-x[a])*(x[b]-x[a])+(y[b]-y[a])*(y[b]-y[a]);\n     cost[b][a]=-sqrt(v);\n\n     mx+=-cost[a][b];\n\n     }\n\n     cout<<mx+prim(N)<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <algorithm>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> P;\nP p[10010];\nint done[10010];\nint main(){\n\tint N,M;\n\tcin >> N >> M;\n\tpriority_queue< pair<double,int> > Q;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tp[i] = P(a,b);\n\t}\n\tvector<int> e[10010];\n\tdouble sum = 0;\n\tfor(int i = 0 ; i < M ; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\ta--,b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t\t\n\t\tsum += abs(p[a]-p[b]);\n\t}\n\tfor(int s = 0 ; s < N ; s++){\n\t\tif( done[s] ) continue;\n\t\tQ.push(make_pair(0,s));\n\t\twhile(Q.size()){\n\t\t\tpair<double,int> q = Q.top(); Q.pop();\n\t\t\tif( done[q.second]++ ){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tsum -= q.first;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < e[q.second].size() ; i++)\n\t\t\t\tQ.push(make_pair(abs(p[q.second]-p[e[q.second][i]]),e[q.second][i]));\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",sum);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nvector<pair<int, double>>X[120];\nint N, M, a, b; double x[120], y[120], d[120]; int g[120];\nint main() {\n\tcin >> N >> M; double S = 0;\n\tfor (int i = 1; i <= N; i++)cin >> x[i] >> y[i];\n\tfor (int i = 1; i <= M; i++) {\n\t\tcin >> a >> b;\n\t\tdouble c = pow((x[a] - x[b]), 2) + pow(y[a] - y[b], 2);\n\t\tc = sqrt(c); X[a].push_back(make_pair(b, c)); S += c;\n\t\tX[b].push_back(make_pair(a, c));\n\t}\n\tfor (int t = 1; t <= N; t++) {\n\t\tif (g[t] >= 2)continue;\n\t\td[t] = 0; g[t] = 1;\n\t\twhile (true) {\n\t\t\tint OK = 1;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1)OK = 0;\n\t\t\t}\n\t\t\tif (OK == 1)break;\n\t\t\tdouble maxn = -1; int maxid = 0;\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tif (g[i] == 1 && maxn < d[i]) {\n\t\t\t\t\tmaxn = d[i]; maxid = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tg[maxid] = 2;\n\t\t\tfor (int i = 0; i < X[maxid].size(); i++) {\n\t\t\t\tint to = X[maxid][i].first; double dist = X[maxid][i].second;\n\t\t\t\tif (g[to] <= 1 && d[to] < dist) {\n\t\t\t\t\td[to] = dist; g[to] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tdouble sum = 0;\n\tfor (int i = 2; i <= N; i++) {\n\t\tsum += d[i];\n\t}\n\tprintf(\"%.50f\", S - sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int& x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int& x,int& y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct Edge {\n\tint to;\n\tdouble cost;\n};\nbool operator <(const Edge& n1, const Edge& n2) {\n\treturn n1.cost < n2.cost;\n}\nbool operator >(const Edge& n1, const Edge& n2) {\n\treturn n2 < n1;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tvector<P> piles(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tpiles[i] = P(x, y);\n\t}\n\n\tvector< vector<Edge> > edges(N);\n\tfor (int i = 0; i < M; ++i) {\n\t\tint p, q; cin >> p >> q; --p, --q;\n\t\tdouble c = abs(piles[p]-piles[q]);\n\t\tedges[p].push_back( (Edge){q, c} );\n\t\tedges[q].push_back( (Edge){p, c} );\n\t}\n\n\tdouble ans = 0;\n\tvector<bool> isMerged(N, false);\n\tfor (int i = 0; i < N; ++i) {\n\t\tpriority_queue<Edge> Q; Q.push( (Edge){i, 0} );\n\t\twhile ( !Q.empty() ) {\n\t\t\tEdge edge = Q.top(); Q.pop();\n\t\t\tint n = edge.to;\n\t\t\tdouble cost = edge.cost;\n\n\t\t\tif (isMerged[n]) continue;\n\t\t\tisMerged[n] = true;\n\t\t\tans += cost;\n\n\t\t\tfor (int i = 0; i < edges[n].size(); ++i) {\n\t\t\t\tQ.push(edges[n][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble sum = 0;\n\tfor (int i = 0; i < edges.size(); ++i) {\n\t\tfor (int j = 0; j < edges[i].size(); ++j) {\n\t\t\tsum += edges[i][j].cost;\n\t\t}\n\t}\n\tans = sum/2 - ans;\n\n\tprintf(\"%.10f\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  int forest[N][N], i, j, k, t1, t2;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    for(j = 0; j < N; j++)\n      if(j == 0)\n\tforest[i][j] = i + 1;\n      else\n\tforest[i][j] = 0;\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++) {\n      k = 0;\n      while(forest[j][k] != 0 || k >= M) {\n\tif(links[i].node1 == forest[j][k])\n\t  t1 = j;\n\telse if(links[i].node2 == forest[j][k])\n\t  t2 = j;\n\tk++;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      for(j = 0; j < N; j++)\n\tif(forest[t1][j] == 0 || j >= M - 1)\n\t  break;\n      k = 0;\n      while(forest[t2][k] != 0 || k >= M) {\n\tswap(forest[t1][j], forest[t2][k]);\n\tj++;\n\tk++;\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "//?????§??????????£???????????????¶?????????????????¨?????§??¨????£???§???????????¨????????????.\n//?????????????????°??????????????¢??°????????????????????????????????????#N - #E + #F = 2, #F <= #N - 1 (????§???¢??????????????´???????????§)\n//??????, #E = #2N - 3????????????. ?????£???, M ??? 2 * N - 3??¨??????, ???????????????????????¨???????????£??????\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct Edge {\n\tint src, dst;\n\tdouble cost;\n\tEdge() {\n\t}\n\tEdge(int s, int d, double c) {\n\t\tsrc = s; dst = d; cost = c;\n\t}\n\tbool operator>(const Edge &r) const {\n\t\treturn cost > r.cost;\n\t}\n};\n\nclass UF {\n\tint par[10000];\npublic:\n\tUF() { for (int i = 0; i < 10000; i++) par[i] = i; }\n\tint root(int x) { if (par[x] == x) return x; return par[x] = root(par[x]); }\n\tvoid marge(int x, int y) { x = root(x); y = root(y); par[x] = y; }\n\tbool isSame(int x, int y) { return root(x) == root(y); }\n};\n\nint n, m;\nint x[10000], y[10000];\nvector<Edge> edges;\nUF uf;\n\nint main() {\n\tint i;\n\t\n\tcin >> n >> m;\n\tfor (i = 0; i < n; i++) cin >> x[i] >> y[i];\n\t\n\tdouble sumCost = 0;\n\tfor (i = 0; i < m; i++) {\n\t\tint p, q;\n\t\tdouble c;\n\t\tcin >> p >> q; p--; q--;\n\t\tc = (x[p] - x[q]) * (x[p] - x[q]) + (y[p] - y[q]) * (y[p] - y[q]);\n\t\tc = sqrt(c);\n\t\tedges.push_back(Edge(p, q, c));\n\t\tsumCost += c;\n\t}\n\tsort(edges.begin(), edges.end(), greater<Edge>());\n\t\n\tdouble treeCost = 0;\n\tfor (i = 0; i < edges.size(); i++) {\n\t\tint s = edges[i].src;\n\t\tint d = edges[i].dst;\n\t\tif (!uf.isSame(s, d)) {\n\t\t\tuf.marge(s, d);\n\t\t\ttreeCost += edges[i].cost;\n\t\t}\n\t}\n\t\n\tprintf(\"%.14f\\n\", sumCost - treeCost);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct edge{\n\tint from;\n\tint to;\n\tdouble cost;\n\tedge(){}\n\tedge(int f, int t, double c){\n\t\tfrom = f;\n\t\tto = t;\n\t\tcost = c;\n\t}\n};\n\nbool comp(const edge &a, const edge &b){\n\treturn a.cost > b.cost;\n}\n\nconst int MAX_N = 10000;\n\n//input\nint N, M;\nint X[MAX_N], Y[MAX_N];\nvector<edge> v;\n\n//kruskal\nint par[MAX_N];\nint rank[MAX_N];\n\ndouble compute(double x1, double y1, double x2, double y2){\n\t//compute the cost\n\treturn sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nvoid init(){\n\tmemset(par, -1, sizeof(par));\n\tmemset(rank, 0, sizeof(rank));\n}\n\nint find(int x){\n\tif(par[x] == -1)return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x] ++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\ndouble kruskal(){\n\tsort(v.begin(), v.end(), comp);\n\tinit();\n\tdouble ans = 0;\n\tfor(int i = 0; i < v.size(); i ++){\n\t\tif(!same(v[i].from, v[i].to)){\n\t\t\tunite(v[i].from, v[i].to);\n\t\t\tans += v[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tdouble ans = 0;\n\tfor(int i = 0; i < v.size(); i ++){\n\t\tans += v[i].cost;\n\t}\n\tans -= kruskal();\n\tprintf(\"%.3lf\\n\", ans);\n}\n\nint main(int argc, char const *argv[]){\n\n\tscanf(\"%d %d\", &N, &M);\n\tfor(int i = 0; i < N; i ++)\n\t\tscanf(\"%d %d\", &X[i], &Y[i]);\n\tfor(int i = 0; i < M; i ++){\n\t\tint f, t;\n\t\tscanf(\"%d %d\", &f, &t);\n\t\tf --, t--;\n\t\tv.push_back(edge(f, t, compute(X[f], Y[f], X[t], Y[t])));\n\t}\n\tsolve();\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i=(int)(a); i<(int)(b); ++i)\n#define REP(i, n) for(int i=0; i<(int)(n); ++i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n// 素集合データ構造\nstruct UnionFind\n{\n  // par[i]：データiが属する木の親の番号。i == par[i]のとき、データiは木の根ノードである\n  vector<int> par;\n  // sizes[i]：根ノードiの木に含まれるデータの数。iが根ノードでない場合は無意味な値となる\n  vector<int> sizes;\n\n  UnionFind(int n) : par(n), sizes(n, 1) {\n    // 最初は全てのデータiがグループiに存在するものとして初期化\n    REP(i, n) par[i] = i;\n  }\n\n  // データxが属する木の根を得る\n  int find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);  // 根を張り替えながら再帰的に根ノードを探す\n  }\n\n  // 2つのデータx, yが属する木をマージする\n  void unite(int x, int y) {\n    // データの根ノードを得る\n    x = find(x);\n    y = find(y);\n\n    // 既に同じ木に属しているならマージしない\n    if (x == y) return;\n\n    // xの木がyの木より大きくなるようにする\n    if (sizes[x] < sizes[y]) swap(x, y);\n\n    // xがyの親になるように連結する\n    par[y] = x;\n    sizes[x] += sizes[y];\n    // sizes[y] = 0;  // sizes[y]は無意味な値となるので0を入れておいてもよい\n  }\n\n  // 2つのデータx, yが属する木が同じならtrueを返す\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  // データxが含まれる木の大きさを返す\n  int size(int x) {\n    return sizes[find(x)];\n  }\n};\n\n// 頂点a, bをつなぐコストcostの（無向）辺\nstruct Edge\n{\n  int a, b;\n  double cost;\n\n  // コストの大小で順序定義\n  bool operator<(const Edge& o) const {\n    return cost < o.cost;\n  }\n};\n\n// 頂点数と辺集合の組として定義したグラフ\nstruct Graph\n{\n  int n;  // 頂点数\n  vector<Edge> es;  // 辺集合\n  double sum;\n\n  // クラスカル法で無向最小全域木のコストの和を計算する\n  // グラフが非連結のときは最小全域森のコストの和となる\n  double kruskal() {\n    // コストが小さい順にソート\n    sort(es.rbegin(), es.rend());\n\n    UnionFind uf(n);\n    double min_cost = 0;\n\n    REP(ei, es.size()) {\n      Edge& e = es[ei];\n      if (!uf.same(e.a, e.b)) {\n        // 辺を追加しても閉路ができないなら、その辺を採用する\n        min_cost += e.cost;\n        uf.unite(e.a, e.b);\n      }\n    }\n\n    return min_cost;\n  }\n};\n\n// 標準入力からグラフを読み込む\nGraph input_graph() {\n  Graph g;\n  int n, m;\n  cin >> n >> m;\n  g.n = n;\n  vi x(n), y(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n  }\n  REP(i, m) {\n    Edge e;\n    cin >> e.a >> e.b;\n    e.a--;\n    e.b--;\n    e.cost = hypot(x[e.a] - x[e.b], y[e.a] - y[e.b]);\n    g.sum += e.cost;\n    g.es.push_back(e);\n  }\n  return g;\n}\n\nint main(){\n  Graph g = input_graph();\n  printf(\"%.3lf\\n\", g.sum - g.kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <math.h>\n\nusing namespace std;\n\nconst int MAX_N = 10000;\n\ntypedef struct {\n    int x, y;\n} Pile;\n\ntypedef struct {\n    int a, b;\n    double cost;\n} Edge;\n\nbool operator < (const Edge& l, const Edge& r){\n    return l.cost < r.cost;\n}\n\nint _par[MAX_N];\nint _rank[MAX_N];\n\nvoid init(int n){\n    for(int i=0; i<n; i++){\n        _par[i] = i;\n        _rank[i] = 0;\n    }\n}\n\nint root(int x){\n    if(x == _par[x])\n        return x;\n    return _par[x] = root(_par[x]);\n}\n\nvoid unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    \n    if(_rank[x] < _rank[y]){\n        _par[x] = y;\n    }else{\n        _par[y] = x;\n        if(_rank[x] == _rank[y])\n            _rank[x]++;\n    }\n}\n\nbool is_same_group(int x, int y){\n    return root(x) == root(y);\n}\n\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Pile> piles(n);\n    for(int i=0; i<n; i++){\n        Pile & pile = piles[i];\n        cin >> pile.x >> pile.y;\n    }\n    \n    priority_queue<Edge> edges;\n    for(int i=0; i<m; i++){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        \n        double cost = sqrt((piles[a].x-piles[b].x)*(piles[a].x-piles[b].x) + (piles[a].y-piles[b].y)*(piles[a].y-piles[b].y));\n        \n        Edge edge;\n        edge.a = a; edge.b = b; edge.cost = cost;\n        \n        edges.push(edge);\n    }\n    \n    double ans = 0;\n    \n    init(n);\n    while(!edges.empty()){\n        Edge edge = edges.top(); edges.pop();\n        \n        if(is_same_group(edge.a, edge.b)){\n            ans += edge.cost;\n        }else{\n            unite(edge.a, edge.b);\n        }\n    }\n    \n    printf(\"%l.3f\\n\", ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef pair <int, double> Edge;\ntypedef vector <Edge> Graph;\ntypedef pair <double, int> Node;\ntypedef priority_queue <Node, vector<Node>, greater<Node> > Queue;\nconst int size = 10001;\nPoint P[size];\nbool used[size];\nGraph G[size];\n\ndouble solve( int s ) {\n    double answer = 0.0;\n    Queue Q;\n    Node start( 0.0, s );\n    Q.push( start );\n\n    while ( ! Q.empty() ) {\n        Node node = Q.top();\n        Q.pop();\n\n        double c = node.first;\n        int t = node.second;\n        \n        if ( used[t] ) continue;\n        used[t] = true;\n        answer += c;\n\n        for ( Graph::iterator it_i = G[t].begin();\n              it_i != G[t].end(); ++ it_i ) {\n            Edge e = *it_i;\n            double nc = e.second;\n            int nt = e.first;\n            Node next( nc, nt );\n            Q.push( next );\n        }\n    }\n\n    return answer;\n}\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n        for ( int i = 0; i < n; ++ i ) {\n            used[i] = false;\n            G[i].clear();\n        }\n        \n        for ( int i = 0; i < n; ++ i ) {\n            int x, y;\n            cin >> x >> y;\n            P[i] = Point( x, y );\n        }\n        \n        double sum1 = 0.0;\n        for ( int i = 0; i < m; ++ i ) {\n            int p, q;\n            cin >> p >> q;\n            p --;\n            q --;\n            double d = abs( P[p] - P[q] );\n            G[p].push_back( Edge( q, d * -1 ) );\n            G[q].push_back( Edge( p, d * -1 ) );\n            sum1 += d;\n        }\n        \n        double sum2 = 0.0;\n        for ( int i = 0; i < n; ++ i ) {\n            if ( used[i] ) continue;\n            sum2 += solve( i );\n        }\n\n        cout << sum1 + sum2 << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nÁ·Ï°Ìâ£ºSave your cats_AOJ 2224 \n\t¼õÈ¥×îÉÙ¡¢Ð¡µÄ±ß£¬Ê¹µÃÕû¸öÆ½ÃæÁ¬Í¨£»\n\t¼´ÎªÇó×î´óÉú³ÉÊ÷ÎÊÌâ£¬µ«×¢ÒâÇóµÄÊÇ²ÃÈ¥µÄÂ·¾¶¡£ \n*/\n\n#include <cstdio>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_E=10007, MAX_V=10007;\nint mark[MAX_E];\npair<int, int> ver[MAX_V];\n\nstruct edge{\n\tint u, v, cost;\n}; \nbool cmp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost<e2.cost;\n}\n\nedge es[MAX_E];\nint V, E;\n\n\n//DUS start line\n\nint par[MAX_V];//¸¸Ç× \nint hight[MAX_V];//Ê÷µÄ¸ß¶È\n\n//³õÊ¼»¯n¸öÔªËØ\nvoid init(int n)\n{\n\tfor(int i=0; i<n; i++)\n\t{\n\t\tpar[i]=i;\n\t\thight[i]=0;\n\t}\n}\n\n//²éÑ¯Ê÷µÄ¸ù\nint find(int x)\n{\n\tif(par[x]==x)\n\t\treturn x;\n\telse\n\t\treturn par[x]=find(par[x]);\n}\n\n//ºÏ²¢xºÍyËùÊôµÄ¼¯ºÏ\nvoid unite(int x, int y)\n{\n\tx=find(x);\n\ty=find(y);\n\tif(x==y)\n\t\treturn ;\n\tif(hight[x]<hight[y])\n\t\tpar[x]=y;\n\telse\n\t{\n\t\tpar[y]=x;\n\t\tif(hight[x]==hight[y])\n\t\t\thight[x]++;\n\t}\n}\n\n//ÅÐ¶ÏxºÍyÊÇ·ñÊôÓÚÍ¬Ò»¸ö¼¯ºÏ\nbool same(int x, int y)\n{\n\treturn find(x)==find(y);\n}\n\n//DUS end line \n\n\ndouble kruskal()\n{\n\tsort(es, es+E, cmp);\n\t\n\tinit(V);\n\t\n\n\tdouble res=0;\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tedge e=es[i];\n\t\tif(!same(e.u, e.v))\n\t\t{\n\t\t\tunite(e.u, e.v);\n\t\t\tmark[i]=1;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tif(mark[i]==0)\n\t\t\tres+=sqrt(-es[i].cost);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d%d\", &V, &E);\n\tfor(int i=0;  i<V; i++)\n\t{\n\t\tscanf(\"%d%d\", &ver[i].first, &ver[i].second);\n\t}\n\tfor(int i=0; i<E; i++)\n\t{\n\t\tedge ed;\n\t\tscanf(\"%d%d\", &ed.u, &ed.v);\n\t\ted.u--;\n\t\ted.v--;\n\t\ted.cost=-((ver[ed.u].first-ver[ed.v].first)*(ver[ed.u].first-ver[ed.v].first)+(ver[ed.u].second-ver[ed.v].second)*(ver[ed.u].second-ver[ed.v].second));\n\t\tes[i]=ed;\n\t}\n\t\n\tdouble ans=kruskal();\n\tprintf(\"%.3lf\\n\", ans);\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint n,m;\nstruct node{\n\tint x,y;\n\tdouble d;\n\tbool operator <(node a)const{\n\t\treturn d>a.d;\n\t}\n}edge[50000005];\nint fa[10005];\nint p[10006][2];\nint find_father(int x){\n\tif(x==fa[x])\n\t\treturn x;\n\treturn fa[x]=find_father(fa[x]);\n}\ndouble dis(int x1,int y1,int x2,int y2){\n\treturn sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n}\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d\",&p[i][0],&p[i][1]);\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tdouble c=dis(p[a][0],p[a][1],p[b][0],p[b][1]);\n\t\tedge[i].x=a,edge[i].y=b,edge[i].d=c;\n\t}\n\tsort(edge+1,edge+m+1);\n\tdouble ans=0;\n\tfor(int i=1;i<=n;i++)\n\t\tfa[i]=i;\n\tfor(int i=1;i<=m;i++){\n\t\tint f1=find_father(edge[i].x),f2=find_father(edge[i].y);\n\t\tif(f1==f2)\n\t\t\tans+=edge[i].d;\n\t\telse\n\t\t\tfa[f1]=f2;\n\t}\n\tprintf(\"%.3lf\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\nstruct edge{\n\tint from;\n\tint to;\n\tdouble cost;\n};\n\nint a[10000], rank[10000];\n\nvoid init(){\n\tfor(int i = 0;i < 10000;i++){\n\t\ta[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(a[x] == x)\n\t\treturn x;\n\telse\n\t\treturn find(a[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(rank[x] < rank[y])\n\t\ta[x] = y;\n\telse{\n\t\ta[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\ndouble dist(int x1,int y1,int x2,int y2){\n\treturn sqrt((double)((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)));\n}\n\nint cmp(const void* a,const void* b){\n\tstruct edge *ea = (struct edge *)a;\n\tstruct edge *eb = (struct edge *)b;\n\tif(eb->cost - ea->cost > 0)\n\t\treturn 1;\n\telse if(eb->cost - ea->cost < 0)\n\t\treturn -1;\n\telse\n\t\treturn 0;\n}\n\nint main(void){\n\tint n, m, x[10000], y[10000], p, q, i, j, c;\n\tdouble s;\n\tedge e[1000000];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\ts = 0;\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d\",&p,&q);\n\t\te[i].from = p - 1,e[i].to = q - 1;\n\t\ts += e[i].cost = dist(x[p - 1],y[p - 1],x[q - 1],y[q - 1]);\n\t}\n\tqsort(e,m + 1,sizeof(e[0]),cmp);\n\tfor(i = 0;i < m;i++)\n\t\tprintf(\"%d:%f\\n\",i + 1,e[i].cost);\n\tc = 0;\n\tinit();\n\tfor(i = 0;i < n;i++)\n\t\tif(i == a[i]) c++;\n\tfor(i = 0;i < m && c != 1;i++){\n\t\tif(find(e[i].from) != find(e[i].to)){\n\t\t\tunite(e[i].from,e[i].to);\n\t\t\ts -= e[i].cost;\n\t\t}\n\t\tc = 0;\n\t\tfor(j = 0;j < n;j++)\n\t\t\tif(j == a[j]) c++;\n\t}\n\tprintf(\"%.3f\\n\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nint par[10000],size[10000];\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i;\n        size[i] = 1;\n    }\n}\nint find(int x) {\n    if (x == par[x]) return x;\n    return find(par[x]);\n}\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return;\n    if (size[x] >= size[y]) {\n        par[y] = x;\n        size[x] += size[y];\n    } else {\n        par[x] = y;\n        size[y] += size[x];\n    }\n}\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\nstruct edge {\n    int u, v;\n    double cost;\n    edge() {}\n    edge(int uu, int vv, double cc) : u(uu), v(vv), cost(cc) {}\n    bool operator<(const edge &e) {\n        return cost > e.cost;\n    };\n};\n\nconst int INF = 100000;\nint N, M;\nint x[10000], y[10000];\ndouble sum;\n//頂点10000で交差がないからせいぜい10倍だろうという見通し\nedge G[100000];\n//初めからクラスカルで書くべきだった\n\ndouble dist(int x, int y) {\n    return sqrt(x * x + y * y);\n}\n\nvoid kruskal() {\n    //プリム法の実行　全体コストから最大全域木を作ってそのコストを引く\n    //mincostとしてしまったが実体はmaxcost\n    sort(G,G+M);\n    init(N);\n    double res = 0;\n    for (int i = 0; i < M; i++) {\n        edge e = G[i];\n        if (!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    printf(\"%.3lf\\n\", sum-res);\n}\n\nint main() {\n    cin >> N >> M;\n    for (int i = 0; i < N; i++) {\n        cin >> x[i] >> y[i];\n\n    }\n    int p, q;\n    \n    for (int i = 0; i < M; i++) {\n        cin >> p >> q;\n        p--; q--;\n        double d = dist(x[p]-x[q], y[p]-y[q]);\n        G[i] = edge(p,q,d);\n        sum += d;\n    }\n\n    //辺を保持→クラスカル\n    kruskal();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define db double\n#define N 15010\nusing namespace std;\nint fa[N];\nint x[N],y[N];\ndb dis(int a,int b){\n  return sqrt((x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]));\n}\nstruct ee{int u,v;db k;}e[N];\nint n,m;\nint find(int x){if(fa[x]!=x)x=find(fa[x]);return fa[x];}\nbool comp(const ee & a,const ee & b){return a.k>b.k;}\ndb sum=0.0;\nint main(){\nscanf(\"%d%d\",&n,&m);\nfor(int i=1;i<=n;++i)scanf(\"%d%d\",&x[i],&y[i]),fa[i]=i;\nfor(int i=1;i<=m;++i){int u,v;scanf(\"%d%d\",&u,&v);e[i]=(ee){u,v,dis(u,v)};\nsum+=dis(u,v);\n}\nsort(e+1,e+m+1,comp);int cnt(0);db Ans=0.0;\nfor(int i=1;i<=m;++i){\nint u=e[i].u,v=e[i].v;u=find(u),v=find(v);\nif(v!=u)Ans+=e[i].k,fa[u]=v,cnt++;\nif(cnt==n-1)break;\n}printf(\"%.3lf\",sum-Ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst double INF = 0;\n\ndouble cost[MAX_V][MAX_V];\ndouble mincost[MAX_V];\nbool used[MAX_V];\nint V;\npair<int, int> data[MAX_V];\n\ndouble dist(pair<int, int> a, pair<int, int> b){\n  return sqrt((a.first-b.first)*(a.first-b.first) + (a.second-b.second)*(a.second-b.second));\n}\n\ndouble prim(){\n  for(int i=0;i<V;++i){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  double res = 0;\n  \n  for(;;){\n    int v = -1;\n    for(int u=0;u<V;++u){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u=0;u<V;++u){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && n|m){\n    fill(cost[0], cost[n], INF);\n    for(int i=0;i<n;++i){\n      cin >> data[i].first >> data[i].second;\n    }\n    double sum = 0.0;\n    for(int i=0;i<m;++i){\n      int a, b;\n      double tmp;\n      cin >> a >> b;\n      --a;\n      --b;\n      tmp = dist(data[a], data[b]);\n      sum += tmp;\n      cost[a][b] = cost[b][a] = -tmp;\n    }\n    V = n;\n    printf(\"%.3f\\n\", sum + prim());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(ll i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct UnionFind{\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unionSet(int x,int y){\n        x=root(x);y=root(y);\n        if(x==y)return 0;\n        if(data[y]<data[x])swap(x,y);\n        data[x]+=data[y],data[y]=x;\n        return 1;\n    }\n    bool findSet(int x,int y){\n        return root(x)==root(y);\n    }\n    int root(int x){\n        return data[x]<0 ? x : data[x]=root(data[x]);\n    }\n    int size(int x){\n        return -data[root(x)];\n    }\n};\nclass KRK{//c++11\n\tpublic:\n\tstruct edge{\n\t\tint from,to;\n\t\tdouble cost;\n\t};\n\tvector<edge>G;\n\tint n;\n\tKRK(int size){\n\t\tn=size;\n\t}\n\tvoid add_edge(int a,int b,double c){\n\t\tedge e={a,b,c};\n\t\tG.pb(e);\n\t}\n\tdouble krk(){\n\t\tdouble sum=0;\n\t\tsort(all(G),[](edge a,edge b){\n\t\t\treturn a.cost>b.cost;\n\t\t});\n\t\tUnionFind uf(n);\n\t\trep(i,G.size()){\n\t\t\tedge e=G[i];\n\t\t\tif(!uf.findSet(e.from,e.to)){\n\t\t\t\tsum+=e.cost;\n\t\t\t\tuf.unionSet(e.from,e.to);\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n};\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tKRK krk(n);\n\tvi x(n),y(n);\n\trep(i,n)cin>>x[i]>>y[i];\n\tdouble sum=0;\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tdouble cost=hypot(x[a]-x[b],y[a]-y[b]);\n\t\tsum+=cost;\n\t\tkrk.add_edge(a,b,cost);\n\t}\n\tcout<<shosu(9)<<sum-krk.krk()<<endl;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    UnionFind(int n) : par(n), sz(n, 1) {\n        for (int i = 0; i < n; ++i) par[i] = i;\n    }\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n    void merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n        if (sz[x] < sz[y]) swap(x, y);\n        par[y] = x;\n        sz[x] += sz[y];\n        sz[y] = 0;\n    }\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n};\n\n\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    // edge(int src, int to, T cost): src(src), to(to), cost(cost) {}\n    // // G[i].push_back({src, to, cost}) requires no constructor\n};\n\ntemplate<typename T>\nT kruskal(vector<edge<T>> &es, int V) {\n\n    UnionFind uf(V);\n    T ret = 0;\n\n    // sort destructively\n    sort(es.begin(), es.end(), [](edge<T> &a,edge<T> &b){\n            return a.cost < b.cost;\n            });\n    for (auto &e : es) {\n        if (!uf.issame(e.src, e.to)) {\n            ret += e.cost;\n            uf.merge(e.src, e.to);\n        }\n    }\n\n    // // sort only the order to check\n    // vector<int> ord(es.size());\n    // iota(ord.begin(), ord.end(), 0);\n    // sort(ord.begin(), ord.end(), [&](int i,int j){\n    //         return es[i].cost < es[j].cost;\n    //         });\n    // for (auto i : ord) {\n    //     auto &e = es[i];\n    //     if (!uf.issame(e.src, e.to)) {\n    //         ret += e.cost;\n    //         uf.merge(e.src, e.to);\n    //     }\n    // }\n\n    return ret;\n}\n\ndouble d(double x1, double y1, double x2, double y2) {\n  return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int n, m; cin >> n >> m;\n  vector<double> x(n), y(n);\n  \n  for(int i=0;i<n;++i) {\n    cin >> x[i] >> y[i];\n  }\n\n  vector<edge<double>> v;\n  double su = 0;\n  for(int i=0;i<m;++i) {\n    int p, q; cin >> p >> q;\n    p--; q--;\n    v.push_back(edge<double>({p, q, -d(x[p], y[p], x[q], y[q])}));\n    v.push_back(edge<double>({q, p, -d(x[p], y[p], x[q], y[q])}));\n    su += d(x[p], y[p], x[q], y[q]);\n  }\n\n  double ans = kruskal(v, n);\n\n  cout << su + ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n#define INF 100000000000000000\n#define MAX_N 500000\npriority_queue<pair<long double, long long>, vector<pair<long double, long long>>, less<pair<long double, long long>>>Q;\nvector<pair<long long, long double>>X[MAX_N]; long long WHITE = 0, GRAY = 1, BLACK = 2;\nlong long COLOR[MAX_N], DIST[MAX_N], POINT[MAX_N], N, M, A, B;long double C, X1[MAX_N], Y1[MAX_N];\nlong long classcal() {\n\tfor (int i = 0; i < MAX_N; i++) { POINT[i] = INF; DIST[i] = 0; COLOR[i] = WHITE; }\n\tDIST[1] = 0; COLOR[1] = GRAY; Q.push(make_pair(0, 1));\n\twhile (!Q.empty()) {\n\t\tpair<long double, long long>pa = Q.top(); Q.pop();\n\t\tlong double a1 = pa.first;long long a2 = pa.second;\n\t\tCOLOR[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first; long double dist = X[a2][i].second;\n\t\t\tif (DIST[to] < dist && COLOR[to] < BLACK) {\n\t\t\t\tfor (int j = 0; j < X[to].size(); j++) {\n\t\t\t\t\tif (X[to][j].first == a2) { POINT[to] = j; }\n\t\t\t\t}\n\t\t\t\tDIST[to] = dist; Q.push(make_pair(DIST[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong double sum = 0;\n\tfor (int i = 1; i <= N; i++) { if (POINT[i] < INF) { sum += X[i][POINT[i]].second; } }\n\treturn sum;\n}\nint main() {\n\tcin >> N >> M; long double S = 0;\n\tfor (int i = 0; i < N; i++) { cin >> X1[i] >> Y1[i]; }\n\tfor (int i = 0; i < M; i++) { cin >> A >> B; C = sqrt(pow(X1[A] - X1[B], 2) + pow(Y1[A] - Y1[B], 2)); S += C; X[A].push_back(make_pair(B, C)); X[B].push_back(make_pair(A, C)); }\n\tcout << S - classcal() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <map>\n#include <string.h>\n\nusing namespace std;\nbool cost[10001][10001];\ndouble mincost[10001];\nbool used[10001];\nconst double INF=100000000;\nint x[10001],y[10001];\n\ndouble prim(int V){\n  for(int i=1; i<=V; ++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n\n  mincost[1]=0;\n  double res=0;\n\n while(true){\n  int v = -1;\n  for(int u=1; u<=V; u++){\n    if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n  }\n\n  if(v==-1) break;\n  used[v]=true;\n  res+=mincost[v];\n\n  for(int u=1; u<=V; u++){\n    int p = (x[v]-x[u])*(x[v]-x[u])+(y[v]-y[u])*(y[v]-y[u]);\n    if(cost[v][u]) mincost[u]=min(mincost[u],-sqrt(p));\n    else mincost[u]=min(mincost[u],0.0);\n  }\n }\n return res;\n}\n\nint main(){\n\n   int N,M; cin>>N>>M;\n\n   for(int i=1; i<=N; i++){\n\n     cin>>x[i]>>y[i];\n\n     }\n\n    double mx=0;\n\n   for(int i=0; i<M; i++){\n\n     int a,b; cin>>a>>b;\n\n     cost[a][b]=true;\n     cost[b][a]=true;\n\n     int p = (x[a]-x[b])*(x[a]-x[b])+(y[a]-y[b])*(y[a]-y[b]);\n     mx+=sqrt(p);\n\n     }\n\n     printf(\"%.8f\\n\",mx+prim(N));\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n\nint n,m;\ndouble xs[10005];\ndouble ys[10005];\n\ntypedef pair<double,mp> dmp;\n\nvector<dmp> es;\n\ndouble dist(int a,int b){\n\tdouble x = xs[a]-xs[b],y=ys[a]-ys[b];\n\t//printf(\"%lf %lfs %lf %lf\\n\",xs[a],xs[b],x,y);\n\treturn sqrt(x*x+y*y);\n}\n\nint uni[10005];\n\nvoid init(){\n\trep(i,10005){\n\t\tuni[i]=i;\n\t}\n}\n\nint find(int q){\n\tif(uni[q]==q)return uni[q];\n\treturn (uni[q]=find(uni[q]));\n}\n\nvoid mer(int p,int q){\n\tuni[find(p)]=find(q);\n}\n\nbool same(int p,int q){\n\treturn (find(p)==find(q));\n}\n\n\nint main(void){\n\tinit();\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n){\n\t\tscanf(\"%lf%lf\",&xs[i],&ys[i]);\n\t}\n\tdouble sw = 0;\n\trep(i,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b); a--; b--;\n\t\tdouble d = dist(a,b);\n\t\tsw+=d;\n\t\t//printf(\"%d %d %lf \",a,b,d);\n\t\tes.push_back(dmp(-d,mp(a,b)));\n\t}\n\t\n\tsort(es.begin(),es.end());\n\t\n\tdouble ans = sw;\n\trep(i,m){\n\t\tdmp pa = es[i];\n\t\tdouble d = pa.fir;\n\t\tint a = pa.sec.fir,\n\t\t\tb = pa.sec.sec;\n\t\tif(same(a,b))continue;\n\t\tans+=d;\n\t\tmer(a,b);\n\t}\n\t\n\tprintf(\"%f\\n\",ans);\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <math.h>\nusing namespace std;\n\nint N, M;\n\nstruct Node {\n  int x;\n  int y;\n};\n\nstruct Link {\n  int node1;\n  int node2;\n  double len;\n};\n\nbool compare(const Link& left, const Link& right);\n\nint main(void) {\n  cin >> N >> M;\n  vector<int> array[N];\n  int forest[N][N], i, j, k, t1, t2, s, t;\n  double ans = 0.0;\n  struct Node nodes[N];\n  struct Link links[M];\n\n  for(i = 0; i < N; i++)\n    array[i].push_back(i + 1);\n\n  for(i = 0; i < N; i++)\n    cin >> nodes[i].x >> nodes[i].y;\n  for(i = 0; i < M; i++) {\n    cin >> links[i].node1 >> links[i].node2;\n    links[i].len = sqrt(pow(nodes[links[i].node1 - 1].x - nodes[links[i].node2 - 1].x, 2.0) + pow(nodes[links[i].node1 - 1].y - nodes[links[i].node2 - 1].y, 2.0));\n  }\n\n  sort(links, links + M, compare);\n\n  for(i = 0; i < M; i++) {\n    for(j = 0; j < N; j++){\n      for(k = 0; k < array[j].size(); k++) {\n\tif(links[i].node1 == array[j].at(k))\n\t  t1 = j;\n\telse if(links[i].node2 == array[j].at(k))\n\t  t2 = j;\n      }\n    }\n    if(t1 == t2)\n      ans += links[i].len;\n    else {\n      if(t1 > t2)\n\tswap(t1, t2);\n      while(!array[t2].empty()) {\n\tarray[t1].push_back(array[t2].back());\n\tarray[t2].pop_back();\n      }\n    }\n  }\n\n  printf(\"%.3f\", ans);\n\n  return 0;\n}\n\nbool compare(const Link& left, const Link& right) {\n        return left.len > right.len;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct edge{\n\tint u, v;\n\tdouble dis;\n};\nbool operator<(const edge& left, const edge& right){\n\treturn left.dis > right.dis;\n}\n\nstruct uf{\n\tint par, rank;\n};\n\nvector<pair<double, double>> pails;\nvector<edge> ve;\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tpails.resize(n);\n\tve.resize(m);\n\tREP(i, n){\n\t\tcin >> pails[i].first >> pails[i].second;\n\t}\n\tREP(i, m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tve[i].u = u - 1;\n\t\tve[i].v = v - 1;\n\t\tve[i].dis = hypot(pails[ve[i].u].first - pails[ve[i].v].first, pails[ve[i].u].second - pails[ve[i].v].second);\n\t}\n\tSORT(ve);\n\tdouble ans = 0.0;\n\tvector<uf> U(n);\n\tREP(i, n){\n\t\tU[i].par = i;\n\t\tU[i].rank = 0;\n\t}\n\tREP(i, m){\n\t\tint u = ve[i].u, v = ve[i].v;\n\t\twhile (u != U[u].par){\n\t\t\tu = U[u].par;\n\t\t}\n\t\twhile (v != U[v].par){\n\t\t\tv = U[v].par;\n\t\t}\n\t\tif (u == v){\n\t\t\tans += ve[i].dis;\n\t\t}\n\t\telse{\n\t\t\tif (U[u].rank > U[v].rank){\n\t\t\t\tU[v].par = u;\n\t\t\t}\n\t\t\telse if (U[u].rank < U[v].rank){\n\t\t\t\tU[u].par = v;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tU[u].par = v;\n\t\t\t\tU[v].rank++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%.3lf\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<stdio.h>\n#include<cmath>\nusing namespace std;\ntypedef long long int ll;\nint const MAX=10005;\nint const MAXM=100000005;\nint par[MAX];\nint rankn[MAX];\nstruct Dian\n{\n    int x;int y;\n};\nstruct Edge\n{\n    int u,v;\n    double cost;\n}edge[MAXM];\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        rankn[i]=0;\n    }\n}\nint findn(int x){\n    if(par[x]==x)return x;\n    else {return par[x]=findn(par[x]);}\n}\nvoid unite(int x,int y)\n{\n    x=findn(x);\n    y=findn(y);\n    if(x==y)return;\n    if(rankn[x]<rankn[y]){\n        par[x]=y;\n    }\n    else{\n        par[y]=x;\n        if(rankn[x]==rankn[y])rankn[x]++;\n    }\n}\nbool same(int x,int y)\n{\n    return findn(x)==findn(y);\n}\nint N,M;\nDian dian[MAX];\ndouble dis(int a,int b)\n{\n    double l;\n    l=sqrt((dian[a].x-dian[b].x)*(dian[a].x-dian[b].x)+(dian[a].y-dian[b].y)*(dian[a].y-dian[b].y));\n    return l;\n}\nbool comp(const Edge e1,const Edge e2)\n{\n    return e1.cost<e2.cost;\n}\nint main()\n{\n    while(cin>>N>>M){\n    int a,b,c;\n    double sum=0;\n    for(int i=0;i<N;i++){\n        cin>>a>>b;\n        dian[i].x=a;\n        dian[i].y=b;\n    }\n    for(int i=0;i<M;i++){\n        cin>>a>>b;\n        a--;\n        b--;\n        edge[i].u=a;\n        edge[i].v=b;\n        edge[i].cost=-dis(a,b);\n        sum+=dis(a,b);\n        //cout<<\"!!!\"<<dis(a,b)<<endl;\n    }\n    sort(edge,edge+M,comp);\n    init(N);\n    double res=0;\n    for(int i=0;i<M;i++){\n        Edge e=edge[i];//cout<<e.v<<\" \"<<e.u<<\" \";\n            //cout<<findn(e.u)<<\"!!!! \"<<findn(e.v)<<endl;\n        if(!same(e.u,e.v)){\n            unite(e.u,e.v);\n            res+=e.cost;\n\n            //cout<<\"###\"<<e.cost<<endl;\n        }\n    }\n    //cout<<res;\n    //cout<<sum<<endl;\n    printf(\"%.3f\\n\",sum+res);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define INF 1e9\nusing namespace std;\ntypedef pair <double,int> P;\nvector <P> G[10001];\n\nint used[10001];\ndouble prim(int start){\n  double res=0;\n  priority_queue <P> Q;\n  Q.push(P(0,start));\n  while(!Q.empty()){\n    P t=Q.top();Q.pop();\n    double cost=t.f;\n    int pos=t.s;\n    if(used[pos])continue;\n    used[pos]=1;\n    res+=cost;\n    for(int i=0;i<G[pos].size();i++)Q.push(P(G[pos][i]));\n    }\n  return res;\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  complex <double>  p[10001];\n  for(int i=0,a,b;i<n;i++)cin>>a>>b,p[i].real()=a,p[i].imag()=b;\n\n  double sum=0;\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;\n    a--,b--;\n    G[a].push_back(P(abs(p[a]-p[b]),b));\n    G[b].push_back(P(abs(p[a]-p[b]),a));\n    sum+=abs(p[a]-p[b]);\n  }\n\n  double ans=0;\n  for(int i=0;i<n;i++) if(!used[i]) ans+=prim(i);\n  printf(\"%f\\n\",sum-ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll; \n#define PI 3.14159265\n\nstruct edge {\n\tint from, to;\n\tdouble cost;\n\tedge() {};\n\tedge(int a, int b, double c) {from=a, to=b, cost=c;}\n\n\tbool operator<(edge& rhs) {\n\t\treturn cost > rhs.cost;\n\t}\n};\nvector<edge> e;\n\nint x[10101];\nint y[10101];\nint n, m;\nint par[10101];\nint cnt[10101];\n\nvoid init(int n)\n{\n\trep(i,0,n) {\n\t\tpar[i] = i;\n\t\tcnt[i] = 1;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) \n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (cnt[x] > cnt[y]) swap(x,y);\n\tpar[x] = y;\n\tcnt[y] += cnt[x];\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\ndouble kruskal()\n{\n\tsort(all(e));\n\tinit(n);\n\tdouble ret = 0;\n\trep(i,0,len(e)) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tret += e[i].cost;\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tdouble sum = 0;\n\tcin >> n >> m;\n\trep(i,0,n) cin >> x[i] >> y[i];\n\trep(i,0,m) {\n\t\tint a,b; cin>>a>>b;\n\t\ta--; b--;\n\t\tif (a>b) swap(a,b);\n\t\tdouble c = sqrt(abs(x[a]-x[b])*abs(x[a]-x[b]) + abs(y[a]-y[b])*abs(y[a]-y[b]));\n\t\te.pb(edge(a,b,c));\n\t\t// printf(\"edge%d : a=%d b=%d c=%lf\\n\",i,a,b,c);\n\t\tsum += c;\n\t}\n\tdouble t = kruskal();\n\tprintf(\"%.12lf\\n\",sum-t);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 10005\n\ntypedef struct {\n\tdouble x, y;\n} point;\n\ntypedef struct {\n\tint from, to;\n\tdouble cost;\n} edge;\n\ntypedef pair<double, int> PDI;\n\npoint p[N];\nvector<edge> G[N];\n\ndouble d[N];\nbool used[N];\n\nint n, m;\ndouble ans;\n\ndouble calc_length(point& p1, point& p2){\n\treturn sqrt((p1.x - p2.x) * (p1.x - p2.x) + \n\t\t\t(p1.y - p2.y) * (p1.y - p2.y));\n} \n\ndouble prim(int x){\n\tfill(d, d + N, 0);\n\n\tpriority_queue<PDI, vector<PDI>, greater<PDI> > que;\n\td[x] = 0.0;\n\tdouble rst = 0.0;\n\tque.push(PDI(0.0, x));\n\twhile (!que.empty()){\n\t\tPDI p = que.top();\n\t\tque.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) continue;\n\t\trst += d[v];\n\t\tused[v] = true;\n\t\tfor (int u = 0; u < G[v].size(); u++){\n\t\t\tedge& e = G[v][u];\n\t\t\tif (!used[e.to] && d[e.to] > e.cost){\n\t\t\t\td[e.to] = e.cost;\n\t\t\t\tque.push(PDI(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn rst;\n}\n\nvoid init(){\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\t}\n\tint from , to;\n\tdouble cost;\n\tans = 0.0;\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d\", &from, &to);\t\n\t\t--from, --to;\n\t\tcost = calc_length(p[from], p[to]);\n\t\tedge e1, e2;\n\t\te1.from = from, e1.to = to, e1.cost = -cost;\n\t\te2.from = to, e2.to = from, e2.cost = -cost;\n\t\tG[from].push_back(e1);\n\t\tG[to].push_back(e2);\n\t\tans += cost;\n\t}\n}\n\nint main(){\n\t\n\tscanf(\"%d %d\", &n, &m);\n\tinit();\n\tfill(used, used + N, false);\n\tfor (int i = 0; i < n; i++){\n\t\tif (!used[i]) ans += prim(i);\n\t}\n\tprintf(\"%.3lf\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <stack>\n#include <queue>\n#include <list>\n#include <bitset>\nusing namespace std;\ntypedef long long ll;\nconst int INF = int(0x7fffffff / 2);\nconst int maxn = 10010;\n\nclass Edge {\npublic:\n\tint from, to;\n\tdouble weight;\n\tEdge(int f, int t, double w):from(f), to(t), weight(w) {}\n\tEdge(){}\n\tbool operator < (const Edge& e) const {\n\t\treturn weight < e.weight;\n\t}\n};\n\nint N, M;\npair<int, int> loc[maxn];\nint parent[maxn];\n\nint getParent(int i) {\n\tif (i == parent[i])\n\t\treturn i;\n\telse {\n\t\tint tmp = parent[i];\n\t\tparent[i] = getParent(parent[i]);\n\t}\n\treturn parent[i];\n}\nvoid merge(int i, int j) {\n\tint fi = getParent(i);\n\tint fj = getParent(j);\n\tif (fi != fj) {\n\t\tparent[fi] = fj;\n\t}\n}\nvoid init() {\n\tfor (int i = 1; i <= N; ++i) {\n\t\tparent[i] = i;\n\t}\n}\nbool isBrother(int i, int j) {\n\treturn getParent(i) == getParent(j);\n}\ndouble distance(int a, int b) {\n\tdouble re = (loc[a].first - loc[b].first) * (loc[a].first - loc[b].first)\n\t\t+ (loc[a].second - loc[b].second) * (loc[a].second - loc[b].second);\n\treturn sqrt(re);\n}\n\nint main() {\n////////////////////////////////////////////////////////////////////\n\tios::sync_with_stdio(false); // 给 cin cout加速\n\tcin.tie(0);\n\t////////////////////////////////////////////////////////////////////////////\n\twhile (scanf(\"%d%d\", &N, &M) != EOF) {\n\t\tinit();\n\t\tfor (int i = 1; i <= N; ++i)\n\t\t\tscanf(\"%d%d\", &loc[i].first, &loc[i].second);\n\t\tpriority_queue<Edge> edges;\n\t\tint a, b;\n\t\tdouble cost = 0;\n\t\tfor (int i = 1; i <= M; ++i) {\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tdouble weight = distance(a, b);\n\t\t\t//cout << weight << endl;\n\t\t\tcost += weight;\n\t\t\tedges.push(Edge(a, b, weight));\n\t\t}\n\n\t\tdouble result = 0;\n\t\tint cnt = 0;\n\t\twhile (!edges.empty() && cnt < N-1) {\n\t\t\tEdge tmp = edges.top();\n\t\t\tedges.pop();\n\t\t\tif (!isBrother(tmp.from, tmp.to)) {\n\t\t\t\tresult += tmp.weight;\n\t\t\t\tmerge(tmp.from, tmp.to);\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.3lf\\n\", cost - result);\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n\n    vector<int> par;     //par[i] := iの親の番号\n\n    //最初は全てが寝であるとして初期化\n    UnionFind(int n) : par(n){\n        for(int i = 0; i < n; i++) par[i] = i;\n    }\n\n    //データ x が属する木の根を再帰で得る : root(x) = {x の木の根}\n    int root(int x){\n        if(par[x] == x) return x;\n        return root(par[x]);\n    }\n\n    //x と y の木を併合\n    void unite(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return;\n        par[rx] = ry;\n    }\n\n    //x と y のが属する木が同じか\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n};\n\nstruct info{\n    int s, t;\n    double w;\n    info(){}\n    info(int s, int t, double w):s(s),t(t),w(w){}\n    bool operator<(const info &a) const{\n        return w > a.w;\n    }\n    bool operator>(const info &a) const{\n        return w < a.w;\n    }\n};\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<vector<pair<int, double> > > adj(n);\n    vector<double> x(n);\n    vector<double> y(n);\n    for(int i = 0; i < n; i++) cin >> x[i] >> y[i];\n\n    UnionFind unionfind(n);\n    vector<info> edge;\n\n\n    for(int i = 0; i < m; i++){\n        int a, b; cin >> a >> b;\n        a--;\n        b--;\n        edge.push_back(info(a, b, sqrt((x[a] - x[b]) * (x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]))));      \n    }\n\n    sort(edge.begin(), edge.end());\n\n    double ans = 0.0;\n    for(auto x : edge){\n\n        //cout << x.w << endl;\n\n        if(!unionfind.same(x.s, x.t)){\n            unionfind.unite(x.s, x.t);\n        }else{\n            ans += x.w;\n        }\n    }\n\n    printf(\"%.10f\\n\", ans);\n    //cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<complex>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<set>\n#include<vector>\n#define maxm 10010\nusing namespace std;\nstruct data{\n  int x,y;double w;\n}e[maxm];\ndouble ans=0.0,X[maxm],Y[maxm];\nint fa[maxm];\nint find(int x){if(fa[x]!=x) fa[x]=find(fa[x]);return fa[x];}\ninline double getdis(int x,int y){return sqrt((X[x]-X[y])*(X[x]-X[y])+(Y[x]-Y[y])*(Y[x]-Y[y]));}\ninline bool cmp(const data &A,const data &B){\n  return A.w>B.w;\n}\nint main(){\n  int n,m,x,y;\n  scanf(\"%d%d\",&n,&m);\n  for(int i=1;i<=n;i++)\n    scanf(\"%lf%lf\",&X[i],&Y[i]),fa[i]=i;\n  for(int i=1;i<=m;i++)\n    scanf(\"%d%d\",&x,&y),e[i]=(data){x,y,getdis(x,y)},ans+=getdis(x,y);\n  sort(e+1,e+m+1,cmp);\n  for(int i=1;i<=m;i++){\n    int u=find(e[i].x),v=find(e[i].y);\n    if(u!=v) ans-=e[i].w,fa[u]=v;\n  }\n  printf(\"%.3lf\",ans);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ntypedef complex<double> P;\n\nstruct Edge {\n  int to;\n  double cost;\n  Edge() {}\n  Edge(int to, double cost) : to(to), cost(cost) {}\n};\n\nconst int MAX_N = 10005;\nint N;\nP Ps[MAX_N];\nvector<Edge> E[MAX_N];\ndouble allEdge;\n\nvoid init() {\n  for(int i = 0; i < MAX_N; ++i)\n    E[i].clear();\n  allEdge = 0.0;\n}\n\nvoid addEdge(int p, int q) {\n  double cost = abs(Ps[p]-Ps[q]);\n  E[p].push_back(Edge(q,cost));\n  E[q].push_back(Edge(p,cost));\n  allEdge += cost;\n}\n\ndouble solve() {\n  priority_queue<pair<double,int> > que;\n  bool vis[MAX_N];\n  double sum = 0.0;\n  fill(vis, vis+N, false);\n  que.push(make_pair(0.0, 0));\n  while(!que.empty()) {\n    pair<double,int> p = que.top();\n    que.pop();\n    if(vis[p.second]) continue;\n    vis[p.second] = true;\n    sum += p.first;\n    for(int i = 0; i < E[p.second].size(); ++i) {\n      Edge& e = E[p.second][i];\n      if(vis[e.to]) continue;\n      que.push(make_pair(e.cost, e.to));\n    }\n  }\n  return allEdge - sum;\n}\n\nint main() {\n  init();\n  int m;\n  cin >> N >> m;\n  for(int i = 0; i < N; ++i)\n    cin >> Ps[i].real() >> Ps[i].imag();\n  for(int i = 0; i < m; ++i) {\n    int p, q;\n    cin >> p >> q;\n    --p; --q;\n    addEdge(p,q);\n  }\n  printf(\"%.3f\\n\", solve());\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstdlib>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\n#define X real()\n#define Y imag()\n#define fi first\n#define se second\ntypedef complex<double> PT;\ntypedef pair<int,int> pii;\n\nstruct UnionFind {\n\tvector<int> uf;\n\tvector<int> rk;\n\tint sz;\n\n\tUnionFind(int n) {\n\t\tsz = n;\n\t\tuf.resize(n);\n\t\trk.resize(n);\n\t\tthis->init();\n\t}\n\n\tvoid init() {\n\t\trep(i,sz) {\n\t\t\tuf[i] = i;\n\t\t\trk[i] = 0;\n\t\t}\n\t}\n\n\tint find(int a) {\n\t\treturn uf[a] == a ? a : (uf[a] = this->find(uf[a]));\n\t}\n\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\tvoid merge(int a, int b) {\n\t\tint aa, bb;\n\t\taa = find(a);\n\t\tbb = find(b);\n\t\tif(aa == bb) return;\n\t\tif(rk[aa] > rk[bb]) {\n\t\t\tuf[bb] = aa;\n\t\t}\n\t\telse {\n\t\t\tif(rk[aa] == rk[bb]) rk[bb]++;\n\t\t\tuf[aa] = bb;\n\t\t}\n\t}\n};\n\nint N, M;\nvector<PT> P;\nvector<pair<double,pii> > E;\n\nint main() {\n\tcin >> N >> M;\n\tfor(int i = 0; i < N; i++) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tP.push_back(PT(x,y));\n\t}\n\tfor(int i = 0; i < M; i++) {\n\t\tint p, q;\n\t\tcin >> p >> q;\n\t\tp--; q--;\n\t\tE.push_back(make_pair(abs(P[p] - P[q]),pii(p,q)));\n\t}\n\tsort(E.rbegin(), E.rend());\n\tUnionFind uf(N);\n\tdouble res = 0;\n\tfor(int i = 0; i < E.size(); i++) {\n\t\tint p, q;\n\t\tp = E[i].se.fi;\n\t\tq = E[i].se.se;\n\t\tif(uf.same(p,q)) {\n\t\t\tres += E[i].fi;\n\t\t}\n\t\telse {\n\t\t\tuf.merge(p,q);\n\t\t}\n\t}\n\tcout << setprecision(10) << fixed << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <math.h>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 100000000;\ntypedef double D;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\ntypedef pair<int, int> P;\n\n/** Problem2224 : Save your cat **/\n\nstruct Edge {\n\tint from, to;\n\tdouble cost;\n\tEdge(int from_, int to_, double cost_) : from(from_), to(to_), cost(cost_){}\n\tbool operator <(const Edge &rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int v) : data(v, -1) {}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x: (data[x] = root(data[x]));\n\t}\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tvoid merge(int x, int y) {\n\t\tx = root(x), y = root(y);\n\t\tif (x != y) {\n\t\t\tif (size(y) > size(x)) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n};\n\ndouble kruskal(const int v, vector<Edge> es) {\n\tsort(es.begin(), es.end());\n\tdouble ans = 0;\n\tUnionFind uf(v);\n\tfor (int i=0; i<es.size(); i++) {\n\t\tif (uf.same(es[i].from, es[i].to)) continue;\n\t\tuf.merge(es[i].from, es[i].to);\n\t\tans += es[i].cost;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint N, M;\n\t\n\tcin>>N>>M;\n\n\t\n\tvector<double> x(N), y(N);\n\tvector<Edge> e;\n\tdouble sum=0;\n\t\n\trep(i, N) {\n\t\tcin>>x[i]>>y[i];\n\t}\n\trep(i, M) {\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\tdouble d = sqrt((x[a-1]-x[b-1])*(x[a-1]-x[b-1]) + (y[a-1]-y[b-1])*(y[a-1]-y[b-1]));\n\t\te.push_back(Edge(a-1, b-1, d));\n\t\tsum += d;\n\t}\n\t\n\tprintf(\"%.3f\\n\", sum - kruskal(N, e));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define fi first\n#define se second\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int,int>P;\nconst int MAXN=100010;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nP p[MAXN];\ndouble Dis(P &a, P &b){\n\treturn sqrt((a.fi - b.fi) * (a.fi - b.fi) + (a.se - b.se) * (a.se - b.se));\n}\nstruct node{\n\tint u,v;\n\tdouble w;\n\tnode(int _u = 0, int _v = 0, double _w = 0) : u(_u), v(_v), w(_w){}\n\tbool operator < (node a) const{\n\t\treturn w > a.w;\n\t}\n}mp[MAXN];\nint f[MAXN];\nint getf(int k){\n\treturn k == f[k] ? k : f[k] = getf(f[k]);\n}\ndouble kruskal(int n, int m){\n\tint i = 0, cnt = 1;\n\tdouble sum = 0;\n\twhile(i < m && cnt < n){\n\t\tint u = getf(mp[i].u);\n\t\tint v = getf(mp[i].v);\n\t\tif(u != v){\n\t\t\tf[u] = v;\n\t\t\tcnt++;\n\t\t\tsum += mp[i].w;\n\t\t}\n\t\ti++;\n\t}\n\treturn sum;\n}\nint main(){\n\tint n, m, u, v;\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; ++i){\n\t\tscanf(\"%d %d\", &p[i].fi, &p[i].se);\n\t\tf[i] = i;\n\t}\n\tdouble sum = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tscanf(\"%d %d\", &u, &v);\n\t\tmp[i] = node(u, v, Dis(p[u], p[v]));\n\t\tsum += Dis(p[u], p[v]);\n\t}\n\tsort(mp, mp + m);\n\tcout << fixed << setprecision(3) << sum - kruskal(n, m) << endl;\n \treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n#define MAXN 10005\n#define MAXM 1000005\nint n,m;\nstruct Edge\n{\n\tint id;\n\tdouble val;\n\tEdge *nxt;\n\tEdge(){nxt=NULL;}\n\tEdge(int i,double v){id=i;val=v;nxt=NULL;}\n}E[MAXM],*V[MAXN],*cur;\nvoid add_edge(int x,int y,double val)\n{\n\t*cur=Edge(y,val);\n\tcur->nxt=V[x];\n\tV[x]=cur++;\n\t*cur=Edge(x,val);\n\tcur->nxt=V[y];\n\tV[y]=cur++;\n}\nstruct cmp\n{\n\tbool operator () (Edge *a,Edge *b)\n\t{return a->val<b->val;}\n};\nbool used[MAXN];\ndouble Prim(int s)\n{\n\tdouble ans=0;\n\tpriority_queue<Edge*,vector<Edge*>,cmp>Q;\n\tused[s]=1;\n\tfor(Edge *p=V[s];p;p=p->nxt)\n\t\tif(!used[p->id])\n\t\t\tQ.push(p);\n\twhile(!Q.empty())\n\t{\n\t\tEdge *t=Q.top();\n\t\tQ.pop();\n\t\tif(used[t->id])\n\t\t\tcontinue;\n\t\tans+=t->val;\n\t\tused[t->id]=1;\n\t\tfor(Edge *p=V[t->id];p;p=p->nxt)\n\t\t\tif(!used[p->id])\n\t\t\t\tQ.push(p);\n\t}\n\treturn ans;\n}\npair<int,int>pile[MAXN];\ndouble dis(int a,int b)\n{\n\treturn sqrt((pile[a].first-pile[b].first)*(pile[a].first-pile[b].first)+\n\t(pile[a].second-pile[b].second)*(pile[a].second-pile[b].second));\n}\nint main()\n{\n\tint N,M;\n\tscanf(\"%d%d\",&N,&M);\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\tcur=E;\n\tdouble sum=0;\n\tfor(int j=1,p,q;j<=M;j++)\n\t{\n\t\tscanf(\"%d%d\",&p,&q);\n\t\tdouble tmp=dis(p,q);\n\t\tadd_edge(p,q,tmp);\n\t\tsum+=tmp;\n\t}\n\tfor(int i=1;i<=N;i++)\n\t\tif(!used[i])\n\t\t\tsum-=Prim(i);\n\tprintf(\"%.3lf\\n\",sum);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#define MAX 10005\n#define MAXE MAX * (MAX - 1) / 2 + 1\n\nstruct edge { int u , v; double cost; };\nstruct node { double x , y; };\nbool comp(const edge& e1 , const edge& e2){\n    return e1.cost > e2.cost;\n}\n\nint V , E;\nint par[MAX], rank[MAX];\nnode node[MAX];\nedge es[MAXE];\n\nvoid init(int n){\n    for(int i = 0; i <= n; i++){\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }else{\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]){ \n        par[x] = y;\n    }else{\n        par[y] = x;\n        if(rank[x] == rank[y]) rank[x]++;\n    }\n}\n\ndouble kruskal(){\n    std::sort(es , es + E , comp);\n    init(V);\n    double res = 0;\n    for(int i = 0;i < E;i++){\n        edge e = es[i];\n        if(find(e.u) != find(e.v)){\n            unite(e.u , e.v);\n        }else{\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    std::cin >> V >> E;\n    for(int i = 1;i <= V;i++){\n        std::cin >> node[i].x >> node[i].y;\n    }\n    for(int i = 0;i < E;i++){\n        std::cin >> es[i].u >> es[i].v;\n        es[i].cost = std::sqrt(std::pow((node[es[i].u].x - node[es[i].v].x) , 2) + std::pow((node[es[i].u].y - node[es[i].v].y) , 2));\n    }\n    std::cout << kruskal() << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint from, to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\ntypedef complex<double> Point;\nstruct union_find\n{\n\tvector<int> par;\n\tunion_find(int n) :par(n, -1) {}\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x); y = find(y);\n\t\tif (x == y) return;\n\t\tif (par[y] < par[x]) swap(x, y);\n\t\tif (par[x] == par[y]) par[x]--;\n\t\tpar[y] = x;\n\t\tif (find(x) != find(y)) par[find(y)] = x;\n\t}\n\tint count()\n\t{\n\t\tint cnt = 0;\n\t\tREP(i, par.size()) if (par[i] < 0) cnt++;\n\t\treturn cnt;\n\t}\n\n\tbool same(int x, int y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n};\n\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<Point> ps(n);\n\tREP(i, n)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[i] = Point(x, y);\n\t}\n\tvector<edge> es;\n\tdouble ans = 0;\n\tREP(i, m)\n\t{\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tdouble d = abs(ps[a] - ps[b]);\n\t\tans += d;\n\t\tes.push_back(edge{ a, b, d });\n\t}\n\tsort(rbegin(es), rend(es));\n\tunion_find uf(n);\n\tREP(i, es.size())\n\t{\n\t\tif (uf.same(es[i].from, es[i].to)) continue;\n\t\tans -= es[i].cost;\n\t\tuf.unite(es[i].from, es[i].to);\n\t}\n\tcout << D10 << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <string.h>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#define N 100005\n#define P pair<int,int>\n#define ll long long\n#define mk(a, b) make_pair(a, b)\n#define mem(a, b) memset(a, b, sizeof(a))\nusing namespace std;\nint inf = 0x3f3f3f3f;\nint n, m, pre[N];\nstruct ac{\n\tint v;\n\tdouble c;\n};\nvoid init() {\n\tfor (int i = 1; i <N; ++i) {\n\t\tpre[i] = i;\n\t}\n}\nint find(int x) {\n\tif (x == pre[x])\treturn x;\n\telse \treturn pre[x] = find(pre[x]);\n}\nvoid join(int x, int y) {\n\tint fx = find(x);\n\tint fy = find(y);\n\tif (fx == fy)\treturn;\n\telse if (fx < fy)\tpre[fy] = fx;\n\telse \tpre[fx] = fy;\n}\ndouble sum;\nbool vis[N];\ndouble dis[N];\nvector<P> a(N);\nvector<ac> g[N];\nvoid prime(int x) {\n\tmem(dis, 0);\n\tmem(vis, false);\n\tdis[x] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tdouble MAX = 0;\n\t\tint u = -1;\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif (vis[j])\tcontinue;\n\t\t\tif (dis[j] > MAX) {\n\t\t\t\tMAX = dis[j];\n\t\t\t\tu = j;\n\t\t\t}\n\t\t}\n\t\tif (u == -1)\treturn;\n\t\tvis[u] = true;\n\t\tif (u == x)\tMAX = 0;\n\t\tsum += MAX;\n\t\t// cout << \"u = \" << u << \" \" << MAX << endl;\n\t\tfor (int j = 0; j < g[u].size(); ++j) {\n\t\t\tac t = g[u][j];\n\t\t\tif (vis[t.v])\tcontinue;\n\t\t\tif (dis[t.v] < t.c ) {\n\t\t\t\tdis[t.v] = t.c;\n\t\t\t}\n\t\t}\n\t}\n\n\n\n}\n\nint main(){\n// #ifndef ONLINE_JUDGE\n//     freopen(\"in.txt\", \"r\", stdin);\n// #endif\n\tios::sync_with_stdio(false);\n\twhile (cin >> n >> m) {\n\t\tinit();\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tcin >> a[i].first >> a[i].second;\n\t\t}\n\t\tdouble ans = 0;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u, v;\n\t\t\tcin >> u >> v;\n\t\t\tint dx = a[u].first - a[v].first;\n\t\t\tint dy = a[u].second - a[v].second;\n\t\t\tdouble temp = sqrt(dx * dx + dy * dy);\n\t\t\t// cout << \"temp = \" << temp << endl;\n\t\t\tans += temp;\n\t\t\tg[u].push_back((ac){v, temp});\n\t\t\tg[v].push_back((ac){u, temp});\n\t\t\tjoin(u, v);\n\t\t}\n\t\t// cout << ans << endl;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif (pre[i] == i) {\n\t\t\t\tsum = 0;\n\t\t\t\tprime(i);\n\t\t\t\tans -= sum;\n\t\t\t\t// cout << i << \"::\" << sum << endl;\n\t\t\t}\n\t\t}\n\t\t// ans += 1;\n\t\tcout << ans << endl;\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define db double\n#define ll long long\n#define RG register\n\ninline int gi()\n{\n\tRG int ret; RG bool flag; RG char ch;\n\tret=0, flag=true, ch=getchar();\n\twhile (ch < '0' || ch > '9')\n\t\tch == '-' ? flag=false : 0, ch=getchar();\n\twhile (ch >= '0' && ch <= '9')\n\t\tret=(ret<<3)+(ret<<1)+ch-'0', ch=getchar();\n\treturn flag ? ret : -ret;\n}\n\nconst db pi = acos(-1.0);\nconst int N = 142857, inf = 1<<30;\n\nstruct poi\n{\n\tint x,y;\n}p[N];\nstruct edge\n{\n\tint fr,to;\n\tdb dis;\n\tinline bool operator <(const edge &E) const { return dis > E.dis; }\n}e[N*10];\nint fa[N];\n\ninline db Dis(int a,int b)\n{\n\treturn sqrt((p[a].x-p[b].x)*(p[a].x-p[b].x)+(p[a].y-p[b].y)*(p[a].y-p[b].y));\n}\n\ninline int find(int o)\n{\n\treturn fa[o] == o ? o : fa[o]=find(fa[o]);\n}\n\nint main()\n{\n\tint n,m,i,x,y;\n\tdb ans,len;\n\tn=gi(), m=gi();\n\tfor (i=1; i<=n; ++i)\n\t\tp[i].x=gi(), p[i].y=gi();\n\tans=0;\n\tfor (i=1; i<=m; ++i)\n\t\te[i].fr=x=gi(), e[i].to=y=gi(), e[i].dis=len=Dis(x,y), ans+=len;\n\tsort(e+1,e+m+1);\n\tfor (i=1; i<=n; ++i)\n\t\tfa[i]=i;\n\tfor (i=1; n>1 && i<=m; ++i)\n\t\t{\n\t\t\tx=e[i].fr, y=e[i].to;\n\t\t\tx=find(x), y=find(y);\n\t\t\tif (x != y)\n\t\t\t\tans-=e[i].dis, fa[x]=y, n--;\n\t\t}\n\tprintf(\"%.3f\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<double,int> id;\nint n,m;\ndouble ans;\nP a[10000];\nvector<int> G[10000];\nbool used[10000];\n\ndouble getl(P a,P b){\n  return sqrt((a.f-b.f)*(a.f-b.f)+(a.s-b.s)*(a.s-b.s));\n}\n\nvoid prin(){\n  for(int i=0;i<n;i++){\n    if(used[i])continue;\n    priority_queue<id> q;\n    q.push(id(0,i));\n    while(!q.empty()){\n      id t=q.top();\n      q.pop();\n      if(used[t.s])continue;\n      used[t.s]=1;\n      ans-=t.f;\n      for(int j=0;j<G[t.s].size();j++)\n\tq.push(id(getl(a[t.s],a[G[t.s][j]]),G[t.s][j]));\n    }   \n  }\n  printf(\"%f\\n\",ans);\n}\n\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++)\n    cin>>a[i].f>>a[i].s;\n  for(int i=0,p,q;i<m;i++){\n    cin>>p>>q;\n    p--,q--;\n    G[p].push_back(q);\n    G[q].push_back(p);\n    ans+=getl(a[p],a[q]);\n  }\n  prin();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(const int& n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(const int& x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(const int& x,const int& y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint parent[maxn],height[maxn];\n\n// void init(const int& n){\n// \tfor(int i=0; i<n; i++){\n// \t\tpa[i] = i;\n// \t\tran[i] = 0;\n// \t}\n// }\n\n// int find(const int& x){\n// \tif(pa[x]==x) return x;\n// \telse pa[x] = find(pa[x]);\n// }\n\n// void unite(int x,int y){\n// \tx = find(x); y = find(y);\n\n// \tif(x==y) return ;\n// \tif(ran[x] < ran[y]){\n// \t\tpa[x] = y;\n// \t}else{\n// \t\tpa[y] = x;\n// \t\tif(ran[x] == ran[y])\n// \t\t\t++ran[x];\n// \t}\n// }\n\n// bool same(const int& x,const int& y){\n// \treturn find(x) == find(y);\n// }\nvoid init(const int& n)\n{\n\tfor (int i = 0; i < n; ++i)\n\t{\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n \nint find(const int& x)\n{\n\tif (parent[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn parent[x] = find(parent[x]);\n\t}\n}\n \nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t{\n\t\treturn;\n\t}\n \n\tif (height[x] < height[y])\n\t{\n\t\tparent[x] = y;\n\t}\n\telse\n\t{\n\t\tparent[y] = x;\n\t\tif (height[x] == height[y])\n\t\t{\n\t\t\t++height[x];\n\t\t}\n\t}\n}\n \nbool same(const int& x, const int& y)\n{\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<LL, LL> PLL;\ntypedef pair<LD, LD> PLDLD;\n\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define ALL(a) a.begin(),a.end()\n\n//const double eps=1e-5;\nconst long long INF=(LL)(1e9)*(LL)(1e9);\n\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n  return (abs(a - b) < eps);\n}\n\nnamespace std {\n  bool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.real() < rhs.real() - eps) return true;\n    if (lhs.real() > rhs.real() + eps) return false;\n    return lhs.imag() < rhs.imag();\n  }\n}\n\nPoint input_point() {\n  ld x, y;\n  cin >> x >> y;\n  return Point(x, y);\n}\n\nld dot(Point a, Point b) {\n  return real(conj(a) * b);\n}\n\nld cross(Point a, Point b) {\n  return imag(conj(a) * b);\n}\n\nclass Line {\npublic:\n  Point a, b;\n  Line () : a(Point(0, 0)), b(Point(0, 0)) {}\n  Line (Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle {\npublic:\n  Point p;\n  ld r;\n  Circle () : p(Point(0, 0)), r(0) {}\n  Circle (Point p, ld r) : p(p), r(r) {}\n};\n\nint ccw (Point a, Point b, Point c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;\n  if (cross(b, c) < -eps) return -1;\n  if (dot(b, c) < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isis_ll (Line l, Line m) {\n  return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls (Line l, Line s) {\n  return isis_ll(l, s) &&\n    (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp (Line l, Point p) {\n  return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp (Line s, Point p) {\n  return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj (Line l, Point p) {\n  ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll (Line s, Line t) {\n  Point sv = s.b - s.a, tv = t.b - t.a;\n  assert(cross(sv, tv) != 0);\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp (Line l, Point p) {\n  return abs(p - proj(l, p));\n}\n\nld dist_ll (Line l, Line m) {\n  return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls (Line l, Line s) {\n  return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp (Line s, Point p) {\n  Point r = proj(s, p);\n  return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss (Line s, Line t) {\n  if (isis_ss(s, t)) return 0;\n  return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc (Circle c1, Circle c2){\n  vector<Point> res;\n  ld d = abs(c1.p - c2.p);\n  ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n  ld dfr = c1.r * c1.r - rc * rc;\n  if (abs(dfr) < eps) dfr = 0.0;\n  else if (dfr < 0.0) return res;\n  ld rs = sqrt(dfr);\n  Point diff = (c2.p - c1.p) / d;\n  res.push_back(c1.p + diff * Point(rc, rs));\n  if (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n  return res;\n}\n\nvector<Point> is_lc (Circle c, Line l){\n  vector<Point> res;\n  ld d = dist_lp(l, c.p);\n  if (d < c.r + eps){\n    ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d);\n    Point nor = (l.a - l.b) / abs(l.a - l.b);\n    res.push_back(proj(l, c.p) + len * nor);\n    res.push_back(proj(l, c.p) - len * nor);\n  }\n  return res;\n}\n\nvector<Point> is_sc(Circle c, Line l){\n  vector<Point> v = is_lc(c, l), res;\n  for (Point p : v)\n    if (isis_sp(l, p)) res.push_back(p);\n  return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p) {\n  vector<Line> ret;\n  Point v = c.p - p;\n  ld d = abs(v);\n  ld l = sqrt(norm(v) - c.r * c.r);\n  if (isnan(l)) { return ret; }\n  Point v1 = v * Point(l / d,  c.r / d);\n  Point v2 = v * Point(l / d, -c.r / d);\n  ret.push_back(Line(p, p + v1));\n  if (l < eps) return ret;\n  ret.push_back(Line(p, p + v2));\n  return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n  vector<Line> ret;\n  if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n    Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n    ret = tangent_cp(c1, center);\n  }\n  if (abs(c1.r - c2.r) > eps) {\n    Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n    vector<Line> nret = tangent_cp(c1, out);\n    ret.insert(ret.end(), ALL(nret));\n  }\n  else {\n    Point v = c2.p - c1.p;\n    v /= abs(v);\n    Point q1 = c1.p + v * Point(0,  1) * c1.r;\n    Point q2 = c1.p + v * Point(0, -1) * c1.r;\n    ret.push_back(Line(q1, q1 + v));\n    ret.push_back(Line(q2, q2 + v));\n  }\n  return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nbool is_counter_clockwise (const Polygon &poly) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n], c = poly[(i+2)%n];\n    angle += arg((c - b) / (b - a));\n  }\n  return angle > eps;\n}\n\nint is_in_polygon (const Polygon &poly, Point p) {\n  ld angle = 0;\n  int n = poly.size();\n  REP(i,n) {\n    Point a = poly[i], b = poly[(i+1)%n];\n    if (isis_sp(Line(a, b), p)) return 1;\n    angle += arg((b - p) / (a - p));\n  }\n  return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps) {\n  int n = ps.size();\n  int k = 0;\n  sort(ps.begin(), ps.end());\n  Polygon ch(2 * n);\n  for (int i = 0; i < n; ch[k++] = ps[i++])\n    while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n    while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n  ch.resize(k - 1);\n  return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l) {\n  int n = ps.size();\n  Polygon Q;\n  REP(i,n) {\n    Point A = ps[i], B = ps[(i+1)%n];\n    Line m = Line(A, B);\n    if (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n    if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n      Q.push_back(is_ll(l, m));\n  }\n  return Q;\n}\n\nvoid add_point(vector<Point> &ps, Point p) {\n  for (Point q : ps) if (abs(q - p) < eps) return;\n  ps.push_back(p);\n}\n\ntypedef ld Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n  g[from].push_back((Edge){from, to, weight});\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n  int n = p.size(), m = s.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (isis_sp(s[i], p[j]))\n      vec.emplace_back(abs(s[i].a - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      add_edge(g, from, to, abs(p[from] - p[to]));\n    }\n  }\n  return g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n  int n = p.size(), m = c.size();\n  Graph g(n);\n  REP(i,m) {\n    vector<pair<ld,int>> vec;\n    REP(j,n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n      vec.emplace_back(arg(c[i].p - p[j]), j);\n    sort(ALL(vec));\n    REP(j,vec.size()-1) {\n      int from = vec[j].second, to = vec[j+1].second;\n      ld angle = vec[j+1].first - vec[j].first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n    if (vec.size() >= 2) {\n      int from = vec.back().second, to = vec.front().first;\n      ld angle = vec.front().first - vec.back().first;\n      add_edge(g, from, to, angle * c[i].r);\n    }\n  }\n  return g;\n}\n\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n  int N = p.size();\n  polygon.clear();\n  REP(i,1024) REP(j,1024) seg2p[i][j].clear();\n  vector<vector<tuple<ld,int,bool>>> tup(N);\n  REP(i,s.size()) {\n    int a = -1, b = -1;\n    REP(j,N) if (abs(s[i].a - p[j]) < eps) a = j;\n    REP(j,N) if (abs(s[i].b - p[j]) < eps) b = j;\n    assert(a >= 0 && b >= 0);\n    tup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n    tup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n  }\n  REP(i,N) sort(ALL(tup[i]));\n  REP(i,N) {\n    REP(j,tup[i].size()) {\n      ld angle; int pos = j, from = i, to; bool flag;\n      tie(angle, to, flag) = tup[i][j];\n      if (flag) continue;\n      vector<int> ps;\n      while (!flag) {\n        ps.push_back(from);\n        get<2>(tup[from][pos]) = true;\n        seg2p[from][to].push_back(polygon.size());\n        seg2p[to][from].push_back(polygon.size());\n        angle += pi + eps;\n        if (angle > pi) angle -= 2 * pi;\n        auto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n        if (it == tup[to].end()) it = tup[to].begin();\n        from = to; tie(angle, to, flag) = *it;\n        pos = it - tup[from].begin();\n      }\n      polygon.push_back(ps);\n    }\n  }\n  Graph g(polygon.size());\n  REP(i,N) REP(j,i) {\n    if (seg2p[i][j].size() == 2) {\n      int from = seg2p[i][j][0], to = seg2p[i][j][1];\n      g[from].push_back((Edge){from, to, abs(p[i]-p[j])});\n      g[to].push_back((Edge){to, from, abs(p[i]-p[j])});\n    }\n  }\n  return g;\n}\n\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n  Point v = l.b - l.a;\n  Line m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n  int n = p.size();\n  REP(i,n) draw_segment(Line(p[i], p[(i+1)%n]));\n}\n\nvoid draw_circle(Circle c) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nnamespace krus\n{\n\nstruct Edge{\n    int start,end;\n    ld dis;\n    bool operator >(const Edge &b)const{return dis > b.dis;}\n    };\n    const int V=100000;//The num of vertex.\n    int inf = INT_MAX/2;\n    priority_queue<Edge,vector<Edge> ,greater<Edge> > que;//Edges are stacked\n    vector<Edge> minTree;//the result will be push in \n    //int belong[V];\n    \n    void Kruskal(int n)\n    {\n        vector<int> belong(n);\n        REP(i,n)\n            belong[i]=i;\n        \n        Edge edge;\n        while(!que.empty())\n        {\n            edge=que.top();\n            if(belong[edge.start]!=belong[edge.end])\n            {\n                REP(i,n)\n                    if(belong[i]==belong[edge.end])\n                        belong[i]=belong[edge.start];\n                        \n                minTree.push_back(edge);\n            }\n            que.pop();\n        }\n    }\n}\n\nint main()\n{\n    //cin.tie(0);\n    //ios::sync_with_stdio(false);\n    int n,m;\n    cin>>n>>m;\n    vector<Point> p(n);\n    vector<Line> l(m);\n    REP(i,n)\n    {\n        int a,b;\n        cin>>a>>b;\n        p[i]=Point(a,b);\n    }\n    REP(i,m)\n    {\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        l[i]=Line(p[a],p[b]);\n    }\n    auto g=dual_graph(l,p);\n    for(auto es:g)\n    for(auto e:es)\n    krus::que.push(krus::Edge{e.from, e.to, e.weight});\n\n    krus::Kruskal(g.size());\n    ld ans=0;\n    for(auto e:krus::minTree)\n        ans+=e.dis;\n    \n        cout<<setprecision(10)<<fixed<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\ndouble maximum_spanning_tree(int n, vector< vector< pair<double,int> > > &G){\n  priority_queue< pair<double, int> > wait;\n  vector<bool> connected(n);\n  double ret = 0;\n  for(int i = 0; i < n; ++i){\n    wait.emplace(0,i);\n    while(!wait.empty()){\n      double cost = wait.top().first;\n      int v = wait.top().second;\n      wait.pop();\n      if(connected[v]) continue;\n      connected[v] = true;\n      ret += cost;\n      for(int i = 0; i < G[v].size(); ++i){\n        int t = G[v][i].second;\n        if(!connected[t]){\n          wait.push(G[v][i]);\n        }\n      }\n    }\n  }\n  return ret;\n}\n\ndouble dist(double x1, double y1, double x2, double y2){\n  return hypot((x1-x2),(y1-y2));\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  double X[N], Y[N];\n  for(int i = 0; i < N; ++i){\n    cin >> X[i] >> Y[i];\n  }\n\n  vector< vector< pair<double,int> > > G(N);\n  int p, q;\n  double s = 0;\n  for(int i = 0; i < M; ++i){\n    cin >> p >> q;\n    --p;\n    --q;\n    double d = dist(X[p],Y[p],X[q],Y[q]);\n    s += d;\n    G[p].emplace_back(d,q);\n    G[q].emplace_back(d,p);\n  }\n  printf(\"%.12f\\n\",s - maximum_spanning_tree(N,G));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\n#define maxn 10000+10\n#define maxe maxn*maxn/2+1\nint pa[maxn],ran[maxn];\n\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpa[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n\nint find(int& x){\n\tif(pa[x]==x) return x;\n\telse pa[x] = find(pa[x]);\n}\n\nvoid unite(int x,int y){\n\tx = find(x); y = find(y);\n\n\tif(x==y) return ;\n\tif(ran[x] < ran[y]){\n\t\tpa[x] = y;\n\t}else{\n\t\tpa[y] = x;\n\t\tif(ran[x] == ran[y])\n\t\t\t++ran[x];\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge{\n\tint u,v;\n\tdouble cost;\n\tedge(int u=0,int v=0,double cost=0) : u(u),v(v),cost(cost){}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost > rhs.cost;\n\t}\n};\nedge es[maxe];\nint V,E;\n\npair<int,int> pile[maxn];\n\ndouble kruskal(){\n\tsort(es,es+E);\n\tinit(V);\n\tdouble res = 0;\n\tfor(int i=0; i<E; i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v))\n\t\t\tunite(e.u,e.v);\n\t\telse\n\t\t\tres += e.cost;\n\t}\n\n\treturn res;\n}\n\n\nint main(){\n\tscanf(\"%d%d\",&V,&E);\n\tfor(int i=0; i<V; i++)\n\t\tscanf(\"%d%d\",&pile[i].first,&pile[i].second);\n\n\tfor(int i=0; i<E; i++){\n\t\tscanf(\"%d%d\",&es[i].u,&es[i].v);\n\t\t--es[i].u,--es[i].v;\n\t\tint dx = pile[es[i].u].first - pile[es[i].v].first;\n\t\tint dy = pile[es[i].u].second - pile[es[i].v].second;\n\t\tes[i].cost = sqrt(dx*dx+dy*dy);\t\n\t}\n\n\tprintf(\"%.3lf\\n\",kruskal());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\nstruct edge{\n    int u, v;\n    double w;\n    edge(){u=v=w=0;}\n    edge(int uu, int vv, double ww){\n        u=uu; v=vv; w=ww;\n    }\n    bool operator < (const edge& b) const {\n        return w>b.w;\n    }\n};\nstruct point{\n    int x, y;\n    point(){x=y=0;}\n    point(int xx, int yy){ x=xx; y=yy;}\n};\n\nconst int MAX_N=10001;\nconst int MAX_M=MAX_N*MAX_N;\n//edge edges[MAX_M];\n//point points[MAX_N];//start from point_1\n\nint par[MAX_N];\nint val[MAX_N];\nvoid init(int n){\n    for(int i=1; i<=n; i++){\n        par[i]=i;\n        val[i]=0;\n    }\n}\n\nint find(int x){\n    int root=x;\n    while(root!=par[root]) root=par[root]; \n    while(x!=root){\n        int t=par[x];\n        par[x]=root;\n        x=t;\n    }\n    return root;\n}\n\nbool same(int x, int y){\n    x=find(x); y=find(y);\n    return x==y;\n}\n\nvoid unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;\n    if(val[x]<val[y]) par[x]=y;\n    else par[y]=x;\n    if(val[x]==val[y]) val[x]++;\n}\n\nint main(){\n    freopen(\"in.txt\", \"r\", stdin);\n    int N, M; \n    cin>>N>>M;\n    point* points=new point[N*2];\n    edge* edges=new edge[M*2];\n        for(int i=1; i<=N; i++){\n            cin>>points[i].x>>points[i].y;\n        }\n        int p, q;\n        for(int i=0; i<M; i++){\n            cin>>p>>q;\n            edges[i].u=p; edges[i].v=q;\n            edges[i].w=sqrt((points[p].x-points[q].x)*(points[p].x-points[q].x)\n                          +(points[p].y-points[q].y)*(points[p].y-points[q].y));\n        }\n        sort(edges, edges+M);\n        double res=0;\n        init(N);\n        for(int i=0; i<M; i++){\n            int p=edges[i].u, q=edges[i].v;\n            if(same(p,q)){\n                res+=edges[i].w;\n            }\n            else{\n                unite(p, q);\n            }\n        }\n        printf(\"%.3lf\", res);\n    \n    fclose(stdin);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\nusing namespace std;\nconst int N=100010,M=N*2;\nstruct node\n{\n    int a,b;\n    double w;\n    bool operator<(const node&A)const\n    {\n        return w>A.w;\n    }\n}sz[M];\ntypedef pair<int,int>PII;\nPII p[N];\nint t[N];\nint m,n;\nint find(int a)\n{\n    if(t[a]!=a)t[a]=find(t[a]);\n    return t[a];\n}\ndouble dist(int x,int y)\n{\n    double a=abs(p[x].first-p[y].first);\n    double b=abs(p[x].second-p[y].second);\n    return sqrt(a*a+b*b);\n}\nint main(void)\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        t[i]=i;\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        p[i]={x,y};\n    }\n    double ans=0,res=0;\n    for(int i=1;i<=m;i++)\n    {\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        ans+=dist(x,y);\n        sz[i]={x,y,dist(x,y)};\n    }\n    sort(sz+1,sz+m+1);\n    for(int i=1;i<=m;i++)\n    {\n        int a=sz[i].a,b=sz[i].b;\n        double w=sz[i].w;\n        int pa=find(a),pb=find(b);\n        if(pa!=pb)\n        {\n            res+=w;\n            t[pa]=pb;\n        }\n    }\n    printf(\"%.3lf\",ans-res);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<map>\n\nusing namespace std;\n\nstruct edge{\n\tint f,t;\n\tdouble c;\n};\n\nbool comp(const edge &e1,const edge &e2){\n\treturn e1.c>e2.c;\n}\n\ntypedef pair<double,int> P;\nint n,m;\nbool used[10001];\nint par[10001];\nint rank[10001];\nint x[10001],y[10001];\nvector<edge> all;\n\nvoid init(int v){\n\tfor(int i=0;i<=v;i++)par[i]=i,rank[i]=0;\n}\n\nint find(int v){\n\tif(par[v]==v)return v;\n\telse return par[v]=find(par[v]);\n}\n\nvoid unite(int v,int w){\n\tv=find(v);\n\tw=find(w);\n\tif(v==w)return;\n\tif(rank[v]<rank[w])par[v]=w;\n\telse{\n\t\tpar[w]=v;\n\t\tif(rank[v]==rank[w])rank[v]++;\n\t}\n}\n\nbool same(int v,int w){\n\treturn find(v)==find(w);\n}\n\ndouble kruskal(){\n\tdouble res=0.0;\n\tinit(n);\n\tsort(all.begin(),all.end(),comp);\n\tfor(int i=0;i<all.size();i++){\n\t\tedge e=all[i];\n\t\tif(!same(e.f,e.t)){\n\t\t\tunite(e.f,e.t);\n\t\t\t//printf(\"%d %d %d %d\\n\",e.f,e.t,par[e.f],par[e.t]);\n\t\t}else res+=e.c;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d\",&x[i],&y[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint f,t;\n\t\tedge e;\n\t\tscanf(\"%d%d\",&f,&t);\n\t\tdouble nx=(double)(abs(x[f]-x[t]));\n\t\tdouble ny=(double)(abs(y[f]-y[t]));\n\t\te.c=(double)sqrt(pow(nx,2)+pow(ny,2));\n\t\te.f=f;\n\t\te.t=t;\n\t\tall.push_back(e);\n\t}\n\tprintf(\"%.7f\\n\",kruskal());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\nusing namespace std;\nstruct point {\n\tint x, y;\n} pp[10001];\nint n, m;\nint par[10001], ran[10001];\nstruct edge {\n\tint from, to;\n\tdouble cost;\n\tbool operator < (const edge &a) const {\n\t\treturn cost > a.cost;\n\t}\n};\nvector <edge> gg;\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid init()\n{\n\tfor(int i = 0; i <= n; i++)\n\t\tpar[i] = i;\n}\nbool unite(int x, int y)\n{\n\tx = find(x); y = find(y);\n\tif(x == y)\treturn false;\n\tif(ran[x] < ran[y])\n\t\tpar[x] = y;\n\telse {\n\t\tif(ran[x] == ran[y])\n\t\t\tran[x]++;\n\t\tpar[y] = x;\n\t}\n\treturn true;\n}\n\nvoid kruls()\n{\n\tinit();\n\tdouble res = 0;\n\tsort(gg.begin(), gg.end() );\n\tfor(int i = 0; i < gg.size(); i++)\n\t{\n\t\tif(!unite(gg[i].from, gg[i].to) )\n\t\t\tres += gg[i].cost;\n\t}\n\tprintf(\"%.3f\\n\", res);\n}\nint main()\n{\n\tscanf(\"%d %d\", &n, &m);\n\tint a, b;\n\tdouble d;\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d %d\", &pp[i].x, &pp[i].y);\n\tfor(int i = 1; i <= m; i++)\n\t{\n\t\tscanf(\"%d %d\", &a, &b);\n\t\td = sqrt( (double)(pp[a].x - pp[b].x) * (pp[a].x - pp[b].x) + (pp[a].y - pp[b].y) * (pp[a].y - pp[b].y) );\n\t\tgg.push_back(edge {a, b, d});\n\t}\n\tkruls();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> par;\n  int n, cnt;\n  UnionFind(const int& x = 0) {\n    init(x);\n  }\n\n  void init(const int& x) {\n    par.assign(cnt = n = x, -1);\n  }\n\n  inline int find(const int& x) {\n    return par[x] < 0 ? x : find(par[x]);\n  }\n\n  inline bool same(const int& x, const int& y) {\n    return find(x) == find(y);\n  }\n\n  inline bool unite(int x, int y) {\n    x = find(x); y = find(y);\n\n    if (x != y) {\n      if (par[x] > par[y]) swap(x, y);\n      par[x] += par[y];\n      par[y] = x;\n      cnt--;\n      return true;\n    }\n\n    return false;\n  }\n\n  inline int count() {\n    return cnt;\n  }\n\n  inline int count(int x) {\n    return -par[find(x)];\n  }\n};\n\nstruct Edge {\n  int u;\n  int v;\n  double cost;\n\n  Edge(int u, int v, double cost): u(u), v(v), cost(cost) {}\n  Edge(): u(0), v(0), cost(0.0) {}\n\n  bool operator<(const Edge& other) const {\n    return cost < other.cost;\n  }\n};\n\nint square(int x) {\n  return x * x;\n}\n\nint main()\n{\n  int N, M; scanf(\"%d%d\", &N, &M);\n  vector<int> X(N), Y(N);\n  vector<Edge> es(M);\n  double sum = 0.0;\n  double cut = 0.0;\n  UnionFind uf(N);\n\n  for (int i = 0; i < N; i++) {\n    scanf(\"%d%d\", &X[i], &Y[i]);\n  }\n\n  for (int i = 0; i < M; i++) {\n    int p, q; scanf(\"%d%d\", &p, &q); p--; q--;\n    double cost = sqrt(square(X[p] - X[q]) + square(Y[p] - Y[q]));\n\n    es.push_back(Edge(p, q, cost));\n    sum += cost;\n  }\n\n  sort(es.rbegin(), es.rend());\n\n  for (int i = 0; i < M; i++) {\n    Edge e = es[i];\n\n    if (uf.same(e.u, e.v)) continue;\n\n    uf.unite(e.u, e.v);\n    cut += e.cost;\n  }\n\n  printf(\"%.3lf\\n\", sum - cut);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <cmath>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nconst int maxn = 1e5+1100;\nconst int INF = 1e6;\n\nusing namespace std;\n\n//生成最大生成树，破开的篱笆才最短 \n\nstruct edge{\n\tint u, v;\n\tdouble cost;\n};\nbool cmp(edge e1, edge e2){\n\treturn e1.cost > e2.cost;\n}\n\nint N, M;\nedge es[maxn];\ndouble X[maxn], Y[maxn];\nint par[maxn], ran[maxn];\n\n//初始\nvoid Init(int n){\n\tfor(int i = 1; i <= n; i++){\n\t\tpar[i] = i;\n\t\tran[i] = 0;\n\t}\n}\n//查询\nint Find(int x){\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = Find(par[x]);\n}\n//合并\nvoid Unit(int x, int y){\n\tx = Find(x);\n\ty = Find(y);\n\tif(x == y)return;\n\t\n\tif(ran[x] > ran[y])\n\t\tpar[y] = x;\n\telse{\n\t\tpar[x] = y;\n\t\tif(ran[x] == ran[y])\n\t\t\tran[y]++;\n\t}\n}\n//判断 \nbool Same(int x, int y){\n\treturn Find(x) == Find(y);\n}\n\nvoid Solve(){\n\tInit(N);\n\tdouble ans = 0.0;\n\t\n\t//花费降序排序，不产生圈的情况下合并 \n\tsort(es, es+M, cmp);\n\tfor(int i = 0; i < M; i++){\n\t\tedge e = es[i];\n\t\t//如果加进并查集产生圈，破开 \n\t\tif(Same(e.u, e.v)){\n\t\t\tans += e.cost;\n\t\t\tcontinue;\n\t\t}\n\t\tUnit(e.u, e.v);\n\t}\n\tprintf(\"%lf\\n\", ans);\n}\n\n//测试函数 \nint main(){\n//\tfreopen(\"D:\\\\钢铁程序员\\\\程序数据\\\\078拯救猫咪.txt\", \"r\", stdin);\n\twhile(~scanf(\"%d%d\", &N, &M)){\n\t\tfor(int i = 1; i <= N; i++)\n\t\t\tscanf(\"%lf%lf\", &X[i], &Y[i]);\n\t\t//提取图\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d%d\", &a, &b);\n\t\t\tes[i].u = a;\n\t\t\tes[i].v = b;\n\t\t\tdouble c = X[a] - X[b];\n\t\t\tdouble d = Y[a] - Y[b];\n\t\t\tes[i].cost = sqrt(c * c + d * d);\n\t\t} \n\t\t\n\t\tSolve();\n\t}\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii p(n);\n\trep(i, n)cin >> p[i].first >> p[i].second;\n\tvector<tuple<double, int, int>> f(m);\n\tunionfind uf(n);\n\trep(i, m) {\n\t\tint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tp1--;\n\t\tp2--;\n\t\tf[i] = tuple<double, int, int>{ hypot(p[p1].first - p[p2].first, p[p1].second - p[p2].second),p1,p2 };\n\t}\n\tsort(ALL(f), greater<tuple<double, int, int>>());\n\tdouble ans = 0;\n\trep(i, m) {\n\t\tif (!uf.same(get<1>(f[i]), get<2>(f[i])))uf.unite(get<1>(f[i]), get<2>(f[i]));\n\t\telse ans += get<0>(f[i]);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 10000+5;\npair<int,int> P[maxn];\nstruct Edge\n{\n    int from,to;\n    double cost;\n    Edge() {}\n    Edge(int a,int b,double c):from(a),to(b),cost(c) {}\n};\nEdge es[maxn*100];\nint N,M,father[maxn];\ndouble res;\n\nvoid init()\n{\n    for(int i=1; i<=N; ++i)\n        father[i]=i;\n}\n\nbool cmp(Edge a,Edge b)\n{\n    return a.cost>b.cost;\n}\n\nint find(int x)\n{\n    if(x == father[x])\n        return x;\n    int temp = father[x];\n    father[x] = find(father[x]);\n    x = temp;\n    return father[x];\n}\n\nvoid Kruskal()\n{\n    sort(es+1,es+1+M,cmp);\n    init();\n//    for(int i=1;i<=M;++i)\n//        printf(\"%d %d %.3lf\\n\",es[i].from,es[i].to,es[i].cost);\n    double ans=0;\n    for(int i=1; i<=M; ++i)\n    {\n        Edge e = es[i];\n        int x=find(e.from),y=find(e.to);\n//        cout<<\"before : \"<<e.from<<\" \"<<e.to<<\" \"<<x<<\" \"<<y<<endl;\n        if(x!=y)\n        {\n            father[x]=y;\n            ans+=e.cost;\n//            cout<<\"after : \"<<x<<\" \"<<y<<\" \"<<find(x)<<\" \"<<find(y)<<endl;\n        }\n    }\n//    cout<<res<<\" \"<<ans<<endl;\n    printf(\"%.3lf\\n\",res-ans);\n}\n\nint main()\n{\n    res=0;\n    scanf(\"%d%d\",&N,&M);\n    for(int i=1; i<=N; ++i)\n    {\n        scanf(\"%d%d\",&P[i].first,&P[i].second);\n    }\n    for(int i=1; i<=M; ++i)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        double temp = sqrt((P[a].first - P[b].first)*(P[a].first - P[b].first)+(P[a].second - P[b].second)*(P[a].second - P[b].second));\n        res+=temp;\n        es[i] = Edge(a,b,temp);\n    }\n    Kruskal();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nstruct edge{\n    int u;\t//?????????\n    int v;\t//??°??????\n    double cost;\t//??????\n    //???????????????????????§?????§?°???¢????????????\n    bool operator<(const edge& another) const {\n        return cost > another.cost;\n    }\n};\n\nconst int MAX_N = 10002;\nconst int MAX_M = 500000;\n\nP a[MAX_N];\nint n,m;\nedge es[MAX_M];\nint par[MAX_N];\nint rrank[MAX_N];\n\nvoid initial(int n){\t\t//?????????\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trrank[i] = 0;\n\t}\n}\n\nint find(int x){\t\t//??¨??????????±???????\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\t//x???????????¨??¨y???????????¨?????????\n\tx = find(x);\t//x???????????¨??????????????????x??¨??????\n\ty = find(y);\t//y???????????¨??????????????????y??¨??????\n\tif(x == y) return;\n\tif(rrank[x] < rrank[y]){\n\t\tpar[x] = y;\n\t}else{\n\t\tpar[y] = x;\n\t\tif(rrank[x] == rrank[y])\n\t\t\trrank[x]++;\n\t}\n}\n\nbool same(int x,int y){\t//x,y???????????¨???????????§?????????\n\treturn find(x) == find(y);\n}\n\ndouble kruskal(int n,int m){\n\tinitial(n);\n\tdouble res = 0;\n\tfor(int i=0;i<m;i++){\n\t\tedge e = es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\ndouble dir(P p1,P p2)\n{\n    return sqrt((p2.first - p1.first)*(p2.first - p1.first) + (p2.second - p1.second)*(p2.second - p1.second));\n}\n\nint main()\n{\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n == 0 && m == 0){\n            break;\n        }\n    \trep(i,n){\n    \t\tscanf(\"%d%d\",&a[i].first,&a[i].second);\n    \t}\n        rep(i,m){\n            int p,q;\n            scanf(\"%d%d\",&p,&q);\n            es[i] = (edge){p-1,q-1,dir(a[p-1],a[q-1])};\n        }\n        double sm = 0.0;\n        rep(i,m){\n            sm += es[i].cost;\n        }\n        sort(es,es+m);\n        printf(\"%.3f\\n\",sm - kruskal(n,m));\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=a-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T,const T& updater(const T&,const T&)>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\telse r--;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &&a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tsegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e){\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii p(n);\n\trep(i, n)cin >> p[i].first >> p[i].second;\n\tvector<uset<int>> pf(n);\n\tvpii f(m);\n\tsegtree<pair<double,int>,min> st(m,make_pair(1e9,1e9));\n\trep(i, m) {\n\t\tint p1, p2;\n\t\tcin >> p1 >> p2;\n\t\tp1--;\n\t\tp2--;\n\t\tf[i] = { p1,p2 };\n\t\tst[i] = { hypot(p[p1].first - p[p2].first, p[p1].second - p[p2].second),i };\n\t\tpf[p1].insert(i);\n\t\tpf[p2].insert(i);\n\t}\n\trep(i, n) {\n\t\tint prev = i;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst[fn].first = 1e9;\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t}\n\tst.updateall();\n\tdouble ans = 0;\n\tpair<double,int> remove;\n\twhile(remove = st.query(0, m),remove.first<1e9) {\n\t\tans += remove.first;\n\t\tint fn = remove.second;\n\t\tst.update(fn, { 1e9,fn });\n\t\tpf[f[fn].first].erase(fn);\n\t\tpf[f[fn].second].erase(fn);\n\t\tint prev = f[fn].first;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst.update(fn, { 1e9,fn });\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t\tprev = f[fn].second;\n\t\twhile (pf[prev].size() == 1) {\n\t\t\tint fn = *pf[prev].begin();\n\t\t\tst.update(fn, { 1e9,fn });\n\t\t\tint next = (f[fn].first == prev ? f[fn].second : f[fn].first);\n\t\t\tpf[prev].erase(fn);\n\t\t\tpf[next].erase(fn);\n\t\t\tprev = next;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1 << 28;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n//int n_stu[MAX_N];\n//void n_init(){\n//\trep(i, 0, n)\n//\t\tn_stu[i] = i;\n//}\n//int n_getf(int id){\n//\tif (n_stu[id] != id){\n//\t\tn_stu[id] = n_getf(n_stu[id]);\n//\t}\n//\treturn n_stu[id];\n//}\n//bool n_same(int i, int j){\n//\tif (n_getf(i) == n_getf(j))\n//\t\treturn true;\n//\treturn false;\n//}\n//void n_union(int i, int j){\n//\tint fi = n_getf(i), fj = n_getf(j);\n//\tif (fi != fj){\n//\t\tn_stu[fi] = fj;\n//\t}\n//}\n\n#define my_debu\nconst int MAX_N = 10005;\nP all[MAX_N];\ntypedef pair<double, P> Path;\nvector<Path> path;\nint n_stu[MAX_N];\n\nint n, m;\n\nvoid n_init(int len){\n\trep(i, 0, len)\n\t\tn_stu[i] = i;\n}\nint n_getf(int id){\n\tif (n_stu[id] != id){\n\t\tn_stu[id] = n_getf(n_stu[id]);\n\t}\n\treturn n_stu[id];\n}\nbool n_same(int i, int j){\n\tif (n_getf(i) == n_getf(j))\n\t\treturn true;\n\treturn false;\n}\nvoid n_union(int i, int j){\n\tint fi = n_getf(i), fj = n_getf(j);\n\tif (fi != fj){\n\t\tn_stu[fi] = fj;\n\t}\n}\n\nvoid solve(){\n\tsort(path.begin(), path.end(), greater<Path>());\n\t//vector<bool> stu(path.size(), true);\n\tn_init(n);\n\tdouble out = 0;\n\trep(i, 0, path.size()){\n\t\tint a = path[i].second.first, b = path[i].second.second;\n\t\tif (n_same(a, b)){\n\t\t\tout += (double)path[i].first;\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\tn_union(a, b);\n\t\t}\n\t}\n\tprintf(\"%0.3f\\n\", out);\n}\n\ndouble gDis(int id1, int id2){\n\tint tmp1 = all[id1].first - all[id2].first;\n\tint tmp2 = all[id1].second - all[id2].second;\n\treturn (double)sqrt(double(tmp1*tmp1) + double(tmp2*tmp2));\n}\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,m) != EOF){\n\t\tpath.clear();\n\t\trep(i, 0, n){\n\t\t\tgint2(all[i].first, all[i].second);\n\t\t}\n\t\tint tmp1, tmp2;\n\t\trep(i, 0, m){\n\t\t\tgint2(tmp1, tmp2);\n\t\t\t--tmp1, --tmp2;\n\t\t\tpath.push_back({ gDis(tmp1, tmp2), {tmp1,tmp2} });\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll long long\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,c;\n#define N 210\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nstruct Edge{\n\tint u,v;\n\tdouble c;\n\tbool operator <(const Edge &x)const{\n\t\treturn c>x.c;\n\t}\n};\nvector<Edge> e;\nvector<pair<int,int> > G;\nint fa[10010];\nint find(int x){\n\treturn x==fa[x]?fa[x]:fa[x]=find(fa[x]);\n}\ndouble Kruskal(){\n\tfor(int i=0;i<n;i++) fa[i]=i;\n\tdouble ans=0;\n\tsort(e.begin(),e.end());\n\tint cnt=0;\n\tfor(int i=0;i<(int)e.size();i+=2){\n\t\tint u = e[i].u;\n\t\tint v = e[i].v;\n\t\tint fu = find(u);\n\t\tint fv = find(v);\n\t\tif(fu != fv){\n\t\t\tfa[fu] = fv;\n\t\t\tans += e[i].c;\n\t\t\tcnt++;\n\t\t\tif(cnt>=n-1) break;\n\t\t}\n\t}\n\treturn ans;\n}\nint main(){\n    while(sfd(n,m)!=EOF){\n    \te.clear();\n    \tG.clear();\n    \tint x,y;\n    \tfor(int i=0;i<n;i++){\n    \t\tsfd(x,y);\n    \t\tG.push_back(make_pair(x,y));\n    \t}\n    \tint u,v;\n    \tdouble ans=0;\n    \tfor(int i=0;i<m;i++){\n    \t\tsfd(u,v);\n    \t\tu--,v--;\n    \t\tdouble cy = sqrt((G[u].first-G[v].first)*(G[u].first-G[v].first)+(G[u].second-G[v].second)*(G[u].second-G[v].second));\n    \t\tans += cy;\n    \t\te.push_back((Edge){u,v,cy});\n    \t\te.push_back((Edge){v,u,cy});\n    \t}\n    \tans = ans - Kruskal();\n    \tprintf(\"%.3f\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\n\nstruct Way{\n\tint p,q,cost;\n\tWay(){}\n\tWay(int _p,int _q,int _cost){\n\t\tp=_p; q=_q; cost=_cost;\n\t}\n\tbool operator<(const Way &a)const{\n\t\treturn cost>a.cost;\n\t}\n};\n\nstruct Node{\n\tint x,y;\n};\n\nint par[10000],_rank[10000];\n\nvoid init(int n){\n\tfor(int i=0;i<n;i++) par[i]=i,_rank[i]=1;\n}\n\nint find(int a){\n\tif(par[a]==a) return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int _a,int _b){\n\tint a = find(_a);\n\tint b = find(_b);\n\tif(a==b) return;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = a;\n\t}\n\telse{\n\t\tpar[a] = b;\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n}\n\nint main(){\n\tint N,M;\n\tNode node[10000];\n\tWay way[100000];\n\tcin>>N>>M;\n\tfor(int i=0;i<N;i++){\n\t\tcin>>node[i].x>>node[i].y;\n\t}\n\tfor(int i=0;i<M;i++){\n\t\tint a,b;\n\t\tcin>>way[i].p>>way[i].q;\n\t\ta = node[--way[i].p].x-node[--way[i].q].x;\n\t\tb = node[way[i].p].y-node[way[i].q].y;\n\t\tway[i].cost = a*a+b*b;\n\t\t//printf(\"\\t%d\\n\",way[i].cost);\n\t}\n\n\tdouble ans=0;\n\tsort(way,way+M);\n\tinit(N);\n\tfor(int i=0;i<M;i++){\n\t\tint a = find(way[i].p),\n\t\t\tb = find(way[i].q);\n\t\tif(a!=b) unite(a,b);\n\t\telse ans += sqrt(way[i].cost);\n\t}\n\tprintf(\"%lf\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nclass UnionFind{\nprivate:\n  vector<int> par, rank;\npublic:\n  UnionFind(int n){\n\tpar.assign(n, 0);\n\trank.assign(n, 0);\n\tfor(int i=0;i<n;++i)\n\t  par[i] = i;\n  }\n\n  //find root of x\n  int find(int x){\n\tif(par[x] == x)\n\t  return x;\n\treturn (par[x] = find(par[x]));\n  }\n\n  void unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(rank[x] < rank[y])\n\t  par[x] = y;\n\telse{\n\t  par[y] = x;\n\t  if(rank[x] == rank[y])\n\t\t++rank[x];\n\t}\n  }\n\n  bool same(int x, int y){\n\treturn find(x) == find(y);\n  }\n};\n\nstruct Edge{\n  int to;\n  double cost;\n\n  Edge(int t, double c): to(t), cost(c)\n  {}\n  bool operator>(const Edge& rhs) const{\n\treturn cost > rhs.cost;\n  }\n  bool operator<(const Edge& rhs) const{\n\treturn cost < rhs.cost;\n  }\n\n};\ntypedef vector< vector<Edge> > Graph;\n\nvoid add_edge(Graph& graph, int u, int v, double cost){\n  graph[u].push_back(Edge(v,cost));\n  graph[v].push_back(Edge(u,cost));\n}\n\ndouble kruskal(const Graph& G){\n  int N = SZ(G);\n  UnionFind uf(N);\n  vector<pair<Edge,int>> edges;\n  REP(i,N) for(auto& e:G[i]){\n\tedges.push_back(MP(e, i));\n  }\n  sort(ALL(edges));\n\n  double res = 0;\n  int i, n;\n  for(i=0,n=1;n<N&&i<SZ(edges);++i){\n\tauto& e = edges[i].first;\n\tint v = edges[i].second;\n\tif(!uf.same(e.to,v)){\n\t  uf.unite(e.to, v);\n\t  res += e.cost;\n\t  ++n;\n\t}\n  }\n  return res;\n}\n\ndouble dist(PII& p, PII& q){\n  int dx = p.FF - q.FF;\n  int dy = p.SS - q.SS;\n  return sqrt(dx*dx + dy*dy);\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  vector<PII> ps(N);\n  REP(i,N) cin >> ps[i];\n  Graph G(N);\n  double ans = 0.;\n  REP(i,M){\n\tint p, q; cin >> p >> q;\n\t--p, --q;\n\tdouble c = dist(ps[p], ps[q]);\n\tadd_edge(G, p, q, -c);\n\tans += c;\n  }\n  ans += kruskal(G);\n  cout << fixed << setprecision(9) << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2224: Save your cats\n// 2017.10.7 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define EPS 1e-7\n#define MAX 10003\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\nvoid make_set(int x) { p[x] = x, rank[x] = 0; }\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\ntypedef struct { int a, b; double d; } T;\nT tbl[50005];\n\nint x[MAX], y[MAX];\n\nint cmp(T *a, T *b)\n{\n\tif (fabs(b->d - a->d) <= EPS) return 0;\n\tif (a->d <= b->d) return 1;\n\treturn -1;\n}\n\nint main()\n{\n\tint n, m, i, s, t;\n\tdouble ans, d, dx, dy;\n\n    scanf(\"%d%d\", &n, &m);\n    for (i = 1; i <= n; i++) scanf(\"%d%d\",x+i, y+i), make_set(i);\n    for (ans = 0, i = 0; i < m; i++) {\n        scanf(\"%d%d\", &s, &t);\n\t\tdx = x[s] - x[t], dy = y[s] - y[t];\n\t\td = sqrt(dx*dx + dy*dy);\n        tbl[i].a = s, tbl[i].b = t, tbl[i].d = d;\n        ans += d;\n    }\n    qsort(tbl, m, sizeof(T), cmp);\n\n    for (i = 0; i < m; i++) {\n        s = find_set(tbl[i].a), t = find_set(tbl[i].b);\n        if (p[s] != p[t]) union_set(s, t), ans -= tbl[i].d;\n    }\n    printf(\"%lf\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint piles,fences;\n\tint\ti,j;\n\n\tdouble output = 0.0;\n\n\t//読み込み\n\tscanf(\"%d %d\",&piles,&fences);\n\tint pilex[piles],piley[piles];\n\tint fencex[fences],fencey[fences];\n\tfor(j=0;j<piles;j++){\n\t\tscanf(\"%d %d\",&pilex[j],&piley[j]);\n\t}\n\tfor(j=0;j<fences;j++){\n\t\tscanf(\"%d %d\",&fencex[j],&fencey[j]);\n\t}\n\n\n\twhile(1){\n\n\t\t//隣接リストを作る\n\t\tint nextto[piles][piles-1];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tfor(j=0;j<piles-1;j++){\n\t\t\t\tnextto[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<piles;i++){\n\t\t\tint counter=0;\n\t\t\tfor(j=0;j<fences;j++){\n\t\t\t\tif(i+1 == fencex[j]){\n\t\t\t\t\tnextto[i][counter] = fencey[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}else if(i+1 == fencey[j]){\n\t\t\t\t\tnextto[i][counter] = fencex[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\t//閉路の検出\n\t\tint circuit[piles];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tcircuit[i] = -1;\n\t\t}\n\n\t\tif(!circuitdetect(piles,nextto,&circuit)){\n\t\t\tbreak;\n\t\t}\n\n\t\t//検出した閉路の中で最小の枝を求める\n\t\tdouble min = 10000000.0;\n\t\tdouble dist = 100000000.0;\n\t\tint mfrom = 0;\n\t\tint mto = 0;\n\t\tint from,to;\n\t\tfor(i=0;i<piles;i++){\n\t\t\tif(circuit[i] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfrom = circuit[i];\n\t\t\tif(i == piles-1 || circuit[i+1] == -1){\n\t\t\t\tto = circuit[0];\n\t\t\t}else{\n\t\t\t\tto = circuit[i+1];\t\n\t\t\t}\n\t\t\tdist = sqrt(pow(pilex[to] - pilex[from],2.0) + pow(piley[to] - piley[from],2.0));\n\n\t\t\tif(dist  < min){\n\t\t\t\tmin = dist;\n\t\t\t\tmfrom = from;\n\t\t\t\tmto = to;\n\t\t\t}\n\t\t}\n\n\t\t//最小の枝を狩る\n\t\toutput += min;\n\t\tfor(j=0;j<fences;j++){\n\t\t\tif((fencex[j] - 1 == mfrom && fencey[j] - 1 == mto) || (fencex[j] - 1 == mto && fencey[j] - 1 == mfrom)){\n\t\t\t\tfencex[j] = 0;\n\t\t\t\tfencey[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprintf(\"%f\\n\",output);\n\n\treturn 0;\n}\n\nint circuitdetect(int peaknum,int nextlist[peaknum][peaknum-1],int* retval){\n\tint k,l;\n\tint visited[peaknum];\n\n\tfor(l=0;l<peaknum;l++){\n\t\tvisited[l] = 0;\n\t}\n\n\n\tfor(k=0;k<peaknum;k++){\n\n\t\tif(visited[k] == 0){\n\t\t\tretval[0] = k;\n\t\t\tint nest = 0;\n\t\t\tint value = reflex_search(k,peaknum,nextlist,&visited,nest,retval);\n\t\t\tif(value == 1){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<peaknum;l++){\n\t\t\t\t\tretval[l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint reflex_search(int r_k,int r_p,int r_n[r_p][r_p-1],int* r_v,int r_nest,int* r_rv){\n\tr_v[r_k] = 1;\n\tr_nest++;\n\tint m;\n\tfor(m=0;m<r_p-1;m++){\n\t\tif(r_n[r_k][m] != -1){\n\t\t\tif(r_v[r_n[r_k][m]] == 0){\n\t\t\t\tr_rv[r_nest] = r_n[r_k][m]; \n\t\t\t\tint rv = reflex_search(r_n[r_k][m],r_p,r_n,r_v,r_nest,r_rv);\n\t\t\t\tif(rv == 1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}else if(r_nest > 1 && r_rv[r_nest-2] != r_n[r_k][m]){\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\nconst int maxn=1e4+7;\nint N, M;\nint x[maxn], y[maxn];\nint p[maxn];\nint cnt;\nstruct edge\n{\n    int u, v, cost;\n};\nvector<edge> es;\nint p[maxn];\nvoid init()\n{\n    for(int i=0;i<=N;i++) p[i]=i;\n}\nint find(int x)\n{\n    if(p[x]==x) return x;\n    else return p[x]=find(p[x]);\n}\nint kruskal()\n{\n    sort(es, es+M);\n    init();\n    int res=0;\n    for(int i=0;i<M;i++){\n        edge e=es[i];\n        int x=find(e.u);\n        int y=find(e.v);\n        if(x!=y){\n            p[x]=y;\n            res+=e.cost;\n            cnt++;\n        }\n    }\n    return -res;\n}\nvoid solve()\n{\n    ans=ans-kruskal();\n    if(cnt!=N-1) ans=0.000;\n    printf(\"%.3lf\\n\", sqrt(ans));\n}\nint main()\n{\n    cin>>N>>M;\n    for(int i=0;i<N;i++){\n        cin>>x[i]>>y[i];\n    }\n    for(int i=0;i<M;i++){\n        edge t;\n        cin>>t.u>>t.v;\n        t.cost=(x[u-1]-x[v-1])*(x[u-1]-x[v-1])+(y[u-1]-y[v-1])*(y[u-1]-y[v-1]);\n        ans+=t.cost;\n        t.cost=-t.cost;\n        es.push_back(t);\n    }\n    solve();\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<cmath>\n\nusing namespace std;\nconst int maxn=1e4+7;\nint N, M;\nint x[maxn], y[maxn];\nint p[maxn];\nint cnt;\nstruct edge\n{\n    int u, v, cost;\n    bool operator < (const edge & x) const\n    {\n        return cost<x.cost;\n    }\n};\nvector<edge> es;\nint p[maxn];\nvoid init()\n{\n    for(int i=0;i<=N;i++) p[i]=i;\n}\nint find(int x)\n{\n    if(p[x]==x) return x;\n    else return p[x]=find(p[x]);\n}\nint kruskal()\n{\n    sort(es, es+M);\n    init();\n    int res=0;\n    for(int i=0;i<M;i++){\n        edge e=es[i];\n        int x=find(e.u);\n        int y=find(e.v);\n        if(x!=y){\n            p[x]=y;\n            res+=e.cost;\n            cnt++;\n        }\n    }\n    return -res;\n}\nvoid solve()\n{\n    ans=ans-kruskal();\n    if(cnt!=N-1) ans=0.000;\n    printf(\"%.3lf\\n\", sqrt(ans));\n}\nint main()\n{\n    cin>>N>>M;\n    for(int i=0;i<N;i++){\n        cin>>x[i]>>y[i];\n    }\n    for(int i=0;i<M;i++){\n        edge t;\n        cin>>t.u>>t.v;\n        t.cost=(x[u-1]-x[v-1])*(x[u-1]-x[v-1])+(y[u-1]-y[v-1])*(y[u-1]-y[v-1]);\n        ans+=t.cost;\n        t.cost=-t.cost;\n        es.push_back(t);\n    }\n    solve();\n}"
  },
  {
    "language": "C",
    "code": "#include<cstdio>  \n#include<cmath>  \n#include<algorithm>  \nusing namespace std;  \nconst int maxn=10005;  \nint pre[maxn];  \nstruct node  \n{  \n    int a,b;  \n    double len;  \n}point[maxn],edge[maxn*100];  \ndouble dist(node x,node y)  \n{  \n    return sqrt((x.a*1.0-y.a)*(x.a-y.a)+(x.b*1.0-y.b)*(x.b-y.b));  \n}  \nvoid init(int n)  \n{  \n    for(int i=1;i<=n;++i)  \n    {  \n        pre[i]=i;  \n    }  \n}  \nint find(int x)  \n{  \n    int r=x;  \n    while(r!=pre[r])  \n    {  \n        r=pre[r];  \n    }  \n    int i=x,j;  \n    while(i!=r)  \n    {  \n        j=pre[i];  \n        pre[i]=r;  \n        i=j;  \n    }  \n    return r;  \n}  \nint join(int x,int y)  \n{  \n    int fx=find(x),fy=find(y);  \n    if(fx!=fy)  \n    {  \n        pre[fx]=fy;  \n        return 1;  \n    }  \n    return 0;  \n}  \nint cmp(node a,node b)  \n{  \n    return a.len>b.len;  \n}  \ndouble kruscal(int n,int m)  \n{  \n    sort(edge,edge+m,cmp);  \n    int cnt=0;double ans=0;  \n    for(int i=0;i<m&&cnt<n-1;++i)  \n    {  \n            if(join(edge[i].a,edge[i].b))  \n            {  \n                ans+=edge[i].len;  \n                ++cnt;  \n            }  \n    }  \n    return ans;  \n}  \nint main()  \n{  \n    int n,m;  \n//  freopen(\"shuju.txt\",\"r\",stdin);  \n    while(~scanf(\"%d%d\",&n,&m))  \n    {  \n        init(n);  \n        for(int i=1;i<=n;++i)  \n        {  \n            scanf(\"%d%d\",&point[i].a,&point[i].b);  \n        }  \n        double sum=0;  \n        for(int i=0;i<m;++i)  \n        {  \n            int a,b;  \n            scanf(\"%d%d\",&a,&b);  \n            node tp={a,b,dist(point[a],point[b])};  \n            edge[i]=tp;  \n            sum+=tp.len;  \n        }  \n        printf(\"%.4f\\n\",sum-kruscal(n,m));  \n    }  \n    return 0;  \n}  "
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint par[10050];\nint N,M;\n\nstruct edge\n{\n    int u,v;\n    double dis;\n}es[10050];\n\nstruct zb\n{\n    int x1,y1;\n}z[10050];\n\nvoid init()\n{\n    for(int i=0;i<10050;i++)\n    {\n        par[i]=i;\n    }\n}\n\nint findroot(int x)\n{\n    if(par[x]==x)\n        return x;\n    else\n        return par[x]=findroot(par[x]);\n}\n\nvoid unite(int x,int y)\n{\n    int xx=findroot(x);\n    int yy=findroot(y);\n    if(xx==yy)\n        return;\n    else\n        par[xx]=yy;\n}\n\nbool same(int x,int y)\n{\n    return findroot(x)==findroot(y);\n}\n\nbool cmp(edge a,edge b)\n{\n    return a.dis>b.dis;\n}\n\ndouble kruskal()\n{\n    sort(es,es+M,cmp);\n    init();\n    double res=0;\n    for(int i=0;i<M;i++)\n    {\n        edge e=es[i];\n        if(same(e.u,e.v)==0)\n        {\n            unite(e.u,e.v);\n            res+=e.dis;\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&N,&M);\n    for(int i=1;i<=N;i++)\n    {\n        scanf(\"%d%d\",&z[i].x1,&z[i].y1);\n    }\n    double sum=0;\n    for(int i=0;i<M;i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        double d=sqrt((z[a].x1-z[b].x1)*(z[a].x1-z[b].x1)+(z[a].y1-z[b].y1)*(z[a].y1-z[b].y1));\n        es[i].u=a;\n        es[i].v=b;\n        es[i].dis=d;\n        sum+=d;\n    }\n    printf(\"%f\\n\",sum-kruskal());\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\n\nint per[20000+10];\nstruct node\n{\n\tint a;\n\tint b;\n\tdouble edge;\n };\n node es[10000+10];\n bool cmp(node x,node y)\n {\n \treturn x.edge>y.edge;\n }\n int find(int x)\n {\n \tif(per[x]==x)\n \t\treturn x;\n \treturn per[x]=find(per[x]);\n }\n int merge(int x,int y)\n {\n \tint fx=find(x);\n \tint fy=find(y);\n \tif(fx!=fy)\n \t{\n \t\tper[fx]=fy;\n \t\treturn 1;\n\t }\n\t return 0;\n }\n double ans;\n double kruskal(int n,int m)\n {\n \tsort(es,es+m,cmp);\n \tans=0;\n \tint cnt=0;\n \tfor(int i=0;i<m&&cnt<n-1;i++)\n \t{\n \t\tif(merge(es[i].a,es[i].b))\n \t\t{\n \t\t\tans+=es[i].edge;\n \t\t\tcnt++;\n\t\t }\n\n\t }\n\t return ans;\n }\n int main()\n {\n \tint n,m;\n \tdouble pointx[10000+10],pointy[10000+10];\n \twhile(~scanf(\"%d%d\",&n,&m))\n \t{\n \t\tfor(int i=1;i<=n;i++)\n \t\t{\n \t\t\tper[i]=i;\n\t\t }\n \t\tdouble sum=0.0;\n \t\tfor(int i=1;i<=n;i++)\n \t\t\tscanf(\"%lf%lf\",&pointx[i],&pointy[i]);\n \t\tfor(int i=0;i<m;i++)\n \t\t{\n \t\t\tscanf(\"%d%d\",&es[i].a,&es[i].b);\n \t\t\tes[i].edge=sqrt((pointx[es[i].a]-pointx[es[i].b])*(pointx[es[i].a]-pointx[es[i].b])+(pointy[es[i].a]-pointy[es[i].b])*(pointy[es[i].a]-pointy[es[i].b]));\n \t\t\tsum+=es[i].edge;\n\t\t }\n\t\t printf(\"%.4lf\\n\",sum-kruskal(n,m));\n\t }\n\t return 0;\n }"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint piles,fences,i,j;\n\n\tdouble output = 0.0;\n\n\t//読み込み\n\tscanf(\"%d %d\",&piles,&fences);\n\tint pilex[piles],piley[piles],fencex[fences],fencey[fences];\n\tfor(j=0;j<piles;j++){\n\t\tscanf(\"%d %d\",&pilex[j],&piley[j]);\n\t}\n\tfor(j=0;j<fences;j++){\n\t\tscanf(\"%d %d\",&fencex[j],&fencey[j]);\n\t}\n\n\twhile(1){\n\t\t//隣接リストを作る\n\t\tint nextto[piles][piles-1];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tfor(j=0;j<piles-1;j++){\n\t\t\t\tnextto[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<piles;i++){\n\t\t\tint counter=0;\n\t\t\tfor(j=0;j<fences;j++){\n\t\t\t\tif(i+1 == fencex[j]){\n\t\t\t\t\tnextto[i][counter] = fencey[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}else if(i+1 == fencey[j]){\n\t\t\t\t\tnextto[i][counter] = fencex[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//閉路の検出\n\t\tint circuit[piles];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tcircuit[i] = -1;\n\t\t}\n\n\t\tif(!circuitdetect(piles,nextto,&circuit)){\n\t\t\tbreak;\n\t\t}\n\n\t\t//検出した閉路の中で最小の枝を求める\n\t\tdouble min = 10000000.0;\n\t\tdouble dist = 100000000.0;\n\t\tint mfrom = 0;\n\t\tint mto = 0;\n\t\tint from,to;\n\t\tfor(i=0;i<piles;i++){\n\t\t\tif(circuit[i] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfrom = circuit[i];\n\t\t\tif(i == piles-1 || circuit[i+1] == -1){\n\t\t\t\tto = circuit[0];\n\t\t\t}else{\n\t\t\t\tto = circuit[i+1];\t\n\t\t\t}\n\t\t\tdist = sqrt(pow(pilex[to] - pilex[from],2.0) + pow(piley[to] - piley[from],2.0));\n\n\t\t\tif(dist  < min){\n\t\t\t\tmin = dist;\n\t\t\t\tmfrom = from;\n\t\t\t\tmto = to;\n\t\t\t}\n\t\t}\n\n\t\t//最小の枝を狩る\n\t\toutput += min;\n\t\tfor(j=0;j<fences;j++){\n\t\t\tif((fencex[j] - 1 == mfrom && fencey[j] - 1 == mto) || (fencex[j] - 1 == mto && fencey[j] - 1 == mfrom)){\n\t\t\t\tfencex[j] = 0;\n\t\t\t\tfencey[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprintf(\"%f\\n\",output);\n\n\treturn 0;\n}\n\nint circuitdetect(int peaknum,int nextlist[peaknum][peaknum-1],int* retval){\n\tint k,l;\n\tint visited[peaknum];\n\n\tfor(l=0;l<peaknum;l++){\n\t\tvisited[l] = 0;\n\t}\n\n\tfor(k=0;k<peaknum;k++){\n\n\t\tif(visited[k] == 0){\n\t\t\tretval[0] = k;\n\t\t\tint nest = 0;\n\t\t\tint value = reflex_search(k,peaknum,nextlist,&visited,nest,retval);\n\t\t\tif(value == 1){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<peaknum;l++){\n\t\t\t\t\tretval[l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint reflex_search(int r_k,int r_p,int r_n[r_p][r_p-1],int* r_v,int r_nest,int* r_rv){\n\tr_v[r_k] = 1;\n\tr_nest++;\n\tint m;\n\tfor(m=0;m<r_p-1;m++){\n\t\tif(r_n[r_k][m] != -1){\n\t\t\tif(r_v[r_n[r_k][m]] == 0){\n\t\t\t\tr_rv[r_nest] = r_n[r_k][m]; \n\t\t\t\tif(reflex_search(r_n[r_k][m],r_p,r_n,r_v,r_nest,r_rv)){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}else if(r_nest > 1 && r_rv[r_nest-2] != r_n[r_k][m]){\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<iostream>\nusing namespace std;\n#define N 11000\nint f[N];\nint father(int x)\n{\n    while(x!=f[x])\n    {\n        x=f[x];\n    }\n    return x;\n}\nstruct node\n{\n    double x,y;\n}p[N];\nstruct node1\n{\n    int b,a;\n    double d;\n}bian[N*N/2+10];\ndouble dis(node A,node B)\n{\n    return sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\nint cmp(node1 A,node1 B)\n{\n    return A.d>B.d;\n}\nint main()\n{\n    int n,m;\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n        f[i]=i;\n    }\n    int num1,num2;\n    double sum=0.0;\n    for(int i=1;i<=m;i++)\n    {\n        scanf(\"%d%d\",&num1,&num2);\n        bian[i].a=num1;\n        bian[i].b=num2;\n        bian[i].d=dis(p[num1],p[num2]);\n        sum+=bian[i].d;\n    }\n    double sum1=0.0;\n    sort(bian+1,bian+m+1,cmp);\n    for(int i=1;i<=m;i++)\n    {\n        int x1=father(bian[i].a);\n        int y1=father(bian[i].b);\n        if(f[x1]!=f[y1])\n        {\n            if(x1>y1)\n                f[x1]=y1;\n            else\n                f[y1]=x1;\n            sum1+=bian[i].d;\n        }\n        else\n            continue;\n    }\n    printf(\"%.3f\\n\",sum-sum1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#define pi acos(-1)\n#define LL long long\n#define INF 0x3f3f3f3f\nusing namespace std;\ntypedef pair<int, int> P;\nconst int maxn = 1e5 + 5;\n\nstruct edge\n{\n    int a, b;\n    double len;\n}fenc[maxn];\nstruct Point\n{\n    int x, y;\n}p[maxn];\ndouble cal(int a, int b)\n{\n    double x = p[a].x*1.0 - p[b].x*1.0;\n    double y = p[a].y*1.0 - p[b].y*1.0;\n    return sqrt(x*x + y*y);\n}\nint cmp(edge a, edge b)\n{\n    if (a.len > b.len) return 1;\n    return 0;\n}\nint ret[maxn];\nint find(int a)\n{\n    if (ret[a] == -1) return a;\n    return ret[a] = find(ret[a]);\n}\nint main(void)\n{\n//\tfreopen(\"C:\\\\Users\\\\wave\\\\Desktop\\\\NULL.exe\\\\NULL\\\\in.txt\",\"r\", stdin);\n    int n, m, i, j, k, a, b;\n    double ans;\n    while (cin >> n >> m)\n    {\n        for (i = 1; i <= n; i++)\n            scanf(\"%d %d\", &p[i].x, &p[i].y);\n        for (i = 1; i <= m; i++){\n            scanf(\"%d %d\", &a, &b);\n            fenc[i].a = a;\n            fenc[i].b = b;\n            fenc[i].len = cal(a, b);\n        }\n        sort(fenc+1, fenc+1+m, cmp);\n        memset(ret, -1, sizeof(ret));\n        ans = 0;\n        for (i = 1; i <= m; i++){\n            int x = find(fenc[i].a);\n            int y = find(fenc[i].b);\n            if (x == y)\n                ans += fenc[i].len;\n            else ret[x] = y;\n        }\n        printf(\"%.3f\\n\", ans);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint piles,fences,i,j;\n\n\tdouble output = 0.0;\n\n\t//読み込み\n\tscanf(\"%d %d\",&piles,&fences);\n\tint pilex[piles],piley[piles],fencex[fences],fencey[fences];\n\tfor(j=0;j<piles;j++){\n\t\tscanf(\"%d %d\",&pilex[j],&piley[j]);\n\t}\n\tfor(j=0;j<fences;j++){\n\t\tscanf(\"%d %d\",&fencex[j],&fencey[j]);\n\t}\n\n\twhile(1){\n\t\t//隣接リストを作る\n\t\tint nextto[piles][piles-1];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tfor(j=0;j<piles-1;j++){\n\t\t\t\tnextto[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<piles;i++){\n\t\t\tint counter=0;\n\t\t\tfor(j=0;j<fences;j++){\n\t\t\t\tif(i+1 == fencex[j]){\n\t\t\t\t\tnextto[i][counter] = fencey[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}else if(i+1 == fencey[j]){\n\t\t\t\t\tnextto[i][counter] = fencex[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//閉路の検出\n\t\tint circuit[piles];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tcircuit[i] = -1;\n\t\t}\n\n\t\tif(!circuitdetect(piles,nextto,&circuit)){\n\t\t\tbreak;\n\t\t}\n\n\t\t//検出した閉路の中で最小の枝を求める\n\t\tdouble min = 10000000.0;\n\t\tdouble dist = 100000000.0;\n\t\tint mfrom = 0;\n\t\tint mto = 0;\n\t\tint from,to;\n\t\tfor(i=0;i<piles;i++){\n\t\t\tif(circuit[i] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfrom = circuit[i];\n\t\t\tif(i == piles-1 || circuit[i+1] == -1){\n\t\t\t\tto = circuit[0];\n\t\t\t}else{\n\t\t\t\tto = circuit[i+1];\t\n\t\t\t}\n\t\t\tdist = sqrt(pow(pilex[to] - pilex[from],2.0) + pow(piley[to] - piley[from],2.0));\n\n\t\t\tif(dist  < min){\n\t\t\t\tmin = dist;\n\t\t\t\tmfrom = from;\n\t\t\t\tmto = to;\n\t\t\t}\n\t\t}\n\n\t\t//最小の枝を狩る\n\t\toutput += min;\n\t\tfor(j=0;j<fences;j++){\n\t\t\tif((fencex[j] - 1 == mfrom && fencey[j] - 1 == mto) || (fencex[j] - 1 == mto && fencey[j] - 1 == mfrom)){\n\t\t\t\tfencex[j] = 0;\n\t\t\t\tfencey[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprintf(\"%f\\n\",output);\n\n\treturn 0;\n}\n\nint circuitdetect(int peaknum,int nextlist[peaknum][peaknum-1],int* retval){\n\tint k,l;\n\tint visited[peaknum];\n\n\tfor(l=0;l<peaknum;l++){\n\t\tvisited[l] = 0;\n\t}\n\n\tfor(k=0;k<peaknum;k++){\n\n\t\tif(visited[k] == 0){\n\t\t\tretval[0] = k;\n\t\t\tint nest = 0;\n\t\t\tint value = reflex_search(k,peaknum,nextlist,&visited,nest,retval);\n\t\t\tif(value == 1){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<peaknum;l++){\n\t\t\t\t\tretval[l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint reflex_search(int r_k,int r_p,int r_n[r_p][r_p-1],int* r_v,int r_nest,int* r_rv){\n\tr_v[r_k] = 1;\n\tr_nest++;\n\tint m;\n\tfor(m=0;m<r_p-1;m++){\n\t\tif(r_n[r_k][m] != -1){\n\t\t\tif(r_v[r_n[r_k][m]] == 0){\n\t\t\t\tr_rv[r_nest] = r_n[r_k][m]; \n\t\t\t\tif(reflex_search(r_n[r_k][m],r_p,r_n,r_v,r_nest,r_rv)){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}else if(r_nest > 1 && r_rv[r_nest-2] != r_n[r_k][m]){\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n#define MAX_N 10001\n\n//??±\nstruct TPile{\n  int x; int y;\n};\n\n//?£?\nstruct TFence{\n  double length;\n  int a,b;\n};\n \ntypedef struct TPile Pile;\ntypedef struct TFence Fence;\n\n  \nPile *pile;\nFence *fence;\n\nint par[MAX_N];\nint rank[MAX_N];\n \n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n \n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\n \n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n \n//?????????????????????(Fence.length?????????)\nvoid FenceSort(int s,int e,Fence* array){\n  int i,j,k;\n  i=s-1;\n  j=e;\n  while(i<j){\n    while(++i<e&&array[i].length<array[e].length);\n    while(--j>=s&&array[j].length>=array[e].length);\n    if(i<j){\n      //??¢??°????????¨??????????????????\n      array[i].length+=array[j].length;\n      array[j].length=array[i].length-array[j].length;\n      array[i].length-=array[j].length;\n \n      array[i].a+=array[j].a;\n      array[j].a=array[i].a-array[j].a;\n      array[i].a-=array[j].a;\n \n      array[i].b+=array[j].b;\n      array[j].b=array[i].b-array[j].b;\n      array[i].b-=array[j].b;\n \n    }\n  }\n  if(i<e){\n    //?????????????????????\n \n    array[e].length+=array[i].length;\n    array[i].length=array[e].length-array[i].length;\n    array[e].length-=array[i].length;\n \n    array[e].a+=array[i].a;\n    array[i].a=array[e].a-array[i].a;\n    array[e].a-=array[i].a;\n \n    array[e].b+=array[i].b;\n    array[i].b=array[e].b-array[i].b;\n    array[e].b-=array[i].b;\n \n    i++;\n  }\n  if(s<j)FenceSort(s,j,array);\n  if(e>i)FenceSort(i,e,array);\n}\n \nint main(){\n  int n,m;\n  char s[16];\n  int i,j,a,b,d;\n  double res;\n  if(!fgets(s,16,stdin))return 1;\n  sscanf(s,\"%d %d\",&n,&m);\n  pile=(Pile*)malloc(sizeof(Pile)*(n+1));\n  fence=(Fence*)malloc(sizeof(Fence)*m);\n  for(i=1;i<=n;i++){\n    fgets(s,16,stdin);\n    sscanf(s,\"%d %d\",&a,&b);\n    pile[i].x=a;\n    pile[i].y=b;\n  }\n\n  for(i=0;i<m;i++){\n    fgets(s,16,stdin);\n    sscanf(s,\"%d %d\",&a,&b);\n    fence[i].a=a;\n    fence[i].b=b;\n    fence[i].length=sqrt((pile[a].x-pile[b].x)*(pile[a].x-pile[b].x)+(pile[a].y-pile[b].y)*(pile[a].y-pile[b].y));\n  }\n  \n  FenceSort(0,m-1,fence);\n  res=0;\n  init(n+1);\n  for(j=m-1;j>=0;j--){\n    if(!same(fence[j].a,fence[j].b)){\n      unite(fence[j].a,fence[j].b);\n    }else{\n      res+=fence[j].length;\n    }\n  }\n  free(pile);\n  free(fence);\n  printf(\"%lf\\n\",res);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\nusing namespace std;\n#define inf 0x3f3f3f3f\n#define pr(x) cout<<\"x=\"<<x<<endl;\n#define maxn 1000100\nint N, M;\nint par[maxn];\nint x[maxn], y[maxn];\nstruct point{\n\tint ls, rs;\n\tdouble cost;\n}p[maxn];\n\n\nbool comp(point a, point b){ return a.cost>b.cost; }\n\nint find(int x)\n{\n\tif (x == par[x])return x;\n\t return par[x] = find(par[x]);\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\ndouble kru(int n, int e)\n{\n\tfor (int i = 1; i <= n; i++)par[i] = i;\n\tsort(p, p + e, comp);\n\t\n\tdouble ans = 0;\n\tfor (int i = 0; i <e; i++)\n\t{\n\t\tint x = find(p[i].ls);\n\t\tint y = find(p[i].rs);\n\t\tif (x != y)\n\t\t{\n\t\t\tans += p[i].cost;\n\t\t\tpar[x] = y;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tdouble ans = 0;\n\tcin >> N >> M;\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\n\tfor (int i = 0; i <M; i++){\n\t\tcin >> p[i].ls >> p[i].rs;\n\t\tint a = p[i].ls;\n\t\tint b = p[i].rs;\n\t\tint xx = x[a] - x[b]; \n\t\txx *= xx;\n\t\tint yy = y[a] - y[b]; \n\t\tyy *= yy;\n\t\tp[i].cost = sqrt(xx + yy);\n\t\tans += p[i].cost;\n\t}\n\tans -= kru(N, M);\n\tprintf(\"%.3f\\n\", ans);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nint main(){\n\tint piles,fences;\n\tint\ti,j;\n\n\tdouble output = 0.0;\n\n\t//読み込み\n\tscanf(\"%d %d\",&piles,&fences);\n\tint pilex[piles],piley[piles];\n\tint fencex[fences],fencey[fences];\n\tfor(j=0;j<piles;j++){\n\t\tscanf(\"%d %d\",&pilex[j],&piley[j]);\n\t}\n\tfor(j=0;j<fences;j++){\n\t\tscanf(\"%d %d\",&fencex[j],&fencey[j]);\n\t}\n\n\n\twhile(1){\n\n\t\t//隣接リストを作る\n\t\tint nextto[piles][piles-1];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tfor(j=0;j<piles-1;j++){\n\t\t\t\tnextto[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<piles;i++){\n\t\t\tint counter=0;\n\t\t\tfor(j=0;j<fences;j++){\n\t\t\t\tif(i+1 == fencex[j]){\n\t\t\t\t\tnextto[i][counter] = fencey[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}else if(i+1 == fencey[j]){\n\t\t\t\t\tnextto[i][counter] = fencex[j] - 1;\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\t\t//閉路の検出\n\t\tint circuit[piles];\n\t\tfor(i=0;i<piles;i++){\n\t\t\tcircuit[i] = -1;\n\t\t}\n\n\t\tif(!circuitdetect(piles,nextto,&circuit)){\n\t\t\tbreak;\n\t\t}\n\n\t\t//検出した閉路の中で最小の枝を求める\n\t\tdouble min = 10000000.0;\n\t\tdouble dist = 100000000.0;\n\t\tint mfrom = 0;\n\t\tint mto = 0;\n\t\tint from,to;\n\t\tfor(i=0;i<piles;i++){\n\t\t\tif(circuit[i] == -1){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfrom = circuit[i];\n\t\t\tif(i == piles-1 || circuit[i+1] == -1){\n\t\t\t\tto = circuit[0];\n\t\t\t}else{\n\t\t\t\tto = circuit[i+1];\t\n\t\t\t}\n\t\t\tdist = sqrt(pow(pilex[to] - pilex[from],2.0) + pow(piley[to] - piley[from],2.0));\n\n\t\t\tif(dist  < min){\n\t\t\t\tmin = dist;\n\t\t\t\tmfrom = from;\n\t\t\t\tmto = to;\n\t\t\t}\n\t\t}\n\n\t\t//最小の枝を狩る\n\t\toutput += min;\n\t\tfor(j=0;j<fences;j++){\n\t\t\tif((fencex[j] - 1 == mfrom && fencey[j] - 1 == mto) || (fencex[j] - 1 == mto && fencey[j] - 1 == mfrom)){\n\t\t\t\tfencex[j] = 0;\n\t\t\t\tfencey[j] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\n\t}\n\n\tprintf(\"%f\\n\",output);\n\n\treturn 0;\n}\n\nint circuitdetect(int peaknum,int nextlist[peaknum][peaknum-1],int* retval){\n\tint k,l;\n\tint visited[peaknum];\n\n\tfor(l=0;l<peaknum;l++){\n\t\tvisited[l] = 0;\n\t}\n\n\n\tfor(k=0;k<peaknum;k++){\n\n\t\tif(visited[k] == 0){\n\t\t\tretval[0] = k;\n\t\t\tint nest = 0;\n\t\t\tint value = reflex_search(k,peaknum,nextlist,&visited,nest,retval);\n\t\t\tif(value == 1){\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\tfor(l=0;l<peaknum;l++){\n\t\t\t\t\tretval[l] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\nint reflex_search(int r_k,int r_p,int r_n[r_p][r_p-1],int* r_v,int r_nest,int* r_rv){\n\tr_v[r_k] = 1;\n\tr_nest++;\n\tint m;\n\tfor(m=0;m<r_p-1;m++){\n\t\tif(r_n[r_k][m] != -1){\n\t\t\tif(r_v[r_n[r_k][m]] == 0){\n\t\t\t\tr_rv[r_nest] = r_n[r_k][m]; \n\t\t\t\tint rv = reflex_search(r_n[r_k][m],r_p,r_n,r_v,r_nest,r_rv);\n\t\t\t\tif(rv == 1){\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}else if(r_nest > 1 && r_rv[r_nest-2] != r_n[r_k][m]){\n\t\t\t\treturn 1;\n\t\t\t} \n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\n\t\tEdge(int to, double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tfinal int CONV_CONST = 30010;\n\t\n\tboolean[] visited;\n\tArrayList<Edge>[] g;\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tint convert(int x, int y) {\n\t\treturn Math.max(x, y) * CONV_CONST + Math.min(x, y);\n\t}\n\t\n\tint a, b;\n\tdouble min;\n\t\n\tboolean dfs(int u, int goal, int prev) {\n\t\tif (u == goal && prev != -1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (visited[u]) return false;\n\t\tvisited[u] = true;\n\t\t\n\t\tfor (Edge e : g[u]) {\n\t\t\tif (hash.contains(convert(e.to, u))) continue;\n\t\t\t\n\t\t\tif (prev != e.to && dfs(e.to, goal, u)) {\n\t\t\t\tif (min > e.cost) {\n\t\t\t\t\tmin = e.cost;\n\t\t\t\t\ta = e.to;\n\t\t\t\t\tb = u;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdouble dist = calcDistance(x[from], y[from], x[to], y[to]);\n\t\t\tg[from].add(new Edge(to, dist));\n\t\t\tg[to].add(new Edge(from, dist));\n\t\t}\n\t\t\n\t\tvisited = new boolean[n];\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (true) {\n\t\t\t\ta = -1; b = -1; min = Double.MAX_VALUE;\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\tdfs(i, i, -1);\n\t\t\t\tif (a == -1) break;\n\t\t\t\t\t\n\t\t\t\thash.add(convert(a, b));\n\n\t\t\t\tres += min;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static final int Max = 2<<10;\n\tpublic static int n,m;\n\tpublic static double res;\n\tpublic static double[][] cost,copy;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tcost = new double[Max][];\n\t\tcopy = new double[Max][];\n\t\tint[] x = new int[n+1];\n\t\tint[] y = new int[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tcost[i] = new double[Max];\n\t\t\tcopy[i] = new double[Max];\n\t\t\tArrays.fill(cost[i], 0);\n\t\t\tArrays.fill(copy[i], 0);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tcost[u][v] = cost[v][u] = Math.sqrt(Math.pow((x[u]-x[v]), 2)+Math.pow((y[u]-y[v]), 2));\n\t\t\tres += cost[u][v];\n\t\t}\n\t\tfor (int i = 1; i < n+1; i++) {\n\t\t\tfor (int j = 1; j < n+1; j++) {\n\t\t\t\tcopy[i][j] = cost[i][j];\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tSystem.out.printf(\"%.3f\", res);\n\t\t\n\t}\n\t\n\tpublic static void prim() {\n\t\t\n\t\tdouble[] maxcost = new double[2<<9];\n\t\tboolean[] used = new boolean[2<<9];\n\t\tfor (int i = 0; i < n+1; i++) {\n\t\t\tmaxcost[i] = 0;\n\t\t\tused[i] = false;\n\t\t}\n//\t\tres = 0;\n\t\t\n\t\twhile(true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u < n+1; u++) {\n\t\t\t\tif(!used[u]&&(v==-1||maxcost[u]>maxcost[v])) v = u;\n\t\t\t}\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\n\t\t\tres -= maxcost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u < n+1; u++) {\n\t\t\t\tmaxcost[u] = Math.max(maxcost[u], cost[v][u]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import static java.lang.System.*;\n\nimport java.lang.reflect.Array;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Scanner;\n\nclass Main {\n\n\tstatic final int INF =1<<30;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint id,from,to;\n\t\tdouble cost;\n\t\tEdge(int _id,int _from,int _to,double _cost){\n\t\t\tid=_id;from=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"→\"+to;\n\t\t}\n\t}\n\n\tpublic static class UnionFind{\n\t\tpublic int[] par,rank;\n\t\tpublic int size;\n\t\tpublic UnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t\trank=new int[n];\n\t\t\tsize=n;\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tx=find(x);y=find(y);\n\t\t\tif(x==y)return;\n\n\t\t\tif(rank[x]<rank[y])par[x]=y;\n\t\t\telse par[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t\tsize--;\n\t\t}\n\t}\n\n\n    public static Scanner sc = new Scanner(in);\n    public static Random rand=new Random();\n\n    public void run() {\n    \tint n=sc.nextInt(),m=sc.nextInt();\n\n    \tNode[] ns=new Node[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tns[i]=new Node(i);\n    \tdouble[] px=new double[n],py=new double[n];\n    \tfor(int i=0;i<n;i++){\n    \t\tpx[i]=sc.nextDouble();\n    \t\tpy[i]=sc.nextDouble();\n    \t}\n    \tEdge[] es=new Edge[m];\n    \tfor(int i=0;i<m;i++){\n    \t\tint f=sc.nextInt()-1,t=sc.nextInt()-1;\n    \t\tes[i]=new Edge(i,f,t,Math.sqrt((px[f]-px[t])*(px[f]-px[t])+(py[f]-py[t])*(py[f]-py[t])));\n    \t\tns[f].link.add(es[i]);\n    \t\tns[t].link.add(new Edge(i,t,f,Math.sqrt((px[f]-px[t])*(px[f]-px[t])+(py[f]-py[t])*(py[f]-py[t]))));\n    \t}\n\n    \tboolean[] uses=kruskal(ns, es);\n\n\n    \tdouble res=0;\n    \tfor(int i=0;i<m;i++){\n    \t\tif(!uses[i])res+=es[i].cost;\n    \t}\n\n    \tln(str(res));\n    }\n\n  //O(E*log(V))\n    public static boolean[] kruskal(Node[] graph,Edge[] edge){\n    \tfinal int V=graph.length,E=edge.length;\n    \tUnionFind uf=new UnionFind(V);\n    \tboolean[] use=new boolean[E];\n\n    \tPriorityQueue<Edge> que=new PriorityQueue<Edge>(20,new Comparator<Edge>(){\n    \t\t@Override\n    \t\tpublic int compare(Edge o1, Edge o2) {\n    \t\t\treturn -(int)Math.signum(o1.cost-o2.cost);\n    \t\t}\n    \t});\n    \tfor(int u=0;u<V;u++)for(Edge e : graph[u].link){\n    \t\tif(u<e.to)que.add(e);\n    \t}\n    \twhile(!que.isEmpty()){\n    \t\tEdge e=que.poll();\n    \t\tif(!uf.same(e.from,e.to)){\n    \t\t\tuf.unite(e.from,e.to);\n    \t\t\tuse[e.id]=true;\n    \t\t}\n    \t}\n    \treturn use;\n    }\n\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n\n\t//output lib\n\tstatic final String br = System.getProperty(\"line.separator\");\n\tstatic final String[] asep = new String[] { \"\", \" \", br, br + br };\n\n\tstatic String str(Boolean o) {\n\t\treturn o ? \"YES\" : \"NO\";\n\t}\n\n\t\tstatic String str(Double o){\n\t\t\treturn String.format(\"%.8f\",o);\n\t\t}\n\tstatic <K, V> String str(Map<K, V> map) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (Entry<K, V> set : map.entrySet()) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic <E> String str(Collection<E> list) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tboolean isFirst = true;\n\t\tfor (E e : list) {\n\t\t\tif (!isFirst)\n\t\t\t\tsb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst = false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o) {\n\t\tint depth = _getArrayDepth(o);\n\t\tif (depth > 0)\n\t\t\treturn _strArray(o, depth);\n\t\tClass<?> c = o.getClass();\n\t\tif (c.equals(Boolean.class))\n\t\t\treturn str((Boolean) o);\n\t\tif(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\n\tstatic int _getArrayDepth(Object o) {\n\t\tif (!o.getClass().isArray() || Array.getLength(o) == 0)\n\t\t\treturn 0;\n\t\treturn 1 + _getArrayDepth(Array.get(o, 0));\n\t}\n\n\tstatic String _strArray(Object o, int depth) {\n\t\tif (depth == 0)\n\t\t\treturn str(o);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0, len = Array.getLength(o); i < len; i++) {\n\t\t\tif (i != 0)\n\t\t\t\tsb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o, i), depth - 1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic void pr(Object... os) {\n\t\tboolean isFirst = true;\n\t\tfor (Object o : os) {\n\t\t\tif (!isFirst)\n\t\t\t\tout.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst = false;\n\t\t}\n\t}\n\n\tstatic void ln() {\n\t\tout.println();\n\t}\n\n\tstatic void ln(Object... os) {\n\t\tfor (Object o : os) {\n\t\t\tpr(o);\n\t\t\tln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static IO io = new IO();\n    public static void main(String[] args) {\n\n        int n = io.nextInt();\n        int m = io.nextInt();\n        int px[] = new int[n];\n        int py[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            px[i] = io.nextInt();\n            py[i] = io.nextInt();\n        }\n        double ans = 0;\n        double e[][] = new double[m][3];\n        for (int i = 0; i < m; i++) {\n            int a = io.nextInt()-1;\n            int b = io.nextInt()-1;\n            double c = Math.sqrt((px[a]-px[b])*(px[a]-px[b]) + (py[a]-py[b])*(py[a]-py[b]));\n            ans += c;\n            e[i] = new double[] {a, b, -c};\n        }\n        Kruskal kr = new Kruskal(n, e);\n        // ???????????§?????????????????????????????´???????????§???????????????????????????\n        // (???????????????????????????????????????)-(?????§??¨?????¨?????????????????????)\n        ans += kr.ans;\n        System.out.println(ans);\n    }\n\n    static class Kruskal {\n        double ans;\n        public Kruskal(int n, double adj[][]) {\n            List<Edge> edges = new LinkedList<Edge>();\n            for (double[] anAdj : adj) {\n                edges.add(new Edge(anAdj[0], anAdj[1], anAdj[2]));\n            }\n            ans = kruskal(n, edges);\n        }\n\n        private double kruskal(int n, List<Edge> edges) {\n            UnionFind uni = new UnionFind(n);\n            Queue<Edge> q = new PriorityQueue<Edge>(edges);\n\n            double totalCost = 0;\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (!uni.same((int)e.source, (int)e.target)) {\n                    totalCost += e.cost;\n                    uni.unite((int)e.source, (int)e.target);\n                }\n            }\n            return totalCost;\n        }\n\n        class Edge implements Comparable<Edge> {\n            double source = 0;\n            double target = 0;\n            double cost = 0;\n\n            Edge(double source, double target, double cost) {\n                this.source = source;\n                this.target = target;\n                this.cost = cost;\n            }\n\n            @Override\n            public int compareTo(Edge o) {\n                return (int)Math.ceil(this.cost - o.cost);\n            }\n        }\n\n        class UnionFind {\n            int par[];\n            int rank[];\n\n            UnionFind(int n) {\n                par = new int[n];\n                rank = new int[n];\n                for (int i=0; i<n; i++) par[i]=i;\n            }\n\n            int find(int x) {\n                if (par[x] == x) return x;\n                return par[x] = find(par[x]);\n            }\n\n            Boolean same(int x,int y) {\n                return find(x)==find(y);\n            }\n\n            void unite(int x,int y) {\n                x = find(x);\n                y = find(y);\n                if (x==y) return;\n                if (rank[x]<rank[y]) par[x] = y;\n                else {\n                    par[y]=x;\n                    if (rank[x]==rank[y]) rank[x]++;\n                }\n            }\n        }\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) return true;\n            else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) return false;\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) throw new NumberFormatException();\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n                else throw new NumberFormatException();\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Point[] ps = new Point[n + 1];\n        for (int i = 1; i <= n; i++) {\n            ps[i] = new Point(sc.nextInt(), sc.nextInt());\n        }\n        PriorityQueue<Fenth> q = new PriorityQueue<Fenth>();\n        double ans = 0;\n\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            double dis = Math.hypot(ps[a].x - ps[b].x, ps[a].y - ps[b].y);\n            q.add(new Fenth(a, b, dis));\n            ans += dis;\n        }\n        UnionFind uf = new UnionFind(n + 1);\n        while (!q.isEmpty()) {\n            Fenth f = q.poll();\n            int a = f.from;\n            int b = f.to;\n            if (uf.same(a, b))\n                continue;\n            uf.unite(a, b);\n            ans -= f.length;\n        }\n        System.out.printf(\"%.4f\\n\", ans);\n    }\n}\n\nclass Fenth implements Comparable<Fenth> {\n    int from;\n    int to;\n    double length;\n\n    Fenth(int from, int to, double length) {\n        this.from = from;\n        this.to = to;\n        this.length = length;\n    }\n\n    public int compareTo(Fenth f) {\n        return (int) (f.length - length);\n    }\n\n    public String toString() {\n        return \"from,to,length\" + from + \" \" + to + \" \" + length;\n    }\n}\n\nclass UnionFind {\n    int par[];\n    int rank[];\n\n    UnionFind(int n) {\n        par = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (x == par[x])\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\n    public void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return;\n        if (rank[x] > rank[y])\n            par[y] = x;\n        else {\n            par[x] = y;\n            if (rank[x] == rank[y])\n                rank[y]++;\n        }\n    }\n\n    public boolean same(int x, int y) {\n        return find(x) == find(y);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\n\t\tEdge(int to, double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tfinal int CONV_CONST = 10010;\n\t\n\tboolean[] visited;\n\tArrayList<Edge>[] g;\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tint convert(int x, int y) {\n\t\treturn Math.max(x, y) * CONV_CONST + Math.min(x, y);\n\t}\n\t\n\tint a, b;\n\tdouble min;\n\t\n\tboolean dfs(int u, int goal, int prev) {\n\t\tif (u == goal && prev != -1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (visited[u]) return false;\n\t\tvisited[u] = true;\n\t\t\n\t\tfor (Edge e : g[u]) {\n\t\t\tif (hash.contains(convert(e.to, u))) continue;\n\t\t\t\n\t\t\tif (prev != e.to && dfs(e.to, goal, u)) {\n\t\t\t\tif (min > e.cost) {\n\t\t\t\t\tmin = e.cost;\n\t\t\t\t\ta = e.to;\n\t\t\t\t\tb = u;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdouble dist = calcDistance(x[from], y[from], x[to], y[to]);\n\t\t\tg[from].add(new Edge(to, dist));\n\t\t\tg[to].add(new Edge(from, dist));\n\t\t}\n\t\t\n\t\tvisited = new boolean[n];\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (true) {\n\t\t\t\ta = -1; b = -1; min = Double.MAX_VALUE;\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\tdfs(i, i, -1);\n\t\t\t\tif (a == -1) break;\n\t\t\t\t\t\n\t\t\t\thash.add(convert(a, b));\n\n\t\t\t\tres += min;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\tif(e2.cost > e1.cost) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(e2.cost < e1.cost){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tdouble mainasu_sum=0;\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n//\t\tSystem.out.println(\"mainasu: \" + mainasu_sum);\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tmainasu_sum -= tmp.cost;\n//\t\t\t\tSystem.out.println(\"tmp: \" + tmp.cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mainasu_sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t\tfor (int i:par) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn (int)e2.cost - (int)e1.cost;\n\t\t\t}\n\t\t});\n\t\tPriorityQueue<Edge> edge_not_ans = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn (int)e2.cost - (int)e1.cost;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tsum += tmp.cost;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Edge1{\n    int u;\n    int v;\n    double cost;\n    public Edge1(int u, int v, double cost){\n        this.u = u;\n        this.v = v;\n        this.cost = cost;\n    }\n}\npublic class Main {\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        int[] x = new int[n];\n        int[] y = new int[n];\n        Edge1[] edges = new Edge1[m];\n        for(int i=0; i<n; i++){\n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n        double res = 0;\n        for(int i=0; i<m; i++){\n            int u = sc.nextInt()-1;\n            int v = sc.nextInt()-1;\n            double dis = Math.sqrt(Math.pow(x[u]-x[v], 2)+Math.pow(y[u]-y[v], 2));\n            res += dis;\n            edges[i] = new Edge1(u, v, dis);\n        }\n        Arrays.sort(edges, new Comparator<Edge1>() {\n            @Override\n            public int compare(Edge1 o1, Edge1 o2) {\n                if(o2.cost>o1.cost) return 1;\n                else if(o2.cost<o1.cost) return -1;\n                return 0;\n            }\n        });\n        int[] parent = new int[n];\n        int[] rank = new int[n];\n        for(int i=0; i<n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n        double cur_res = 0;\n        for(int i=0; i<m; i++){\n            Edge1 e = edges[i];\n            if(!same(e.u, e.v, parent)){\n                unite(e.u, e.v, parent, rank);\n                cur_res += e.cost;\n            }\n        }\n        System.out.println(res-cur_res);\n    }\n    public static boolean same(int u, int v, int[] parent){\n        int pu = find(u, parent);\n        int pv = find(v, parent);\n        if(pu == pv)return true;\n        return false;\n    }\n    public static int find(int v, int[] parent){\n        if(parent[v] == v) return v;\n        return parent[v] = find(parent[v], parent);\n    }\n    public static void unite(int u, int v, int[] parent, int[] rank){\n        int pu = find(u, parent);\n        int pv = find(v, parent);\n        if(pu==pv) return;\n        if(rank[pu]<rank[pv]){\n            parent[pu] = pv;\n        }\n        else{\n            parent[pv] = pu;\n            if(rank[pu] == rank[pv]) rank[pu]++;\n        }\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\t\n\t\n\tclass Edge implements Comparable<Edge> {\n\t\tint from, to;\n\t\tdouble cost;\n\n\t\tEdge(int from, int to, double cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tpublic int compareTo(Edge s) {\n\t\t\treturn Double.compare(s.cost, cost);\n\t\t}\n\t}\n\n\tclass UnionFindTree {\n\t\tint[] parent;\n\t\t\n\t\tpublic UnionFindTree(int n) {\n\t\t\tparent = new int[n];\n\t\t\tfor (int i = 0; i < parent.length; i++) {\n\t\t\t\tparent[i] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int find(int x) {\n\t\t\tif (parent[x] == x) return x;\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t\t\n\t\tpublic boolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t\t\n\t\tpublic void unite(int x, int y) {\n\t\t\tint xx = find(x), yy = find(y);\n\t\t\tif (xx == yy) return;\n\t\t\tparent[xx] = yy;\n\t\t}\n\t}\n\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tPriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tpq.add(new Edge(from, to, calcDistance(x[from], y[from], x[to], y[to])));\n\t\t}\n\t\t\n\t\tUnionFindTree uft = new UnionFindTree(n);\n\t\t\n\t\tdouble res = 0;\n\t\twhile (!pq.isEmpty()) {\n\t\t\tEdge e = pq.poll();\n\t\t\t\n\t\t\tif (!uft.same(e.to, e.from)) {\n\t\t\t\tuft.unite(e.to, e.from);\n\t\t\t} else {\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\t\n\t/* MLE... Why?\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\n\t\tEdge(int to, double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tfinal int CONV_CONST = 30010;\n\t\n\tboolean[] visited;\n\tArrayList<Edge>[] g;\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tint convert(int x, int y) {\n\t\treturn Math.max(x, y) * CONV_CONST + Math.min(x, y);\n\t}\n\t\n\tint a, b;\n\tdouble min;\n\t\n\tboolean dfs(int u, int goal, int prev) {\n\t\tif (u == goal && prev != -1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (visited[u]) return false;\n\t\tvisited[u] = true;\n\t\t\n\t\tfor (Edge e : g[u]) {\n\t\t\tif (hash.contains(convert(e.to, u))) continue;\n\t\t\t\n\t\t\tif (prev != e.to && dfs(e.to, goal, u)) {\n\t\t\t\tif (min > e.cost) {\n\t\t\t\t\tmin = e.cost;\n\t\t\t\t\ta = e.to;\n\t\t\t\t\tb = u;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdouble dist = calcDistance(x[from], y[from], x[to], y[to]);\n\t\t\tg[from].add(new Edge(to, dist));\n\t\t\tg[to].add(new Edge(from, dist));\n\t\t}\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum += g[i].size();\n\t\t}\n\t\tSystem.out.println(sum);\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (true) {\n\t\t\t\ta = -1; b = -1; min = Double.MAX_VALUE;\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\tdfs(i, i, -1);\n\t\t\t\tif (a == -1) break;\n\t\t\t\t\t\n\t\t\t\thash.add(convert(a, b));\n\n\t\t\t\tres += min;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(hash.size());\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\t*/\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tdouble[][] cost = new double[n][n];\n\t\tfor(int i=0;i<n;i++) Arrays.fill(cost[i], -1);\n\t\tdouble all = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint p = sc.nextInt()-1;\n\t\t\tint q = sc.nextInt()-1;\n\t\t\tdouble c = Math.sqrt((y[p]-y[q])*(y[p]-y[q])+(x[p]-x[q])*(x[p]-x[q]));\n\t\t\tcost[p][q] = c;\n\t\t\tcost[q][p] = c;\n\t\t\tall += c;\n\t\t}\n\t\n\t\tboolean[] f = new boolean[n];\n\t\tdouble sum = 0;\n\t\tint r = 0;\n\t\twhile(true){\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!f[i]){\n\t\t\t\t\tf[i] = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) break;\n\n\t\t\twhile(true){\n\t\t\t\tdouble t = -1;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(f[i]){\n\t\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\t\tif(!f[j] && t<cost[i][j]){\n\t\t\t\t\t  \t\t\tt = cost[i][j];\n\t\t\t\t\t\t\t\tr = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(t==-1) break;\n\t\t\t\tf[r] = true;\n\t\t\t\tsum += t;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(all-sum);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\tif(e2.cost > e1.cost) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(e2.cost < e1.cost){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n//\t\tSystem.out.println(\"mainasu: \" + mainasu_sum);\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tsum += tmp.cost;\n//\t\t\t\tSystem.out.println(\"tmp: \" + tmp.cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\n\t\tEdge(int to, double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tfinal int CONV_CONST = 10010;\n\t\n\tboolean[] visited;\n\tArrayList<Edge>[] g;\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tint convert(int x, int y) {\n\t\treturn x * CONV_CONST + y;\n\t}\n\t\n\tint a, b;\n\tdouble min;\n\t\n\tboolean dfs(int u, int goal, int prev) {\n\t\tif (u == goal && prev != -1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (visited[u]) return false;\n\t\tvisited[u] = true;\n\t\t\n\t\tfor (Edge e : g[u]) {\n\t\t\tif (hash.contains(convert(e.to, u))) continue;\n\t\t\t\n\t\t\tif (prev != e.to && dfs(e.to, goal, u)) {\n\t\t\t\tif (min > e.cost) {\n\t\t\t\t\tmin = e.cost;\n\t\t\t\t\ta = e.to;\n\t\t\t\t\tb = u;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdouble dist = calcDistance(x[from], y[from], x[to], y[to]);\n\t\t\tg[from].add(new Edge(to, dist));\n\t\t\tg[to].add(new Edge(from, dist));\n\t\t}\n\t\t\n\t\tvisited = new boolean[n];\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (true) {\n\t\t\t\ta = -1; b = -1; min = Double.MAX_VALUE;\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\tdfs(i, i, -1);\n\t\t\t\tif (a == -1) break;\n\t\t\t\t\t\n\t\t\t\thash.add(convert(a, b));\n\t\t\t\thash.add(convert(b, a));\n\n\t\t\t\tres += min;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();//the number of piles\n\t\tint m=sc.nextInt();//the number of fences\n\t\tdouble[] x=new double[n];\n\t\tdouble[] y=new double[n];\n\t\tdouble sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=sc.nextDouble();\n\t\t\ty[i]=sc.nextDouble();\n\t\t}\n\t\tKruskal kl=new Kruskal(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from=sc.nextInt()-1;\n\t\t\tint to=sc.nextInt()-1;\n\t\t\tdouble d=Math.sqrt((x[from]-x[to])*(x[from]-x[to])+(y[from]-y[to])*(y[from]-y[to]));\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tsum+=d;\n\t\t}\n\t\tdouble total=kl.get_minimum_spanning_tree();\n\t\tSystem.out.println(sum-total);\n\t}\n\n\tclass Kruskal{\n\t\tint n;//the number of vertices\n\t\tdouble weight_sum=-1;\n\t\tList<Edge>[] edges;//adjacency list\n\t\tPriorityQueue<Edge> pq;\n\t\tKruskal(int n){\n\t\t\tthis.n=n;\n\t\t\tedges=new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tedges[i]=new ArrayList<Edge>();\n\t\t\t}\n\t\t\tpq=new PriorityQueue<Edge>();\n\t\t}\n\n\t\tdouble get_minimum_spanning_tree(){\n\t\t\tDJSet ds=new DJSet(n);\n\t\t\tweight_sum=0;\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tEdge e=pq.poll();\n\t\t\t\tif(ds.same(e.from, e.to))continue;\n\t\t\t\tweight_sum+=e.cost;\n\t\t\t\tds.setUnion(e.from, e.to);\n\t\t\t}\n\t\t\tif(ds.size(0)!=n)return -1;\n\t\t\telse return weight_sum;\n\t\t}\n\t\tvoid addEdge(int from,int to,double cost){\n\t\t\tedges[from].add(new Edge(from,to,cost));\n\t\t\tpq.add(new Edge(from,to,cost));\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tint from;\n\t\tint to;\n\t\tdouble cost;\n\t\tEdge(int from,int to,double cost){\n\t\t\tthis.from=from;\n\t\t\tthis.to=to;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn this.cost>o.cost?-1:this.cost<o.cost?1:0;\n\t\t}\n\t}\n\tclass DJSet{\n\t\tint n;//the number of vertices\n\t\tint[] d;\n\t\tDJSet(int n){\n\t\t\tthis.n=n;\n\t\t\td=new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn d[x]<0?x:root(d[x]);\n\t\t}\n\t\tboolean setUnion(int x,int y){\n\t\t\tx=root(x);\n\t\t\ty=root(y);\n\t\t\tif(x!=y){\n\t\t\t\tif(x<y){\n\t\t\t\t\tint d=x;\n\t\t\t\t\tx=y;\n\t\t\t\t\ty=d;\n\t\t\t\t}\n\t\t\t\t//x>y\n\t\t\t\td[y]+=d[x];\n\t\t\t\td[x]=y;\n\t\t\t}\n\t\t\treturn x!=y;\n\t\t}\n\t\tboolean same(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint size(int x){\n\t\t\treturn d[root(x)]*(-1);\n\t\t}\n\t}\n\n\n\tvoid tr(Object...objects){System.out.println(Arrays.deepToString(objects));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn (int)e2.cost - (int)e1.cost;\n\t\t\t}\n\t\t});\n\t\tPriorityQueue<Edge> edge_not_ans = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn (int)e2.cost - (int)e1.cost;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tsum += tmp.cost;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint M = in.nextInt();\n\t\tint[] x = new int[N];\n\t\tint[] y = new int[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tdouble ans = 0;\n\t\tint[][] e = new int[M][];\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tint p = in.nextInt();\n\t\t\tint q = in.nextInt();\n\t\t\tint dx = x[p - 1] - x[q - 1];\n\t\t\tint dy = y[p - 1] - y[q - 1];\n\t\t\tint d2 = dx * dx + dy * dy;\n\t\t\te[j] = new int[]{p - 1, q - 1, d2};\n\t\t\tans += Math.sqrt(d2);\n\t\t}\n\t\t\n\t\tComparator<int[]> cmp = new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn b[2] - a[2];\n\t\t\t}\n\t\t};\n\t\tArrays.sort(e, cmp);\n\t\t\n\t\tDisjointSetForest dsf = new DisjointSetForest(N);\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tint v = e[j][0];\n\t\t\tint w = e[j][1];\n\t\t\tint d2 = e[j][2];\n\t\t\tif (dsf.find(v) != dsf.find(w)) {\n\t\t\t\tdsf.union(v, w);\n\t\t\t\tans -= Math.sqrt(d2);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n\nclass DisjointSetForest {\n\tint[] parent;\n\tint[] rank;\n\t\n\tDisjointSetForest(int n) {\n\t\tparent = new int[n];\n\t\tArrays.fill(parent, -1);\n\t\trank = new int[n];\n\t}\n\t\n\tint find(int x) {\n\t\tif (parent[x] == -1) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tvoid union(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tparent[x] = y;\n\t\t\t} else {\n\t\t\t\tparent[y] = x;\n\t\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static IO io = new IO();\n    public static void main(String[] args) {\n\n        int n = io.nextInt();\n        int m = io.nextInt();\n        int px[] = new int[n];\n        int py[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            px[i] = io.nextInt();\n            py[i] = io.nextInt();\n        }\n        double ans = 0;\n        double e[][] = new double[m][3];\n        for (int i = 0; i < m; i++) {\n            int a = io.nextInt()-1;\n            int b = io.nextInt()-1;\n            double c = Math.sqrt((px[a] - px[b])*(px[a]-px[b]) + (py[a]-py[b])*(py[a]-py[b]));\n            ans += c;\n            e[i] = new double[] {a, b, -c};\n        }\n        Kruskal kr = new Kruskal(n, e);\n        ans += kr.ans;\n        System.out.println(ans);\n    }\n\n    static class Kruskal {\n        double ans;\n        // ?????????????????????\n        public Kruskal(int n, double adj[][]) {\n            List<Edge> edges = new LinkedList<Edge>();    //???????????±\n            for (double[] anAdj : adj) {\n                edges.add(new Edge(anAdj[0], anAdj[1], anAdj[2]));\n            }\n\n            ans = kruskal(n, edges);\n        }\n\n        // ??????????????????\n        private double kruskal(int n, List<Edge> edges) {\n            UnionFind uni = new UnionFind(n);  //??????????????¨\n            Queue<Edge> q = new PriorityQueue<Edge>(edges);\n\n            double totalCost = 0;\t//????°???¨?????¨?????????\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (!uni.same((int)e.source, (int)e.target)) {\n                    totalCost += e.cost;\n                    uni.unite((int)e.source, (int)e.target);\n                }\n            }\n\n            return totalCost;\n        }\n\n        //????????±????§???????\n        class Edge implements Comparable<Edge> {\n            double source = 0;\t//??\\?¶?????????????\n            double target = 0;\t//??\\?¶?????????????\n            double cost = 0;\t//??????\n\n            Edge(double source, double target, double cost) {\n                this.source = source;\n                this.target = target;\n                this.cost = cost;\n            }\n\n            @Override\n            public int compareTo(Edge o) {\n                return (int)Math.ceil(this.cost - o.cost);\n            }\n\n            @Override\n            public String toString() {  //???????????°??¨\n                return \"source = \" + source + \", target = \" + target + \", cost = \" + cost;\n            }\n        }\n\n        class UnionFind {\n            int par[];\t// i??????(parent)\n            int rank[];\t// i?????±???\n\n            // ????????????????????? n????´???§?????????\n            UnionFind(int n) {\n                par = new int[n];\n                rank = new int[n];\n                for (int i=0; i<n; i++) par[i]=i;\n            }\n\n            // ??¨??????????±???????\n            int find(int x) {\n                if (par[x] == x) return x;\n                return par[x] = find(par[x]);\n            }\n\n            // x??¨y???????????????????±????????????????\n            Boolean same(int x,int y) {\n                return find(x)==find(y);\n            }\n\n            // x??¨y????±??????????????????????\n            void unite(int x,int y) {\n                x = find(x);\n                y = find(y);\n                if (x==y) return;\n                if (rank[x]<rank[y]) par[x] = y;\n                else {\n                    par[y]=x;\n                    if (rank[x]==rank[y]) rank[x]++;\n                }\n            }\n\n        }\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) return true;\n            else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) return false;\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        long nextLong() {\n            if (!hasNext()) throw new NoSuchElementException();\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) throw new NumberFormatException();\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) return minus ? -n : n;\n                else throw new NumberFormatException();\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();\n            return (int) nl;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException ignored) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t\tfor (int i:par) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n//\t\tSystem.out.println(\"befo\" + par[x]);\n\t\tpar[x]=y;\n//\t\tSystem.out.println(\"after\" + par[x]);\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint x, y;\n\t\tint p, q;\n\t\tint fence[][] = new int[M][2];\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tx = scan.nextInt();\n\t\t\ty = scan.nextInt();\n\t\t\tcoordinate[i][0] = x;\n\t\t\tcoordinate[i][1] = y;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\tfence[i][0] = p;\n\t\t\tfence[i][1] = q;\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t}\n//\t\t大きい順にソート\n\t\tdouble tmp;\n\t\tint tmp2, tmp3;\n\t\tfor(int i = 0; i< M; i++) {\n\t\t\tfor(int j = 0; j < M;j++) {\n\t\t\t\tif(hypotenuse[i] > hypotenuse[j]) {\n\t\t\t\t\ttmp = hypotenuse[i];\n\t\t\t\t\thypotenuse[i] = hypotenuse[j];\n\t\t\t\t\thypotenuse[j] = tmp;\n\t\t\t\t\ttmp2 = fence[i][0];\n\t\t\t\t\ttmp3 = fence[j][0];\n\t\t\t\t\tfence[i][0] = fence[i][1];\n\t\t\t\t\tfence[j][0] = fence[j][1];\n\t\t\t\t\tfence[i][1] = tmp2;\n\t\t\t\t\tfence[j][1] = tmp3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i=0; i < M;i++) {\n\t\t\tif (!unionfindSame(par[fence[i][0]], par[fence[i][1]])) {\n\t\t\t\tunionfinUnite(par[fence[i][0]], par[fence[i][1]]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsum += hypotenuse[i];\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\tif(e2.cost > e1.cost) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(e2.cost < e1.cost){\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n//\t\tSystem.out.println(\"mainasu: \" + mainasu_sum);\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tsum += tmp.cost;\n//\t\t\t\tSystem.out.println(\"tmp: \" + tmp.cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();//the number of piles\n\t\tint m=sc.nextInt();//the number of fences\n\t\tdouble[] x=new double[n];\n\t\tdouble[] y=new double[n];\n\t\tdouble sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=sc.nextDouble();\n\t\t\ty[i]=sc.nextDouble();\n\t\t}\n\t\tKruskal kl=new Kruskal(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from=sc.nextInt()-1;\n\t\t\tint to=sc.nextInt()-1;\n\t\t\tdouble d=Math.sqrt((x[from]-x[to])*(x[from]-x[to])+(y[from]-y[to])*(y[from]-y[to]));\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tsum+=d;\n\t\t}\n\t\tdouble total=kl.get_minimum_spanning_tree();\n\t\tSystem.out.println(sum-total);\n\t}\n\n\tclass Kruskal{\n\t\tint n;//the number of vertices\n\t\tdouble weight_sum=-1;\n\t\tList<Edge>[] edges;//adjacency list\n\t\tPriorityQueue<Edge> pq;\n\t\tKruskal(int n){\n\t\t\tthis.n=n;\n\t\t\tedges=new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tedges[i]=new ArrayList<Edge>();\n\t\t\t}\n\t\t\tpq=new PriorityQueue<Edge>();\n\t\t}\n\n\t\tdouble get_minimum_spanning_tree(){\n\t\t\tDJSet ds=new DJSet(n);\n\t\t\tweight_sum=0;\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tEdge e=pq.poll();\n\t\t\t\tif(ds.same(e.from, e.to))continue;\n\t\t\t\tweight_sum+=e.cost;\n\t\t\t\tds.setUnion(e.from, e.to);\n\t\t\t}\n\t\t\tif(ds.size(0)!=n)return -1;\n\t\t\telse return weight_sum;\n\t\t}\n\t\tvoid addEdge(int from,int to,double cost){\n\t\t\tedges[from].add(new Edge(from,to,cost));\n\t\t\tpq.add(new Edge(from,to,cost));\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tint from;\n\t\tint to;\n\t\tdouble cost;\n\t\tEdge(int from,int to,double cost){\n\t\t\tthis.from=from;\n\t\t\tthis.to=to;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn this.cost>o.cost?-1:this.cost<o.cost?1:0;\n\t\t}\n\t}\n\tclass DJSet{\n\t\tint n;//the number of vertices\n\t\tint[] d;\n\t\tDJSet(int n){\n\t\t\tthis.n=n;\n\t\t\td=new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn d[x]<0?x:root(d[x]);\n\t\t}\n\t\tboolean setUnion(int x,int y){\n\t\t\tx=root(x);\n\t\t\ty=root(y);\n\t\t\tif(x!=y){\n\t\t\t\tif(x<y){\n\t\t\t\t\tint d=x;\n\t\t\t\t\tx=y;\n\t\t\t\t\ty=d;\n\t\t\t\t}\n\t\t\t\t//x>y\n\t\t\t\td[y]+=d[x];\n\t\t\t\td[x]=y;\n\t\t\t}\n\t\t\treturn x!=y;\n\t\t}\n\t\tboolean same(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint size(int x){\n\t\t\treturn d[root(x)]*(-1);\n\t\t}\n\t}\n\n\n\tvoid tr(Object...objects){System.out.println(Arrays.deepToString(objects));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\tfinal int MIN = -100000;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tfloat[][] cost = new float[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tcost[i][j] = MIN;\n\n\t\tfloat[] mincost = new float[n + 1];\n\t\tboolean[] used = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tmincost[i] = MIN;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble c = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost[p][q] = cost[q][p] = (float)c;\n\t\t}\n//\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\tSystem.out.print((cost[i][j] == MIN ? \"X\" : (int)cost[i][j]) + \" \");\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tmincost[1] = 0;\n\t\tdouble res = 0;\n\t\t\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] > mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t\n\t\t\tif (v == -1)\n\t\t\t\tbreak;\n\n\t\t\tused[v] = true;\n\t\t\tif (mincost[v] != MIN)\n\t\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tmincost[u] = Math.max(mincost[u], cost[v][u]);\n\t\t}\n\t\tSystem.out.printf(\"%.3f\", sum - res);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\tfinal int MIN = -100000;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tdouble[][] cost = new double[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tcost[i][j] = MIN;\n\n\t\tdouble[] mincost = new double[n + 1];\n\t\tboolean[] used = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tmincost[i] = MIN;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble c = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost[p][q] = cost[q][p] = c;\n\t\t}\n//\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\tSystem.out.print((cost[i][j] == MIN ? \"X\" : (int)cost[i][j]) + \" \");\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tmincost[1] = 0;\n\t\tdouble res = 0;\n\t\t\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] > mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t\n\t\t\tif (v == -1)\n\t\t\t\tbreak;\n\n\t\t\tused[v] = true;\n\t\t\tif (mincost[v] != MIN)\n\t\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tmincost[u] = Math.max(mincost[u], cost[v][u]);\n\t\t}\n\t\tSystem.out.printf(\"%.3f\", sum - res);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Save your cat\npublic class Main{\n\t\n\tclass UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\t\n\tclass E implements Comparable<E>{\n\t\tint s, t;\n\t\tdouble d;\n\t\tpublic E(int s, int t, double d) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn (int)Math.signum(o.d-d);\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tint[] x = new int[n+1], y = new int[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tx[i] = sc.nextInt(); y[i] = sc.nextInt();\n\t\t}\n\t\tE[] es = new E[m];\n\t\tdouble sum = 0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s = sc.nextInt(), t = sc.nextInt();\n\t\t\tdouble d = Math.hypot(x[s]-x[t], y[s]-y[t]);\n\t\t\tsum+=d;\n\t\t\tes[i] = new E(s, t, d);\n\t\t}\n\t\tArrays.sort(es);\n\t\tUnionFind u = new UnionFind(n+1);\n\t\tdouble res = 0;\n\t\tfor(E e:es){\n\t\t\tif(u.find(e.s, e.t))continue;\n\t\t\tres+=e.d;\n\t\t\tu.union(e.s, e.t);\n\t\t}\n\t\tSystem.out.printf(\"%.8f\\n\", sum-res);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.awt.Point;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\tString[] tmpArray = br.readLine().split(\" \");\n\n\t\t//0 origin\n\t\tint n = Integer.parseInt(tmpArray[0]);\n\t\tint m = Integer.parseInt(tmpArray[1]);\n\n\t\tEdge edges[] = new Edge[m];\n\n\t\tdouble sumOfLength = 0;\n\n\t\tPoint points[] = new Point[n];\n\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ttmpArray = br.readLine().split(\" \");\n\t\t\tint x = Integer.parseInt(tmpArray[0]);\n\t\t\tint y = Integer.parseInt(tmpArray[1]);\n\n\t\t\tpoints[i] = new Point(x, y);\n\t\t}\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\ttmpArray = br.readLine().split(\" \");\n\t\t\tint from = Integer.parseInt(tmpArray[0]) - 1;\n\t\t\tint to = Integer.parseInt(tmpArray[1]) - 1;\n\t\t\tdouble cost = points[from].distance(points[to]);\n\n\t\t\tedges[i] = new Edge(from,to, cost);\n\n\t\t\tsumOfLength += cost;\n\t\t}\n\n\t\tSystem.out.printf(\"%.3f\\n\", sumOfLength - kruskal(edges, n));\n\t}\n\n\n\tstatic final int INF = Integer.MAX_VALUE;\n\n\n\tstatic double kruskal(Edge[] edges, int n){\n\t\tint numOfEdge = edges.length;\n\n\t\tArrays.sort(edges);\n\n\t\tDisjointSet set = new DisjointSet(n);\n\n\t\tdouble result = 0;\n\n\t\tfor(int i = 0; i < numOfEdge ; i++){\n\t\t\tEdge tmpEdge = edges[i];\n\n\t\t\tif(!set.isSameSet(tmpEdge.from, tmpEdge.to)){\n\t\t\t\tset.union(tmpEdge.from, tmpEdge.to);\n\t\t\t\tresult += tmpEdge.cost;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\n\t}\n}\n\nclass DisjointSet {\n    private int n;\n    private int[] p;\n    private int[] rank;\n\n    public DisjointSet(int n){\n        this.n = n;\n\n        p = new int[n + 1];\n        rank = new int[n + 1];\n\n        for(int i = 1; i <= n; i++){\n            makeSet(i);\n        }\n    }\n\n    private void makeSet(int x){\n        p[x] = x;\n        rank[x] = 0;\n    }\n\n    public void union(int x, int y){\n        link (findSet(x), findSet(y));\n    }\n\n    private int findSet(int x){\n        if(x != p[x]){\n            p[x] = findSet( p[x]);\n        }\n        return p[x];\n    }\n\n    public boolean isSameSet(int x, int y){\n        return findSet(x) == findSet(y);\n    }\n\n    private void link(int x, int y){\n        if(rank[x] > rank[y]){\n            p[y] = x;\n        }\n        else {\n            p[x] = y;\n            if(rank[x] == rank[y]){\n                rank[y]++;\n            }\n        }\n    }\n}\n\nclass Edge implements Comparable<Edge>{\n\tint from;\n\tint to;\n\tdouble cost;\n\n\tEdge(int from, int to, double cost){\n\t\tthis.from = from;\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\t//長い順に並ぶように\n\t@Override\n\tpublic int compareTo(Edge e) {\n\t\treturn this.cost == e.cost ? 0 : (this.cost < e.cost ? 1 : -1);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\tif(e2.cost > e1.cost) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\telse if(e2.cost == e1.cost){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tdouble mainasu_sum=0;\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n\t\tSystem.out.println(\"mainasu: \" + mainasu_sum);\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tmainasu_sum -= tmp.cost;\n\t\t\t\tSystem.out.println(\"tmp: \" + tmp.cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mainasu_sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\t}\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tPriorityQueue<Edge> edges = new PriorityQueue<>();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = sc.nextInt() - 1;\n\t\t\tint q = sc.nextInt() - 1;\n\t\t\tedges.add(new Edge(p, q, (x[p] - x[q]) * (x[p] - x[q]) + (y[p] - y[q]) * (y[p] - y[q])));\n\t\t}\n\t\tSystem.out.println(MST(edges,n));\n\t}\n\n\tdouble MST(PriorityQueue<Edge> edges,int n) {\n\t\tDJSet ds = new DJSet(n);\n\t\tdouble ans = 0;\n\t\twhile (!edges.isEmpty()) {\n\t\t\tEdge e = edges.poll();\n\t\t\tif (!ds.same(e.dst, e.src)) {\n\t\t\t\tds.setUnion(e.dst, e.src);\n\t\t\t} else {\n\t\t\t\tans += Math.sqrt(e.weight);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint src;\n\t\tint dst;\n\t\tlong weight;\n\n\t\tEdge(int src, int dst, long weight) {\n\t\t\tthis.src = src;\n\t\t\tthis.dst = dst;\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn -Long.compare(this.weight, o.weight);\n\t\t}\n\t}\n\n\tclass DJSet {\n\t\tint n;\n\t\tint[] s;\n\n\t\tpublic DJSet(int n) {\n\t\t\tthis.n = n;\n\t\t\ts = new int[n];\n\t\t\tArrays.fill(s, -1);\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (s[x] < 0) {\n\t\t\t\treturn x;\n\t\t\t} else {\n\t\t\t\treturn find(s[x]);\n\t\t\t}\n\t\t}\n\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tboolean setUnion(int x, int y) {\n\t\t\tif (find(x) != find(y)) {\n\t\t\t\tx = find(x);\n\t\t\t\ty = find(y);\n\t\t\t\tif (count(x) < count(y)) {\n\t\t\t\t\tint tmp = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = tmp;\n\t\t\t\t}\n\t\t\t\ts[x] += s[y];\n\t\t\t\ts[y] = x;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tint count(int x) {\n\t\t\treturn -s[find(x)];\n\t\t}\n\n\t\tint size() {\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (s[i] < 0) {\n\t\t\t\t\tcount += -s[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn count;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\t\tint[][] kui = new int[2][n];\n\t\tGroup[] groups = new Group[n];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tkui[0][i] = scan.nextInt();\n\t\t\tkui[1][i] = scan.nextInt();\n\t\t\tgroups[i] = new Group();\n\t\t}\n\t\tdouble allLen = 0.0;\n\t\tQueue<Branch> q = new PriorityQueue<>();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint e1 = scan.nextInt()-1;\n\t\t\tint e2 = scan.nextInt()-1;\n\t\t\tint _w = kui[0][e1] - kui[0][e2];\n\t\t\tint _h = kui[1][e1] - kui[1][e2];\n\t\t\tdouble len = Math.sqrt(_w*_w+_h*_h);\n\t\t\tq.add(new Branch(e1,e2,len));\n\t\t\tallLen += len;\n\t\t}\n\t\tdouble resultLen = 0.0;\n\t\twhile(!q.isEmpty()) {\n\t\t\tBranch _b = q.poll();\n\t\t\t//System.out.println(_b.len);\n\t\t\tGroup g1 = groups[_b.e1].getGroup();\n\t\t\tGroup g2 = groups[_b.e2].getGroup();\n\t\t\tif(g1==g2) continue;\n\t\t\tGroup ng = new Group();\n\t\t\tg1.parent = ng;\n\t\t\tg2.parent = ng;\n\t\t\tresultLen += _b.len;\n\t\t}\n\t\tSystem.out.println(allLen-resultLen);\n\t}\n}\n\nclass Group{\n\tGroup parent;\n\tGroup(){}\n\tGroup getGroup() {\n\t\treturn (parent==null)?this:parent.getGroup();\n\t}\n}\n\nclass Branch implements Comparable<Branch> {\n\tint e1,e2;\n\tdouble len;\n\tBranch(int _e1, int _e2, double _len) {\n\t\te1 = _e1;\n\t\te2 = _e2;\n\t\tlen = _len;\n\t}\n\t@Override\n\tpublic int compareTo(Branch _b) {\n\t\treturn (_b.len - this.len>0.0)?1:-1;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t\tfor (int i:par) {\n\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn (int)e2.cost - (int)e1.cost;\n\t\t\t}\n\t\t});\n\t\tPriorityQueue<Edge> edge_not_ans = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn (int)e2.cost - (int)e1.cost;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tsum += tmp.cost;\n\t\t\t\tSystem.out.println(\"tmp.cost: \" + tmp.cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class SaveYourCat {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\n\t\tEdge(int to, double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tfinal int CONV_CONST = 10010;\n\t\n\tboolean[] visited;\n\tArrayList<Edge>[] g;\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tint convert(int x, int y) {\n\t\treturn Math.max(x, y) * CONV_CONST + Math.min(x, y);\n\t}\n\t\n\tint a, b;\n\tdouble min;\n\t\n\tboolean dfs(int u, int goal, int prev) {\n\t\tif (u == goal && prev != -1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (visited[u]) return false;\n\t\tvisited[u] = true;\n\t\t\n\t\tfor (Edge e : g[u]) {\n\t\t\tif (hash.contains(convert(e.to, u))) continue;\n\t\t\t\n\t\t\tif (prev != e.to && dfs(e.to, goal, u)) {\n\t\t\t\tif (min > e.cost) {\n\t\t\t\t\tmin = e.cost;\n\t\t\t\t\ta = e.to;\n\t\t\t\t\tb = u;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdouble dist = calcDistance(x[from], y[from], x[to], y[to]);\n\t\t\tg[from].add(new Edge(to, dist));\n\t\t\tg[to].add(new Edge(from, dist));\n\t\t}\n\t\t\n\t\tvisited = new boolean[n];\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (true) {\n\t\t\t\ta = -1; b = -1; min = Double.MAX_VALUE;\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\tdfs(i, i, -1);\n\t\t\t\tif (a == -1) break;\n\t\t\t\t\t\n\t\t\t\thash.add(convert(a, b));\n\n\t\t\t\tres += min;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew SaveYourCat().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tclass UnionFind {\n\t\tint[] par, rank;\n\t\tUnionFind(int n) {\n\t\t\tpar  = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\tinit(n);\n\t\t}\n\t\tvoid init(int n) {\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint find(int x) {\n\t\t\tif (par[x] == x)\n\t\t\t\treturn x;\n\t\t\telse\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t\t\n\t\tvoid unite(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[x] = y;\n\t\t\t} else {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint u, v;\n\t\tdouble cost;\n\t\tEdge(int u, int v, double cost) {\n\t\t\tthis.u = u; this.v = v; this.cost = cost;\n\t\t}\n\t}\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y; this.x = x;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tdouble sum = 0;\n\t\tEdge[] edges = new Edge[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble cost = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost;\n\t\t\tedges[i] = new Edge(p, q, cost);\n\t\t}\n\t\t\n\t\tArrays.sort(edges, new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn e1.cost - e2.cost > 0 ? -1 :\n\t\t\t\t       e1.cost - e2.cost < 0 ?  1 :\n\t\t\t\t    \t                        0 ;\n\t\t\t}\n\t\t});\n\t\tUnionFind uf = new UnionFind(n);\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge e = edges[i];\n\t\t\tif (!uf.same(e.u, e.v)) {\n\t\t\t\tuf.unite(e.u, e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.4f\", sum - res);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main{\n\t\n\tpublic static final int Max = 2<<10;\n\tpublic static int n,m;\n\tpublic static double res;\n\tpublic static double[][] cost,copy;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\tcost = new double[Max][];\n\t\tcopy = new double[Max][];\n\t\tint[] x = new int[n+1];\n\t\tint[] y = new int[n+1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tcost[i] = new double[Max];\n\t\t\tcopy[i] = new double[Max];\n\t\t\tArrays.fill(cost[i], 0);\n\t\t\tArrays.fill(copy[i], 0);\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tcost[u][v] = cost[v][u] = Math.sqrt(Math.pow((x[u]-x[v]), 2)+Math.pow((y[u]-y[v]), 2));\n\t\t\tres += cost[u][v];\n\t\t}\n\t\tfor (int i = 1; i < n+1; i++) {\n\t\t\tfor (int j = 1; j < n+1; j++) {\n\t\t\t\tcopy[i][j] = cost[i][j];\n\t\t\t}\n\t\t}\n\t\tprim();\n\t\tSystem.out.printf(\"%.3f\", res);\n\t\t\n\t}\n\t\n\tpublic static void prim() {\n\t\t\n\t\tdouble[] maxcost = new double[2<<9];\n\t\tboolean[] used = new boolean[2<<9];\n\t\tfor (int i = 0; i < n+1; i++) {\n\t\t\tmaxcost[i] = 0;\n\t\t\tused[i] = false;\n\t\t}\n//\t\tres = 0;\n\t\t\n\t\twhile(true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u < n+1; u++) {\n\t\t\t\tif(!used[u]&&(v==-1||maxcost[u]>maxcost[v])) v = u;\n\t\t\t}\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\n\t\t\tres -= maxcost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u < n+1; u++) {\n\t\t\t\tmaxcost[u] = Math.max(maxcost[u], cost[v][u]);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();//the number of piles\n\t\tint m=sc.nextInt();//the number of fences\n\t\tdouble[] x=new double[n];\n\t\tdouble[] y=new double[n];\n\t\tdouble sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=sc.nextDouble();\n\t\t\ty[i]=sc.nextDouble();\n\t\t}\n\t\tKruskal kl=new Kruskal(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from=sc.nextInt()-1;\n\t\t\tint to=sc.nextInt()-1;\n\t\t\tdouble d=Math.sqrt((x[from]-x[to])*(x[from]-x[to])+(y[from]-y[to])*(y[from]-y[to]));\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tkl.addEdge(from, to, d);\n//\t\t\ttr(from,to,d);\n\t\t\tsum+=d;\n\t\t}\n\t\tdouble total=kl.get_minimum_spanning_tree();\n\t\tSystem.out.println(sum-total);\n\t}\n\n\tclass Kruskal{\n\t\tint n;//the number of vertices\n\t\tdouble weight_sum=-1;\n\t\tList<Edge>[] edges;//adjacency list\n\t\tPriorityQueue<Edge> pq;\n\t\tKruskal(int n){\n\t\t\tthis.n=n;\n//\t\t\tedges=new List[n];\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tedges[i]=new ArrayList<Edge>();\n//\t\t\t}\n\t\t\tpq=new PriorityQueue<Edge>();\n\t\t}\n\n\t\tdouble get_minimum_spanning_tree(){\n\t\t\tDJSet ds=new DJSet(n);\n\t\t\tweight_sum=0;\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tEdge e=pq.poll();\n\t\t\t\tif(ds.same(e.from, e.to))continue;\n\t\t\t\tweight_sum+=e.cost;\n\t\t\t\tds.setUnion(e.from, e.to);\n\t\t\t}\n//\t\t\tif(ds.size(0)!=n)return -1;\nreturn weight_sum;\n\t\t}\n\t\tvoid addEdge(int from,int to,double cost){\n//\t\t\tedges[from].add(new Edge(from,to,cost));\n\t\t\tpq.add(new Edge(from,to,cost));\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tint from;\n\t\tint to;\n\t\tdouble cost;\n\t\tEdge(int from,int to,double cost){\n\t\t\tthis.from=from;\n\t\t\tthis.to=to;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn this.cost>o.cost?-1:this.cost<o.cost?1:0;\n\t\t}\n\t}\n\tclass DJSet{\n\t\tint n;//the number of vertices\n\t\tint[] d;\n\t\tDJSet(int n){\n\t\t\tthis.n=n;\n\t\t\td=new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn d[x]<0?x:root(d[x]);\n\t\t}\n\t\tboolean setUnion(int x,int y){\n\t\t\tx=root(x);\n\t\t\ty=root(y);\n\t\t\tif(x!=y){\n\t\t\t\tif(x<y){\n\t\t\t\t\tint d=x;\n\t\t\t\t\tx=y;\n\t\t\t\t\ty=d;\n\t\t\t\t}\n\t\t\t\t//x>y\n\t\t\t\td[y]+=d[x];\n\t\t\t\td[x]=y;\n\t\t\t}\n\t\t\treturn x!=y;\n\t\t}\n\t\tboolean same(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint size(int x){\n\t\t\treturn d[root(x)]*(-1);\n\t\t}\n\t}\n\n\n\tvoid tr(Object...objects){System.out.println(Arrays.deepToString(objects));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tclass UnionFind {\n\t\tint[] par, rank;\n\t\tUnionFind(int n) {\n\t\t\tpar  = new int[n + 1];\n\t\t\trank = new int[n + 1];\n\t\t\tinit(n);\n\t\t}\n\t\tvoid init(int n) {\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tpar[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint find(int x) {\n\t\t\tif (par[x] == x)\n\t\t\t\treturn x;\n\t\t\telse\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t\t\n\t\tvoid unite(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\t\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[x] = y;\n\t\t\t} else {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\n\tclass Edge {\n\t\tint u, v;\n\t\tdouble cost;\n\t\tEdge(int u, int v, double cost) {\n\t\t\tthis.u = u; this.v = v; this.cost = cost;\n\t\t}\n\t}\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y; this.x = x;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tEdge[] edges = new Edge[m];\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble cost = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost;\n\t\t\tedges[i] = new Edge(p, q, cost);\n\t\t}\n\t\t\n\t\tArrays.sort(edges, new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\treturn e1.cost - e2.cost > 0 ? -1 :\n\t\t\t\t       e1.cost - e2.cost < 0 ?  1 :\n\t\t\t\t    \t                        0 ;\n\t\t\t}\n\t\t});\n\t\tUnionFind uf = new UnionFind(n);\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge e = edges[i];\n\t\t\tif (!uf.same(e.u, e.v)) {\n\t\t\t\tuf.unite(e.u, e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.4f\\n\", sum - res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main\n{\n    private static class Point\n    {\n        int x, y;\n        private Point(int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n        }\n\n        private double distanceTo(Point that)\n        {\n            return Math.sqrt(Math.pow(this.x-that.x, 2)+Math.pow(this.y-that.y, 2));\n        }\n    }\n    private static class Edge\n    {\n        int v, w;\n        double weight;\n        private Edge(int v, int w, double weight)\n        {\n            this.v = v;\n            this.w = w;\n            this.weight = weight;\n        }\n        public int another(int v)\n        {\n            if (v == this.v)    return w;\n            else                return this.v;\n        }\n    }\n    private static class Node implements Comparable<Node>\n    {\n        int x;\n        double val;\n        private Node(int x, double val)\n        {\n            this.x = x;\n            this.val = val;\n        }\n        public int compareTo(Node that)\n        {\n            return Double.compare(that.val, this.val);\n        }\n    }\n    private static class Graph\n    {\n        ArrayList<ArrayList<Edge>> adj;\n        boolean[] marked;\n        double[] disTo;\n        int v;\n        double totalWeight;\n        double mst;\n        private Graph(int v)\n        {\n            this.v = v;\n            marked = new boolean[v+1];\n            disTo = new double[v+1];\n            adj = new ArrayList<>(v+1);\n            Arrays.fill(disTo, -1);\n            for (int i = 0; i <= v; i++)\n                adj.add(new ArrayList<>());\n        }\n        private void addEdge(Edge e)\n        {\n            totalWeight += e.weight;\n            int v = e.v, w = e.another(v);\n            adj.get(v).add(e);\n            adj.get(w).add(e);\n        }\n        public void solve(int s)\n        {\n            PriorityQueue<Node> pq = new PriorityQueue<>(v);\n            disTo[s] = 0.0;\n            pq.add(new Node(s, 0.0));\n            ArrayList<Integer> visited = new ArrayList<>();\n            while (!pq.isEmpty())\n            {\n                Node p = pq.poll();\n                int u = p.x;\n                if (marked[u]) continue;\n                marked[u] = true;\n                visited.add(u);\n                for (int i = 0; i < adj.get(u).size(); i++)\n                {\n                    Edge e = adj.get(u).get(i);\n                    int v = e.another(u);\n                    if (marked[v]) continue;\n                    double w = e.weight;\n                    if (w > disTo[v])\n                    {\n                        disTo[v] = w;\n                        pq.add(new Node(v, w));\n                    }\n                }\n            }\n            for (int i: visited)\n            {\n                mst += disTo[i];\n            }\n\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int m = in.nextInt();\n        HashMap<Integer, Point> map = new HashMap<>(n);\n        Graph g = new Graph(n);\n        for (int i = 1; i <= n; i++)\n            map.put(i, new Point(in.nextInt(), in.nextInt()));\n\n        for (int i = 0; i < m; i++)\n        {\n            int v = in.nextInt(), w = in.nextInt();\n            double weight = map.get(v).distanceTo(map.get(w));\n            g.addEdge(new Edge(v, w, weight));\n        }\n        for (int i = 1; i <= n; i++)\n        {\n            if (!g.marked[i])\n                g.solve(i);\n        }\n        System.out.printf(\"%.3f\", g.totalWeight - g.mst);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "//package com.daimens.algorithm.june;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2224.Save your cats\n * \n *         Save your cats Time Limit : 8 sec, Memory Limit : 65536 KB Problem C:\n *         Save your cats Nicholas Y. Alford was a cat lover. He had a garden in\n *         a village and kept many cats in his garden. The cats were so cute\n *         that people in the village also loved them.\n * \n *         One day, an evil witch visited the village. She envied the cats for\n *         being loved by everyone. She drove magical piles in his garden and\n *         enclosed the cats with magical fences running between the piles. She\n *         said ???Your cats are shut away in the fences until they become ugly\n *         old cats.??? like a curse and went away.\n * \n *         Nicholas tried to break the fences with a hummer, but the fences are\n *         impregnable against his effort. He went to a church and asked a\n *         priest help. The priest looked for how to destroy the magical fences\n *         in books and found they could be destroyed by holy water. The\n *         Required amount of the holy water to destroy a fence was proportional\n *         to the length of the fence. The holy water was, however, fairly\n *         expensive. So he decided to buy exactly the minimum amount of the\n *         holy water required to save all his cats. How much holy water would\n *         be required?\n * \n *         Input The input has the following format:\n * \n *         N M x1 y1 . . . xN yN p1 q1 . . . pM qM The first line of the input\n *         contains two integers N (2 ??? N ??? 10000) and M (1 ??? M). N indicates\n *         the number of magical piles and M indicates the number of magical\n *         fences. The following N lines describe the coordinates of the piles.\n *         Each line contains two integers xi and yi (-10000 ??? xi, yi ??? 10000).\n *         The following M lines describe the both ends of the fences. Each line\n *         contains two integers pj and qj (1 ??? pj, qj ??? N). It indicates a\n *         fence runs between the pj-th pile and the qj-th pile.\n * \n *         You can assume the following:\n * \n *         No Piles have the same coordinates. A pile doesn???t lie on the middle\n *         of fence. No Fences cross each other. There is at least one cat in\n *         each enclosed area. It is impossible to destroy a fence partially. A\n *         unit of holy water is required to destroy a unit length of magical\n *         fence. Output Output a line containing the minimum amount of the holy\n *         water required to save all his cats. Your program may output an\n *         arbitrary number of digits after the decimal point. However, the\n *         absolute error should be 0.001 or less.\n * \n *         Sample Input 1 3 3 0 0 3 0 0 4 1 2 2 3 3 1 Output for the Sample\n *         Input 1 3.000 Sample Input 2 4 3 0 0 -100 0 100 0 0 100 1 2 1 3 1 4\n *         Output for the Sample Input 2 0.000 Sample Input 3 6 7 2 0 6 0 8 2 6\n *         3 0 5 1 7 1 2 2 3 3 4 4 1 5 1 5 4 5 6 Output for the Sample Input 3\n *         7.236 Sample Input 4 6 6 0 0 0 1 1 0 30 0 0 40 30 40 1 2 2 3 3 1 4 5\n *         5 6 6 4 Output for the Sample Input 4 31.000\n *\n */\npublic class Main{\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint from;\n\t\tint to;\n\t\tdouble cost;\n\n\t\tpublic Edge(int from, int to, double cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.cost == o.cost ? 0 : (this.cost < o.cost ? 1 : -1);\n\t\t}\n\t}\n\n\tstatic class Union {\n\t\tint[] id;\n\t\tint[] sz;\n\n\t\tpublic Union(int SIZE) {\n\t\t\tid = new int[SIZE];\n\t\t\tsz = new int[SIZE];\n\t\t\tfor (int i = 0; i < SIZE; ++i) {\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic int find(int i) {\n\t\t\twhile (i != id[i]) {\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic boolean connect(int i, int j) {\n\t\t\treturn find(i) == find(j);\n\t\t}\n\n\t\tpublic void union(int i, int j) {\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\tif (p == q)\n\t\t\t\treturn;\n\t\t\tif (sz[p] < sz[q]) {\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t} else {\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double distance(int[] o1, int[] o2) {\n\t\tint x1 = o1[0];\n\t\tint y1 = o1[1];\n\t\tint x2 = o2[0];\n\t\tint y2 = o2[1];\n\t\treturn Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint M = in.nextInt();\n\t\tint[][] pos = new int[N][2];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x1 = in.nextInt();\n\t\t\tint y1 = in.nextInt();\n\t\t\tpos[i][0] = x1;\n\t\t\tpos[i][1] = y1;\n\t\t}\n\t\t\n\t\tList<Edge>[] g = new ArrayList[N];\n\t\tfor (int i = 0; i < N; ++i) g[i] = new ArrayList<>();\n\t\t\n\t\tu = new Union(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint from = in.nextInt();\n\t\t\tint to = in.nextInt();\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\tdouble cost = distance(pos[from], pos[to]);\n\t\t\tg[from].add(new Edge(from, to, cost));\n\t\t}\n\t\t\n\t\tSystem.out.println(krusal(g));\n\t}\n\t\n\tstatic Union u;\n\tprivate static double krusal(List<Edge>[] g){\n\t\tint V = g.length;\n\t\tQueue<Edge> pq = new PriorityQueue<>();\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tfor (Edge e : g[i]){\n\t\t\t\tsum += e.cost;\n\t\t\t\tpq.offer(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!pq.isEmpty()){\n\t\t\tEdge e = pq.poll();\n\t\t\tint from = e.from, to = e.to;\n\t\t\tif (u.connect(from, to)) continue;\n\t\t\tsum -= e.cost;\n\t\t\tu.union(from, to);\n\t\t}\n\t\treturn sum;\n\t}\n\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tIO io = new IO();\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tio.nextIntArrays(x,y);\n\t\tKruscal g = new Kruscal(n);\n\t\tdouble total = 0;\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint p = io.nextInt() - 1;\n\t\t\tint q = io.nextInt() - 1;\n\t\t\tint dx = x[p] - x[q];\n\t\t\tint dy = y[p] - y[q];\n\t\t\tdouble dist = Math.sqrt(dx * dx + dy * dy);\n\t\t\tg.addBidirectionalEdge(p, q, dist);\n\t\t\ttotal += dist;\n\t\t}\n\t\tSystem.out.println(String.format(\"%.9f\", total - g.maxCost()));\n\t}\n\n}\nclass Kruscal {\n\tint n;\n\tArrayList<Edge> graph = new ArrayList<Edge>();\n\n\tpublic Kruscal(int n) {\n\t\tthis.n = n;\n\t}\n\n\tpublic void addBidirectionalEdge(int u,int v,double cost) {\n\t\tgraph.add(new Edge(cost,u,v));\n\t}\n\n\tpublic double maxCost() {\n\t\tCollections.sort(graph,Collections.reverseOrder());\n\t\tUnionFind uf = new UnionFind(n);\n\t\tdouble ans = 0;\n\t\tint connected = 1;\n\t\tfor(int i=0;i<graph.size();i++) {\n\t\t\tEdge e = graph.get(i);\n\t\t\tif (!uf.isConnected(e.from, e.to)) {\n\t\t\t\tuf.union(e.from, e.to);\n\t\t\t\tconnected++;\n\t\t\t\tans+=e.cost;\n\t\t\t\tif (connected==n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\tstatic class Edge implements Comparable<Edge>{\n\t\tdouble cost;\n\t\tint from;\n\t\tint to;\n\t\tpublic Edge(double cost,int from,int to) {\n\t\t\tthis.cost = cost;\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\tif (this.cost == o.cost) {\n\t\t\t\treturn 0;\n\t\t\t}else if(this.cost > o.cost) {\n\t\t\t\treturn 1;\n\t\t\t}else{\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn this.cost + \",\" + this.from + \",\" + this.to;\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tprivate int[] data;\n\t\tpublic UnionFind(int size) {\n\t\t\tdata = new int[size];\n\t\t\tArrays.fill(data, -1);\n\t\t}\n\t\tpublic void union(int x,int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x!=y) {\n\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\tint tmp = y;\n\t\t\t\t\ty = x;\n\t\t\t\t\tx = tmp;\n\t\t\t\t}\n\t\t\t\tdata[x] += data[y];\n\t\t\t\tdata[y] = x;\n\t\t\t}\n\t\t}\n\t\tpublic boolean isConnected(int x,int y) {\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tprivate int root(int x) {\n\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t}\n\t\tpublic int size(int x) {\n\t\t\treturn -data[root(x)];\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn Arrays.toString(data);\n\t\t}\n\t}\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static class Edge implements Comparable<Edge>{\n\t\tint s, e;\n\t\tdouble cost;\n\t\t\n\t\tpublic Edge(int s, int e, double cost) {\n\t\t\tsuper();\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Double.compare(o.cost, this.cost);\n\t\t}\n\t}\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\t\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int M = sc.nextInt();\n\t\t\n\t\tint[] x_pos = new int[N];\n\t\tint[] y_pos = new int[N];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tx_pos[i] = sc.nextInt();\n\t\t\ty_pos[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tdouble[][] cost = new double[N][N];\n\t\tfor(int from = 0; from < N; from++){\n\t\t\tfor(int to = from + 1; to < N; to++){\n\t\t\t\tcost[from][to] = cost[to][from] = Math.sqrt((x_pos[from] - x_pos[to]) * (x_pos[from] - x_pos[to]) + \n\t\t\t\t\t\t                                    (y_pos[from] - y_pos[to]) * (y_pos[from] - y_pos[to]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tPriorityQueue<Edge> edges = new PriorityQueue<Main.Edge>();\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tfinal int s = sc.nextInt() - 1;\n\t\t\tfinal int e = sc.nextInt() - 1;\n\t\t\t\n\t\t\tedges.add(new Edge(s, e, cost[s][e]));\n\t\t}\n\t\t\n\t\tUnionFind uf = new UnionFind(N);\n\t\tdouble sum = 0;\n\t\tint count = 0;\n\t\twhile(!edges.isEmpty()){\n\t\t\tEdge edge = edges.poll();\n\t\t\t\n\t\t\tif(uf.same(edge.s, edge.e) || count >= N - 1){\n\t\t\t\tsum += edge.cost;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuf.unite(edge.s, edge.e);\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tSystem.out.printf(\"%.3f\\n\",sum);\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\tfinal int MIN = -100000;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tfloat[][] cost = new float[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tcost[i][j] = MIN;\n\n\t\tfloat[] mincost = new float[n + 1];\n\t\tboolean[] used = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tmincost[i] = MIN;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tfloat sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble c = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost[p][q] = cost[q][p] = (float)c;\n\t\t}\n//\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\tSystem.out.print((cost[i][j] == MIN ? \"X\" : (int)cost[i][j]) + \" \");\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tmincost[1] = 0;\n\t\tfloat res = 0;\n\t\t\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] > mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t\n\t\t\tif (v == -1)\n\t\t\t\tbreak;\n\n\t\t\tused[v] = true;\n\t\t\tif (mincost[v] != MIN)\n\t\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tmincost[u] = Math.max(mincost[u], cost[v][u]);\n\t\t}\n\t\tSystem.out.println(sum - res);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\tfinal int MIN = -100000;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tfloat[][] cost = new float[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tcost[i][j] = MIN;\n\n\t\tfloat[] mincost = new float[n + 1];\n\t\tboolean[] used = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tmincost[i] = MIN;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble c = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost[p][q] = cost[q][p] = (float)c;\n\t\t}\n//\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\tSystem.out.print((cost[i][j] == MIN ? \"X\" : (int)cost[i][j]) + \" \");\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tmincost[1] = 0;\n\t\tdouble res = 0;\n\t\t\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] > mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t\n\t\t\tif (v == -1)\n\t\t\t\tbreak;\n\n\t\t\tused[v] = true;\n\t\t\tif (mincost[v] != MIN)\n\t\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tmincost[u] = Math.max(mincost[u], cost[v][u]);\n\t\t}\n\t\tSystem.out.printf(\"%.4f\", sum - res);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static class Edge implements Comparable<Edge>{\n\t\tint s, e;\n\t\tdouble cost;\n\t\t\n\t\tpublic Edge(int s, int e, double cost) {\n\t\t\tsuper();\n\t\t\tthis.s = s;\n\t\t\tthis.e = e;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Double.compare(o.cost, this.cost);\n\t\t}\n\t}\n\t\n\t/*\n\tpublic static class Node implements Comparable<Node>{\n\t\tint node;\n\t\tdouble cost;\n\t\t\n\t\tpublic Node(int node, double cost) {\n\t\t\tsuper();\n\t\t\tthis.node = node;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn Double.compare(this.cost, o.cost);\n\t\t}\n\t}\n\t*/\n\t\n\tpublic static class UnionFind{\n\t\tint[] par;\n\t\t\n\t\tUnionFind(int n){\n\t\t\tpar=new int[n];\n\t\t\tfor(int i=0;i<n;i++)par[i]=i;\n\t\t}\n\t\t\n\t\tpublic int find(int x){\n\t\t\tif(par[x]==x)return x;\n\t\t\treturn par[x]=find(par[x]);\n\t\t}\n\t\tpublic Boolean same(int x,int y){\n\t\t\treturn find(x)==find(y);\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tif(find(x)==find(y))return;\n\t\t\tpar[find(x)]=find(y);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\n\t\tfinal int N = sc.nextInt();\n\t\tfinal int M = sc.nextInt();\n\t\t\n\t\tint[] x_pos = new int[N];\n\t\tint[] y_pos = new int[N];\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tx_pos[i] = sc.nextInt();\n\t\t\ty_pos[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\t/*\n\t\tdouble[][] cost = new double[N][N];\n\t\tfor(int from = 0; from < N; from++){\n\t\t\tfor(int to = from + 1; to < N; to++){\n\t\t\t\tcost[from][to] = cost[to][from] = Math.sqrt((x_pos[from] - x_pos[to]) * (x_pos[from] - x_pos[to]) + \n\t\t\t\t\t\t                                    (y_pos[from] - y_pos[to]) * (y_pos[from] - y_pos[to]));\n\t\t\t}\n\t\t}\n\t\t*/\n\t\t\n\t\tPriorityQueue<Edge> edges = new PriorityQueue<Main.Edge>();\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tfinal int s = sc.nextInt() - 1;\n\t\t\tfinal int e = sc.nextInt() - 1;\n\t\t\t\n\t\t\tedges.add(new Edge(s, e, \n\t\t\t\t\tMath.sqrt((x_pos[s] - x_pos[e]) * (x_pos[s] - x_pos[e]) + \n                              (y_pos[s] - y_pos[e]) * (y_pos[s] - y_pos[e]))));\n\t\t}\n\t\t\n\t\tUnionFind uf = new UnionFind(N);\n\t\tdouble sum = 0;\n\t\tint count = 0;\n\t\twhile(!edges.isEmpty()){\n\t\t\tEdge edge = edges.poll();\n\t\t\t\n\t\t\tif(uf.same(edge.s, edge.e) || count >= N - 1){\n\t\t\t\tsum += edge.cost;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tuf.unite(edge.s, edge.e);\n\t\t\tcount++;\n\t\t}\n\t\t\n\t\tSystem.out.printf(\"%.3f\\n\",sum);\n\t}\n\n\tpublic static class Scanner {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\t\t\n\t\tpublic Scanner(InputStream is) throws IOException{\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\t\t\n\t\tprivate void getLine() throws IOException{\n\t\t\twhile(tok == null || !tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate boolean hasNext(){\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn tok.nextToken();\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic double nextDouble() throws IOException{\n\t\t\tif(hasNext()){\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}else{\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tdouble[][] cost = new double[n][n];\n\t\tfor(int i=0;i<n;i++) Arrays.fill(cost[i], 0);\n\t\tdouble all = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint p = sc.nextInt()-1;\n\t\t\tint q = sc.nextInt()-1;\n\t\t\tdouble c = Math.sqrt((y[p]-y[q])*(y[p]-y[q])+(x[p]-x[q])*(x[p]-x[q]));\n\t\t\tcost[p][q] = c;\n\t\t\tcost[q][p] = c;\n\t\t\tall += c;\n\t\t}\n\t\n\t\tboolean[] f = new boolean[n];\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tdouble sum = 0;\n\t\tint s;\n\t\tint r = 0;\n\t\tdouble t;\n\t\twhile(true){\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!f[i]){\n\t\t\t\t\tlist = new ArrayList<Integer>();\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\tf[i] = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) break;\n\t\t\t\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\ts = list.get(j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(list.contains(k)==false && t<cost[s][k]){\n\t\t\t  \t\t\t\tt = cost[s][k];\n\t\t\t\t\t\t\tr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.add(r);\n\t\t\t\tf[r] = true;\n\t\t\t \tsum += t;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(all-sum);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "//package com.daimens.algorithm.june;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2224.Save your cats\n * \n *         Save your cats Time Limit : 8 sec, Memory Limit : 65536 KB Problem C:\n *         Save your cats Nicholas Y. Alford was a cat lover. He had a garden in\n *         a village and kept many cats in his garden. The cats were so cute\n *         that people in the village also loved them.\n * \n *         One day, an evil witch visited the village. She envied the cats for\n *         being loved by everyone. She drove magical piles in his garden and\n *         enclosed the cats with magical fences running between the piles. She\n *         said ???Your cats are shut away in the fences until they become ugly\n *         old cats.??? like a curse and went away.\n * \n *         Nicholas tried to break the fences with a hummer, but the fences are\n *         impregnable against his effort. He went to a church and asked a\n *         priest help. The priest looked for how to destroy the magical fences\n *         in books and found they could be destroyed by holy water. The\n *         Required amount of the holy water to destroy a fence was proportional\n *         to the length of the fence. The holy water was, however, fairly\n *         expensive. So he decided to buy exactly the minimum amount of the\n *         holy water required to save all his cats. How much holy water would\n *         be required?\n * \n *         Input The input has the following format:\n * \n *         N M x1 y1 . . . xN yN p1 q1 . . . pM qM The first line of the input\n *         contains two integers N (2 ??? N ??? 10000) and M (1 ??? M). N indicates\n *         the number of magical piles and M indicates the number of magical\n *         fences. The following N lines describe the coordinates of the piles.\n *         Each line contains two integers xi and yi (-10000 ??? xi, yi ??? 10000).\n *         The following M lines describe the both ends of the fences. Each line\n *         contains two integers pj and qj (1 ??? pj, qj ??? N). It indicates a\n *         fence runs between the pj-th pile and the qj-th pile.\n * \n *         You can assume the following:\n * \n *         No Piles have the same coordinates. A pile doesn???t lie on the middle\n *         of fence. No Fences cross each other. There is at least one cat in\n *         each enclosed area. It is impossible to destroy a fence partially. A\n *         unit of holy water is required to destroy a unit length of magical\n *         fence. Output Output a line containing the minimum amount of the holy\n *         water required to save all his cats. Your program may output an\n *         arbitrary number of digits after the decimal point. However, the\n *         absolute error should be 0.001 or less.\n * \n *         Sample Input 1 3 3 0 0 3 0 0 4 1 2 2 3 3 1 Output for the Sample\n *         Input 1 3.000 Sample Input 2 4 3 0 0 -100 0 100 0 0 100 1 2 1 3 1 4\n *         Output for the Sample Input 2 0.000 Sample Input 3 6 7 2 0 6 0 8 2 6\n *         3 0 5 1 7 1 2 2 3 3 4 4 1 5 1 5 4 5 6 Output for the Sample Input 3\n *         7.236 Sample Input 4 6 6 0 0 0 1 1 0 30 0 0 40 30 40 1 2 2 3 3 1 4 5\n *         5 6 6 4 Output for the Sample Input 4 31.000\n *\n */\npublic class Main{\n\n\tstatic class Edge implements Comparable<Edge> {\n\t\tint from;\n\t\tint to;\n\t\tdouble cost;\n\n\t\tpublic Edge(int from, int to, double cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.cost == o.cost ? 0 : (this.cost < o.cost ? 1 : -1);\n\t\t}\n\t}\n\n\tstatic class Union {\n\t\tint[] id;\n\t\tint[] sz;\n\n\t\tpublic Union(int SIZE) {\n\t\t\tid = new int[SIZE];\n\t\t\tsz = new int[SIZE];\n\t\t\tfor (int i = 0; i < SIZE; ++i) {\n\t\t\t\tid[i] = i;\n\t\t\t\tsz[i] = 1;\n\t\t\t}\n\t\t}\n\n\t\tpublic int find(int i) {\n\t\t\twhile (i != id[i]) {\n\t\t\t\ti = id[i];\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\n\t\tpublic boolean connect(int i, int j) {\n\t\t\treturn find(i) == find(j);\n\t\t}\n\n\t\tpublic void union(int i, int j) {\n\t\t\tint p = find(i);\n\t\t\tint q = find(j);\n\t\t\tif (p == q)\n\t\t\t\treturn;\n\t\t\tif (sz[p] < sz[q]) {\n\t\t\t\tid[p] = q;\n\t\t\t\tsz[q] += sz[p];\n\t\t\t} else {\n\t\t\t\tid[q] = p;\n\t\t\t\tsz[p] += sz[1];\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double distance(int[] o1, int[] o2) {\n\t\tint x1 = o1[0];\n\t\tint y1 = o1[1];\n\t\tint x2 = o2[0];\n\t\tint y2 = o2[1];\n\t\treturn Math.sqrt((y2 - y1) * (y2 - y1) + (x2 - x1) * (x2 - x1));\n\t}\n\t\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\tint N = in.nextInt();\n\t\tint M = in.nextInt();\n\t\tint[][] pos = new int[N][2];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x1 = in.nextInt();\n\t\t\tint y1 = in.nextInt();\n\t\t\tpos[i][0] = x1;\n\t\t\tpos[i][1] = y1;\n\t\t}\n\t\t\n\t\tList<Edge>[] g = new ArrayList[N];\n\t\tfor (int i = 0; i < N; ++i) g[i] = new ArrayList<>();\n\t\t\n\t\tu = new Union(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint from = in.nextInt();\n\t\t\tint to = in.nextInt();\n\t\t\tfrom--;\n\t\t\tto--;\n\t\t\tdouble cost = distance(pos[from], pos[to]);\n\t\t\tg[from].add(new Edge(from, to, cost));\n\t\t}\n\t\t\n\t\tSystem.out.println(krusal(g));\n\t}\n\t\n\tstatic Union u;\n\tprivate static double krusal(List<Edge>[] g){\n\t\tint V = g.length;\n\t\tQueue<Edge> pq = new PriorityQueue<>();\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < V; ++i){\n\t\t\tfor (Edge e : g[i]){\n\t\t\t\tsum += e.cost;\n\t\t\t\tpq.offer(e);\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!pq.isEmpty()){\n\t\t\tEdge e = pq.poll();\n\t\t\tint from = e.from, to = e.to;\n\t\t\tif (u.connect(from, to)) continue;\n\t\t\tsum -= e.cost;\n\t\t\tu.union(from, to);\n\t\t}\n\t\treturn sum;\n\t}\n\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();//the number of piles\n\t\tint m=sc.nextInt();//the number of fences\n\t\tdouble[] x=new double[n];\n\t\tdouble[] y=new double[n];\n\t\tdouble sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i]=sc.nextDouble();\n\t\t\ty[i]=sc.nextDouble();\n\t\t}\n\t\tKruskal kl=new Kruskal(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from=sc.nextInt()-1;\n\t\t\tint to=sc.nextInt()-1;\n\t\t\tdouble d=Math.sqrt((x[from]-x[to])*(x[from]-x[to])+(y[from]-y[to])*(y[from]-y[to]));\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tkl.addEdge(from, to, d);\n\t\t\tsum+=d;\n\t\t}\n\t\tdouble total=kl.get_minimum_spanning_tree();\n\t\tSystem.out.println(sum-total);\n\t}\n\n\tclass Kruskal{\n\t\tint n;//the number of vertices\n\t\tdouble weight_sum=-1;\n\t\tList<Edge>[] edges;//adjacency list\n\t\tPriorityQueue<Edge> pq;\n\t\tKruskal(int n){\n\t\t\tthis.n=n;\n\t\t\tedges=new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tedges[i]=new ArrayList<Edge>();\n\t\t\t}\n\t\t\tpq=new PriorityQueue<Edge>();\n\t\t}\n\n\t\tdouble get_minimum_spanning_tree(){\n\t\t\tDJSet ds=new DJSet(n);\n\t\t\tweight_sum=0;\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tEdge e=pq.poll();\n\t\t\t\tif(ds.same(e.from, e.to))continue;\n\t\t\t\tweight_sum+=e.cost;\n\t\t\t\tds.setUnion(e.from, e.to);\n\t\t\t}\n\t\t\tif(ds.size(0)!=n)return -1;\n\t\t\telse return weight_sum;\n\t\t}\n\t\tvoid addEdge(int from,int to,double cost){\n\t\t\tedges[from].add(new Edge(from,to,cost));\n\t\t\tpq.add(new Edge(from,to,cost));\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge>{\n\t\tint from;\n\t\tint to;\n\t\tdouble cost;\n\t\tEdge(int from,int to,double cost){\n\t\t\tthis.from=from;\n\t\t\tthis.to=to;\n\t\t\tthis.cost=cost;\n\t\t}\n\t\tpublic int compareTo(Edge o){\n\t\t\treturn this.cost>o.cost?-1:this.cost<o.cost?1:0;\n\t\t}\n\t}\n\tclass DJSet{\n\t\tint n;//the number of vertices\n\t\tint[] d;\n\t\tDJSet(int n){\n\t\t\tthis.n=n;\n\t\t\td=new int[n];\n\t\t\tArrays.fill(d, -1);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn d[x]<0?x:root(d[x]);\n\t\t}\n\t\tboolean setUnion(int x,int y){\n\t\t\tx=root(x);\n\t\t\ty=root(y);\n\t\t\tif(x!=y){\n\t\t\t\tif(x<y){\n\t\t\t\t\tint d=x;\n\t\t\t\t\tx=y;\n\t\t\t\t\ty=d;\n\t\t\t\t}\n\t\t\t\t//x>y\n\t\t\t\td[y]+=d[x];\n\t\t\t\td[x]=y;\n\t\t\t}\n\t\t\treturn x!=y;\n\t\t}\n\t\tboolean same(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint size(int x){\n\t\t\treturn d[root(x)]*(-1);\n\t\t}\n\t}\n\n\n\tvoid tr(Object...objects){System.out.println(Arrays.deepToString(objects));}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.font.GraphicAttribute;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tclass Edge {\n\t\tint to;\n\t\tdouble cost;\n\n\t\tEdge(int to, double cost) {\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\t\n\tfinal int CONV_CONST = 10010;\n\t\n\tboolean[] visited;\n\tArrayList<Edge>[] g;\n\tHashSet<Integer> hash = new HashSet<Integer>();\n\t\n\tdouble calcDistance(int x1, int y1, int x2, int y2) {\n\t\treturn Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n\t}\n\t\n\tint convert(int x, int y) {\n\t\treturn x * CONV_CONST + y;\n\t}\n\t\n\tint a, b;\n\tdouble min;\n\t\n\tboolean dfs(int u, int goal, int prev) {\n\t\tif (u == goal && prev != -1) {\n\t\t\treturn true;\n\t\t}\n\t\tif (visited[u]) return false;\n\t\tvisited[u] = true;\n\t\t\n\t\tfor (Edge e : g[u]) {\n\t\t\tif (hash.contains(convert(e.to, u))) continue;\n\t\t\t\n\t\t\tif (prev != e.to && dfs(e.to, goal, u)) {\n\t\t\t\tif (min > e.cost) {\n\t\t\t\t\tmin = e.cost;\n\t\t\t\t\ta = e.to;\n\t\t\t\t\tb = u;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] x = new int[n], y = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tx[i] = in.nextInt();\n\t\t\ty[i] = in.nextInt();\n\t\t}\n\t\t\n\t\tg = new ArrayList[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tg[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from = in.nextInt() - 1, to = in.nextInt() - 1;\n\t\t\tdouble dist = calcDistance(x[from], y[from], x[to], y[to]);\n\t\t\tg[from].add(new Edge(to, dist));\n\t\t\tg[to].add(new Edge(from, dist));\n\t\t}\n\t\t\n\t\tvisited = new boolean[n];\n\t\t\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\twhile (true) {\n\t\t\t\ta = -1; b = -1; min = Double.MAX_VALUE;\n\t\t\t\tArrays.fill(visited, false);\n\t\t\t\tdfs(i, i, -1);\n\t\t\t\tif (a == -1) break;\n\t\t\t\t\t\n\t\t\t\thash.add(convert(a, b));\n\t\t\t\thash.add(convert(b, a));\n\n\t\t\t\tres += min;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\t\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int m = sc.nextInt();\n        Point[] ps = new Point[n + 1];\n        for (int i = 1; i <= n; i++) {\n            ps[i] = new Point(sc.nextInt(), sc.nextInt());\n        }\n        PriorityQueue<Fenth> q = new PriorityQueue<Fenth>();\n        double ans = 0;\n\n        for (int i = 0; i < m; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            double dis = Math.hypot(ps[a].x - ps[b].x, ps[a].y - ps[b].y);\n            q.add(new Fenth(a, b, dis));\n            ans += dis;\n        }\n        UnionFind uf = new UnionFind(n + 1);\n        while (!q.isEmpty()) {\n            Fenth f = q.poll();\n            int a = f.from;\n            int b = f.to;\n            if (uf.same(a, b))\n                continue;\n            uf.unite(a, b);\n            ans -= f.length;\n        }\n        System.out.printf(\"%.4f\\n\", ans);\n    }\n}\n\nclass Fenth implements Comparable<Fenth> {\n    int from;\n    int to;\n    double length;\n\n    Fenth(int from, int to, double length) {\n        this.from = from;\n        this.to = to;\n        this.length = length;\n    }\n\n    public int compareTo(Fenth f) {\n        if (f.length > length)\n            return 1;\n        else if (f.length < length)\n            return -1;\n        else {\n            return 0;\n        }\n    }\n\n    public String toString() {\n        return \"from,to,length\" + from + \" \" + to + \" \" + length;\n    }\n}\n\nclass UnionFind {\n    int par[];\n    int rank[];\n\n    UnionFind(int n) {\n        par = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n        }\n    }\n\n    public int find(int x) {\n        if (x == par[x])\n            return x;\n        else\n            return par[x] = find(par[x]);\n    }\n\n    public void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return;\n        if (rank[x] > rank[y])\n            par[y] = x;\n        else {\n            par[x] = y;\n            if (rank[x] == rank[y])\n                rank[y]++;\n        }\n    }\n\n    public boolean same(int x, int y) {\n        return find(x) == find(y);\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\n\npublic class Main {\n\tclass Edge{\n\t\tint p, q;\n\t\tdouble cost;\n\t\tEdge(int p, int q, double cost){\n\t\t\tthis.p = p; this.q = q;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n\tint[] par;\n//\tunion-findの木の初期化\n\tvoid unionfindInit(int n){\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n//\t木の根を求める\n\tint unionfindRoot(int x) {\n\t\tif(par[x]==x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = unionfindRoot(par[x]);\n\t\t}\n\t}\n//\txとyが同じ集合に属するか否か\n\tboolean unionfindSame(int x, int y) {\n\t\treturn unionfindRoot(x) == unionfindRoot(y);\n\t}\n\t\n//\txとyの属する集合を併合\n\tvoid unionfinUnite(int x, int y) {\n\t\tx = unionfindRoot(x);\n\t\ty = unionfindRoot(y);\n\t\tif (x == y) return;\n\t\tpar[x]=y;\n\t}\n\tvoid run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint N = scan.nextInt();\n\t\tpar = new int[N+1];\n\t\tint M = scan.nextInt();\n\t\tint coordinate[][] = new int[N+1][2];\n\t\tint p, q;\n\t\tdouble hen1, hen2;\n\t\tdouble[] hypotenuse = new double[M]; //パイル間の距離\n\t\tPriorityQueue<Edge> edge = new PriorityQueue<Edge>(new Comparator<Edge>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Edge e1, Edge e2) {\n\t\t\t\tif(e2.cost > e1.cost) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\telse if(e2.cost == e1.cost){\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t});\n\t\tEdge tmp = new Edge(0,0,0);\n//\t\t釘の座標情報\n\t\tfor(int i=1; i< N+1;i++) {\n\t\t\tcoordinate[i][0] = scan.nextInt();;\n\t\t\tcoordinate[i][1] = scan.nextInt();;\n\t\t}\n//\t\tフェンスの情報\n\t\tunionfindInit(N+1);\n\t\tdouble mainasu_sum=0;\n\t\tfor(int i=0; i < M; i++) {\n\t\t\tp = scan.nextInt();\n\t\t\tq = scan.nextInt();\n\t\t\then1 = Math.abs(coordinate[p][0] - coordinate[q][0]);\n\t\t\then2 = Math.abs(coordinate[p][1] - coordinate[q][1]);\n\t\t\thypotenuse[i] = Math.sqrt(hen1*hen1+hen2*hen2);\n\t\t\tedge.offer(new Edge(p, q, hypotenuse[i]));\n\t\t}\n\t\tSystem.out.println(\"mainasu: \" + mainasu_sum);\n\t\tdouble sum=0;\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\ttmp = edge.poll();\n\t\t\tif(!unionfindSame(tmp.p, tmp.q)) unionfinUnite(tmp.p, tmp.q);\n\t\t\telse {\n\t\t\t\tmainasu_sum -= tmp.cost;\n\t\t\t\tSystem.out.println(\"tmp: \" + tmp.cost);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mainasu_sum);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tdouble[][] cost = new double[n][n];\n\t\tfor(int i=0;i<n;i++) Arrays.fill(cost[i], 0);\n\t\tdouble all = 0;\n\t\tfor(int j=0;j<m;j++){\n\t\t\tint p = sc.nextInt()-1;\n\t\t\tint q = sc.nextInt()-1;\n\t\t\tdouble c = Math.sqrt((y[p]-y[q])*(y[p]-y[q])+(x[p]-x[q])*(x[p]-x[q]));\n\t\t\tcost[p][q] = c;\n\t\t\tcost[q][p] = c;\n\t\t\tall += c;\n\t\t}\n\t\n\t\tboolean[] f = new boolean[n];\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tdouble sum = 0;\n\t\tint s;\n\t\tint r = 0;\n\t\tdouble t;\n\t\twhile(true){\n\t\t\tboolean flag = false;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!f[i]){\n\t\t\t\t\tlist = new ArrayList<Integer>();\n\t\t\t\t\tlist.add(i);\n\t\t\t\t\tf[i] = true;\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==false) break;\n\t\t\t\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tt = 0;\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\ts = list.get(j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(list.contains(k)==false && t<cost[s][k]){\n\t\t\t  \t\t\t\tt = cost[s][k];\n\t\t\t\t\t\t\tr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.add(r);\n\t\t\t\tf[r] = true;\n\t\t\t \tsum += t;\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.3f\\n\", all-sum);\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tclass Pair {\n\t\tint y, x;\n\t\tPair(int y, int x) {\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t}\n\t}\n\tfinal int MIN = -100000;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint m = scan.nextInt();\n\n\t\tPair[] pairs = new Pair[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tint x = scan.nextInt();\n\t\t\tint y = scan.nextInt();\n\t\t\tpairs[i] = new Pair(y, x);\n\t\t}\n\n\t\tfloat[][] cost = new float[n + 1][n + 1];\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\tcost[i][j] = MIN;\n\n\t\tfloat[] mincost = new float[n + 1];\n\t\tboolean[] used = new boolean[n + 1];\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tmincost[i] = MIN;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tdouble sum = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint p = scan.nextInt();\n\t\t\tint q = scan.nextInt();\n\t\t\tint _y = Math.abs(pairs[p].y - pairs[q].y);\n\t\t\tint _x = Math.abs(pairs[p].x - pairs[q].x);\n\t\t\tdouble c = Math.sqrt(_y * _y + _x * _x);\n\t\t\tsum += cost[p][q] = cost[q][p] = (float)c;\n\t\t}\n//\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\tSystem.out.print((cost[i][j] == MIN ? \"X\" : (int)cost[i][j]) + \" \");\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\tmincost[1] = 0;\n\t\tdouble res = 0;\n\t\t\n\t\twhile (true) {\n\t\t\tint v = -1;\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tif (!used[u] && (v == -1 || mincost[u] > mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t\n\t\t\tif (v == -1)\n\t\t\t\tbreak;\n\n\t\t\tused[v] = true;\n\t\t\tif (mincost[v] != MIN)\n\t\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor (int u = 1; u <= n; u++)\n\t\t\t\tmincost[u] = Math.max(mincost[u], cost[v][u]);\n\t\t}\n\t\tSystem.out.printf(\"%.4f\", sum - res);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n            var n = ri;\n            var m = ri;\n            var X = new long[n];\n            var Y = new long[n];\n            for (int i = 0; i < n; i++)\n            {\n                X[i] = ri;\n                Y[i] = ri;\n            }\n            var u = new int[m];\n            var v = new int[m];\n            var s = new DisjointSet(n);\n            for (int i = 0; i < m; i++)\n            {\n                u[i] = ri - 1;\n                v[i] = ri - 1;\n            }\n            var p = Enumerate(m, x => x).OrderByDescending(x =>\n            {\n                var dx = X[u[x]] - X[v[x]];\n                var dy = Y[u[x]] - Y[v[x]];\n                return dx * dx + dy * dy;\n            }).ToArray();\n            var ans = 0.0;\n            foreach (var x in p)\n            {\n                if (!s.Unite(u[x], v[x]))\n                {\n                    var dx = X[u[x]] - X[v[x]];\n                    var dy = Y[u[x]] - Y[v[x]];\n                    ans += Math.Sqrt(dx * dx + dy * dy);\n                }\n            }\n            Console.Out.WriteLine(\"{0:0.000000000}\", ans);\n\n        }\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        Console.SetOut(new System.IO.StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read())\n                if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n#endregion\n#region DisjointSet\npublic class DisjointSet\n{\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n)\n    {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id]\n    {\n        get\n        {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y)\n    {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y])\n        {\n            par[y] += par[x];\n            par[x] = y;\n        }\n        else\n        {\n            par[x] += par[y];\n            par[y] = x;\n            if (rank[x] == rank[y])\n                rank[x]++;\n        }\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Enu = System.Linq.Enumerable;\n\nclass Program\n{\n    void Solve()\n    {\n        int N = reader.Int(), M = reader.Int();\n        var uf = new UnionFind(N);\n        int[] x = new int[N], y = new int[N];\n        var list = new List<Edge>();\n        double ans = 0;\n\n        for (int i = 0; i < N; i++)\n        {\n            x[i] = reader.Int(); y[i] = reader.Int();\n        }\n        for (int i = 0; i < M; i++)\n        {\n            int a = reader.Int() - 1, b = reader.Int() - 1;\n            double cost = Dist(x[a], y[a], x[b], y[b]);\n            ans += cost;\n            list.Add(new Edge(cost, a, b));\n        }\n        foreach (var e in list.OrderByDescending(e => e))\n        {\n            if (!uf.Same(e.a, e.b))\n            {\n                ans -= e.cost;\n                uf.Unite(e.a, e.b);\n            }\n        }\n        Console.WriteLine(ans);\n    }\n\n    static double Dist(long x1, long y1, long x2, long y2)\n    {\n        return Math.Sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n    }\n\n    struct Edge : IComparable<Edge>\n    {\n        public double cost;\n        public int a, b;\n        public Edge(double cost, int a, int b)\n        {\n            this.cost = cost;\n            this.a = a;\n            this.b = b;\n        }\n        public int CompareTo(Edge other)\n        {\n            return Math.Sign(cost - other.cost);\n        }\n    }\n    class UnionFind\n    {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int V)\n        {\n            parent = new int[V];\n            rank = new int[V];\n            for (int i = 0; i < V; i++) { parent[i] = i; }\n        }\n        public int Root(int x)\n        {\n            if (parent[x] == x) return x;\n            return parent[x] = Root(parent[x]);\n        }\n        public void Unite(int x, int y)\n        {\n            x = Root(x); y = Root(y);\n            if (x == y) return;\n            if (rank[x] < rank[y]) { parent[x] = y; }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n            }\n        }\n        public bool Same(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n    }\n\n    static void Main() { new Program().Solve(); }\n    static Reader reader = new Reader(Console.In);\n    class Reader\n    {\n        private readonly TextReader reader;\n        private readonly char[] splitter = new char[] { ' ' };\n        private string[] s = new string[0];\n        private int i;\n        public Reader(TextReader r) { reader = r; }\n        public bool HasNext() { return Enqueue(); }\n        public string String() { return Dequeue(); }\n        public char Char() { return Dequeue()[0]; }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private bool Enqueue()\n        {\n            if (i < s.Length) return true;\n            string line = reader.ReadLine();\n            if (string.IsNullOrEmpty(line)) return false;\n            s = line.Split(splitter, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return true;\n        }\n        private string Dequeue() { Enqueue(); return s[i++]; }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "def max_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] > $heap[x][0]\n    maximum = l\n  else\n    maximum = x\n  end\n  if r <= $n && $heap[r][0] > $heap[maximum][0]\n    maximum = r\n  end\n  if maximum != x\n    $heap[x], $heap[maximum] = $heap[maximum], $heap[x]\n    max_heapify(maximum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  max_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] < $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [ 0, *n.times.map { gets.split.map(&:to_f) } ]\nq = m.times.map { gets.split.map(&:to_i) }\nsum = 0\n$n = 0\n$heap = []\nq.each do |a, b|\n  insert( [ Math.sqrt( (p[a][0] - p[b][0]) ** 2 + (p[a][1] - p[b][1]) ** 2 ), a, b ] )\nend\nuntil $n < 1\n  d, p0, p1 = extract\n  if ( p0 = find(p0) ) != ( p1 = find(p1) )\n    $sibling[p1] = p0\n  else\n    sum += d\n  end\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "def max_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] > $heap[x][0]\n    maximum = l\n  else\n    maximum = x\n  end\n  if r <= $n && $heap[r][0] > $heap[maximum][0]\n    maximum = r\n  end\n  if maximum != x\n    $heap[x], $heap[maximum] = $heap[maximum], $heap[x]\n    max_heapify(maximum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  max_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] < $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [ 0, *n.times.map { gets.split.map(&:to_f) } ]\nq = m.times.map { gets.split.map(&:to_i) }\nsum = 0\n$n = 0\n$heap = []\nq.each do |a, b|\n  insert( [ Math.sqrt( (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 ), a, b ] )\nend\nuntil $n < 1\n  d, p0, p1 = extract\n  if ( p0 = find(p0) ) != ( p1 = find(p1) )\n    $sibling[p1] = p0\n  else\n    sum += d\n  end\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "def max_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] > $heap[x][0]\n    maximum = l\n  else\n    maximum = x\n  end\n  if r <= $n && $heap[r][0] > $heap[maximum][0]\n    maximum = r\n  end\n  if maximum != x\n    $heap[x], $heap[maximum] = $heap[maximum], $heap[x]\n    max_heapify(maximum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  max_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] < $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dist(p0, p1)\n  Math.sqrt( (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 )\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [ 0, *n.times.map { gets.split.map(&:to_f) } ]\nq = m.times.map { gets.split.map(&:to_i) }\nsum = 0\n$n = 0\n$heap = []\nq.each do |a, b|\n  insert( [dist(p[a], p[b]), a, b] )\nend\nuntil $n < 1\n  d, p0, p1 = extract\n  if ( p0 = find(p0) ) != ( p1 = find(p1) )\n    $sibling[p1] = p0\n  else\n    sum += d\n  end\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "def max_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] > $heap[x][0]\n    maximum = l\n  else\n    maximum = x\n  end\n  if r <= $n && $heap[r][0] > $heap[maximum][0]\n    maximum = r\n  end\n  if maximum != x\n    $heap[x], $heap[maximum] = $heap[maximum], $heap[x]\n    max_heapify(maximum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  max_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] < $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dist(p0, p1)\n  Math.sqrt( (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 )\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [ 0, *n.times.map { gets.split.map(&:to_f) } ]\nq = m.times.map { gets.split.map(&:to_i) }\nsum = 0\n$n = 0\n$heap = []\nq.each do |a, b|\n  insert( [dist(p[a], p[b]), a, b] )\nend\nuntil $n < 1\n  d, p0, p1 = extract\n  if ( p0 = find(p0) ) != ( p1 = find(p1) )\n    $sibling[p2] = p1\n  else\n    sum += d\n  end\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "def dist(p0, p1)\n  Math.sqrt( (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 )\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [0, *n.times.map { gets.split.map(&:to_f) }]\nq = m.times.map { gets.split.map(&:to_i) }\nq = q.map{ |a, b| [a, b, dist(p[a], p[b])] }\nsum = q.map{ |_, _, d| d }.reduce(:+)\nuntil q.empty?\n  ps = q.max{ |a, b| a[2] <=> b[2] }\n  q.delete(ps)\n  p1, p2, d = ps\n  if ( p1 = find(p1) ) != ( p2 = find(p2) )\n    $sibling[p2] = p1\n    sum -= d\n  end\nend\np sum < 0 ? 0 : sum"
  },
  {
    "language": "Ruby",
    "code": "def max_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] > $heap[x][0]\n    maximum = l\n  else\n    maximum = x\n  end\n  if r <= $n && $heap[r][0] > $heap[maximum][0]\n    maximum = r\n  end\n  if maximum != x\n    $heap[x], $heap[maximum] = $heap[maximum], $heap[x]\n    max_heapify(maximum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  max_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] < $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dist(p0, p1)\n  Math.sqrt( (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 )\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [ 0, *n.times.map { gets.split.map(&:to_f) } ]\nq = m.times.map { gets.split.map(&:to_i) }\nsum = 0\n$n = 0\n$heap = []\nq.each do |a, b|\n  insert( [dist(p[a], p[b]), a, b] )\nend\nuntil $n < 1\n  d, p1, p2 = extract\n  if ( p1 = find(p1) ) != ( p2 = find(p2) )\n    $sibling[p2] = p1\n  else\n    sum += d\n  end\nend\np sum < 0 ? 0 : sum"
  },
  {
    "language": "Ruby",
    "code": "def max_heapify(x = 1)\n  l = 2*x\n  r = 2*x+1\n  if l <= $n && $heap[l][0] > $heap[x][0]\n    maximum = l\n  else\n    maximum = x\n  end\n  if r <= $n && $heap[r][0] > $heap[maximum][0]\n    maximum = r\n  end\n  if maximum != x\n    $heap[x], $heap[maximum] = $heap[maximum], $heap[x]\n    max_heapify(maximum)\n  end\nend\n\ndef extract\n  key = $heap[1]\n  $heap[1] = $heap[$n]\n  $n -= 1\n  max_heapify\n  key\nend\n\ndef insert(key)\n  $n += 1\n  $heap[$n] = key\n  i = $n\n  while i > 1 && $heap[i/2][0] < $heap[i][0]\n    $heap[i], $heap[i/2] = $heap[i/2], $heap[i]\n    i /= 2\n  end\nend\n\ndef dist(p0, p1)\n  Math.sqrt( (p0[0] - p1[0]) ** 2 + (p0[1] - p1[1]) ** 2 )\nend\n\ndef find(x)\n  x == $sibling[x] ? x : $sibling[x] = find($sibling[x])\nend\n\nn, m = gets.split.map(&:to_i)\n$sibling = Array.new(n + 1) { |i| i }\np = [0, *n.times.map { gets.split.map(&:to_f) }]\nq = m.times.map { gets.split.map(&:to_i) }\nsum = 0\n$n = 0\n$heap = []\nq.each do |a, b|\n  d = dist(p[a], p[b])\n  sum += d\n  insert( [d, a, b] )\nend\nuntil $n < 1\n  ps = extract\n  d, p1, p2 = ps\n  if ( p1 = find(p1) ) != ( p2 = find(p2) )\n    $sibling[p2] = p1\n    sum -= d\n  end\nend\np sum < 0 ? 0 : sum"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\n\tdef get_path_by_bfs(s, t)\n\t\tprev_node = {}\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\twhile !queue.empty? \n\t\t\tu = queue.shift\n\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\tnext if reached.include?(v)\t\n\t\t\t\treached << v\n\t\t\t\tqueue << v\n\t\t\t\tprev_node[v] = u\n\n\t\t\t\tif v == t\n\t\t\t\t\tpath = [v]\n\t\t\t\t\twhile v = prev_node[v]\n\t\t\t\t\t\tpath.unshift v\n\t\t\t\t\tend\n\t\t\t\t\treturn path\n\t\t\t\tend\n\t\t\t}\n\t\tend\t\n\t\treturn nil\n\tend\n\n\tdef get_path_by_dfs(s, t, reached = Set.new)\n\t\treached << s\n\t\treturn [s] if s == t\n\t\teach_out_connection_of(s){|v|\n\t\t\tnext if reached.include?(v)\n\t\t\tpath = get_path_by_dfs(v, t, reached) \n\t\t\treturn [s] + path if path\n\t\t}\n\t\tnil\n\tend\n\n\tdef reachable_from(s, max_depth = nil)\n\t\treached = Set[s]\n\t\tqueue = [s]\n\t\tdepth = 0\n\t\tloop {\n\t\t\tbreak if max_depth && depth >= max_depth\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t\tdepth += 1\n\t\t}\n\t\treturn reached\n\tend\n\n\tdef bfs(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treached = Set[*start.to_a]\n\t\tqueue = []\n\t\tstart.each{|s| queue << s}\n\t\tdist = {}\n\t\tloop.with_index {|_, depth|\n\t\t\tnext_queue = []\n\t\t\tuntil queue.empty?\n\t\t\t\tu = queue.shift\n\t\t\t\treturn depth if block_given? && yield(u, depth)\n\t\t\t\tdist[u] = depth\n\t\t\t\teach_out_connection_of(u){|v, _|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_queue << v\n\t\t\t\t}\n\t\t\tend\n\t\t\tbreak if next_queue.empty?\n\t\t\tqueue = next_queue\n\t\t}\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef dijkstra(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\th = Heap.new\n\t\treached = Set[*start.to_a]\n\t\tstart.each{|s| h.add(s, 0)}\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\treturn key if block_given? && yield(u, key)\n\t\t\tdist[u] = key\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\tdef bidir_dijkstra(s, t)\n\t\tf_dist = {}\n\t\tb_dist = {}\n\n\t\tf_heap = Heap.new\n\t\tb_heap = Heap.new\n\n\t\tf_heap.add(s, 0)\n\t\tb_heap.add(t, 0)\n\n\t\tf_reached = Set[s]\n\t\tb_reached = Set[t]\n\n\t\tf_current_dist = b_current_dist = 0\n\t\tbest = Float::INFINITY\n\n\t\tloop {\n\t\t\tif !f_heap.empty?\n\t\t\t\tu, key = f_heap.del_min\n\t\t\t\tf_dist[u] = key\n\t\t\t\tf_current_dist = key\n\t\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\t\td = f_dist[u] + l\n\t\t\t\t\tif b_dist[v]\n\t\t\t\t\t\tpath_len = d + b_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif f_reached.include?(v)\n\t\t\t\t\t\tf_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tf_heap.add(v, d)\n\t\t\t\t\t\tf_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\tif !b_heap.empty?\n\t\t\t\tu, key = b_heap.del_min\n\t\t\t\tb_dist[u] = key\n\t\t\t\tb_current_dist = key\n\t\t\t\teach_in_connection_of(u){|v, l|\n\t\t\t\t\td = b_dist[u] + l\n\t\t\t\t\tif f_dist[v]\n\t\t\t\t\t\tpath_len = d + f_dist[v]\n\t\t\t\t\t\tbest = path_len if path_len < best\n\t\t\t\t\tend\n\t\t\t\t\tif b_reached.include?(v)\n\t\t\t\t\t\tb_heap.update_key(v, d)\n\t\t\t\t\telse\n\t\t\t\t\t\tb_heap.add(v, d)\n\t\t\t\t\t\tb_reached << v\n\t\t\t\t\tend\n\t\t\t\t}\n\t\t\tend\n\n\t\t\treturn best if f_current_dist + b_current_dist >= best\n\t\t\treturn nil if f_heap.empty? && b_heap.empty?\n\t\t}\n\tend\n\n\tdef a_star(start)\n\t\traise \"a_star need termination condition\" unless block_given?\n\t\th = Heap.new\n\t\treached = Set[start]\n\t\th.add(start, [a_star_heuristic(start), 0])\n\n\t\tdist = {}\n\t\tuntil h.empty?\n\t\t\tu, (e, d) = h.del_min\n\t\t\treturn d if yield(u, dist)\n\t\t\tdist[u] = d\n\t\t\teach_out_connection_of(u){|v, l|\n\t\t\t\td = dist[u] + l\n\t\t\t\te = d + a_star_heuristic(v)\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, [e, d])\n\t\t\t\telse\n\t\t\t\t\th.add(v, [e, d])\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\tblock_given? ? nil : dist\n\tend\n\n\t#make_variations :bidir_dijkstra\n\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\n\n\tdef each_layer_from(start)\n\t\traise \"start must be Enumerable\" if !start.kind_of?(Enumerable)\n\t\treturn enum_for(__method__, start) unless block_given?\n\t\treached = Set[*start]\n\t\tcurrent_layer = start\n\n\t\tloop {\n\t\t\tyield current_layer\n\t\t\tnext_layer = []\n\t\t\tcurrent_layer.each{|u|\n\t\t\t\teach_out_connection_of(u){|v|\n\t\t\t\t\tnext if reached.include?(v)\n\t\t\t\t\treached << v\n\t\t\t\t\tnext_layer << v\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\treturn if next_layer.empty?\n\t\t\tcurrent_layer = next_layer\n\t\t}\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nn, m = gets.split.map &:to_i\n\ng = Graph.new\n\nnodes = (1..n).map{\n\tv = g.add_node\n\tv.property[:x], v.property[:y] = gets.split.map &:to_i\n\tv\n}\n\ntotal_len = 0\n(1..m).each{\n    i, j = gets.split.map &:to_i\n    i -= 1\n    j -= 1\n    u, v = nodes[i], nodes[j]\n    x1, y1 = u.property[:x], u.property[:y]\n    x2, y2 = v.property[:x], v.property[:y]\n    d = Math.sqrt((x1-x2)**2 + (y1-y2)**2)\n    total_len += d\n    g.add_edge(nodes[i], nodes[j], {:length => -d})\n}\n\nreached = Set.new\nsum = 0\nnodes.each{|u|\n\tnext if reached.include?(u)\n\ttotal_len += g.prim(u)\t\n\tg.reachable_from(u).each{|v|\n\t\treached << v\n\t}\n}\np total_len"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass UnionFind:\n    def __init__(self, size):\n        self.table = [-1 for _ in range(size)]\n\n    def find(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.find(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        s1 = self.find(x)\n        s2 = self.find(y)\n        if s1 != s2:\n            if self.table[s1] <= self.table[s2]:\n                self.table[s1] += self.table[s2]\n                self.table[s2] = s1\n            else:\n                self.table[s2] += self.table[s1]\n                self.table[s1] = s2\n            return True\n        return False\n\n    def subsetall(self):\n        a = []\n        for i in range(len(self.table)):\n            if self.table[i] < 0:\n                a.append((i, -self.table[i]))\n        return a\n\ndef ky2(a,b):\n    return pow(a[0]-b[0], 2) + pow(a[1]-b[1], 2)\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        global fr\n        a = [LI() for _ in range(n)]\n        es = []\n        for _ in range(m):\n            b,c = LI_()\n            es.append([ky2(a[b],a[c]), b, c])\n        es.sort(reverse=True)\n        r = 0\n        uf = UnionFind(n)\n        for k,b,c in es:\n            if uf.union(b,c):\n                continue\n            r += pow(k,0.5)\n\n        return '{:0.3f}'.format(r)\n\n    while 1:\n        n,m = LI()\n        if n == 0 and m == 0:\n            break\n        rr.append(f(n,m))\n        break\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "def dist(c1, c2):\n    return ((c1[0]-c2[0])**2+(c1[1]-c2[1])**2)**.5\n\n\ndef kruskal(edges, size):\n    uf = UnionFind(size)\n    edges = sorted(edges, key=lambda e: e[2])[::-1]\n    ret = 0\n    for u, v, weight in edges:\n        if not uf.same(u, v):\n            uf.unite(u, v)\n            ret += weight\n    return ret\n\n\nclass UnionFind:\n    def __init__(self, size):\n        self.parent = list(range(size))\n        self.rank = [0] * size\n\n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n\n    def unite(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n        if x == y:\n            return\n        if self.rank[x] < self.rank[y]:\n            self.parent[x] = y\n        else:\n            self.parent[y] = x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\n    def same(self, x, y):\n        return self.find(x) == self.find(y)\n\n\nN, M = map(int, input().split())\ncoords = [tuple(map(int, input().split())) for i in range(N)]\nedges = []\nfor i in range(M):\n    p, q = map(lambda x: int(x) - 1, input().split())\n    edges.append((p, q, dist(coords[p], coords[q])))\nprint(sum(e[2] for e in edges) - kruskal(edges, N))\n\n"
  },
  {
    "language": "Python",
    "code": "N,M = map(int,input().rstrip().split())\npileDict = {}\nfor i in range(N):\n    prow,pcol = map(lambda x: int(x),input().rstrip().split())\n    pileDict[i] = [prow,pcol]\nedgeDict = {}\nfor i in range(M):\n    fs,fe = map(lambda x: int(x),input().rstrip().split())\n    edgeDict[i] = [fs,fe]\n\n\nprint(\"test\")"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, size):\n        self.table = [-1] * size\n    \n    def find(self, x):\n        while self.table[x] >= 0:\n            x = self.table[x]\n        return x\n    \n    def union(self, x, y):\n        x_root = self.find(x)\n        y_root = self.find(y)\n        if x_root != y_root:\n            if self.table[x_root] < self.table[y_root]:\n                self.table[x_root] += self.table[y_root]\n                self.table[y_root] = x_root\n            else:\n                self.table[y_root] += self.table[x_root]\n                self.table[x_root] = y_root\n    \n    def isDisjoint(self, x, y):\n        return self.find(x) != self.find(y)\n\ndef solve():\n    import sys\n    file_input = sys.stdin\n    N, M = map(int, file_input.readline().split())\n    \n    piles = [tuple(map(int, file_input.readline().split())) for i in range(N)]\n    \n    fences = []\n    for i in range(M):\n        p, q = map(int, file_input.readline().split())\n        p -= 1\n        q -= 1\n        px, py = piles[p]\n        qx, qy = piles[q]\n        fence_len = ((px - qx) ** 2 + (py - qy) ** 2) ** 0.5\n        fences.append((fence_len, p, q))\n    \n    fences.sort(reverse=True)\n    S = UnionFind(N)\n    fences_len = 0\n    \n    for f_len, p1, p2 in fences:\n        if S.isDisjoint(p1, p2):\n            S.union(p1, p2)\n        else:\n            fences_len += f_len\n    \n    print(fences_len)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.data=[-1 for i in range(n)]\n\n    def root(self,x):\n        if self.data[x]<0:\n            return x\n        else:\n            self.data[x]=self.root(self.data[x])\n            return self.data[x]\n\n    def uni(self,x,y):\n        x=self.root(x)\n        y=self.root(y)\n        if(x==y):\n            return\n        if self.data[y]<self.data[x]:\n            x,y=y,x\n        self.data[x]+= self.data[y]\n        self.data[y] = x\n\n    def same(self,x,y):\n        return self.root(x)==self.root(y)\n\n    def size(self,x):\n        return -self.data[self.root(x)]\n\n\nn,m=map(int,input().split())\nuf=UnionFind(n)\ncd=[]\ng=[[] for i in range(n)]\nsm=0.0\nfor i in range(n):\n    cd.append(tuple(map(int,input().split())))\nf=0\nfor j in range(m):\n    p,q=map(int,input().split())\n    p,q=p-1,q-1\n    uf.uni(p,q)\n    f=p\n    g[p].append((-((cd[p][0]-cd[q][0])**2+(cd[p][1]-cd[q][1])**2)**0.50,q))\n    g[q].append((-((cd[p][0]-cd[q][0])**2+(cd[p][1]-cd[q][1])**2)**0.50,p))\n    sm+=((cd[p][0]-cd[q][0])**2+(cd[p][1]-cd[q][1])**2)**0.50\n\nfrom heapq import heappush, heappop, heapify\nused = [0 for i in range(n)]\nans = 0\nfor i in range(n):\n    if uf.data[i]>=0:\n        continue\n    que = [(c, w) for c, w in g[i]]\n    used[i] = 1\n    heapify(que)\n    while que:\n        cv, v = heappop(que)\n        if used[v]:\n            continue\n        used[v] = 1\n        ans -= cv\n        for c, w in g[v]:\n            if used[w]:\n                continue\n            heappush(que, (c, w))\n\nprint(sm-ans)\n"
  },
  {
    "language": "Rust",
    "code": "#![allow(non_snake_case)]\n#![allow(dead_code)]\n\npub fn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    s.trim().parse().ok().unwrap()\n}\n\npub fn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\npub fn read_tuple<T: std::str::FromStr + Copy>() -> (T, T) {\n    let v: Vec<T> = read_vec();\n    (v[0], v[1])\n}\n\npub struct Edge {\n    from: usize,\n    to: usize,\n    weight: f64\n}\n\npub fn kruskal(edges: &mut Vec<Edge>, size: usize) -> f64 {\n    let mut uf = UnionFind::new(size);\n    edges.sort_by(|a, b| b.weight.partial_cmp(&a.weight).unwrap());\n    let mut ret = 0.0;\n    for e in edges {\n        if !uf.same(e.from, e.to) {\n            uf.unite(e.from, e.to);\n            ret += e.weight;\n        }\n    }\n    ret\n}\n\npub struct UnionFind {\n    par: Vec<usize>,\n    rank: Vec<usize>\n}\n\nimpl UnionFind {\n    pub fn new(size: usize) -> UnionFind {\n        UnionFind {\n            par: (0..size).collect(),\n            rank: vec![0; size]\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let par = self.par[x];\n            self.par[x] = self.find(par);\n            self.par[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) {\n        let x = self.find(x);\n        let y = self.find(y);\n        if x == y {\n            return;\n        }\n\n        if self.rank[x] < self.rank[y] {\n            self.par[x] = y;\n        } else {\n            self.par[y] = x;\n            if self.rank[x] == self.rank[y] {\n                self.rank[x] += 1;\n            }\n        }\n    }\n\n    pub fn same(&mut self, x: usize, y: usize) -> bool {\n        self.find(x) == self.find(y)\n    }\n}\n\npub fn dist(c1: (i32, i32), c2: (i32, i32)) -> f64 {\n    (((c1.0-c2.0).pow(2) + (c1.1-c2.1).pow(2)) as f64).sqrt()\n}\n\n\nfn main() {\n    let (N, M) = read_tuple::<usize>();\n    let coords: Vec<(i32, i32)> = (0..N).map(|_| read_tuple::<i32>()).collect();\n    let mut edges = Vec::new();\n    for i in 0..M {\n        let (p, q) = read_tuple::<usize>();\n        let p = p - 1;\n        let q = q - 1;\n        edges.push(Edge {\n            from: p,\n            to: q,\n            weight: dist(coords[p], coords[q])\n        });\n    }\n    let ans: f64 = edges.iter().map(|e| e.weight).sum::<f64>() - kruskal(&mut edges, N);\n    println!(\"{}\", ans);\n}\n\n"
  }
]