[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#define MAX_CITIES 200001\n\ntypedef struct {\n    int* adj[MAX_CITIES];\n    int adj_size[MAX_CITIES];\n    int adj_capacity[MAX_CITIES];\n} Graph;\n\nvoid graph_init(Graph* g, int n) {\n    for (int i = 0; i < n; i++) {\n        g->adj[i] = malloc(sizeof(int) * 10);\n        g->adj_size[i] = 0;\n        g->adj_capacity[i] = 10;\n    }\n}\n\nvoid graph_add_edge(Graph* g, int u, int v) {\n    if (g->adj_size[u] == g->adj_capacity[u]) {\n        g->adj_capacity[u] *= 2;\n        g->adj[u] = realloc(g->adj[u], sizeof(int) * g->adj_capacity[u]);\n    }\n    if (g->adj_size[v] == g->adj_capacity[v]) {\n        g->adj_capacity[v] *= 2;\n        g->adj[v] = realloc(g->adj[v], sizeof(int) * g->adj_capacity[v]);\n    }\n    g->adj[u][g->adj_size[u]++] = v;\n    g->adj[v][g->adj_size[v]++] = u;\n}\n\nbool bipartite_check(Graph* g, int n, int* color) {\n    memset(color, -1, sizeof(int) * n);\n    for (int start = 0; start < n; start++) {\n        if (color[start] != -1) continue;\n        \n        color[start] = 0;\n        int queue[MAX_CITIES], front = 0, rear = 0;\n        queue[rear++] = start;\n        \n        while (front < rear) {\n            int u = queue[front++];\n            for (int i = 0; i < g->adj_size[u]; i++) {\n                int v = g->adj[u][i];\n                if (color[v] == -1) {\n                    color[v] = 1 - color[u];\n                    queue[rear++] = v;\n                }\n                else if (color[v] == color[u]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n\nint solve(int n, int m, int* edges) {\n    Graph g;\n    graph_init(&g, n);\n    \n    for (int i = 0; i < m; i++) {\n        graph_add_edge(&g, edges[2*i]-1, edges[2*i+1]-1);\n    }\n    \n    int color[MAX_CITIES];\n    if (!bipartite_check(&g, n, color)) return -1;\n    \n    int cut_edges = 0;\n    for (int i = 0; i < m; i++) {\n        int u = edges[2*i]-1, v = edges[2*i+1]-1;\n        if (color[u] != color[v]) cut_edges++;\n    }\n    \n    for (int i = 0; i < n; i++) {\n        free(g.adj[i]);\n    }\n    \n    return cut_edges;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    \n    int edges[2*m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &edges[2*i], &edges[2*i+1]);\n    }\n    \n    printf(\"%d\\n\", solve(n, m, edges));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <limits.h>\n\n#define MAX_N 17\n\nint N, M;\nbool adj[MAX_N][MAX_N];\nint dp[1 << MAX_N];\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nbool is_clique(int mask) {\n    for (int i = 0; i < N; i++) {\n        if (!(mask & (1 << i))) continue;\n        for (int j = i + 1; j < N; j++) {\n            if (!(mask & (1 << j))) continue;\n            if (!adj[i][j]) return false;\n        }\n    }\n    return true;\n}\n\nint solve() {\n    for (int mask = 0; mask < (1 << N); mask++) {\n        dp[mask] = INT_MAX;\n    }\n    dp[0] = 0;\n\n    for (int mask = 1; mask < (1 << N); mask++) {\n        if (is_clique(mask)) {\n            dp[mask] = 0;\n            continue;\n        }\n        for (int submask = mask; submask > 0; submask = (submask - 1) & mask) {\n            if (submask == mask) continue;\n            int other = mask ^ submask;\n            if (dp[submask] != INT_MAX && dp[other] != INT_MAX) {\n                dp[mask] = min(dp[mask], dp[submask] + dp[other] + __builtin_popcount(submask) * __builtin_popcount(other));\n            }\n        }\n    }\n\n    return dp[(1 << N) - 1] == INT_MAX ? -1 : dp[(1 << N) - 1];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            adj[i][j] = false;\n        }\n    }\n    for (int i = 0; i < M; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        adj[a][b] = adj[b][a] = true;\n    }\n    printf(\"%d\\n\", solve());\n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nbool isBipartite(int start, const vector<vector<int>>& adj, vector<int>& color) {\n    queue<int> q;\n    q.push(start);\n    color[start] = 0;\n    \n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        \n        for (int v : adj[u]) {\n            if (color[v] == -1) {\n                color[v] = 1 - color[u];\n                q.push(v);\n            } else if (color[v] == color[u]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n    \n    vector<int> color(N + 1, -1);\n    bool possible = true;\n    for (int i = 1; i <= N; ++i) {\n        if (color[i] == -1) {\n            if (!isBipartite(i, adj, color)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n    \n    if (!possible) {\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    int count0 = 0, count1 = 0;\n    for (int i = 1; i <= N; ++i) {\n        if (color[i] == 0) ++count0;\n        else if (color[i] == 1) ++count1;\n    }\n    \n    int min_roads = (count0 * (count0 - 1) / 2) + (count1 * (count1 - 1) / 2) - M;\n    cout << min_roads << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:05:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        boolean[][] adj = new boolean[N + 1][N + 1];\n        for (int i = 0; i < M; i++) {\n            int a = sc.nextInt();\n            int b = sc.nextInt();\n            adj[a][b] = true;\n            adj[b][a] = true;\n        }\n\n        int minRoads = Integer.MAX_VALUE;\n\n        // Iterate all possible subsets for Taka (non-empty and not all)\n        for (int mask = 1; mask < (1 << N) - 1; mask++) {\n            List<Integer> taka = new ArrayList<>();\n            List<Integer> hashi = new ArrayList<>();\n            for (int i = 1; i <= N; i++) {\n                if ((mask & (1 << (i - 1))) != 0) {\n                    taka.add(i);\n                } else {\n                    hashi.add(i);\n                }\n            }\n\n            boolean valid = true;\n            // Check Taka is a clique\n            for (int i = 0; i < taka.size() && valid; i++) {\n                for (int j = i + 1; j < taka.size() && valid; j++) {\n                    if (!adj[taka.get(i)][taka.get(j)]) {\n                        valid = false;\n                    }\n                }\n            }\n            // Check Hashi is a clique\n            for (int i = 0; i < hashi.size() && valid; i++) {\n                for (int j = i + 1; j < hashi.size() && valid; j++) {\n                    if (!adj[hashi.get(i)][hashi.get(j)]) {\n                        valid = false;\n                    }\n                }\n            }\n\n            if (valid) {\n                int roads = 0;\n                for (int i = 0; i < taka.size(); i++) {\n                    for (int j = i + 1; j < taka.size(); j++) {\n                        if (adj[taka.get(i)][taka.get(j)]) {\n                            roads++;\n                        }\n                    }\n                }\n                for (int i = 0; i < hashi.size(); i++) {\n                    for (int j = i + 1; j < hashi.size(); j++) {\n                        if (adj[hashi.get(i)][hashi.get(j)]) {\n                            roads++;\n                        }\n                    }\n                }\n                minRoads = Math.min(minRoads, roads);\n            }\n        }\n\n        if (minRoads != Integer.MAX_VALUE) {\n            System.out.println(minRoads);\n        } else {\n            System.out.println(-1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:06:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int minimumRoads(int N, int M, int[][] roads) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] road : roads) {\n            int u = road[0] - 1;\n            int v = road[1] - 1;\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        int[] color = new int[N];\n        Arrays.fill(color, -1);\n        \n        int componentsCount = 0;\n        for (int i = 0; i < N; i++) {\n            if (color[i] == -1) {\n                if (!bfs(graph, color, i, componentsCount)) {\n                    return -1;\n                }\n                componentsCount++;\n            }\n        }\n        \n        return componentsCount - 1;\n    }\n    \n    private static boolean bfs(List<List<Integer>> graph, int[] color, int start, int componentColor) {\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        color[start] = componentColor;\n        \n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            \n            for (int neighbor : graph.get(current)) {\n                if (color[neighbor] == -1) {\n                    color[neighbor] = 1 - color[current];\n                    queue.offer(neighbor);\n                } else if (color[neighbor] == color[current]) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n}",
    "timestamp": "2025-08-05 23:06:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumRoadsCut(int N, vector<vector<int>>& roads) {\n        vector<vector<int>> graph(N + 1);\n        \n        // Build adjacency list\n        for (auto& road : roads) {\n            graph[road[0]].push_back(road[1]);\n            graph[road[1]].push_back(road[0]);\n        }\n        \n        vector<int> color(N + 1, 0);\n        \n        // Try bipartite coloring\n        for (int i = 1; i <= N; i++) {\n            if (color[i] == 0) {\n                if (!dfs(i, 1, graph, color)) {\n                    return -1;\n                }\n            }\n        }\n        \n        // Count roads within same state\n        int cutRoads = 0;\n        for (auto& road : roads) {\n            if (color[road[0]] == color[road[1]]) {\n                cutRoads++;\n            }\n        }\n        \n        return cutRoads;\n    }\n    \nprivate:\n    bool dfs(int node, int c, vector<vector<int>>& graph, vector<int>& color) {\n        color[node] = c;\n        \n        for (int neighbor : graph[node]) {\n            if (color[neighbor] == 0) {\n                if (!dfs(neighbor, 3 - c, graph, color)) {\n                    return false;\n                }\n            } else if (color[neighbor] == color[node]) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};",
    "timestamp": "2025-08-05 23:06:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve(N, M, roads):\n    def bfs(start):\n        queue = deque([start])\n        color[start] = 0\n        expected_edges = 0\n        while queue:\n            city = queue.popleft()\n            for neighbor in adj[city]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[city]\n                    expected_edges += color[neighbor] == 0\n                    queue.append(neighbor)\n                elif color[neighbor] == color[city]:\n                    return 0, float('inf')  # Bipartition is not possible\n        return sum(color), expected_edges\n    \n    adj = [[] for _ in range(N)]\n    for a, b in roads:\n        adj[a - 1].append(b - 1)\n        adj[b - 1].append(a - 1)\n    \n    color = [-1] * N\n    total_within_state_edges = 0\n    possible = True\n\n    for i in range(N):\n        if color[i] == -1:\n            total_within_state_edges += bfs(i)[1]\n            if not possible:\n                break\n            \n    return total_within_state_edges if possible else -1\n\n# Example usage:\n# N, M = 5, 4\n# roads = [(1, 2), (2, 3), (3, 4), (4, 5)]\n# print(solve(N, M, roads))  # Output: -1",
    "timestamp": "2025-08-13 13:34:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n\n        List<Integer>[] graph = new List[N + 1];\n        for (int i = 1; i <= N; i++) {\n            graph[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph[u].add(v);\n            graph[v].add(u);\n        }\n\n        int[] color = new int[N + 1];\n        \n        for (int i = 1; i <= N; i++) {\n            if (color[i] == 0 && !bipartiteDfs(graph, color, i, 1)) {\n                System.out.println(-1);\n                return;\n            }\n        }\n\n        int count = 0;\n        for (int u = 1; u <= N; u++) {\n            for (int v : graph[u]) {\n                if (u < v && color[u] == color[v]) {\n                    count++;\n                }\n            }\n        }\n        System.out.println(count);\n    }\n\n    private static boolean bipartiteDfs(List<Integer>[] graph, int[] color, int node, int col) {\n        color[node] = col;\n        for (int neighbor : graph[node]) {\n            if (color[neighbor] == 0) {\n                if (!bipartiteDfs(graph, color, neighbor, -col)) {\n                    return false;\n                }\n            } else if (color[neighbor] == col) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 13:34:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100000\n#define MAXM 200000\n\ntypedef struct {\n    int u, v;\n} Road;\n\nRoad roads[MAXM];\nint parent[MAXN + 1];\nint size[MAXN + 1];\nint color[MAXN + 1];\n\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        parent[i] = i;\n        size[i] = 1;\n        color[i] = -1; // -1 means uncolored\n    }\n}\n\nint find(int x) {\n    if (parent[x] != x) {\n        parent[x] = find(parent[x]);\n    }\n    return parent[x];\n}\n\nvoid union_sets(int a, int b) {\n    int rootA = find(a);\n    int rootB = find(b);\n    if (rootA != rootB) {\n        if (size[rootA] < size[rootB]) {\n            parent[rootA] = rootB;\n        } else if (size[rootA] > size[rootB]) {\n            parent[rootB] = rootA;\n        } else {\n            parent[rootB] = rootA;\n            size[rootA]++;\n        }\n    }\n}\n\nint dfs_color(int node, int col) {\n    color[node] = col;\n    for (int i = 0; i < 2 * MAXM; i++) {\n        int neighbor = -1;\n        if (roads[i].u == node) {\n            neighbor = roads[i].v;\n        } else if (roads[i].v == node) {\n            neighbor = roads[i].u;\n        }\n        if (neighbor != -1) {\n            if (color[neighbor] == -1) {\n                if (!dfs_color(neighbor, !col)) return 0;\n            } else if (color[neighbor] == col) {\n                return 0;\n            }\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n\n    init(n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        roads[i] = (Road){u, v};\n        union_sets(u, v);\n    }\n\n    int valid = 1;\n    for (int i = 1; i <= n; i++) {\n        if (color[i] == -1) {\n            if (!dfs_color(i, 0)) {\n                valid = 0;\n                break;\n            }\n        }\n    }\n\n    if (!valid) {\n        printf(\"-1\\n\");\n    } else {\n        int min_roads_cut = 0;\n        for (int i = 0; i < m; i++) {\n            if (color[roads[i].u] == color[roads[i].v]) {\n                min_roads_cut++;\n            }\n        }\n        printf(\"%d\\n\", min_roads_cut / 2);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 13:34:25"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nbool isBipartite(const vector<vector<int>>& adj, vector<int>& color, int start) {\n    queue<int> q;\n    q.push(start);\n    color[start] = 0; // Start coloring with 0\n\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n\n        for (int v : adj[u]) {\n            if (color[v] == -1) {\n                // Color with opposite color\n                color[v] = 1 - color[u];\n                q.push(v);\n            } else if (color[v] == color[u]) {\n                // Found same color neighbor, not bipartite\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<vector<int>> adj(N + 1);\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> color(N + 1, -1); // -1 means uncolored\n    bool possible = true;\n    for (int i = 1; i <= N; ++i) {\n        if (color[i] == -1) {\n            if (!isBipartite(adj, color, i)) {\n                possible = false;\n                break;\n            }\n        }\n    }\n\n    if (!possible) {\n        cout << -1 << endl;\n    } else {\n        int count = 0;\n        for (int u = 1; u <= N; ++u) {\n            for (int v : adj[u]) {\n                if (color[u] == color[v]) {\n                    count++;\n                }\n            }\n        }\n        cout << count / 2 << endl; // Each edge is counted twice\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 13:34:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_state_division(N, roads):\n    # Create adjacency list representation of the graph\n    graph = [[] for _ in range(N+1)]\n    for u, v in roads:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Try to color the graph with 2 colors\n    color = [0] * (N+1)\n    \n    def dfs(node, current_color):\n        color[node] = current_color\n        for neighbor in graph[node]:\n            if color[neighbor] == current_color:\n                return False\n            if color[neighbor] == 0 and not dfs(neighbor, 3 - current_color):\n                return False\n        return True\n    \n    # Check if graph is 2-colorable\n    for i in range(1, N+1):\n        if color[i] == 0:\n            if not dfs(i, 1):\n                return -1\n    \n    # Count roads within same state\n    same_state_roads = 0\n    for u, v in roads:\n        if color[u] == color[v]:\n            same_state_roads += 1\n    \n    return same_state_roads\n\n# Read input\nN, M = map(int, input().split())\nroads = []\nfor _ in range(M):\n    u, v = map(int, input().split())\n    roads.append((u, v))\n\n# Print result\nprint(solve_state_division(N, roads))",
    "timestamp": "2025-08-13 13:34:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        a, b = map(int, sys.stdin.readline().split())\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Check if the graph is bipartite\n    color = [-1] * (N+1)\n    is_bipartite = True\n    q = deque()\n    \n    for i in range(1, N+1):\n        if color[i] == -1:\n            q.append(i)\n            color[i] = 0\n            while q:\n                v = q.popleft()\n                for u in adj[v]:\n                    if color[u] == -1:\n                        color[u] = color[v] ^ 1\n                        q.append(u)\n                    elif color[u] == color[v]:\n                        is_bipartite = False\n    \n    if not is_bipartite:\n        print(-1)\n        return\n    \n    # Count the number of nodes in each partition\n    cnt0 = color.count(0)\n    cnt1 = N - cnt0\n    \n    # The answer is the number of edges within partitions, which is (edges in Taka) + (edges in Hashi)\n    # But we need to minimize (edges in Taka) + (edges in Hashi)\n    # Since the graph is bipartite, the minimal is achieved when one partition is as small as possible\n    \n    # However, the minimal is (cnt0 choose 2) + (cnt1 choose 2) - M\n    # Because the original graph has M edges, and the bipartition ensures no edges within partitions\n    \n    # Wait, no. The problem requires that within each state, every pair must be connected by a road.\n    # So each state must be a complete graph (clique).\n    # So the graph must be a complement of a bipartite graph.\n    # So the original graph must be such that its complement is bipartite.\n    # Which is equivalent to the original graph is a complete bipartite graph minus some edges.\n    # But the condition is that the two partitions must be cliques in the original graph.\n    \n    # So the problem reduces to checking if the graph can be partitioned into two cliques.\n    # This is equivalent to checking if the complement of the graph is bipartite.\n    \n    # So first, build the complement graph.\n    # But for N=1e5, building the complement is infeasible.\n    # So we need a smarter approach.\n    \n    # The problem is equivalent to checking if the graph is a bipartite graph where each partition is a clique.\n    # So the graph must be a complete bipartite graph minus some edges.\n    \n    # So first, check if the graph is bipartite.\n    # Then, check if each partition forms a clique in the original graph.\n    \n    if not is_bipartite:\n        print(-1)\n        return\n    \n    # Check if each partition is a clique\n    for v in range(1, N+1):\n        # All nodes in the same partition must be connected to v\n        for u in range(1, N+1):\n            if u == v:\n                continue\n            if color[u] == color[v] and u not in adj[v]:\n                print(-1)\n                return\n    \n    # Now, compute the minimal (edges in Taka) + (edges in Hashi)\n    # The number of edges in Taka is (cnt0 choose 2) - existing edges within Taka\n    # But since Taka is a clique, existing edges within Taka is (cnt0 choose 2)\n    # Similarly for Hashi.\n    # So the number of edges within same state is (cnt0 choose 2) + (cnt1 choose 2) - M\n    # But since the graph is bipartite, M is the number of edges between partitions, which is cnt0 * cnt1\n    # So the total edges is (cnt0 choose 2) + (cnt1 choose 2)\n    \n    # So the answer is (cnt0*(cnt0-1)//2) + (cnt1*(cnt1-1)//2)\n    ans = (cnt0 * (cnt0 - 1) // 2) + (cnt1 * (cnt1 - 1) // 2)\n    print(ans)\n\nsolve()",
    "timestamp": "2025-08-13 13:35:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minRoadsInSameState(N, M, roads) {\n    const adjList = Array.from({ length: N + 1 }, () => []);\n    const visited = Array(N + 1).fill(0);\n    const color = Array(N + 1).fill(-1);\n\n    const addEdge = (u, v) => {\n        adjList[u].push(v);\n        adjList[v].push(u);\n    };\n\n    const isBipartiteUtil = (u, c) => {\n        visited[u] = true;\n        color[u] = c;\n\n        for (const v of adjList[u]) {\n            if (!visited[v]) {\n                if (!isBipartiteUtil(v, 1 - c)) return false;\n            } else if (color[v] === color[u]) {\n                return false;\n            }\n        }\n        return true;\n    };\n\n    const isBipartite = () => {\n        for (let i = 1; i <= N; i++) {\n            if (!visited[i]) {\n                if (!isBipartiteUtil(i, 0)) return false;\n            }\n        }\n        return true;\n    };\n\n    roads.forEach(([u, v]) => addEdge(u, v));\n\n    if (!isBipartite()) return -1;\n\n    let countInSameState = 0;\n    roads.forEach(([u, v]) => {\n        if (color[u] === color[v]) countInSameState++;\n    });\n\n    return countInSameState;\n}",
    "timestamp": "2025-08-13 13:35:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function minimumRoadsCut(N, roads) {\n    const graph = Array.from({ length: N + 1 }, () => []);\n    for (const [u, v] of roads) {\n        graph[u].push(v);\n        graph[v].push(u);\n    }\n\n    const color = new Array(N + 1).fill(0);\n    let crossedRoads = 0;\n\n    for (let start = 1; start <= N; start++) {\n        if (color[start] === 0) {\n            if (!bipartiteDFS(start, 1)) return -1;\n        }\n    }\n\n    function bipartiteDFS(node, currentColor) {\n        color[node] = currentColor;\n        for (const neighbor of graph[node]) {\n            if (color[neighbor] === 0) {\n                if (!bipartiteDFS(neighbor, 3 - currentColor)) return false;\n            } else if (color[neighbor] === color[node]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    for (const [u, v] of roads) {\n        if (color[u] !== color[v]) crossedRoads++;\n    }\n\n    return crossedRoads;\n}",
    "timestamp": "2025-08-13 13:35:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const solve = () => {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [N, M] = input[0].split(' ').map(Number);\n    const adj = Array.from({ length: N + 1 }, () => new Set());\n    for (let i = 1; i <= M; i++) {\n        const [a, b] = input[i].split(' ').map(Number);\n        adj[a].add(b);\n        adj[b].add(a);\n    }\n\n    let minRoads = Infinity;\n\n    const isComplete = (nodes) => {\n        for (let i = 0; i < nodes.length; i++) {\n            for (let j = i + 1; j < nodes.length; j++) {\n                if (!adj[nodes[i]].has(nodes[j])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n\n    const backtrack = (index, taka, hashi) => {\n        if (index > N) {\n            if (taka.length === 0 || hashi.length === 0) return;\n            if (isComplete(taka) && isComplete(hashi)) {\n                let roads = 0;\n                for (const a of taka) {\n                    for (const b of taka) {\n                        if (a < b && adj[a].has(b)) roads++;\n                    }\n                }\n                for (const a of hashi) {\n                    for (const b of hashi) {\n                        if (a < b && adj[a].has(b)) roads++;\n                    }\n                }\n                minRoads = Math.min(minRoads, roads);\n            }\n            return;\n        }\n\n        // Try adding to Taka\n        taka.push(index);\n        backtrack(index + 1, taka, hashi);\n        taka.pop();\n\n        // Try adding to Hashi\n        hashi.push(index);\n        backtrack(index + 1, taka, hashi);\n        hashi.pop();\n    };\n\n    backtrack(1, [], []);\n\n    console.log(minRoads === Infinity ? -1 : minRoads);\n};\n\nsolve();",
    "timestamp": "2025-08-13 13:35:26"
  }
]