[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nint isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>abs(s.v.x))return false;\n  if(abs(q.y)>abs(s.v.y))return false;\n  return true;  \n}\n\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n}\n\nvoid init(){\n  c=0;\n  mp.clear();\n  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int i=0;i<size;i++)\n        G[id].push_back((Segment){t[i],t[(i+1)%size]-t[i]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npii operator-(const pii &a,const pii &b){\n    return make_pair(a.first-b.first,a.second-b.second);\n}\n\nvoid solve(int n){\n    map<string,int> t;\n    vector<vector<int>> vs;\n    vector<vector<pii>> ps;\n    int size=0;\n    rep(i,0,n){\n        string str;\n        cin >> str;\n        if(t.find(str)==t.end()){\n            t[str]=size;\n            vs.push_back(vector<int>());\n            ps.push_back(vector<pii>());\n            ++size;\n        }\n        int idx=t[str];\n        vs[idx].push_back(i);\n        while(true){\n            int x,y;\n            cin >> x;\n            if(x==-1) break;\n            cin >> y;\n            ps[idx].push_back(make_pair(x,y));\n        }\n    }\n\n    auto cross=[](pii &a,pii &b){\n        return a.first*b.second-a.second*b.first;\n    };\n\n    vector<vector<int>> graph(size);\n    rep(i,0,size) rep(j,0,i){\n        if([&](){\n            rep(i_,0,ps[i].size()) rep(j_,0,ps[j].size()){\n                pii &p1=ps[i][i_],&p2=ps[i][(i_+1)%ps[i].size()];\n                pii &q1=ps[j][j_],&q2=ps[j][(j_+1)%ps[j].size()];\n                pii a=p1-p2,b=q1-q2;\n                pii c=p1-q2,d=p2-q1;\n                if(cross(a,b)) continue;\n                if(cross(c,d)) continue;\n                if(a.first and (max(p1.first,p2.first)==min(q1.first,q2.first) or min(p1.first,p2.first)==max(q1.first,q2.first))) continue;\n                if(a.second and (max(p1.second,p2.second)==min(q1.second,q2.second) or min(p1.second,p2.second)==max(q1.second,q2.second))) continue;\n                return true;\n            }\n            return false;\n        }()){\n            graph[i].push_back(j);\n            graph[j].push_back(i);\n        }\n    }\n\n    vector<int> dp(1<<size,inf);\n    vector<bool> done(1<<size);\n    dp[0]=0;\n    done[0]=true;\n    rep(i,0,size){\n        dp[1<<i]=1;\n        done[1<<i]=true;\n    }\n    function<int(int)> rec=[&](int s){\n        if(done[s]) return dp[s];\n        done[s]=true;\n        rep(t,0,1<<size){\n            if((s&t)!=t) continue;\n            int d=s&~t;\n            if([&](){\n                rep(i,0,size){\n                    if(!((d>>i)&1)) continue;\n                    for(int j:graph[i]) if((d>>j)&1) return false;\n                }\n                return true;\n            }()) dp[s]=min(dp[s],rec(t)+1);\n        }\n        return dp[s];\n    };\n    cout << rec((1<<size)-1) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){\n\t\tx+=p.x,y+=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator-=(Point p){\n\t\tx-=p.x,y-=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator*=(double c){\n\t\tx*=c,y*=c;\n\t\treturn *this;\n\t}\n\tPoint& operator/=(double c){\n\t\tx/=c,y/=c;\n\t\treturn *this;\n\t}\n};\nPoint operator+(Point a,Point b){\n\treturn a+=b;\n}\nPoint operator-(Point a,Point b){\n\treturn a-=b;\n}\nPoint operator*(Point a,double c){\n\treturn a*=c;\n}\nPoint operator*(double c,Point a){\n\treturn a*=c;\n}\nPoint operator/(Point a,double c){\n\treturn a/=c;\n}\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\n\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n\tPoint pos,dir;\n\tSegment(){}\n\tSegment(Point p,Point d):pos(p),dir(d){}\n\tSegment(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n\t//explicit Segment(Line l):pos(l.pos),dir(l.dir){}\n\t//explicit operator Line()const{return Line(pos,dir);}\n};\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\t//if(Dot(b,c)<-EPS)\n\t//\treturn -2;   // c-a-b\n\t//if(Abs2(b)<Abs2(c)-EPS)\n\t//\treturn 2;    // a-b-c\n\t//return 0;        // a-c-b (inclusive)\n\tif(Dot(b,c)<EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)+EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (exclusive)\n}\nbool IntersectSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\n\nint solve(const vvi& g,int u,vi& color)\n{\n\tint n=g.size();\n\tif(u==n) return *max_element(all(color))+1;\n\tint mx=*max_element(all(color));\n\tint res=INF;\n\tfor(int c=0;c<=mx+1;c++){\n\t\tbool ok=true;\n\t\tfor(int v:g[u])\n\t\t\tif(color[v]==c){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,solve(g,u+1,color));\n\t\t\tcolor[u]=-1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int m;cin>>m && m;){\n\t\tmap<string,int> ntoi;\n\t\tvi is(m);\n\t\tvvi xs(m),ys(m);\n\t\trep(i,m){\n\t\t\tstring name; cin>>name;\n\t\t\tntoi.insert(mp(name,ntoi.size()));\n\t\t\tis[i]=ntoi[name];\n\t\t\tfor(int x,y;cin>>x && x!=-1;){\n\t\t\t\tcin>>y;\n\t\t\t\txs[i].push_back(x);\n\t\t\t\tys[i].push_back(y);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint n=ntoi.size();\n\t\tvvi g(n);\n\t\trep(i,m) repi(j,i+1,m){\n\t\t\tint u=is[i],v=is[j];\n\t\t\tif(u==v) continue;\n\t\t\trep(k,xs[i].size()) rep(l,xs[j].size()){\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1=xs[i][k],x2=xs[i][(k+1)%xs[i].size()];\n\t\t\t\ty1=ys[i][k],y2=ys[i][(k+1)%ys[i].size()];\n\t\t\t\tSegment s1(x1,y1,x2-x1,y2-y1);\n\t\t\t\tx1=xs[j][l],x2=xs[j][(l+1)%xs[j].size()];\n\t\t\t\ty1=ys[j][l],y2=ys[j][(l+1)%ys[j].size()];\n\t\t\t\tSegment s2(x1,y1,x2-x1,y2-y1);\n\t\t\t\tif(IntersectSS(s1,s2)){\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\t\trep(i,n){\n\t\t\tsort(all(g[i]));\n\t\t\tg[i].erase(unique(all(g[i])),end(g[i]));\n\t\t}\n\t\t\n\t\tvi color(n,-1);\n\t\tcout<<solve(g,0,color)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\n#define EPS (1e-10)\n#define eq(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n#define le(a, b) (eq(a, b) || lt(a, b))\n\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n\n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\ndouble dot(Vector a, Vector b) { return a.x*b.x + a.y*b.y; }\ndouble norm(Vector v) { return dot(v, v); }\ndouble abs(Vector v) { return sqrt(norm(v)); }\ndouble cross(Vector a, Vector b) { return a.x*b.y - a.y*b.x; }\n\nbool isParallel(Vector a, Vector b) {\n  return eq(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n  return isParallel(a1 - a2, b1 - b2);\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\nint ccw(Point p0, Point p1, Point p2) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(norm(a) < norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersect(Point p1, Point p2, Point p3, Point p4) {\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\n\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\nbool isParallel(Segment s1, Segment s2) {\n  return eq(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n\ntypedef vector<Point> Polygon;\n\nint n;\nvector<string> name;\nmap<string, int> mp;\nvector<int> naid;\nvector<Polygon> teri;\nvector< vector<Segment> > seg;\nvector<int> col;\nbool adj[11][11];\n\nbool check(int a, int b) {\n  for(auto s1 : seg[a]) {\n    for(auto s2 : seg[b]) {\n      if(isParallel(s1, s2)) {\n\tif((s1.p1 == s2.p1 && s1.p2 == s2.p2) ||\n\t   (s1.p1 == s2.p2 && s1.p2 == s2.p1)) {\n\t  return true;\n\t}\n\tif(ccw(s1.p1, s1.p2, s2.p1) == ON_SEGMENT &&\n\t   !(s1.p1 == s2.p1 || s1.p2 == s2.p1)) {\n\t  return true;\n\t}\n\tif(ccw(s1.p1, s1.p2, s2.p2) == ON_SEGMENT &&\n\t   !(s1.p1 == s2.p2 || s1.p2 == s2.p2)) {\n\t  return true;\n\t}\n\tif(ccw(s2.p1, s2.p2, s1.p1) == ON_SEGMENT &&\n\t   !(s2.p1 == s1.p1 || s2.p2 == s1.p1)) {\n\t  return true;\n\t}\n\tif(ccw(s2.p1, s2.p2, s1.p2) == ON_SEGMENT &&\n\t   !(s2.p1 == s1.p2 || s2.p2 == s1.p2)) {\n\t  return true;\n\t}\n      }\n    }\n  }\n  return false;\n}\n\nint N;\nint ans;\n\nvoid solve(int idx, int cnum) {\n  if(cnum >= ans) return;\n  if(idx == N) {\n    chmin(ans, cnum);\n    return;\n  }\n  set<int> adjcol;\n  rep(i, N) {\n    if(adj[idx][i] && ~col[i]) adjcol.insert(col[i]);\n  }\n  rep(i, cnum) {\n    if(!adjcol.count(i)) {\n      col[idx] = i;\n      solve(idx+1, cnum);\n      col[idx] = -1;\n    }\n  }\n  col[idx] = cnum;\n  solve(idx+1, cnum+1);\n  col[idx] = -1;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> n, n) {\n    resz(name, n);\n    mp.clear();\n    resz(naid, n);\n    resz(teri, n);\n    resz(seg, n);\n    int num = 0;\n    rep(i, n) {\n      cin >> name[i];\n      if(!mp.count(name[i])) mp[name[i]] = num++;\n      naid[i] = mp[name[i]];\n      int x, y;\n      while(cin >> x, x != -1) {\n\tcin >> y;\n\tteri[i].push_back(Point(x, y));\n      }\n      int sz = teri[i].size();\n      rep(j, sz) {\n\tseg[i].push_back(Segment(teri[i][j], teri[i][(j+1)%sz]));\n      }\n    }\n    memset(adj, false, sizeof(adj));\n    rep(i, n) reps(j, i+1, n) {\n      if(naid[i] == naid[j]) continue;\n      if(check(i, j)) adj[naid[i]][naid[j]] = adj[naid[j]][naid[i]] = true;\n    }\n    /*\n    for(auto p : mp) {\n      cout<<\"<\"<<p.first<<\">\"<<endl;\n      int id = p.second;\n      for(auto q : mp) {\n\tif(adj[id][q.second]) cout << q.first << \" \";\n      }\n      cout<<endl;\n    }\n    */\n    N = mp.size();\n    resz(col, N, -1);\n    ans = N;\n    solve(0, 0);\n    cout << ans << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i=0; i<(n); ++i)\n#define RREP(i, n) for (int i=(int)(n)-1; i>=0; --i)\n#define FOR(i, a, n) for (int i=(a); i<(n); ++i)\n#define RFOR(i, a, n) for (int i=(int)(n)-1; i>=(a); --i)\n\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(),(x).end()\n\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl;\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector <T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\ntemplate<class T, class U>\nostream &operator<<(ostream &os, const pair <T, U> &p) {\n    return os << \"(\" << p.first << \" \" << p.second << \")\";\n}\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vi>;\nusing vvll = vector<vll>;\n\nconst ll MOD = 1e9 + 7;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\nconst ld eps = 1e-9;\n\n\n// template {{{\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        if (a.real() == b.real()) return a.imag() < b.imag();\n        return a.real() < b.real();\n    }\n}\n\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\n\nstruct Segment : Line {\n    Segment() {}\n    // Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < eps; }\n\n// }}}\n\n\n// utils {{{\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar((Real)1.0, theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\n// }}}\n\n\n/**\n* @brief 点p の直線l への射影を求める.\n*/\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n            B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\n/**\n* @brief 2直線の並行判定\n*/\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\n/**\n* @brief 2直線の直行判定\n*/\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\n\n/**\n* @brief 有向線分と点の位置関係\n* @param[in] a, b, c: 線分a->b, 点c\n* @return 線分a->b からみて, 点c がどこにあるか.\n*/\nconst int COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = -2,\n        ON_SEGMENT = 0,\n        ONEDGE_BACK = 3,\n        ONEDGE_FRONT = -3;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > eps) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -eps) return CLOCKWISE;\n    if (dot(b, c) < -eps) return ONLINE_BACK;\n    if (norm(b) + eps < norm(c)) return ONLINE_FRONT;\n    if (norm(c) < eps) return ONEDGE_BACK;\n    if (abs(norm(b) - norm(c)) < eps) return ONEDGE_FRONT;\n    return ON_SEGMENT;\n}\n\n\n// 交差 {{{\n\n/**\n* @brief 直線と点の交差判定\n*/\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\n/**\n* @brief 線分と点の交差判定\n*/\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\n/**\n* @brief 直線と線分の交差判定\n*/\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n}\n\n/**\n* @brief 2つの線分の交差判定\n*/\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\n\n/**\n* @brief 2直線の交点\n*/\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n            B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\n// }}}\n\n\n// 距離 {{{\n\n/**\n* @brief 直線と点の距離\n*/\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\n/**\n* @brief 線分と点の距離\n*/\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\n/**\n* @brief 直線と線分の距離\n*/\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\n/**\n* @brief 2つの線分の距離\n*/\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\n\n// }}}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n\n    // ifstream in(\"in.txt\");\n    // cin.rdbuf(in.rdbuf());\n\n    for (;;) {\n        int n; cin >> n;\n        if (n == 0) break;\n        map<string, vector<Segment>> segments;\n        REP(i, n) {\n            string country; cin >> country;\n            vector<Point> p;\n            for (;;) {\n                int x; cin >> x;\n                if (x == -1) break;\n                int y; cin >> y;\n                p.emplace_back((double)x, (double)y);\n            }\n            int m = p.size();\n            REP(j, m) {\n                segments[country].emplace_back(p[j], p[(j+1) % m]);\n            }\n        }\n        map<string,int> ord;\n        for (auto &tp : segments) {\n            ord[tp.first] = -1;\n        }\n        int cnt = 0;\n        for (auto &tp : ord) {\n            tp.second = cnt++;\n        }\n        vvi G(cnt, vi(cnt));\n        for (auto &tp1 : segments) {\n            for (auto &tp2 : segments) {\n                if (tp1.first == tp2.first) continue;\n                for (const Segment &s1 : tp1.second) {\n                    for (const Segment &s2 : tp2.second) {\n                        if (intersected(s1, s2)) {\n                            G[ord[tp1.first]][ord[tp2.first]] = 1;\n                        }\n                    }\n                }\n            }\n        }\n\n        vi color(cnt, -1);\n        function<int(int,int)> dfs = [&](int i, int upper) {\n            if (i == cnt) {\n                return upper;\n            }\n            int ret = 10;\n            REP(c, upper+1) {\n                bool valid = true;\n                REP(j, i) {\n                    if (G[i][j] and c == color[j]) {\n                        valid = false;\n                        break;\n                    }\n                }\n                if (valid) {\n                    color[i] = c;\n                    chmin(ret, dfs(i+1, max(upper, c+1)));\n                    color[i] = -1;\n                }\n            }\n            return ret;\n        };\n\n        int ans = dfs(0, 0);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\nstring d[M];\n\nbool eq(double n1,double n2){return abs(n1-n2)<EPS;}\n\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n}\n\nvoid func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0;\n    for(int i=0;i<Slen;i++){\n      for(int j=i+1;j<Slen;j++){\n\tif(mark[i]!=mark[j])continue;\n\tif(z.find(P1(d[i],d[j]))!=z.end()){\n\t  f=1;\n\t  break;\n\t}\n      }\n      if(f)break;\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <array>\nusing namespace std;\nconst int inf = 1e9;\nconst double EPS = 1e-10;\nconst double INF = 1e18;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nbool strictItsSP(const L &s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<-EPS;\n}\nbool overlapSS(const L &a, const L &b){\n    return strictItsSP(a, b[0]) || strictItsSP(a, b[1]) ||\n        strictItsSP(b, a[0]) || strictItsSP(b, a[1]) ||\n        (a[0]==b[0] && a[1]==b[1]) || (a[0]==b[1] && a[1]==b[0]);\n}\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        map<string, int> name;\n        vector<vector<L> > edge;\n        int num = 0;\n        for(int i=0; i<n; i++){\n            string city;\n            cin >> city;\n            if(name.count(city) == 0){\n                name[city] = num;\n                num++;\n                edge.push_back(vector<L>());\n            }\n            VP v;\n            while(1){\n                int x,y;\n                cin >> x;\n                if(x == -1) break;\n                cin >> y;\n                v.push_back(P(x, y));\n            }\n            for(int j=0; j<(int)v.size(); j++){\n                edge[name[city]].push_back(L(v[j], v[(j+1)%v.size()]));\n            }\n        }\n\n        vector<vector<bool> > adj(num, vector<bool>(num, false));\n        for(int i=0; i<num; i++){\n            for(int j=i+1; j<num; j++){\n                for(int k=0; k<(int)edge[i].size(); k++){\n                    for(int l=0; l<(int)edge[j].size(); l++){\n                        if(isParallel(edge[i][k], edge[j][l]) && overlapSS(edge[i][k], edge[j][l])){\n                            adj[i][j] = adj[j][i] = true;\n                            k = edge[i].size();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = inf;\n        vector<int> ord(num);\n        for(int i=0; i<num; i++) ord[i] = i;\n        do{\n            int count = 1;\n            int last = 0;\n            for(int i=1; i<num; i++){\n                for(int j=last; j<i; j++){\n                    if(adj[ord[i]][ord[j]]){\n                        count++;\n                        last = i;\n                        break;\n                    }\n                }\n            }\n            ans = min(ans, count);\n        }while(next_permutation(ord.begin(), ord.end()));\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n    bool operator==(const Point& p) const{\n        return x == p.x && y == p.y;\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return (a2-a1).cross(b1-a1) == 0 && (a2-a1).cross(b2-a1) == 0 &&\n                ((b1-a1).dot(b2-a1) < 0 || (b1-a2).dot(b2-a2) < 0 || (a1-b1).dot(a2-b1) < 0 || (a1-b2).dot(a2-b2) < 0 || (a1 == b1 && a2 == b2) || (a1 == b2 && a2 == b1));\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsCollide(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]))\n                return true;\n        }\n    }\n    return false;\n}\n\nint solve(vector<vector<bool> >& connect, vector<int>& color, int colorNum, int i)\n{\n    int n = color.size();\n    if(i == n)\n        return colorNum;\n\n    int ret = INT_MAX;\n    for(int j=0; j<colorNum; ++j){\n        bool ok = true;\n        for(int k=0; k<i; ++k){\n            if(connect[i][k] && color[k] == j)\n                ok = false;\n        }\n\n        if(ok){\n            color[i] = j;\n            ret = min(ret, solve(connect, color, colorNum, i+1));\n        }\n    }\n\n    color[i] = colorNum;\n    ret = min(ret, solve(connect, color, colorNum+1, i+1));\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<string> name(n);\n        vector<vector<Point> > p(n);\n        int m = 0;\n        map<string, int> index;\n        for(int i=0; i<n; ++i){\n            cin >> name[i];\n            if(index.find(name[i]) == index.end()){\n                index[name[i]] = m;\n                ++ m;\n            }\n            for(;;){\n                int x, y;\n                cin >> x;\n                if(x == -1)\n                    break;\n                cin >> y;\n                p[i].push_back(Point(y, x));\n            }\n        }\n\n        vector<vector<bool > > connect(m, vector<bool>(m, false));\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                if(index[name[i]] != index[name[j]] && polygonsCollide(p[i], p[j]))\n                    connect[index[name[i]]][index[name[j]]] = connect[index[name[j]]][index[name[i]]] = true;\n            }\n        }\n\n        vector<int> color(m);\n        cout << solve(connect, color, 0, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point &a, Point &b, Point &c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2, p3=b[j], p4;\n      if(i==a.size()-1 && j==b.size()-1){\n\tp2=a[0];\n\tp4=b[0];\n      }else if(i==a.size()-1){\n\tp2=a[0];\n\tp4=b[j+1];\n      }else if(j==b.size()-1){\n\tp2=a[i+1];\n\tp4=b[0];\n      }else{\n\tp2=a[i+1];\n\tp4=b[j+1];\n      }\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge, vector<Polygon> *country, int n){\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(is_Touch(country[i], country[j])) edge[i].push_back(j), edge[j].push_back(i);\n    }\n  }\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=now;i>=0;i--){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      cin >> name;\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=4;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> L;\ntypedef vector<xy_t> polygon;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-6;\n\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define DI(l) ((l).second-(l).first)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n\ndouble cross(const xy_t &a, const xy_t &b) { return imag(conj(a)*b); }\ndouble dot(const xy_t& a, const xy_t& b) { return real(conj(a)*b); }\n\nint ccw(xy_t a, xy_t b, xy_t c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectSS(const L &s, const L &t) {\n  return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0;\n}\n\nbool share_border(const polygon &p1, const polygon &p2){\n  int n = p1.size();\n  int m = p2.size();\n  REP(i, n)REP(j, m){\n    L l1 = L(p1[i], p1[(i+1)%n]);\n    L l2 = L(p2[j], p2[(j+1)%m]);\n    if(sameline(l1, l2) && intersectSS(l1, l2)){\n      if(p1[i].real() == p2[j].real()){\n      \tvector<double> ys;\n      \tys.push_back(l1.first.imag());\n      \tys.push_back(l2.first.imag());\n      \tys.push_back(l1.second.imag());\n      \tys.push_back(l2.second.imag());\n      \tsort(ALL(ys));\n      \tif(ys[2] - ys[1] > EPS) return true;\n      }else{\n      \tvector<double> xs;\n      \txs.push_back(l1.first.real());\n      \txs.push_back(l2.first.real());\n      \txs.push_back(l1.second.real());\n      \txs.push_back(l2.second.real());\n      \tsort(ALL(xs));\n      \tif(xs[2] - xs[1] > EPS) return true;\n      }\n    }\n  } \n  return false;\n}\n\n\nint dfs(int v, const vector<vector<bool> > &g, vector<int> &color, int M){\n  int n = g.size();\n  if(v == n) return M + 1;\n\n  int res = INF;\n  REP(c, M + 2){\n    bool ok = true;\n    REP(i, v) if(g[v][i] && color[i] == c) ok = false;\n    \n    if(ok){\n      color[v] = c;\n      res = min(res, dfs(v + 1, g, color, max(M, c)));\n      color[v] = -1;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  \n  while(cin >> n && n > 0){\n    vector<string> names(n);\n    map<string, int> ID;\n    vector<polygon> polys(n);\n    \n    REP(i, n){\n      cin >> names[i];\n      \n      if(ID.find(names[i]) == ID.end()){\n\tint count = ID.size();\n\tID[names[i]] = count;\n      }\n      int x, y;\n      while(cin >> x && x != -1 && cin >> y){\n\tpolys[i].PB(xy_t(x, y));\n      }\n    }\n\n    int c_size = ID.size();\n    vector<vector<bool> > g(c_size,vector<bool>(c_size,false));\n    \n    REP(i, n)REP(j, i)if(share_border(polys[i], polys[j])){\n      g[ID[names[i]]][ID[names[j]]] = true;\n      g[ID[names[j]]][ID[names[i]]] = true;      \n    }\n\n\n    vector<int> color(c_size, -1);\n    cout << dfs(0, g, color, -1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\nconst int MAXV = 50;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 2;   //counter clockwise\n  if (cross(b,c)<-EPS) return -2; //clockwise\n  if (dot(b, c)<-EPS) return 1;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n      }\n      if(num>=ans)return;\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cassert>\n#include<cmath>\n#define F first\n#define S second\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint n;\nmap<string,int> Index;\nint index;\n\n\nint getIndex(string name)\n{\n  int pos;\n  if(Index.find(name) == Index.end())Index[name] = index,pos = index++;\n  else pos = Index[name];\n  return pos;\n}\n\ndouble dot(P a,P b)\n{\n  return a.F*b.F+a.S*b.S;\n}\n\ndouble cross(P a,P b)\n{\n  return a.F*b.S-a.S*b.F;\n}\n\ndouble norm(P a)\n{\n  return a.F*a.F+a.S*a.S;\n}\n\nP operator - (P &a,P &b)\n{\n  return P(a.F-b.F,a.S-b.S);\n}\n\nint ccw(P p0,P p1,P p2)\n{\n  P a = p1-p0;\n  P b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool cmp(const pair<int,int> &a,const pair<int,int> &b)\n{\n  if(a.first != b.first)return a.first < b.first;\n  return a.second < b.second;\n}\n\nvector<pair<int,int> > AndrewScan(vector<pair<int,int> > G2)\n{\n  if(G2.size() < 3)return G2;\n  vector<pair<int,int> > U,L;\n  sort(G2.begin(),G2.end(),cmp);\n  int G2_size = G2.size();\n\n  U.push_back(G2[0]);\n  U.push_back(G2[1]);\n  L.push_back(G2[G2_size-1]);\n  L.push_back(G2[G2_size-2]);\n\n  for(int i=2;i<G2_size;i++)\n    {\n      for(int j=U.size();j>=2 && ccw(U[j-2],U[j-1],G2[i]) != CLOCKWISE;j--)\n\tU.pop_back();\n      U.push_back(G2[i]);\n    }\n\n  for(int i=G2_size-3;i>=0;i--)\n    {\n      for(int j=L.size();j>=2 && ccw(L[j-2],L[j-1],G2[i]) != CLOCKWISE;j--)\n\tL.pop_back();\n      L.push_back(G2[i]);\n    }\n  reverse(L.begin(),L.end());\n  for(int i=U.size()-2;i>=1;i--)L.push_back(U[i]);\n  return L;\n}\n\nbool isIntersect(P p1,P p2,P p3,P p4)\n{\n\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\n\n\nint Welch_Powell(vector<vector<int> > &G2)\n{\n\n  bool Empti = true;\n  for(int i=0;i<G2.size();i++)if(G2[i].size() != 0){Empti = false; break;}\n  if(Empti)return 1;\n  int G2_size = G2.size();\n  int PC = 0;\n  int chromatic_number = 0;\n  bool Drew[G2_size];\n  vector<pair<int,int> > Degree;\n  for(int i=0;i<G2_size;i++)Drew[i] = false,Degree.push_back(pair<int,int>(G2[i].size(),i) );\n  sort(Degree.begin(),Degree.end(),greater<pair<int,int> >());\n  while(PC < G2_size)\n    {\n      chromatic_number++;\n      bool Draw[G2_size];\n      for(int i=0;i<G2_size;i++)Draw[i] = Drew[i];\n      for(int i=0;i<G2_size;i++)\n\t{ \n\t  if(Draw[Degree[i].second]) \n\t    continue;\n\t  Drew[Degree[i].second] = Draw[Degree[i].second] = true;\n\t  PC++;\n\t  int index = Degree[i].second;\n\t  for(int j=0;j<G2[index].size();j++)Draw[G2[index][j]] = true; \n\t}\n    }\n  return chromatic_number;\n}\n\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI -- \"<< endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << G[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid printVVP(VVP &G)\n{\n  cout << \"printVVP ---- \" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << \"(\" << G[i][j].F << \",\" << G[i][j].S << \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n\n}\n\nbool isParallel(P a,P b)\n{\n  return fabs(cross(a,b)-0.0) < EPS;\n}\n\nbool isParallel(P a1,P a2,P b1,P b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool Not(P a,P b,P c)\n{\n  if(ccw(a,b,c) == CLOCKWISE || ccw(a,b,c) == COUNTER_CLOCKWISE)return false;\n  return true;\n}\n\n\n\nbool check(P a,P b,P c,P d)\n{\n  if(!Not(a,b,c) || !Not(a,b,c))return false;\n  if(ccw(a,b,c)== 0 && ccw(a,b,d) == 0)return true;\n  if(ccw(a,b,c) == 0 || ccw(a,b,d) == 0)return false;\n  return true;\n  //if((a == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  //if((a == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  \n  return false;\n}\n\nvoid printP(P p)\n{\n  cout << \"(\" << p.F << \",\" << p.S << \") \" << endl;\n}\n\nvoid printCCW(P a,P b,P c)\n{\n  int res = ccw(a,b,c);\n  if(res == 1)cout << \"COUNTER_CLOCKWISE\" << endl;\n  else if(res == -1) cout << \"CLOCKWISE\" << endl;\n  else if(res == 2)cout<< \"ONLINE_BACK\" << endl;\n  else if(res == -2)cout << \"ONLINE_FRONT\" << endl;\n  else cout << \"ON_SEGMENT\" << endl;  \n}\n\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      index = 0;\n      Index.clear();\n      VVP PG(n);\n      vector<string> NameList(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> NameList[i];\n\t \n\t  while(true)\n\t    {\n\t      P p;\n\t      cin >> p.first;\n\t      if(p.first == -1)break;\n\t      cin >> p.second;\n\t      PG[i].push_back(p);\n\t    }\n\t}\n\n      VVI G;\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<PG[i].size();j++)\n\t    {\n\t      for(int k=0;k<n;k++)\n\t\t{\n\t\t  if(k == i)continue;\n\t\t  int Ikey = getIndex(NameList[i]);\n\t\t  int Kkey = getIndex(NameList[k]);\n\t\t  if(Ikey == Kkey)continue;\n\n\t\t  for(int l=0;l<PG[k].size();l++)\n\t\t    {\n\t\t      int kmod = PG[k].size();\n\t\t      int imod = PG[i].size();\n\t\t      P a,b,c,d;\n\t\t\t  a = PG[i][j];\n\t\t\t  b = PG[i][(j+1)%imod];\n\t\t\t  c = PG[k][l];\n\t\t\t  d = PG[k][(l+1)%kmod];\n\t\t  \n\t\t\t  if(isIntersect(a,b,c,d) && isParallel(a,b,c,d) && check(a,b,c,d))\n\t\t\t    {\n\t\t\t      //cout << \"OK! \"<< Ikey << \".pb \" << Kkey << endl;\n\t\t\t      //printP(a);printP(b);printP(c); printP(d);\n\t\t\t      //cout << \"ccw(a,b,c) = \";\n\t\t\t      //printCCW(a,b,c);\n\t\t\t      //cout << \"ccw(a,b,d) = \";\n\t\t\t      //printCCW(a,b,d);\n\t\t\t      if(Ikey >= G.size())\n\t\t\t\t{\n\t\t\t\t  G.push_back(vector<int>());\n\t\t\t\t  if(G.size() <= Ikey)\n\t\t\t\t    {\n\t\t\t\t      cerr << \"G.size() = \"<< G.size() << endl;\n\t\t\t\t      cerr << \"Ikey = \"<< Ikey << endl;\n\t\t\t\t      assert(G.size() <= Ikey);\n\t\t\t\t    }\n\t\t\t\t  G[Ikey].push_back(Kkey);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tG[Ikey].push_back(Kkey);\n\t\t\t      \n\t\t\t      break;\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n   \n      for(int i=0;i<G.size();i++)\n\t    {\n\t      sort(G[i].begin(),G[i].end());\n\t      G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t    }\n\t\n     \n      //printVVI(G);\n      cout << Welch_Powell(G) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cassert>\n#include<cmath>\n#define F first\n#define S second\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint n;\nmap<string,int> Index;\nint index;\n\n\nint getIndex(string name)\n{\n  int pos;\n  if(Index.find(name) == Index.end())Index[name] = index,pos = index++;\n  else pos = Index[name];\n  return pos;\n}\n\ndouble dot(P a,P b)\n{\n  return a.F*b.F+a.S*b.S;\n}\n\ndouble cross(P a,P b)\n{\n  return a.F*b.S-a.S*b.F;\n}\n\ndouble norm(P a)\n{\n  return a.F*a.F+a.S*a.S;\n}\n\nP operator - (P &a,P &b)\n{\n  return P(a.F-b.F,a.S-b.S);\n}\n\nint ccw(P p0,P p1,P p2)\n{\n  P a = p1-p0;\n  P b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool cmp(const pair<int,int> &a,const pair<int,int> &b)\n{\n  if(a.first != b.first)return a.first < b.first;\n  return a.second < b.second;\n}\n\nvector<pair<int,int> > AndrewScan(vector<pair<int,int> > G2)\n{\n  if(G2.size() < 3)return G2;\n  vector<pair<int,int> > U,L;\n  sort(G2.begin(),G2.end(),cmp);\n  int G2_size = G2.size();\n\n  U.push_back(G2[0]);\n  U.push_back(G2[1]);\n  L.push_back(G2[G2_size-1]);\n  L.push_back(G2[G2_size-2]);\n\n  for(int i=2;i<G2_size;i++)\n    {\n      for(int j=U.size();j>=2 && ccw(U[j-2],U[j-1],G2[i]) != CLOCKWISE;j--)\n\tU.pop_back();\n      U.push_back(G2[i]);\n    }\n\n  for(int i=G2_size-3;i>=0;i--)\n    {\n      for(int j=L.size();j>=2 && ccw(L[j-2],L[j-1],G2[i]) != CLOCKWISE;j--)\n\tL.pop_back();\n      L.push_back(G2[i]);\n    }\n  reverse(L.begin(),L.end());\n  for(int i=U.size()-2;i>=1;i--)L.push_back(U[i]);\n  return L;\n}\n\nbool isIntersect(P p1,P p2,P p3,P p4)\n{\n\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\n\n\nint Welch_Powell(vector<vector<int> > &G2)\n{\n\n  bool Empti = true;\n  for(int i=0;i<G2.size();i++)if(G2[i].size() != 0){Empti = false; break;}\n  if(Empti)return 1;\n  int G2_size = G2.size();\n  int PC = 0;\n  int chromatic_number = 0;\n  bool Drew[G2_size];\n  vector<pair<int,int> > Degree;\n  for(int i=0;i<G2_size;i++)Drew[i] = false,Degree.push_back(pair<int,int>(G2[i].size(),i) );\n  sort(Degree.begin(),Degree.end(),greater<pair<int,int> >());\n  while(PC < G2_size)\n    {\n      chromatic_number++;\n      bool Draw[G2_size];\n      for(int i=0;i<G2_size;i++)Draw[i] = Drew[i];\n      for(int i=0;i<G2_size;i++)\n\t{ \n\t  if(Draw[Degree[i].second]) \n\t    continue;\n\t  Drew[Degree[i].second] = Draw[Degree[i].second] = true;\n\t  PC++;\n\t  int index = Degree[i].second;\n\t  for(int j=0;j<G2[index].size();j++)Draw[G2[index][j]] = true; \n\t}\n    }\n  return chromatic_number;\n}\n\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI -- \"<< endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << G[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid printVVP(VVP &G)\n{\n  cout << \"printVVP ---- \" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << \"(\" << G[i][j].F << \",\" << G[i][j].S << \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n\n}\n\nbool isParallel(P a,P b)\n{\n  return fabs(cross(a,b)-0.0) < EPS;\n}\n\nbool isParallel(P a1,P a2,P b1,P b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool Not(P a,P b,P c)\n{\n  if(ccw(a,b,c) == CLOCKWISE || ccw(a,b,c) == COUNTER_CLOCKWISE)return false;\n  return true;\n}\n\n\n\nbool check(P a,P b,P c,P d)\n{\n  if(!Not(a,b,c) || !Not(a,b,c))return false;\n  if(ccw(a,b,c)== 0 && ccw(a,b,d) == 0)return true;\n  if(ccw(a,b,c) == 0 || ccw(a,b,d) == 0)return false;\n  return true;\n  //if((a == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  //if((a == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  \n  return false;\n}\n\nvoid printP(P p)\n{\n  cout << \"(\" << p.F << \",\" << p.S << \") \" << endl;\n}\n\nvoid printCCW(P a,P b,P c)\n{\n  int res = ccw(a,b,c);\n  if(res == 1)cout << \"COUNTER_CLOCKWISE\" << endl;\n  else if(res == -1) cout << \"CLOCKWISE\" << endl;\n  else if(res == 2)cout<< \"ONLINE_BACK\" << endl;\n  else if(res == -2)cout << \"ONLINE_FRONT\" << endl;\n  else cout << \"ON_SEGMENT\" << endl;  \n}\n\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      index = 0;\n      Index.clear();\n      VVP PG(n);\n      vector<string> NameList(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> NameList[i];\n\t \n\t  while(true)\n\t    {\n\t      P p;\n\t      cin >> p.first;\n\t      if(p.first == -1)break;\n\t      cin >> p.second;\n\t      PG[i].push_back(p);\n\t    }\n\t}\n\n      VVI G;\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<PG[i].size();j++)\n\t    {\n\t      for(int k=0;k<n;k++)\n\t\t{\n\t\t  if(k == i)continue;\n\t\t  int Ikey = getIndex(NameList[i]);\n\t\t  int Kkey = getIndex(NameList[k]);\n\t\t  if(Ikey == Kkey)continue;\n\n\t\t  for(int l=0;l<PG[k].size();l++)\n\t\t    {\n\t\t      int kmod = PG[k].size();\n\t\t      int imod = PG[i].size();\n\t\t      P a,b,c,d;\n\t\t\t  a = PG[i][j];\n\t\t\t  b = PG[i][(j+1)%imod];\n\t\t\t  c = PG[k][l];\n\t\t\t  d = PG[k][(l+1)%kmod];\n\t\t  \n\t\t\t  if(isIntersect(a,b,c,d) && isParallel(a,b,c,d) && check(a,b,c,d))\n\t\t\t    {\n\t\t\t      //cout << \"OK! \"<< Ikey << \".pb \" << Kkey << endl;\n\t\t\t      //printP(a);printP(b);printP(c); printP(d);\n\t\t\t      //cout << \"ccw(a,b,c) = \";\n\t\t\t      //printCCW(a,b,c);\n\t\t\t      //cout << \"ccw(a,b,d) = \";\n\t\t\t      //printCCW(a,b,d);\n\t\t\t      if(Ikey >= G.size())\n\t\t\t\t{\n\t\t\t\t  G.push_back(vector<int>());\n\t\t\t\t  assert(G.size() > Ikey);\n\t\t\t\t  G[Ikey].push_back(Kkey);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tG[Ikey].push_back(Kkey);\n\t\t\t      \n\t\t\t      break;\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n   \n      for(int i=0;i<G.size();i++)\n\t    {\n\t      sort(G[i].begin(),G[i].end());\n\t      G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t    }\n\t\n     \n      //printVVI(G);\n      cout << Welch_Powell(G) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nstruct Point{\n  double x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return eq(0,cross(a,b));\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  \n  //cout<<s.p.x<<' '<<s.p.y<<endl;\n  //cout<<s.v.x<<' '<<s.v.y<<endl;\n  //cout<<p.x<<' '<<p.y<<endl;\n  //cout<<q.x<<' '<<q.y<<endl;\n  \n  if(!isParallel(s.v,q))return false;\n  //cout<<1<<endl;\n  if(dot(s.v,q)<0)return false;\n  //cout<<2<<endl;\n  if(abs(q.x)>abs(s.v.x)-eps)return false;\n  //cout<<3<<endl;\n  if(abs(q.y)>abs(s.v.y)-eps)return false;\n  //cout<<4<<endl;\n  return true;  \n}\n\nbool eq(Point a,Point b){\n  return (eq(a.x,b.x)&&eq(a.y,b.y));\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n}\n\nvoid init(){\n  c=0;\n  mp.clear();\n  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  double px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px<0)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int i=0;i<size;i++)\n        G[id].push_back((Segment){t[i],t[(i+1)%size]-t[i]});\n    }\n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\ntypedef const point &rpoint;\n\n\ndouble cross(rpoint v1, rpoint v2){\n\treturn v1.real() * v2.imag() - v1.imag() * v2.real();\n}\n\n//完全に含む。\nbool contains(rpoint va1, rpoint va2, rpoint vb){\n\tif( norm(va1 - vb) < EPS || norm(va2 - vb) < EPS ) return false;\n\treturn abs(abs(vb - va1) + abs(va2 - vb) - abs(va1 - va2)) < EPS;\n}\n\n//ここがだめ\nbool share(rpoint pa1, rpoint pa2, rpoint pb1, rpoint pb2){\n\tif( abs(cross(pa2 - pa1, pb1 - pa1)) > EPS ) return false;\n\tif( abs(cross(pa2 - pa1, pb2 - pa1)) > EPS ) return false;\n\n\tif( contains(pa1, pa2, pb1) || contains(pa1, pa2, pb2) || contains(pb1, pb2, pa1) )\n\t\treturn true;\n\tif( contains(pa1, pa2, (pb1 + pb2) * 0.5) )\n\t\treturn true;\n\t\n\treturn false;\n}\n\nbool adjacent(const polygon &plg1, const polygon &plg2){\n\tfor(int i = 1; i < plg1.size(); ++i){\n\t\tfor(int j = 1; j < plg2.size(); ++j){\n\t\t\tif( share(plg1[i-1], plg1[i], plg2[j-1], plg2[j]) )\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool adjacentcountry(const vector<polygon> &c1, const vector<polygon> &c2){\n\tfor(int i = 0; i < c1.size(); ++i){\n\t\tfor(int j = 0; j < c2.size(); ++j){\n\t\t\tif( adjacent(c1[i], c2[j]) ) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint m;\nint adj[10];\nint ans;\nint color[10];\n\nvoid paint(int t, int a){\n\tif( a >= ans ) return;\n\tif( t == m ){\n\t\tans = a;\n\t\treturn;\n\t}\n\n\tbool adjclr[11] = {};\n\tfor(int i = 0; i < m; ++i){\n\t\tif( (adj[t] >> i) & 1 ){\n\t\t\tadjclr[ color[i] ] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= a; ++i){\n\t\tif( !adjclr[i] ){\n\t\t\tcolor[t] = i;\n\t\t\tpaint(t + 1, a);\n\t\t}\n\t}\n\t\n\tcolor[t] = a + 1;\n\tpaint(t + 1, a + 1);\n\tcolor[t] = 0;\n}\n\n\nint main(){\n\tint n;\n\twhile( cin >> n, n != 0 ){\n\t\tmap<string,int> nametbl;\n\n\t\tvector<vector<polygon> > country(10);\n\t\t\n\t\tstring name;\n\t\tint x, y;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> name;\n\t\t\tint number = nametbl.insert( make_pair(name, nametbl.size()) ).first->second;\n\t\t\t\n\t\t\tpolygon plg;\n\t\t\twhile( cin >> x, x != -1 ){\n\t\t\t\tcin >> y;\n\t\t\t\tplg.push_back( point(x, y) );\n\t\t\t}\n\t\t\t\n\t\t\tplg.push_back( plg[0] );\n\t\t\tcountry[number].push_back(plg);\n\t\t}\n\t\t\n\t\tm = nametbl.size();\n\t\tcountry.resize(m);\n\n\t\tfill(adj, adj + 10, 0);\n\n\t\tfor(int i = 0; i < m - 1; ++i){\n\t\t\tfor(int j = i + 1; j < m; ++j){\n\t\t\t\tif( (adj[i] >> j) & 1 ) continue;\n\n\t\t\t\tif( adjacentcountry(country[i], country[j]) ){\n\t\t\t\t\tadj[i] |= 1 << j;\n\t\t\t\t\tadj[j] |= 1 << i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 10;\n\t\tfill(color, color + 10, 0);\n\t\tcolor[0] = 1;\n\n\t\tpaint(1, 1);\n\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point a, Point b, Point c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2=a[(i+1)%a.size()], p3=b[j], p4=b[(j+1)%b.size()];\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n      if((c[0] && c[2] && p1!=p3) || (c[0] && c[3] && p1!=p4) || (c[1] && c[2] && p2!=p3) || (c[1] && c[3] && p2!=p4)) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      getline(cin, name);\n      getline(cin, name);\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<ntoi.size();i++){\n      for(int j=i+1;j<ntoi.size();j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=10;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  Point Q=p-(s.p+s.v);\n  if(dot(s.p-s.p-s.v,Q)<=0)return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  for(int i=0;i<10;i++)G[i].clear();\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        scanf(\"%d\",&px);\n        if(px==-1)break;\n        scanf(\"%d\",&py);\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++)\n      for(int j=i+1;j<c;j++)\n        if(calc(i,j))g[i][j]=g[j][i]=1;\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j+1<c;j++){\n        if(i>>j&1){\n          for(int k=j+1;k<c;k++){\n            if(i>>k&1){\n            if(g[j][k]){\n              flg=false;\n            }\n          }\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[(1<<c)];\n    fill(dp,dp+(1<<c),1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point a, Point b, Point c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2=a[(i+1)%a.size()], p3=b[j], p4=b[(j+1)%b.size()];\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+n, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      getline(cin, name);\n      getline(cin, name);\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<ntoi.size();i++){\n      for(int j=i+1;j<ntoi.size();j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+n, -1);\n    ans=10;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct point {\n  int x, y;\n  point operator + (point r) { return point{x+r.x, y+r.y}; }\n  point operator - (point r) { return point{x-r.x, y-r.y}; }\n};\n\nstruct segment {\n  point s, t;\n};\n\nbool equals(point s, point t) {\n  return s.x == t.x && s.y == t.y;\n}\n\nbool equals(segment s, segment t) {\n  return (equals(s.s, t.s) && equals(s.t, t.t)) ||\n         (equals(s.t, t.s) && equals(s.s, t.t));\n}\n\nint dot(point p, point q) {\n  return p.x*q.x + p.x*q.y;\n}\n\nint cross(point p, point q) {\n  return p.x*q.y - q.x*p.y;\n}\n\nbool on_segment(segment s, point p) {\n  if(equals(s.s, p)) return false;\n  if(equals(s.t, p)) return false;\n  if(cross(s.t-s.s, p-s.s) != 0) return false;\n  if(dot(s.t-s.s, p-s.s) <= 0) return false;\n  if(dot(s.s-s.t, p-s.t) <= 0) return false;\n  return true;\n}\n\nbool parallel(segment s, segment t) {\n  return cross(s.t-s.s, t.t-t.s) == 0;\n}\n\nint have_common_segment(segment s, segment t) {\n  if(equals(s, t)) return true;\n  if(!parallel(s, t)) return false;\n  if(on_segment(s, t.s)) return true;\n  if(on_segment(s, t.t)) return true;\n  if(on_segment(t, s.s)) return true;\n  if(on_segment(t, s.t)) return true;\n  return false;\n}\n\nbool adjacent(int i, int j, vector<segment>* regions) {\n  for(auto s: regions[i])\n    for(auto t: regions[j])\n      if(have_common_segment(s, t))\n        return true;\n  return false;\n}\n\nbool same_coloring(int V, bool G[][10], int S) {  \n  rep(i, V) REP(j, i+1, V) {\n    if((S >> i & 1) == 0) continue;\n    if((S >> j & 1) == 0) continue;\n    if(G[i][j]) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  while(1) {\n    int N; cin >> N;\n    if(N == 0) break;\n    vector<segment> regions[10];\n    map<string, int> id;\n    int V = 0;\n    rep(_, N) {\n      string name; cin >> name;\n      if(!id.count(name)) {\n        id[name] = V++;\n      }\n      vector<point> v;\n      while(1) {\n        int x; cin >> x;\n        if(x == -1) break;\n        int y; cin >> y;\n        v.push_back(point{x, y});\n      }\n      rep(k, v.size()) {\n        auto seg = segment{v[k], v[(k+1)%v.size()]};\n        regions[id[name]].push_back(seg);\n      }\n    }\n\n    bool G[10][10] = {};\n    rep(i, V) REP(j, i+1, V) {\n      if(adjacent(i, j, regions)) {\n        G[i][j] = G[j][i] = 1;\n      }\n    }\n\n    vector<int> same_col;\n    rep(S, 1<<V)\n      if(same_coloring(V, G, S))\n        same_col.push_back(S);\n\n    int dp[1<<V]; rep(i, 1<<V) dp[i] = 10;\n    dp[0] = 0;\n\n    rep(S, 1<<V)\n      for(auto T: same_col)\n        dp[S|T] = min(dp[S|T], dp[S] + 1);\n\n    cout << dp[(1<<V)-1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(const point& a, const point& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point& a, const point& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a_, point b_):a(a_), b(b_) {}\n};\n\ntypedef vector<point> polygon;\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const polygon &P, const polygon &Q) {\n\tpoint p1 = P.back();\n\tfor(const auto &p2 : P) {\n\t\tconst segment s1(p1 + (p2 - p1) * EPS, p2 + (p1 - p2) * EPS);\n\n\t\tpoint q1 = Q.back();\n\t\tfor(const auto &q2 : Q) {\n\t\t\tconst segment s2(q1 + (q2 - q1) * EPS, q2 + (q1 - q2) * EPS);\n\t\t\tif(intersect(s1, s2)) return true;\n\t\t\tq1 = q2;\n\t\t}\n\t\tp1 = p2;\n\t}\n\treturn false;\n}\n\nbool one(const vector<vector<int>> &G) {\n\treturn none_of(G.begin(), G.end(), [](const vector<int> &v) { return v.size(); });\n}\n\nbool two(const vector<vector<int>> &G) {\n\tconst int n = G.size();\n\tvector<int> colors(n, 0);\n\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(colors[v]) continue;\n\n\t\tqueue<int> que;\n\t\tque.push(v);\n\t\tcolors[v] = 1;\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int u = que.front();\n\t\t\tque.pop();\n\n\t\t\tfor(const auto &to : G[u]) {\n\t\t\t\tif(colors[to]) {\n\t\t\t\t\tif(colors[to] == colors[u]) return false;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcolors[to] = 3 - colors[u];\n\t\t\t\t\tque.push(to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nbool three(const vector<vector<int>> &G) {\n\tvector<int> colors(G.size(), -1);\n\n\tfunction<bool(int)> dfs = [&](int v) {\n\t\tif(v == G.size()) return true;\n\t\tif(G[v].empty()) return dfs(v + 1);\n\n\t\tvector<bool> can(3, true);\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(colors[to] != -1) can[colors[to]] = false;\n\t\t}\n\n\t\tfor(int c = 0; c < 3; ++c) {\n\t\t\tif(!can[c]) continue;\n\t\t\tcolors[v] = c;\n\t\t\tif(dfs(v + 1)) return true;\n\t\t}\n\t\tcolors[v] = -1;\n\t\treturn false;\n\t};\n\n\treturn dfs(0);\n}\n\nint calc(const vector<vector<int>> &G) {\n\tif(one(G))   return 1;\n\tif(two(G))   return 2;\n\tif(three(G)) return 3;\n\treturn 4;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tunordered_map<string, int> converter;\n\t\tvector<int> idx(n);\n\t\tvector<polygon> territories;\n\t\tterritories.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tif(!converter.count(name)) converter.insert({name, converter.size()});\n\t\t\tidx[i] = converter[name];\n\t\t\tpolygon P;\n\t\t\tfor(int x, y; cin >> x && x != -1;) {\n\t\t\t\tcin >> y;\n\t\t\t\tP.emplace_back(x, y);\n\t\t\t}\n\t\t\tterritories.emplace_back(P);\n\t\t}\n\n\t\tconst int V = converter.size();\n\t\tvector<vector<int>> G(V);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(idx[i] == idx[j]) continue;\n\t\t\t\tif(intersect(territories[i], territories[j])) {\n\t\t\t\t\tG[idx[i]].emplace_back(idx[j]);\n\t\t\t\t\tG[idx[j]].emplace_back(idx[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(auto &vec : G) {\n\t\t\tsort(vec.begin(), vec.end());\n\t\t\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\t}\n\n\t\tcout << calc(G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  Point Q=p-(s.p+s.v);\n  if(dot(s.p-s.p-s.v,Q)<=0)return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  for(int i=0;i<10;i++)G[i].clear();\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[(1<<c)];\n    fill(dp,dp+(1<<c),1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n    assert(c<=10);\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005,INF=1<<30;\nconst double eps=1e-10;\nconst double pi=acos((long double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x+eps<p.x||(equals(x,p.x)&&y+eps<p.y);\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nbool overlap(Segment s1,Segment s2){\n    int a=ccw(s1.p1,s1.p2,s2.p1),b=ccw(s1.p1,s1.p2,s2.p2);\n    if(a&1||b&1) return 0;\n    if(a==2){\n        if(b==-2||(b==0&&!(s2.p2==s1.p1))) return 1;\n        else return 0;\n    }\n    if(a==-2){\n        if(b==2||(b==0&&!(s2.p2==s1.p2))) return 1;\n        else return 0;\n    }\n    if(a==0){\n        if(s1.p1==s2.p1){\n            if(b!=2) return 1;\n            else return 0;\n        }\n        else if(s1.p2==s2.p1){\n            if(b!=-2) return 1;\n            else return 0;\n        }\n        else return 1;\n    }\n    return 0;\n}\n//s1とs2の共通の線分(長さ0より大きい)があるかどうか\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)==0&&ccw(s1.p1,s1.p2,s2.p2)==0) return s1.p1;\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}//同じ時壊れます\n\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\nPoint CircleCenter(Point a,Point b,Point c){\n    Point u=a-b,v=a-c;\n    double m1=(norm(a)-norm(b))/2.0,m2=(norm(a)-norm(c))/2.0;\n    \n    Point res;\n    if(cross(u,v)==0.0){\n        res.x=1e9;\n        res.y=1e9;\n        \n        return res;\n    }\n    res.x=(m1*v.y-m2*u.y)/cross(u,v);\n    res.y=(m1*v.x-m2*u.x)/cross(v,u);\n    \n    return res;\n}\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\nPolygon convex_cut(const Polygon& P, const Line& l) {\n    Polygon Q;\n    for(int i=0;i<si(P);i++){\n        Point A=P[i],B=P[(i+1)%si(P)];\n        if(ccw(l.p1,l.p2,A)!=-1)Q.push_back(A);\n        if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0) Q.push_back(getCrossPoint(Line{A,B},l));\n    }\n    return Q;\n}\n\ndouble area(Point a,Point b,Point c){\n    b=b-a;\n    c=c-a;\n    return abs(b.x*c.y-b.y*c.x)/2.0;\n}\n\ndouble area(Polygon &P){\n    if(si(P)==0) return 0.0;\n    double res=0;\n    Point c={0.0,0.0};\n    for(int i=0;i<si(P);i++){\n        c=c+P[i];\n    }\n    c=c/si(P);\n    \n    for(int i=0;i<si(P);i++){\n        res+=area(c,P[i],P[(i+1)%si(P)]);\n    }\n    \n    return res;\n}\n\nbool check[10][10];\nint ans,M;\nvector<int> now;\n\nvoid DFS(int u){\n    if(u==M){\n        for(int i=0;i<M;i++){\n            for(int j=0;j<M;j++){\n                if(now[i]==now[j]&&check[i][j]) return;\n            }\n        }\n        set<int> SE;\n        for(int i=0;i<M;i++) SE.insert(now[i]);\n        chmin(ans,si(SE));\n        \n        return;\n    }\n    \n    for(int i=0;i<=u;i++){\n        now.push_back(i);\n        DFS(u+1);\n        now.pop_back();\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N;cin>>N;\n        if(N==0) break;\n        memset(check,0,sizeof(check));\n        map<string,int> MA;\n        vector<vector<Point>> S(N);\n        vector<string> q(N);\n        vector<int> T(N);\n        \n        for(int i=0;i<N;i++){\n            cin>>q[i];\n            MA[q[i]]=1;\n            \n            while(1){\n                Point p;\n                cin>>p.x;\n                if(p.x==-1) break;\n                cin>>p.y;\n                S[i].push_back(p);\n            }\n        }\n        \n        int id=0;\n        for(auto &a:MA){\n            a.se=id;\n            id++;\n        }\n        \n        M=id;\n        ans=INF;\n        \n        for(int i=0;i<N;i++) T[i]=MA[q[i]];\n        \n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(T[i]==T[j]) continue;\n                if(check[T[i]][T[j]]) continue;\n                \n                for(int a=0;a<si(S[i]);a++){\n                    for(int b=0;b<si(S[j]);b++){\n                        Segment s1={S[i][a],S[i][(a+1)%si(S[i])]},s2={S[j][b],S[j][(b+1)%si(S[j])]};\n                        if(overlap(s1,s2)){\n                            check[T[i]][T[j]]=1;\n                            check[T[j]][T[i]]=1;\n                            \n                            //cout<<i<<\" \"<<j<<\" \"<<a<<\" \"<<b<<endl;\n                            break;\n                        }\n                    }\n                    if(check[T[i]][T[j]]) break;\n                }\n            }\n        }\n        \n        DFS(0);\n        \n        cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tint x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n  int norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn x == p.x && y == p.y;\n\t}\n\n  bool operator != (const Point &p) const {\n\treturn !(*this == p);\n  }\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\nint dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\nint cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) >0) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < 0) return CLOCKWISE;\n\tif (dot(a, b) < 0) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\n\nbool intersect(Segment s1, Segment s2){\n  if(s1.p1 != s2.p1 && s1.p2 != s2.p1 && ccw(s1.p1, s1.p2, s2.p1) == 0) return true;\n  if(s1.p1 != s2.p2 && s1.p2 != s2.p2 && ccw(s1.p1, s1.p2, s2.p2) == 0) return true;\n  if((s1.p1 == s2.p1 && s1.p2 == s2.p2)\n\t || (s1.p1 == s2.p2 && s1.p2 == s2.p1)) return true;\n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tVS name(N);\n\tmap<string,int> id;\n\tvector<Polygon> poly(N);\n\tREP(i,N){\n\t  cin >> name[i];\n\t  if(!id.count(name[i])) id[name[i]] = SZ(id)-1;\n\t  while(true){\n\t\tint x; cin >> x;\n\t\tif(x < 0) break;\n\t\tint y; cin >> y;\n\t\tpoly[i].PB(Point(x,y));\n\t  }\n\t}\n\n\tint M = SZ(id);\n\tVVI xs(M);\n\tREP(i,N) FOR(j,i+1,N){\n\t  if(name[i] == name[j]) continue;\n\t  bool ok = false;\n\t  for(int i_=0;i_<SZ(poly[i]);++i_){\n\t\tSegment l1;\n\t\tl1.p1 = poly[i][i_];\n\t\tl1.p2 = poly[i][(i_+1)%SZ(poly[i])];\n\t\tfor(int j_=0;j_<SZ(poly[j]);++j_){\n\t\t  Segment l2;\n\t\t  l2.p1 = poly[j][j_];\n\t\t  l2.p2 = poly[j][(j_+1)%SZ(poly[j])];\n\t\t  if(intersect(l1,l2) || intersect(l2,l1)) ok = true;\n\t\t}\n\t  }\n\t  if(ok){\n\t\tint id1 = id[name[i]], id2 = id[name[j]];\n\t\tif(id1 < id2) swap(id1, id2);\n\t\txs[id1].PB(id2);\n\t  }\n\t}\n\t/*\n\tREP(i,M){\n\t  cout << i << \": \";\n\t  for(int x: xs[i]) cout << x << \" \";\n\t  cout << endl;\n\t}\n\t*/\n\tVI col(M,0);\n\tREP(i,M){\n\t  vector<bool> use(M+1,false);\n\t  for(int x: xs[i])\n\t\tuse[col[x]] = true;\n\t  for(int c=1;;++c)\n\t\tif(!use[c]){\n\t\t  col[i] = c;\n\t\t  break;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i,M) ans = max(ans, col[i]);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\nint n;\nstring str[100];\nvector<pair<int, int>> xy[100];\n//-----------------------------------------------------------------\nbool isAdjacent(int a, int b) {\n\trep(i, 0, xy[a].size()) rep(j, 0, xy[b].size()) {\n\t\tint ii = (i + 1) % xy[a].size();\n\t\tint jj = (j + 1) % xy[b].size();\n\n\t\tint x_a = xy[a][i].first - xy[a][ii].first;\n\t\tint y_a = xy[a][i].second - xy[a][ii].second;\n\t\tint x_b = xy[b][j].first - xy[b][jj].first;\n\t\tint y_b = xy[b][j].second - xy[b][jj].second;\n\n\t\tif (x_a == 0 && x_b == 0) {\n\t\t\tif (max(xy[a][i].second, xy[a][ii].second) <= min(xy[b][j].second, xy[b][jj].second)) continue;\n\t\t\tif (max(xy[b][j].second, xy[b][jj].second) <= min(xy[a][i].second, xy[a][ii].second)) continue;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (x_a*y_b == x_b*y_a) {\n\t\t\tif (max(xy[a][i].first, xy[a][ii].first) <= min(xy[b][j].first, xy[b][jj].first)) continue;\n\t\t\tif (max(xy[b][j].first, xy[b][jj].first) <= min(xy[a][i].first, xy[a][ii].first)) continue;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n//-----------------------------------------------------------------\nint E[100][100];\nint C[100];\nmap<string, set<int>> M;\nvector<set<int>> MM;\nint ans;\nvoid dfs(int cur, int mnum) {\n\tif (cur == MM.size()) {\n\t\tans = min(ans, mnum);\n\t\treturn;\n\t}\n\trep(i, 1, mnum + 2) {\n\t\tbool ok = true;\n\t\tfor (int j : MM[cur]) rep(k, 0, n) if (E[j][k] && C[k] == i) ok = false;\n\t\tif (ok) {\n\t\t\tfor (int j : MM[cur]) C[j] = i;\n\t\t\tdfs(cur + 1, max(i, mnum));\n\t\t}\n\t}\n}\nint solve() {\n\trep(i, 0, n) rep(j, 0, n) E[i][j] = 0;\n\trep(i, 0, n) rep(j, i + 1, n) if (isAdjacent(i, j)) E[i][j] = E[j][i] = 1;\n\n\trep(i, 0, n) C[i] = 0;\n\n\tM.clear();\n\trep(i, 0, n) M[str[i]].insert(i);\n\n\tMM.clear();\n\tfor (auto p : M) MM.push_back(p.second);\n\t\n\tans = 10;\n\tdfs(0, 0);\n\n\treturn ans;\n}\n//-----------------------------------------------------------------\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) return 0;\n\n\t\trep(i, 0, n) {\n\t\t\tcin >> str[i];\n\n\t\t\txy[i].clear();\n\t\t\tint x, y;\n\t\t\twhile (cin >> x) {\n\t\t\t\tif (x < 0) break;\n\t\t\t\tcin >> y;\n\t\t\t\txy[i].push_back({ x, y });\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct point {\n  int x, y;\n  point operator + (point r) { return point{x+r.x, y+r.y}; }\n  point operator - (point r) { return point{x-r.x, y-r.y}; }\n};\n\nstruct segment {\n  point s, t;\n};\n\nbool equals(point s, point t) {\n  return s.x == t.x && s.y == t.y;\n}\n\nbool equals(segment s, segment t) {\n  return (equals(s.s, t.s) && equals(s.t, t.t)) ||\n         (equals(s.t, t.s) && equals(s.s, t.t));\n}\n\nint dot(point p, point q) {\n  return p.x*q.x + p.y*q.y;\n}\n\nint cross(point p, point q) {\n  return p.x*q.y - q.x*p.y;\n}\n\nbool on_segment(segment s, point p) {\n  if(equals(s.s, p)) return false;\n  if(equals(s.t, p)) return false;\n  if(cross(s.t-s.s, p-s.s) != 0) return false;\n  if(dot(s.t-s.s, p-s.s) <= 0) return false;\n  if(dot(s.s-s.t, p-s.t) <= 0) return false;\n  return true;\n}\n\nbool parallel(segment s, segment t) {\n  return cross(s.t-s.s, t.t-t.s) == 0;\n}\n\nbool have_common_segment(segment s, segment t) {\n  if(equals(s, t)) return true;\n  if(!parallel(s, t)) return false;\n  if(on_segment(s, t.s)) return true;\n  if(on_segment(s, t.t)) return true;\n  if(on_segment(t, s.s)) return true;\n  if(on_segment(t, s.t)) return true;\n  return false;\n}\n\nbool adjacent(int i, int j, vector<segment>* regions) {\n  for(auto s: regions[i])\n    for(auto t: regions[j])\n      if(have_common_segment(s, t))\n        return true;\n  return false;\n}\n\nbool same_coloring(int V, bool G[][10], int S) {  \n  rep(i, V) REP(j, i+1, V) {\n    if((S >> i & 1) == 0) continue;\n    if((S >> j & 1) == 0) continue;\n    if(G[i][j]) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  while(1) {\n    int N; cin >> N;\n    if(N == 0) break;\n    vector<segment> regions[10];\n    map<string, int> id;\n    int V = 0;\n    rep(_, N) {\n      string name; cin >> name;\n      if(!id.count(name)) {\n        id[name] = V++;\n      }\n      vector<point> v;\n      while(1) {\n        int x; cin >> x;\n        if(x == -1) break;\n        int y; cin >> y;\n        v.push_back(point{x, y});\n      }\n      rep(k, v.size()) {\n        auto seg = segment{v[k], v[(k+1)%v.size()]};\n        regions[id[name]].push_back(seg);\n      }\n    }\n\n    bool G[10][10] = {};\n    rep(i, V) REP(j, i+1, V) {\n      if(adjacent(i, j, regions)) {\n        G[i][j] = G[j][i] = 1;\n      }\n    }\n\n    vector<int> same_col;\n    rep(S, 1<<V)\n      if(same_coloring(V, G, S))\n        same_col.push_back(S);\n\n    int dp[1<<V]; rep(i, 1<<V) dp[i] = 10;\n    dp[0] = 0;\n\n    rep(S, 1<<V)\n      for(auto T: same_col)\n        dp[S|T] = min(dp[S|T], dp[S] + 1);\n\n    cout << dp[(1<<V)-1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-6;\n\n/*** geometry part ***/\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble dot(const point &a,const point &b){ return a.x*b.x+a.y*b.y; }\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\nstruct segment{\n\tpoint a,b;\n\tsegment(){}\n\tsegment(const point &a,const point &b):a(a),b(b){}\n};\n\ntypedef vector<point> polygon;\n\nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point &a,const point &b,const point &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool cover(const segment &S,const point &p){\n\treturn abs(cross(S.a-p,S.b-p))<EPS && dot(S.a-p,S.b-p)<EPS;\n}\n\n// 二つの線分が長さ正の部分で接しているかどうか\nbool touch(const segment &S,const segment &T){\n\tif(ccw(S.a,S.b,T.a)!=ON || ccw(S.a,S.b,T.b)!=ON) return false; // 平行でないとダメ\n\tif(S.a==T.a && S.b==T.b\n\t|| S.a==T.b && S.b==T.a) return true;\n\treturn cover(S,T.a) && S.a!=T.a && S.b!=T.a\n\t\t|| cover(S,T.b) && S.a!=T.b && S.b!=T.b\n\t\t|| cover(T,S.a) && T.a!=S.a && T.b!=S.a\n\t\t|| cover(T,S.b) && T.a!=S.b && T.b!=S.b;\n}\n\n// 二つの多角形が長さ正の部分で接しているかどうか\nbool touch(const polygon &F,const polygon &G){\n\tint m=F.size(),n=G.size();\n\trep(i,m) rep(j,n) {\n\t\tsegment S(F[i],F[(i+1)%m]);\n\t\tsegment T(G[j],G[(j+1)%n]);\n\t\tif(touch(S,T)) return true;\n\t}\n\treturn false;\n}\n\n/*** end ***/\n\n/*** graph part ***/\n\nint N; // 異なる国の個数\nbool G[10][10]; // 国どうしの接続関係のグラフ\n\nint color[10];\n// 彩色\nint dfs(int u,int next){\n\tif(u==N) return next;\n\n\tint res=N;\n\trep(c,next+1){\n\t\tbool ok=true;\n\t\trep(v,N) if(G[u][v] && color[v]==c) ok=false;\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,dfs(u+1,max(c+1,next)));\n\t\t}\n\t}\n\treturn res;\n}\n\n/*** end ***/\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstring name[100];\n\t\tpolygon F[100];\n\t\trep(i,n){\n\t\t\tchar s[32]; scanf(\"%s\",s);\n\t\t\tname[i]=s;\n\t\t\twhile(1){\n\t\t\t\tpoint p;\n\t\t\t\tscanf(\"%lf\",&p.x);\n\t\t\t\tif(p.x==-1) break;\n\t\t\t\tscanf(\"%lf\",&p.y);\n\t\t\t\tF[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tmap<string,int> f;\n\t\trep(i,n) if(f.count(name[i])==0) {\n\t\t\tf.insert(make_pair(name[i],f.size()));\n\t\t}\n\n\t\tN=f.size();\n\t\trep(u,N) rep(v,N) G[u][v]=false;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint u=f[name[i]],v=f[name[j]];\n\t\t\tif(u!=v && !G[u][v] && touch(F[i],F[j])) G[u][v]=true;\n\t\t}\n\n\t\trep(u,N) color[u]=-1;\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct Point{\n  int x,y;\n\n  Point(int x,int y):x(x),y(y){}\n\n  Point operator + (Point p){\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (Point p){\n    return Point(x-p.x,y-p.y);\n  }\n};\n\nstruct Segment{\n  Point s,t;\n  Segment(Point s,Point t):s(s),t(t){}\n};\n\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n\nbool eq(Segment a,Segment b){\n  if( eq(a.s,b.s) && eq(a.t,b.t) )return true;\n  if( eq(a.s,b.t) && eq(a.t,b.s) )return true;  \n  return false;\n}\n\nint dot(Point a,Point b ){\n return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b ){\n return a.x*b.y-a.y*b.x;\n}\n\nbool isParallel(Segment a,Segment b){\n  return (cross(a.s-a.t,b.s-b.t)==0);\n}\n\nbool onSegment(Segment a,Point p){\n  if(eq(a.s,p))return false;\n  if(eq(a.t,p))return false;\n  if(cross(a.s-p,a.t-p)!=0)return false;\n  if(dot(a.t-a.s,p-a.s)<=0)return false;\n  if(dot(a.s-a.t,p-a.t)<=0)return false;\n  return true;\n}\n\nbool haveCommonSegment(Segment a,Segment b){\n  if(eq(a,b))return true;\n  if(!isParallel(a, b))return false;\n  if(onSegment(a,b.s))return true;\n  if(onSegment(a,b.t))return true;\n  if(onSegment(b,a.s))return true;\n  if(onSegment(b,a.t))return true;\n  return false;\n}\n\nbool haveCommonSegment(vector<Segment> &a,vector<Segment> &b){\n  for(Segment A : a )\n    for(Segment B : b )\n      if(haveCommonSegment(A,B))\n        return true;\n  return false;\n}\n\n\nbool check(int G[10][10],int S){\n  for(int i=0;i<10;i++){\n    if((S>>i&1)==0)continue;\n    for(int j=0;j<10;j++){\n      if((S>>j&1)==0)continue;\n      if(G[i][j])return false;\n    }\n  }\n  return true;\n}\n\n\nint main() {\n\n\n  while(1){\n    int N;\n    vector<Segment> Country[10];\n    map<string,int> id;\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      string name;\n      vector<Point> v;\n      cin>>name;\n      id[name]=id.size()-1;\n      while(1){\n        int x,y;\n        cin>>x;\n        if(x==-1)break;\n        cin>>y;\n        v.push_back(Point(x,y));\n      }\n      int size=v.size();\n      for(int i=0;i<size;i++){\n        Segment segment=Segment(v[i],v[(i+1)%size]);\n        Country[id[name]].push_back(segment);\n      }\n    }\n    int M=id.size();\n    int G[10][10]={};\n    for(int i=0;i<M;i++){\n      for(int j=0;j<M;j++){\n        if(i!=j){\n          G[i][j]=haveCommonSegment(Country[i],Country[j]);\n        }\n      }\n    }\n\n    vector<int> edge;\n    for(int S=0;S<(1<<M);S++)\n      if(check(G,S))\n        edge.push_back(S);\n\n    int dp[(1<<M)];\n    fill(dp,dp+(1<<M),10);\n    dp[0]=0;\n\n    for(int S=0;S<(1<<M);S++)\n      for(int T : edge)\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n\n    cout<<dp[(1<<M)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-10;\n\n/*** geometry part ***/\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble dot(const point &a,const point &b){ return a.x*b.x+a.y*b.y; }\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\nstruct segment{\n\tpoint a,b;\n\tsegment(){}\n\tsegment(const point &a,const point &b):a(a),b(b){}\n};\n\ntypedef vector<point> polygon;\n\nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point &a,const point &b,const point &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool cover(const segment &S,const point &p){\n\treturn abs(cross(S.a-p,S.b-p))<EPS && dot(S.a-p,S.b-p)<EPS;\n}\n\n// 二つの線分が長さ正の部分で接しているかどうか\nbool touch(const segment &S,const segment &T){\n\tif(ccw(S.a,S.b,T.a)!=ON || ccw(S.a,S.b,T.b)!=ON) return false; // 平行でないとダメ\n\tif(S.a==T.a && S.b==T.b\n\t|| S.a==T.b && S.b==T.a) return true;\n\treturn cover(S,T.a) && S.a!=T.a && S.b!=T.a\n\t\t|| cover(S,T.b) && S.a!=T.b && S.b!=T.b\n\t\t|| cover(T,S.a) && T.a!=S.a && T.b!=S.a\n\t\t|| cover(T,S.b) && T.a!=S.b && T.b!=S.b;\n}\n\n// 二つの多角形が長さ正の部分で接しているかどうか\nbool touch(const polygon &F,const polygon &G){\n\tint m=F.size(),n=G.size();\n\trep(i,m) rep(j,n) {\n\t\tsegment S(F[i],F[(i+1)%m]);\n\t\tsegment T(G[j],G[(j+1)%n]);\n\t\tif(touch(S,T)) return true;\n\t}\n\treturn false;\n}\n\n/*** end ***/\n\n/*** graph part ***/\n\nint N; // 異なる国の個数\nbool G[10][10]; // 国どうしの接続関係のグラフ\n\nint color[10];\n// 彩色\nint dfs(int u,int next){\n\tif(u==N) return next;\n\n\tint res=N;\n\trep(c,next+1){\n\t\tbool ok=true;\n\t\trep(v,N) if(G[u][v] && color[v]==c) ok=false;\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,dfs(u+1,max(c+1,next)));\n\t\t}\n\t}\n\treturn res;\n}\n\n/*** end ***/\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstring name[100];\n\t\tpolygon F[100];\n\t\trep(i,n){\n\t\t\tchar s[32]; scanf(\"%s\",s);\n\t\t\tname[i]=s;\n\t\t\twhile(1){\n\t\t\t\tpoint p;\n\t\t\t\tscanf(\"%lf\",&p.x);\n\t\t\t\tif(p.x==-1) break;\n\t\t\t\tscanf(\"%lf\",&p.y);\n\t\t\t\tF[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tmap<string,int> f;\n\t\trep(i,n) if(f.count(name[i])==0) {\n\t\t\tf.insert(make_pair(name[i],f.size()));\n\t\t}\n\n\t\tN=f.size();\n\t\trep(u,N) rep(v,N) G[u][v]=false;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint u=f[name[i]],v=f[name[j]];\n\t\t\tif(u!=v && !G[u][v] && touch(F[i],F[j])) G[u][v]=true;\n\t\t}\n\n\t\trep(u,N) color[u]=-1;\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cassert>\n#include<cmath>\n#define F first\n#define S second\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint n;\nmap<string,int> Index;\nint index;\n\n\nint getIndex(string name)\n{\n  int pos;\n  if(Index.find(name) == Index.end())Index[name] = index,pos = index++;\n  else pos = Index[name];\n  return pos;\n}\n\ndouble dot(P a,P b)\n{\n  return a.F*b.F+a.S*b.S;\n}\n\ndouble cross(P a,P b)\n{\n  return a.F*b.S-a.S*b.F;\n}\n\ndouble norm(P a)\n{\n  return a.F*a.F+a.S*a.S;\n}\n\nP operator - (P &a,P &b)\n{\n  return P(a.F-b.F,a.S-b.S);\n}\n\nint ccw(P p0,P p1,P p2)\n{\n  P a = p1-p0;\n  P b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool cmp(const pair<int,int> &a,const pair<int,int> &b)\n{\n  if(a.first != b.first)return a.first < b.first;\n  return a.second < b.second;\n}\n\nvector<pair<int,int> > AndrewScan(vector<pair<int,int> > G2)\n{\n  if(G2.size() < 3)return G2;\n  vector<pair<int,int> > U,L;\n  sort(G2.begin(),G2.end(),cmp);\n  int G2_size = G2.size();\n\n  U.push_back(G2[0]);\n  U.push_back(G2[1]);\n  L.push_back(G2[G2_size-1]);\n  L.push_back(G2[G2_size-2]);\n\n  for(int i=2;i<G2_size;i++)\n    {\n      for(int j=U.size();j>=2 && ccw(U[j-2],U[j-1],G2[i]) != CLOCKWISE;j--)\n\tU.pop_back();\n      U.push_back(G2[i]);\n    }\n\n  for(int i=G2_size-3;i>=0;i--)\n    {\n      for(int j=L.size();j>=2 && ccw(L[j-2],L[j-1],G2[i]) != CLOCKWISE;j--)\n\tL.pop_back();\n      L.push_back(G2[i]);\n    }\n  reverse(L.begin(),L.end());\n  for(int i=U.size()-2;i>=1;i--)L.push_back(U[i]);\n  return L;\n}\n\nbool isIntersect(P p1,P p2,P p3,P p4)\n{\n\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\n\n\nint Welch_Powell(vector<vector<int> > &G2)\n{\n\n  bool Empti = true;\n  for(int i=0;i<G2.size();i++)if(G2[i].size() != 0){Empti = false; break;}\n  if(Empti)return 1;\n  int G2_size = G2.size();\n  int PC = 0;\n  int chromatic_number = 0;\n  bool Drew[G2_size];\n  vector<pair<int,int> > Degree;\n  for(int i=0;i<G2_size;i++)Drew[i] = false,Degree.push_back(pair<int,int>(G2[i].size(),i) );\n  sort(Degree.begin(),Degree.end(),greater<pair<int,int> >());\n  while(PC < G2_size)\n    {\n      chromatic_number++;\n      bool Draw[G2_size];\n      for(int i=0;i<G2_size;i++)Draw[i] = Drew[i];\n      for(int i=0;i<G2_size;i++)\n\t{ \n\t  if(Draw[Degree[i].second]) \n\t    continue;\n\t  Drew[Degree[i].second] = Draw[Degree[i].second] = true;\n\t  PC++;\n\t  int index = Degree[i].second;\n\t  for(int j=0;j<G2[index].size();j++)Draw[G2[index][j]] = true; \n\t}\n    }\n  return chromatic_number;\n}\n\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI -- \"<< endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << G[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid printVVP(VVP &G)\n{\n  cout << \"printVVP ---- \" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << \"(\" << G[i][j].F << \",\" << G[i][j].S << \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n\n}\n\nbool isParallel(P a,P b)\n{\n  return fabs(cross(a,b)-0.0) < EPS;\n}\n\nbool isParallel(P a1,P a2,P b1,P b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool Not(P a,P b,P c)\n{\n  if(ccw(a,b,c) == CLOCKWISE || ccw(a,b,c) == COUNTER_CLOCKWISE)return false;\n  return true;\n}\n\n\n\nbool check(P a,P b,P c,P d)\n{\n  if(!Not(a,b,c) || !Not(a,b,c))return false;\n  if(ccw(a,b,c)== 0 && ccw(a,b,d) == 0)return true;\n  if(ccw(a,b,c) == 0 || ccw(a,b,d) == 0)return false;\n  return true;\n  //if((a == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  //if((a == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  \n  return false;\n}\n\nvoid printP(P p)\n{\n  cout << \"(\" << p.F << \",\" << p.S << \") \" << endl;\n}\n\nvoid printCCW(P a,P b,P c)\n{\n  int res = ccw(a,b,c);\n  if(res == 1)cout << \"COUNTER_CLOCKWISE\" << endl;\n  else if(res == -1) cout << \"CLOCKWISE\" << endl;\n  else if(res == 2)cout<< \"ONLINE_BACK\" << endl;\n  else if(res == -2)cout << \"ONLINE_FRONT\" << endl;\n  else cout << \"ON_SEGMENT\" << endl;  \n}\n\n\nint main()\n{\n\n  while(cin >> n,n)\n    {\n      index = 0;\n      Index.clear();\n      VVP PG(n);\n      vector<string> NameList(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> NameList[i];\n\t \n\t  while(true)\n\t    {\n\t      P p;\n\t      cin >> p.first;\n\t      if(p.first == -1)break;\n\t      cin >> p.second;\n\t      PG[i].push_back(p);\n\t    }\n\t}\n\n\n      for(int i=0;i<NameList.size();i++)\n\tgetIndex(NameList[i]);\n      VVI G(index);\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<PG[i].size();j++)\n\t    {\n\t      for(int k=0;k<n;k++)\n\t\t{\n\t\t  if(k == i)continue;\n\t\t  int Ikey = getIndex(NameList[i]);\n\t\t  int Kkey = getIndex(NameList[k]);\n\t\t  if(Ikey == Kkey)continue;\n\n\t\t  for(int l=0;l<PG[k].size();l++)\n\t\t    {\n\t\t      int kmod = PG[k].size();\n\t\t      int imod = PG[i].size();\n\t\t      P a,b,c,d;\n\t\t\t  a = PG[i][j];\n\t\t\t  b = PG[i][(j+1)%imod];\n\t\t\t  c = PG[k][l];\n\t\t\t  d = PG[k][(l+1)%kmod];\n\t\t  \n\t\t\t  if(isIntersect(a,b,c,d) && isParallel(a,b,c,d) && check(a,b,c,d))\n\t\t\t    {\n\t\t\t      //cout << \"OK! \"<< Ikey << \".pb \" << Kkey << endl;\n\t\t\t      //printP(a);printP(b);printP(c); printP(d);\n\t\t\t      //cout << \"ccw(a,b,c) = \";\n\t\t\t      //printCCW(a,b,c);\n\t\t\t      //cout << \"ccw(a,b,d) = \";\n\t\t\t      //printCCW(a,b,d);\n\t\t\t      if(Ikey >= G.size())\n\t\t\t\t{\n\t\t\t\t  G.push_back(vector<int>());\t\t\t\t \n\t\t\t\t  G[Ikey].push_back(Kkey);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tG[Ikey].push_back(Kkey);\n\t\t\t      \n\t\t\t      break;\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n   \n      for(int i=0;i<G.size();i++)\n\t    {\n\t      sort(G[i].begin(),G[i].end());\n\t      G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t    }\n\t\n     \n      //printVVI(G);\n      cout << Welch_Powell(G) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nint n,x,y,ans=inf,num;\nvector<Segment> v[20];\nbool bo[20][20];\nint color[20];\n\nvoid init(){\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++)bo[i][j]=false;\n    v[i].clear();\n    color[i]=0;\n  }\n}\n\nbool touch(int a,int b){\n  for(int i=0;i<v[a].size();i++){\n    for(int j=0;j<v[b].size();j++){\n      Point A=v[a][i].p1,B=v[a][i].p2,\n\t    C=v[b][j].p1,D=v[b][j].p2;\n      if(isParallel(A-B,C-D)){\n\tint c1=ccw(C,D,A),c2=ccw(C,D,B);\n\tif(c1==0 && c2==0)return true;\n\tif(c1==0 && !(A==C) && !(A==D))return true;\n\tif(c2==0 && !(B==C) && !(B==D))return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid dfs(int index,int sum){\n  bool b[20]={};\n  for(int i=0;i<num;i++){\n    if(bo[index][i])b[color[i]]=true;\n  }\n  if(index==num-1){\n    for(int i=1;i<=sum+1;i++){\n      if(!b[i]){\n\tans=min(ans,max(i,sum));\n\treturn;\n      }\n    }\n  }\n  else {\n    for(int i=1;i<=sum+1;i++){\n      if(!b[i]){\n\tcolor[index]=i;\n\tdfs(index+1,max(i,sum));\n\tcolor[index]=0;\n      }\n    }\n  }\n}\n\nint main()\n{\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    init();\n\n    map<string,int> M;\n    num=0;\n    string s;\n\n    for(int i=0;i<n;i++){\n      cin>>s;\n      vector<Point> vp;\n      while(1){\n\tcin>>x;\n\tif(x==-1)break;\n\tcin>>y;\n\tvp.push_back(Point(x,y));\n      }\n      if(M.find(s)==M.end()){\n\tM[s]=num;\n\tfor(int j=0;j<vp.size();j++){\n\t  v[num].push_back(Segment(vp[j],vp[(j+1)%vp.size()]));\n\t}\t\t   \n\tnum++;\n      }\n      else {\n\tfor(int j=0;j<vp.size();j++){\n\t  v[M[s]].push_back(Segment(vp[j],vp[(j+1)%vp.size()]));\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++){\n      for(int j=0;j<num;j++){\n\tif(i==j)continue;\n\tif(!touch(i,j))continue;\n\tbo[i][j]=true;\n\tbo[j][i]=true;\n      }\n    }\n    ans=inf;\n    dfs(0,0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\n\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢é±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 1;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n    // üªªÉÜÜêéÆ«A±±ÌRgAEgðÍ¸¹Îtrue(ð·)ÆÈé\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// é`ÌÉ_ª¶Ý·é©Ç¤©\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)>0)\n        ||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++)\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\treturn sum/2;\n}\n// 2xNgÔÌpx\n// a©çbÖ¶üèÅ½x©(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n\n// 2ÂÌxNgÌdÈÁÄ¢éªÌ·³ðÔ·\n// àµdÈÁÄ¢È¯êÎ0ðÔ·\ndouble multipleLength(P a,P b,P c,P d){\n    Edge &e1=make_pair(a,b);\n    Edge &e2=make_pair(c,d);\n    // ½sÅ é©Ç¤©\n    if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n        &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n        return 0;\n    double dist=0;\n    // ¼ûæÁÄ¢é\n    if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0))\n        dist=abs(e2.first-e2.second);\n    else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0))\n        dist=abs(e1.first-e1.second);\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n        // Ç¿çªüãÉ é©\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.first);\n        else\n            dist=abs(e1.second-e2.first);\n    }\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.second);\n        else\n            dist=abs(e1.second-e2.second);\n    }\n    return dist;\n}\n\nstruct Polygon{\n    vector<Edge> edges;\n};\n\nint n;\nint idx;\nvector<Polygon> polygons;\nmap<string,int> nti;\nvector<int> G[10001];\nstring nodeStr[10001];\nint minColor=10000;\nbool passed[10001];\n\n//// ·×ÄÌm[hªðð½µÄ¢é©ðmF·é\n//void dfs(int s,string &str){\n//}\n\nvoid dfs(int rem,string s,char num){\n    if(rem==0){\n        // ®¬µ½¶ñÌhèûÅÊêé©·B\n        // ÊêéêÍAÅ¬hèðXVÅ«éÌÅ êÎAXV·é\n        bool ok=true;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < G[i].size(); j++){\n                // ¯¶m[h©AÊÌF\n                if(!(nodeStr[G[i][j]]==nodeStr[i]||s[nti[nodeStr[i]]]!=s[nti[nodeStr[G[i][j]]]])){\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok)break;\n        }\n        if(ok)\n            minColor=min(minColor,num-'0');\n    }\n    else{\n        for(char ch='0'; ch<=num; ch++){\n            if(ch==num)\n                dfs(rem-1,s+ch,num+1);\n            else\n                dfs(rem-1,s+ch,num);\n        }\n    }\n}\n\nint main(){\n\n    while(cin>>n&&n!=0){\n        minColor=10000;\n        for(int i = 0; i < n; i++)G[i].clear();\n        idx=0;\n        nti.clear();\n        polygons.clear();\n        for(int i = 0; i < n; i++){\n            Polygon pol;\n            string name;\n            cin>>name;\n            // idxðo^\n            if(nti.find(name)==nti.end())\n                nti[name]=idx++;\n            // ¼Oðo^\n            nodeStr[i]=name;\n            int x,y;\n            int px,py;\n            int sx,sy;\n            cin>>px>>py;\n            sx=px;sy=py;\n            while(cin>>x&&x!=-1){\n                cin>>y;\n                pol.edges.push_back(make_pair(P(px,py),P(x,y)));\n                px=x;\n                py=y;\n            }\n            // ÅãÌC\n            pol.edges.push_back(make_pair(P(px,py),P(sx,sy)));\n            polygons.push_back(pol);\n        }\n        // ×Úð`FbN\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                bool isAdj=false;\n                // »ê¼êÌÓª×ÚµÄ¢é©`FbN\n                for(int k = 0; k < polygons[i].edges.size(); k++){\n                    for(int l = 0; l < polygons[j].edges.size(); l++){\n                        Edge &e1=polygons[i].edges[k];\n                        Edge &e2=polygons[j].edges[l];\n                        double dist=multipleLength(e1.first,e1.second,e2.first,e2.second);\n                        //// ½sÅ é©Ç¤©\n                        //if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n                        //    &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n                        //    continue;\n                        //double dist=0;\n                        //// ¼ûæÁÄ¢é\n                        //if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n                        //    dist=abs(e2.first-e2.second);\n                        //}\n                        //else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0)){\n                        //    dist=abs(e1.first-e1.second);\n                        //}\n                        //else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n                        //    // Ç¿çªüãÉ é©\n                        //    if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n                        //        dist=abs(e1.first-e2.first);\n                        //    else\n                        //        dist=abs(e1.second-e2.first);\n                        //}\n                        //else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n                        //    if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n                        //        dist=abs(e1.first-e2.second);\n                        //    else\n                        //        dist=abs(e1.second-e2.second);\n                        //}\n                        //else\n                        //    continue;\n                        if(!EQ(dist,0)){\n                            // ×ÚµÄ¢éÈçÎAedgeðø­\n                            isAdj=true;\n                            break;\n                        }\n                    }\n                    if(isAdj)break;\n                }\n                // draw edge\n                if(isAdj){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        dfs(nti.size(),\"\",'0');\n        cout<<minColor<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_sp(Line s, Point p)\n{\n\tif (s.a == p || s.b == p) return false;\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nbool is_cover(Line s, Line t)\n{\n\tif (isis_ll(s, t)) return false;\n\tif ((s.a == t.a && s.b == t.b) || (s.a == t.b && t.a == s.b)) return true;\n\tint cnt = 0;\n\tif (isis_sp(s, t.a)) cnt++;\n\tif (isis_sp(s, t.b)) cnt++;\n\tif (isis_sp(t, s.a)) cnt++;\n\tif (isis_sp(t, s.b)) cnt++;\n\treturn cnt > 0;\n}\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint ans;\nint cnt;\nMatrix g;\nvi belong;\n\nvoid solve(int bit, int col)\n{\n\tif (bit == (1 << cnt) - 1)\n\t{\n\t\tchmin(ans, col);\n\t\treturn;\n\t}\n\tif (col == ans) return;\n\tvi white;\n\tREP(i, cnt)\n\t{\n\t\tif (!((bit >> i) & 1))\n\t\t{\n\t\t\twhite.push_back(i);\n\t\t}\n\t}\n\tREP(i, 1<<white.size())\n\t{\n\t\tif (!i & 1) continue;\n\t\tvi use;\n\t\tREP(j, white.size())\n\t\t{\n\t\t\tif ((i >> j) & 1) use.push_back(white[j]);\n\t\t}\n\t\tbool f = false;\n\t\tREP(j, use.size())REP(k, j)\n\t\t{\n\t\t\tif (g[use[j]][use[k]]) f = true;\n\t\t}\n\t\tif (f) continue;\n\t\tint nx = bit;\n\t\tREP(j, use.size()) nx |= 1 << use[j];\n\t\tsolve(nx, col + 1);\n\t}\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tbelong.clear();\n\t\tg.clear();\n\t\tbelong.resize(n);\n\t\tans = 10;\n\t\tcnt = 0;\n\t\tvector<Polygon> ps(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (!mp.count(s))\n\t\t\t{\n\t\t\t\tmp[s] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tbelong[i] = mp[s];\n\t\t\tint a, b;\n\t\t\twhile (cin >> a, a >= 0)\n\t\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\tps[i].emplace_back(a, b);\n\t\t\t}\n\t\t}\n\t\tg.resize(cnt, Array(cnt));\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tif (belong[i] == belong[j]) continue;\n\t\t\tbool f = false;\n\t\t\tREP(k, ps[i].size())REP(l, ps[j].size())\n\t\t\t{\n\t\t\t\tLine s1(ps[i][k], ps[i][(k + 1) % ps[i].size()]), s2(ps[j][l], ps[j][(l + 1) % ps[j].size()]);\n\t\t\t\tif (is_cover(s1, s2)) f = true;\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tg[belong[j]][belong[i]] = 1;\n\t\t\t\tg[belong[i]][belong[j]] = 1;\n\t\t\t}\n\t\t}\n\t\tsolve(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n  \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n  \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n  \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  \n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\ntypedef point Vector;\ntypedef pair<point,point> Line;\ntypedef vector<point> Polygon;\n\nclass Segment{\npublic:\n  point p1, p2;\n  Segment(){}\n  Segment(point p1,point p2):p1(p1), p2(p2){}\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint is_parallel(point a1, point a2, point b1, point b2) {\n  return cross(a1-a2, b1-b2)==0.0 ;\n}\n\nint isOnSegment(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n    (dot(b-a, c-a) > -EPS) &&\n    (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  \n  if(cross(a1-a2,b1-b2)==0){\n    return isOnSegment(a1,a2,b1) || isOnSegment(a1,a2,b2)\n      || isOnSegment(b1,b2,a1) || isOnSegment(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n      ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nvector<int>g[11];\nint used[11];\n\nvoid dfs(int v){\n  \n  bool fg[11];\n  fill(fg,fg+11,false);\n  for(int i=0;i<g[v].size();i++){\n    fg[used[g[v][i]]]=true;\n  }\n  \n  for(int i=1;i<11;i++){\n    if(!fg[i]){\n      used[v]=i;\n      break;\n    }\n  }\n\n  for(int i=0;i<g[v].size();i++){\n    if(used[g[v][i]]>0)continue;\n    dfs(g[v][i]);\n  }\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    string s;\n    vector<point>pol[11];\n    for(int i=0;i<n;i++){\n      cin >> s;\n      point in;\n      while(true){\n\tcin >> in.x;\n\tif(in.x<0)break;\n\tcin >> in.y;\n\tpol[i].push_back(in);\n      }\n    }\n\n    for(int i=0;i<11;i++)g[i].clear();\n    \n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tfor(int k=0;k<pol[i].size();k++){\n\t  for(int l=0;l<pol[j].size();l++){\n\t    point cri=curr(pol[i],k),nxi=next(pol[i],k);\n\t    point crj=curr(pol[j],l),nxj=next(pol[j],l);\n\n\t    if(is_intersected_ls(cri,nxi,crj,nxj)){\n\t      if(is_parallel(cri,nxi,crj,nxj)){\n\t\tif(cri==crj || nxi==nxj)continue;\n\t\tg[i].push_back(j);\n\t\tg[j].push_back(i);\n\t\tgoto end;\n\t      }\n\t    }\n\t  }\n\t}\n      end:;\n      }\n    }\n\n    fill(used,used+11,0);\n    dfs(0);\n\n    int mx=0;\n    for(int i=0;i<11;i++)mx=max(mx,used[i]);   \n    cout << mx << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n\nint n;\nint cur = 1;\nbool exi[11][11];\nbool on_line(P x, P l, P r) {\n\tif (l.first > r.first)swap(l, r);\n\tif (l.first == r.first) {\n\t\tif (x.first != l.first)return false;\n\t\telse {\n\t\t\tif (l.second > r.second)swap(l, r);\n\t\t\tif (x.second < l.second)return false;\n\t\t\telse if (x.second > r.second)return false;\n\t\t\telse return true;\n\t\t}\n\t}\n\tif (x.first < l.first)return false;\n\tif (x.first > r.first)return false;\n\tint dx1 = x.first - l.first, dy1 = x.second - l.second;\n\tint dx2 = x.first - r.first, dy2 = x.second - r.second;\n\treturn dx1 * dy2 == dx2 * dy1;\n}\nbool kousa(P l1, P r1, P l2, P r2) {\n\tvector<P> v;\n\tif (on_line(l1, l2, r2))v.push_back(l1);\n\tif (on_line(r1, l2, r2))v.push_back(r1);\n\tif (on_line(l2, l1, r1))v.push_back(l2);\n\tif (on_line(r2, l1, r1))v.push_back(r2);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\treturn v.size() >= 2;\n}\nint ans = mod;\nint col[11];\nint num = 0;\nvoid dfs(int id) {\n\tif (id == cur+1) {\n\t\trep1(i, cur) {\n\t\t\tRep1(j,i+1, cur) {\n\t\t\t\tif (exi[i][j] && col[i] == col[j])return;\n\t\t\t}\n\t\t}\n\t\tans = min(ans, num);\n\t\treturn;\n\t}\n\trep(i, num) {\n\t\tcol[id] = i; dfs(id+1);\n\t}\n\tcol[id] = num; \n\tnum++; dfs(id+1); num--;\n}\nvoid solve() {\n\tans = mod;\n\tcur = 1;\n\trep(i, 11)rep(j, 11)exi[i][j] = false;\n\tmap<string, int> mp;\n\tvector<vector<P>> v(n);\n\tvector<int> ids(n);\n\trep(i, n) {\n\t\tstring s; cin >> s;\n\t\tif (!mp[s]) {\n\t\t\tmp[s] = cur; cur++;\n\t\t}\n\t\tint id = mp[s];\n\t\tids[i] = id;\n\t\tint x, y;\n\t\twhile (cin >> x) {\n\t\t\tif (x == -1)break;\n\t\t\tcin >> y;\n\t\t\tv[i].push_back({ x,y });\n\t\t}\n\t}\n\trep(i, n) {\n\t\tRep(j, i + 1, n) {\n\t\t\tif (ids[i] == ids[j])continue;\n\t\t\tbool f = false;\n\t\t\trep(k, v[i].size()) {\n\t\t\t\tP le1 = v[i][k], ri1 = v[i][(k+1)%v[i].size()];\n\t\t\t\trep(l, v[j].size()) {\n\t\t\t\t\tP le2 = v[j][l], ri2 = v[j][(l+1)%v[j].size()];\n\t\t\t\t\tif (kousa(le1, ri1, le2, ri2))f = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\texi[ids[i]][ids[j]] = exi[ids[j]][ids[i]] = true;\n\t\t\t}\n\t\t}\n\t}\n\tcur--;\n\trep(i, 11)col[i] = -1; num = 0;\n\tdfs(0);\n\tcout << ans << endl;\n\t/*cout << \"answer_is_ \"<<ans << endl;\n\trep1(i, cur) {\n\t\tRep1(j,i+1,cur) {\n\t\t\tif (exi[i][j])cout << i << \" \" << j << endl;\n\t\t}\n\t}*/\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_sp(Line s, Point p)\n{\n\tif (s.a == p || s.b == p) return false;\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nbool is_cover(Line s, Line t)\n{\n\tif (isis_ll(s, t)) return false;\n\tif ((s.a == t.a && s.b == t.b) || (s.a == t.b && t.a == s.b)) return true;\n\tint cnt = 0;\n\tif (isis_sp(s, t.a)) cnt++;\n\tif (isis_sp(s, t.b)) cnt++;\n\tif (isis_sp(t, s.a)) cnt++;\n\tif (isis_sp(t, s.b)) cnt++;\n\treturn cnt > 0;\n}\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint ans;\nint cnt;\nMatrix g;\nvi belong;\n\nvoid solve(int bit, int col)\n{\n\tif (bit == (1 << cnt) - 1)\n\t{\n\t\tchmin(ans, col);\n\t\treturn;\n\t}\n\tif (col == ans) return;\n\tvi white;\n\tREP(i, cnt)\n\t{\n\t\tif (!((bit >> i) & 1))\n\t\t{\n\t\t\twhite.push_back(i);\n\t\t}\n\t}\n\tREP(i, 1<<white.size())\n\t{\n\t\tvi use;\n\t\tREP(j, white.size())\n\t\t{\n\t\t\tif ((i >> j) & 1) use.push_back(white[j]);\n\t\t}\n\t\tbool f = false;\n\t\tREP(j, use.size())REP(k, j)\n\t\t{\n\t\t\tif (g[use[j]][use[k]]) f = true;\n\t\t}\n\t\tif (f) continue;\n\t\tint nx = bit;\n\t\tREP(j, use.size()) nx |= 1 << use[j];\n\t\tsolve(nx, col + 1);\n\t}\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tbelong.clear();\n\t\tg.clear();\n\t\tbelong.resize(n);\n\t\tans = 10;\n\t\tcnt = 0;\n\t\tvector<Polygon> ps(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (!mp.count(s))\n\t\t\t{\n\t\t\t\tmp[s] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tbelong[i] = mp[s];\n\t\t\tint a, b;\n\t\t\twhile (cin >> a, a >= 0)\n\t\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\tps[i].emplace_back(a, b);\n\t\t\t}\n\t\t}\n\t\tg.resize(cnt, Array(cnt));\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tif (belong[i] == belong[j]) continue;\n\t\t\tbool f = false;\n\t\t\tREP(k, ps[i].size())REP(l, ps[j].size())\n\t\t\t{\n\t\t\t\tLine s1(ps[i][k], ps[i][(k + 1) % ps[i].size()]), s2(ps[j][l], ps[j][(l + 1) % ps[j].size()]);\n\t\t\t\tif (is_cover(s1, s2)) f = true;\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tg[belong[j]][belong[i]] = 1;\n\t\t\t\tg[belong[i]][belong[j]] = 1;\n\t\t\t}\n\t\t}\n\t\tsolve(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\n\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢é±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 1;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n    // üªªÉÜÜêéÆ«A±±ÌRgAEgðÍ¸¹Îtrue(ð·)ÆÈé\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// é`ÌÉ_ª¶Ý·é©Ç¤©\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)>0)\n        ||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++)\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\treturn sum/2;\n}\n// 2xNgÔÌpx\n// a©çbÖ¶üèÅ½x©(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n\n// 2ÂÌxNgÌdÈÁÄ¢éªÌ·³ðÔ·\n// àµdÈÁÄ¢È¯êÎ0ðÔ·\ndouble multipleLength(P a,P b,P c,P d){\n    Edge e1=make_pair(a,b);\n    Edge e2=make_pair(c,d);\n    // ½sÅ é©Ç¤©\n    if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n        &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n        return 0;\n    double dist=0;\n    // ¼ûæÁÄ¢é\n    if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0))\n        dist=abs(e2.first-e2.second);\n    else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0))\n        dist=abs(e1.first-e1.second);\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n        // Ç¿çªüãÉ é©\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.first);\n        else\n            dist=abs(e1.second-e2.first);\n    }\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.second);\n        else\n            dist=abs(e1.second-e2.second);\n    }\n    return dist;\n}\n\nstruct Polygon{\n    vector<Edge> edges;\n};\n\nint n;\nint idx;\nvector<Polygon> polygons;\nmap<string,int> nti;\nvector<int> G[10001];\nstring nodeStr[10001];\nint minColor=10000;\nbool passed[10001];\n\n//// ·×ÄÌm[hªðð½µÄ¢é©ðmF·é\n//void dfs(int s,string &str){\n//}\n\nvoid dfs(int rem,string s,char num){\n    if(rem==0){\n        // ®¬µ½¶ñÌhèûÅÊêé©·B\n        // ÊêéêÍAÅ¬hèðXVÅ«éÌÅ êÎAXV·é\n        bool ok=true;\n        memset(passed,0,sizeof(passed));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < G[i].size(); j++){\n                // ¯¶m[h©AÊÌF\n                if(!(nodeStr[G[i][j]]==nodeStr[i]||s[nti[nodeStr[i]]]!=s[nti[nodeStr[G[i][j]]]])){\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok)break;\n        }\n        if(ok)\n            minColor=min(minColor,num-'0');\n    }\n    else{\n        for(char ch='0'; ch<=num; ch++){\n            if(ch==num)\n                dfs(rem-1,s+ch,num+1);\n            else\n                dfs(rem-1,s+ch,num);\n        }\n    }\n}\n\nint main(){\n\n    while(cin>>n&&n!=0){\n        minColor=10000;\n        for(int i = 0; i < n; i++)G[i].clear();\n        idx=0;\n        nti.clear();\n        polygons.clear();\n        for(int i = 0; i < n; i++){\n            Polygon pol;\n            string name;\n            cin>>name;\n            // idxðo^\n            if(nti.find(name)==nti.end())\n                nti[name]=idx++;\n            // ¼Oðo^\n            nodeStr[i]=name;\n            int x,y;\n            int px,py;\n            int sx,sy;\n            cin>>px>>py;\n            sx=px;sy=py;\n            while(cin>>x&&x!=-1){\n                cin>>y;\n                pol.edges.push_back(make_pair(P(px,py),P(x,y)));\n                px=x;\n                py=y;\n            }\n            // ÅãÌC\n            pol.edges.push_back(make_pair(P(px,py),P(sx,sy)));\n            polygons.push_back(pol);\n        }\n        // ×Úð`FbN\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                bool isAdj=false;\n                // »ê¼êÌÓª×ÚµÄ¢é©`FbN\n                for(int k = 0; k < polygons[i].edges.size(); k++){\n                    for(int l = 0; l < polygons[j].edges.size(); l++){\n                        Edge &e1=polygons[i].edges[k];\n                        Edge &e2=polygons[j].edges[l];\n                        double dist=multipleLength(e1.first,e1.second,e2.first,e2.second);\n                        //// ½sÅ é©Ç¤©\n                        //if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n                        //    &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n                        //    continue;\n                        //double dist=0;\n                        //// ¼ûæÁÄ¢é\n                        //if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n                        //    dist=abs(e2.first-e2.second);\n                        //}\n                        //else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0)){\n                        //    dist=abs(e1.first-e1.second);\n                        //}\n                        //else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n                        //    // Ç¿çªüãÉ é©\n                        //    if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n                        //        dist=abs(e1.first-e2.first);\n                        //    else\n                        //        dist=abs(e1.second-e2.first);\n                        //}\n                        //else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n                        //    if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n                        //        dist=abs(e1.first-e2.second);\n                        //    else\n                        //        dist=abs(e1.second-e2.second);\n                        //}\n                        //else\n                        //    continue;\n                        if(!EQ(dist,0)){\n                            // ×ÚµÄ¢éÈçÎAedgeðø­\n                            isAdj=true;\n                            break;\n                        }\n                    }\n                    if(isAdj)break;\n                }\n                // draw edge\n                if(isAdj){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        dfs(nti.size(),\"\",'0');\n        cout<<minColor<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<map>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n  \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n  \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n  \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  \n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\ntypedef point Vector;\ntypedef pair<point,point> Line;\ntypedef vector<point> Polygon;\n\nclass Segment{\npublic:\n  point p1, p2;\n  Segment(){}\n  Segment(point p1,point p2):p1(p1), p2(p2){}\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint is_parallel(point a1, point a2, point b1, point b2) {\n  return cross(a1-a2, b1-b2)==0.0 ;\n}\n\nint isOnSegment(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n    (dot(b-a, c-a) > -EPS) &&\n    (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  \n  if(cross(a1-a2,b1-b2)==0){\n    return isOnSegment(a1,a2,b1) || isOnSegment(a1,a2,b2)\n      || isOnSegment(b1,b2,a1) || isOnSegment(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n      ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nvector<int>g[11];\nint used[11];\n\nvoid dfs(int v){\n  \n  bool fg[11];\n  fill(fg,fg+11,false);\n  for(int i=0;i<g[v].size();i++){\n    fg[used[g[v][i]]]=true;\n  }\n  \n  for(int i=1;i<11;i++){\n    if(!fg[i]){\n      used[v]=i;\n      break;\n    }\n  }\n\n  for(int i=0;i<g[v].size();i++){\n    if(used[g[v][i]]>0)continue;\n    dfs(g[v][i]);\n  }\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    string s;\n    vector<point>pol[11];\n    map<string,int>id;\n    int sz=0;\n\n    for(int i=0;i<n;i++){\n      cin >> s;\n      if(!id.count(s))id[s]=sz++;\n      point in;\n      while(true){\n\tcin >> in.x;\n\tif(in.x<0)break;\n\tcin >> in.y;\n\tpol[id[s]].push_back(in);\n      }\n    }\n\n    for(int i=0;i<11;i++)g[i].clear();\n    \n    for(int i=0;i<sz;i++){\n      for(int j=i+1;j<sz;j++){\n\tfor(int k=0;k<pol[i].size();k++){\n\t  for(int l=0;l<pol[j].size();l++){\n\t    point cri=curr(pol[i],k),nxi=next(pol[i],k);\n\t    point crj=curr(pol[j],l),nxj=next(pol[j],l);\n\n\t    if(is_intersected_ls(cri,nxi,crj,nxj)){\n\t      if(is_parallel(cri,nxi,crj,nxj)){\n\t\tif(cri==crj || nxi==nxj)continue;\n\t\tif(cri==nxj || nxi==crj)continue;\n\t\tg[i].push_back(j);\n\t\tg[j].push_back(i);\n\t\tgoto end;\n\t      }\n\t    }\n\t  }\n\t}\n      end:;\n      }\n    }\n\n    fill(used,used+11,0);\n    dfs(0);\n\n    int mx=0;\n    for(int i=0;i<11;i++)mx=max(mx,used[i]);   \n    cout << mx*2 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> L;\ntypedef vector<xy_t> polygon;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define DI(l) ((l).second-(l).first)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n\ndouble cross(const xy_t &a, const xy_t &b) { return imag(conj(a)*b); }\ndouble dot(const xy_t& a, const xy_t& b) { return real(conj(a)*b); }\n\nint ccw(xy_t a, xy_t b, xy_t c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\n\nL shorten(const L &l){\n  xy_t p1 = l.first;\n  xy_t p2 = l.second;\n  \n  if(p1.real() > p2.real()){\n    p1.real() -= EPS;\n    p2.real() += EPS;\n  }else if(p1.real() < p2.real()){\n    p1.real() += EPS;\n    p2.real() -= EPS;\n  }\n\n  if(p1.imag() > p2.imag()){\n    p1.imag() -= EPS;\n    p2.imag() += EPS;\n  }else if(p1.imag() < p2.imag()){\n    p1.imag() += EPS;\n    p2.imag() -= EPS;\n  }\n  return L(p1, p2);\n}\n\nbool share_border(const polygon &p1, const polygon &p2){\n  int n = p1.size();\n  int m = p2.size();\n  REP(i, n)REP(j, m){\n    L l1 = shorten(L(p1[i], p1[(i+1)%n]));\n    L l2 = L(p2[j], p2[(j+1)%m]);\n    if(sameline(l1, l2) && intersectSS(l1, l2)) return true;\n  } \n  return false;\n}\n\nbool dfs(int v, const vector<vector<bool> > &g, vector<int> &color, int C){\n  int n = g.size();\n  if(v == n) return true;\n  REP(c, C){\n    bool ok = true;\n    REP(i, v) if(g[v][i] && color[i] == c) ok = false;\n    \n    if(ok){\n      color[v] = c;\n      if(dfs(v + 1, g, color, C)) return true;\n      color[v] = -1;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n\n    vector<string> names(n);\n    map<string, int> ID;\n    vector<polygon> polys(n);\n    \n    REP(i, n){\n      int x, y;      \n      cin >> names[i];\n      if(ID.find(names[i]) == ID.end()){\n\tint count = ID.size();\n\tID[names[i]] = count;\n      }\n      while(cin >> x && x != -1 && cin >> y) polys[i].PB(xy_t(x, y));\n    }\n\n    int c_size = ID.size();\n    vector<vector<bool> > g(c_size, vector<bool>(c_size, false));    \n    \n    REP(i, n)REP(j, i)if(share_border(polys[i], polys[j])){\n      g[ID[names[i]]][ID[names[j]]] = true;\n      g[ID[names[j]]][ID[names[i]]] = true;      \n    }\n    \n    vector<int> color(c_size, -1);\n    \n    if(dfs(0, g, color, 1)){\n      cout << 1 << endl;\n    }else if(dfs(0, g, color, 2)){\n      cout << 2 << endl;\n    }else if(dfs(0, g, color, 3)){\n      cout << 3 << endl;\n    }else{\n      cout << 4 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nmap<string,int> cntid;\nint cntnum=0;\nint cntidx[100];\nvector<P> poly[100];\nvector<int> g[10];\nint col[10];\nint colcnt[10];\nint res=100;\n\nP operator-(const P& a,const P& b){ return P(a.fi-b.fi,a.se-b.se); }\nll cross(P a,P b){ return a.fi*b.se - a.se*b.fi; }\ndouble norm(P a){ return (double)sqrt((double)a.fi*a.fi + (double)a.se*a.se); }\nbool intersectSP(P p1,P p2,P q){\n  if(p1==q||p2==q)return false;\n  return norm(p1-q)+norm(p2-q)-norm(p2-p1)<1e-9;\n}\nbool intersectSS(P p1,P p2,P q1,P q2){\n  if(cross(p2-p1,q2-q1)!=0)return false;\n  if(min(p1,p2)==min(q1,q2)&&max(p1,p2)==max(q1,q2))return true;\n  return intersectSP(p1,p2,q1)||intersectSP(p1,p2,q2)||intersectSP(q1,q2,p1)||intersectSP(q1,q2,p2);\n}\n\nint getid(string s){\n  if(cntid.find(s)!=cntid.end())return cntid[s];\n  cntid[s]=cntnum++;\n  return cntid[s];\n}\n\nvoid dfs(int v,int crtres){\n  if(v==cntnum){\n    minch(res,crtres);\n    return ;\n  }\n  if(crtres>=res)return ;\n  vector<bool> used(10,false);\n  for(int nv : g[v])if(col[nv]!=-1)used[col[nv]]=true;\n  rep(i,10){\n    if(used[i])continue;\n    col[v]=i;\n    colcnt[i]++;\n    dfs(v+1,crtres+(colcnt[i]==1?1:0));\n    colcnt[i]--;\n  }\n  return ;\n}\n\nint main(){\n  while(1){\n    int N;\n    cin>>N;\n    if(N==0)break;\n    cntid.clear(); cntnum=0;\n    rep(i,10)g[i].clear();\n    rep(i,N){\n      string name;\n      cin>>name;\n      int crtid=getid(name);\n      cntidx[i]=crtid;\n      poly[i].clear();\n      int x,y;\n      while(1){\n        cin>>x;\n        if(x==-1)break;\n        cin>>y;\n        poly[i].push_back(P(x,y));\n      }\n    }\n    rep(i,N)rep(j,i){\n      bool crossed=false;\n      rep(l1,poly[i].size())rep(l2,poly[j].size()){\n        if(intersectSS(poly[i][l1],poly[i][(l1+1)%poly[i].size()],poly[j][l2],poly[j][(l2+1)%poly[j].size()]))crossed=true;\n      }\n      if(crossed&&cntidx[i]!=cntidx[j]&&!exist(g[cntidx[i]],cntidx[j])){\n        g[cntidx[i]].push_back(cntidx[j]);\n        g[cntidx[j]].push_back(cntidx[i]);\n      }\n    }\n    memset(colcnt,0,sizeof(colcnt)); memset(col,-1,sizeof(col)); res=100;\n    dfs(0,0);\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <map>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\nconst double EPS = (1e-7);\nconst int INF = 1 << 20;\ndouble dot(P &a, P &b){ return a.X*b.X + a.Y*b.Y;}\ndouble cross(P &a, P &b){ return a.X*b.Y - a.Y*b.X;}\n\nint ccw( P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) > norm(b) - EPS) return -2;\n  return 0;\n}\n\nbool is_adjacent(vector<P> &A, vector<P> &B){\n  int n = A.size(), m = B.size();\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      P x = A[i], y = A[(i+1)%n], z = B[j], w = B[(j+1)%m];\n      int s = ccw(x,y,z), t = ccw(x,y,w);\n      if(abs(s) == 1 or abs(t) == 1) continue;\n      if(s*t > 0) continue;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    map<string, int> M;\n    vector< vector< vector<P> > > V(n);\n    int t = 1;\n    for(int i = 0; i < n; ++i){\n      string s;\n      cin >> s;\n      vector<P> Poly;\n      if(!M[s]){\n        M[s] = t;\n        ++t;\n      }\n      double x;\n      while(cin >> x, x != -1){\n        double y;\n        cin >> y;\n        Poly.emplace_back(x,y);\n      }\n      V[M[s]-1].emplace_back(Poly);\n    }\n    int c = t-1;\n    vector< vector<int> > G(c, vector<int>(c,0));\n    for(int i = 0; i < c; ++i){\n      for(int j = 0; j < i; ++j){\n        for(int k = 0; k < V[i].size(); ++k){\n          for(int l = 0; l < V[j].size(); ++l){\n            if(is_adjacent(V[i][k], V[j][l])) ++G[i][j], ++G[j][i];\n          }\n        }\n      }\n    }\n\n    for(int i=0; i<c; i++) {\n      for(int j=0; j<c; j++) {\n        fprintf(stderr, \"%d \", G[i][j]);\n      }\n      fprintf(stderr, \"\\n\");\n    }\n\n    vector<int> dp(1 << c, INF);\n    dp[0] = 0;\n    for(int bit=0; bit<(1<<c); bit++) {\n      for(int mask=0; mask<(1<<c); mask++) {\n        if((bit & mask) != 0) continue;\n        bool ok = true;\n        for(int i=0; i<c; i++) {\n          for(int j=0; j<c; j++) {\n            if(!(mask >> i & 1)) continue;\n            if(!(mask >> j & 1)) continue;\n            if(G[i][j]) ok = false;\n          }\n        }\n\n        int nbit = bit | mask;\n        if(ok) dp[nbit] = min(dp[nbit], dp[bit] + 1);\n      }\n    }\n    cout << dp[(1<<c) - 1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint isccw(const vi& xs,const vi& ys)\n{\n\tint sum=0;\n\trep(i,xs.size()){\n\t\tint x1=xs[i],x2=xs[(i+1)%xs.size()];\n\t\tint y1=ys[i],y2=ys[(i+1)%ys.size()];\n\t\tsum+=x1*y2-y1*x2;\n\t}\n\tassert(sum);\n\treturn sum>0;\n}\n\nint solve(const vvi& g,int u,vi& color)\n{\n\tint n=g.size();\n\tif(u==n) return *max_element(all(color))+1;\n\tint mx=*max_element(all(color));\n\tint res=INF;\n\tfor(int c=0;c<=mx+1;c++){\n\t\tbool ok=true;\n\t\tfor(int v:g[u])\n\t\t\tif(color[v]==c){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,solve(g,u+1,color));\n\t\t\tcolor[u]=-1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tmap<string,int> ntoi;\n\t\tconst int h=1001,w=1001;\n\t\tvvi grid(h,vi(w,-1));\n\t\trep(_,n){\n\t\t\tstring name; cin>>name;\n\t\t\tntoi.insert(mp(name,ntoi.size()));\n\t\t\tint v=ntoi[name];\n\t\t\tvi xs,ys;\n\t\t\tfor(int x,y;cin>>x && x!=-1;){\n\t\t\t\tcin>>y;\n\t\t\t\txs.push_back(x);\n\t\t\t\tys.push_back(y);\n\t\t\t}\n\t\t\tif(!isccw(xs,ys)){\n\t\t\t\treverse(all(xs));\n\t\t\t\treverse(all(ys));\n\t\t\t}\n\t\t\trep(i,xs.size()){\n\t\t\t\tint x1=xs[i],x2=xs[(i+1)%xs.size()];\n\t\t\t\tint y1=ys[i],y2=ys[(i+1)%ys.size()];\n\t\t\t\tif(x1<x2 && y1==y2)\n\t\t\t\t\trepi(x,x1,x2) grid[y1][x]=v;\n\t\t\t\tif(x1>x2 && y1==y2)\n\t\t\t\t\tperi(x,x2,x1) grid[y1-1][x]=v;\n\t\t\t\tif(x1==x2 && y1<y2)\n\t\t\t\t\trepi(y,y1,y2) grid[y][x1-1]=v;\n\t\t\t\tif(x1==x2 && y1>y2)\n\t\t\t\t\tperi(y,y2,y1) grid[y][x1]=v;\n\t\t\t}\n\t\t}\n\t\t\n\t\tn=ntoi.size();\n\t\tvvi d(n,vi(n));\n\t\trep(i,h) rep(j,w) rep(k,4){\n\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj) continue;\n\t\t\tint u=grid[i][j],v=grid[ni][nj];\n\t\t\tif(u!=-1 && v!=-1 && u!=v) d[u][v]=d[v][u]=1;\n\t\t}\n\t\t\n\t\tvvi g(n);\n\t\trep(i,n) rep(j,n) if(d[i][j])\n\t\t\tg[i].push_back(j);\n\t\t\n\t\t//rep(i,n) dump(g[i]);\n\t\t\n\t\tvi color(n,-1);\n\t\tcout<<solve(g,0,color)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[100000];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  for(int i=0;i<100000;i++)G[i].clear();\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      for(int j=0;j<(int)str.size();j++){\n        if('a'<=str[j]&&str[j]<='z'){\n          str[j]=str[j]-'a'+'A';\n        }\n      }\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n#define int long long\n \nusing namespace std;\n\n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\npair<Point,Point> getCrossPointCL(Circle c,Line l);\npair<Point,Point> getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\npair<Point,Point> getCrossPointCL(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\npair<Point,Point> getCrossPointCC(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\n#define MAX 11\nbool e[MAX][MAX];\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint I[1<<MAX],bn[1<<MAX];\nbool check(int n,int k){\n  int g=0;\n  int MOD=10009;\n  for(int i=0;i<(1<<n);i++){\n    if(bn[i]%2==0) g+=mod_pow(I[i],k,MOD);\n    else g-=mod_pow(I[i],k,MOD);\n  }\n  return (g%MOD+MOD)%MOD!=0;\n}\nint paint(int n){\n  vector<int> N(1<<n);\n  for(int i=0;i<n;i++){\n    int bit=(1<<i);\n    for(int j=0;j<n;j++)\n      if(e[i][j]) bit|=(1<<j);\n    N[i]=bit;\n  }\n  memset(I,0,sizeof(I));\n  I[0]=1;\n  for(int S=1;S<(1<<n);S++){\n    bn[S]=__builtin_popcountll(S);\n    int v=0;\n    while(!((S>>v)&1)) v++;\n    I[S]=I[S-(1<<v)]+I[S&~N[v]];\n  }\n  int l=0,r=n;\n  while(l+1<r){\n    int m=(l+r)/2;\n    if(check(n,m)) r=m;\n    else l=m;\n  }\n  return r;\n}\nbool calc(Point a1,Point a2,Point b1,Point b2){\n  if(abs(cross(a2-a1,b1-a1))>EPS) return 0;\n  if(abs(cross(a2-a1,b2-a1))>EPS) return 0;\n  double ml=0;\n  ml=max(ml,abs(a1-a2));\n  ml=max(ml,abs(a1-b1));\n  ml=max(ml,abs(a1-b2));\n  ml=max(ml,abs(a2-b1));\n  ml=max(ml,abs(a2-b2));\n  ml=max(ml,abs(b1-b2));\n  return (ml+EPS<abs(a1-a2)+abs(b1-b2));\n}\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p[n];\n    string name[n];\n    map<string,int> m;\n    for(int i=0;i<n;i++){\n      cin>>name[i];\n      if(!m.count(name[i])){\n\tint k=m.size();\n\tm[name[i]]=k;\n      }\n      int x,y;\n      while(cin>>x,~x){\n\tcin>>y;\n\tp[i].push_back(Point(x,y));\n      }\n    }\n    memset(e,0,sizeof(e));\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(name[i]==name[j]) continue;\n\tfor(int k=0;k<(int)p[i].size();k++){\n\t  for(int l=0;l<(int)p[j].size();l++){\n\t    e[m[name[i]]][m[name[j]]]|=\n\t      calc(p[i][k],p[i][(k+1)%p[i].size()],\n\t\t   p[j][l],p[j][(l+1)%p[j].size()]);\n\t    e[m[name[j]]][m[name[i]]]|=\n\t      calc(p[i][k],p[i][(k+1)%p[i].size()],\n\t\t   p[j][l],p[j][(l+1)%p[j].size()]);\n\t  }\n\t}\n\t//cout<<i<<\" \"<<j<<\":\"<<e[m[name[i]]][m[name[j]]]<<endl;\n      }\n    }\n    /*\n    for(int i=0;i<(int)m.size();i++){\n      for(int j=0;j<(int)m.size();j++) cout<<e[i][j];\n      cout<<endl;\n    }\n    */\n    cout<<paint(m.size())<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\n\nbool eq(double n1,double n2){return abs(n1-n2)<EPS;}\n\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  /*if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if( EPS < right-left ) return true;\n  else return false;\n  */\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n}\n\nvoid func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0,k1=0,k2;\n    for(ite=S.begin();ite!=S.end();ite++,k1++){\n      set<string>::iterator ite2=ite;\n      ite2++;\n      k2=k1+1;\n      while(ite2!=S.end()){\n\tif(mark[k1]!=mark[k2]){\n\t  ite2++;\n\t  k2++;\n\t  continue;\n\t}\n\tif(z.find(P1((*ite),(*ite2)))!=z.end()){\n\t  f=1;\n\t  break;\n\t}\n\tite2++;\n\tk2++;\n      }\n      if(f)break;\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n \nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n \nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n \nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n \nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n \n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < EPS)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() - EPS < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定(平行でない)\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(l.vector(), m.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n \ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n \nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = prev(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nbool is_adj(Polygon& P, Polygon& Q){\n  REP(i, P.size())REP(j, Q.size())if(intersectSS(Line(curr(P, i), next(P, i)), Line(curr(Q, j), next(Q, j)))) return true;\n  return false;\n}\nint dfs(int K, int maxc, bool d[10][10], int M, int color[10]){\n  if(K == M) return maxc;\n  int res = INF;\n  for(int c = 1; c <= maxc; c++){\n    bool ok = true;\n    REP(i, K) if(d[i][K] && color[i] == c) ok = false;\n    if(!ok) continue;\n    color[K] = c;\n    res = min(res, dfs(K + 1, maxc, d, M, color));\n  }\n  color[K] = maxc + 1;\n  res = min(res, dfs(K + 1, maxc + 1, d, M, color));\n  return res;\n}\nint main(){\n  int N;\n  while(cin>>N && N){\n    map<string, int> id;\n    vector<string> name(N);\n    vector<Polygon> terry;\n    REP(i, N){\n      cin>>name[i];\n      if(!id.count(name[i])){\n        int t = id.size();\n        id[name[i]] = t;\n      }\n      Polygon P;\n      double x, y;\n      while(cin>>x && x != -1){\n        cin>>y;\n        P.push_back(Point(x, y));\n      }\n      terry.push_back(P);\n    }\n    int M = id.size();\n    bool t[10][10] = {};\n    REP(i, N)FOR(j, i + 1, N){\n      int a = id[name[i]], b = id[name[j]];\n      if(is_adj(terry[i], terry[j]) && a != b){\n        t[a][b] = t[b][a] = true;\n      }\n    }\n    int color[10];\n    cout<<dfs(0, 0, t, M, color)<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Point\n{\npublic:\n    int y, x;\n    Point(){\n        y = x = 0;\n    }\n    Point(int y0, int x0){\n        y = y0;\n        x = x0;\n    }\n    Point operator+(const Point& p) const{\n        return Point(y + p.y, x + p.x);\n    }\n    Point operator-(const Point& p) const{\n        return Point(y - p.y, x - p.x);\n    }\n    Point operator*(int a) const{\n        return Point(y * a, x * a);\n    }\n    int length2() const{\n        return y * y + x * x;\n    }\n    int dist2(const Point& p) const{\n        return (y - p.y) * (y - p.y) + (x - p.x) * (x - p.x);\n    }\n    int dot(const Point& p) const{\n        return y * p.y + x * p.x; // |a|*|b|*cos慮\n    }\n    int cross(const Point& p) const{\n        return x * p.y - y * p.x; // |a|*|b|*sin慮\n    }\n    bool operator==(const Point& p) const{\n        return x == p.x && y == p.y;\n    }\n};\n\nbool segmentsCollide(const Point& a1, const Point& a2, const Point& b1, const Point& b2)\n{\n    if(min(a1.x, a2.x) > max(b1.x, b2.x) || min(b1.x, b2.x) > max(a1.x, a2.x) || min(a1.y, a2.y) > max(b1.y, b2.y) || min(b1.y, b2.y) > max(a1.y, a2.y))\n        return false;\n\n    return (a2-a1).cross(b1-a1) == 0 && (a2-a1).cross(b2-a1) == 0 && ((b1-a1).dot(b2-a1) < 0 || (b1-a2).dot(b2-a2) < 0 || (a1-b1).dot(a2-b1) < 0 || (a1-b2).dot(a2-b2) < 0 || (a1 == b1 && a2 == b2) || (a1 == b2 && a2 == b1));\n}\n\nbool polygonsCollide(const vector<Point>& cp1, const vector<Point>& cp2)\n{\n    int n = cp1.size();\n    int m = cp2.size();\n    for(int i=0; i<n; ++i){\n        for(int j=0; j<m; ++j){\n            if(segmentsCollide(cp1[i], cp1[(i+1)%n], cp2[j], cp2[(j+1)%m]))\n                return true;\n        }\n    }\n    return false;\n}\n\nint solve(vector<vector<bool> >& connect, vector<int>& color, int i)\n{\n    int n = color.size();\n    if(i == n)\n        return *max_element(color.begin(), color.end()) + 1;\n\n    int ret = INT_MAX;\n    for(int j=0; j<4; ++j){\n        bool ok = true;\n        for(int k=0; k<i; ++k){\n            if(connect[i][k] && color[k] == j)\n                ok = false;\n        }\n\n        if(ok){\n            color[i] = j;\n            ret = min(ret, solve(connect, color, i+1));\n        }\n    }\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<string> name(n);\n        vector<vector<Point> > p(n);\n        int m = 0;\n        map<string, int> index;\n        for(int i=0; i<n; ++i){\n            cin >> name[i];\n            if(index.find(name[i]) == index.end()){\n                index[name[i]] = m;\n                ++ m;\n            }\n            for(;;){\n                int x, y;\n                cin >> x;\n                if(x == -1)\n                    break;\n                cin >> y;\n                p[i].push_back(Point(y, x));\n            }\n        }\n\n        vector<vector<bool > > connect(m, vector<bool>(m, false));\n        for(int i=0; i<n; ++i){\n            for(int j=i+1; j<n; ++j){\n                if(index[name[i]] != index[name[j]] && polygonsCollide(p[i], p[j]))\n                    connect[index[name[i]]][index[name[j]]] = connect[index[name[j]]][index[name[i]]] = true;\n            }\n        }\n\n        vector<int> color(m);\n        cout << solve(connect, color, 0) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 105\n#define M 15\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nstring d[M];\nset<P1> z;\n\ndouble dot(P A,P B){return real(conj(A)*B);}\ndouble cross(P A,P B){return imag(conj(A)*B);}\n\nint ccw(P A, P B, P C){\n  B-=A;\n  C-=A;\n  if(cross(B,C)>EPS)return 1;\n  if(cross(B,C)<-EPS)return -1;\n  if(dot(B,C)<-EPS)return 2;\n  if(norm(B)<norm(C))return -2;\n  return 0;\n}\n\nbool check(P A1,P A2,P B1,P B2){\n  int r1=ccw(A1,A2,B1);\n  int r2=ccw(A1,A2,B2);\n  int r3=ccw(B1,B2,A1);\n  int r4=ccw(B1,B2,A2);\n  if(r1==1||r1==-1||r2==1||r2==-1)return false;\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if(right-left<=EPS)return false;\n  if(!r1||!r2||!r3||!r4)return true;\n  return false;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++){\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      string s1=min(d[i],d[j]);\n      string s2=max(d[i],d[j]);\n      if(z.find(P1(s1,s2))!=z.end())return;\n    }\n  }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P A1=v[i][k],A2=v[i][(k+1)%leni];\n\t    P B1=v[j][l],B2=v[j][(l+1)%lenj];\n\t    if(check(A1,A2,B1,B2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point &a, Point &b, Point &c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2=a[(i+1)%a.size()], p3=b[j], p4=b[(j+1)%b.size()];\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge, vector<Polygon> *country, int n){\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(is_Touch(country[i], country[j])) edge[i].push_back(j), edge[j].push_back(i);\n    }\n  }\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+n, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      cin >> name;\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()>-1-EPS && t.real()<-1+EPS) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+n, -1);\n    ans=10;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  Point Q=p-(s.p+s.v);\n  if(dot(s.p-s.p-s.v,Q)<=0)return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  for(int i=0;i<10;i++)G[i].clear();\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        scanf(\"%d\",&px);\n        if(px==-1)break;\n        scanf(\"%d\",&py);\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++)\n      for(int j=i+1;j<c;j++)\n        if(calc(i,j))g[i][j]=g[j][i]=1;\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j+1<c;j++){\n        if(i>>j&1){\n          for(int k=j+1;k<c;k++){\n            if(i>>k&1){\n              if(g[j][k])flg=false;\n            }\n          }\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[(1<<c)];\n    fill(dp,dp+(1<<c),1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-5;\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef vector<Polygon> Country;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    map<string,Country> m;\n    while(n--){\n      string s;\n      cin>>s;\n      Polygon p;\n      for(int x,y;cin>>x,x>=0;){\n\tcin>>y;\n\tp.push_back(P(x,y));\n      }\n      m[s].push_back(p);\n    }\n    vector<Country> c;\n    for(auto e:m){\n      c.push_back(e.second);\n    }\n    bool d[100][100]={};\n    for(int i=0;i<c.size();i++){\n      for(auto e:c[i]){\n\tfor(int j=0;j<e.size();j++){\n\t  for(int k=0;k<i;k++){\n\t    for(auto f:c[k]){\n\t      for(int l=0;l<f.size();l++){\n\t\tP a=e[j],b=e[(j+1)%e.size()];\n\t\tP x=f[l],y=f[(l+1)%f.size()];\n\t\tif(fabs(cross(a-b,x-b))<eps&&fabs(cross(a-b,y-b)<eps)){\n\t\t  double len=abs(a-b);\n\t\t  if(!(len<abs(x-a)+eps&&len<abs(y-a)+eps||len<abs(x-b)+eps&&len<abs(y-b)+eps)){\n\t\t    d[i][k]=d[k][i]=true;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    int a=1;\n    for(int i=0;i<c.size();i++){\n      for(int j=0;j<i;j++){\n\tif(d[i][j]){\n\t  a=max(a,2);\n\t  for(int k=0;k<j;k++){\n\t    if(d[i][k]&&d[j][k]){\n\t      a=max(a,3);\n\t      for(int l=0;l<k;l++){\n\t\tif(d[i][l]&&d[j][l]&&d[k][l]){\n\t\t  a=4;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\n\nint cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(l==Alen+Blen)r=false;\n  if(B1.Y||B2.Y)r=false;\n  return r;\n}\n\nvoid func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0,k1=0,k2;\n    for(ite=S.begin();ite!=S.end();ite++,k1++){\n      set<string>::iterator ite2=ite;\n      ite2++;\n      k2=k1+1;\n      while(ite2!=S.end()){\n\tif(mark[k1]!=mark[k2]){\n\t  ite2++;\n\t  k2++;\n\t  continue;\n\t}\n\tif(z.find(P1((*ite),(*ite2)))!=z.end())f=1;\n\tite2++;\n\tk2++;\n      }\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++){\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2)){\n\t      z.insert(P1(s1,s2));\n\t    }\n\t  }\n\t}\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\tvoid out(Segment& s){\n\t\tcout << s.p1 << ' ' << s.p2 << endl;\n\t}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n\tbool operator == (const Segment &a, const Segment &b){\n\t\treturn (a.p1 == b.p1 and a.p2 == b.p2) or (a.p1 == b.p2 and a.p2 == b.p1);\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\nbool isIntersectedLs_(Point a1, Point a2, Point b1, Point b2) {\n\tdouble ax = a1.real(), ay = a1.imag();\n\tdouble bx = a2.real(), by = a2.imag();\n\tdouble cx = b1.real(), cy = b1.imag();\n\tdouble dx = b2.real(), dy = b2.imag();\n\n\tdouble ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tdouble tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tdouble tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tdouble td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n\treturn tc * td < -EPS and ta * tb < -EPS; // 端点含まず\n\t//return tc * td <= 0 and ta * tb <= 0; // 端点含む\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs_(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint nxt(Polygon& a, int i){\n\treturn a[(i + 1) % a.size()];\n}\n\nbool shareBorder(Polygon& a, Polygon& b){\n\tauto f = [](Segment s1, Segment s2) -> bool{\n\t\tif(isParallel(s1, s2)){\n\t\t\tPoint t = (s1.p1 != s2.p1 and s1.p1 != s2.p2) ? s1.p1 : s1.p2;\n\t\t\tif(ccw(s2.p1, s2.p2, t) == ON_SEGMENT) return true;\n\t\t}\n\t\treturn false;\n\t};\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tSegment s1 = Segment{a[i], nxt(a,i)}, s2 = Segment{b[j], nxt(b,j)};\n\t\t\tif(s1 == s2) return true;\n\n\t\t\tif(f(s1,s2) or f(s2,s1)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tmap<string, vector<Polygon>> ps;\n\t\trep(i,n){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\n\t\t\tPolygon p;\n\t\t\tdouble y, x;\n\t\t\twhile(cin >> y, y != -1){\n\t\t\t\tcin >> x;\n\t\t\t\tp.emplace_back(Point(y,x));\n\t\t\t}\n\t\t\t//show(name)\n\t\t\tps[name].emplace_back(p);\n\t\t}\n\n\t\t//for(auto i : ps){ show(i.first) for(auto j : i.second){ cout << j << endl; } }\n\n\t\tvector<vector<Polygon>> v;\n\t\tfor(auto i : ps){\n\t\t\tv.emplace_back(i.second);\n\t\t}\n\n\t\tvector<int> color(ps.size(), -1);\n\t\trep(i,v.size()){\n\t\t\tset<int> s;\n\t\t\t//show(i)\n\t\t\trep(j,v.at(i).size()){\n\t\t\t\trep(k,v.size()){\n\t\t\t\t\tif(i == k) continue;\n\t\t\t\t\trep(l,v.at(k).size()){\n\t\t\t\t\t\tif(shareBorder(v[i][j], v[k][l])){\n\t\t\t\t\t\t\t//cout << i << ' ' << k << endl;\n\t\t\t\t\t\t\ts.emplace(color[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(j,4){\n\t\t\t\tif(not s.count(j)){\n\t\t\t\t\tcolor[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tset<int> s;\n\t\tfor(auto i : color) s.emplace(i);\n\t\tcout << s.size() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nconstexpr double EPS = (1e-10);\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point() {}\n    Point(double x, double y) : x{x}, y{y} {}\n\n    Point operator - (const Point& p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble dot(const Point& a, const Point& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point& p)\n{\n    return dot(p, p);\n}\n\nconstexpr int COUNTER_CLOCKWISE = +1;\nconstexpr int CLOCKWISE         = -1;\nconstexpr int ONLINE_BACK       = +2;\nconstexpr int ONLINE_FRONT      = -2;\nconstexpr int ON_SEGMENT        = +0;\nusing Vector = Point;\n\nint ccw(const Point& p0, const Point& p1, const Point& p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment() {}\n    Segment(Point s, Point t) : s{s}, t{t} {}\n};\n\nbool parallel(const Segment& s1, const Segment& s2)\n{\n    Vector a = s1.t - s1.s;\n    Vector b = s2.t - s2.s;    \n    return equals(cross(a, b), 0);\n}\n\nusing ll = long long;\nconstexpr int MAX = 10;\n\nbool con[MAX][MAX];\n\ninline int mod_pow(ll x, int n, int mod)\n{\n    if (n == 0) return 1;\n    int res = mod_pow(x * x % mod, n / 2, mod);\n    if (n & 1) res = res * x % mod;\n    return res;\n}\n\nint I[1 << MAX], bn[1 << MAX];\n\nbool c(int n, int k)\n{\n    ll g = 0;\n    constexpr int MOD = 10009;    \n    for (int i = 0; i < (1 << n); i++) {\n        if (bn[i] % 2 == 0) {\n            g += mod_pow(I[i], k, MOD);\n        } else {\n            g -= mod_pow(I[i], k, MOD);\n        }\n    }\n    return (g % MOD + MOD) % MOD != 0;\n}\n\nint paint_color_num(int n)\n{\n    vector<int> N(1 << n);\n    for (int i = 0; i < n; i++) {\n        int bit = (1 << i);\n        for (int j = 0; j < n; j++) {\n            if (i != j && con[i][j]) {\n                bit |= (1 << j);\n            }\n        }\n        N[i] = bit;\n    }\n        \n    memset(I, 0, sizeof(I));\n    I[0] = 1;\n    for (int S = 1; S < (1 << n); S++) {\n        bn[S] = __builtin_popcount(S);\n        int v = 0;\n        while (!(S >> v & 1)) v++;\n        I[S] = I[S - (1 << v)] + I[S & ~N[v]];\n    }\n            \n    int L = 0, R = n;\n    while (R - L > 1) {\n        int mid = (L + R) / 2;\n        if (c(n, mid)) {\n            R = mid;\n        } else {\n            L = mid;\n        }           \n    }\n    return R;\n}\n\nusing Polygon = vector<Point>;\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\n\nbool check(const Polygon& p1, const Polygon& p2)\n{\n    int N = p1.size(), M = p2.size();    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            Segment s1{curr(p1, i), next(p1, i)};\n            Segment s2{curr(p2, j), next(p2, j)};\n            if ((ccw(s1.s, s1.t, s2.s) == 0 && ccw(s1.s, s1.t, s2.t) == 0) ||\n                (ccw(s2.s, s2.t, s1.s) == 0 && ccw(s2.s, s2.t, s1.t) == 0)) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    \n    map<string, int> num;\n    vector<int> c(N);\n    vector<Polygon> pgs(N);\n    \n    int idx = 0;\n    string country;\n    for (int i = 0; i < N; i++) {\n        cin >> country;\n        if (num.count(country) == 0) {\n            num[country] = idx++;\n        }\n        \n        c[i] = num[country];\n        \n        double x, y;\n        Polygon pg;\n        while (cin >> x, x != -1) {\n            cin >> y;\n            pg.emplace_back(x, y);\n        }\n        pgs[i] = pg;\n    }\n\n    memset(con, 0, sizeof(con));\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (c[i] == c[j]) continue;\n            \n            if (check(pgs[i], pgs[j])) {\n                con[c[i]][c[j]] = con[c[i]][c[j]] = 1;\n            }\n        }\n    }\n\n    cout << paint_color_num(idx) << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <complex>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nusing Pd = pair<ld, ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\ntypedef vector<P> region;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > eps)  return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;     // clockwise\n\tif(dot(b, c) < 0)      return BEHIND; // c--a--b on line\n\tif(norm(b) < norm(c))  return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nstruct L : public vector<P> {\n\tL(const P &a = 0, const P &b = 0) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tL(ld A, ld B, ld C) { // Ax + By + C = 0\n\t\tif(A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n\t\telse if(B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t}\n\tint ccw(const P& p) {\n\t\treturn ::ccw((*this)[0], (*this)[1], p);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps; // triangle inequality\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\nld distanceSS(const L &s, const L &t) {\n\tif(intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint n, C;\n\nbool adjacent(region r1, region r2) {\n\tint n1 = r1.size(), n2 = r2.size();\n\tfor(int i = 0; i < r1.size(); i++) {\n\t\tfor(int j = 0; j < r2.size(); j++) {\n\t\t\tP p11 = r1[i], p12 = r1[(i + 1) % n1];\n\t\t\tP p21 = r2[j], p22 = r2[(j + 1) % n2];\n\t\t\tif(p11.real() > p12.real()) swap(p11, p12);\n\t\t\tif(p21.real() > p22.real()) swap(p21, p22);\n\t\t\tL s1 = L(p11, p12), s2 = L(p21, p22);\n\t\t\tif(abs(cross(p11 - p12, p21 - p22)) > eps) continue;\n\t\t\tif(distanceSS(s1, s2) > eps) continue;\n\t\t\tvector<pair<Pd, int> > v;\n\t\t\tv.emplace_back(Pd(p11.real(), p11.imag()), 0);\n\t\t\tv.emplace_back(Pd(p12.real(), p12.imag()), 0);\n\t\t\tv.emplace_back(Pd(p21.real(), p21.imag()), 1);\n\t\t\tv.emplace_back(Pd(p22.real(), p22.imag()), 1);\n\t\t\tsort(v.begin(), v.end());\n\t\t\tif(v[1].first != v[2].first) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint adj[100][100];\nint color[100];\nint ans;\n\nbool check() {\n\tfor(int i = 0; i < C; i++) {\n\t\tfor(int j = i + 1; j < C; j++) {\n\t\t\tif(adj[i][j] && color[i] == color[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(int n) {\n\tif(n == C) {\n\t\tif(check()) {\n\t\t\tint cnt = 0;\n\t\t\tint used[100] = { 0 };\n\t\t\tfor(int i = 0; i < C; i++) {\n\t\t\t\tif(!used[color[i]]) {\n\t\t\t\t\tused[color[i]] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(ans, cnt);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int c = 0; c < C; c++) {\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(adj[n][i] && c == color[i]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tcolor[n] = c;\n\t\t\tdfs(n + 1);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tmap<string, int> id;\n\t\tvector<string> name(n);\n\t\tvector<region> rs(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> name[i];\n\t\t\tid[name[i]] = -1;\n\t\t\tregion r;\n\t\t\tint a, b;\n\t\t\twhile(cin >> a, a != -1) {\n\t\t\t\tcin >> b;\n\t\t\t\tr.push_back(P(a, b));\n\t\t\t}\n\t\t\trs[i] = r;\n\t\t}\n\n\t\tC = 0;\n\t\tfor(auto& p : id) {\n\t\t\tid[p.first] = C++;\n\t\t}\n\n\t\tmemset(adj, 0, sizeof adj);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tint id1 = id[name[i]], id2 = id[name[j]];\n\t\t\t\tif(id1 == id2 || adj[id1][id2]) continue;\n\t\t\t\tif(adjacent(rs[i], rs[j])) {\n\t\t\t\t\tadj[id1][id2] = adj[id2][id1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 1000000;\n\t\tdfs(1);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  REP(i, 2) {\n    if (ccw(s[0], s[1], t[i]) == 0) {\n      int c = ccw(s[0],s[1],t[!i]);\n      if (s[0] == t[i]) {\n        if (c!=-2&&c) return 0;\n      } else if (s[1] == t[i]) {\n        if (c!=2&&c) return 0;\n      } else if (abs(c)==1) return 0;\n    }\n  }\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectGG(G a, G b) {\n  a.push_back(a[0]);\n  b.push_back(b[0]);\n  REP(i, a.size()-1)\n    REP(j, b.size()-1)\n      if (intersectSS(L(a[i], a[i+1]), L(b[j], b[j+1])))\n        return 1;\n  return 0;\n}\n\nint n;\nint num;\n\nvector<int> graph[10];\nint color[10];\n\nint dfs(int id, int maxcolor) {\n  if (id == num) return maxcolor;\n  int res = INF;\n  for (int i=1; i<=maxcolor; ++i) {\n    bool dame = 0;\n    FOR(it, graph[id])\n      if (color[*it] == i)\n        goto NEXT;\n    color[id] = i;\n    res = min(res, dfs(id+1, maxcolor));\n  NEXT:;\n  }\n  color[id] = maxcolor+1;\n  res = min(res, dfs(id+1, maxcolor+1));\n  return res;\n}\n\nint main() {\n  // cout << \"0 -> \" << intersectSS(L(P(100,100), P(100,0)), L(P(100,90), P(200,200))) << endl;\n  // cout << \"1 -> \" << intersectSS(L(P(100,100), P(100,0)), L(P(100,90), P(100,200))) << endl;\n  // cout << \"1 -> \" << intersectSS(L(P(100,100), P(100,0)), L(P(100,100), P(100,0))) << endl;\n  // return 0;\n  while(cin >> n, n) {\n    vector<G> polygon[n];\n    num = 0;\n    map<string, int> id;\n    REP(i, n) {\n      string name;\n      cin >> name;\n      int x, y;\n      G tmp;\n      while(cin >> x, x!=-1) {\n        cin >> y;\n        tmp.push_back(P(x,y));\n      }\n      if (id.count(name) == 0) id[name] = num++;\n      polygon[id[name]].push_back(tmp);\n    }\n    REP(i, num) graph[i].clear();\n    REP(i, num) {\n      REP(j, i) {\n        FOR(it, polygon[i]) {\n          FOR(jt, polygon[j]) {\n            if (intersectGG(*it, *jt)) {\n              graph[i].push_back(j);\n              graph[j].push_back(i);\n              goto NEXT;\n            }\n          }\n        }\n      NEXT:;\n      }\n    }\n    // REP(i, num) {\n    //   cout << i << \" : \";\n    //   FOR(it, graph[i])\n    //     cout << *it << \" \";\n    //   cout << endl;\n    // }\n    memset(color, 0, sizeof(color));\n    cout << dfs(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[100000];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++)\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  for(int i=0;i<100000;i++)G[i].clear();\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point &a, Point &b, Point &c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2, p3=b[j], p4;\n      if(i==a.size()-1 && j==b.size()-1){\n\tp2=a[0];\n\tp4=b[0];\n      }else if(i==a.size()-1){\n\tp2=a[0];\n\tp4=b[j+1];\n      }else if(j==b.size()-1){\n\tp2=a[i+1];\n\tp4=b[0];\n      }else{\n\tp2=a[i+1];\n\tp4=b[j+1];\n      }\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge, vector<Polygon> *country, int n){\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(is_Touch(country[i], country[j])) edge[i].push_back(j), edge[j].push_back(i);\n    }\n  }\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin >> n, n){\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      cin >> name;\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=4;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\n/*** geometry part ***/\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble dot(const point &a,const point &b){ return a.x*b.x+a.y*b.y; }\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\nstruct segment{\n\tpoint a,b;\n\tsegment(){}\n\tsegment(const point &a,const point &b):a(a),b(b){}\n};\n\ntypedef vector<point> polygon;\n\nenum{CCW=1,CW=-1,ON=0};\nint ccw(const point &a,const point &b,const point &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool cover(const segment &S,const point &p){\n\treturn abs(cross(S.a-p,S.b-p))<EPS && dot(S.a-p,S.b-p)<EPS;\n}\n\n// 二つの線分が長さ正の部分で接しているかどうか\nbool touch(const segment &S,const segment &T){\n\tif(ccw(S.a,S.b,T.a)!=ON || ccw(S.a,S.b,T.b)!=ON) return false; // 平行でないとダメ\n\tif(S.a==T.a && S.b==T.b\n\t|| S.a==T.b && S.b==T.a) return true;\n\treturn cover(S,T.a) && S.a!=T.a && S.b!=T.a\n\t\t|| cover(S,T.b) && S.a!=T.b && S.b!=T.b\n\t\t|| cover(T,S.a) && T.a!=S.a && T.b!=S.a\n\t\t|| cover(T,S.b) && T.a!=S.b && T.b!=S.b;\n}\n\n// 二つの多角形が長さ正の部分で接しているかどうか\nbool touch(const polygon &F,const polygon &G){\n\tint m=F.size(),n=G.size();\n\trep(i,m) rep(j,n) {\n\t\tsegment S(F[i],F[(i+1)%m]);\n\t\tsegment T(G[j],G[(j+1)%n]);\n\t\tif(touch(S,T)) return true;\n\t}\n\treturn false;\n}\n\n/*** end ***/\n\n/*** graph part ***/\n\nint N; // 異なる国の個数\nbool G[10][10]; // 国どうしの接続関係のグラフ\n\nint color[10];\n// 彩色\nint dfs(int u,int next){\n\tif(u==N) return next;\n\n\tint res=N;\n\trep(c,next+1){\n\t\tbool ok=true;\n\t\trep(v,N) if(G[u][v] && color[v]==c) ok=false;\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,dfs(u+1,max(c+1,next)));\n\t\t}\n\t}\n\treturn res;\n}\n\n/*** end ***/\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstring name[100];\n\t\tpolygon F[100];\n\t\trep(i,n){\n\t\t\tchar s[32]; scanf(\"%s\",s);\n\t\t\tname[i]=s;\n\t\t\twhile(1){\n\t\t\t\tpoint p;\n\t\t\t\tscanf(\"%lf\",&p.x);\n\t\t\t\tif(p.x==-1) break;\n\t\t\t\tscanf(\"%lf\",&p.y);\n\t\t\t\tF[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tmap<string,int> f;\n\t\trep(i,n) if(f.count(name[i])==0) {\n\t\t\tf.insert(make_pair(name[i],f.size()));\n\t\t}\n\n\t\tN=f.size();\n\t\trep(u,N) rep(v,N) G[u][v]=false;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint u=f[name[i]],v=f[name[j]];\n\t\t\tif(u!=v && !G[u][v] && touch(F[i],F[j])) G[u][v]=true;\n\t\t}\n\n\t\trep(u,N) color[u]=-1;\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> L;\ntypedef vector<xy_t> polygon;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define DI(l) ((l).second-(l).first)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n\ndouble cross(const xy_t &a, const xy_t &b) { return imag(conj(a)*b); }\ndouble dot(const xy_t& a, const xy_t& b) { return real(conj(a)*b); }\n\nint ccw(xy_t a, xy_t b, xy_t c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\n\nL shorten(const L &l){\n  xy_t p1 = l.first;\n  xy_t p2 = l.second;\n  \n  if(p1.real() > p2.real()){\n    p1.real() -= EPS;\n    p2.real() += EPS;\n  }else if(p1.real() < p2.real()){\n    p1.real() += EPS;\n    p2.real() -= EPS;\n  }\n\n  if(p1.imag() > p2.imag()){\n    p1.imag() -= EPS;\n    p2.imag() += EPS;\n  }else if(p1.imag() < p2.imag()){\n    p1.imag() += EPS;\n    p2.imag() -= EPS;\n  }\n  return L(p1, p2);\n}\n\nbool share_border(const polygon &p1, const polygon &p2){\n  int n = p1.size();\n  int m = p2.size();\n  REP(i, n)REP(j, m){\n    L l1 = shorten(L(p1[i], p1[(i+1)%n]));\n    L l2 = L(p2[j], p2[(j+1)%m]);\n    if(sameline(l1, l2) && intersectSS(l1, l2)) return true;\n  }\n  return false;\n}\n\nbool dfs(int v, const vector<vector<bool> > &g, vector<int> &color, int C){\n  int n = g.size();\n  if(v == n) return true;\n  REP(c, C){\n    bool ok = true;\n    REP(i, n) if(g[v][i] && color[i] == c) ok = false;\n    if(ok){\n      color[v] = c;\n      if(dfs(v + 1, g, color, C)) return true;\n      color[v] = -1;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<vector<bool> > g(n, vector<bool>(n, false));\n    vector<string> names(n);\n    vector<polygon> polys(n);\n    REP(i, n){\n      cin >> names[i];\n      int x, y;\n      while(cin >> x && x != -1 && cin >> y) polys[i].PB(xy_t(x, y));\n    }\n    REP(i, n)REP(j, n)if(i != j) g[i][j] = share_border(polys[i], polys[j]);\n    \n    vector<int> color(n, -1);\n    if(dfs(0, g, color, 1)){\n      cout << 1 << endl;\n    }else if(dfs(0, g, color, 2)){\n      cout << 2 << endl;\n    }else if(dfs(0, g, color, 3)){\n      cout << 3 << endl;\n    }else{\n      cout << 4 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n  return false;\n}\n\nvoid init(){\n  c=0;\n  mp.clear();  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n        assert(n<=10);\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int j=0;j<size;j++)\n        G[id].push_back((Segment){t[j],t[(j+1)%size]-t[j]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    \n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <complex>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nusing Pd = pair<ld, ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\ntypedef vector<P> region;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > eps)  return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;     // clockwise\n\tif(dot(b, c) < 0)      return BEHIND; // c--a--b on line\n\tif(norm(b) < norm(c))  return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nstruct L : public vector<P> {\n\tL(const P &a = 0, const P &b = 0) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tL(ld A, ld B, ld C) { // Ax + By + C = 0\n\t\tif(A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n\t\telse if(B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t}\n\tint ccw(const P& p) {\n\t\treturn ::ccw((*this)[0], (*this)[1], p);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps; // triangle inequality\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\nld distanceSS(const L &s, const L &t) {\n\tif(intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint n, C;\n\nbool adjacent(region r1, region r2) {\n\tint n1 = r1.size(), n2 = r2.size();\n\tfor(int i = 0; i < r1.size(); i++) {\n\t\tfor(int j = 0; j < r2.size(); j++) {\n\t\t\tP p11 = r1[i], p12 = r1[(i + 1) % n1];\n\t\t\tP p21 = r2[j], p22 = r2[(j + 1) % n2];\n\t\t\tif(p11.real() > p12.real()) swap(p11, p12);\n\t\t\tif(p21.real() > p22.real()) swap(p21, p22);\n\t\t\tL s1 = L(p11, p12), s2 = L(p21, p22);\n\t\t\tif(abs(cross(p11 - p12, p21 - p22)) > eps) continue;\n\t\t\tif(distanceSS(s1, s2) > eps) continue;\n\t\t\tvector<pair<Pd, int> > v;\n\t\t\tv.emplace_back(Pd(p11.real(), p11.imag()), 0);\n\t\t\tv.emplace_back(Pd(p12.real(), p12.imag()), 0);\n\t\t\tv.emplace_back(Pd(p21.real(), p21.imag()), 1);\n\t\t\tv.emplace_back(Pd(p22.real(), p22.imag()), 1);\n\t\t\tsort(v.begin(), v.end());\n\t\t\tif(v[1].first != v[2].first) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint adj[100][100];\nint color[100];\nint ans;\n\nbool check() {\n\tfor(int i = 0; i < C; i++) {\n\t\tfor(int j = i + 1; j < C; j++) {\n\t\t\tif(adj[i][j] && color[i] == color[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(int n) {\n\tif(n == C) {\n\t\tif(check()) {\n\t\t\tint cnt = 0;\n\t\t\tint used[100] = { 0 };\n\t\t\tfor(int i = 0; i < C; i++) {\n\t\t\t\tif(!used[color[i]]) {\n\t\t\t\t\tused[color[i]] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = min(ans, cnt);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int c = 0; c < C; c++) {\n\t\tcolor[n] = c;\n\t\tdfs(n + 1);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tmap<string, int> id;\n\t\tvector<string> name(n);\n\t\tvector<region> rs(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> name[i];\n\t\t\tid[name[i]] = -1;\n\t\t\tregion r;\n\t\t\tint a, b;\n\t\t\twhile(cin >> a, a != -1) {\n\t\t\t\tcin >> b;\n\t\t\t\tr.push_back(P(a, b));\n\t\t\t}\n\t\t\trs[i] = r;\n\t\t}\n\n\t\tC = 0;\n\t\tfor(auto& p : id) {\n\t\t\tid[p.first] = C++;\n\t\t}\n\n\t\tmemset(adj, 0, sizeof adj);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tint id1 = id[name[i]], id2 = id[name[j]];\n\t\t\t\tif(id1 == id2 || adj[id1][id2]) continue;\n\t\t\t\tif(adjacent(rs[i], rs[j])) {\n\t\t\t\t\tadj[id1][id2] = adj[id2][id1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = 1000000;\n\t\tdfs(1);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nmap<string,int> idx;\nvector<P> v[N];\nset<string> S;\nbool c[M][M];\nstring s[N];\nstring d[M];\n\ndouble dot(P A,P B){return real(conj(A)*B);}\ndouble cross(P A,P B){return imag(conj(A)*B);}\n\nint ccw(P A, P B, P C){\n  B-=A;\n  C-=A;\n  if(cross(B,C)>EPS)return 1;\n  if(cross(B,C)<-EPS)return -1;\n  if(dot(B,C)<-EPS)return 2;\n  if(norm(B)<norm(C))return -2;\n  return 0;\n}\n\nbool check(P A1,P A2,P B1,P B2){\n  int r1=ccw(A1,A2,B1);\n  int r2=ccw(A1,A2,B2);\n  int r3=ccw(B1,B2,A1);\n  int r4=ccw(B1,B2,A2);\n  if(r1==1||r1==-1||r2==1||r2==-1)return false;\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if(right-left<=EPS)return false;\n  if(!r1||!r2||!r3||!r4)return true;\n  return false;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++)\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      if(c[i][j])return;\n    }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    memset(c,0,sizeof(c));\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)idx[(*ite)]=k;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tint s1=idx[s[i]],s2=idx[s[j]];\n\tif(s1==s2)continue;\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P A1=v[i][k],A2=v[i][(k+1)%leni];\n\t    P B1=v[j][l],B2=v[j][(l+1)%lenj];\n\t    if(check(A1,A2,B1,B2))c[s1][s2]=c[s2][s1]=true;\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nbool check(const vector<Point>&l, const vector<Point>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tfor (int j = 0; j < r.size(); ++j) {\n\t\t\tLine ll(l[i], l[(i + 1) % l.size()]);\n\t\t\tLine rl(r[j], r[(j + 1) % r.size()]);\n\t\t\tif (is_ll2(ll, rl).size() >= 2)return true;\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(const int now, const vector<vector<int>>&edges, vector<int>colors,const int amax) {\n\tif (now == edges.size())return amax;\n\telse {\n\t\tint ans = 22;\n\t\tfor (int c = 0; c <= amax + 1; ++c) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < now; ++j) {\n\t\t\t\tif (edges[now][j] && colors[j] == c)ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcolors.push_back(c);\n\t\t\t\tans = min(ans, dfs(now + 1, edges, colors, max(amax, c)));\n\t\t\t\tcolors.pop_back();\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tmap<string, int>mp;\n\t\tvector<pair<int, vector<Point>>>ters;\n\t\tint id = 0;\n\t\twhile (N--) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.find(st) == mp.end())mp[st] = id++;\n\t\t\tvector<Point>ps;\n\t\t\twhile (1) {\n\t\t\t\tint x; cin >> x;\n\t\t\t\tif (x == -1)break;\n\t\t\t\tint y; cin >> y;\n\t\t\t\tPoint p(x, y);\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t\tters.push_back(make_pair(mp[st], ps));\n\t\t}\n\t\tvector<vector<int>>edges(id,vector<int>(id,false));\n\t\tfor (int i = 0; i < ters.size(); ++i) {\n\t\t\tfor (int j = i + 1; j < ters.size(); ++j) {\n\t\t\t\t\n\t\t\t\tif (check(ters[i].second, ters[j].second)) {\n\t\t\t\t\tedges[ters[i].first][ters[j].first] = true;\n\t\t\t\t\tedges[ters[j].first][ters[i].first] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>colors;\n\t\tint ans = dfs(0,edges,colors,-1);\n\t\tcout << ans+1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <map>\n#include <cmath>\n#include <complex>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\n\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\n\nbool intersectSS(const L &s, const L &t) \n{\t\t\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool isequal(P a, P b)\n{\n\treturn (fabs(a.real()-b.real()) < EPS && fabs(a.imag()-b.imag()) < EPS);\n}\n\nbool isOnePoint(const L &l, const L &m) \n{\n\tbool xp=false;\n\tfor(int i=0; i<2; i++)\n\tfor(int j=0; j<2; j++)\n\t{\n\t\tif(isequal(l[i],m[j])) xp=true;\n\t}\n\tif(!xp) return false;\n\tfor(int i=0; i<2; i++)\n\tfor(int j=0; j<2; j++)\n\t{\n\t\tif(isequal(l[i], m[j]))\n\t\t{\n\t\t\tif(!intersectSP(l, m[(j+1)%2])&&!intersectSP(m,l[(i+1)%2])) return true;\n\t\t\telse return false;\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\ntypedef vector<L> Terr;\ntypedef vector<Terr> Cont;\ntypedef vector<int> Adj;\n\nbool isAdj(Cont& a, Cont& b)\n{\n\tfor(int i=0; i<a.size(); i++)\n\tfor(int j=0; j<b.size(); j++)\n\t{\n\t\tfor(int k=0; k<a[i].size(); k++)\n\t\tfor(int l=0; l<b[j].size(); l++)\n\t\t{\n\t\t\tif(intersectSS(a[i][k],b[j][l]))\n\t\t\t{\n\t\t\t\tif(!isOnePoint(a[i][k], b[j][l])) return true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn false;\n}\n\nint cr[10];\nCont cont[10];\nAdj adj[10];\n\nbool isconf(int p)\n{\n\tfor(int i=0; i<adj[p].size(); i++)\n\t{\n\t\tif(cr[adj[p][i]]==cr[p]) return true;\n\t}\n\t\n\treturn false;\n}\n\nbool paint(int p, int c, int cnt)\n{\n\tif(p==cnt) return true;\n\t\n\tfor(int i=1; i<=c; i++)\n\t{\n\t\tcr[p]=i;\n\t\tif(!isconf(p)) if(paint(p+1, c, cnt)) return true;\n\t\tcr[p]=0;\n\t}\n\t\n\treturn false;\n}\n\nint main()\n{\n\tint N;\n\twhile(scanf(\"%d\", &N) , N)\n\t{\n\t\tfor(int i=0; i<10; i++)\n\t\t{\n\t\t\tcont[i].clear();\n\t\t\tadj[i].clear();\n\t\t\tcr[i]=0;\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tmap<string, int> d;\n\t\twhile(N--)\n\t\t{\n\t\t\tint id;\n\t\t\tchar n[15];\n\t\t\tscanf(\"%s\", n);\n\t\t\tmap<string, int>::iterator it=d.find(string(n));\n\t\t\tif(it != d.end())\n\t\t\t{\n\t\t\t\tid=it->second;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tid=cnt;\n\t\t\t\td.insert(make_pair(string(n), cnt));\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tint x,y;\n\t\t\tTerr t;\n\t\t\tvector<P> pt;\n\t\t\twhile(scanf(\"%d\", &x), x!=-1)\n\t\t\t{\n\t\t\t\tscanf(\"%d\", &y);\n\t\t\t\tpt.push_back(P(x,y));\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<pt.size(); i++)\n\t\t\t\tt.push_back(L(pt[i], pt[(i+1)%pt.size()]));\n\t\t\t\t\n\t\t\tcont[id].push_back(t);\n\t\t}\n\t\t\n\t\tfor(int i=0; i<cnt; i++)\n\t\tfor(int j=i+1; j<cnt; j++)\n\t\t{\n\t\t\tif(isAdj(cont[i], cont[j]))\n\t\t\t{\n\t\t\t\tadj[i].push_back(j);\n\t\t\t\tadj[j].push_back(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1; ; i++)\n\t\t{\n\t\t\tif(paint(0, i, cnt))\n\t\t\t{\n\t\t\t\tprintf(\"%d\\n\", i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\ninline int sgn(const ll& r){ return (r > 0) - (r < 0);}\n\nusing P=complex<ll>;\nusing L=struct{P s,t;};\n\nnamespace std{\n\tbool operator >  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)>0:sgn(imag(a-b))>0;}\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\ninline ll dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline ll det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\ninline bool cross(L a,L b){\n\tif(det(P(0,0),a.t-a.s,b.t-b.s)!=0) return false;\n\tconst int sa=ccw(a.s,a.t,b.s)|ccw(a.s,b.t,b.t);\n\tconst int sb=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif((sa&ON)==0) return false;\n\tif((sb&ON)==0) return false;\n\t\n\tusing state=tuple<P,int>;\n\n\tbool ok=true;\n\tvector<state> ary={state(a.s,0),state(a.t,0),state(b.s,1),state(b.t,1)};\n\tsort(_all(ary));\n\tif(get<1>(ary[0])==get<1>(ary[1])) return false;\n\tif(get<1>(ary[2])==get<1>(ary[3])) return false;\n\tif(get<0>(ary[1])==get<0>(ary[2])) return false;\n\t//cout << a.s << \" \" << a.t << \" \" << b.s << \" \" << b.t << endl;\n\treturn true;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tset<L> pol[110];\n\t\tmap<string,vector<int>> conv;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin >> s; \n\t\t\tconv[s].push_back(i);\n\n\t\t\tint x[110],y[110],m=0;\n\n\t\t\twhile(1){\n\t\t\t\tcin >> x[m];\n\t\t\t\tif(x[m]==-1) break;\n\t\t\t\tcin >> y[m++];\n\t\t\t}\n\n\t\t\trep(j,m){\n\t\t\t\tP a=P(x[j],y[j]);\n\t\t\t\tP b=P(x[(j+1)%m],y[(j+1)%m]);\n\t\t\t\tif(a>b) swap(a,b);\n\t\t\t\tpol[i].insert(L({a,b})); \n\t\t\t}\n\t\t}\n\n\t\tvector<string> ary;\n\t\tfor(auto &it:conv) ary.push_back(it.first);\n\t\tconst int m=ary.size();\n\n\t\tbool graph[110][110];\n\t\tclr(graph,0);\n\t\t\n\t\trep(i,n)rep(j,i){\n\t\t\tbool ok=false;\n\t\t\tfor(auto &line:pol[i]) for(auto &line2:pol[j]){\n\t\t\t\tif(ok) continue;\n\t\t\t\tif(cross(line,line2)) ok=true;\n\t\t\t}\n\t\t\tif(ok) graph[i][j]=graph[j][i]=true;\n\t\t}\n\n\t\tint index[10];\n\t\tiota(index,index+m,0);\n\n\t\tint ans=10;\n\n\t\tdo{\n\t\t\tint color[110];\n\t\t\tclr(color,-1);\n\n\t\t\trep(i,m){\n\t\t\t\tstring s= ary[i];\n\t\t\t\tset<int> used;\n\t\t\t\tfor(auto &v:conv[s]) rep(v2,n) if(graph[v][v2]) used.insert(color[v2]);\n\t\t\t\tint cmax=0;\n\t\t\t\twhile(used.find(cmax)!=used.end()) cmax++;\n\t\t\t\tfor(auto &v:conv[s]) color[v]=cmax;\n\t\t\t}\n\n\t\t\tint num=0;\n\t\t\trep(i,n) chmax(num,color[i]);\n\t\t\tchmin(ans,num+1);\n\n\t\t}while(next_permutation(index,index+m));\n\n\t\t// rep(i,n){\n\t\t// \trep(j,n) cout << graph[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\n\t\t// const P a=P(10,50),b=P(20,40),c=P(35,25);\n\t\t// cout << cross(L({a,b}),L({a,c})) << endl;\n\t\t//for(auto &line:pol[2]) for(auto &line2:pol[3]) cout << cross(line,line2) << endl;\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num, const int &clique){\n  if(num >= ans || num>=m)return;\n  if(d==m){ ans = num; return; }\n  if((clique>>d)&1)dfs(d+1,num,clique);\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,m){\n      if(i<d || (clique>>i)&1){\n\tif(g[d][i])use[cols[i]] = 1;\n      }\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num,clique);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1,clique);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    int clique = 1, s = 1;\n    rep(bit,1<<m){\n      int p = __builtin_popcount(bit);\n      if(p<=s)continue;\n      bool f = true;\n      rep(i,m)rep(j,i){\n\tif( ((bit>>i)&1) && ((bit>>j)&1) && !g[i][j])f = false;\n      }\n      if(f){\n\tclique = bit; s = p;\n      }\n    }\n\n    cols.resize(m);\n    s = 0;\n    rep(i,m){\n      if((clique>>i)&1)cols[i] = s++;\n    }\n\n    ans = m;\n    dfs(0,s,clique);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nint n,x,y,ans=inf,num;\nvector<Segment> v[20];\nbool bo[20][20];\nint color[20];\n\nvoid init(){\n  for(int i=0;i<20;i++){\n    for(int j=0;j<20;j++)bo[i][j]=false;\n    v[i].clear();\n    color[i]=0;\n  }\n}\n\nbool touch(int a,int b){\n  for(int i=0;i<v[a].size();i++){\n    for(int j=0;j<v[b].size();j++){\n      Point A=v[a][i].p1,B=v[a][i].p2,\n\t    C=v[b][j].p1,D=v[b][j].p2;\n      if(isParallel(A-B,C-D)){\n\tint c1=ccw(C,D,A),c2=ccw(C,D,B);\n\tif(c1==0 && c2==0)return true;\n\tif(c1==0 && !(A==C) && !(A==D))return true;\n\tif(c2==0 && !(B==C) && !(B==D))return true;\n      }\n    }\n  }\n  return false;\n}\n\nvoid dfs(int index,int sum){\n  bool b[20];\n  for(int i=0;i<num;i++){\n    if(bo[index][i])b[color[i]]=true;\n  }\n  if(index==num-1){\n    for(int i=1;i<=sum+1;i++){\n      if(!b[i])ans=min(ans,max(i,sum));\n    }\n  }\n  else {\n    for(int i=1;i<=sum+1;i++){\n      if(!b[i]){\n\tcolor[index]=i;\n\tdfs(index+1,max(i,sum));\n\tcolor[index]=0;\n      }\n    }\n  }\n}\n\nint main()\n{\n\n  while(1){\n    cin>>n;\n    if(n==0)break;\n\n    init();\n\n    map<string,int> M;\n    num=0;\n    string s;\n\n    for(int i=0;i<n;i++){\n      cin>>s;\n      vector<Point> vp;\n      while(1){\n\tcin>>x;\n\tif(x==-1)break;\n\tcin>>y;\n\tvp.push_back(Point(x,y));\n      }\n      if(M.find(s)==M.end()){\n\tM[s]=num;\n\tfor(int j=0;j<vp.size();j++){\n\t  v[num].push_back(Segment(vp[j],vp[(j+1)%vp.size()]));\n\t}\t\t   \n\tnum++;\n      }\n      else {\n\tfor(int j=0;j<vp.size();j++){\n\t  v[M[s]].push_back(Segment(vp[j],vp[(j+1)%vp.size()]));\n\t}\n      }\n    }\n\n    for(int i=0;i<num;i++){\n      for(int j=0;j<num;j++){\n\tif(i==j)continue;\n\tif(!touch(i,j))continue;\n\tbo[i][j]=true;\n\tbo[j][i]=true;\n      }\n    }\n    ans=inf;\n    dfs(0,0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nstruct Polygon{\n    int id;\n    int V;\n    vector<pi> v;\n};\n\nmap<string,int> name2id;\nint C;\nPolygon read_p(){\n    Polygon ret;\n\n    string name;\n    cin >>name;\n\n    if(!name2id.count(name)) name2id[name] = C++;\n    ret.id = name2id[name];\n\n    int x,y;\n    while(1){\n        cin >>x;\n        if(x==-1) break;\n\n        cin >>y;\n        ret.v.pb({x,y});\n    }\n    ret.V = ret.v.size();\n    return ret;\n}\n\nbool share_edge(pi p1, pi p2, pi q1, pi q2){\n    if(p1>p2) swap(p1,p2);\n    if(q1>q2) swap(q1,q2);\n\n    int px = p2.fi-p1.fi, py = p2.se-p1.se;\n    int pg = __gcd(abs(px), abs(py));\n    px /= pg;\n    py /= pg;\n\n    int qx = q2.fi-q1.fi, qy = q2.se-q1.se;\n    int qg = __gcd(abs(qx), abs(qy));\n    qx /= qg;\n    qy /= qg;\n\n    if(px!=qx || py!=qy) return false;\n\n    if(px == 0){\n        if(p1.fi != q1.fi) return false;\n        return (p1<q1 && q1<p2) || (q1<p1 && p1<q2) ;\n    }\n    else{\n        pi tp(p1);\n        int D = p1.fi/px;\n        tp.fi -= px*D;\n        tp.se -= py*D;\n\n        pi tq(p1);\n        D = q1.fi/qx;\n        tq.fi -= qx*D;\n        tq.se -= qy*D;\n        if(tp != tq) return false;\n\n        return (p1<q1 && q1<p2) || (q1<p1 && p1<q2) ;\n    }\n}\n\nbool check(const Polygon &p, const Polygon &q){\n    rep(i,p.V)rep(j,q.V){\n        if(share_edge(p.v[i], p.v[(i+1)%p.V], q.v[j], q.v[(j+1)%q.V])) return true;\n    }\n    return false;\n}\n\nint main(){\n    int pw[11]={};\n    pw[0] = 1;\n    for(int i=1; i<=10; ++i) pw[i] = pw[i-1]*3;\n\n    int n;\n    while(cin >>n,n){\n        name2id.clear();\n        C = 0;\n\n        vector<Polygon> p(n);\n        rep(i,n) p[i] = read_p();\n\n        vector<vector<bool>> adj(C,vector<bool>(C));\n        rep(i,n)rep(j,i){\n            if(check(p[i],p[j])){\n                adj[p[i].id][p[j].id] = true;\n                adj[p[j].id][p[i].id] = true;\n            }\n        }\n\n        int ans = 4;\n        rep(mask,pw[C]){\n            int t = mask;\n            vector<int> col(C);\n            set<int> s;\n            rep(i,C){\n                col[i] = t%3;\n                t/=3;\n                s.insert(col[i]);\n            }\n\n            bool ok = true;\n            rep(i,C)rep(j,C)if(adj[i][j]){\n                if(col[i]==col[j]) ok = false;\n            }\n            if(ok) ans = min(ans,(int)s.size());\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n\nlong long power(long long a, long long n) {\n    long long res = 1;\n    while (n > 0) {\n        if (n & 1) res = res * a;\n        a = a * a;\n        n >>= 1;\n    }\n    return res;\n}\n\nint Chromatic(vector<vector<int> > graph) {\n    int n = graph.size();\n    vector<int> G(n, 0);\n    for (int i = 0; i < n; ++i) {\n        G[i] |= (1<<i);\n        for (int j = 0; j < n; ++j)\n            if (graph[i][j])\n                G[i] |= (1<<j);\n    }\n    vector<int> I(1<<n);\n    I[0] = 1;\n    for (int s = 1; s < (1<<n); ++s) {\n        //int v = __builtin_ctz(s);\n\t\tint v = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (s & (1<<i)) break;\n\t\t\t++v;\n\t\t}\n        I[s] = I[s^(1<<v)] + I[s&~G[v]];\n    }\n    int lo = 0, up = n, med;\n    while (up - lo > 1) {\n        med = (up + lo) >> 1;\n        int g = 0;\n        for (int s = 0; s < (1<<n); ++s) {\n\t\t\tint v = 0;\n\t\t\tfor (int i = 0; i < n; ++i) if (s & (1<<i)) ++v;\n            if (v & 1) g -= power(I[s], med);\n            else g += power(I[s], med);\n        }\n        if (g != 0) up = med;\n        else lo = med;\n    }\n    return up;\n}\n\ntypedef double DD;\n\nconst DD INF = 1LL<<60;\nconst DD EPS = 1e-10;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\nPoint operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nDD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nDD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nDD norm(const Point &p) {return dot(p, p);}\nDD abs(const Point &p) {return sqrt(dot(p, p));}\nDD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n    friend ostream& operator << (ostream &s, const Line &l) {return s << '{' << l[0] << \", \" << l[1] << '}';}\n};\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\n\nint n;\nmap<string, vector<vector<Point> > > ma;\n\nbool issame(Line l, Line s) {\n\tfor (int it = 0; it < 2; ++it) {\n\t\tif (it == 1) swap(l, s);\n\t\tif ( !eq(l[0], s[0]) && !eq(l[0], s[1]) && ccw(s[0], s[1], l[0]) == 0 ) return true;\n\t\tif ( !eq(l[1], s[0]) && !eq(l[1], s[1]) && ccw(s[0], s[1], l[1]) == 0 ) return true;\n\t\tif ( eq(l[0], s[0]) && eq(l[1], s[1]) ) return true;\n\t\tif ( eq(l[0], s[1]) && eq(l[1], s[0]) ) return true;\n\t}\n\treturn false;\n}\n\nint main() {\n    //freopen( \"/Users/macuser/Dropbox/Contest/input.in\", \"r\", stdin );\n    \n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tma.clear();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tstring str; cin >> str;\n\t\t\tvector<Point> vp;\n\t\t\tint a, b;\n\t\t\twhile (cin >> a) {\n\t\t\t\tif (a == -1) break;\n\t\t\t\tcin >> b;\n\t\t\t\tPoint p(a, b);\n\t\t\t\tvp.push_back(p);\n\t\t\t}\n\t\t\tma[str].push_back(vp);\n\t\t}\n\t\tint V = ma.size();\n\t\tvector<vector<int> > G(V, vector<int>(V, 0));\n\n\t\t//COUT(ma);\n\t\t\n\t\tint i = 0, j = 0;\n\t\tfor (map<string, vector<vector<Point> > >::iterator it1 = ma.begin(); it1 != ma.end(); ++it1) {\n\t\t\tj = 0;\n\t\t\tfor (map<string, vector<vector<Point> > >::iterator it2 = ma.begin(); it2 != ma.end(); ++it2) {\n\t\t\t\tif (i == j) { ++j; continue; }\n\t\t\t\tbool adj = false;\n\t\t\t\t\n\t\t\t\tfor (int x = 0; x < (it1->second).size(); ++x) for (int y = 0; y < (it2->second).size(); ++y) {\n\t\t\t\t\tvector<Point> vp1 = (it1->second)[x], vp2 = (it2->second)[y];\n\t\t\t\t\tfor (int p = 0; p < vp1.size(); ++p) for (int q = 0; q < vp2.size(); ++q) {\n\t\t\t\t\t\t//cout << p << \", \" << q << endl;\n\t\t\t\t\t\tLine l(vp1[p], vp1[ (p+1)%vp1.size() ]);\n\t\t\t\t\t\tLine m(vp2[q], vp2[ (q+1)%vp2.size() ]);\n\t\t\t\t\t\tif (issame(l, m)) adj = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (adj) G[i][j] = true;\n\t\t\t\t++j;\n\t\t\t}\n\t\t\t++i;\n\t\t}\n\n\t\t//COUT(G);\n\n\t\tint res = Chromatic(G);\n\t\tcout << res << endl;\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nconst int mod = 10009;\ninline int modpow(int n, int m){\n\tint res = 1;\n\tfor(; m; m >>= 1){\n\t\tif(m & 1) res = res * n % mod;\n\t\tn = n * n % mod;\n\t}\n\treturn res;\n}\nint n, e[22][22];\nint I[1 << 22], N[22];\nbool kcolor(int k){\n\tll ans = 0;\n\trep(i, 1 << n){\n\t\tif(__builtin_popcount(i) % 2) ans -= modpow(I[i], k);\n\t\telse ans += modpow(I[i], k);\n\t}\n\tans = (ans % mod + mod) %  mod;\n\t \n\treturn ans;\n}\nint color(){\n\trep(i, n){\n\t\tint bit = 1 << i;\n\t\trep(j, n) if(e[i][j]) bit |= 1 << j;\n\t\tN[i] = bit;\n\t}\n\trep(i, 1 << n) I[i] = 0;\n\tI[0] = 1;\n\tfor(int i = 1; i < 1 << n; i++){\n\t\tint v = 0;\n\t\tfor(; !(i & 1 << v); v++);\n\t\tI[i] = I[i - (1 << v)] + I[i & ~N[v]];\n\t\tif(I[i] > mod) I[i] -= mod;\n\t}\n\t \n\tint lo = 0, hi = n, mid;\n\twhile(lo + 1 < hi){\n\t\tmid = (lo + hi) / 2;\n\t\tif(kcolor(mid)) hi = mid;\n\t\telse lo = mid;\n\t}\n\treturn hi;\n}\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\n\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\nbool overlap(const L &a, const L &b){\n\tif(abs(cross(a[1] - a[0], b[1] - b[0])) > EPS) return 0;\n\trep(i, 2){\n\t\tif(a[0] == b[i]  && a[1] == b[1 - i]) return 1;\n\t\tif(ccw(b[i], a[0], a[1]) == 2) return 1;\n\t\tif(ccw(a[i], b[0], b[1]) == 2) return 1;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tint m;\n\twhile(cin >> m, m){\n\t\tvector<G> gs;\n\t\tstring name[100];\n\t\tvector<string> s;\n\t\trep(i, m){\n\t\t\tcin >> name[i];\n\t\t\ts.pb(name[i]);\n\t\t\tint x, y;\n\t\t\tG g;\n\t\t\twhile(cin >> x, x >= 0){\n\t\t\t\tcin >> y;\n\t\t\t\tg.pb(P(x, y));\n\t\t\t}\n\t\t\tgs.pb(g);\n\t\t}\n\t\tmemset(e, 0, sizeof(e));\n\t\tsort(all(s));\n\t\ts.erase(unique(all(s)), s.end());\n\t\tn = s.size();\n\t\t\n\t\trep(i, m) rep(j, i) if(name[i] != name[j]){\n\t\t\trep(k, gs[i].size()) rep(l, gs[j].size()){\n\t\t\t\tL a(gs[i][k], gs[i][(k + 1) % gs[i].size()]), b(gs[j][l], gs[j][(l + 1) % gs[j].size()]);\n\t\t\t\tif(overlap(a, b)){\n\t\t\t\t\tint p = lower_bound(all(s), name[i]) - s.begin();\n\t\t\t\t\tint q = lower_bound(all(s), name[j]) - s.begin();\n\t\t\t\t\te[p][q] = e[q][p] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << color() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nconstexpr double EPS = (1e-10);\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point() {}\n    Point(double x, double y) : x{x}, y{y} {}\n\n    Point operator - (const Point& p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble dot(const Point& a, const Point& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point& p)\n{\n    return dot(p, p);\n}\n\nconstexpr int COUNTER_CLOCKWISE = +1;\nconstexpr int CLOCKWISE         = -1;\nconstexpr int ONLINE_BACK       = +2;\nconstexpr int ONLINE_FRONT      = -2;\nconstexpr int ON_SEGMENT        = +0;\nusing Vector = Point;\n\nint ccw(const Point& p0, const Point& p1, const Point& p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment() {}\n    Segment(Point s, Point t) : s{s}, t{t} {}\n};\n\nbool parallel(const Segment& s1, const Segment& s2)\n{\n    Vector a = s1.t - s1.s;\n    Vector b = s2.t - s2.s;    \n    return equals(cross(a, b), 0);\n}\n\nusing ll = long long;\nconstexpr int MAX = 10;\n\nbool con[MAX][MAX];\n\ninline int mod_pow(ll x, int n, int mod)\n{\n    if (n == 0) return 1;\n    int res = mod_pow(x * x % mod, n / 2, mod);\n    if (n & 1) res = res * x % mod;\n    return res;\n}\n\nint I[1 << MAX], bn[1 << MAX];\n\nbool c(int n, int k)\n{\n    ll g = 0;\n    constexpr int MOD = 10009;    \n    for (int i = 0; i < (1 << n); i++) {\n        if (bn[i] % 2 == 0) {\n            g += mod_pow(I[i], k, MOD);\n        } else {\n            g -= mod_pow(I[i], k, MOD);\n        }\n    }\n    return (g % MOD + MOD) % MOD != 0;\n}\n\nint paint_color_num(int n)\n{\n    vector<int> N(1 << n);\n    for (int i = 0; i < n; i++) {\n        int bit = (1 << i);\n        for (int j = 0; j < n; j++) {\n            if (i != j && con[i][j]) {\n                bit |= (1 << j);\n            }\n        }\n        N[i] = bit;\n    }\n        \n    memset(I, 0, sizeof(I));\n    I[0] = 1;\n    for (int S = 1; S < (1 << n); S++) {\n        bn[S] = __builtin_popcount(S);\n        int v = 0;\n        while (!(S >> v & 1)) v++;\n        I[S] = I[S - (1 << v)] + I[S & ~N[v]];\n    }\n            \n    int L = 0, R = n;\n    while (R - L > 1) {\n        int mid = (L + R) / 2;\n        if (c(n, mid)) {\n            R = mid;\n        } else {\n            L = mid;\n        }           \n    }\n    return R;\n}\n\nusing Polygon = vector<Point>;\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\n\nbool check(const Polygon& p1, const Polygon& p2)\n{\n    int N = p1.size(), M = p2.size();    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            Segment s1{curr(p1, i), next(p1, i)};\n            Segment s2{curr(p2, j), next(p2, j)};\n            if (!parallel(s1, s2)) continue;\n            if ((ccw(s1.s, s1.t, s2.s) == 0 && ccw(s1.s, s1.t, s2.t) == 0) ||\n                (ccw(s2.s, s2.t, s1.s) == 0 && ccw(s2.s, s2.t, s1.t) == 0)) {\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    \n    map<string, int> num;\n    vector<int> c(N);\n    vector<Polygon> pgs(N);\n    \n    int idx = 0;\n    string country;\n    for (int i = 0; i < N; i++) {\n        cin >> country;\n        if (num.count(country) == 0) {\n            num[country] = idx++;\n        }\n        \n        c[i] = num[country];\n        \n        double x, y;\n        Polygon pg;\n        while (cin >> x, x != -1) {\n            cin >> y;\n            pg.emplace_back(x, y);\n        }\n        pgs[i] = pg;\n    }\n\n    memset(con, 0, sizeof(con));\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (c[i] == c[j]) continue;\n            \n            if (check(pgs[i], pgs[j])) {\n                con[c[i]][c[j]] = con[c[i]][c[j]] = 1;\n            }\n        }\n    }\n\n    cout << paint_color_num(idx) << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npii operator-(const pii &a,const pii &b){\n    return make_pair(a.first-b.first,a.second-b.second);\n}\n\nvoid solve(int n){\n    map<string,int> t;\n    vector<vector<int>> vs;\n    vector<vector<pii>> ps;\n    int cnt=0;\n    rep(i,0,n){\n        string str;\n        cin >> str;\n        if(t.find(str)==t.end()){\n            t[str]=cnt;\n            vs.push_back(vector<int>());\n            ps.push_back(vector<pii>());\n            ++cnt;\n        }\n        int idx=t[str];\n        vs[idx].push_back(i);\n        while(true){\n            int x,y;\n            cin >> x;\n            if(x==-1) break;\n            cin >> y;\n            ps[idx].push_back(make_pair(x,y));\n        }\n    }\n\n    auto cross=[](pii &a,pii &b){\n        return a.first*b.second-a.second*b.first;\n    };\n\n    vector<vector<int>> graph(cnt);\n    rep(i,0,cnt) rep(j,0,i){\n        if([&](){\n            rep(i_,0,ps[i].size()) rep(j_,0,ps[j].size()){\n                pii &p1=ps[i][i_],&p2=ps[i][(i_+1)%ps[i].size()];\n                pii &q1=ps[j][j_],&q2=ps[j][(j_+1)%ps[j].size()];\n                pii a=p1-p2,b=q1-q2;\n                pii c=p1-q2,d=p2-q1;\n                if(cross(a,b)) continue;\n                if(cross(c,d)) continue;\n                if(a.first and (max(p1.first,p2.first)==min(q1.first,q2.first) or min(p1.first,p2.first)==max(q1.first,q2.first))) continue;\n                if(a.second and (max(p1.second,p2.second)==min(q1.second,q2.second) or min(p1.second,p2.second)==max(q1.second,q2.second))) continue;\n                return true;\n            }\n            return false;\n        }()){\n            graph[i].push_back(j);\n            graph[j].push_back(i);\n        }\n    }\n\n    {\n        bool f=true;\n        rep(i,0,cnt) if(graph[i].size()){\n            f=false;\n            break;\n        }\n        if(f){\n            cout << 1 << endl;\n            return;\n        }\n    }\n\n    function<bool(int,vector<int>&,int)> dfs=[&](int k,vector<int> &color,int u){\n        for(int v:graph[u]){\n            if(color[v]){\n                if(color[v]==color[u]) return false;\n                continue;\n            }\n            bool ok=false;\n            rep(i,1,k+1){\n                if(i==color[u]) continue;\n                color[v]=i;\n                ok|=dfs(k,color,v);\n            }\n            color[v]=0;\n            if(!ok) return false;\n        }\n        return true;\n    };\n\n    vector<int> color(cnt);\n    color[0]=1;\n    if(dfs(2,color,0)){\n        cout << 2 << endl;\n        return;\n    }\n    fill(color.begin(),color.end(),0);\n    color[0]=1;\n    if(dfs(3,color,0)) cout << 3 << endl;\n    else cout << 4 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<map>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n  \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n  \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n  \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  \n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\ntypedef point Vector;\ntypedef pair<point,point> Line;\ntypedef vector<point> Polygon;\n\nclass Segment{\npublic:\n  point p1, p2;\n  Segment(){}\n  Segment(point p1,point p2):p1(p1), p2(p2){}\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint is_parallel(point a1, point a2, point b1, point b2) {\n  return cross(a1-a2, b1-b2)==0.0 ;\n}\n\nint isOnSegment(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n    (dot(b-a, c-a) > -EPS) &&\n    (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  \n  if(cross(a1-a2,b1-b2)==0){\n    return isOnSegment(a1,a2,b1) || isOnSegment(a1,a2,b2)\n      || isOnSegment(b1,b2,a1) || isOnSegment(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n      ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nvector<int>g[11];\nint used[11];\n\nvoid dfs(int v){\n  \n  bool fg[11];\n  fill(fg,fg+11,false);\n  for(int i=0;i<g[v].size();i++){\n    fg[used[g[v][i]]]=true;\n  }\n  \n  for(int i=1;i<11;i++){\n    if(!fg[i]){\n      used[v]=i;\n      break;\n    }\n  }\n\n  for(int i=0;i<g[v].size();i++){\n    if(used[g[v][i]]>0)continue;\n    dfs(g[v][i]);\n  }\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    string s;\n    vector<point>pol[11];\n    map<string,int>id;\n    int sz=0;\n\n    for(int i=0;i<n;i++){\n      cin >> s;\n      if(!id.count(s))id[s]=sz++;\n      point in;\n      while(true){\n\tcin >> in.x;\n\tif(in.x<0)break;\n\tcin >> in.y;\n\tpol[id[s]].push_back(in);\n      }\n    }\n\n    for(int i=0;i<11;i++)g[i].clear();\n    \n    for(int i=0;i<sz;i++){\n      for(int j=i+1;j<sz;j++){\n\tfor(int k=0;k<pol[i].size();k++){\n\t  for(int l=0;l<pol[j].size();l++){\n\t    point cri=curr(pol[i],k),nxi=next(pol[i],k);\n\t    point crj=curr(pol[j],l),nxj=next(pol[j],l);\n\n\t    if(is_intersected_ls(cri,nxi,crj,nxj)){\n\t      if(is_parallel(cri,nxi,crj,nxj)){\n\t\tif(cri==crj || nxi==nxj)continue;\n\t\tg[i].push_back(j);\n\t\tg[j].push_back(i);\n\t\tgoto end;\n\t      }\n\t    }\n\t  }\n\t}\n      end:;\n      }\n    }\n\n    fill(used,used+11,0);\n    dfs(0);\n\n    int mx=0;\n    for(int i=0;i<11;i++)mx=max(mx,used[i]);   \n    cout << mx << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 20\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - CCW - begin\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - CCW - end\n\n// Library - intersect - begin\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// Library - intersect - end\n\n// Library - Dent - begin\n\n\nint pow(int x,int n)\n{\n  int res = 1;\n  for(;n;n>>=1)\n    {\n      if(n&1)res = res*x;\n      x = x * x;\n    }\n  return res;\n}\n\nint chromatic_number(vector<vector<int> > &M)\n{\n  int n = M.size();\n  vector<int> F(n);\n  rep(i,n)\n    {\n      F[i] |= 1<<i;\n      rep(j,n)\n\t{\n\t  if(M[i][j])F[i] |= 1 << j;\n\t}\n    }\n\n  vector<int> I(1<<n);\n  I[0] = 1;\n  for(int i=1;i<(1<<n);i++)\n    {\n      int v = __builtin_ctz(i);\n      I[i] = I[i^(1<<v)] + I[i & ~F[v]];\n    }\n  int low = 0,high = n;\n  while(low+1 < high)\n    {\n      int k = (low+high)/2,g = 0;\n      rep(i,(1<<n))\n\t{\n\t  if(__builtin_popcount(i) & 1)\n\t    {\n\t      g -= pow(I[i],k);\n\t    }\n\t  else\n\t    {\n\t      g += pow(I[i],k);\n\t    }\n\t}\n      if(g != 0)high = k;\n      else low = k;\n    }\n  return high;\n}\n\n// Library - Dent - end\n\nstruct P\n{\n  Point p;\n  int type;\n  P(Point p=Point(),int type=IINF):p(p),type(type){}\n  bool operator < (const P& a)const\n  {\n    if(!(p == a.p))return p < a.p;\n    return type < a.type;\n  }\n};\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool intersect(Segment seg1,Segment seg2)\n{\n  if(!isParallel(seg1,seg2))return false;\n\n  double dist = distanceSS(seg1,seg2);\n\n  if(!equals(dist,0.0))return false;\n\n  vector<P> vec;\n  \n  vec.push_back(P(seg1.p1,0));\n  vec.push_back(P(seg1.p2,0));\n  vec.push_back(P(seg2.p1,1));\n  vec.push_back(P(seg2.p2,1));\n  sort(vec.begin(),vec.end());\n  if(vec[1].p == vec[2].p)return false;\n  \n  return true;\n\n}\n\nvector<int> G[MAX];\nint color[MAX],SIZE,ans;\n\nvoid rec(int upper,int state)\n{\n  if(upper >= ans)\n    {\n      return;\n    }\n\n  if(state == (1<<SIZE)-1)\n    {\n      ans = min(ans,upper);\n      return;\n    }\n\n  int OK = ((1<<SIZE)-1) & (~state);\n  while(OK)\n    {\n      int use = OK & -OK;\n      OK -= use;\n      int i = (int)log2(use);\n      if((state >> i) & 1)continue;\n\n      int x = 0;\n      rep(j,G[i].size())\n\t{\n\t  if(color[G[i][j]] == -1)continue;\n\t  x |= (1<<color[G[i][j]]);\n\t}\n\n      int OK2 = ((1<<(upper+1))-1) & (~x);\n      \n      while(OK2)\n\t{\n\t  int use2 = OK2 & -OK2;\n\t  OK2 -= use2;\n\t  int c = log2(use2);\n\t  int cost = (upper == c);\n\t  color[i] = c;\n\t  rec(upper+cost,state|(1<<i));\n\t  color[i] = -1;\n\n\t}\n      return;\n    }\n\n}\n\nvoid compute()\n{\n  ans = IINF;\n  rep(i,SIZE)color[i] = -1;\n  rec(0,0);\n  cout << ans << endl;\n}\n\nint main()\n{\n\n  int N;\n  while(cin >> N,N)\n    {\n      map<string,int> Index;\n      int dex = 0;\n      string country[N];\n      vector<Point> coor[N];\n      int index[N];\n\n      rep(i,N)\n\t{\n\t  cin >> country[i];\n\t  if(Index.find(country[i]) == Index.end())Index[country[i]] = dex++;\n\t  int x,y;\n\t  while(cin >> x, x != -1)\n\t    {\n\t      cin >> y;\n\t      coor[i].push_back(Point(x,y));\n\t    }\n\t}\n\n      rep(i,N)\n\t{\n\t  index[i] = Index[country[i]];\n\t  //cout << \"index[\" << i << \"] = \" << index[i] << endl;\n\t}\n      int n = Index.size();\n      rep(i,n)G[i].clear();\n\n      set<ii> used;\n\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\t \n\t      if(index[i] == index[j])continue;\n\t      if(used.find(ii(index[i],index[j])) != used.end())continue;\n\n\t      vector<Point> vec;\n\t      bool check = false;\n\t      \n\t      rep(k,coor[i].size())\n\t\t{\n\t\t  Segment seg1 = Segment(coor[i][k],coor[i][(k+1)%coor[i].size()]);\n\t\t  rep(l,coor[j].size())\n\t\t    {\n\t\t      Segment seg2 = Segment(coor[j][l],coor[j][(l+1)%coor[j].size()]);\n\n\t\t      if(intersect(seg1,seg2))\n\t\t\t{\n\t\t\t  check = true;\n\t\t\t  goto Skip;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    Skip:;\t      \n\t      if(check)\n\t\t{\n\t\t  used.insert(ii(index[i],index[j]));\n\t\t  used.insert(ii(index[j],index[i]));\n\t\t  G[index[i]].push_back(index[j]);\n\t\t  G[index[j]].push_back(index[i]);\n\t\t}\n\t    }\n\t}\n\n      SIZE = n;\n\n      compute();\n\n      /*\n      cout << \"Graph === \" << endl;\n      rep(i,n)\n\t{\n\t  cout << \"i = \" << i << endl;\n\t  rep(j,G[i].size())\n\t    {\n\t      cout << G[i][j];\n\t    }\n\t  cout << endl;\n\t}\n      */\n      /*\n      vector<vector<int> > M(n,vector<int>(n,0));\n      //cout << \"n = \" << n << endl;\n      rep(i,n)\n\t{\n\t  rep(j,G[i].size())\n\t    {\n\t      int to = G[i][j];\n\t      M[i][to] = M[to][i] = 1;\n\t    }\n\t}      \n      //cout << \"-----------222----\" << endl;\n      cout << chromatic_number(M) << endl;\n      */\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nint isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\n\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  return true;  \n}\n\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n}\n\nvoid init(){\n  c=0;\n  mp.clear();\n  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int i=0;i<size;i++)\n        G[id].push_back((Segment){t[i],t[(i+1)%size]-t[i]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\nint chromatic(vector< vector<int> > &G){\n  int n=G.size();\n  if(n==0) return 0;\n  assert(n<=30);\n  \n  vector<int> es(n,0);  \n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      es[i]|=G[i][j]<<j;\n  \n  int s=1<<n;\n  vector<int> dp(s);\n  for(int b=0;b<s;b++)\n    dp[b]=((n-__builtin_popcount(b))&1?-1:1);\n\n  auto calc=\n    [&](const int MOD){\n      vector<int> res(s);\n      res[0]=1;\n      for(int b=1;b<s;b++){\n        int ctz=__builtin_ctz(b);\n        res[b]=res[b-(1<<ctz)]+res[(b-(1<<ctz))&~es[ctz]];\n        if(res[b]>=MOD) res[b]-=MOD;\n      }\n      return res;\n    };\n  \n  constexpr int MOD1 = 1077563119;\n  constexpr int MOD2 = 1e9+7;\n  vector<int> ind1=calc(MOD1);\n  vector<int> ind2=calc(MOD2);\n  \n  using ll = long long;\n  vector<int> dp1=dp,dp2=dp;\n  for(int i=1;i<n;i++){\n    ll sum1=0,sum2=0;\n    for(int b=0;b<s;b++){\n      dp1[b]=((ll)dp1[b]*ind1[b])%MOD1;\n      sum1+=dp1[b];\n      \n      dp2[b]=((ll)dp2[b]*ind2[b])%MOD2;\n      sum2+=dp2[b];\n    }\n    if(sum1%MOD1!=0) return i;\n    if(sum2%MOD2!=0) return i;\n  }\n  return n;\n}\n//END CUT HERE\n\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n\n//INSERT ABOVE HERE\n\n#define EPS (1e-10)\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool calc(Point a1,Point a2,Point b1,Point b2){\n  if(abs(cross(a2-a1,b1-a1))>EPS) return 0;\n  if(abs(cross(a2-a1,b2-a1))>EPS) return 0;\n  double ml=0;\n  ml=max(ml,abs(a1-a2));\n  ml=max(ml,abs(a1-b1));\n  ml=max(ml,abs(a1-b2));\n  ml=max(ml,abs(a2-b1));\n  ml=max(ml,abs(a2-b2));\n  ml=max(ml,abs(b1-b2));\n  return (ml+EPS<abs(a1-a2)+abs(b1-b2));\n}\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    vector<Polygon> p(n);\n    vector<string> name(n);\n    map<string,int> m;\n    for(int i=0;i<n;i++){\n      cin>>name[i];\n      if(!m.count(name[i])){\n        int k=m.size();\n        m[name[i]]=k;\n      }\n      int x,y;\n      while(cin>>x,~x){\n        cin>>y;\n        p[i].push_back(Point(x,y));\n      }\n    }\n    \n    vector<vector<int> > G(m.size(),vector<int>(m.size(),0));\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n        if(name[i]==name[j]) continue;\n        for(int k=0;k<(int)p[i].size();k++){\n          for(int l=0;l<(int)p[j].size();l++){\n            G[m[name[i]]][m[name[j]]]|=\n              calc(p[i][k],p[i][(k+1)%p[i].size()],\n                   p[j][l],p[j][(l+1)%p[j].size()]);\n            G[m[name[j]]][m[name[i]]]|=\n              calc(p[i][k],p[i][(k+1)%p[i].size()],\n                   p[j][l],p[j][(l+1)%p[j].size()]);\n          }\n        }\n      }\n    }\n    cout<<chromatic(G)<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2017/12/12\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1254\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\ntemplate< typename T = long long >\nT pow_mod(T x, T n, T mod)\n{\n  T ret = 1;\n  while(n > 0) {\n    if(n & 1) ret = 1LL * ret * x % mod;\n    x = 1LL * x * x % mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > 0) return +1;\n    if(cross(b, c) < 0) return -1;\n    if(dot(b, c) <= 0) return +2;\n    if(b.norm() <= c.norm()) return -2;\n    return 0;\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    // return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n    int a = ccw(s.a, s.b, t.a);\n    int b = ccw(s.a, s.b, t.b);\n    if(a == 2 && (b == -2 || b == 0)) return (true);\n    if(a == -2 && (b == 2 || b == 0)) return (true);\n    if(a == 0 && (b == 2 || b == 0 || b == -2)) return (true);\n    return (false);\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  { //OK\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  { //OK\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n};\n\nusing namespace Geometory;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, vector< Polygon > > data;\n    vector< string > nums;\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      int x, y;\n      Polygon polygon;\n      while(cin >> x, ~x) {\n        cin >> y;\n        polygon.push_back(Point(x, y));\n      }\n\n      nums.push_back(S);\n      data[S].push_back(polygon);\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n\n    int sz = (int) nums.size(), g[10][10] = {{}};\n    for(auto &ps : data) {\n      for(auto &qs : data) {\n        if(ps.first == qs.first) continue;\n        int u = lower_bound(begin(nums), end(nums), ps.first) - begin(nums);\n        int v = lower_bound(begin(nums), end(nums), qs.first) - begin(nums);\n        bool crossed = false;\n        for(auto &p : ps.second) {\n          for(auto &q : qs.second) {\n            for(int i = 0; i < p.size(); i++) {\n              for(int j = 0; j < q.size(); j++) {\n                if(Intersect(Segment(curr(p, i), next(p, i)), Segment(curr(q, j), next(q, j)))) {\n                  crossed = true;\n                }\n              }\n            }\n          }\n        }\n        g[u][v] = crossed;\n      }\n    }\n\n\n    vector< int > beet;\n    for(int i = 0; i < 1 << sz; i++) {\n      bool flag = true;\n      for(int j = 0; j < sz; j++) {\n        for(int k = 0; k < j; k++) {\n          if((i >> j) & 1 && (i >> k) & 1 && g[j][k]) flag = false;\n        }\n      }\n      if(flag) beet.push_back(i);\n    }\n\n    vector< int > dp(1 << sz, sz);\n    dp[0] = 0;\n    for(int i = 0; i < 1 << sz; i++) {\n      for(auto &j : beet) dp[i | j] = min(dp[i | j], dp[i] + 1);\n    }\n    cout << dp.back() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = long double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nbool operator < (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() < r.imag() : l.real() < r.real();\n}\n\nbool operator > (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() > r.imag() : l.real() > r.real();\n}\n\nbool equals (P const& l, P const& r) {\n  return abs(l - r) <= EPS;\n}\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Polygon : public vector<P> {\n  vector<P>& g = *this;\n  Polygon() = default;\n  Polygon(vector<P> const& g) { this->g = g; }\n  P& operator[] (int x) { return vector<P>::operator[]((x + size()) % size()); }\n  Segment side(int x) { return std::move(Segment(this->operator[](x), this->operator[](x+1))); }\n  Segment backside(int x) { return std::move(Segment(this->operator[](x), this->operator[](x-1))); }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = -2, online_front = +2, on_segment = 0\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > +EPS){ return ccw_result::counter_clockwise; }\n  if(cross(b, c) < -EPS){ return ccw_result::clockwise; }\n  if(dot(b, c) < 0) { return ccw_result::online_back; }\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return on_segment;\n}\n}\nusing namespace point_2d;\n\nbool adjacent(Polygon& x, Polygon& y) {\n  rep(i, x.size()) rep(j, y.size()) {\n    auto e = x.side(i), u = y.side(j);\n    {\n      int k = ccw(e[0], e[1], u[0]);\n      int l = ccw(e[0], e[1], u[1]);\n      if(k != counter_clockwise && k != clockwise && l != counter_clockwise && l != clockwise) {\n        Real mlen = abs(u[1]-u[0]) + abs(e[1]-e[0]);\n        if(mlen > abs(e[0]-u[0]) && mlen > abs(e[0]-u[1]) && mlen > abs(e[1]-u[0]) && mlen > abs(e[1]-u[1])) {\n          return true;\n        }\n      }\n    }\n    {\n      int k = ccw(u[0], u[1], e[0]);\n      int l = ccw(u[0], u[1], e[1]);\n      if(k != counter_clockwise && k != clockwise && l != counter_clockwise && l != clockwise) {\n        Real mlen = abs(u[1]-u[0]) + abs(e[1]-e[0]);\n        if(mlen > abs(e[0]-u[0]) && mlen > abs(e[0]-u[1]) && mlen > abs(e[1]-u[0]) && mlen > abs(e[1]-u[1])) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n}\n\nint ans, curr;\n\nvoid dfs(const vector<vector<int>>& g, int idx, vector<bool>& visited, vector<int>& color) {\n  set<int> st;\n  for(auto && next: g[idx]) {\n    if(color[next] != -1) { st.insert(color[next]); }\n  }\n  bool ok = 0;\n  rep(i, curr) {\n    if(!st.count(i)) {\n      ok = 1; color[idx] = i;\n      break;\n    }\n  }\n  if(!ok) { color[idx] = curr ++; }\n\n  for(auto && next: g[idx]) {\n    if(visited[next]) { continue; }\n    visited[next] = 1;\n    dfs(g, next, visited, color);\n  }\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    map<string, int> id;\n    vector<vector<Polygon>> gs(N);\n    int x, y;\n    int V = 0;\n    rep(_, N) {\n      string name; cin >> name;\n      if(id.find(name)==id.end()) id[name] = V++;\n      Polygon v;\n      while(cin >> x) {\n        if(x == -1) { break; }\n        cin >> y;\n        v.emplace_back(x, y);\n      }\n      gs[id[name]].push_back(v);\n    }\n\n    vector<vector<int>> gr(N);\n\n    rep(i, N) REP(j, i+1, N) {\n      auto f = [&]() {\n        for(auto& e: gs[i]) for(auto& u: gs[j]) {\n          if(adjacent(e, u)) {\n            gr[i].push_back(j);\n            gr[j].push_back(i);\n            return;}}}; f();\n    }\n    vector<bool> visited(N);\n    vector<int> color(N, -1);\n    ans = 0;\n\n    rep(i, N) {\n      if(visited[i]) { continue; }\n      visited[i] = 1;\n      curr = 0;\n      dfs(gr, i, visited, color);\n      maximize(ans, curr);\n    }\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\n\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// àÏ\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// OÏ\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// _cª¼üabãÉ é©È¢©\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2¼üÌ¼s»è\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2¼üÌ½s»è\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// _a,bðÊé¼üÆ_cÌÔÌ£\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// _a,bð[_Æ·éüªÆ_cÆÌ£\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð·»è\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // üªª½sÈêÍdÈÁÄ¢é±ÆÉ·é\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 1;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// a1,a2ð[_Æ·éüªÆb1,b2ð[_Æ·éüªÌð_vZ\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð·»è\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2ðÊé¼üÆb1,b2ðÊé¼üÌð_vZ\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n/*\n~üÆüªÌð·»è\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n    // üªªÉÜÜêéÆ«A±±ÌRgAEgðÍ¸¹Îtrue(ð·)ÆÈé\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// Op`ÌàÉ_ª é©Ç¤©\n// OÏÌ³ª·×Ä¯¶ÈçàÉ_ è\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// é`ÌÉ_ª¶Ý·é©Ç¤©\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)>0)\n        ||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// Op`ÌÊÏðÀW©çvZ\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// ^¦çê½~ÌÍÍàÉ_ª¶Ý·é©Ç¤©\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// ½p`ÌÊÏö®\ndouble calcPolygonArea(vector<P> p){\n\tdouble sum=0;\n\tfor(int i = 0; i < p.size(); i++)\n\t\tsum+=cross(p[i],p[(i+1)%(p.size())]);\n\treturn sum/2;\n}\n// 2xNgÔÌpx\n// a©çbÖ¶üèÅ½x©(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n\nstruct Polygon{\n    vector<Edge> edges;\n};\n\nint n;\nint idx;\nvector<Polygon> polygons;\nmap<string,int> nti;\nvector<int> G[10001];\nstring nodeStr[10001];\nint minColor=10000;\n\nvoid dfs(int rem,string s,char num){\n    if(rem==0){\n        // ®¬µ½¶ñÌhèûÅÊêé©·B\n        // ÊêéêÍAÅ¬hèðXVÅ«éÌÅ êÎAXV·é\n        bool ok=true;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < G[i].size(); j++){\n                // ¯¶m[h©AÊÌF\n                if(!(nodeStr[G[i][j]]==nodeStr[i]||s[nti[nodeStr[i]]]!=s[nti[nodeStr[G[i][j]]]])){\n                    ok=false;\n                    break;\n                }\n            }\n            if(!ok)break;\n        }\n        if(ok)\n            minColor=min(minColor,num-'0');\n\n    }\n    else{\n        for(char ch='0'; ch<=num; ch++){\n            if(ch==num)\n                dfs(rem-1,s+ch,num+1);\n            else\n                dfs(rem-1,s+ch,num);\n        }\n    }\n}\n\nint main(){\n\n    while(cin>>n&&n!=0){\n        minColor=10000;\n        for(int i = 0; i < n; i++)G[i].clear();\n        idx=0;\n        nti.clear();\n        polygons.clear();\n        for(int i = 0; i < n; i++){\n            Polygon pol;\n            string name;\n            cin>>name;\n            // idxðo^\n            if(nti.find(name)==nti.end())\n                nti[name]=idx++;\n            // ¼Oðo^\n            nodeStr[i]=name;\n            int x,y;\n            int px,py;\n            int sx,sy;\n            cin>>px>>py;\n            sx=px;sy=py;\n            while(cin>>x&&x!=-1){\n                cin>>y;\n                pol.edges.push_back(make_pair(P(px,py),P(x,y)));\n                px=x;\n                py=y;\n            }\n            // ÅãÌC\n            pol.edges.push_back(make_pair(P(px,py),P(sx,sy)));\n            polygons.push_back(pol);\n        }\n        // ×Úð`FbN\n        for(int i = 0; i < n; i++){\n            for(int j = i+1; j < n; j++){\n                if(i==2&&j==3){\n                 //   cout<<endl;\n                }\n                bool isAdj=false;\n                // »ê¼êÌÓª×ÚµÄ¢é©`FbN\n                for(int k = 0; k < polygons[i].edges.size(); k++){\n                    for(int l = 0; l < polygons[j].edges.size(); l++){\n                        Edge &e1=polygons[i].edges[k];\n                        Edge &e2=polygons[j].edges[l];\n                        // ½sÅ é©Ç¤©\n                        if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n                            &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n                            continue;\n                        double dist=0;\n                        // ¼ûæÁÄ¢é\n                        if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n                            dist=abs(e2.first-e2.second);\n                        }\n                        else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0)){\n                            dist=abs(e1.first-e1.second);\n                        }\n                        else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n                            // Ç¿çªüãÉ é©\n                            if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n                                dist=abs(e1.first-e2.first);\n                            else\n                                dist=abs(e1.second-e2.first);\n                        }\n                        else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n                            if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n                                dist=abs(e1.first-e2.second);\n                            else\n                                dist=abs(e1.second-e2.second);\n                        }\n                        else\n                            continue;\n                        if(!EQ(dist,0)){\n                            // ×ÚµÄ¢éÈçÎAedgeðø­\n                            isAdj=true;\n                            break;\n                        }\n                    }\n                    if(isAdj)break;\n                }\n                // draw edge\n                if(isAdj){\n                    G[i].push_back(j);\n                    G[j].push_back(i);\n                }\n            }\n        }\n        //for(int i = 0; i < n; i++){\n        //    cout<<i<<\" \";\n        //    for(int j = 0; j < G[i].size(); j++){\n        //        cout<<G[i][j]<<\" \";\n        //    }\n        //    cout<<endl;\n        //}\n\n        dfs(nti.size(),\"\",'0');\n        cout<<minColor<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\nstring d[M];\n\nbool eq(double n1,double n2){return abs(n1-n2)<EPS;}\n\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n}\n\nvoid func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0;\n    for(int i=0;i<Slen;i++){\n      for(int j=i+1;j<Slen;j++){\n\tif(mark[i]!=mark[j])continue;\n\tif(z.find(P1(d[i],d[j]))!=z.end())f=1;\n      }\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<map>\n#include<cassert>\n#include<cmath>\n#define F first\n#define S second\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint n;\nmap<string,int> Index;\nint index;\n\n\nint getIndex(string name)\n{\n  int pos;\n  if(Index.find(name) == Index.end())Index[name] = index,pos = index++;\n  else pos = Index[name];\n  return pos;\n}\n\ndouble dot(P a,P b)\n{\n  return a.F*b.F+a.S*b.S;\n}\n\ndouble cross(P a,P b)\n{\n  return a.F*b.S-a.S*b.F;\n}\n\ndouble norm(P a)\n{\n  return a.F*a.F+a.S*a.S;\n}\n\nP operator - (P &a,P &b)\n{\n  return P(a.F-b.F,a.S-b.S);\n}\n\nint ccw(P p0,P p1,P p2)\n{\n  P a = p1-p0;\n  P b = p2-p0;\n  if(cross(a,b) > 0)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < 0)return CLOCKWISE;\n  if(dot(a,b) < 0)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool cmp(const pair<int,int> &a,const pair<int,int> &b)\n{\n  if(a.first != b.first)return a.first < b.first;\n  return a.second < b.second;\n}\n\nvector<pair<int,int> > AndrewScan(vector<pair<int,int> > G2)\n{\n  if(G2.size() < 3)return G2;\n  vector<pair<int,int> > U,L;\n  sort(G2.begin(),G2.end(),cmp);\n  int G2_size = G2.size();\n\n  U.push_back(G2[0]);\n  U.push_back(G2[1]);\n  L.push_back(G2[G2_size-1]);\n  L.push_back(G2[G2_size-2]);\n\n  for(int i=2;i<G2_size;i++)\n    {\n      for(int j=U.size();j>=2 && ccw(U[j-2],U[j-1],G2[i]) != CLOCKWISE;j--)\n\tU.pop_back();\n      U.push_back(G2[i]);\n    }\n\n  for(int i=G2_size-3;i>=0;i--)\n    {\n      for(int j=L.size();j>=2 && ccw(L[j-2],L[j-1],G2[i]) != CLOCKWISE;j--)\n\tL.pop_back();\n      L.push_back(G2[i]);\n    }\n  reverse(L.begin(),L.end());\n  for(int i=U.size()-2;i>=1;i--)L.push_back(U[i]);\n  return L;\n}\n\nbool isIntersect(P p1,P p2,P p3,P p4)\n{\n\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0);\n}\n\n\n\nint Welch_Powell(vector<vector<int> > &G2)\n{\n\n  bool Empti = true;\n  for(int i=0;i<G2.size();i++)if(G2[i].size() != 0){Empti = false; break;}\n  if(Empti)return 1;\n  int G2_size = G2.size();\n  int PC = 0;\n  int chromatic_number = 0;\n  bool Drew[G2_size];\n  vector<pair<int,int> > Degree;\n  for(int i=0;i<G2_size;i++)Drew[i] = false,Degree.push_back(pair<int,int>(G2[i].size(),i) );\n  sort(Degree.begin(),Degree.end(),greater<pair<int,int> >());\n  while(PC < G2_size)\n    {\n      chromatic_number++;\n      bool Draw[G2_size];\n      for(int i=0;i<G2_size;i++)Draw[i] = Drew[i];\n      for(int i=0;i<G2_size;i++)\n\t{ \n\t  if(Draw[Degree[i].second]) \n\t    continue;\n\t  Drew[Degree[i].second] = Draw[Degree[i].second] = true;\n\t  PC++;\n\t  int index = Degree[i].second;\n\t  for(int j=0;j<G2[index].size();j++)Draw[G2[index][j]] = true; \n\t}\n    }\n  return chromatic_number;\n}\n\n\nvoid printVVI(VVI &G)\n{\n  cout << \"printVVI -- \"<< endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << G[i][j] << \" \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n}\n\nvoid printVVP(VVP &G)\n{\n  cout << \"printVVP ---- \" << endl;\n  for(int i=0;i<G.size();i++)\n    {\n      for(int j=0;j<G[i].size();j++)\n\t{\n\t  cout << \"(\" << G[i][j].F << \",\" << G[i][j].S << \") \";\n\t}\n      cout << endl;\n    }\n  cout << endl;\n\n}\n\nbool isParallel(P a,P b)\n{\n  return fabs(cross(a,b)-0.0) < EPS;\n}\n\nbool isParallel(P a1,P a2,P b1,P b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool Not(P a,P b,P c)\n{\n  if(ccw(a,b,c) == CLOCKWISE || ccw(a,b,c) == COUNTER_CLOCKWISE)return false;\n  return true;\n}\n\n\n\nbool check(P a,P b,P c,P d)\n{\n  if(!Not(a,b,c) || !Not(a,b,c))return false;\n  if(ccw(a,b,c)== 0 && ccw(a,b,d) == 0)return true;\n  if(ccw(a,b,c) == 0 || ccw(a,b,d) == 0)return false;\n  return true;\n  //if((a == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  //if((a == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == d) && (ccw(a,b,c) == ONLINE_FRONT || ccw(a,b,c) == ON_SEGMENT))return true;\n  //if((b == c) && (ccw(a,b,d) == ONLINE_FRONT || ccw(a,b,d) == ON_SEGMENT))return true;\n  \n  return false;\n}\n\nvoid printP(P p)\n{\n  cout << \"(\" << p.F << \",\" << p.S << \") \" << endl;\n}\n\nvoid printCCW(P a,P b,P c)\n{\n  int res = ccw(a,b,c);\n  if(res == 1)cout << \"COUNTER_CLOCKWISE\" << endl;\n  else if(res == -1) cout << \"CLOCKWISE\" << endl;\n  else if(res == 2)cout<< \"ONLINE_BACK\" << endl;\n  else if(res == -2)cout << \"ONLINE_FRONT\" << endl;\n  else cout << \"ON_SEGMENT\" << endl;  \n}\n\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      index = 0;\n      Index.clear();\n      VVP PG(n);\n      vector<string> NameList(n);\n      for(int i=0;i<n;i++)\n\t{\n\t  cin >> NameList[i];\n\t \n\t  while(true)\n\t    {\n\t      P p;\n\t      cin >> p.first;\n\t      if(p.first == -1)break;\n\t      cin >> p.second;\n\t      PG[i].push_back(p);\n\t    }\n\t}\n\n      VVI G;\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<PG[i].size();j++)\n\t    {\n\t      for(int k=0;k<n;k++)\n\t\t{\n\t\t  if(k == i)continue;\n\t\t  int Ikey = getIndex(NameList[i]);\n\t\t  int Kkey = getIndex(NameList[k]);\n\t\t  if(Ikey == Kkey)continue;\n\n\t\t  for(int l=0;l<PG[k].size();l++)\n\t\t    {\n\t\t      int kmod = PG[k].size();\n\t\t      int imod = PG[i].size();\n\t\t      P a,b,c,d;\n\t\t\t  a = PG[i][j];\n\t\t\t  b = PG[i][(j+1)%imod];\n\t\t\t  c = PG[k][l];\n\t\t\t  d = PG[k][(l+1)%kmod];\n\t\t  \n\t\t\t  if(isIntersect(a,b,c,d) && isParallel(a,b,c,d) && check(a,b,c,d))\n\t\t\t    {\n\t\t\t      //cout << \"OK! \"<< Ikey << \".pb \" << Kkey << endl;\n\t\t\t      //printP(a);printP(b);printP(c); printP(d);\n\t\t\t      //cout << \"ccw(a,b,c) = \";\n\t\t\t      //printCCW(a,b,c);\n\t\t\t      //cout << \"ccw(a,b,d) = \";\n\t\t\t      //printCCW(a,b,d);\n\t\t\t      if(Ikey >= G.size())\n\t\t\t\t{\n\t\t\t\t  G.push_back(vector<int>());\n\t\t\t\t  if(G.size() > Ikey)\n\t\t\t\t    {\n\t\t\t\t      cerr << \"G.size() = \"<< G.size() << endl;\n\t\t\t\t      cerr << \"Ikey = \"<< Ikey << endl;\n\t\t\t\t      assert(G.size() > Ikey);\n\t\t\t\t    }\n\t\t\t\t  G[Ikey].push_back(Kkey);\n\t\t\t\t}\n\t\t\t      else\n\t\t\t\tG[Ikey].push_back(Kkey);\n\t\t\t      \n\t\t\t      break;\n\t\t\t    }\n\t\t    }\n\t\t}\n\t    }\n\t}\n      \n   \n      for(int i=0;i<G.size();i++)\n\t    {\n\t      sort(G[i].begin(),G[i].end());\n\t      G[i].erase(unique(G[i].begin(),G[i].end()),G[i].end());\n\t    }\n\t\n     \n      //printVVI(G);\n      cout << Welch_Powell(G) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\n/*** geometry part ***/\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble dot(const point &a,const point &b){ return a.x*b.x+a.y*b.y; }\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\nstruct segment{\n\tpoint a,b;\n\tsegment(){}\n\tsegment(const point &a,const point &b):a(a),b(b){}\n};\n\ntypedef vector<point> polygon;\n\nbool cover(const segment &S,const point &p){\n\treturn abs(cross(S.a-p,S.b-p))<EPS && dot(S.a-p,S.b-p)<EPS;\n}\n\n// 二つの線分が長さ正の部分で接しているかどうか\nbool touch(const segment &S,const segment &T){\n\tif(abs(cross(S.b-S.a,T.b-T.a))>EPS) return false; // 平行でないとダメ\n\tif(S.a==T.a && S.b==T.b\n\t|| S.a==T.b && S.b==T.a) return true;\n\treturn cover(S,T.a) && S.a!=T.a && S.b!=T.a\n\t\t|| cover(S,T.b) && S.a!=T.b && S.b!=T.b\n\t\t|| cover(T,S.a) && T.a!=S.a && T.b!=S.a\n\t\t|| cover(T,S.b) && T.a!=S.b && T.b!=S.b;\n}\n\n// 二つの多角形が長さ正の部分で接しているかどうか\nbool touch(const polygon &F,const polygon &G){\n\tint m=F.size(),n=G.size();\n\trep(i,m) rep(j,n) {\n\t\tsegment S(F[i],F[(i+1)%m]);\n\t\tsegment T(G[j],G[(j+1)%n]);\n\t\tif(touch(S,T)) return true;\n\t}\n\treturn false;\n}\n\n/*** end ***/\n\n/*** graph part ***/\n\nint N; // 異なる国の個数\nbool G[10][10]; // 国どうしの接続関係のグラフ\n\nint color[10];\n// 彩色\nint dfs(int u,int next){\n\tif(u==N) return next;\n\n\tint res=N;\n\trep(c,next+1){\n\t\tbool ok=true;\n\t\trep(v,N) if(G[u][v] && color[v]==c) ok=false;\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,dfs(u+1,max(c+1,next)));\n\t\t\tcolor[u]=-1;\n\t\t}\n\t}\n\treturn res;\n}\n\n/*** end ***/\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstring name[100];\n\t\tpolygon F[100];\n\t\trep(i,n){\n\t\t\tchar s[32]; scanf(\"%s\",s);\n\t\t\tname[i]=s;\n\t\t\twhile(1){\n\t\t\t\tpoint p;\n\t\t\t\tscanf(\"%lf\",&p.x);\n\t\t\t\tif(p.x==-1) break;\n\t\t\t\tscanf(\"%lf\",&p.y);\n\t\t\t\tF[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tmap<string,int> f;\n\t\trep(i,n) if(f.count(name[i])==0) f.insert(make_pair(name[i],f.size()));\n\n\t\tN=f.size();\n\t\trep(u,N) rep(v,N) G[u][v]=false;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint u=f[name[i]],v=f[name[j]];\n\t\t\tif(u!=v && !G[u][v] && touch(F[i],F[j])) G[u][v]=true;\n\t\t}\n\n\t\trep(u,N) color[u]=-1;\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;\n  if (cross(b,c)<0) return -2;\n  if (dot(b, c)<0) return 1;\n  if (norm(b)<norm(c)) return -1;\n  return 0;\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num, const int &clique){\n  if(num >= ans || num>=m)return;\n  if(d==m){ ans = num; return; }\n  if((clique>>d)&1){ dfs(d+1,num,clique); return; }\n\n  vi use(num,0);\n  rep(i,m){\n    if(i<d || (clique>>i)&1){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n  }\n  \n  rep(i,num){\n    if(!use[i]){\n      cols[d] = i;\n      dfs(d+1,num,clique);\n      if(num>=ans)return;\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1,clique);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    int clique = 1, s = 1;\n    for(int bit=1;bit<(1<<m);bit++){\n      int p = __builtin_popcount(bit);\n      if(p<=s)continue;\n      bool f = true;\n      rep(i,m)rep(j,i){\n\tif( ((bit>>i)&1) && ((bit>>j)&1) && !g[i][j])f = false;\n      }\n      if(f){\n\tclique = bit; s = p;\n      }\n    }\n\n    cols.resize(m);\n    s = 0;\n    rep(i,m){\n      if((clique>>i)&1)cols[i] = s++;\n    }\n\n    ans = m;\n    dfs(0,s,clique);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\nconstexpr double EPS = (1e-8);\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point() {}\n    Point(double x, double y) : x{x}, y{y} {}\n\n    Point operator - (const Point& p) const\n    {\n        return Point(x - p.x, y - p.y);\n    }\n\n    bool operator == (const Point& p) const {\n        return equals(x, p.x) && equals(y, p.y);\n    }\n};\n\ndouble dot(const Point& a, const Point& b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point& a, const Point& b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point& p)\n{\n    return dot(p, p);\n}\n\nconstexpr int COUNTER_CLOCKWISE = +1;\nconstexpr int CLOCKWISE         = -1;\nconstexpr int ONLINE_BACK       = +2;\nconstexpr int ONLINE_FRONT      = -2;\nconstexpr int ON_SEGMENT        = +0;\nusing Vector = Point;\n\nint ccw(const Point& p0, const Point& p1, const Point& p2)\n{    \n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment() {}\n    Segment(Point s, Point t) : s{s}, t{t} {}\n\n    bool operator == (const Segment& seg) const {\n        if (s == seg.s && t == seg.t) return 1;\n        if (s == seg.t && t == seg.s) return 1;\n        return 0;\n    }\n};\n\nbool parallel(const Segment& s1, const Segment& s2)\n{\n    Vector a = s1.t - s1.s;\n    Vector b = s2.t - s2.s;    \n    return equals(cross(a, b), 0);\n}\n\nusing ll = long long;\nconstexpr int MAX = 10;\n\nbool con[MAX][MAX];\n\ninline int mod_pow(ll x, int n, int mod)\n{\n    if (n == 0) return 1;\n    int res = mod_pow(x * x % mod, n / 2, mod);\n    if (n & 1) res = res * x % mod;\n    return res;\n}\n\nint I[1 << MAX], bn[1 << MAX];\n\nbool c(int n, int k)\n{\n    ll g = 0;\n    constexpr int MOD = 10009;    \n    for (int i = 0; i < (1 << n); i++) {\n        if (bn[i] % 2 == 0) {\n            g += mod_pow(I[i], k, MOD);\n        } else {\n            g -= mod_pow(I[i], k, MOD);\n        }\n    }\n    return (g % MOD + MOD) % MOD != 0;\n}\n\nint paint_color_number(int n)\n{\n    vector<int> N(1 << n);\n    for (int i = 0; i < n; i++) {\n        int bit = (1 << i);\n        for (int j = 0; j < n; j++) {\n            if (con[i][j]) {\n                bit |= (1 << j);\n            }\n        }\n        N[i] = bit;\n    }\n        \n    memset(I, 0, sizeof(I));\n    I[0] = 1;\n    for (int S = 1; S < (1 << n); S++) {\n        bn[S] = __builtin_popcount(S);\n        int v = 0;\n        while (!(S >> v & 1)) v++;\n        I[S] = I[S - (1 << v)] + I[S & ~N[v]];\n    }\n            \n    int L = 0, R = n;\n    while (R - L > 1) {\n        int mid = (L + R) / 2;\n        if (c(n, mid)) {\n            R = mid;\n        } else {\n            L = mid;\n        }           \n    }\n    return R;\n}\n\nusing Polygon = vector<Point>;\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\n\nbool contain(const Segment& s, const Point& p)\n{\n    if (s.s == p) return 0;\n    if (s.t == p) return 0;\n    return ccw(s.s, s.t, p) == 0;\n}\n\nbool check(const Polygon& p1, const Polygon& p2)\n{\n    int N = p1.size(), M = p2.size();    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < M; j++) {\n            const Segment s1{curr(p1, i), next(p1, i)};\n            const Segment s2{curr(p2, j), next(p2, j)};\n            if (s1 == s2) return 1;\n            if (!parallel(s1, s2)) continue;\n            if (contain(s1, s2.s) || contain(s1, s2.t) ||\n                contain(s2, s1.s) || contain(s2, s1.t)) return 1;\n        }\n    }\n    return 0;\n}\n\nbool run()\n{\n    int N;\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    \n    map<string, int> num;\n    vector<int> c(N);\n    vector<Polygon> pgs(N);\n    \n    int idx = 0;\n    string country;\n    for (int i = 0; i < N; i++) {\n        cin >> country;\n        \n        if (num.count(country) == 0) {\n            num[country] = idx++;\n        }\n        \n        c[i] = num[country];\n        \n        double x, y;\n        Polygon pg;\n        while (cin >> x, x != -1) {\n            cin >> y;\n            pg.emplace_back(x, y);\n        }\n        pgs[i] = pg;\n    }\n    \n    memset(con, 0, sizeof(con));\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (c[i] == c[j]) continue;\n            if (check(pgs[i], pgs[j])) {\n                con[c[i]][c[j]] = con[c[j]][c[i]] = 1;\n            }\n        }\n    }\n    cout << paint_color_number(idx) << endl;\n    return true;\n}\n\nint main()\n{\n    while (run())\n        ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-9;\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef vector<Polygon> Country;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    map<string,Country> m;\n    while(n--){\n      string s;\n      cin>>s;\n      Polygon p;\n      for(int x,y;cin>>x,x>=0;){\n\tcin>>y;\n\tp.push_back(P(x,y));\n      }\n      m[s].push_back(p);\n    }\n    vector<Country> c;\n    for(auto e:m){\n      c.push_back(e.second);\n    }\n    bool d[100][100]={};\n    for(int i=0;i<c.size();i++){\n      for(auto e:c[i]){\n\tfor(int j=0;j<e.size();j++){\n\t  for(int k=0;k<i;k++){\n\t    for(auto f:c[k]){\n\t      for(int l=0;l<f.size();l++){\n\t\tP a=e[j],b=e[(j+1)%e.size()];\n\t\tP x=f[l],y=f[(l+1)%f.size()];\n\t\tif(fabs(cross(a-b,x-b))<eps&&fabs(cross(a-b,y-b)<eps)){\n\t\t  double len=abs(a-b);\n\t\t  if(!(len<abs(x-a)+eps&&len<abs(y-a)+eps||len<abs(x-b)+eps&&len<abs(y-b)+eps)){\n\t\t    d[i][k]=d[k][i]=true;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    int a=1;\n    for(int i=0;i<c.size();i++){\n      for(int j=0;j<i;j++){\n\tif(d[i][j]){\n\t  a=max(a,2);\n\t  for(int k=0;k<j;k++){\n\t    if(d[i][k]&&d[j][k]){\n\t      a=max(a,3);\n\t      for(int l=0;l<k;l++){\n\t\tif(d[i][l]&&d[j][l]&&d[k][l]){\n\t\t  a=4;\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<a<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\nint N;\nint cross(pair<int,int>a,pair<int,int>b)\n{\n\treturn a.first*b.second-a.second*b.first;\n}\nbool in(pair<pair<int,int>,pair<int,int> >L,pair<int,int>p)\n{\n\tint crs=cross(make_pair(L.first.first-p.first,L.first.second-p.second),\n\t\tmake_pair(L.second.first-p.first,L.second.second-p.second));\n\tif(crs!=0)return false;\n\tint norm=(L.first.first-L.second.first)*(L.first.first-L.second.first)\n\t\t+(L.first.second-L.second.second)*(L.first.second-L.second.second);\n\tint norma=(L.first.first-p.first)*(L.first.first-p.first)\n\t\t+(L.first.second-p.second)*(L.first.second-p.second);\n\tint normb=(p.first-L.second.first)*(p.first-L.second.first)\n\t\t+(p.second-L.second.second)*(p.second-L.second.second);\n\treturn norm>=norma&&norm>=normb;\n}\nmain()\n{\n\twhile(cin>>N,N)\n\t{\n\t\tmap<string,int>id;\n\t\tvector<pair<pair<int,int>,pair<int,int> > >A[10];\n\t\tint sz=0;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tstring s;cin>>s;\n\t\t\tint now;\n\t\t\tif(id.find(s)!=id.end())now=id[s];\n\t\t\telse now=id[s]=sz++;\n\t\t\tvector<pair<int,int> >Ps;\n\t\t\tint x,y;\n\t\t\twhile(cin>>x,x>=0)\n\t\t\t{\n\t\t\t\tcin>>y;\n\t\t\t\tPs.push_back(make_pair(x,y));\n\t\t\t}\n\t\t\tfor(int i=0;i<Ps.size();i++)\n\t\t\t{\n\t\t\t\tA[now].push_back(minmax(Ps[i],Ps[(i+1)%Ps.size()]));\n\t\t\t}\n\t\t}\n\t\tint G[10]={};\n\t\tfor(int i=0;i<sz;i++)for(int j=i+1;j<sz;j++)\n\t\t{\n\t\t\tbool flag=false;\n\t\t\tfor(pair<pair<int,int>,pair<int,int> >p:A[i])\n\t\t\t{\n\t\t\t\tfor(pair<pair<int,int>,pair<int,int> >q:A[j])\n\t\t\t\t{\n\t\t\t\t\tif(in(p,q.first)&&in(p,q.second)\n\t\t\t\t\t\t||in(q,p.first)&&in(q,p.second)\n\t\t\t\t\t\t||p.first!=q.first&&in(p,q.first)&&in(q,p.first)\n\t\t\t\t\t\t||p.first!=q.second&&in(p,q.second)&&in(q,p.first)\n\t\t\t\t\t\t||p.second!=q.first&&in(p,q.first)&&in(q,p.second)\n\t\t\t\t\t\t||p.second!=q.second&&in(p,q.second)&&in(q,p.second))\n\t\t\t\t\t{\n\t\t\t\t\t\tflag=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)\n\t\t\t{\n\t\t\t\tG[i]|=1<<j;\n\t\t\t\tG[j]|=1<<i;\n\t\t\t}\n\t\t}\n\t\tvector<int>ok;\n\t\tfor(int i=1;i<1<<sz;i++)\n\t\t{\n\t\t\tbool take=true;\n\t\t\tfor(int j=0;j<sz;j++)\n\t\t\t{\n\t\t\t\tif(i>>j&1)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=j+1;k<sz;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(i>>k&1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(G[j]>>k&1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttake=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(take)ok.push_back(i);\n\t\t}\n\t\tvector<int>dp(1<<sz,114514);\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<1<<sz;i++)\n\t\t{\n\t\t\tfor(int v:ok)\n\t\t\t{\n\t\t\t\tdp[i|v]=min(dp[i|v],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[(1<<sz)-1]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n \nusing namespace std;\n \nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n \n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n \ntypedef long long ll;\nint const inf = 1<<29;\n \nstruct Point{\n  int x,y;\n \n  Point(int x,int y):x(x),y(y){}\n \n  Point operator + (Point p){\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (Point p){\n    return Point(x-p.x,y-p.y);\n  }\n};\n \nstruct Segment{\n  Point s,t;\n  Segment(Point s,Point t):s(s),t(t){}\n};\n \nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n \nbool eq(Segment a,Segment b){\n  if( eq(a.s,b.s) && eq(a.t,b.t) )return true;\n  if( eq(a.s,b.t) && eq(a.t,b.s) )return true;  \n  return false;\n}\n \nint dot(Point a,Point b ){\n return a.x*b.x+a.y*b.y;\n}\n \nint cross(Point a,Point b ){\n return a.x*b.y-a.y*b.x;\n}\n \nbool isParallel(Segment a,Segment b){\n  return (cross(a.s-a.t,b.s-b.t)==0);\n}\n \nbool onSegment(Segment a,Point p){\n  if(eq(a.s,p))return false;\n  if(eq(a.t,p))return false;\n  if(cross(a.s-p,a.t-p)!=0)return false;\n  if(dot(a.t-a.s,p-a.s)<=0)return false;\n  if(dot(a.s-a.t,p-a.t)<=0)return false;\n  return true;\n}\n \nbool haveCommonSegment(Segment a,Segment b){\n  if(eq(a,b))return true;\n  if(!isParallel(a, b))return false;\n  if(onSegment(a,b.s))return true;\n  if(onSegment(a,b.t))return true;\n  if(onSegment(b,a.s))return true;\n  if(onSegment(b,a.t))return true;\n  return false;\n}\n \nbool haveCommonSegment(vector<Segment> &a,vector<Segment> &b){\n  for(Segment A : a )\n    for(Segment B : b )\n      if(haveCommonSegment(A,B))\n        return true;\n  return false;\n}\n \n \nbool check(int G[10][10],int S){\n  for(int i=0;i<10;i++){\n    if((S>>i&1)==0)continue;\n    for(int j=0;j<10;j++){\n      if((S>>j&1)==0)continue;\n      if(G[i][j])return false;\n    }\n  }\n  return true;\n}\n \n \nint main() {\n \n \n  while(1){\n    int N;\n    vector<Segment> Country[10];\n    map<string,int> id;\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      string name;\n      vector<Point> v;\n      cin>>name;\n      if(id.count(name)==0)\n        id[name]=id.size()-1;\n      while(1){\n        int x,y;\n        cin>>x;\n        if(x==-1)break;\n        cin>>y;\n        v.push_back(Point(x,y));\n      }\n      int size=v.size();\n      for(int j=0;j<size;j++){\n        Segment segment=Segment(v[j],v[(j+1)%size]);\n        Country[id[name]].push_back(segment);\n      }\n    }\n    int M=id.size();\n    int G[10][10]={};\n    for(int i=0;i<M;i++){\n      for(int j=0;j<M;j++){\n        if(i!=j){\n          G[i][j]=haveCommonSegment(Country[i],Country[j]);\n        }\n      }\n    }\n \n    vector<int> edge;\n    for(int S=0;S<(1<<M);S++)\n      if(check(G,S))\n        edge.push_back(S);\n \n    int dp[(1<<M)];\n    fill(dp,dp+(1<<M),10);\n    dp[0]=0;\n \n    for(int S=0;S<(1<<M);S++)\n      for(int T : edge)\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n \n    cout<<dp[(1<<M)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define next(i,n)  ((i+1)%n)\nconst double eps = 1e-10;\ntypedef complex<double>P;\ntypedef vector<P> Polygon;\n\nnamespace std{\n  bool operator==(P &a,P &b){\n    return abs(a-b)<eps;\n  }\n}\n\nbool is_point_online(P a,P b,P c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+eps;\n}\n\nbool is_adjacent(Polygon &a,Polygon &b){\n  rep(i,a.size()){\n    rep(j,b.size()){\n      bool a0=false,a1=false,b0=false,b1=false;\n      a0=is_point_online(b[j],b[next(j,b.size())],a[i]);\n      a1=is_point_online(b[j],b[next(j,b.size())],a[next(i,a.size())]);\n      b0=is_point_online(a[i],a[next(i,a.size())],b[j]);\n      b1=is_point_online(a[i],a[next(i,a.size())],b[next(j,b.size())]);\n      if ( a0&&a1)return true;\n      else if (b0&&b1)return true;\n      else if ( (a0&&b0&&a[i]!=b[j])||(a0&&b1&&a[i]!=b[next(j,b.size())])||\n\t\t(a1&&b0&&a[next(i,a.size())]!=b[j])||(a1&&b1&&a[next(i,a.size())]!=b[next(j,b.size())])){\n\treturn true;\n      }\n\n    }\n  }\n  return false;\n}\n\nbool judge(vector<Polygon> &a,vector<Polygon> &b){\n  rep(i,a.size()){\n    rep(j,b.size()){\n      if (is_adjacent(a[i],b[j]))return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge,vector<Polygon> *in,int n){\n  rep(i,n){\n    REP(j,i+1,n){\n      if ( judge(in[i],in[j]))edge[i].push_back(j),edge[j].push_back(i);\n    }\n  }\n\n}\n\n\nint ans;\nvoid dfs(int now,int n,int tmp,vector<int> *edge,int *color,bool *used){\n  if ( tmp > ans)return;\n  if (now == n){\n    \n    ans=min(ans,tmp);\n    return ;\n  }\n  \n  for(int i=now;i>=0;i--){\n    bool flag=true;\n    rep(j,edge[now].size()){\n      if(color[edge[now][j]]==i){flag=false;break;}\n    }\n    if ( flag== true){\n      bool tmpused=used[i];\n      int next=used[i]==false?1:0;\n      color[now]=i;\n      used[i]=true;\n      dfs(now+1,n,tmp+next,edge,color,used);\n      used[i]=tmpused;\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>> n && n){\n    ans=10;\n    vector<Polygon> in[10];\n    vector<int> edge[10];\n    bool used[10]={false};\n    int color[10];\n    map<string,int> M;\n    rep(i,n){\n      string name;\n      getline(cin,name);\n      getline(cin,name);\n      if (M.find(name)==M.end()){int index=M.size();M[name]=index;color[index]=-1;}\n      int index=M[name];\n      Polygon tmp;\n      P ins;\n      while(cin>>ins.real() && ins.real()!=-1){\n\tcin>>ins.imag();\n\ttmp.push_back(ins);\n      }\n      in[index].push_back(tmp);\n    }\n    make_graph(edge,in,M.size());\n    dfs(0,M.size(),0,edge,color,used);\n    cout << ans << endl;\n    /*\n    rep(i,M.size()){\n      cout << \"From \" << i ;\n      rep(j,edge[i].size())cout << \" \" << edge[i][j];\n      cout << endl;\n    }\n    */\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define EPS (1e-8)\n\nbool equals(double a, double b) {\n  return (fabs((a)-(b)) < EPS );\n}\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point (x+p.x,y+p.y);}\n  Point operator - (Point p){return Point (x-p.x,y-p.y);}\n  Point operator * (double a){return Point (x*a,y*a);}\n  Point operator / (double a){return Point (x/a,y/a);}\n};\n\nbool equals(Point a, Point b) {\n  return equals(a.x, b.x) && equals(a.y, b.y);\n}\n\ndouble norm( Point a ){ return a.x*a.x + a.y*a.y;}\ndouble abs( Point a ){ return sqrt(norm(a)); }\ndouble dot( Point a, Point b ){return a.x*b.x+a.y*b.y;}\ndouble cross(Point a,Point b){return a.x*b.y-a.y*b.x;}\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point a,Point b):p1(a),p2(b){}\n};\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a=p1-p0;\n  Point b=p2-p0;\n  if( cross(a, b) > EPS ) return 1;\n  if( cross(a, b) < -EPS ) return -1;\n  if( dot(a,b) < -EPS ) return 2;\n  if( norm(a) < norm(b) ) return -2;\n  return 0;\n}\n\nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\ndouble getDistanceLP(Segment s,Point p){\n  return abs(cross(s.p2-s.p1,p-s.p1)/abs(s.p2-s.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1)<0.0)return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2)<0.0)return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(isIntersect(s1,s2))return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\ntypedef vector<Point> Polygon;\n\nbool adjacent(const Polygon &s, const Polygon &t) {\n  int n = s.size();\n  int m = t.size();\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j < m; ++j) {\n      Point a = s[i];\n      Point b = s[(i+1)%n];\n      Point c = t[j];\n      Point d = t[(j+1)%n];\n      if(equals(a, c) && equals(b, d)) return true;\n      if(equals(a, d) && equals(b, c)) return true;\n      if(!isIntersect(a, b, c, d)) continue;\n      if(equals(a, c) && dot(b - a, d - c) < 0) continue;\n      if(equals(a, d) && dot(b - a, c - d) < 0) continue;\n      if(equals(b, c) && dot(a - b, d - c) < 0) continue;\n      if(equals(b, d) && dot(a - b, c - d) < 0) continue;\n      return true;\n    }\n  }\n  return false;\n}\n\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 101;\nint color[MAXN], vis[MAXN];\nint n;\nGraph G;\n\nvoid dfs(int v) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    int to = G[v][i];\n    if(!vis[to]) dfs(to);\n  }\n}\n\nvoid dfs(int v, int k) {\n  {\n    vector<int> can(k, true);\n    for(int i = 0; i < G[v].size(); ++i) {\n      int to = G[v][i];\n      if(color[to] != -1) can[color[to]] = false;\n    }\n    int c = -1;\n    for(int j = 0; j < k; ++j) {\n      if(can[j]) {\n\tc = j;\n\tbreak;\n      }\n    }\n    if(c == -1) throw 0;\n    color[v] = c;\n  }\n  for(int i = 0; i < G[v].size(); ++i) {\n    int to = G[v][i];\n    if(color[to] != -1) continue;\n    dfs(to, k);\n  }\n}\n\nint main() {\n  while(cin >> n && n) {\n    vector<Polygon> A;\n    for(int i = 0; i < n; ++i) {\n      string dumy; cin >> dumy;\n      Polygon ps;\n      while(1) {\n\tint x, y;\n\tcin >> x;\n\tif(x == -1) break;\n\tcin >> y;\n\tps.push_back(Point(x, y));\n      }\n      A.push_back(ps);\n    }\n    G = Graph(n);\n    for(int i = 0; i < n; ++i) {\n      for(int j = i+1; j < n; ++j) {\n\tif(adjacent(A[i], A[j])) {\n\t  G[i].push_back(j);\n\t  G[j].push_back(i);\n\t  //cout << i << \"-\" << j << endl;\n\t}\n      }\n    }\n    memset(vis, 0, sizeof(vis));\n    int res = 0;\n    for(int i = 0; i < n; ++i) {\n      if(vis[i]) continue;\n      dfs(i);\n      int num = 4;\n      for(int k = 1; k <= 3; ++k) {\n\ttry {\n\t  memset(color, -1, sizeof(color));\n\t  dfs(i, k);\n\t  num = k;\n\t  break;\n\t} catch(...) {}\n      }\n      res = max(res, num);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint isccw(const vi& xs,const vi& ys)\n{\n\tint sum=0;\n\trep(i,xs.size()){\n\t\tint x1=xs[i],x2=xs[(i+1)%xs.size()];\n\t\tint y1=ys[i],y2=ys[(i+1)%ys.size()];\n\t\tsum+=x1*y2-y1*x2;\n\t}\n\tassert(sum);\n\treturn sum>0;\n}\n\nint solve(const vvi& g,int u,vi& color)\n{\n\tint n=g.size();\n\tif(u==n) return *max_element(all(color))+1;\n\tint res=INF;\n\tfor(int c=0;c<n;c++){\n\t\tbool ok=true;\n\t\tfor(int v:g[u])\n\t\t\tif(color[v]==c){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,solve(g,u+1,color));\n\t\t\tcolor[u]=-1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tmap<string,int> ntoi;\n\t\tconst int h=1001,w=1001;\n\t\tvvi grid(h,vi(w,-1));\n\t\trep(_,n){\n\t\t\tstring name; cin>>name;\n\t\t\tntoi.insert(mp(name,ntoi.size()));\n\t\t\tint v=ntoi[name];\n\t\t\tvi xs,ys;\n\t\t\tfor(int x,y;cin>>x && x!=-1;){\n\t\t\t\tcin>>y;\n\t\t\t\txs.push_back(x);\n\t\t\t\tys.push_back(y);\n\t\t\t}\n\t\t\tif(!isccw(xs,ys)){\n\t\t\t\treverse(all(xs));\n\t\t\t\treverse(all(ys));\n\t\t\t}\n\t\t\trep(i,xs.size()){\n\t\t\t\tint x1=xs[i],x2=xs[(i+1)%xs.size()];\n\t\t\t\tint y1=ys[i],y2=ys[(i+1)%ys.size()];\n\t\t\t\tif(x1<x2 && y1==y2)\n\t\t\t\t\trepi(x,x1,x2) grid[y1][x]=v;\n\t\t\t\tif(x1>x2 && y1==y2)\n\t\t\t\t\tperi(x,x2,x1) grid[y1-1][x]=v;\n\t\t\t\tif(x1==x2 && y1<y2)\n\t\t\t\t\trepi(y,y1,y2) grid[y][x1-1]=v;\n\t\t\t\tif(x1==x2 && y1>y2)\n\t\t\t\t\tperi(y,y2,y1) grid[y][x1]=v;\n\t\t\t}\n\t\t}\n\t\t\n\t\tn=ntoi.size();\n\t\tvvi d(n,vi(n));\n\t\trep(i,h) rep(j,w) rep(k,4){\n\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj) continue;\n\t\t\tint u=grid[i][j],v=grid[ni][nj];\n\t\t\tif(u!=-1 && v!=-1 && u!=v) d[u][v]=d[v][u]=1;\n\t\t}\n\t\t\n\t\tvvi g(n);\n\t\trep(i,n) rep(j,n) if(d[i][j])\n\t\t\tg[i].push_back(j);\n\t\t\n\t\t//rep(i,n) dump(g[i]);\n\t\t\n\t\tvi color(n,-1);\n\t\tcout<<solve(g,0,color)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double eps = 1e-8;\nconst double inf = 1e10;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool equals(P a, P b) {\n  return ( equals(a.real(), b.real()) &&\n           equals(a.imag(), b.imag()) );\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ntypedef vector<P> Polygon;\n \nbool adjacent(const Polygon &s, const Polygon &t) {\n  int n = s.size();\n  int m = t.size();\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j < m; ++j) {\n      P a = s[i];\n      P b = s[(i+1)%n];\n      P c = t[j];\n      P d = t[(j+1)%m];\n      if(equals(a, c) && equals(b, d)) return true;\n      if(equals(a, d) && equals(b, c)) return true;\n      if(!isIntersect(a, b, c, d)) continue;\n      if(cross(a - b, c - d) != 0) continue;\n      if(equals(a, c) && dot(b - a, d - c) < 0) continue;\n      if(equals(a, d) && dot(b - a, c - d) < 0) continue;\n      if(equals(b, c) && dot(a - b, d - c) < 0) continue;\n      if(equals(b, d) && dot(a - b, c - d) < 0) continue;\n      return true;\n    }\n  }\n  return false;\n}\n \ntypedef vector<vector<int> > Graph;\n \nconst int MAXN = 101;\nint color[MAXN], vis[MAXN];\nint n;\nGraph G;\n \nvoid dfs(int v) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    int to = G[v][i];\n    if(!vis[to]) dfs(to);\n  }\n}\n \nvoid dfs(int v, int k) {\n  {\n    vector<int> can(k, true);\n    for(int i = 0; i < G[v].size(); ++i) {\n      int to = G[v][i];\n      if(color[to] != -1) can[color[to]] = false;\n    }\n    int c = -1;\n    for(int j = 0; j < k; ++j) {\n      if(can[j]) {\n        c = j;\n        break;\n      }\n    }\n    if(c == -1) throw 0;\n    color[v] = c;\n  }\n  for(int i = 0; i < G[v].size(); ++i) {\n    int to = G[v][i];\n    if(color[to] != -1) continue;\n    dfs(to, k);\n  }\n}\n \nint main() {\n  while(cin >> n && n) {\n    vector<Polygon> A;\n    for(int i = 0; i < n; ++i) {\n      string dumy; cin >> dumy;\n      Polygon ps;\n      while(1) {\n        int x, y;\n        cin >> x;\n        if(x == -1) break;\n        cin >> y;\n        ps.push_back(P(x, y));\n      }\n      A.push_back(ps);\n    }\n    G = Graph(n);\n    for(int i = 0; i < n; ++i) {\n      for(int j = i+1; j < n; ++j) {\n        if(adjacent(A[i], A[j])) {\n          G[i].push_back(j);\n          G[j].push_back(i);\n          //cout << i << \"-\" << j << endl;\n        }\n      }\n    }\n    memset(vis, 0, sizeof(vis));\n    int res = 0;\n    for(int i = 0; i < n; ++i) {\n      if(vis[i]) continue;\n      dfs(i);\n      int num = 4;\n      for(int k = 1; k <= 3; ++k) {\n        try {\n          memset(color, -1, sizeof(color));\n          dfs(i, k);\n          num = k;\n          break;\n        } catch(...) {}\n      }\n      res = max(res, num);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\n#define MAX 11\nbool e[MAX][MAX];\nint mod_pow(int x,int n,int mod){\n  int res=1;\n  while(n>0){\n    if(n&1) (res*=x)%=mod;\n    (x*=x)%=mod;\n    n>>=1;\n  }\n  return res;\n}\nint I[1<<MAX],bn[1<<MAX];\nbool check(int n,int k){\n  int g=0;\n  int MOD=10009;\n  for(int i=0;i<(1<<n);i++){\n    if(bn[i]%2==0) g+=mod_pow(I[i],k,MOD);\n    else g-=mod_pow(I[i],k,MOD);\n  }\n  return (g%MOD+MOD)%MOD!=0;\n}\nint paint(int n){\n  vector<int> N(1<<n);\n  for(int i=0;i<n;i++){\n    int bit=(1<<i);\n    for(int j=0;j<n;j++)\n      if(e[i][j]) bit|=(1<<j);\n    N[i]=bit;\n  }\n  memset(I,0,sizeof(I));\n  I[0]=1;\n  for(int S=1;S<(1<<n);S++){\n    bn[S]=__builtin_popcountll(S);\n    int v=0;\n    while(!((S>>v)&1)) v++;\n    I[S]=I[S-(1<<v)]+I[S&~N[v]];\n  }\n  int l=0,r=n;\n  while(l+1<r){\n    int m=(l+r)/2;\n    if(check(n,m)) r=m;\n    else l=m;\n  }\n  return r;\n}\n//END CUT HERE\n\n\n\n#define EPS (1e-10)\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool calc(Point a1,Point a2,Point b1,Point b2){\n  if(abs(cross(a2-a1,b1-a1))>EPS) return 0;\n  if(abs(cross(a2-a1,b2-a1))>EPS) return 0;\n  double ml=0;\n  ml=max(ml,abs(a1-a2));\n  ml=max(ml,abs(a1-b1));\n  ml=max(ml,abs(a1-b2));\n  ml=max(ml,abs(a2-b1));\n  ml=max(ml,abs(a2-b2));\n  ml=max(ml,abs(b1-b2));\n  return (ml+EPS<abs(a1-a2)+abs(b1-b2));\n}\n\n\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    Polygon p[n];\n    string name[n];\n    map<string,int> m;\n    for(int i=0;i<n;i++){\n      cin>>name[i];\n      if(!m.count(name[i])){\n\tint k=m.size();\n\tm[name[i]]=k;\n      }\n      int x,y;\n      while(cin>>x,~x){\n\tcin>>y;\n\tp[i].push_back(Point(x,y));\n      }\n    }\n    memset(e,0,sizeof(e));\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(name[i]==name[j]) continue;\n\tfor(int k=0;k<(int)p[i].size();k++){\n\t  for(int l=0;l<(int)p[j].size();l++){\n\t    e[m[name[i]]][m[name[j]]]|=\n\t      calc(p[i][k],p[i][(k+1)%p[i].size()],\n\t\t   p[j][l],p[j][(l+1)%p[j].size()]);\n\t    e[m[name[j]]][m[name[i]]]|=\n\t      calc(p[i][k],p[i][(k+1)%p[i].size()],\n\t\t   p[j][l],p[j][(l+1)%p[j].size()]);\n\t  }\n\t}\n      }\n    }\n    cout<<paint(m.size())<<endl;\n  }\n  return 0;\n}\n\n/*\n  verified on 2017/12/12\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1254\n*/"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nbool check(const vector<Point>&l, const vector<Point>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tfor (int j = 0; j < r.size(); ++j) {\n\t\t\tLine ll(l[i], l[(i + 1) % l.size()]);\n\t\t\tLine rl(r[j], r[(j + 1) % r.size()]);\n\t\t\tif (is_ll2(ll, rl).size() >= 2)return true;\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(const int now, const vector<vector<int>>&edges, vector<int>&colors,const int amax) {\n\tif (now == edges.size())return amax;\n\telse {\n\t\tint ans = 22;\n\t\tfor (int c = 0; c <= amax + 1; ++c) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < now; ++j) {\n\t\t\t\tif (edges[now][j] && colors[j] == c)ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcolors.push_back(c);\n\t\t\t\tans = min(ans, dfs(now + 1, edges, colors, max(amax, c)));\n\t\t\t\tcolors.pop_back();\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tvector<pair<int, vector<Point>>>ters;\n\t\tint id = 0;\n\t\twhile (N--) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.find(st) == mp.end())mp[st] = id++;\n\t\t\tvector<Point>ps;\n\t\t\twhile (1) {\n\t\t\t\tint x; cin >> x;\n\t\t\t\tif (x == -1)break;\n\t\t\t\tint y; cin >> y;\n\t\t\t\tPoint p(x, y);\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t\tters.push_back(make_pair(mp[st], ps));\n\t\t}\n\t\tvector<vector<int>>edges(id,vector<int>(id,false));\n\t\tfor (int i = 0; i < ters.size(); ++i) {\n\t\t\tfor (int j = i + 1; j < ters.size(); ++j) {\n\t\t\t\t\n\t\t\t\tif (check(ters[i].second, ters[j].second)) {\n\t\t\t\t\tedges[ters[i].first][ters[j].first] = true;\n\t\t\t\t\tedges[ters[j].first][ters[i].first] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>colors;\n\t\tint ans = dfs(0,edges,colors,-1);\n\t\tcout << ans+1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n  Pt() : x(0), y(0) {}\n  Pt(const T x, const T y) : x(x), y(y) {}\n  template <class F> explicit operator Pt<F> () const {\n    return Pt<F>((F)x, (F)y); }\n\n  Pt operator+(const Pt b) const { return Pt(x + b.x, y + b.y); }\n  Pt operator-(const Pt b) const { return Pt(x - b.x, y - b.y); }\n  template <class F> Pt<F> operator* (const F fac) {\n    return Pt<F>(x * fac, y * fac); }\n  template <class F> Pt<F> operator/ (const F fac) {\n    return Pt<F>(x / fac, y / fac); }\n\n  T operator&(const Pt b) const { return x * b.x + y * b.y; }\n  T operator^(const Pt b) const { return x * b.y - y * b.x; }\n\n  bool operator==(const Pt b) const {\n    return x == b.x and  y == b.y; }\n  bool operator<(const Pt b) const {\n    return x == b.x? y < b.y: x < b.x; }\n\n  Pt operator-() const { return Pt(-x, -y); }\n  T norm() const { return *this & *this; }\n  Pt prep() const { return Pt(-y, x); }\n};\ntemplate<class F> istream& operator>>(istream& is, Pt<F> &pt) {\n  return is >> pt.x >> pt.y;\n}\ntemplate<class F> ostream& operator<<(ostream& os, Pt<F> &pt) {\n  return os << pt.x << ' ' << pt.y;\n}\n\n\n\n\n\n  \ntemplate <typename T, typename Real = double>\nstruct Line {\n  Pt<T> st, ed;\n  Pt<T> vec() const { return ed - st; }\n  T ori(const Pt<T> p) const { return (ed - st)^(p - st); }\n  Line(const Pt<T> x, const Pt<T> y) : st(x), ed(y) {}\n  template<class F> operator Line<F> () const {\n    return Line<F>((Pt<F>)st, (Pt<F>)ed);\n  }\n\n  // sort by arg, the left is smaller for parallel lines\n  bool operator<(Line B) const {\n    Pt<T> a = vec(), b = B.vec();\n    auto sgn = [](const Pt<T> t) { return (t.y == 0? t.x: t.y) < 0; };\n    if (sgn(a) != sgn(b)) return sgn(a) < sgn(b);\n    if (abs(a^b) == 0) return B.ori(st) > 0;\n    return (a^b) > 0;\n  }\n\n  // Regard a line as a function\n  template<typename F> Pt<F> operator()(const F x) const {\n    return Pt<F>(st) + vec() * x;\n  }\n\n  bool isSegProperIntersection(const Line l) const {\n    return l.ori(st) * l.ori(ed) < 0 and ori(l.st) * ori(l.ed) < 0;\n  }\n\n  bool isPtOnSegProperly(const Pt<T> p) const {\n    return ori(p) == 0 and ((st - p)&(ed - p)) < 0;\n  }\n\n  Pt<Real> getIntersection(const Line<Real> l) {\n    Line<Real> h = *this;\n    return l(((l.st - h.st)^h.vec()) / (h.vec()^l.vec()));\n  }\n\n  Pt<Real> projection(const Pt<T> p) const {\n    return operator()(((p - st)&vec()) / (Real)(vec().norm()));\n  }\n};\n\n\n\nbool bipartite(const vector<vector<int>> &g) {\n  vector<int> vis(g.size(), -1);\n  function<bool(int, int)> dfs = [&](int u, int c) {\n    vis[u] = c;\n    bool test = true;\n    for (int v : g[u]) {\n      if (vis[v] == -1) {\n        test &= dfs(v, !c);\n      } else {\n        test &= vis[v] == !c;\n      }\n    }\n    return test;\n  };\n  for (int i = 0; i < g.size(); ++i) if (vis[i] == -1) \n    if (not dfs(i, 0)) return false;\n  return true;\n}\n\nint coloring(const vector<vector<int>> &g) {\n  int n = g.size();\n  vector<int> dp(1<<n, INT_MAX), indep;\n  dp[0] = 0;\n  for (int S = 0; S < (1<<n); ++S) {\n    bool flag = true;\n    for (int u = 0; u < n; ++u) for (int v : g[u]) {\n      flag &= not (S&1<<u) or not (S&1<<v);\n    }\n    if (flag) indep.push_back(S);\n  }\n  for (int S = 0; S < (1<<n); ++S) if (dp[S] != INT_MAX) {\n    for (auto T : indep) dp[S|T] = min(dp[S|T], dp[S] + 1);\n  }\n  return dp.back();\n}\n\n  \nbool test(const vector<Line<int>> &A, const vector<Line<int>> &B) {\n  for (auto a : A) for (auto b : B) {\n    if ((a.vec()^b.vec()) == 0) {\n      if (b.isPtOnSegProperly(a.st) or b.isPtOnSegProperly(a.ed)) return true;\n      if (a.isPtOnSegProperly(b.st) or a.isPtOnSegProperly(b.ed)) return true;\n      if (a.st == b.st and a.ed == b.ed) return true;\n      if (a.ed == b.st and a.st == b.ed) return true;\n    }\n  }\n  return false;\n}\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n  int n;\n  while (cin >> n and n) {\n    map<string, int> mp;\n    vector<vector<Line<int>>> T;\n    vector<int> country;\n    for (int i = 0; i < n; ++i) {\n      string s; cin >> s;\n      int x, id = mp.count(s) ? mp[s] : mp.size();\n      country.push_back(id);\n      mp[s] = id;\n      vector<Pt<int>> P;\n      vector<Line<int>> L;\n      while (cin >> x and x != -1) {\n        int y; cin >> y;\n        P.emplace_back(x, y);\n      }\n      for (int i = 0; i < P.size(); ++i) {\n        L.emplace_back(P[i], P[(i + 1) % P.size()]);\n      }\n      T.push_back(L);\n    }\n    vector<vector<int>> g(mp.size());\n\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < i; ++j) {\n        int a = country[i], b = country[j];\n        if (a != b and test(T[i], T[j])) {\n          g[a].push_back(b);\n          g[b].push_back(a);\n        }\n      }\n    }\n    for (int i = 0; i < g.size(); ++i) {\n      sort(g[i].begin(), g[i].end());\n      g[i].erase(unique(g[i].begin(), g[i].end()), g[i].end());\n    }\n    cout << coloring(g) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=long double;\nusing P=complex<ld>;\nusing Poly=vector<P>;\n\nconst int SIZE=10;\nconst ld EPS=1e-12;\nstruct Segment{\n    P a,b;\n};\n\nld cross(P a,P b){return real(a)*imag(b)-real(b)*imag(a);}\n\nbool is_adjacent(Segment l,Segment r){\n    P aa=r.a-l.a;\n    P ab=r.b-l.a;\n    P ldir=l.b-l.a;\n    if(abs(ldir)<EPS || abs(r.b-r.a)<EPS) return false;\n    if(abs(cross(aa,ab))<EPS && abs(cross(ab,ldir))<EPS){\n        P app=aa/ldir;\n        if(abs(imag(app))>EPS) return false;\n        ld ap=real(app);\n        P bpp=ab/ldir;\n        if(abs(imag(bpp))>EPS) return false;\n        ld bp=real(bpp);\n        return ! ((ap<EPS && bp<EPS) || (ap>1-EPS && bp>1-EPS));\n    }\n    else return false;\n}\nbool is_adjacent(Poly lhs,Poly rhs){\n    bool isok=false;\n    for(int i=0;i<lhs.size();i++){\n        Segment l={lhs[i],lhs[(i+1)%lhs.size()]};\n        for(int j=0;j<rhs.size();j++){\n            Segment r={rhs[j],rhs[(j+1)%rhs.size()]};\n            isok=isok || is_adjacent(l,r);\n        }\n    }\n    return isok;\n}\n\nint solve(int n){\n    vector<int> idx(n);\n    vector<Poly> poly(n);\n    map<string,int> dic;\n    int m=0;\n    auto getIdx=[&](string name){\n        if(dic.count(name)) return dic[name];\n        else return dic[name]=m++;\n    };\n    for(int i=0;i<n;i++){\n        string name;\n        cin>>name;\n        ld x,y;\n        while(cin>>x,abs(x+1)>EPS){\n            cin>>y;\n            poly[i].push_back(P(x,y));\n            idx[i]=getIdx(name);\n        }\n    }\n    vector<set<int>> gs(m);\n    for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n            if(idx[i]==idx[j]) continue;\n            if(is_adjacent(poly[i],poly[j])){\n                gs[idx[i]].insert(idx[j]);\n                gs[idx[j]].insert(idx[i]);\n            }\n        }\n    }\n\n    vector<bitset<SIZE>> bad(m);\n    for(int i=0;i<m;i++){\n        for(int j=0;j<SIZE;j++) bad[i][j]=false;\n        for(auto &e:gs[i]) bad[i][e]=true;\n    }\n    \n    function<int(int,int,vector<int>&)> dfs=[&](int v,int k,vector<int>& color){\n        if(v==m) return k;\n        int res=m;\n        for(int i=0;i<=k;i++){\n            bool isok=true;\n            for(int j=0;j<v;j++){\n                isok=isok && (!(color[j]==i && bad[v][j]));\n            }\n            if(isok){\n                color[v]=i;\n                int buf=(k==i);\n                res=min(res,dfs(v+1,k+buf,color));\n            }\n        }\n        return res;\n    };\n    vector<int> color(m);\n    return dfs(0,0,color);\n}\nint main(){\n    int n;\n    while(cin>>n,n){\n        cout<<solve(n)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef vector <int> V;\nstring str[101];\nvector <point> G[101];\nV node[101];\nmap <string,V> M;\nint n,ans;\n\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;\n  if(cross(d,e)<0) return -1;\n  if(dot(d,e)<0) return 2;\n  if(abs(d) < abs(e)) return -2;\n  return 0;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(!(ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0))return 0;\n  if(abs(ccw(a,b,c))==1||abs(ccw(a,b,d))==1)return 0;\n  double AB=abs(a-b)+abs(c-d);\n  double D=max(abs(a-c),abs(a-d));\n  D=max(D,max(abs(b-c),abs(b-d)));\n  if(AB==D) return 0;\n  return 1;\n}\n\nvoid mk_node(){\n  for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++){\n      if(str[i]==str[j])continue;\n      int is=G[i].size(),js=G[j].size();\n      for(int k=0;k<is;k++)\n\tfor(int l=0;l<js;l++){\n\t  point a=G[i][k],b=G[i][(k+1)%is];\n\t  point c=G[j][l],d=G[j][(l+1)%js];\n\t  if((intersection(a,b,c,d)))node[i].push_back(j),k=is,l=js;\n\t}\n    }\n  for(int i=0;i<n;i++) M[str[i]].push_back(i);\n}\n\n\nint col[101];\nvoid check(){\n  int c=0;\n  for(int i=0;i<n;i++){\n    c=max(c,col[i]);\n    for(int j=0;j<node[i].size();j++)\n      if(col[i]==col[node[i][j]])return;\n  }\n  ans=min(ans,c);\n}\nvoid nxp(map<string,V>::iterator it,int c){\n  if(it==M.end()){check();return;}\n\n  V a=it->second;\n  for(int i=0;i<=c;i++){\n    for(int j=0;j<a.size();j++)col[a[j]]=i;\n    if(i==c)nxp(++it,c+1);\n    else nxp(++it,c);\n    it--;\n  }\n\t }\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<n;i++) G[i].clear(),node[i].clear();\n\n    for(int i=0;i<n;i++){\n      cin>>str[i];\n      while(1){\n\tint a,b;\n\tcin>>a;\n\tif(a==-1) break;\n\tcin>>b;\n\tG[i].push_back(point(a,b));\n      }\n    }\n    mk_node();\n    ans=10;\n    nxp(M.begin(),0);\n    cout <<ans+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\nconst double eps = 1e-8;\nconst double inf = 1e10;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\nbool equals(P a, P b) {\n  return ( equals(a.real(), b.real()) &&\n           equals(a.imag(), b.imag()) );\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a,b) > eps) return 1;\n  if(cross(a,b) < -eps) return -1;\n  if(dot(a,b) < -eps) return 2;\n  if(norm(b)-norm(a) > eps) return -2;\n  return 0;\n}\n\nbool isIntersect(P a1, P a2, P b1, P b2) {\n  return ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n           ccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\n\ntypedef vector<P> Polygon;\n \nbool adjacent(const Polygon &s, const Polygon &t) {\n  int n = s.size();\n  int m = t.size();\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j < m; ++j) {\n      P a = s[i];\n      P b = s[(i+1)%n];\n      P c = t[j];\n      P d = t[(j+1)%m];\n      if(equals(a, c) && equals(b, d)) return true;\n      if(equals(a, d) && equals(b, c)) return true;\n      if(!isIntersect(a, b, c, d)) continue;\n      if(!equals(cross(a - b, c - d), 0.0)) continue;\n      if(equals(a, c) && dot(b - a, d - c) < 0) continue;\n      if(equals(a, d) && dot(b - a, c - d) < 0) continue;\n      if(equals(b, c) && dot(a - b, d - c) < 0) continue;\n      if(equals(b, d) && dot(a - b, c - d) < 0) continue;\n      return true;\n    }\n  }\n  return false;\n}\n \ntypedef vector<vector<int> > Graph;\n \nconst int MAXN = 101;\nint color[MAXN], vis[MAXN];\nint n;\nGraph G;\n \nvoid dfs(int v) {\n  vis[v] = true;\n  for(int i = 0; i < G[v].size(); ++i) {\n    int to = G[v][i];\n    if(!vis[to]) dfs(to);\n  }\n}\n \nvoid dfs(int v, int k) {\n  {\n    vector<int> can(k, true);\n    for(int i = 0; i < G[v].size(); ++i) {\n      int to = G[v][i];\n      if(color[to] != -1) can[color[to]] = false;\n    }\n    int c = -1;\n    for(int j = 0; j < k; ++j) {\n      if(can[j]) {\n        c = j;\n        break;\n      }\n    }\n    if(c == -1) throw 0;\n    color[v] = c;\n  }\n  for(int i = 0; i < G[v].size(); ++i) {\n    int to = G[v][i];\n    if(color[to] != -1) continue;\n    dfs(to, k);\n  }\n}\n \nint main() {\n  while(cin >> n && n) {\n    vector<Polygon> A;\n    for(int i = 0; i < n; ++i) {\n      string dumy; cin >> dumy;\n      Polygon ps;\n      while(1) {\n        int x, y;\n        cin >> x;\n        if(x == -1) break;\n        cin >> y;\n        ps.push_back(P(x, y));\n      }\n      A.push_back(ps);\n    }\n    G = Graph(n);\n    for(int i = 0; i < n; ++i) {\n      for(int j = i+1; j < n; ++j) {\n        if(adjacent(A[i], A[j])) {\n          G[i].push_back(j);\n          G[j].push_back(i);\n          //cout << i << \"-\" << j << endl;\n        }\n      }\n    }\n    memset(vis, 0, sizeof(vis));\n    int res = 0;\n    for(int i = 0; i < n; ++i) {\n      if(vis[i]) continue;\n      dfs(i);\n      int num = 4;\n      for(int k = 1; k <= 3; ++k) {\n        try {\n          memset(color, -1, sizeof(color));\n          dfs(i, k);\n          num = k;\n          break;\n        } catch(...) {}\n      }\n      res = max(res, num);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "6\nBlizid\n0 0\n60 0\n60 60\n0 60\n0 50\n50 50\n50 10\n0 10\n-1\nBlizid\n0 10\n10 10\n10 50\n0 50\n-1\nWindom\n10 10\n50 10\n40 20\n20 20\n20 40\n10 50\n-1\nAccent\n50 10\n50 50\n35 50\n35 25\n-1\nPilot\n35 25\n35 50\n10 50\n-1\nBlizid\n20 20\n40 20\n20 40\n-1\n4\nA1234567890123456789\n0 0\n0 100\n100 100\n100 0\n-1\nB1234567890123456789\n100 100\n100 200\n200 200\n200 100\n-1\nC1234567890123456789\n0 100\n100 100\n100 200\n0 200\n-1\nD123456789012345678\n100 0\n100 100\n200 100\n200 0\n-1\n0"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\ninline int sgn(const ll& r){ return (r > 0) - (r < 0);}\n\nusing P=complex<ll>;\nusing L=struct{P s,t;};\n\nnamespace std{\n\tbool operator >  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)>0:sgn(imag(a-b))>0;}\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\ninline ll dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline ll det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\ninline bool cross(L a,L b){\n\tif(det(P(0,0),a.t-a.s,b.t-b.s)!=0) return false;\n\tconst int sa=ccw(a.s,a.t,b.s)|ccw(a.s,b.t,b.t);\n\tconst int sb=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif((sa&ON)==0) return false;\n\tif((sb&ON)==0) return false;\n\t\n\tusing state=tuple<P,int>;\n\n\tvector<state> ary={state(a.s,0),state(a.t,0),state(b.s,1),state(b.t,1)};\n\tsort(_all(ary));\n\tif(get<1>(ary[0])==get<1>(ary[1])) return false;\n\tif(get<1>(ary[2])==get<1>(ary[3])) return false;\n\tif(get<0>(ary[1])==get<0>(ary[2])) return false;\n\t//cout << a.s << \" \" << a.t << \" \" << b.s << \" \" << b.t << endl;\n\treturn true;\n}\n\nbool cgraph[10][10];\nint color[10];\nint dfs(int v,int n,int c){\n\tif(v==n) return c;\n\tset<int> used;\n\trep(i,v) if(cgraph[v][i]) used.insert(color[i]);\n\n\tint ret=10;\n\trep(i,c+1){\n\t\tif(used.find(i)!=used.end()) continue;\n\t\tcolor[v]=i;\n\t\tchmin(ret,dfs(v+1,n,max(i+1,c)));\n\t\tcolor[v]=-1;\n\t}\n\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tset<L> pol[110];\n\t\tmap<string,vector<int>> conv;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin >> s; \n\t\t\tconv[s].push_back(i);\n\n\t\t\tint x[110],y[110],m=0;\n\n\t\t\twhile(1){\n\t\t\t\tcin >> x[m];\n\t\t\t\tif(x[m]==-1) break;\n\t\t\t\tcin >> y[m++];\n\t\t\t}\n\n\t\t\trep(j,m){\n\t\t\t\tP a=P(x[j],y[j]);\n\t\t\t\tP b=P(x[(j+1)%m],y[(j+1)%m]);\n\t\t\t\tif(a>b) swap(a,b);\n\t\t\t\tpol[i].insert(L({a,b})); \n\t\t\t}\n\t\t}\n\n\t\tvector<string> ary;\n\t\tfor(auto &it:conv) ary.push_back(it.first);\n\t\tconst int m=ary.size();\n\n\t\tbool graph[110][110];\n\t\tclr(graph,0);\n\t\t\n\t\trep(i,n)rep(j,i){\n\t\t\tbool ok=false;\n\t\t\tfor(auto &line:pol[i]) for(auto &line2:pol[j]){\n\t\t\t\tif(ok) continue;\n\t\t\t\tif(cross(line,line2)) ok=true;\n\t\t\t}\n\t\t\tif(ok) graph[i][j]=graph[j][i]=true;\n\t\t}\n\n\t\trep(i,m)rep(j,i){\n\t\t\tcgraph[i][j]=cgraph[j][i]=false;\n\t\t\tfor(auto &v:conv[ary[i]]) for(auto &v2:conv[ary[j]]) if(graph[v][v2]) cgraph[i][j]=cgraph[j][i]=true;\n\t\t}\n\n\t\tcout << dfs(0,m,0) << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <iostream>\n#include <cmath>\n#define INF 1LL<<5\nusing namespace std;\nstruct P{\n\tint x,y;\n\tP(){}\n\tP(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(x+p.x,y+p.y);\n\t}\n\tP operator -(P p){\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tP operator *(int d){\n\t\treturn P(x*d,y*d);\n\t}\n\tbool operator ==(const P &p)const{\n\t\treturn (x==p.x && y==p.y);\n\t}\n};\n\ntypedef P Vector;\ntypedef vector<P> Polygon;\nint norm(P p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nint dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(P p0,P p1,P p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>0)return 1;\n\tif(cross(a,b)<0)return -1;\n\tif(dot(a,b)<0)return 2;\n\tif(norm(a)<norm(b))return -2;\n\treturn 0;\n}\n\nbool intersect(P p1,P p2,P p3,P p4){\n\tif(ccw(p1,p2,p3)*ccw(p1,p2,p4)>0 || ccw(p3,p4,p1)*ccw(p3,p4,p2)>0)return false;\n\tif(ccw(p1,p2,p3)*ccw(p1,p2,p4)<0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<0)return true;\n\tif(ccw(p1,p2,p4)==0 && ccw(p1,p2,p3)==0)return true;\n\tif(ccw(p3,p4,p1)==0 && ccw(p3,p4,p2)==0)return true;\n\tif(ccw(p1,p2,p3)==0 && !(p1==p3) && !(p2==p3) && abs(ccw(p1,p2,p4))!=1)return true;\n\tif(ccw(p1,p2,p4)==0 && !(p1==p4) && !(p2==p4) && abs(ccw(p1,p2,p3))!=1)return true;\n\treturn false;\n}\n\n\n\nint n;\nmap<string,int> id;\nPolygon territory[101];\nvector<int> ind[101];\nbool edge[11][11];\nvector<int> paint;\nint dp[1<<11];\n\nbool share(int c1,int c2){\n\tfor(int i=0;i<ind[c1].size();i++){\n\t\tfor(int j=0;j<ind[c2].size();j++){\n\t\t\tint t1=ind[c1][i],t2=ind[c2][j];\n\t\t\tfor(int k=0;k<territory[t1].size();k++){\n\t\t\t\tP p1=territory[t1][k];\n\t\t\t\tP p2=territory[t1][(k+1)%territory[t1].size()];\n\t\t\t\tfor(int l=0;l<territory[t2].size();l++){\n\t\t\t\t\tP p3=territory[t2][l];\n\t\t\t\t\tP p4=territory[t2][(l+1)%territory[t2].size()];\n\t\t\t\t\tif(intersect(p1,p2,p3,p4)){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint all=0;\n\t\tid.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tterritory[i].clear();\n\t\t\tind[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(id.find(str)==id.end()){\n\t\t\t\tid[str]=all++;\n\t\t\t}\n\t\t\tind[id[str]].push_back(i);\n\t\t\twhile(1){\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tif(x==-1)break;\n\t\t\t\tscanf(\"%d\",&y);\n\t\t\t\tterritory[i].push_back(P(x,y));\n\t\t\t}\n\t\t}\n\t\tmemset(edge,false,sizeof(edge));\n\t\tfor(int i=0;i<all;i++){\n\t\t\tfor(int j=i+1;j<all;j++){\n\t\t\t\tif(share(i,j)){\n\t\t\t\t\tedge[i][j]=true;\n\t\t\t\t\tedge[j][i]=true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tpaint.clear();\n\t\tfor(int i=0;i<(1<<all);i++){\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<all;j++){\n\t\t\t\tif(!((i>>j) & 1))continue;\n\t\t\t\tfor(int k=j+1;k<all;k++){\n\t\t\t\t\tif(!((i>>k) & 1))continue;\n\t\t\t\t\tif(edge[j][k])flag=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)paint.push_back(i);\n\t\t}\n\t\tfill(dp,dp+(1<<all),INF);\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<all);i++){\n\t\t\tif(dp[i]==INF)continue;\n\t\t\tfor(int j=0;j<paint.size();j++){\n\t\t\t\tint k=paint[j];\n\t\t\t\tdp[i|k]=min(dp[i|k],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[(1<<all)-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 20\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad テ」ツ?ッティツァツ津・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ァテヲツ個?」ツ?淌」ツ?崚」ツつ凝」ツ?禿」ツ?ィ\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// テ・ツコツヲテ」ツつ津」ツδゥテ」ツつクテ」ツつ「テ」ツδウテ」ツ?ォテ・ツ、ツ嘉ヲツ渉?\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - CCW - begin\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - CCW - end\n\n// Library - intersect - begin\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// Library - intersect - end\n\nstruct P\n{\n  Point p;\n  int type;\n  P(Point p=Point(),int type=IINF):p(p),type(type){}\n  bool operator < (const P& a)const\n  {\n    if(!(p == a.p))return p < a.p;\n    return type < a.type;\n  }\n};\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool intersect(Segment seg1,Segment seg2)\n{\n  if(!isParallel(seg1,seg2))return false;\n\n  double dist = distanceSS(seg1,seg2);\n\n  if(!equals(dist,0.0))return false;\n\n  vector<P> vec;\n  \n  vec.push_back(P(seg1.p1,0));\n  vec.push_back(P(seg1.p2,0));\n  vec.push_back(P(seg2.p1,1));\n  vec.push_back(P(seg2.p2,1));\n  sort(vec.begin(),vec.end());\n  if(vec[1].p == vec[2].p)return false;\n  \n  return true;\n\n}\n\nvector<int> G[MAX];\nint color[MAX],SIZE,ans;\n\nvoid rec(int upper,int state)\n{\n  if(upper >= ans)\n    {\n      return;\n    }\n\n  if(state == (1<<SIZE)-1)\n    {\n      ans = min(ans,upper);\n      return;\n    }\n\n  int OK = ((1<<SIZE)-1) & (~state);\n  while(OK)\n    {\n      int use = OK & -OK;\n      OK -= use;\n      int i = (int)log2(use);\n      if((state >> i) & 1)continue;\n\n      int x = 0;\n      rep(j,G[i].size())\n\t{\n\t  if(color[G[i][j]] == -1)continue;\n\t  x |= (1<<color[G[i][j]]);\n\t}\n\n      int OK2 = ((1<<(upper+1))-1) & (~x);\n      \n      while(OK2)\n\t{\n\t  int use2 = OK2 & -OK2;\n\t  OK2 -= use2;\n\t  int c = log2(use2);\n\t  int cost = (upper == c);\n\t  color[i] = c;\n\t  rec(upper+cost,state|(1<<i));\n\t  color[i] = -1;\n\n\t}\n      return;\n    }\n\n}\n\nvoid compute()\n{\n  ans = IINF;\n  rep(i,SIZE)color[i] = -1;\n  rec(0,0);\n  cout << ans << endl;\n}\n\nint main()\n{\n\n  int N;\n  while(cin >> N,N)\n    {\n      map<string,int> Index;\n      int dex = 0;\n      string country[N];\n      vector<Point> coor[N];\n      int index[N];\n\n      rep(i,N)\n\t{\n\t  cin >> country[i];\n\t  if(Index.find(country[i]) == Index.end())Index[country[i]] = dex++;\n\t  int x,y;\n\t  while(cin >> x, x != -1)\n\t    {\n\t      cin >> y;\n\t      coor[i].push_back(Point(x,y));\n\t    }\n\t}\n\n      rep(i,N)\n\t{\n\t  index[i] = Index[country[i]];\n\t}\n      int n = Index.size();\n      rep(i,n)G[i].clear();\n\n      set<ii> used;\n\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\t \n\t      if(index[i] == index[j])continue;\n\t      if(used.find(ii(index[i],index[j])) != used.end())continue;\n\n\t      vector<Point> vec;\n\t      bool check = false;\n\t      \n\t      rep(k,coor[i].size())\n\t\t{\n\t\t  Segment seg1 = Segment(coor[i][k],coor[i][(k+1)%coor[i].size()]);\n\t\t  rep(l,coor[j].size())\n\t\t    {\n\t\t      Segment seg2 = Segment(coor[j][l],coor[j][(l+1)%coor[j].size()]);\n\n\t\t      if(intersect(seg1,seg2))\n\t\t\t{\n\t\t\t  check = true;\n\t\t\t  goto Skip;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    Skip:;\t      \n\t      if(check)\n\t\t{\n\t\t  used.insert(ii(index[i],index[j]));\n\t\t  used.insert(ii(index[j],index[i]));\n\t\t  G[index[i]].push_back(index[j]);\n\t\t  G[index[j]].push_back(index[i]);\n\t\t}\n\t    }\n\t}\n\n      SIZE = n;\n\n      compute();\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;\n  if (cross(b,c)<0) return -2;\n  if (dot(b, c)<0) return 1;\n  if (norm(b)<norm(c)) return -1;\n  return 0;\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num >= ans || num>=m)return;\n  if(d==m){ ans = num; return; }\n\n  vi use(num,0);\n  rep(i,d){\n    if(g[d][i])use[cols[i]] = 1;\n  }\n  \n  rep(i,num){\n    if(!use[i]){\n      cols[d] = i;\n      dfs(d+1,num);\n      if(num>=ans)return;\n    }\n  }\n\n  cols[d] = num;\n  dfs(d+1,num+1);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    cols.resize(m);\n    ans = m;\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;\n#define show2d(v) rep(_,v.size()){rep(__,v[_].size())cout<<\" \"<<v[_][__];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\n\nstruct L : public vector<P> {\n\tL(){\n\t\tpb(0);\n\t\tpb(0);\n\t}\n\tL(const P &a, const P &b) {\n\tpush_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;                               // a--c--b on line\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n\t\t abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n\t\t cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n\t\t ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\t\t min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n\treturn (distanceLP(l,c.c) < c.r+EPS &&\n\t\t\t(c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble tmp=c.r*c.r-norm(pr-c.c);\n\tif(abs(tmp)<EPS)tmp=0;\n\tdouble t=sqrt(tmp);\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n\tdouble S =0;\n\tfor(int i =0;i <g.size();i++){\n\t\tS +=(cross(g[i],g[(i+1)%g.size()]));\n\t}\n\treturn abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<EPS&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(abs(cross(a,b))<EPS&&dot(a,b)<EPS)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n\tint n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n\tif (imag(pt[i]) > imag(pt[is])) is = i;\n\tif (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n\tif (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n\telse i = (i+1) % n;\n\tif (norm(pt[i]-pt[j]) > maxd) {\n\t  maxd = norm(pt[i]-pt[j]);\n\t  maxi = i; maxj = j;\n\t}\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n\tP a= curr(g, i), b= next(g, i);\n\tif (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n\tif (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n\t  Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%0.9f %0.9f %0.9f %0.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\ndouble max(double a,double b){return a>b?a:b;}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs nam(n);\n\t\tvi name(n);\n\t\tvector<G>g;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tG t;\n\t\t\tcin>>s;\n\t\t\tma[s]=1;\n\t\t\tnam[i]=s;\n\t\t\tint a,b;\n\t\t\twhile(cin>>a,a+1){\n\t\t\t\tcin>>b;\n\t\t\t\tt.pb(P(a,b));\n\t\t\t}\n\t\t\tg.pb(t);\n\t\t}\n\t\tint c=0;\n\t\tfor(auto a=ma.begin();a!=ma.end();a++){\n\t\t\ta->second=c++;\n\t\t}\n\t\trep(i,n)name[i]=ma[nam[i]];\n\t\tvvi tG(c,vi(c));\n\t\trep(i,n)rep(j,n)if(i-j&&name[i]-name[j]){\n\t\t\tbool h=false;\n\t\t\trep(x,g[i].size())rep(y,g[j].size()){\n\t\t\t\tL l(g[j][y],g[j][(y+1)%g[j].size()]);\n\t\t\t\tif(abs(g[i][x]-g[j][y])<EPS&&abs(g[i][(x+1)%g[i].size()]-g[j][(y+1)%g[j].size()])<EPS)h=true;\n\t\t\t\tif(abs(g[i][(x+1)%g[i].size()]-g[j][y])<EPS&&abs(g[i][x]-g[j][(y+1)%g[j].size()])<EPS)h=true;\n\t\t\t\trep(z,2){\n\t\t\t\t\tif(abs(ccw(g[i][x],g[i][(x+1)%g[i].size()],l[z]))==1)continue;\n\t\t\t\t\tdouble dis1=abs(g[i][x]-l[z]);\n\t\t\t\t\tdouble dis2=abs(g[i][(x+1)%g[i].size()]-l[z]);\n\t\t\t\t\tdouble dis3=abs(g[i][(x+1)%g[i].size()]-g[i][x]);\n\t\t\t\t\tif(abs(dis1+dis2-dis3)<EPS&&dis1>EPS&&dis2>EPS)h=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(h){\n\t\t\t\ttG[name[i]][name[j]]=1;\n\t\t\t\ttG[name[j]][name[i]]=1;\n\t\t\t}\n\t\t}\n\t\t// show1d(name);\n\t\t// show2d(tG);\n\t\tvi dp(1<<c,inf);\n\t\tdp[0]=0;\n\t\trep(i,1<<c)if(dp[i]-inf){\n\t\t\tint t=(1<<c)-1-i;\n\t\t\tfor(int j=t;j>0;j=(j-1)&t){\n\t\t\t\tbool h=true;\n\t\t\t\trep(x,c)rep(y,c)if((j&1<<x)&&(j&1<<y)&&x-y&&tG[x][y])h=false;\n\t\t\t\t\n\t\t\t\tif(h)cmin(dp[i|j],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[(1<<c)-1]<<endl;\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef vector <int> V;\nstring str[101];\nvector <point> G[101];\nV node[101];\nmap <string,V> M;\nint n,ans;\n\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;\n  if(cross(d,e)<0) return -1;\n  if(dot(d,e)<0) return 2;\n  if(abs(d) < abs(e)) return -2;\n  return 0;\n}\n\n\nbool intersection(point a,point b,point c,point d){\n  if(!(ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0))return 0;\n  if(abs(ccw(a,b,c))==1||abs(ccw(a,b,d))==1)return 0;\n  double AB=abs(a-b)+abs(c-d);\n  double D=max(abs(a-c),abs(a-d));\n  D=max(D,max(abs(b-c),abs(b-d)));\n  if(AB==D) return 0;\n  return 1;\n}\n\nvoid mk_node(){\n  for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++){\n      if(str[i]==str[j])continue;\n      int is=G[i].size(),js=G[j].size();\n      for(int k=0;k<is;k++)\n\tfor(int l=0;l<js;l++){\n\t  point a=G[i][k],b=G[i][(k+1)%is];\n\t  point c=G[j][l],d=G[j][(l+1)%js];\n\t  if((intersection(a,b,c,d)))node[i].push_back(j),k=is,l=js;\n\t}\n    }\n  for(int i=0;i<n;i++) M[str[i]].push_back(i);\n}\n\n\nint col[101];\nvoid check(){\n  int c=0;\n  for(int i=0;i<n;i++){\n    c=max(c,col[i]);\n    for(int j=0;j<node[i].size();j++)\n      if(col[i]==col[node[i][j]])return;\n  }\n  ans=min(ans,c);\n}\n\nvoid nxp(map<string,V>::iterator it,int c){\n  if(it==M.end()){\n    check();\n    return ;\n  }\n  V a=it->second;\n  for(int i=0;i<=c;i++){\n    for(int j=0;j<a.size();j++)col[a[j]]=i;\n    nxp(++it,max(c,i+1));\n    it--;\n  }\n  \t }\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    ans=10;\n    for(int i=0;i<n;i++) G[i].clear(),node[i].clear();\n\n    for(int i=0;i<n;i++){\n      cin>>str[i];\n      while(1){\n\tint a,b;\n\tcin>>a;\n\tif(a==-1) break;\n\tcin>>b;\n\tG[i].push_back(point(a,b));\n      }\n    }\n\n    mk_node();\n    nxp(M.begin(),0);\n    cout <<ans+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "< \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\""
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct Point{\n  int x,y;\n\n  Point(int x,int y):x(x),y(y){}\n\n  Point operator + (Point p){\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (Point p){\n    return Point(x-p.x,y-p.y);\n  }\n};\n\nstruct Segment{\n  Point s,t;\n  Segment(Point s,Point t):s(s),t(t){}\n};\n\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n\nbool eq(Segment a,Segment b){\n  if( eq(a.s,b.s) && eq(a.t,b.t) )return true;\n  if( eq(a.s,b.t) && eq(a.t,b.s) )return true;  \n  return false;\n}\n\nint dot(Point a,Point b ){\n return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b ){\n return a.x*b.y-a.y*b.x;\n}\n\nbool isParallel(Segment a,Segment b){\n  return (cross(a.s-a.t,b.s-b.t)==0);\n}\n\nbool onSegment(Segment a,Point p){\n  if(eq(a.s,p))return false;\n  if(eq(a.t,p))return false;\n  if(cross(a.s-p,a.t-p)!=0)return false;\n  if(dot(a.t-a.s,p-a.s)<=0)return false;\n  if(dot(a.s-a.t,p-a.t)<=0)return false;\n  return true;\n}\n\nbool haveCommonSegment(Segment a,Segment b){\n  if(eq(a,b))return true;\n  if(!isParallel(a, b))return false;\n  if(onSegment(a,b.s))return true;\n  if(onSegment(a,b.t))return true;\n  if(onSegment(b,a.s))return true;\n  if(onSegment(b,a.t))return true;\n  return false;\n}\n\nbool haveCommonSegment(vector<Segment> &a,vector<Segment> &b){\n  for(Segment A : a )\n    for(Segment B : b )\n      if(haveCommonSegment(A,B))\n        return true;\n  return false;\n}\n\n\nbool check(int G[10][10],int S){\n  for(int i=0;i<10;i++){\n    if((S>>i&1)==0)continue;\n    for(int j=0;j<10;j++){\n      if((S>>j&1)==0)continue;\n      if(G[i][j])return false;\n    }\n  }\n  return true;\n}\n\n\nint main() {\n\n\n  while(1){\n    int N;\n    vector<Segment> Country[10];\n    map<string,int> id;\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      string name;\n      vector<Point> v;\n      cin>>name;\n      if(id.count(name)==0)\n        id[name]=id.size()-1;\n      while(1){\n        int x,y;\n        cin>>x;\n        if(x==-1)break;\n        cin>>y;\n        v.push_back(Point(x,y));\n      }\n      int size=v.size();\n      for(int j=0;j<size;j++){\n        Segment segment=Segment(v[j],v[(j+1)%size]);\n        Country[id[name]].push_back(segment);\n      }\n    }\n    int M=id.size();\n    int G[10][10]={};\n    for(int i=0;i<M;i++){\n      for(int j=0;j<M;j++){\n        if(i!=j){\n          G[i][j]=haveCommonSegment(Country[i],Country[j]);\n        }\n      }\n    }\n\n    vector<int> edge;\n    for(int S=0;S<(1<<M);S++)\n      if(check(G,S))\n        edge.push_back(S);\n\n    int dp[(1<<M)];\n    fill(dp,dp+(1<<M),10);\n    dp[0]=0;\n\n    for(int S=0;S<(1<<M);S++)\n      for(int T : edge)\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n\n    cout<<dp[(1<<M)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\ninline int sgn(const ll& r){ return (r > 0) - (r < 0);}\n\nusing P=complex<ll>;\nusing L=struct{P s,t;};\n\nnamespace std{\n\tbool operator >  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)>0:sgn(imag(a-b))>0;}\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\ninline ll dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline ll det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\ninline bool cross(L a,L b){\n\tif(det(P(0,0),a.t-a.s,b.t-b.s)!=0) return false;\n\tif((ccw(a.s,a.t,b.s)&28)==0) return false;\n\n\tusing state=tuple<P,int>;\n\n\tvector<state> ary={state(a.s,0),state(a.t,0),state(b.s,1),state(b.t,1)};\n\tsort(_all(ary));\n\tif(get<1>(ary[0])==get<1>(ary[1])) return false;\n\tif(get<0>(ary[1])==get<0>(ary[2])) return false;\n\treturn true;\n}\n\nbool cgraph[10][10];\nint color[10];\nint dfs(int v,int n,int c){\n\tif(v==n) return c;\n\tset<int> used;\n\trep(i,v) if(cgraph[v][i]) used.insert(color[i]);\n\n\tint ret=10;\n\trep(i,c+1){\n\t\tif(used.find(i)!=used.end()) continue;\n\t\tcolor[v]=i;\n\t\tchmin(ret,dfs(v+1,n,max(i+1,c)));\n\t\tcolor[v]=-1;\n\t}\n\n\treturn ret;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tset<L> pol[110];\n\t\tmap<string,vector<int>> conv;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin >> s; \n\t\t\tconv[s].push_back(i);\n\n\t\t\tint x[110],y[110],m=0;\n\n\t\t\twhile(1){\n\t\t\t\tcin >> x[m];\n\t\t\t\tif(x[m]==-1) break;\n\t\t\t\tcin >> y[m++];\n\t\t\t}\n\n\t\t\trep(j,m){\n\t\t\t\tP a=P(x[j],y[j]);\n\t\t\t\tP b=P(x[(j+1)%m],y[(j+1)%m]);\n\t\t\t\tif(a>b) swap(a,b);\n\t\t\t\tpol[i].insert(L({a,b})); \n\t\t\t}\n\t\t}\n\n\t\tvector<string> ary;\n\t\tfor(auto &it:conv) ary.push_back(it.first);\n\t\tconst int m=ary.size();\n\n\t\tbool graph[110][110];\n\t\tclr(graph,0);\n\t\t\n\t\trep(i,n)rep(j,i){\n\t\t\tfor(auto &line:pol[i]) for(auto &line2:pol[j]){\n\t\t\t\tif(cross(line,line2))\n\t\t\t\t\tgraph[i][j]=graph[j][i]=true;\n\t\t\t}\n\t\t}\n\n\t\tclr(cgraph,0);\n\t\trep(i,m)rep(j,i){\n\t\t\tcgraph[i][j]=cgraph[j][i]=false;\n\t\t\tfor(auto &v:conv[ary[i]]) for(auto &v2:conv[ary[j]]) if(graph[v][v2]) cgraph[i][j]=cgraph[j][i]=true;\n\t\t}\n\n\t\t// rep(i,m){\n\t\t// \trep(j,m) cout << cgraph[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\t\tcout << dfs(0,m,0) << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint isccw(const vi& xs,const vi& ys)\n{\n\tint sum=0;\n\trep(i,xs.size()){\n\t\tint x1=xs[i],x2=xs[(i+1)%xs.size()];\n\t\tint y1=ys[i],y2=ys[(i+1)%ys.size()];\n\t\tsum+=x1*y2-y1*x2;\n\t}\n\tassert(sum);\n\treturn sum>0;\n}\n\nint solve(const vvi& g,int u,vi& color)\n{\n\tint n=g.size();\n\tif(u==n) return *max_element(all(color))+1;\n\tint mx=*max_element(all(color));\n\tint res=INF;\n\tfor(int c=0;c<=u;c++){\n\t\tbool ok=true;\n\t\tfor(int v:g[u])\n\t\t\tif(color[v]==c){\n\t\t\t\tok=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,solve(g,u+1,color));\n\t\t\tcolor[u]=-1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tmap<string,int> ntoi;\n\t\tconst int h=1001,w=1001;\n\t\tvvi grid(h,vi(w,-1));\n\t\trep(_,n){\n\t\t\tstring name; cin>>name;\n\t\t\tntoi.insert(mp(name,ntoi.size()));\n\t\t\tint v=ntoi[name];\n\t\t\tvi xs,ys;\n\t\t\tfor(int x,y;cin>>x && x!=-1;){\n\t\t\t\tcin>>y;\n\t\t\t\txs.push_back(x);\n\t\t\t\tys.push_back(y);\n\t\t\t}\n\t\t\tif(!isccw(xs,ys)){\n\t\t\t\treverse(all(xs));\n\t\t\t\treverse(all(ys));\n\t\t\t}\n\t\t\trep(i,xs.size()){\n\t\t\t\tint x1=xs[i],x2=xs[(i+1)%xs.size()];\n\t\t\t\tint y1=ys[i],y2=ys[(i+1)%ys.size()];\n\t\t\t\tif(x1<x2 && y1==y2)\n\t\t\t\t\trepi(x,x1,x2) grid[y1][x]=v;\n\t\t\t\tif(x1>x2 && y1==y2)\n\t\t\t\t\tperi(x,x2,x1) grid[y1-1][x]=v;\n\t\t\t\tif(x1==x2 && y1<y2)\n\t\t\t\t\trepi(y,y1,y2) grid[y][x1-1]=v;\n\t\t\t\tif(x1==x2 && y1>y2)\n\t\t\t\t\tperi(y,y2,y1) grid[y][x1]=v;\n\t\t\t}\n\t\t}\n\t\t\n\t\tn=ntoi.size();\n\t\tvvi d(n,vi(n));\n\t\trep(i,h) rep(j,w) rep(k,4){\n\t\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\t\tif(ni<0 || h<=ni || nj<0 || w<=nj) continue;\n\t\t\tint u=grid[i][j],v=grid[ni][nj];\n\t\t\tif(u!=-1 && v!=-1 && u!=v) d[u][v]=d[v][u]=1;\n\t\t}\n\t\t\n\t\tvvi g(n);\n\t\trep(i,n) rep(j,n) if(d[i][j])\n\t\t\tg[i].push_back(j);\n\t\t\n\t\t//rep(i,n) dump(g[i]);\n\t\t\n\t\tvi color(n,-1);\n\t\tcout<<solve(g,0,color)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nmap<string,int> idx;\nvector<P> v[N];\nset<string> S;\nbool c[M][M];\nstring s[N];\nstring d[M];\n\ndouble dot(P A,P B){return real(conj(A)*B);}\ndouble cross(P A,P B){return imag(conj(A)*B);}\n\nint ccw(P A, P B, P C){\n  B-=A;\n  C-=A;\n  if(cross(B,C)>EPS)return 1;\n  if(cross(B,C)<-EPS)return -1;\n  if(dot(B,C)<-EPS)return 2;\n  if(norm(B)<norm(C))return -2;\n  return 0;\n}\n\nbool check(P A1,P A2,P B1,P B2){\n  int r1=ccw(A1,A2,B1);\n  int r2=ccw(A1,A2,B2);\n  int r3=ccw(B1,B2,A1);\n  int r4=ccw(B1,B2,A2);\n  if(r1==1||r1==-1||r2==1||r2==-1)return false;\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if(right-left<=EPS)return false;\n  if(!r1||!r2||!r3||!r4)return true;\n  return false;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++)\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      if(c[i][j])return;\n    }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    memset(c,0,sizeof(c));\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)idx[(*ite)]=k;\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tint s1=idx[s[i]],s2=idx[s[j]];\n\tif(s1==s2)continue;\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P A1=v[i][k],A2=v[i][(k+1)%leni];\n\t    P B1=v[j][l],B2=v[j][(l+1)%lenj];\n\t    if(check(A1,A2,B1,B2))c[s1][s2]=c[s2][s1]=true;\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num, const vi &ord){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[ord[d]][ord[i]])use[cols[ord[i]]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[ord[d]] = i;\n\tdfs(d+1,num,ord);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[ord[d]] = num;\n  dfs(d,num+1,ord);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    vector<P> deg(m);\n    rep(i,m){\n      int d = accumulate(all(g[i]),0);\n      deg[i] = P(d,i);\n    }\n    sort(all(deg));\n    vi ord(m);\n    rep(i,m)ord[i] = deg[m-1-i].sc;\n\n    ans = m; cols.resize(m);\n    dfs(0,0,ord);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\tvoid out(Segment& s){\n\t\tcout << s.p1 << ' ' << s.p2 << endl;\n\t}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n\tbool operator == (const Segment &a, const Segment &b){\n\t\treturn (a.p1 == b.p1 and a.p2 == b.p2) or (a.p1 == b.p2 and a.p2 == b.p1);\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\nbool isIntersectedLs_(Point a1, Point a2, Point b1, Point b2) {\n\tdouble ax = a1.real(), ay = a1.imag();\n\tdouble bx = a2.real(), by = a2.imag();\n\tdouble cx = b1.real(), cy = b1.imag();\n\tdouble dx = b2.real(), dy = b2.imag();\n\n\tdouble ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tdouble tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tdouble tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tdouble td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n\treturn tc * td < -EPS and ta * tb < -EPS; // 端点含まず\n\t//return tc * td <= 0 and ta * tb <= 0; // 端点含む\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs_(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint nxt(Polygon& a, int i){\n\treturn a[(i + 1) % a.size()];\n}\n\nbool shareBorder(Polygon& a, Polygon& b){\n\tauto f = [](Segment s1, Segment s2) -> bool{\n\t\tif(isParallel(s1, s2)){\n\t\t\tPoint t = (s1.p1 != s2.p1 and s1.p1 != s2.p2) ? s1.p1 : s1.p2;\n\t\t\tif(ccw(s2.p1, s2.p2, t) == ON_SEGMENT) return true;\n\t\t}\n\t\treturn false;\n\t};\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tSegment s1 = Segment{a[i], nxt(a,i)}, s2 = Segment{b[j], nxt(b,j)};\n\t\t\tif(s1 == s2) return true;\n\n\t\t\tif(f(s1,s2) or f(s2,s1)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tmap<string, vector<Polygon>> ps;\n\t\trep(i,n){\n\t\t\tstring name;\n\t\t\tcin >> name;\n\n\t\t\tPolygon p;\n\t\t\tdouble y, x;\n\t\t\twhile(cin >> y, y != -1){\n\t\t\t\tcin >> x;\n\t\t\t\tp.emplace_back(Point(y,x));\n\t\t\t}\n\t\t\t//show(name)\n\t\t\tps[name].emplace_back(p);\n\t\t}\n\n\t\t//for(auto i : ps){ show(i.first) for(auto j : i.second){ cout << j << endl; } }\n\n\t\tvector<vector<Polygon>> v;\n\t\tfor(auto i : ps){\n\t\t\tv.emplace_back(i.second);\n\t\t}\n\n\t\tvector<int> color(ps.size(), -1);\n\t\trep(i,v.size()){\n\t\t\tset<int> s;\n\t\t\t//show(i)\n\t\t\trep(j,v.at(i).size()){\n\t\t\t\trep(k,v.size()){\n\t\t\t\t\tif(i == k) continue;\n\t\t\t\t\trep(l,v.at(k).size()){\n\t\t\t\t\t\tif(shareBorder(v[i][j], v[k][l])){\n\t\t\t\t\t\t\t//cout << i << ' ' << k << endl;\n\t\t\t\t\t\t\ts.emplace(color[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(j,10){\n\t\t\t\tif(not s.count(j)){\n\t\t\t\t\tcolor[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tset<int> s;\n\t\tfor(auto i : color) s.emplace(i);\n\t\tcout << s.size() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <array>\nusing namespace std;\nconst int inf = 1e9;\nconst double EPS = 1e-10;\nconst double INF = 1e18;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nbool strictItsSP(const L &s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<-EPS;\n}\nbool overlapSS(const L &a, const L &b){\n    return strictItsSP(a, b[0]) || strictItsSP(a, b[1]) ||\n        strictItsSP(b, a[0]) || strictItsSP(b, a[1]) ||\n        (a[0]==b[0] && a[1]==b[1]) || (a[0]==b[1] && a[1]==b[0]);\n}\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\nint color[10];\nint solve(int d, vector<vector<bool> > &adj){\n    if(d==0){\n        int n = adj.size();\n        vector<vector<int> > comp(n);\n        for(int i=0; i<n; i++){\n            comp[color[i]].push_back(i);\n        }\n        int res = 0;\n        for(int i=0; i<n; i++){\n            if(comp[i].empty()) continue;\n            for(int j=0; j<(int)comp[i].size(); j++){\n                for(int k=j+1; k<(int)comp[i].size(); k++){\n                    if(adj[comp[i][j]][comp[i][k]]){\n                        j = inf;\n                        i = n;\n                        res = inf;\n                        break;\n                    }\n                }\n            }\n            res++;\n        }\n        return res;\n    }\n    int res=inf;\n    for(int i=0; i<d; i++){\n        color[d-1] = i;\n        res = min(res, solve(d-1, adj));\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        map<string, int> name;\n        vector<vector<L> > edge;\n        int num = 0;\n        for(int i=0; i<n; i++){\n            string city;\n            cin >> city;\n            if(name.count(city) == 0){\n                name[city] = num;\n                num++;\n                edge.push_back(vector<L>());\n            }\n            VP v;\n            while(1){\n                int x,y;\n                cin >> x;\n                if(x == -1) break;\n                cin >> y;\n                v.push_back(P(x, y));\n            }\n            for(int j=0; j<(int)v.size(); j++){\n                edge[name[city]].push_back(L(v[j], v[(j+1)%v.size()]));\n            }\n        }\n\n        vector<vector<bool> > adj(num, vector<bool>(num, false));\n        for(int i=0; i<num; i++){\n            for(int j=i+1; j<num; j++){\n                for(int k=0; k<(int)edge[i].size(); k++){\n                    for(int l=0; l<(int)edge[j].size(); l++){\n                        if(isParallel(edge[i][k], edge[j][l]) && overlapSS(edge[i][k], edge[j][l])){\n                            adj[i][j] = adj[j][i] = true;\n                            k = edge[i].size();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        cout << solve(num, adj) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define x real()\n#define y imag()\nusing namespace std;\ntypedef complex <double> point;\ntypedef vector <int> V;\nstring str[101];\nvector <point> G[101];\nV node[101];\nmap <string,V> M;\nint n,ans;\n\ndouble dot(point a,point b){return a.x*b.x+a.y*b.y;}\ndouble cross(point a,point b){return a.x*b.y-a.y*b.x;}\n\nint ccw(point a,point b,point c){\n  point d = b-a;\n  point e = c-a;\n  if(cross(d,e)>0) return 1;\n  if(cross(d,e)<0) return -1;\n  if(dot(d,e)<0) return 2;\n  if(abs(d) < abs(e)) return -2;\n  return 0;\n}\n\nbool intersection(point a,point b,point c,point d){\n  if(!(ccw(a,b,c)*ccw(a,b,d)<=0&&ccw(c,d,a)*ccw(c,d,b)<=0))return 0;\n  if(abs(ccw(a,b,c))==1||abs(ccw(a,b,d))==1)return 0;\n  double A=abs(a-b),B=abs(c-d);\n  double D=max(abs(a-c),abs(a-d));\n  D=max(D,max(abs(b-c),abs(b-d)));\n  if(A+B==D) return 0;\n  return 1;\n}\n\nvoid mk_node(){\n  for(int i=0;i<n;i++) node[i].clear();\n  for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++){\n      if(str[i]==str[j])continue;\n      int is=G[i].size(),js=G[j].size();\n      for(int k=0;k<is;k++)\n\tfor(int l=0;l<js;l++){\n\t  point a=G[i][k],b=G[i][(k+1)%is];\n\t  point c=G[j][l],d=G[j][(l+1)%js];\n\t  if((intersection(a,b,c,d)))node[i].push_back(j),k=is,l=js;\n\t}\n    }\n\n  M.clear();\n  for(int i=0;i<n;i++) M[str[i]].push_back(i);\n}\n\nint col[101];\nbool check(){\n  for(int i=0;i<n;i++)\n    for(int j=0;j<node[i].size();j++){\n      if(str[i]!=str[node[i][j]]&&col[i]==col[node[i][j]])return 0;\n    }\n  return 1;\n}\n\nbool nxp(map<string,V>::iterator it,int c){\n  if(it==M.end())return check();\n  V a=it->second;\n\n  for(int i=0;i<=c;i++){\n    for(int j=0;j<a.size();j++)col[a[j]]=i;\n    ans=max(ans,i);\n    if(nxp(++it,i))return 1;\n    it--;\n  }\n  return 0;\n\t }\n\nint main(){\n  while(cin>>n,n){\n    for(int i=0;i<n;i++){\n      G[i].clear();\n      cin>>str[i];\n      while(1){\n\tint a,b;\n\tcin>>a;\n\tif(a==-1) break;\n\tcin>>b;\n\tG[i].push_back(point(a,b));\n      }\n    }\n    mk_node();\n    ans=0;\n    nxp(M.begin(),10);\n    cout <<ans+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\tvoid out(Segment& s){\n\t\tcout << s.p1 << ' ' << s.p2 << endl;\n\t}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n\tbool operator == (const Segment &a, const Segment &b){\n\t\treturn (a.p1 == b.p1 and a.p2 == b.p2) or (a.p1 == b.p2 and a.p2 == b.p1);\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\nbool isIntersectedLs_(Point a1, Point a2, Point b1, Point b2) {\n\tdouble ax = a1.real(), ay = a1.imag();\n\tdouble bx = a2.real(), by = a2.imag();\n\tdouble cx = b1.real(), cy = b1.imag();\n\tdouble dx = b2.real(), dy = b2.imag();\n\n\tdouble ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tdouble tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tdouble tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tdouble td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n\treturn tc * td < -EPS and ta * tb < -EPS; // 端点含まず\n\t//return tc * td <= 0 and ta * tb <= 0; // 端点含む\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs_(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint nxt(Polygon& a, int i){\n\treturn a[(i + 1) % a.size()];\n}\n\nbool isSharedLs(Segment s1, Segment s2){\n\tauto f = [](Segment s1, Segment s2) -> bool{\n\t\t//if(isParallel(s1, s2)){\n\t\t\tPoint t = (s1.p1 != s2.p1 and s1.p1 != s2.p2) ? s1.p1 : s1.p2;\n\t\t\tif(ccw(s2.p1, s2.p2, t) == ON_SEGMENT) return true;\n\t\t//}\n\t\treturn false;\n\t};\n\treturn f(s1, s2) or f(s2, s1) or s1 == s2;\n}\n\nbool shareBorder(Polygon& a, Polygon& b){\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tSegment s1 = Segment{a[i], nxt(a,i)}, s2 = Segment{b[j], nxt(b,j)};\n\t\t\tif(isSharedLs(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvector<vector<Polygon>> input(int n){\n\tmap<string, vector<Polygon>> ps;\n\trep(i,n){\n\t\tstring name;\n\t\tcin >> name;\n\n\t\tPolygon p;\n\t\tdouble y, x;\n\t\twhile(cin >> y, y != -1){\n\t\t\tcin >> x;\n\t\t\tp.emplace_back(Point(y,x));\n\t\t}\n\t\t//show(name)\n\t\tps[name].emplace_back(p);\n\t}\n\n\tvector<vector<Polygon>> res;\n\tfor(auto i : ps){\n\t\tres.emplace_back(i.second);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\t//for(auto i : ps){ show(i.first) for(auto j : i.second){ cout << j << endl; } }\n\t\tvector<vector<Polygon>> countries = input(n); // countries[i] := 国 i が持つ領地\n\t\tint m = countries.size();\n\n\t\tvector<vector<bool>> g(m, vector<bool>(m, 0)); // 国が隣接しているかを表す隣接行列\n\t\trep(i,m){\n\t\t\trep(j,countries[i].size()){\n\t\t\t\trep(k,m){\n\t\t\t\t\trep(l,countries[k].size()){\n\t\t\t\t\t\tif(shareBorder(countries[i][j], countries[k][l])) g[i][k] = g[k][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> color(m, -1);\n\t\trep(i,m){\n\t\t\tset<int> s;\n\t\t\trep(j,m){\n\t\t\t\tif(g[i][j]){\n\t\t\t\t\ts.emplace(color[j]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint k = 0;\n\t\t\twhile(s.count(k)) k++;\n\t\t\tcolor[i] = k;\n\t\t}\n\n\t\tset<int> s;\n\t\tfor(auto i : color) s.emplace(i);\n\t\tcout << s.size() << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tint x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n  int norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn x == p.x && y == p.y;\n\t}\n\n  bool operator != (const Point &p) const {\n\treturn !(*this == p);\n  }\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\nint dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\nint cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) >0) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < 0) return CLOCKWISE;\n\tif (dot(a, b) <= 0) return ONLINE_BACK;\n\tif (a.norm() <= b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Segment s1, Segment s2){\n  int c1 = ccw(s1.p1, s1.p2, s2.p1);\n  int c2 = ccw(s1.p1, s1.p2, s2.p2);\n  switch(c1){\n  case 2:\n\treturn (c2 == -2 || c2 == 0);\n  case -2:\n\treturn (c2 == 2 || c2 == 0);\n  case 0:\n\treturn (c2 == 2 || c2 == 0 || c2 == -2);\n  }\n  return false;\n}\n\nconst int INF = 1e9;\n\nint bc(int b){\n  int res = 0;\n  while(b > 0){\n\tres += b&1;\n\tb >>= 1;\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tVS name(N);\n\tmap<string,int> id;\n\tvector<Polygon> poly(N);\n\tREP(i,N){\n\t  cin >> name[i];\n\t  if(!id.count(name[i])) id[name[i]] = SZ(id)-1;\n\t  while(true){\n\t\tint x; cin >> x;\n\t\tif(x < 0) break;\n\t\tint y; cin >> y;\n\t\tpoly[i].PB(Point(x,y));\n\t  }\n\t}\n\n\tint M = SZ(id);\n\tvector<vector<bool>> xs(M, vector<bool>(M, false));\n\tREP(i,N) FOR(j,i+1,N){\n\t  if(name[i] == name[j]) continue;\n\t  bool ok = false;\n\t  for(int i_=0;i_<SZ(poly[i]);++i_){\n\t\tSegment l1;\n\t\tl1.p1 = poly[i][i_];\n\t\tl1.p2 = poly[i][(i_+1)%SZ(poly[i])];\n\t\tfor(int j_=0;j_<SZ(poly[j]);++j_){\n\t\t  Segment l2;\n\t\t  l2.p1 = poly[j][j_];\n\t\t  l2.p2 = poly[j][(j_+1)%SZ(poly[j])];\n\t\t  if(intersect(l1,l2) || intersect(l2,l1)) ok = true;\n\t\t}\n\t  }\n\t  if(ok){\n\t\tint id1 = id[name[i]], id2 = id[name[j]];\n\t\tif(id1 < id2) swap(id1, id2);\n\t\txs[id1][id2] = xs[id2][id1] = true;\n\t  }\n\t}\n\n\tVI dp(1<<11, INF);\n\tdp[0] = 0;\n\tfor(int s=1;s<1<<M;++s){\n\t  for(int i=s;i>=0;--i){\n\t\ti &= s;\n\t\tint nt = s & (~i);\n\t\tbool ok = true;\n\t\tREP(k,M){\n\t\t  if(nt>>k&1);else continue;\n\t\t  REP(j,M){\n\t\t\tif(nt>>j&1); else continue;\n\t\t\tif(xs[k][j]) ok = false;\n\t\t  }\n\t\t}\n\t\tif(ok) dp[s] = min(dp[s], dp[i]+1);\n\t  }\n\t}\n\tcout << dp[(1<<M)-1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npii operator-(const pii &a,const pii &b){\n    return make_pair(a.first-b.first,a.second-b.second);\n}\n\nvoid solve(int n){\n    map<string,int> t;\n    vector<vector<int>> vs;\n    vector<vector<pii>> ps(n);\n    int size=0;\n    rep(i,0,n){\n        string str;\n        cin >> str;\n        if(t.find(str)==t.end()){\n            t[str]=size;\n            vs.push_back(vector<int>());\n            ++size;\n        }\n        vs[t[str]].push_back(i);\n        while(true){\n            int x,y;\n            cin >> x;\n            if(x==-1) break;\n            cin >> y;\n            ps[i].push_back(make_pair(x,y));\n        }\n    }\n\n    auto cross=[](pii &a,pii &b){\n        return a.first*b.second-a.second*b.first;\n    };\n\n    vector<vector<int>> graph(size);\n    rep(i,0,size) rep(j,0,i){\n        if([&](){\n            rep(k,0,vs[i].size()) rep(l,0,vs[j].size()){\n                rep(i_,0,ps[vs[i][k]].size()) rep(j_,0,ps[vs[j][l]].size()){\n                    pii &p1=ps[vs[i][k]][i_],&p2=ps[vs[i][k]][(i_+1)%ps[vs[i][k]].size()];\n                    pii &q1=ps[vs[j][l]][j_],&q2=ps[vs[j][l]][(j_+1)%ps[vs[j][l]].size()];\n                    pii a=p1-p2,b=q1-q2;\n                    pii c=p1-q2,d=p2-q1;\n                    if(cross(a,b)) continue;\n                    if(cross(c,d)) continue;\n                    if(a.first and (max(p1.first,p2.first)==min(q1.first,q2.first) or min(p1.first,p2.first)==max(q1.first,q2.first))) continue;\n                    if(a.second and (max(p1.second,p2.second)==min(q1.second,q2.second) or min(p1.second,p2.second)==max(q1.second,q2.second))) continue;\n                    return true;\n                }\n            }\n            return false;\n        }()){\n            graph[i].push_back(j);\n            graph[j].push_back(i);\n        }\n    }\n\n    vector<int> dp(1<<size,inf);\n    vector<bool> done(1<<size);\n    dp[0]=0;\n    done[0]=true;\n    rep(i,0,size){\n        dp[1<<i]=1;\n        done[1<<i]=true;\n    }\n    rep(s,0,1<<size) rep(t,0,1<<size){\n        if((s&t)!=t or (s|t)!=s) continue;\n        if(![&](){\n            int d=s&~t;\n            rep(i,0,size){\n                if(!((d>>i)&1)) continue;\n                for(int j:graph[i]) if((d>>j)&1) return false;\n            }\n            return true;\n        }()) continue;\n        dp[s]=min(dp[s],dp[t]+1);\n    }\n\n    cout << dp[(1<<size)-1] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <map>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\nconst double EPS = (1e-7);\nconst int INF = 1 << 20;\ndouble dot(P &a, P &b){ return a.X*b.X + a.Y*b.Y;}\ndouble cross(P &a, P &b){ return a.X*b.Y - a.Y*b.X;}\n\nint ccw( P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < EPS) return 2;\n  if(norm(c) > norm(b) - EPS) return -2;\n  return 0;\n}\n\nbool is_adjacent(vector<P> &A, vector<P> &B){\n  int n = A.size(), m = B.size();\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      P x = A[i], y = A[(i+1)%n], z = B[j], w = B[(j+1)%m];\n      int s = ccw(x,y,z), t = ccw(x,y,w);\n      if(abs(s) == 1 or abs(t) == 1) continue;\n      if(s*t > 0) continue;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    map<string, int> M;\n    vector< vector< vector<P> > > V(n);\n    int t = 1;\n    for(int i = 0; i < n; ++i){\n      string s;\n      cin >> s;\n      vector<P> Poly;\n      if(!M[s]){\n        M[s] = t;\n        ++t;\n      }\n      double x;\n      while(cin >> x, x != -1){\n        double y;\n        cin >> y;\n        Poly.emplace_back(x,y);\n      }\n      V[M[s]-1].emplace_back(Poly);\n    }\n    int c = t-1;\n    vector< vector<int> > G(c, vector<int>(c,0));\n    for(int i = 0; i < c; ++i){\n      for(int j = 0; j < i; ++j){\n        for(int k = 0; k < V[i].size(); ++k){\n          for(int l = 0; l < V[j].size(); ++l){\n            if(is_adjacent(V[i][k], V[j][l])) ++G[i][j], ++G[j][i];\n          }\n        }\n      }\n    }\n\n    /*\n    for(int i=0; i<c; i++) {\n      for(int j=0; j<c; j++) {\n        fprintf(stderr, \"%d \", G[i][j]);\n      }\n      fprintf(stderr, \"\\n\");\n    }\n    */\n    \n\n    vector<int> dp(1 << c, INF);\n    dp[0] = 0;\n    for(int bit=0; bit<(1<<c); bit++) {\n      for(int mask=0; mask<(1<<c); mask++) {\n        if((bit & mask) != 0) continue;\n        bool ok = true;\n        for(int i=0; i<c; i++) {\n          for(int j=0; j<c; j++) {\n            if(!(mask >> i & 1)) continue;\n            if(!(mask >> j & 1)) continue;\n            if(G[i][j]) ok = false;\n          }\n        }\n\n        int nbit = bit | mask;\n        if(ok) dp[nbit] = min(dp[nbit], dp[bit] + 1);\n      }\n    }\n    cout << dp[(1<<c) - 1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_sp(Line s, Point p)\n{\n\tif (s.a == p || s.b == p) return false;\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nbool is_cover(Line s, Line t)\n{\n\tif (isis_ll(s, t)) return false;\n\tif ((s.a == t.a && s.b == t.b) || (s.a == t.b && t.a == s.b)) return true;\n\tint cnt = 0;\n\tif (isis_sp(s, t.a)) cnt++;\n\tif (isis_sp(s, t.b)) cnt++;\n\tif (isis_sp(t, s.a)) cnt++;\n\tif (isis_sp(t, s.b)) cnt++;\n\treturn cnt > 0;\n}\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nint ans;\nint cnt;\nMatrix g;\nvi belong;\n\nvoid solve(int bit, int col)\n{\n\tif (bit == (1 << cnt) - 1)\n\t{\n\t\tchmin(ans, col);\n\t\treturn;\n\t}\n\tif (col == ans) return;\n\tvi white;\n\tREP(i, cnt)\n\t{\n\t\tif (!(bit >> i) & 1)\n\t\t{\n\t\t\twhite.push_back(i);\n\t\t}\n\t}\n\tREP(i, 1<<(white.size()-1))\n\t{\n\t\tvi use;\n\t\tuse.push_back(white[0]);\n\t\tREP(j, white.size() - 1)\n\t\t{\n\t\t\tif ((i >> j) & 1) use.push_back(white[j + 1]);\n\t\t}\n\t\tbool f = false;\n\t\tREP(j, use.size())REP(k, j)\n\t\t{\n\t\t\tif (g[use[j]][use[k]]) f = true;\n\t\t}\n\t\tif (f) continue;\n\t\tint nx = bit;\n\t\tREP(j, use.size()) nx |= 1 << use[j];\n\t\tsolve(nx, col + 1);\n\t}\n}\n\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tbelong.clear();\n\t\tg.clear();\n\t\tbelong.resize(n);\n\t\tans = 10;\n\t\tcnt = 0;\n\t\tvector<Polygon> ps(n);\n\t\tmap<string, int> mp;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (!mp.count(s))\n\t\t\t{\n\t\t\t\tmp[s] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tbelong[i] = mp[s];\n\t\t\tint a, b;\n\t\t\twhile (cin >> a, a >= 0)\n\t\t\t{\n\t\t\t\tcin >> b;\n\t\t\t\tps[i].emplace_back(a, b);\n\t\t\t}\n\t\t}\n\t\tg.resize(cnt, Array(cnt));\n\t\tREP(i, n)REP(j, i)\n\t\t{\n\t\t\tif (belong[i] == belong[j]) continue;\n\t\t\tbool f = false;\n\t\t\tREP(k, ps[i].size())REP(l, ps[j].size())\n\t\t\t{\n\t\t\t\tLine s1(ps[i][k], ps[i][(k + 1) % ps[i].size()]), s2(ps[j][l], ps[j][(l + 1) % ps[j].size()]);\n\t\t\t\tif (is_cover(s1, s2)) f = true;\n\t\t\t}\n\t\t\tif (f)\n\t\t\t{\n\t\t\t\tg[belong[j]][belong[i]] = 1;\n\t\t\t\tg[belong[i]][belong[j]] = 1;\n\t\t\t}\n\t\t}\n\t\tsolve(0, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nvoid dfs(const int now,const vector<vector<int>>&edges, vector<int>&colors) {\n\tset<int>concol;\n\tfor (auto e : edges[now]) {\n\t\tif (colors[e] != -1) {\n\t\t\tconcol.emplace(colors[e]);\n\t\t}\n\t}\n\tfor (int i = 0; i < 100; ++i) {\n\t\tif (concol.find(i) == concol.end()) {\n\t\t\tcolors[now] = i;\n\t\t\tfor (auto e : edges[now]) {\n\t\t\t\tif (colors[e] == -1) {\n\t\t\t\t\tdfs(e, edges, colors);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nint solve(const vector<vector<int>>&edges) {\n\tvector<int>colors(edges.size(),-1);\n\tfor (int i = 0; i < colors.size(); ++i) {\n\t\tif (colors[i] == -1) {\n\t\t\tdfs(0, edges, colors);\n\t\t}\n\t}\n\tint ans = *max_element(colors.begin(), colors.end())+1;\n\treturn ans;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tmap<string, vector<vector<Point>>>mp;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tvector<Point>poly;\n\t\t\twhile (1) {\n\t\t\t\tint x; cin >> x;\n\t\t\t\tif (x == -1)break;\n\t\t\t\tint y; cin >> y;\n\t\t\t\tpoly.emplace_back(x, y);\n\t\t\t}\n\t\t\tmp[st].emplace_back(poly);\n\t\t}\n\t\tvector<vector<int>>edges(mp.size());\n\t\tint fnum = 0;\n\t\tfor (auto f : mp) {\n\t\t\tint tnum = 0;\n\t\t\tfor (auto t : mp) {\n\t\t\t\tif (f == t) {\n\t\t\t\t\ttnum++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool connect = false;\n\t\t\t\tfor (auto fpo : f.second) {\n\t\t\t\t\tfor (auto tpo : t.second) {\n\t\t\t\t\t\tfor (int i = 0; i < fpo.size(); ++i) {\n\t\t\t\t\t\t\tLine fl(fpo[i], fpo[(i + 1) % fpo.size()]);\n\t\t\t\t\t\t\tfor (int j = 0; j < tpo.size(); ++j) {\n\t\t\t\t\t\t\t\tLine tl(tpo[j], tpo[(j + 1) % tpo.size()]);\n\t\t\t\t\t\t\t\tif (is_ll2(fl, tl).size() >= 2)connect = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (connect)edges[fnum].push_back(tnum);\n\t\t\t\ttnum++;\n\t\t\t}\n\t\t\tfnum++;\n\t\t}\n\t\tint ans = solve(edges);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,ans,country_index;\n\nbool adj_check[10][10];\n\n#define NUM 9999999.0\n\nstruct Point{\n\tdouble x,y;\n};\n\nstruct Data{\n\tData(double arg_value,bool arg_is_i){\n\t\tvalue = arg_value;\n\t\tis_i = arg_is_i;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn value < arg.value;\n\t};\n\tdouble value;\n\tbool is_i;\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n\tvoid set(double x1,double y1,double x2,double y2){\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tPoint p1,p2;\n};\n\ntypedef Segment Line;\n\nstruct Region{\n\tvector<Line> Lines;\n};\n\nstruct Country{\n\tint color;\n\tchar name[21];\n\tvector<Region> regions;\n};\n\nstruct Shishimaru{\n\tint colors[10];\n};\n\n\nvoid recursive(Shishimaru shishimaru,int count){\n\n\tif(count == country_index){\n\n\t\tint tmp_max = 0;\n\n\t\tfor(int i = 0; i < country_index; i++){\n\t\t\ttmp_max = max(tmp_max,shishimaru.colors[i]);\n\t\t}\n\n\t\tans  = min(ans,tmp_max);\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < country_index; i++){\n\t\tif(shishimaru.colors[i] != -1)continue;\n\n\t\tbool check[11];\n\t\tfor(int k = 0; k < 11; k++)check[k] = false;\n\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tif(i != k && adj_check[i][k] == true && shishimaru.colors[k] != -1){\n\t\t\t\tcheck[shishimaru.colors[k]] = true;\n\t\t\t}\n\t\t}\n\n\t\tShishimaru next_shishimaru;\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tnext_shishimaru.colors[k] = shishimaru.colors[k];\n\t\t}\n\n\t\tfor(int k = 1; k <= 10; k++){\n\t\t\tif(check[k] == false){\n\t\t\t\tnext_shishimaru.colors[i] = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trecursive(next_shishimaru,count+1);\n\t}\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\ndouble calc_slope(Line line){\n\n\tif(fabs(line.p1.y - line.p2.y) < EPS){\n\t\treturn 0.0;\n\t}else if(fabs(line.p1.x - line.p2.x) < EPS){\n\t\treturn NUM;\n\t}else{\n\t\treturn (line.p1.y-line.p2.y)/(line.p1.x-line.p2.x);\n\t}\n}\n\nvoid solve(){\n\n\tCountry country[N];\n\tcountry_index = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tcountry[i].color = -1;\n\t}\n\n\tchar buf[21];\n\n\tint tmp_index;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s\",buf);\n\n\t\ttmp_index = -1;\n\t\tfor(int i = 0; i < country_index; i++){\n\t\t\tif(strCmp(country[i].name,buf)){\n\t\t\t\ttmp_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(tmp_index == -1){\n\t\t\tstrcpy(country[country_index].name,buf);\n\t\t\ttmp_index = country_index;\n\t\t\tcountry_index++;\n\t\t}\n\n\t\tRegion new_region;\n\t\tLine new_line;\n\n\t\tdouble x,y,pre_x = -1.0,pre_y = -1.0;\n\n\t\twhile(true){\n\t\t\tscanf(\"%lf\",&x);\n\t\t\tif(fabs(x + 1.0) < EPS){\n\t\t\t\tnew_line.p1.x = pre_x;\n\t\t\t\tnew_line.p1.y = pre_y;\n\t\t\t\tnew_line.p2.x = new_region.Lines[0].p1.x;\n\t\t\t\tnew_line.p2.y = new_region.Lines[0].p1.y;\n\t\t\t\tnew_region.Lines.push_back(new_line);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscanf(\"%lf\",&y);\n\n\t\t\tif(fabs(pre_x+1.0) > EPS){\n\t\t\t\tnew_line.p1.x = pre_x;\n\t\t\t\tnew_line.p1.y = pre_y;\n\t\t\t\tnew_line.p2.x = x;\n\t\t\t\tnew_line.p2.y = y;\n\t\t\t\tnew_region.Lines.push_back(new_line);\n\t\t\t}\n\n\t\t\tpre_x = x;\n\t\t\tpre_y = y;\n\t\t}\n\n\t\tcountry[tmp_index].regions.push_back(new_region);\n\t}\n\n\n\tif(country_index == 1){\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < country_index; i++){\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tadj_check[i][k] = false;\n\t\t}\n\t}\n\n\tbool adj_FLG;\n\tdouble tmp_slope;\n\n\tvector<Data> calc_V;\n\n\tfor(int i = 0; i < country_index; i++){\n\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tif(i == k)continue;\n\n\t\t\tadj_FLG = false;\n\n\t\t\tfor(int a = 0; a < country[i].regions.size(); a++){\n\t\t\t\tfor(int b = 0; b < country[k].regions.size(); b++){\n\t\t\t\t\tfor(int c = 0; c < country[i].regions[a].Lines.size(); c++){\n\t\t\t\t\t\tfor(int d = 0; d < country[k].regions[b].Lines.size();d++){\n\n\n\t\t\t\t\t\t\tif(fabs((tmp_slope = calc_slope(country[i].regions[a].Lines[c])) - calc_slope(country[k].regions[b].Lines[d])) < EPS){\n\n\t\t\t\t\t\t\t\tcalc_V.clear();\n\n\t\t\t\t\t\t\t\tif(fabs(tmp_slope) < EPS && country[i].regions[a].Lines[c].p1.y == country[k].regions[b].Lines[d].p1.y &&\n\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.y == country[k].regions[b].Lines[d].p2.y){\n\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p1.x,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p2.x,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p1.x,false));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p2.x,false));\n\n\t\t\t\t\t\t\t\t\tsort(calc_V.begin(),calc_V.end());\n\n\t\t\t\t\t\t\t\t\tif(calc_V[0].is_i != calc_V[1].is_i && fabs(calc_V[1].value - calc_V[2].value) > 0.1){\n\t\t\t\t\t\t\t\t\t\tadj_FLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else if(fabs(tmp_slope-NUM) < EPS && country[i].regions[a].Lines[c].p1.x == country[k].regions[b].Lines[d].p1.x &&\n\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x == country[k].regions[b].Lines[d].p2.x){\n\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p1.y,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p2.y,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p1.y,false));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p2.y,false));\n\n\t\t\t\t\t\t\t\t\tsort(calc_V.begin(),calc_V.end());\n\n\t\t\t\t\t\t\t\t\tif(calc_V[0].is_i != calc_V[1].is_i && fabs(calc_V[1].value - calc_V[2].value) > 0.1){\n\t\t\t\t\t\t\t\t\t\tadj_FLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else if(fabs(tmp_slope-0.0) > EPS && fabs(tmp_slope-NUM) > EPS){\n\n\t\t\t\t\t\t\t\t\tif(func(country[i].regions[a].Lines[c].p1.x,country[i].regions[a].Lines[c].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x,country[i].regions[a].Lines[c].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p1.x,country[k].regions[b].Lines[d].p1.y)*\n\t\t\t\t\t\t\t\t\t\tfunc(country[i].regions[a].Lines[c].p1.x,country[i].regions[a].Lines[c].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x,country[i].regions[a].Lines[c].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p2.x,country[k].regions[b].Lines[d].p2.y) <= 0 &&\n\t\t\t\t\t\t\t\t\t\tfunc(country[k].regions[b].Lines[d].p1.x,country[k].regions[b].Lines[d].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p2.x,country[k].regions[b].Lines[d].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p1.x,country[i].regions[a].Lines[c].p1.y)*\n\t\t\t\t\t\t\t\t\t\tfunc(country[k].regions[b].Lines[d].p1.x,country[k].regions[b].Lines[d].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p2.x,country[k].regions[b].Lines[d].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x,country[i].regions[a].Lines[c].p2.y) <= 0){\n\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p1.x,true));\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p2.x,true));\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p1.x,false));\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p2.x,false));\n\n\t\t\t\t\t\t\t\t\t\tsort(calc_V.begin(),calc_V.end());\n\n\t\t\t\t\t\t\t\t\t\tif(calc_V[0].is_i != calc_V[1].is_i && fabs(calc_V[1].value - calc_V[2].value) > 0.1){\n\t\t\t\t\t\t\t\t\t\t\tadj_FLG = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(adj_FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(adj_FLG)break;\n\t\t\t\t}\n\t\t\t\tif(adj_FLG)break;\n\t\t\t}\n\n\t\t\tif(adj_FLG){\n\t\t\t\tadj_check[i][k] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\tfor(int i = 0; i < country_index; i++){\n\t\tShishimaru shishi;\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tshishi.colors[k] = -1;\n\t\t}\n\t\tshishi.colors[i] = 1;\n\t\trecursive(shishi,1);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < EPS)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() - EPS < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定(平行でない)\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS;\n}\n// 二直線の同一判定\nbool equalLL(const Line& l, const Line& m){\n  return abs(cross(l.vector(), m[0] - l[0])) < EPS;\n}\n// 直線と線分の交差判定(同一直線上にある場合も含む)\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(l.vector(), m.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = prev(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nbool is_adj(Polygon& P, Polygon& Q){\n  REP(i, P.size())REP(j, Q.size())if(intersectSS(Line(curr(P, i), next(P, i)), Line(curr(Q, j), next(Q, j)))) return true;\n  return false;\n}\nint dfs(int K, int maxc, bool d[10][10], int M, int color[10]){\n  if(K == M) return maxc;\n  int res = INF;\n  for(int c = 1; c <= maxc; c++){\n    bool ok = true;\n    REP(i, K) if(d[i][K] && color[i] == c) ok = false;\n    if(!ok) continue;\n    color[K] = c;\n    res = min(res, dfs(K + 1, maxc, d, M, color));\n  }\n  color[K] = maxc + 1;\n  res = min(res, dfs(K + 1, maxc + 1, d, M, color));\n  return res;\n}\nint main(){\n  int N;\n  while(cin>>N && N){\n    map<string, int> id;\n    vector<string> name(N);\n    vector<Polygon> terry;\n    REP(i, N){\n      cin>>name[i];\n      if(!id.count(name[i])){\n        int t = id.size();\n        id[name[i]] = t;\n      }\n      Polygon P;\n      double x, y;\n      while(cin>>x && x != -1){\n        cin>>y;\n        P.push_back(Point(x, y));\n      }\n      terry.push_back(P);\n    }\n    int M = id.size();\n    bool t[10][10] = {};\n    REP(i, N)FOR(j, i + 1, N){\n      int a = id[name[i]], b = id[name[j]];\n      if(is_adj(terry[i], terry[j]) && a != b){\n        t[a][b] = t[b][a] = true;\n      }\n    }\n    int color[10];\n    cout<<dfs(0, 0, t, M, color)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num, const int &clique){\n  if(num >= ans || num>=m)return;\n  if(d==m){ ans = num; return; }\n  if((clique>>d)&1)dfs(d+1,num,clique);\n\n  vi use(num,0);\n  rep(i,m){\n    if(i<d || (clique>>i)&1){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n  }\n  \n  rep(i,num){\n    if(!use[i]){\n      cols[d] = i;\n      dfs(d+1,num,clique);\n      if(num>=ans)return;\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1,clique);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    int clique = 1, s = 1;\n    for(int bit=1;bit<(1<<m);bit++){\n      int p = __builtin_popcount(bit);\n      if(p<=s)continue;\n      bool f = true;\n      rep(i,m)rep(j,i){\n\tif( ((bit>>i)&1) && ((bit>>j)&1) && !g[i][j])f = false;\n      }\n      if(f){\n\tclique = bit; s = p;\n      }\n    }\n\n    cols.resize(m);\n    s = 0;\n    rep(i,m){\n      if((clique>>i)&1)cols[i] = s++;\n    }\n\n    ans = m;\n    dfs(0,s,clique);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> L;\ntypedef vector<xy_t> polygon;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define DI(l) ((l).second-(l).first)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n\ndouble cross(const xy_t &a, const xy_t &b) { return imag(conj(a)*b); }\ndouble dot(const xy_t& a, const xy_t& b) { return real(conj(a)*b); }\n\nint ccw(xy_t a, xy_t b, xy_t c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\n\nL shorten(const L &l){\n  xy_t p1 = l.first;\n  xy_t p2 = l.second;\n  \n  if(p1.real() > p2.real()){\n    p1.real() -= EPS;\n    p2.real() += EPS;\n  }else if(p1.real() < p2.real()){\n    p1.real() += EPS;\n    p2.real() -= EPS;\n  }\n\n  if(p1.imag() > p2.imag()){\n    p1.imag() -= EPS;\n    p2.imag() += EPS;\n  }else if(p1.imag() < p2.imag()){\n    p1.imag() += EPS;\n    p2.imag() -= EPS;\n  }\n  return L(p1, p2);\n}\n\nbool share_border(const polygon &p1, const polygon &p2){\n  int n = p1.size();\n  int m = p2.size();\n  REP(i, n)REP(j, m){\n    L l1 = shorten(L(p1[i], p1[(i+1)%n]));\n    L l2 = L(p2[j], p2[(j+1)%m]);\n    if(sameline(l1, l2) && intersectSS(l1, l2)) return true;\n  } \n  return false;\n}\n\nbool dfs(int v, const vector<vector<bool> > &g, vector<int> &color, int C){\n  int n = g.size();\n  if(v == n) return true;\n  REP(c, C){\n    bool ok = true;\n    REP(i, n) if(g[v][i] && color[i] == c) ok = false;\n    if(ok){\n      color[v] = c;\n      if(dfs(v + 1, g, color, C)) return true;\n      color[v] = -1;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    vector<vector<bool> > g(n, vector<bool>(n, false));\n    vector<string> names(n);\n    vector<polygon> polys(n);\n    REP(i, n){\n      cin >> names[i];\n      int x, y;\n      while(cin >> x && x != -1 && cin >> y) polys[i].PB(xy_t(x, y));\n    }\n    REP(i, n)REP(j, i) g[i][j] = g[j][i] = share_border(polys[i], polys[j]);\n    \n    vector<int> color(n, -1);\n    if(dfs(0, g, color, 1)){\n      cout << 1 << endl;\n    }else if(dfs(0, g, color, 2)){\n      cout << 2 << endl;\n    }else if(dfs(0, g, color, 3)){\n      cout << 3 << endl;\n    }else{\n      cout << 4 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\n\nint cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(l==Alen+Blen)r=false;\n  if(B1.Y||B2.Y)r=false;\n  return r;\n}\n\nvoid func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0,k1=0,k2;\n    for(ite=S.begin();ite!=S.end();ite++,k1++){\n      set<string>::iterator ite2=ite;\n      ite2++;\n      k2=k1+1;\n      while(ite2!=S.end()){\n\tif(mark[k1]!=mark[k2]){\n\t  ite2++;\n\t  k2++;\n\t  continue;\n\t}\n\tif(z.find(P1((*ite),(*ite2)))!=z.end()){\n\t  f=1;\n\t  break;\n\t}\n\tite2++;\n\tk2++;\n      }\n      if(f)break;\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++){\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2)){\n\t      z.insert(P1(s1,s2));\n\t    }\n\t  }\n\t}\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 105\n#define M 15\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nstring d[M];\nset<P1> z;\n\ndouble dot(P A,P B){return real(conj(A)*B);}\ndouble cross(P A,P B){return imag(conj(A)*B);}\n\nint ccw(P A, P B, P C){\n  B-=A;\n  C-=A;\n  if(cross(B,C)>EPS)return 1;\n  if(cross(B,C)<-EPS)return -1;\n  if(dot(B,C)<-EPS)return 2;\n  if(norm(B)<norm(C))return -2;\n  return 0;\n}\n\nbool check(P A1,P A2,P B1,P B2){\n  int r1=ccw(A1,A2,B1);\n  int r2=ccw(A1,A2,B1);\n  int r3=ccw(B1,B2,A1);\n  int r4=ccw(B1,B2,A2);\n  if(r1==1||r1==-1||r2==1||r2==-1)return false;\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if(right-left<=EPS)return false;\n  if(!r1||!r2||!r3||!r4)return true;\n  return false;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++){\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      string s1=min(d[i],d[j]);\n      string s2=max(d[i],d[j]);\n      if(z.find(P1(s1,s2))!=z.end())return;\n    }\n  }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P A1=v[i][k],A2=v[i][(k+1)%leni];\n\t    P B1=v[j][l],B2=v[j][(l+1)%lenj];\n\t    if(check(A1,A2,B1,B2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\nint n;\nstring str[100];\nvector<pair<int, int>> xy[100];\n//-----------------------------------------------------------------\nbool isAdjacent(int a, int b) {\n\trep(i, 0, xy[a].size()) rep(j, 0, xy[b].size()) {\n\t\tint ii = (i + 1) % xy[a].size();\n\t\tint jj = (j + 1) % xy[b].size();\n\n\t\tint x_a = xy[a][i].first - xy[a][ii].first;\n\t\tint y_a = xy[a][i].second - xy[a][ii].second;\n\t\tint x_b = xy[b][j].first - xy[b][jj].first;\n\t\tint y_b = xy[b][j].second - xy[b][jj].second;\n\n\t\tif (x_a == 0 && x_b == 0) {\n\t\t\tif (max(xy[a][i].second, xy[a][ii].second) <= min(xy[b][j].second, xy[b][jj].second)) continue;\n\t\t\tif (max(xy[b][j].second, xy[b][jj].second) <= min(xy[a][i].second, xy[a][ii].second)) continue;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (x_a*y_b == x_b*y_a) {\n\t\t\tif (max(xy[a][i].first, xy[a][ii].first) <= min(xy[b][j].first, xy[b][jj].first)) continue;\n\t\t\tif (max(xy[b][j].first, xy[b][jj].first) <= min(xy[a][i].first, xy[a][ii].first)) continue;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n//-----------------------------------------------------------------\nint E[100][100];\nint C[100];\nmap<string, set<int>> M;\nvector<set<int>> MM;\nint ans;\nvoid dfs(int cur, int mnum) {\n\tif (cur == MM.size()) {\n\t\tans = min(ans, mnum);\n\t\treturn;\n\t}\n\trep(i, 1, mnum + 2) {\n\t\tbool ok = true;\n\t\tfor (int j : MM[cur]) rep(k, 0, n) if (E[j][k] && C[k] == i) ok = false;\n\t\tif (ok) {\n\t\t\tfor (int j : MM[cur]) C[j] = i;\n\t\t\tdfs(cur + 1, max(i, mnum));\n\t\t}\n\t}\n}\nint solve() {\n\trep(i, 0, n) rep(j, 0, n) E[i][j] = 0;\n\trep(i, 0, n) rep(j, i + 1, n) if (isAdjacent(i, j)) E[i][j] = E[j][i] = 1;\n\n\trep(i, 0, n) C[i] = 0;\n\n\tM.clear();\n\trep(i, 0, n) M[str[i]].insert(i);\n\n\tMM.clear();\n\tfor (auto p : M) MM.push_back(p.second);\n\t\n\tans = 10;\n\tdfs(0, 0);\n\n\treturn ans;\n}\n//-----------------------------------------------------------------\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) return 0;\n\n\t\trep(i, 0, n) {\n\t\t\tcin >> str[i];\n\n\t\t\txy[i].clear();\n\t\t\tint x, y;\n\t\t\twhile (cin >> x) {\n\t\t\t\tif (x < 0) break;\n\t\t\t\tcin >> y;\n\t\t\t\txy[i].push_back({ x, y });\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#include<climits>\n#include<map>\n#include<set>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define EPS (1e-10)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define MAX 20\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\n\n// Library - template - begin\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -IINF,double y = -IINF): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator == (const Segment& p)const\n  {\n    return p.p1 == p1 && p.p2 == p2;\n  }\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a)\n{\n  os << \"(\" << a.x << \",\" << a.y << \")\";\n}\n\nostream& operator << (ostream& os,const Segment& a)\n{\n  os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\";\n}\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad は角度をラジアンで持たせること\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// 度をラジアンに変換\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n// Library - template - end\n\n// Library - CCW - begin\n\nint ccw(Point p0,Point p1,Point p2)\n{\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\n// Library - CCW - end\n\n// Library - intersect - begin\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\nPoint crosspoint(Line l, Line m) {\n  double A = cross(l.p2 - l.p1, m.p2 - m.p1);\n  double B = cross(l.p2 - l.p1, l.p2 - m.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return m.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m.p1 +   (m.p2 - m.p1) * (B / A);\n}\n\n// Library - intersect - end\n\n// Library - Dent - begin\n\n\nint pow(int x,int n)\n{\n  int res = 1;\n  for(;n;n>>=1)\n    {\n      if(n&1)res = res*x;\n      x = x * x;\n    }\n  return res;\n}\n\nint chromatic_number(vector<vector<int> > &M)\n{\n  int n = M.size();\n  vector<int> F(n);\n  rep(i,n)\n    {\n      F[i] |= 1<<i;\n      rep(j,n)\n\t{\n\t  if(M[i][j])F[i] |= 1 << j;\n\t}\n    }\n\n  vector<int> I(1<<n);\n  I[0] = 1;\n  for(int i=1;i<(1<<n);i++)\n    {\n      int v = __builtin_ctz(i);\n      I[i] = I[i^(1<<v)] + I[i & ~F[v]];\n    }\n  int low = 0,high = n;\n  while(low+1 < high)\n    {\n      int k = (low+high)/2,g = 0;\n      rep(i,(1<<n))\n\t{\n\t  if(__builtin_popcount(i) & 1)\n\t    {\n\t      g -= pow(I[i],k);\n\t    }\n\t  else\n\t    {\n\t      g += pow(I[i],k);\n\t    }\n\t}\n      if(g != 0)high = k;\n      else low = k;\n    }\n  return high;\n}\n\n// Library - Dent - end\n\nstruct P\n{\n  Point p;\n  int type;\n  P(Point p=Point(),int type=IINF):p(p),type(type){}\n  bool operator < (const P& a)const\n  {\n    if(!(p == a.p))return p < a.p;\n    return type < a.type;\n  }\n};\n\nbool isParallel(Vector a,Vector b)\n{\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2)\n{\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2)\n{\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool intersect(Segment seg1,Segment seg2)\n{\n  if(!isParallel(seg1,seg2))return false;\n\n  double dist = distanceSS(seg1,seg2);\n\n  if(!equals(dist,0.0))return false;\n\n  vector<P> vec;\n  \n  vec.push_back(P(seg1.p1,0));\n  vec.push_back(P(seg1.p2,0));\n  vec.push_back(P(seg2.p1,1));\n  vec.push_back(P(seg2.p2,1));\n  sort(vec.begin(),vec.end());\n  if(vec[1].p == vec[2].p)return false;\n  \n  return true;\n\n}\n\nvector<int> G[MAX];\n\nint main()\n{\n\n  int N;\n  while(cin >> N,N)\n    {\n      map<string,int> Index;\n      int dex = 0;\n      string country[N];\n      vector<Point> coor[N];\n      int index[N];\n\n      rep(i,N)\n\t{\n\t  cin >> country[i];\n\t  if(Index.find(country[i]) == Index.end())Index[country[i]] = dex++;\n\t  int x,y;\n\t  while(cin >> x, x != -1)\n\t    {\n\t      cin >> y;\n\t      coor[i].push_back(Point(x,y));\n\t    }\n\t}\n\n      rep(i,N)\n\t{\n\t  index[i] = Index[country[i]];\n\t  //cout << \"index[\" << i << \"] = \" << index[i] << endl;\n\t}\n      int n = Index.size();\n      rep(i,n)G[i].clear();\n\n      set<ii> used;\n\n      rep(i,N)\n\t{\n\t  REP(j,i+1,N)\n\t    {\t \n\t      if(index[i] == index[j])continue;\n\t      if(used.find(ii(index[i],index[j])) != used.end())continue;\n\n\t      vector<Point> vec;\n\t      bool check = false;\n\t      \n\t      rep(k,coor[i].size())\n\t\t{\n\t\t  Segment seg1 = Segment(coor[i][k],coor[i][(k+1)%coor[i].size()]);\n\t\t  rep(l,coor[j].size())\n\t\t    {\n\t\t      Segment seg2 = Segment(coor[j][l],coor[j][(l+1)%coor[j].size()]);\n\n\t\t      if(intersect(seg1,seg2))\n\t\t\t{\n\t\t\t  check = true;\n\t\t\t  goto Skip;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    Skip:;\t      \n\t      if(check)\n\t\t{\n\t\t  used.insert(ii(index[i],index[j]));\n\t\t  used.insert(ii(index[j],index[i]));\n\t\t  G[index[i]].push_back(index[j]);\n\t\t  G[index[j]].push_back(index[i]);\n\t\t}\n\t    }\n\t}\n      /*\n      cout << \"Graph === \" << endl;\n      rep(i,n)\n\t{\n\t  cout << \"i = \" << i << endl;\n\t  rep(j,G[i].size())\n\t    {\n\t      cout << G[i][j];\n\t    }\n\t  cout << endl;\n\t}\n      */\n      vector<vector<int> > M(n,vector<int>(n,0));\n      //cout << \"n = \" << n << endl;\n      rep(i,n)\n\t{\n\t  rep(j,G[i].size())\n\t    {\n\t      int to = G[i][j];\n\t      M[i][to] = M[to][i] = 1;\n\t    }\n\t}      \n      //cout << \"-----------222----\" << endl;\n      cout << chromatic_number(M) << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> L;\ntypedef vector<xy_t> polygon;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define DI(l) ((l).second-(l).first)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n\ndouble cross(const xy_t &a, const xy_t &b) { return imag(conj(a)*b); }\ndouble dot(const xy_t& a, const xy_t& b) { return real(conj(a)*b); }\n\nint ccw(xy_t a, xy_t b, xy_t c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\n\nL shorten(const L &l){\n  xy_t p1 = l.first;\n  xy_t p2 = l.second;\n  \n  if(p1.real() > p2.real()){\n    p1.real() -= EPS;\n    p2.real() += EPS;\n  }else if(p1.real() < p2.real()){\n    p1.real() += EPS;\n    p2.real() -= EPS;\n  }\n\n  if(p1.imag() > p2.imag()){\n    p1.imag() -= EPS;\n    p2.imag() += EPS;\n  }else if(p1.imag() < p2.imag()){\n    p1.imag() += EPS;\n    p2.imag() -= EPS;\n  }\n  return L(p1, p2);\n}\n\nbool share_border(const polygon &p1, const polygon &p2){\n  int n = p1.size();\n  int m = p2.size();\n  REP(i, n)REP(j, m){\n    L l1 = shorten(L(p1[i], p1[(i+1)%n]));\n    L l2 = L(p2[j], p2[(j+1)%m]);\n    if(sameline(l1, l2) && intersectSS(l1, l2)) return true;\n  } \n  return false;\n}\n\nbool dfs(int v, const vector<vector<bool> > &g, vector<int> &color, int C){\n  int n = g.size();\n  if(v == n) return true;\n  REP(c, C){\n    bool ok = true;\n    REP(i, v) if(g[v][i] && color[i] == c) ok = false;\n    \n    if(ok){\n      color[v] = c;\n      if(dfs(v + 1, g, color, C)) return true;\n      color[v] = -1;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n > 0){\n    vector<string> names(n);\n    map<string, int> ID;\n    vector<polygon> polys(n);\n    \n    REP(i, n){\n\n      cin >> names[i];\n      if(ID.find(names[i]) == ID.end()){\n\tint count = ID.size();\n\tID[names[i]] = count;\n      }\n      int x, y;            \n      while(cin >> x && x != -1 && cin >> y){\n\tpolys[i].PB(xy_t(x, y));\n      }\n    }\n\n    int c_size = ID.size();\n    vector<vector<bool> > g(c_size, vector<bool>(c_size, false));    \n    \n    REP(i, n)REP(j, i)if(share_border(polys[i], polys[j])){\n      g[ID[names[i]]][ID[names[j]]] = true;\n      g[ID[names[j]]][ID[names[i]]] = true;      \n    }\n\n    \n    vector<int> color(c_size, -1);\n    // REP(i, c_size)REP(j, c_size) cout << g[i][j] << (j + 1 == c_size ? '\\n': ' ');\n    \n    if(dfs(0, g, color, 1)){\n      cout << 1 << endl;\n    }else if(dfs(0, g, color, 2)){\n      cout << 2 << endl;\n    }else if(dfs(0, g, color, 3)){\n      cout << 3 << endl;\n    }else{\n      cout << 4 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - s.a) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\nld slope(segment s) {\n    if(abs(real(s.a) - real(s.b)) < eps) {\n        return 1e18;\n    }\n    return abs((imag(s.a) - imag(s.b)) / (real(s.a) - real(s.b)));\n}\n\nbool is_on(segment s1, segment s2) {\n    if(dist_ss(s1, s2) > eps) {\n        return false;\n    }\n    if(abs(slope(s1) - slope(s2)) > eps) {\n        return false;\n    }\n    vector<pair<point, int>> v;\n    v.emplace_back(s1.a, 0); v.emplace_back(s1.b, 0);\n    v.emplace_back(s2.a, 1); v.emplace_back(s2.b, 1);\n    sort(v.begin(), v.end(), [](auto const& p1, auto const& p2) {\n        if(abs(real(p1.first) - real(p2.first)) < eps) {\n            if(abs(imag(p1.first) - imag(p2.first)) < eps) {\n                return p1.second < p2.second;\n            }\n            return imag(p1.first) < imag(p2.first);\n        }\n        return real(p1.first) < real(p2.first);\n    });\n    if(abs(v[1].first - v[2].first) < eps) {\n        return false;\n    }\n    return true;\n}\n\n\nvoid solve(vector<int>& color, vector<vector<bool>> const& f, int i, int k, int& res) {\n    const int N = color.size();\n    if(k >= res) {\n        return;\n    }\n    if(i == N) {\n        res = k;\n        return;\n    }\n    vector<bool> used(N);\n    for(int j=0; j<N; ++j) {\n        if(color[j] != -1 && f[i][j]) {\n            used[color[j]] = true;\n        }\n    }\n    for(int j=0; j<k+1; ++j) {\n        if(!used[j]) {\n            color[i] = j;\n            solve(color, f, i+1, max(j+1, k), res);\n        }\n    }\n    color[i] = -1;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        map<string, int> id;\n        vector<int> ter_id(n);\n        vector<polygon> ter(n);\n        for(int i=0; i<n; ++i) {\n            string s;\n            cin >> s;\n            if(id.count(s) == 0) {\n                id[s] = id.size()-1;\n            }\n            ter_id[i] = id[s];\n            int x, y;\n            polygon p;\n            while(cin >> x, x != -1) {\n                cin >> y;\n                p.emplace_back(ld(x), ld(y));\n            }\n            ter[i] = p;\n        }\n        int res = 10;\n        vector<vector<bool>> f(id.size(), vector<bool>(id.size()));\n        for(int i=0; i<id.size(); ++i) {\n            f[i][i] = true;\n        }\n        vector<int> color(id.size(), -1);\n        for(int i=0; i<ter.size(); ++i) {\n            for(int j=i+1; j<ter.size(); ++j) {\n                bool connect = false;\n                for(int k=0; k<ter[i].size(); ++k) {\n                    segment s1(ter[i][k], ter[i][(k+1)%ter[i].size()]);\n                    for(int l=0; l<ter[j].size(); ++l) {\n                        segment s2(ter[j][l], ter[j][(l+1)%ter[j].size()]);\n                        connect |= is_on(s1, s2);\n                    }\n                }\n                f[ter_id[i]][ter_id[j]] = f[ter_id[i]][ter_id[j]] | connect;\n                f[ter_id[j]][ter_id[i]] = f[ter_id[j]][ter_id[i]] | connect;\n            }\n        }\n        solve(color, f, 0, 1, res);\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\ntypedef vector<P> G;\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\n\nbool intersectSS(const L &s, const L &t) {\n  REP(i, 4) {\n    int c = ccw(s[i&1],s[!(i&1)],t[!(i>>1&1)]);\n    if (s[i&1]==t[i>>1&1]&&c!=-2&&c)\n      return 0;\n  }\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n\nbool intersectGG(G a, G b) {\n  a.push_back(a[0]);\n  b.push_back(b[0]);\n  REP(i, a.size()-1)\n    REP(j, b.size()-1)\n      if (intersectSS(L(a[i], a[i+1]), L(b[j], b[j+1])))\n        return 1;\n  return 0;\n}\n\nint n;\nint num;\n\nvector<int> graph[10];\nint color[10];\n\nint dfs(int id, int maxcolor) {\n  if (id == num) return maxcolor;\n  int res = INF;\n  for (int i=1; i<=maxcolor; ++i) {\n    bool dame = 0;\n    FOR(it, graph[id]) {\n      if (color[*it] == i) {\n        dame = 1;\n        break;\n      }\n    }\n    if (!dame) {\n      color[id] = i;\n      res = min(res, dfs(id+1, maxcolor));\n    }\n  }\n  color[id] = maxcolor+1;\n  res = min(res, dfs(id+1, maxcolor+1));\n  return res;\n}\n\nint main() {\n  //cout << intersectSS(L(P(100,100), P(100,0)), L(P(100,100), P(100,200))) << endl;\n  while(cin >> n, n) {\n    vector<G> polygon[n];\n    num = 0;\n    map<string, int> id;\n    REP(i, n) {\n      string name;\n      cin >> name;\n      int x, y;\n      G tmp;\n      while(cin >> x, x!=-1) {\n        cin >> y;\n        tmp.push_back(P(x,y));\n      }\n      if (id.count(name) == 0) id[name] = num++;\n      polygon[id[name]].push_back(tmp);\n    }\n    REP(i, num) graph[i].clear();\n    REP(i, num) {\n      REP(j, i) {\n        FOR(it, polygon[i]) {\n          FOR(jt, polygon[j]) {\n            if (intersectGG(*it, *jt)) {\n              graph[i].push_back(j);\n              graph[j].push_back(i);\n              goto NEXT;\n            }\n          }\n        }\n      NEXT:;\n      }\n    }\n    // REP(i, num) {\n    //   cout << i << \" : \";\n    //   FOR(it, graph[i])\n    //     cout << *it << \" \";\n    //   cout << endl;\n    // }\n    memset(color, 0, sizeof(color));\n    cout << dfs(0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace point_2d {\n\nusing Real = double;\n\nReal const EPS = 1e-7;  // !!! DO CHECK EPS !!!\n\ntypedef complex<Real> P;\n\nbool operator < (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() < r.imag() : l.real() < r.real();\n}\n\nbool operator > (P const& l, P const& r) {\n  return abs(l.real() - r.real()) < EPS ? l.imag() > r.imag() : l.real() > r.real();\n}\n\nbool equals (P const& l, P const& r) {\n  return abs(l - r) <= EPS;\n}\n\n//bool operator == (P const& l, P const& r) {return equals(l, r);}\n\nstruct Line : public pair<P, P> {\n  Line(P const& a, P const& b) { first = a, second = b; }\n  const P& operator[] (int x) const { return x == 0 ? first : second; }\n  P& operator[] (int x) { return x == 0 ? first : second; }\n};\ntypedef Line Segment;\n\nstruct Circle : public P {\n  P& p = *this; Real r;\n  Real(&cent)[2] = reinterpret_cast<Real(&)[2]>(*this);\n  Circle(){}\n  Circle(P const& p, Real r): r(r) { this->p = p; }\n};\n\nstruct Polygon : public vector<P> {\n  vector<P>& g = *this;\n  Polygon() = default;\n  Polygon(vector<P> const& g) { this->g = g; }\n  P& operator[] (int x) { return vector<P>::operator[]((x + size()) % size()); }\n  Segment side(int x) { return std::move(Segment(this->operator[](x), this->operator[](x+1))); }\n  Segment backside(int x) { return std::move(Segment(this->operator[](x), this->operator[](x-1))); }\n};\n\nReal cross(P const& a, P const& b) { return imag(conj(a)*b); }\nReal dot(P const& a, P const& b) { return real(conj(a)*b); }\nReal cos(P const& l, P const& r) { return dot(l, r) / (abs(l) * abs(r)); }  // not verified\n\nenum ccw_result {\n  counter_clockwise = +1, clockwise = -1, online_back = +2, online_front = -2, on_end_point = 3, on_segment = 0, inside = 4\n};\n\nccw_result ccw(P a, P b, P c) {\n  b -= a, c -= a;\n  if(cross(b, c) > 0)   { return ccw_result::counter_clockwise; }\n  if(cross(b, c) < 0)   { return ccw_result::clockwise; }\n  if(dot(b, c) < 0)     { return ccw_result::online_back; }\n  if(norm(c) < EPS) { return ccw_result::on_end_point; } // INSERTED\n  if(abs(abs(norm(b)) - abs(norm(c))) < EPS) { return ccw_result::on_end_point; } // INSERTED\n  if(norm(b) < norm(c)) { return ccw_result::online_front; }\n  return ccw_result::inside;  // inside\n}\n\nbool intersect_lp(Line const& l, P const& p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nbool intersect_sp(Line const& s, P const& p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\n\nbool intersect_ss(Segment const& s, Segment const& t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= EPS &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= EPS;\n}\n\nbool intersect_ll(Line const& l, Line const& m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\n\nbool intersect_ls(Line const& l, Segment const& s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\nP projection(Line const& l, P const& p) {\n  auto t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP reflection(Line const& l, P const& p) {\n  return p + (Real)2.0 * (projection(l, p) - p);\n}\n\nReal distance_sp(Line const& s, P const& p) {\n  P const r = projection(s, p);\n  if(intersect_sp(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\n\nReal distance_lp(Line const& l, P const& p) {\n  return abs(p - projection(l, p));\n}\n\nbool intersect_cl(Circle const& c, Line const& l) {\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nbool intersect_cs(Circle const& c, Line const& l) {\n  if(abs(l[0] - c) < c.r - EPS && abs(l[1] - c) < c.r - EPS) { return false; }\n  return distance_lp(l, c) <= c.r + EPS;\n}\n\nbool intersect_gs(Polygon const& g, Segment const& s) { // not verified\n  auto u = const_cast<Polygon&>(g);\n  rep(i, g.size()) {\n    if(!intersect_sp(s, u[i]) && intersect_ss(s, u.side(i))) { return true; }\n  }\n  return false;\n}\n\nP crosspoint(const Line &l, const Line &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if(abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\npair<P, P> crosspoint(Circle const& c, Line const& l) {\n  auto h = projection(l, c);\n  auto e = (l[1]-l[0]) / abs(l[1]-l[0]);\n  auto base = sqrt(c.r*c.r-abs(h-c)*abs(h-c));\n  return {h+e*base, h-e*base};\n}\n\n// テゥツ?堙・ツクツクclangテ」ツ?ァテ」ツ?づ」ツつ古」ツ?ーテ」ツ??(x, y)\"テ」ツ?ョテ・ツスツ「テ・ツシツ湘」ツつ津ィツェツュテ」ツ?ソテ・ツ渉姪」ツつ凝」ツ?古」ツ??」ツ?禿」ツつ古」ツつ?x y\"テ」ツ?ォテ・ツ、ツ嘉ヲツ崢エテ」ツ?凖」ツつ?\nistream& operator >> (istream& is, P& p) { Real x, y; is >> x >> y; p = P(x, y); return is; }\nostream& operator << (ostream& os, Line const& l) { return os << \"{\" << l[0] << \", \" << l[1] << \"}\"; }\n\n}\nusing namespace point_2d;\n\nbool adjacent(Polygon& x, Polygon& y) {\n  rep(i, x.size()) rep(j, y.size()) {\n    auto e = x.side(i), u = y.side(j);\n    {\n      int k = ccw(e[0], e[1], u[0]);\n      int l = ccw(e[0], e[1], u[1]);\n      if(k != counter_clockwise && k != clockwise &&\n         l != counter_clockwise && l != clockwise) {\n        if(k == inside || l == inside) { return true; }\n        if(k == on_end_point && l == on_end_point) { return true; }\n      }\n    }\n    {\n      int k = ccw(u[0], u[1], e[0]);\n      int l = ccw(u[0], u[1], e[1]);\n      if(k != counter_clockwise && k != clockwise &&\n         l != counter_clockwise && l != clockwise) {\n        if(k == inside || l == inside) { return true; }\n        if(k == on_end_point && l == on_end_point) { return true; }\n      }\n    }\n  }\n  return false;\n}\n\nint ans, curr;\n\nvoid dfs(const vector<vector<int>>& g, int idx, vector<bool>& visited, vector<int>& color) {\n  set<int> st;\n  for(auto && next: g[idx]) {\n    if(color[next] != -1) { st.insert(color[next]); }\n  }\n  bool ok = 0;\n  rep(i, curr) {\n    if(!st.count(i)) {\n      ok = 1; color[idx] = i;\n    }\n  }\n  if(!ok) { color[idx] = curr ++; }\n\n  for(auto && next: g[idx]) {\n    if(visited[next]) { continue; }\n    visited[next] = 1;\n    dfs(g, next, visited, color);\n  }\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    map<string, int> id;\n    vector<vector<Polygon>> gs(N);\n    int x, y;\n    int V = 0;\n    rep(_, N) {\n      string name; cin >> name;\n      if(id.find(name)==id.end()) id[name] = V++;\n      Polygon v;\n      while(cin >> x) {\n        if(x == -1) { break; }\n        cin >> y;\n        v.emplace_back(x, y);\n      }\n      gs[id[name]].push_back(v);\n    }\n\n    vector<vector<int>> gr(N);\n\n    rep(i, N) REP(j, i+1, N) {\n      auto f = [&]() {\n        for(auto& e: gs[i]) for(auto& u: gs[j]) {\n          if(adjacent(e, u)) {\n            gr[i].push_back(j);\n            gr[j].push_back(i);\n            return;}}}; f();\n    }\n    vector<bool> visited(N);\n    vector<int> color(N, -1);\n    ans = 0;\n\n    rep(i, N) {\n      if(visited[i]) { continue; }\n      visited[i] = 1;\n      curr = 0;\n      dfs(gr, i, visited, color);\n      maximize(ans, curr);\n    }\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nmap<string,int> cntid;\nint cntnum=0;\nint cntidx[100];\nvector<P> poly[100];\nvector<int> g[10];\nint col[10];\nint colcnt[10];\nint res=100;\n\nP operator-(const P& a,const P& b){ return P(a.fi-b.fi,a.se-b.se); }\nll cross(P a,P b){ return a.fi*b.se - a.se*b.fi; }\nll norm(P a){ return a.fi*a.fi + a.se*a.se; }\nbool intersectSP(P p1,P p2,P q){\n  if(p1==q||p2==q)return false;\n  return norm(p1-q)+norm(p2-q)-norm(p2-p1)<0;\n}\nbool intersectSS(P p1,P p2,P q1,P q2){\n  if(cross(p2-p1,q2-q1)!=0)return false;\n  if(min(p1,p2)==min(q1,q2)&&max(p1,p2)==max(q1,q2))return true;\n  return intersectSP(p1,p2,q1)||intersectSP(p1,p2,q2)||intersectSP(q1,q2,p1)||intersectSP(q1,q2,p2);\n}\n\nint getid(string s){\n  if(cntid.find(s)!=cntid.end())return cntid[s];\n  cntid[s]=cntnum++;\n  return cntid[s];\n}\n\nvoid dfs(int v,int crtres){\n  if(v==cntnum){\n    minch(res,crtres);\n    return ;\n  }\n  if(crtres>=res)return ;\n  vector<bool> used(10,false);\n  for(int nv : g[v])if(col[nv]!=-1)used[col[nv]]=true;\n  rep(i,10){\n    if(used[i])continue;\n    col[v]=i;\n    colcnt[i]++;\n    dfs(v+1,crtres+(colcnt[i]==1?1:0));\n    colcnt[i]--;\n  }\n  return ;\n}\n\nint main(){\n  while(1){\n    int N;\n    cin>>N;\n    if(N==0)break;\n    cntid.clear(); cntnum=0;\n    rep(i,10)g[i].clear();\n    rep(i,N){\n      string name;\n      cin>>name;\n      int crtid=getid(name);\n      cntidx[i]=crtid;\n      poly[i].clear();\n      int x,y;\n      while(1){\n        cin>>x;\n        if(x==-1)break;\n        cin>>y;\n        poly[i].push_back(P(x,y));\n      }\n    }\n    rep(i,N)rep(j,i){\n      bool crossed=false;\n      rep(l1,poly[i].size())rep(l2,poly[j].size()){\n        if(intersectSS(poly[i][l1],poly[i][(l1+1)%poly[i].size()],poly[j][l2],poly[j][(l2+1)%poly[j].size()]))crossed=true;\n      }\n      if(crossed&&cntidx[i]!=cntidx[j]&&!exist(g[cntidx[i]],cntidx[j])){\n        g[cntidx[i]].push_back(cntidx[j]);\n        g[cntidx[j]].push_back(cntidx[i]);\n      }\n    }\n    memset(colcnt,0,sizeof(colcnt)); memset(col,-1,sizeof(col)); res=100;\n    dfs(0,0);\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-7)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nstring d[M];\nset<P1> z;\n\nbool eq(double n1,double n2){return abs(n1-n2)<EPS;}\n\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++){\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      string s1=min(d[i],d[j]);\n      string s2=max(d[i],d[j]);\n      if(z.find(P1(s1,s2))!=z.end())return;\n    }\n  }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\nbool parallel(L a, L b) {return sgn(det(O,vec(a),vec(b)))==0;}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n\nbool iss(L a,L b,int end=0){\n    int s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n    int s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n    if(end) return (s1&s2)==(LEFT|RIGHT);\n    return (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nR dsp(L s,P p){\n    if(sgn(dot(s.s,s.t,p))<=0) return abs(p-s.s);\n    if(sgn(dot(s.t,s.s,p))<=0) return abs(p-s.t);\n    return abs(det(s.s,s.t,p))/abs(s.t-s.s);\n}\n\nusing vi = vector<int>;\n\nconst int N = 11;\nvector<VP> islands[N];\nvi graph[N];\n\ninline bool check(L a, L b){\n    if(not iss(a, b) or not parallel(a, b)) return false;\n\n    rep(loop, 2){\n        rep(looop, 2){\n            if(a.s == b.s and dot(a.s, a.t, b.t) < EPS){\n                return false;\n            }\n            swap(a.s, a.t);\n        }\n        swap(b.s, b.t);\n    }\n\n    return true;\n}\n\nint main(void){\n    for(int Q; cin >> Q, Q;){\n        int n = 0;\n        map<string, int> s2i;\n        rep(v, N) islands[v] = vector<VP>();\n\n        rep(loop, Q){\n            string name; cin >> name;\n            if(s2i.find(name) == end(s2i)){\n                s2i[name] = n++;\n            }\n            int v = s2i[name];\n\n            islands[v].push_back(VP());\n            for(R x, y; cin >> x, x != -1;){\n                cin >> y;\n                islands[v].back().push_back({x, y});\n            }\n        }\n\n        rep(i, n) graph[i] = vi();\n        rep(a, n){\n            rep(b, a){\n                [&]{\n                    for(auto & pola : islands[a]){\n                        for(auto & polb : islands[b]){\n                            int alen = pola.size();\n                            int blen = polb.size();\n\n                            rep(ai, alen){\n                                rep(bi, blen){\n                                    L as = {pola[ai], pola[(ai + 1) % alen]};\n                                    L bs = {polb[bi], polb[(bi + 1) % blen]};\n\n                                    if(check(as, bs)){\n                                        graph[a].push_back(b);\n                                        graph[b].push_back(a);\n                                        return;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }();\n            }\n        }\n\n        const int inf = 1 << 30;\n        vi dp = vi(1 << n, inf);\n        dp[0] = 0;\n\n        rep(sup, 1, 1 << n){\n            for(int sub = (sup - 1) & sup; sub != sup; sub = (sub - 1) & sup){\n                if(dp[sup] <= dp[sub]) continue;\n\n                int vmask = sup & ~sub;\n\n                [&]{\n                    rep(a, n){\n                        if(not ((vmask >> a) & 1)) continue;\n\n                        for(auto & b : graph[a]){\n                            if((vmask >> b) & 1) return;\n                        }\n                    }\n                    dp[sup] = dp[sub] + 1;\n                }();\n            }\n        }\n        \n        cout << dp.back() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint N,ans,country_index;\n\nbool adj_check[10][10];\n\n#define NUM 9999999.0\n\nstruct Point{\n\tdouble x,y;\n};\n\nstruct Data{\n\tData(double arg_value,bool arg_is_i){\n\t\tvalue = arg_value;\n\t\tis_i = arg_is_i;\n\t}\n\tbool operator<(const struct Data &arg) const{\n\t\treturn value < arg.value;\n\t};\n\tdouble value;\n\tbool is_i;\n};\n\ntypedef Point Vector;\n\nstruct Segment{\n\tvoid set(double x1,double y1,double x2,double y2){\n\t\tp1.x = x1;\n\t\tp1.y = y1;\n\t\tp2.x = x2;\n\t\tp2.y = y2;\n\t}\n\tPoint p1,p2;\n};\n\ntypedef Segment Line;\n\nstruct Region{\n\tvector<Line> Lines;\n};\n\nstruct Country{\n\tint color;\n\tchar name[21];\n\tvector<Region> regions;\n};\n\nstruct Shishimaru{\n\tint colors[10];\n\tint max_color;\n};\n\n\nvoid recursive(Shishimaru shishimaru,int count){\n\n\tif(shishimaru.max_color >= ans)return;\n\n\tif(count == country_index){\n\n\t\tint tmp_max = 0;\n\n\t\tfor(int i = 0; i < country_index; i++){\n\t\t\ttmp_max = max(tmp_max,shishimaru.colors[i]);\n\t\t}\n\n\t\tans  = min(ans,tmp_max);\n\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < country_index; i++){\n\t\tif(shishimaru.colors[i] != -1)continue;\n\n\t\tbool check[11];\n\t\tfor(int k = 0; k < 11; k++)check[k] = false;\n\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tif(i != k && adj_check[i][k] == true && shishimaru.colors[k] != -1){\n\t\t\t\tcheck[shishimaru.colors[k]] = true;\n\t\t\t}\n\t\t}\n\n\t\tShishimaru next_shishimaru;\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tnext_shishimaru.colors[k] = shishimaru.colors[k];\n\t\t}\n\n\t\tfor(int k = 1; k <= 10; k++){\n\t\t\tif(check[k] == false){\n\t\t\t\tnext_shishimaru.colors[i] = k;\n\t\t\t\tnext_shishimaru.max_color = max(shishimaru.max_color,k);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\trecursive(next_shishimaru,count+1);\n\t}\n}\n\nint func(double x1,double y1,double x2, double y2, double xp, double yp){\n\tdouble naiseki,norm1,norm2,gaiseki;\n\tnorm1 = sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));\n\tnorm2 = sqrt((xp-x1)*(xp-x1)+(yp-y1)*(yp-y1));\n\tnaiseki = (xp-x1)*(x2-x1)+(yp-y1)*(y2-y1);\n\tgaiseki = (x2-x1)*(yp-y1)-(xp-x1)*(y2-y1);\n\tif(gaiseki > EPS){\n\t\treturn 1;\n\t}else if(gaiseki < -EPS){\n\t\treturn -1;\n\t}\n\tif(naiseki < -EPS){\n\t\treturn 2;\n\t}\n\n\tif(norm1 < norm2){\n\t\treturn -2;\n\t}\n\treturn 0;\n}\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\ndouble calc_slope(Line line){\n\n\tif(fabs(line.p1.y - line.p2.y) < EPS){\n\t\treturn 0.0;\n\t}else if(fabs(line.p1.x - line.p2.x) < EPS){\n\t\treturn NUM;\n\t}else{\n\t\treturn (line.p1.y-line.p2.y)/(line.p1.x-line.p2.x);\n\t}\n}\n\nvoid solve(){\n\n\tCountry country[N];\n\tcountry_index = 0;\n\n\tfor(int i = 0; i < N; i++){\n\t\tcountry[i].color = -1;\n\t}\n\n\tchar buf[21];\n\n\tint tmp_index;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%s\",buf);\n\n\t\ttmp_index = -1;\n\t\tfor(int i = 0; i < country_index; i++){\n\t\t\tif(strCmp(country[i].name,buf)){\n\t\t\t\ttmp_index = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(tmp_index == -1){\n\t\t\tstrcpy(country[country_index].name,buf);\n\t\t\ttmp_index = country_index;\n\t\t\tcountry_index++;\n\t\t}\n\n\t\tRegion new_region;\n\t\tLine new_line;\n\n\t\tdouble x,y,pre_x = -1.0,pre_y = -1.0;\n\n\t\twhile(true){\n\t\t\tscanf(\"%lf\",&x);\n\t\t\tif(fabs(x + 1.0) < EPS){\n\t\t\t\tnew_line.p1.x = pre_x;\n\t\t\t\tnew_line.p1.y = pre_y;\n\t\t\t\tnew_line.p2.x = new_region.Lines[0].p1.x;\n\t\t\t\tnew_line.p2.y = new_region.Lines[0].p1.y;\n\t\t\t\tnew_region.Lines.push_back(new_line);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tscanf(\"%lf\",&y);\n\n\t\t\tif(fabs(pre_x+1.0) > EPS){\n\t\t\t\tnew_line.p1.x = pre_x;\n\t\t\t\tnew_line.p1.y = pre_y;\n\t\t\t\tnew_line.p2.x = x;\n\t\t\t\tnew_line.p2.y = y;\n\t\t\t\tnew_region.Lines.push_back(new_line);\n\t\t\t}\n\n\t\t\tpre_x = x;\n\t\t\tpre_y = y;\n\t\t}\n\n\t\tcountry[tmp_index].regions.push_back(new_region);\n\t}\n\n\n\tif(country_index == 1){\n\t\tprintf(\"1\\n\");\n\t\treturn;\n\t}\n\n\tfor(int i = 0; i < country_index; i++){\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tadj_check[i][k] = false;\n\t\t}\n\t}\n\n\tbool adj_FLG;\n\tdouble tmp_slope;\n\n\tvector<Data> calc_V;\n\n\tfor(int i = 0; i < country_index; i++){\n\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tif(i == k)continue;\n\n\t\t\tadj_FLG = false;\n\n\t\t\tfor(int a = 0; a < country[i].regions.size(); a++){\n\t\t\t\tfor(int b = 0; b < country[k].regions.size(); b++){\n\t\t\t\t\tfor(int c = 0; c < country[i].regions[a].Lines.size(); c++){\n\t\t\t\t\t\tfor(int d = 0; d < country[k].regions[b].Lines.size();d++){\n\n\n\t\t\t\t\t\t\tif(fabs((tmp_slope = calc_slope(country[i].regions[a].Lines[c])) - calc_slope(country[k].regions[b].Lines[d])) < EPS){\n\n\t\t\t\t\t\t\t\tcalc_V.clear();\n\n\t\t\t\t\t\t\t\tif(fabs(tmp_slope) < EPS && country[i].regions[a].Lines[c].p1.y == country[k].regions[b].Lines[d].p1.y &&\n\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.y == country[k].regions[b].Lines[d].p2.y){\n\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p1.x,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p2.x,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p1.x,false));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p2.x,false));\n\n\t\t\t\t\t\t\t\t\tsort(calc_V.begin(),calc_V.end());\n\n\t\t\t\t\t\t\t\t\tif(calc_V[0].is_i != calc_V[1].is_i && fabs(calc_V[1].value - calc_V[2].value) > 0.1){\n\t\t\t\t\t\t\t\t\t\tadj_FLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else if(fabs(tmp_slope-NUM) < EPS && country[i].regions[a].Lines[c].p1.x == country[k].regions[b].Lines[d].p1.x &&\n\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x == country[k].regions[b].Lines[d].p2.x){\n\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p1.y,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p2.y,true));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p1.y,false));\n\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p2.y,false));\n\n\t\t\t\t\t\t\t\t\tsort(calc_V.begin(),calc_V.end());\n\n\t\t\t\t\t\t\t\t\tif(calc_V[0].is_i != calc_V[1].is_i && fabs(calc_V[1].value - calc_V[2].value) > 0.1){\n\t\t\t\t\t\t\t\t\t\tadj_FLG = true;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}else if(fabs(tmp_slope-0.0) > EPS && fabs(tmp_slope-NUM) > EPS){\n\n\t\t\t\t\t\t\t\t\tif(func(country[i].regions[a].Lines[c].p1.x,country[i].regions[a].Lines[c].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x,country[i].regions[a].Lines[c].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p1.x,country[k].regions[b].Lines[d].p1.y)*\n\t\t\t\t\t\t\t\t\t\tfunc(country[i].regions[a].Lines[c].p1.x,country[i].regions[a].Lines[c].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x,country[i].regions[a].Lines[c].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p2.x,country[k].regions[b].Lines[d].p2.y) <= 0 &&\n\t\t\t\t\t\t\t\t\t\tfunc(country[k].regions[b].Lines[d].p1.x,country[k].regions[b].Lines[d].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p2.x,country[k].regions[b].Lines[d].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p1.x,country[i].regions[a].Lines[c].p1.y)*\n\t\t\t\t\t\t\t\t\t\tfunc(country[k].regions[b].Lines[d].p1.x,country[k].regions[b].Lines[d].p1.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[k].regions[b].Lines[d].p2.x,country[k].regions[b].Lines[d].p2.y,\n\t\t\t\t\t\t\t\t\t\t\t\tcountry[i].regions[a].Lines[c].p2.x,country[i].regions[a].Lines[c].p2.y) <= 0){\n\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p1.x,true));\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[i].regions[a].Lines[c].p2.x,true));\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p1.x,false));\n\t\t\t\t\t\t\t\t\t\tcalc_V.push_back(Data(country[k].regions[b].Lines[d].p2.x,false));\n\n\t\t\t\t\t\t\t\t\t\tsort(calc_V.begin(),calc_V.end());\n\n\t\t\t\t\t\t\t\t\t\tif(calc_V[0].is_i != calc_V[1].is_i && fabs(calc_V[1].value - calc_V[2].value) > 0.1){\n\t\t\t\t\t\t\t\t\t\t\tadj_FLG = true;\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(adj_FLG)break;\n\t\t\t\t\t}\n\t\t\t\t\tif(adj_FLG)break;\n\t\t\t\t}\n\t\t\t\tif(adj_FLG)break;\n\t\t\t}\n\n\t\t\tif(adj_FLG){\n\t\t\t\tadj_check[i][k] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tans = BIG_NUM;\n\n\tfor(int i = 0; i < country_index; i++){\n\t\tShishimaru shishi;\n\t\tfor(int k = 0; k < country_index; k++){\n\t\t\tshishi.colors[k] = -1;\n\t\t}\n\t\tshishi.colors[i] = 1;\n\t\tshishi.max_color = 1;\n\t\trecursive(shishi,1);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <iostream>\n#include <cmath>\n#define INF 1LL<<5\nusing namespace std;\nstruct P{\n\tint x,y;\n\tP(){}\n\tP(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(x+p.x,y+p.y);\n\t}\n\tP operator -(P p){\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tP operator *(int d){\n\t\treturn P(x*d,y*d);\n\t}\n\tbool operator ==(const P &p)const{\n\t\treturn (x==p.x && y==p.y);\n\t}\n};\n\ntypedef P Vector;\ntypedef vector<P> Polygon;\nint norm(P p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nint dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(P p0,P p1,P p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>0)return 1;\n\tif(cross(a,b)<0)return -1;\n\tif(dot(a,b)<0)return 2;\n\tif(norm(a)<norm(b))return -2;\n\treturn 0;\n}\n\nbool intersect(P p1,P p2,P p3,P p4){\n\tif(ccw(p1,p2,p3)*ccw(p1,p2,p4)>0 || ccw(p3,p4,p1)*ccw(p3,p4,p2)>0)return false;\n\tif(ccw(p1,p2,p3)*ccw(p1,p2,p4)<0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<0)return true;\n\tif(ccw(p1,p2,p4)==0 && ccw(p1,p2,p3)==0)return true;\n\tif(ccw(p3,p4,p1)==0 && ccw(p3,p4,p2)==0)return true;\n\tif(ccw(p1,p2,p3)==0 && !(p1==p3) && !(p2==p3) && abs(ccw(p1,p2,p4))!=1)return true;\n\tif(ccw(p1,p2,p4)==0 && !(p1==p4) && !(p2==p4) && abs(ccw(p1,p2,p3))!=1)return true;\n\treturn false;\n}\n\n\n\nint n;\nmap<string,int> id;\nPolygon territory[101];\nvector<int> ind[101];\nbool edge[11][11];\nvector<int> paint;\nint dp[1<<11];\n\nbool share(int c1,int c2){\n\tfor(int i=0;i<ind[c1].size();i++){\n\t\tfor(int j=0;j<ind[c2].size();j++){\n\t\t\tint t1=ind[c1][i],t2=ind[c2][j];\n\t\t\tfor(int k=0;k<territory[t1].size();k++){\n\t\t\t\tP p1=territory[t1][k];\n\t\t\t\tP p2=territory[t1][(k+1)%territory[t1].size()];\n\t\t\t\tfor(int l=0;l<territory[t2].size();l++){\n\t\t\t\t\tP p3=territory[t2][l];\n\t\t\t\t\tP p4=territory[t2][(l+1)%territory[t2].size()];\n\t\t\t\t\tif(intersect(p1,p2,p3,p4)){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint all=0;\n\t\tid.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tterritory[i].clear();\n\t\t\tind[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(id.find(str)==id.end()){\n\t\t\t\tid[str]=all++;\n\t\t\t}\n\t\t\tind[id[str]].push_back(i);\n\t\t\twhile(1){\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tif(x==-1)break;\n\t\t\t\tscanf(\"%d\",&y);\n\t\t\t\tterritory[i].push_back(P(x,y));\n\t\t\t}\n\t\t}\n\t\tmemset(edge,false,sizeof(edge));\n\t\tfor(int i=0;i<all;i++){\n\t\t\tfor(int j=i+1;j<all;j++){\n\t\t\t\tif(share(i,j)){\n\t\t\t\t\tedge[i][j]=true;\n\t\t\t\t\tedge[j][i]=true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<all;i++){\n\t\t\tfor(int j=0;j<all;j++){\n\t\t\t\tprintf(\"%c%c\",edge[i][j]?'y':'n',j==all-1?'\\n':' ');\n\t\t\t}\n\t\t}\n\t\tpaint.clear();\n\t\tfor(int i=0;i<(1<<all);i++){\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<all;j++){\n\t\t\t\tif(!((i>>j) & 1))continue;\n\t\t\t\tfor(int k=j+1;k<all;k++){\n\t\t\t\t\tif(!((i>>k) & 1))continue;\n\t\t\t\t\tif(edge[j][k])flag=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)paint.push_back(i);\n\t\t}\n\t\tfill(dp,dp+(1<<all),INF);\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<all);i++){\n\t\t\tif(dp[i]==INF)continue;\n\t\t\tfor(int j=0;j<paint.size();j++){\n\t\t\t\tint k=paint[j];\n\t\t\t\tdp[i|k]=min(dp[i|k],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[(1<<all)-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\ninline int sgn(const ll& r){ return (r > 0) - (r < 0);}\n\nusing P=complex<ll>;\nusing L=struct{P s,t;};\n\nnamespace std{\n\tbool operator >  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)>0:sgn(imag(a-b))>0;}\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\ninline ll dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline ll det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\ninline bool cross(L a,L b){\n\tif(det(P(0,0),a.t-a.s,b.t-b.s)!=0) return false;\n\tconst int sa=ccw(a.s,a.t,b.s)|ccw(a.s,b.t,b.t);\n\tconst int sb=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif((sa&ON)==0) return false;\n\tif((sb&ON)==0) return false;\n\t\n\tusing state=tuple<P,int>;\n\n\tbool ok=true;\n\tvector<state> ary={state(a.s,0),state(a.t,0),state(b.s,1),state(b.t,1)};\n\tsort(_all(ary));\n\tif(get<1>(ary[0])==get<1>(ary[1])) return false;\n\tif(get<1>(ary[2])==get<1>(ary[3])) return false;\n\tif(get<0>(ary[1])==get<0>(ary[2])) return false;\n\t//cout << a.s << \" \" << a.t << \" \" << b.s << \" \" << b.t << endl;\n\treturn true;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tset<L> pol[110];\n\t\tmap<string,vector<int>> conv;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin >> s; \n\t\t\tconv[s].push_back(i);\n\n\t\t\tint x[110],y[110],m=0;\n\n\t\t\twhile(1){\n\t\t\t\tcin >> x[m];\n\t\t\t\tif(x[m]==-1) break;\n\t\t\t\tcin >> y[m++];\n\t\t\t}\n\n\t\t\trep(j,m){\n\t\t\t\tP a=P(x[j],y[j]);\n\t\t\t\tP b=P(x[(j+1)%m],y[(j+1)%m]);\n\t\t\t\tif(a>b) swap(a,b);\n\t\t\t\tpol[i].insert(L({a,b})); \n\t\t\t}\n\t\t}\n\n\t\tvector<string> ary;\n\t\tfor(auto &it:conv) ary.push_back(it.first);\n\t\tconst int m=ary.size();\n\n\t\tbool graph[110][110];\n\t\tclr(graph,0);\n\t\t\n\t\trep(i,n)rep(j,i){\n\t\t\tbool ok=false;\n\t\t\tfor(auto &line:pol[i]) for(auto &line2:pol[j]) if(cross(line,line2)) ok=true;\n\t\t\tif(ok) graph[i][j]=graph[j][i]=true;\n\t\t}\n\n\t\tint index[10];\n\t\tiota(index,index+m,0);\n\n\t\tint ans=10;\n\n\t\tdo{\n\t\t\tint color[110];\n\t\t\tclr(color,-1);\n\n\t\t\trep(i,m){\n\t\t\t\tstring s= ary[i];\n\t\t\t\tset<int> used;\n\t\t\t\tfor(auto &v:conv[s]) rep(v2,n) if(graph[v][v2]) used.insert(color[v2]);\n\t\t\t\tint cmax=0;\n\t\t\t\twhile(used.find(cmax)!=used.end()) cmax++;\n\t\t\t\tfor(auto &v:conv[s]) color[v]=cmax;\n\t\t\t}\n\n\t\t\tint num=0;\n\t\t\trep(i,n) chmax(num,color[i]);\n\t\t\tchmin(ans,num+1);\n\n\t\t}while(next_permutation(index,index+m));\n\n\t\t// rep(i,n){\n\t\t// \trep(j,n) cout << graph[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\n\t\t// const P a=P(10,50),b=P(20,40),c=P(35,25);\n\t\t// cout << cross(L({a,b}),L({a,c})) << endl;\n\t\t//for(auto &line:pol[2]) for(auto &line2:pol[3]) cout << cross(line,line2) << endl;\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npii operator-(const pii &a,const pii &b){\n    return make_pair(a.first-b.first,a.second-b.second);\n}\n\nvoid solve(int n){\n    map<string,int> t;\n    vector<vector<int>> vs;\n    vector<vector<pii>> ps;\n    int cnt=0;\n    rep(i,0,n){\n        string str;\n        cin >> str;\n        if(t.find(str)==t.end()){\n            t[str]=cnt;\n            vs.push_back(vector<int>());\n            ps.push_back(vector<pii>());\n            ++cnt;\n        }\n        int idx=t[str];\n        vs[idx].push_back(i);\n        while(true){\n            int x,y;\n            cin >> x;\n            if(x==-1) break;\n            cin >> y;\n            ps[idx].push_back(make_pair(x,y));\n        }\n    }\n\n    auto cross=[](pii &a,pii &b){\n        return a.first*b.second-a.second*b.first;\n    };\n\n    vector<vector<int>> graph(cnt);\n    rep(i,0,cnt) rep(j,0,i){\n        if([&](){\n            rep(i_,0,ps[i].size()) rep(j_,0,ps[j].size()){\n                pii &p1=ps[i][i_],&p2=ps[i][(i_+1)%ps[i].size()];\n                pii &q1=ps[j][j_],&q2=ps[j][(j_+1)%ps[j].size()];\n                pii a=p1-p2,b=q1-q2;\n                pii c=p1-q2,d=p2-q1;\n                if(cross(a,b)) continue;\n                if(cross(c,d)) continue;\n                if(a.first and (max(p1.first,p2.first)==min(q1.first,q2.first) or min(p1.first,p2.first)==max(q1.first,q2.first))) continue;\n                if(a.second and (max(p1.second,p2.second)==min(q1.second,q2.second) or min(p1.second,p2.second)==max(q1.second,q2.second))) continue;\n                return true;\n            }\n            return false;\n        }()){\n            graph[i].push_back(j);\n            graph[j].push_back(i);\n        }\n    }\n\n    {\n        bool f=true;\n        rep(i,0,cnt) if(graph[i].size()){\n            f=false;\n            break;\n        }\n        if(f){\n            cout << 1 << endl;\n            return;\n        }\n    }\n\n    function<bool(int,vector<int>&,int)> dfs=[&](int k,vector<int> &color,int u){\n        for(int v:graph[u]){\n            if(color[v]){\n                if(color[v]==color[u]) return false;\n                continue;\n            }\n            bool ok=false;\n            rep(i,1,k+1){\n                if(i==color[u]) continue;\n                color[v]=i;\n                ok|=dfs(k,color,v);\n            }\n            if(!ok) return false;\n        }\n        return true;\n    };\n\n    vector<int> color(cnt);\n    color[0]=1;\n    if(dfs(2,color,0)){\n        cout << 2 << endl;\n        return;\n    }\n    fill(color.begin(),color.end(),0);\n    color[0]=1;\n    if(dfs(3,color,0)) cout << 3 << endl;\n    else cout << 4 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 105\n#define M 15\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nstring d[M];\nset<P1> z;\n\ndouble dot(P A,P B){return real(conj(A)*B);}\ndouble cross(P A,P B){return imag(conj(A)*B);}\n\nint ccw(P A, P B, P C){\n  B-=A;\n  C-=A;\n  if(cross(B,C)>EPS)return 1;\n  if(cross(B,C)<-EPS)return -1;\n  if(dot(B,C)<-EPS)return 2;\n  if(norm(B)<norm(C))return -2;\n  return 0;\n}\n\nbool check(P A1,P A2,P B1,P B2){\n  int r1=ccw(A1,A2,B1);\n  int r2=ccw(A1,A2,B2);\n  int r3=ccw(B1,B2,A1);\n  int r4=ccw(B1,B2,A2);\n  if(r1==1||r1==-1||r2==1||r2==-1)return false;\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if(right-left<=EPS)return false;\n  if(!r1||!r2||!r3||!r4)return true;\n  return false;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++){\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      string s1=min(d[i],d[j]);\n      string s2=max(d[i],d[j]);\n      if(z.find(P1(s1,s2))!=z.end())return;\n    }\n  }\n  if(x==Slen){\n    set<int> cnt;\n    //for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P A1=v[i][k],A2=v[i][(k+1)%leni];\n\t    P B1=v[j][l],B2=v[j][(l+1)%lenj];\n\t    if(check(A1,A2,B1,B2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nstring d[M];\nset<P1> z;\n\ndouble dot(P pa,P pb){return real(conj(pa)*pb);}\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nint ccw(P A, P B, P C){\n  B-=A;\n  C-=A;\n  if(cross(B,C)>EPS)return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(B,C)<-EPS)return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(B,C)<-EPS)return 2;\n  if(norm(B)<norm(C))return -2;\n  return 0;\n}\n\nbool check(P A1,P A2,P B1,P B2){\n  int r1=ccw(A1,A2,B1);\n  int r2=ccw(A1,A2,B1);\n  int r3=ccw(B1,B2,A1);\n  int r4=ccw(B1,B2,A2);\n  if(r1==1||r1==-1||r2==1||r2==-1)return false;\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if(!(EPS<right-left))return false;\n  if(!r1||!r2||!r3||!r4)return true;\n  return false;\n}\n\n\n/*bool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n  }*/\n\nvoid func(int x){\n  for(int i=0;i<x;i++){\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      string s1=min(d[i],d[j]);\n      string s2=max(d[i],d[j]);\n      if(z.find(P1(s1,s2))!=z.end())return;\n    }\n  }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return x < a.x || x == a.x && y < a.y; }\n\tbool operator==(const Pt &a) const { return x == a.x && y == a.y; }\n\tbool operator!=(const Pt &a) const { return x != a.x || y != a.y; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\n\n// end of library from hos\n\nint iSP2(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) <= 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) <= 0) return +2; // a-b-c\n\treturn 0;\n}\n\ndouble area(vector<Pt> p){\n\tdouble res = 0;\n\trep(i,sz(p)){\n\t\tres += p[i].det(p[(i+1) % sz(p)]);\n\t}\n\treturn res / 2;\n}\n\nint n;\nmap<string,vector<vector<Pt>>> M;\nstring name[11];\nint g[11][11];\nint ok[1<<11];\nint dp[1<<11];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\tM.clear();\n\t\tmemset(g,0,sizeof(g));\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tvector<Pt> p;\n\t\t\tint x,y;\n\t\t\twhile(cin>>x && x!=-1){\n\t\t\t\tcin>>y;\n\t\t\t\tp.pb(Pt(x,y));\n\t\t\t}\n\t\t\tif(area(p) < 0){\n\t\t\t\treverse(p.begin(),p.end());\n\t\t\t}\n\t\t\tM[s].pb(p);\n\t\t}\n\n\t\tint c = 0;\n\t\tforeach(it,M){\n\t\t\tname[c++] = it->fir;\n\t\t}\n\n\t\trep(I,c)rep2(J,I+1,c){\n\t\t\tauto &v1 = M[name[I]], &v2 = M[name[J]];\n\t\t\trep(i,sz(v1))rep(j,sz(v2))rep(ii,sz(v1[i]))rep(jj,sz(v2[j])){\n\t\t\t\tint res1 = iSP2(v1[i][ii], v1[i][(ii+1) % sz(v1[i])], v2[j][jj]);\n\t\t\t\tint res2 = iSP2(v1[i][ii], v1[i][(ii+1) % sz(v1[i])], v2[j][(jj+1) % sz(v2[j])]);\n\t\t\t\tif(res1 > res2) swap(res1, res2);\n\t\t\t\tif((res1 == -2 || res1 == 0) && (res2 == 0 || res2 == +2)){\n\t\t\t\t\t//cout<<name[I]<<\" \"<<name[J]<<\" \"<<v1[i][ii]<<\" \"<<v1[i][(ii+1) % sz(v1[i])]<<\" \"<<v2[j][jj]<<\" \"<<v2[j][(jj+1) % sz(v2[j])]<<endl;\n\t\t\t\t\tg[I][J] = g[J][I] = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\n\t\t/*rep(i,c)rep(j,c){\n\t\t\tcout<<g[i][j]<<\" \";if(j==c-1)cout<<endl;\n\t\t}*/\n\n\t\trep(i,1<<c) ok[i]=1, dp[i]=INF;\n\t\tdp[0] = 0;\n\t\trep(mask,1<<c){\n\t\t\trep(i,c)if(mask>>i&1)rep(j,c)if(mask>>j&1){\n\t\t\t\tif(g[i][j]) ok[mask] = 0;\n\t\t\t}\n\t\t}\n\n\t\trep(mask,1<<c){\n\t\t\trep(sub,1<<c)if((mask&sub) == sub && ok[sub]){\n\t\t\t\tdp[mask] = min(dp[mask], dp[mask^sub] + 1);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[(1<<c)-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct Point{\n  int x,y;\n\n  Point(int x,int y):x(x),y(y){}\n\n  Point operator + (Point p){\n    return Point(x+p.x,y+p.y);\n  }\n  Point operator - (Point p){\n    return Point(x-p.x,y-p.y);\n  }\n};\n\nstruct Segment{\n  Point s,t;\n  Segment(Point s,Point t):s(s),t(t){}\n};\n\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n\nbool eq(Segment a,Segment b){\n  if( eq(a.s,b.s) && eq(a.t,b.t) )return true;\n  if( eq(a.s,b.t) && eq(a.t,b.s) )return true;  \n  return false;\n}\n\nint dot(Point a,Point b ){\n return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b ){\n return a.x*b.y-a.y*b.x;\n}\n\nbool isParallel(Segment a,Segment b){\n  return (cross(a.s-a.t,b.s-b.t)==0);\n}\n\nbool onSegment(Segment a,Point p){\n  if(eq(a.s,p))return false;\n  if(eq(a.t,p))return false;\n  if(cross(a.s-p,a.t-p)!=0)return false;\n  if(dot(a.t-a.s,p-a.s)<=0)return false;\n  if(dot(a.s-a.t,p-a.t)<=0)return false;\n  return true;\n}\n\nbool haveCommonSegment(Segment a,Segment b){\n  if(eq(a,b))return true;\n  if(!isParallel(a, b))return false;\n  if(onSegment(a,b.s))return true;\n  if(onSegment(a,b.t))return true;\n  if(onSegment(b,a.s))return true;\n  if(onSegment(b,a.t))return true;\n  return false;\n}\n\nbool haveCommonSegment(vector<Segment> &a,vector<Segment> &b){\n  for(Segment A : a )\n    for(Segment B : b )\n      if(haveCommonSegment(A,B))\n        return true;\n  return false;\n}\n\n\nbool check(int G[10][10],int S){\n  for(int i=0;i<10;i++){\n    if((S>>i&1)==0)continue;\n    for(int j=0;j<10;j++){\n      if((S>>j&1)==0)continue;\n      if(G[i][j])return false;\n    }\n  }\n  return true;\n}\n\n\nint main() {\n  int N;\n  vector<Segment> Country[10];\n  map<string,int> id;\n\n  while(1){\n    cin>>N;\n    if(N==0)break;\n    for(int i=0;i<N;i++){\n      string name;\n      vector<Point> v;\n      cin>>name;\n      id[name]=id.size()-1;\n      while(1){\n        int x,y;\n        cin>>x;\n        if(x==-1)break;\n        cin>>y;\n        v.push_back(Point(x,y));\n      }\n      int size=v.size();\n      for(int i=0;i<size;i++){\n        Segment segment=Segment(v[i],v[(i+1)%size]);\n        Country[id[name]].push_back(segment);\n      }\n    }\n    int M=id.size();\n    int G[10][10]={};\n    for(int i=0;i<M;i++)\n      for(int j=0;j<M;j++)\n        G[i][j]=haveCommonSegment(Country[i],Country[j]);\n\n    vector<int> edge;\n    for(int S=0;S<(1<<M);S++)\n      if(check(G,S))\n        edge.push_back(S);\n\n    int dp[(1<<M)];\n    fill(dp,dp+(1<<M),10);\n    dp[0]=0;\n\n    for(int S=0;S<(1<<M);S++)\n      for(int T : edge)\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      \n    cout<<dp[(1<<M)-1]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\nstring d[M];\n\nbool eq(double n1,double n2){return abs(n1-n2)<EPS;}\n\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n}\n\nvoid func(int x){\n  for(int i=0;i<x;i++){\n    for(int j=i+1;j<x;j++){\n      if(mark[i]!=mark[j])continue;\n      string s1=min(d[i],d[j]);\n      string s2=max(d[i],d[j]);\n      if(z.find(P1(s1,s2))!=z.end())return;\n    }\n  }\n  if(x==Slen){\n    set<int> cnt;\n    for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n    ans=min(ans,(int)cnt.size());\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\n/*void func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0;\n    for(int i=0;i<Slen;i++){\n      for(int j=i+1;j<Slen;j++){\n\tif(mark[i]!=mark[j])continue;\n\tstring s1=min(d[i],d[j]);\n\tstring s2=max(d[i],d[j]);\n\tif(z.find(P1(s1,s2))!=z.end()){\n\t  f=1;\n\t  break;\n\t}\n      }\n      if(f)break;\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n  }*/\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    set<string>::iterator ite;\n    int k=0;\n    for(ite=S.begin();ite!=S.end();ite++,k++)d[k]=(*ite);\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <complex>\nusing namespace std;\nusing ld = long double;\nusing P = complex<ld>;\nusing Pd = pair<ld, ld>;\nusing G = vector<P>;\nconst ld pi = acos(-1);\nconst ld eps = 1e-10;\nconst ld inf = 1e12;\ntypedef vector<P> region;\n\nld cross(const P& a, const P& b) { return a.real()*b.imag() - a.imag()*b.real(); }\nld dot(const P& a, const P& b) { return a.real()*b.real() + a.imag()*b.imag(); }\nenum { CCW = +1, CW = -1, BEHIND = +2, FRONT = -2, ON = 0 };\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > eps)  return CCW;    // counter clockwise\n\tif(cross(b, c) < -eps) return CW;     // clockwise\n\tif(dot(b, c) < 0)      return BEHIND; // c--a--b on line\n\tif(norm(b) < norm(c))  return FRONT;  // a--b--c on line\n\treturn ON;\n}\n\nstruct L : public vector<P> {\n\tL(const P &a = 0, const P &b = 0) {\n\t\tpush_back(a); push_back(b);\n\t}\n\tL(ld A, ld B, ld C) { // Ax + By + C = 0\n\t\tif(A < eps) *this = L(P(0, -C / B), P(1, -C / B));\n\t\telse if(B < eps) *this = L(P(-C / A, 0), P(-C / A, 1));\n\t\t*this = L(P(0, -C / B), P(-C / A, 0));\n\t}\n\tint ccw(const P& p) {\n\t\treturn ::ccw((*this)[0], (*this)[1], p);\n\t}\n};\n\nP projection(const L &l, const P &p) {\n\tld t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < eps; // triangle inequality\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nld distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif(intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\nld distanceSS(const L &s, const L &t) {\n\tif(intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n\nint n, C;\n\nbool adjacent(region r1, region r2) {\n\tint n1 = r1.size(), n2 = r2.size();\n\tfor(int i = 0; i < r1.size(); i++) {\n\t\tfor(int j = 0; j < r2.size(); j++) {\n\t\t\tP p11 = r1[i], p12 = r1[(i + 1) % n1];\n\t\t\tP p21 = r2[j], p22 = r2[(j + 1) % n2];\n\t\t\tif(p11.real() > p12.real()) swap(p11, p12);\n\t\t\tif(p21.real() > p22.real()) swap(p21, p22);\n\t\t\tL s1 = L(p11, p12), s2 = L(p21, p22);\n\t\t\tif(abs(cross(p11 - p12, p21 - p22)) > eps) continue;\n\t\t\tif(distanceSS(s1, s2) > eps) continue;\n\t\t\tvector<pair<Pd, int> > v;\n\t\t\tv.emplace_back(Pd(p11.real(), p11.imag()), 0);\n\t\t\tv.emplace_back(Pd(p12.real(), p12.imag()), 0);\n\t\t\tv.emplace_back(Pd(p21.real(), p21.imag()), 1);\n\t\t\tv.emplace_back(Pd(p22.real(), p22.imag()), 1);\n\t\t\tsort(v.begin(), v.end());\n\t\t\tif(v[1].first != v[2].first) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint adj[100][100];\nint use[100];\nint color[100];\nint color_num;\nint ans;\n\nbool check() {\n\tfor(int i = 0; i < C; i++) {\n\t\tfor(int j = i + 1; j < C; j++) {\n\t\t\tif(adj[i][j] && color[i] == color[j]) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid dfs(int n) {\n\tif(n == C) {\n\t\tif(check()) {\n\t\t\tans = min(ans, color_num);\n\t\t}\n\t\treturn;\n\t}\n\tfor(int c = 0; c < C; c++) {\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(adj[n][i] && c == color[i]) {\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(ok) {\n\t\t\tuse[c]++;\n\t\t\tif(use[c] == 1) color_num++;\n\t\t\tif(color_num < ans) {\n\t\t\t\tcolor[n] = c;\n\t\t\t\tdfs(n + 1);\n\t\t\t}\n\t\t\tuse[c]--;\n\t\t\tif(use[c] == 0) color_num--;\n\t\t}\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n, n) {\n\t\tmap<string, int> id;\n\t\tvector<string> name(n);\n\t\tvector<region> rs(n);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tcin >> name[i];\n\t\t\tid[name[i]] = -1;\n\t\t\tregion r;\n\t\t\tint a, b;\n\t\t\twhile(cin >> a, a != -1) {\n\t\t\t\tcin >> b;\n\t\t\t\tr.push_back(P(a, b));\n\t\t\t}\n\t\t\trs[i] = r;\n\t\t}\n\n\t\tC = 0;\n\t\tfor(auto& p : id) {\n\t\t\tid[p.first] = C++;\n\t\t}\n\n\t\tmemset(adj, 0, sizeof adj);\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tfor(int j = i + 1; j < n; j++) {\n\t\t\t\tint id1 = id[name[i]], id2 = id[name[j]];\n\t\t\t\tif(id1 == id2 || adj[id1][id2]) continue;\n\t\t\t\tif(adjacent(rs[i], rs[j])) {\n\t\t\t\t\tadj[id1][id2] = adj[id2][id1] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tuse[0] = 1;\n\t\tcolor_num = 1;\n\t\tans = 1000000;\n\t\tdfs(1);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define X real()\n#define Y imag()\n#define curr(P, i) P[(i)%P.size()]\n#define next(P, i) curr(P, (i+1))\n#define prev(P, i) curr(P, (i-1+P.size()))\nusing D = double;\nconst D EPS = 1e-8;\nusing P = complex<D>;\nusing G = vector<P>;\nnamespace std {\n    bool operator < (const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n};\nD dot(const P& a, const P& b) {\n    return (conj(a)*b).X;\n}\nD cross(const P& a, const P& b) {\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c) {\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\nstruct L : public vector<P> {\n    L(const P &a, const P &b) {\n        push_back(a); push_back(b);\n    }\n};\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nvoid f(L& l) {\n    auto v = l[1] - l[0];\n    l[0] += v*EPS;\n    l[1] -= v*EPS;\n}\nbool isHitGG(const G& a, const G& b) {\n    rep(i, a.size()) {\n        L s = {curr(a, i), next(a, i)};\n        f(s);\n        rep(j, b.size()) {\n            L t = {curr(b, j), next(b, j)};\n            f(t);\n            if(intersectSS(s, t)) return true;\n        }\n    }\n    return false;\n}\nbool isHitGsGs(const vector<G>& a, const vector<G>& b) {\n    for(auto&& g : a) for(auto&& h : b) {\n        if(isHitGG(g, h)) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    while(cin >> n) {\n        if(n == 0) break;\n        map<string, int> mp;\n        vector<vector<G>> gs;\n        rep(i, n) {\n            string s;\n            cin >> s;\n            if(mp.count(s) == 0) {\n                mp[s] = gs.size();\n                gs.push_back({});\n            }\n            G g;\n            {\n                int x, y;\n                while(cin >> x) {\n                    if(x == -1) break;\n                    cin >> y;\n                    g.push_back({(D)x, (D)y});\n                }\n            }\n            gs[mp[s]].push_back(g);\n        }\n        int m = mp.size();\n        vector<set<int>> sts(m);//同色で塗れるidx\n        rep(i, m) {\n            rep(j, i) {\n                if(!isHitGsGs(gs[i], gs[j])) {\n                    sts[i].insert(j);\n                    sts[j].insert(i);\n                }\n            }\n        }\n        const int INF = 1e9;\n        vector<int> dp(1<<m, INF);\n        dp[0] = 0;\n        REP(mask, 1, 1<<m) {\n            bool f = true;\n            rep(i, m) rep(j, i) {\n                if((mask&(1<<i)) && (mask&(1<<j))) {\n                    if(sts[i].count(j) == 0) f = false;\n                }\n            }\n            if(f) {\n                dp[mask] = 1;\n            }\n        }\n        REP(mask, 1, 1<<m) {\n            for(int A = (mask-1); A > 0; A = (A-1)&mask) {\n                int B = mask - A;\n                dp[mask] = min(dp[mask], dp[A]+dp[B]);\n            }\n        }\n        cout << dp[(1<<m)-1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing namespace std;\n\nusing ll=long long;\ninline int sgn(const ll& r){ return (r > 0) - (r < 0);}\n\nusing P=complex<ll>;\nusing L=struct{P s,t;};\n\nnamespace std{\n\tbool operator >  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)>0:sgn(imag(a-b))>0;}\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\ninline ll dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline ll det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\ninline bool cross(L a,L b){\n\tif(det(P(0,0),a.t-a.s,b.t-b.s)!=0) return false;\n\tconst int sa=ccw(a.s,a.t,b.s)|ccw(a.s,b.t,b.t);\n\tconst int sb=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif((sa&ON)==0) return false;\n\tif((sb&ON)==0) return false;\n\t\n\tusing state=tuple<P,int>;\n\n\tbool ok=true;\n\tvector<state> ary={state(a.s,0),state(a.t,0),state(b.s,1),state(b.t,1)};\n\tsort(_all(ary));\n\tif(get<1>(ary[0])==get<1>(ary[1])) return false;\n\tif(get<1>(ary[2])==get<1>(ary[3])) return false;\n\tif(get<0>(ary[1])==get<0>(ary[2])) return false;\n\t//cout << a.s << \" \" << a.t << \" \" << b.s << \" \" << b.t << endl;\n\treturn true;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tset<L> pol[110];\n\t\tmap<string,vector<int>> conv;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin >> s; \n\t\t\tconv[s].push_back(i);\n\n\t\t\tint x[110],y[110],m=0;\n\n\t\t\twhile(1){\n\t\t\t\tcin >> x[m];\n\t\t\t\tif(x[m]==-1) break;\n\t\t\t\tcin >> y[m++];\n\t\t\t}\n\n\t\t\trep(j,m){\n\t\t\t\tP a=P(x[j],y[j]);\n\t\t\t\tP b=P(x[(j+1)%m],y[(j+1)%m]);\n\t\t\t\tif(a>b) swap(a,b);\n\t\t\t\tpol[i].insert(L({a,b})); \n\t\t\t}\n\t\t}\n\n\t\tvector<string> ary;\n\t\tfor(auto &it:conv) ary.push_back(it.first);\n\t\tconst int m=ary.size();\n\n\t\tbool graph[110][110];\n\t\tclr(graph,0);\n\t\t\n\t\trep(i,n)rep(j,i){\n\t\t\tbool ok=false;\n\t\t\tfor(auto &line:pol[i]) for(auto &line2:pol[j]){\n\t\t\t\tif(ok) continue;\n\t\t\t\tif(cross(line,line2)) ok=true;\n\t\t\t}\n\t\t\tif(ok) graph[i][j]=graph[j][i]=true;\n\t\t}\n\n\t\tint index[10];\n\t\tiota(index,index+m,0);\n\n\t\tint ans=10;\n\n\t\tdo{\n\t\t\tint color[110];\n\t\t\tclr(color,-1);\n\n\t\t\trep(i,m){\n\t\t\t\tstring s= ary[i];\n\t\t\t\tset<int> used;\n\t\t\t\tfor(auto &v:conv[s]) rep(v2,n) if(graph[v][v2]) used.insert(color[v2]);\n\t\t\t\tint cmax=0;\n\t\t\t\twhile(used.find(cmax)!=used.end()) cmax++;\n\t\t\t\tfor(auto &v:conv[s]) color[v]=cmax;\n\t\t\t}\n\n\t\t\tint num=0;\n\t\t\trep(i,n) chmax(num,color[i]);\n\t\t\tchmin(ans,num+1);\n\n\t\t}while(next_permutation(index,index+m));\n\n\t\t// rep(i,n){\n\t\t// \trep(j,n) cout << graph[i][j] << \" \";\n\t\t// \tcout << endl;\n\t\t// }\n\n\t\t// const P a=P(10,50),b=P(20,40),c=P(35,25);\n\t\t// cout << cross(L({a,b}),L({a,c})) << endl;\n\t\t//for(auto &line:pol[2]) for(auto &line2:pol[3]) cout << cross(line,line2) << endl;\n\t\tcout << ans << endl;\n\t}\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-5;\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef vector<Polygon> Country;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n\nbool d[100][100];\nint color[10];\nint nv;\n\nint dfs(int x,int n){\n  if(x==nv){\n    return n;\n  }else{\n    int m=99;\n    for(int i=0;i<n+1;i++){\n      bool f=false;\n      for(int j=0;j<x;j++){\n\tf|=d[x][j]&&i==color[j];\n      }\n      if(!f){\n\tcolor[x]=i;\n\tm=min(m,dfs(x+1,max(n,i+1)));\n      }\n    }\n    return m;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    map<string,Country> m;\n    while(n--){\n      string s;\n      cin>>s;\n      Polygon p;\n      for(int x,y;cin>>x,x>=0;){\n\tcin>>y;\n\tp.push_back(P(x,y));\n      }\n      m[s].push_back(p);\n    }\n    vector<Country> c;\n    for(auto e:m){\n      c.push_back(e.second);\n    }\n    nv=c.size();\n    fill(d[0],d[10],false);\n    for(int i=0;i<c.size();i++){\n      for(auto e:c[i]){\n\tfor(int j=0;j<e.size();j++){\n\t  for(int k=0;k<i;k++){\n\t    for(auto f:c[k]){\n\t      for(int l=0;l<f.size();l++){\n\t\tP a=e[j],b=e[(j+1)%e.size()];\n\t\tP x=f[l],y=f[(l+1)%f.size()];\n\t\tif(fabs(cross(a-b,x-b))<eps&&fabs(cross(a-b,y-b)<eps)){\n\t\t  double pa,pb,pc,pd;\n\t\t  if(fabs(a.real()-b.real())<eps){\n\t\t    pa=min(a.imag(),b.imag());\n\t\t    pb=max(a.imag(),b.imag());\n\t\t    pc=min(x.imag(),y.imag());\n\t\t    pd=max(x.imag(),y.imag());\n\t\t  }else{\n\t\t    pa=min(a.real(),b.real());\n\t\t    pb=max(a.real(),b.real());\n\t\t    pc=min(x.real(),y.real());\n\t\t    pd=max(x.real(),y.real());\n\t\t  }\n\t\t  if(max(pa,pc)<min(pb,pd)-eps){\n\t\t    d[i][k]=d[k][i]=true;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num, const vi &ord){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[ord[d]][ord[i]])use[cols[ord[i]]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[ord[d]] = i;\n\tdfs(d+1,num,ord);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[ord[d]] = num;\n  dfs(d,num+1,ord);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    vi ord, rem;\n    rep(i,m)rem.pb(i);\n    while(rem.size()){\n      int id = 0, num = 0;\n      rep(j,rem.sz){\n\tint sum = 0;\n\trep(k,ord.sz){\n\t  if(g[rem[j]][ord[k]])sum++;\n\t}\n\tif(sum > num){\n\t  id = j; num = sum;\n\t}\n      }\n      ord.pb(rem[id]); rem.erase(rem.begin()+id);\n    }\n\n    ans = m; cols.resize(m);\n    dfs(0,0,ord);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nchar in[50];\nvector<pair<Pt,Pt> > p[12];\ndouble x[120];\ndouble y[120];\nint g[20][20];\nint col[20];\nint n;\nint solve(int a,int b){\n\tif(a==n)return 1;\n\tfor(int i=1;i<=b;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<a;j++)if(g[a][j]&&col[j]==i)ok=false;\n\t\tif(ok){\n\t\t\tcol[a]=i;\n\t\t\tint res=solve(a+1,b);\n\t\t\tif(res)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tn=0;\n\t\tfor(int i=0;i<12;i++)p[i].clear();\n\t\tfor(int i=0;i<20;i++)for(int j=0;j<20;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring tmp=in;\n\t\t\tint at;\n\t\t\tif(m.count(tmp))at=m[tmp];\n\t\t\telse {\n\t\t\t\tat=n;\n\t\t\t\tm[tmp]=n++;\n\t\t\t}\n\t\t\tint s=0;\n\t\t\twhile(1){\n\t\t\t\tscanf(\"%lf\",x+s);\n\t\t\t\tif(x[s]<-0.5)break;\n\t\t\t\tscanf(\"%lf\",y+s);\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tdouble X=x[i]*cos(1)-y[i]*sin(1);\n\t\t\t\tdouble Y=x[i]*sin(1)+y[i]*cos(1);\n\t\t\t\tx[i]=X;y[i]=Y;\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tp[at].push_back(make_pair(Pt(x[i],y[i]),Pt(x[(i+1)%s],y[(i+1)%s])));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(int k=0;k<p[i].size();k++){\n\t\t\t\t\tif(ok)break;\n\t\t\t\t\tfor(int l=0;l<p[j].size();l++){\n\t\t\t\t\t\tif(ok)break;\n\t\t\t\t\t\tif(iLL(p[i][k].first,p[i][k].second,p[j][l].first,p[j][l].second)==-1){\n\t\t\t\t\t\t\tif(max(p[i][k].first.x,p[i][k].second.x)<EPS+min(p[j][l].first.x,p[j][l].second.x))continue;\n\t\t\t\t\t\t\tif(min(p[i][k].first.x,p[i][k].second.x)+EPS>max(p[j][l].first.x,p[j][l].second.x))continue;\n\t\t\t\t\t\t\tok=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)g[i][j]=g[j][i]=1;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<20;j++)col[j]=0;\n\t\t\tif(solve(0,i)){\n\t\t\t\tans=i;break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-8)\n#define INF (1e9)\n#define X real()\n#define Y imag()\n#define N 100\n#define M 10\nusing namespace std;\ntypedef pair<string,string> P1;\ntypedef complex<double> P;\nint n,a,b,Slen,mark[M],ans;\nvector<P> v[N];\nset<string> S;\nstring s[N];\nset<P1> z;\n\nbool eq(double n1,double n2){return abs(n1-n2)<EPS;}\n\ndouble cross(P pa,P pb){return imag(conj(pa)*pb);}\n\nbool check(P A1,P A2,P B1,P B2){\n  bool r=false;\n  double Alen=abs(A2-A1);\n  double Blen=abs(B2-B1);\n  A2-=A1,B1-=A1,B2-=A1,A1-=A1;\n  B1=B1*conj(A2)/abs(A2);\n  B2=B2*conj(A2)/abs(A2);\n  A2=A2*conj(A2)/abs(A2);\n  double Xmin=min(min(A1.X,A2.X),min(B1.X,B2.X));\n  double Xmax=max(max(A1.X,A2.X),max(B1.X,B2.X));\n  if(A1.X>A2.X)swap(A1,A2);\n  if(B1.X>B2.X)swap(B1,B2);\n  double left=max(A1.X,B1.X);\n  double right=min(A2.X,B2.X);\n  if( EPS < right-left ) return true;\n  else return false;\n  \n  if(A1.X<=B1.X&&B1.X<=A2.X)r=true;\n  if(A1.X<=B2.X&&B2.X<=A2.X)r=true;\n  if(B1.X<=A2.X&&A2.X<=B2.X)r=true;\n  if(B1.X<=A1.X&&A1.X<=B2.X)r=true;\n  double l=abs(Xmin-Xmax);\n  if(eq(l,Alen+Blen))r=false;\n  if(!eq(B1.Y,0)||!eq(B2.Y,0))r=false;\n  return r;\n}\n\nvoid func(int x){\n  if(x==Slen){\n    set<string>::iterator ite;\n    int f=0,k1=0,k2;\n    for(ite=S.begin();ite!=S.end();ite++,k1++){\n      set<string>::iterator ite2=ite;\n      ite2++;\n      k2=k1+1;\n      while(ite2!=S.end()){\n\tif(mark[k1]!=mark[k2]){\n\t  ite2++;\n\t  k2++;\n\t  continue;\n\t}\n\tif(z.find(P1((*ite),(*ite2)))!=z.end()){\n\t  f=1;\n\t  break;\n\t}\n\tite2++;\n\tk2++;\n      }\n      if(f)break;\n    }\n    if(!f){\n      set<int> cnt;\n      for(int i=0;i<Slen;i++)cnt.insert(mark[i]);\n      ans=min(ans,(int)cnt.size());\n    }\n    return;\n  }\n  for(int i=0;i<=x;i++)mark[x]=i,func(x+1);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(!n)break;\n    for(int i=0;i<n;i++){\n      cin>>s[i];\n      S.insert(s[i]);\n      while(1){\n\tcin>>a;\n\tif(a<0)break;\n\tcin>>b;\n\tv[i].push_back(P(a,b));\n      }\n    }\n    Slen=S.size();\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tint leni=v[i].size();\n\tint lenj=v[j].size();\n\tstring s1=s[i],s2=s[j];\n\tif(s1==s2)continue;\n\tif(s1>s2)swap(s1,s2);\n\tfor(int k=0;k<leni;k++)\n\t  for(int l=0;l<lenj;l++){\n\t    P pa1=v[i][k],pa2=v[i][(k+1)%leni];\n\t    P pb1=v[j][l],pb2=v[j][(l+1)%lenj];\n\t    if(check(pa1,pa2,pb1,pb2))z.insert(P1(s1,s2));\n\t  }\n      }\n    }\n    ans=INF;\n    func(0);\n    cout<<ans<<endl;\n    for(int i=0;i<n;i++)v[i].clear();\n    S.clear();\n    z.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-9;\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef vector<Polygon> Country;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n\nbool d[100][100];\nint color[10];\nint nv;\n\nint dfs(int x,int n){\n  if(x==nv){\n    return n;\n  }else{\n    int m=99;\n    for(int i=0;i<n+1;i++){\n      bool f=false;\n      for(int j=0;j<x;j++){\n\tf|=d[x][j]&&i==color[j];\n      }\n      if(!f){\n\tcolor[x]=i;\n\tm=min(m,dfs(x+1,max(n,i+1)));\n      }\n    }\n    return m;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    map<string,Country> m;\n    while(n--){\n      string s;\n      cin>>s;\n      Polygon p;\n      for(int x,y;cin>>x,x>=0;){\n\tcin>>y;\n\tp.push_back(P(x,y));\n      }\n      m[s].push_back(p);\n    }\n    vector<Country> c;\n    for(auto e:m){\n      c.push_back(e.second);\n    }\n    nv=c.size();\n    fill(d[0],d[10],false);\n    for(int i=0;i<c.size();i++){\n      for(auto e:c[i]){\n\tfor(int j=0;j<e.size();j++){\n\t  for(int k=0;k<i;k++){\n\t    for(auto f:c[k]){\n\t      for(int l=0;l<f.size();l++){\n\t\tP a=e[j],b=e[(j+1)%e.size()];\n\t\tP x=f[l],y=f[(l+1)%f.size()];\n\t\tif(fabs(cross(a-b,x-b))<eps&&fabs(cross(a-b,y-b)<eps)){\n\t\t  double pa,pb,pc,pd;\n\t\t  if(fabs(a.real()-b.real())<eps){\n\t\t    pa=min(a.imag(),b.imag());\n\t\t    pb=max(a.imag(),b.imag());\n\t\t    pc=min(x.imag(),y.imag());\n\t\t    pd=max(x.imag(),y.imag());\n\t\t  }else{\n\t\t    pa=min(a.real(),b.real());\n\t\t    pb=max(a.real(),b.real());\n\t\t    pc=min(x.real(),y.real());\n\t\t    pd=max(x.real(),y.real());\n\t\t  }\n\t\t  if(max(pa,pc)<min(pb,pd)-eps){\n\t\t    d[i][k]=d[k][i]=true;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\nconst int MAXV = 50;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 2;   //counter clockwise\n  if (cross(b,c)<-EPS) return -2; //clockwise\n  if (dot(b, c)<-EPS) return 1;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\ninline void dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = m; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nint chromatic_number(const Matrix< bool > &g) {\n  int N = (int) g.size();\n  vector< int > es(N);\n  for(int i = 0; i < g.size(); i++) {\n    for(int j = 0; j < g.size(); j++) {\n      es[i] |= g[i][j] << j;\n    }\n  }\n  int ret = N;\n  for(int d : {7, 11, 21}) {\n    int mod = 1e9 + d;\n    vector< int > ind(1 << N), aux(1 << N, 1);\n    ind[0] = 1;\n    for(int S = 1; S < 1 << N; S++) {\n      int u = __builtin_ctz(S);\n      ind[S] = ind[S ^ (1 << u)] + ind[(S ^ (1 << u)) & ~es[u]];\n    }\n    for(int i = 1; i < ret; i++) {\n      int64_t all = 0;\n      for(int j = 0; j < 1 << N; j++) {\n        int S = j ^(j >> 1);\n        aux[S] = (1LL * aux[S] * ind[S]) % mod;\n        all += j & 1 ? aux[S] : mod - aux[S];\n      }\n      if(all % mod) ret = i;\n    }\n  }\n  return ret;\n}\n\n\nconst double EPS = 1e-10;\n\nstruct Point {\n  double x, y;\n\n  Point() {}\n\n  Point(double x, double y) : x(x), y(y) {}\n\n  Point operator+(Point p) { return Point(x + p.x, y + p.y); }\n\n  Point operator-(Point p) { return Point(x - p.x, y - p.y); }\n\n  Point operator*(double k) { return Point(x * k, y * k); }\n\n  Point operator/(double k) { return Point(x / k, y / k); }\n};\n\ntypedef Point Vector;\ntypedef vector< Point > Polygon;\n\ndouble norm(Vector a) {\n  return a.x * a.x + a.y * a.y;\n}\n\ndouble abs(Vector a) {\n  return sqrt(norm(a));\n}\n\ndouble cross(Vector a, Vector b) {\n  return a.x * b.y - a.y * b.x;\n}\n\nbool calc(Point a1, Point a2, Point b1, Point b2) {\n  if(abs(cross(a2 - a1, b1 - a1)) > EPS) return 0;\n  if(abs(cross(a2 - a1, b2 - a1)) > EPS) return 0;\n  double ml = 0;\n  ml = max(ml, abs(a1 - a2));\n  ml = max(ml, abs(a1 - b1));\n  ml = max(ml, abs(a1 - b2));\n  ml = max(ml, abs(a2 - b1));\n  ml = max(ml, abs(a2 - b2));\n  ml = max(ml, abs(b1 - b2));\n  return (ml + EPS < abs(a1 - a2) + abs(b1 - b2));\n}\n\nsigned main() {\n\n  int n;\n  while(cin >> n, n) {\n    vector< Polygon > p(n);\n    vector< string > name(n);\n    map< string, int > m;\n    for(int i = 0; i < n; i++) {\n      cin >> name[i];\n      if(!m.count(name[i])) {\n        int k = m.size();\n        m[name[i]] = k;\n      }\n      int x, y;\n      while(cin >> x, ~x) {\n        cin >> y;\n        p[i].push_back(Point(x, y));\n      }\n    }\n\n    Matrix< bool > G(m.size(), vector< bool >(m.size()));\n    for(int i = 0; i < n; i++) {\n      for(int j = i + 1; j < n; j++) {\n        if(name[i] == name[j]) continue;\n        for(int k = 0; k < (int) p[i].size(); k++) {\n          for(int l = 0; l < (int) p[j].size(); l++) {\n            if(calc(p[i][k], p[i][(k + 1) % p[i].size()],\n                    p[j][l], p[j][(l + 1) % p[j].size()])) {\n              G[m[name[j]]][m[name[i]]] = true;\n              G[m[name[i]]][m[name[j]]] = true;\n            }\n          }\n        }\n      }\n    }\n    cout << chromatic_number(G) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n\tif(num>=ans)return;\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  cin.tie(0); ios::sync_with_stdio(0);\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    /*\n    ans = m; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n    */\n    cout << 0 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point &a, Point &b, Point &c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2=a[(i+1)%a.size()], p3=b[j], p4=b[(j+1)%b.size()];\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge, vector<Polygon> *country, int n){\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(is_Touch(country[i], country[j])) edge[i].push_back(j), edge[j].push_back(i);\n    }\n  }\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      cin >> name;\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=10;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nPol pol[100];\nmap<string,int> mp;\nint I;\nint cntry[100];\nP operator -(P x,P y){\n\treturn P(x.fs-y.fs,x.sc-y.sc);\n}\ninline bool is(L a,L b){\n\tP x=a.sc-a.fs,y=b.sc-b.fs,z=b.fs-a.fs;\n\tif(x.fs*y.sc!=x.sc*y.fs) return 0;\n\tif(x.fs*z.sc!=x.sc*z.fs) return 0;\n\tint d=a.fs.fs,e=a.sc.fs,f=b.fs.fs,g=b.sc.fs;\n\tif(x.fs==0) d=a.fs.sc,e=a.sc.sc,f=b.fs.sc,g=b.sc.sc;\n\tif(d>e) swap(d,e);\n\tif(f>g) swap(f,g);\n\treturn max(d,f)<min(e,g);\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) pol[i].clear();\n\t\tmp.clear();\n\t\tI=0;\n\t\trep(i,N){\n\t\t\tstring st;\n\t\t\tcin>>st;\n\t\t\tif(!mp.count(st)) mp[st]=I++;\n\t\t\tcntry[i]=mp[st];\n\t\t\twhile(true){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x;\n\t\t\t\tif(x<0) break;\n\t\t\t\tcin>>y;\n\t\t\t\tpol[i].pb(P(x,y));\n\t\t\t}\n\t\t}\n\t\tbool e[10][10]={};\n\t\trep(i,I) e[i][i]=1;\n\t\trep(i,N) rep(j,i){\n\t\t\tint a=cntry[i],b=cntry[j];\n\t\t\tif(e[a][b]) continue;\n\t\t\trep(k,pol[i].size()) rep(l,pol[j].size()){\n\t\t\t\tL x=L(pol[i][k],pol[i][(k+1)%pol[i].size()]);\n\t\t\t\tL y=L(pol[j][l],pol[j][(l+1)%pol[j].size()]);\n\t\t\t\tif(is(x,y)){\n\t\t\t\t\te[a][b]=e[b][a]=1;\n\t\t\t\t\tgoto done;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone:\n\t\t\t;\n\t\t}\n\t\tbool ind[1024]={};\n/*\t\tshow(I);\n\t\trep(i,I){\n\t\t\trep(j,I) cout<<e[i][j]<<\" \";\n\t\t\tputs(\"\");\n\t\t}*/\n\t\trep(i,1<<I){\n\t\t\tind[i]=1;\n\t\t\trep(j,I) rep(k,j) if((i>>j)&(i>>k)&1) if(e[j][k]) ind[i]=0;\n\t\t}\n\t\tint dp[1024]={};\n\t\trep(i,1<<I){\n\t\t\tif(i==0) continue;\n\t\t\tdp[i]=11;\n\t\t\trep(j,1<<I){\n\t\t\t\tif((i|j)==i && ind[j]) chmin(dp[i],dp[i^j]+1);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[(1<<I)-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <cmath>\n#include <bitset>\nusing namespace std;\n\n#define EPS 1e-7\n\ntypedef complex<double> point;\ntypedef vector<point> polygon;\ntypedef const point &rpoint;\n\n\ndouble cross(rpoint v1, rpoint v2){\n\treturn v1.real() * v2.imag() - v1.imag() * v2.real();\n}\n\n//完全に含む。\nbool contains(rpoint va1, rpoint va2, rpoint vb){\n\tif( norm(va1 - vb) < EPS || norm(va2 - vb) < EPS ) return false;\n\treturn abs(abs(vb - va1) + abs(va2 - vb) - abs(va1 - va2)) < EPS;\n}\n\n//ここがだめ\nbool share(rpoint pa1, rpoint pa2, rpoint pb1, rpoint pb2){\n\tif( abs(cross(pa2 - pa1, pb1 - pa1)) > EPS ) return false;\n\tif( abs(cross(pa2 - pa1, pb2 - pa1)) > EPS ) return false;\n\n\tif( contains(pa1, pa2, pb1) || contains(pa1, pa2, pb2) || contains(pb1, pb2, pa1) || contains(pb1, pb2, pa2) )\n\t\treturn true;\n\tif( contains(pa1, pa2, (pb1 + pb2) * 0.5) )\n\t\treturn true;\n\t\n\treturn false;\n}\n\nbool adjacent(const polygon &plg1, const polygon &plg2){\n\tfor(int i = 1; i < plg1.size(); ++i){\n\t\tfor(int j = 1; j < plg2.size(); ++j){\n\t\t\tif( share(plg1[i-1], plg1[i], plg2[j-1], plg2[j]) )\n\t\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nbool adjacentcountry(const vector<polygon> &c1, const vector<polygon> &c2){\n\tfor(int i = 0; i < c1.size(); ++i){\n\t\tfor(int j = 0; j < c2.size(); ++j){\n\t\t\tif( adjacent(c1[i], c2[j]) ) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint m;\nint adj[10];\nint ans;\nint color[10];\n\nvoid paint(int t, int a){\n\tif( a >= ans ) return;\n\tif( t == m ){\n\t\tans = a;\n\t\treturn;\n\t}\n\n\tbool adjclr[11] = {};\n\tfor(int i = 0; i < t; ++i){\n\t\tif( (adj[t] >> i) & 1 ){\n\t\t\tadjclr[ color[i] ] = true;\n\t\t}\n\t}\n\n\tfor(int i = 1; i <= a; ++i){\n\t\tif( !adjclr[i] ){\n\t\t\tcolor[t] = i;\n\t\t\tpaint(t + 1, a);\n\t\t}\n\t}\n\t\n\tcolor[t] = a + 1;\n\tpaint(t + 1, a + 1);\n\tcolor[t] = 0;\n}\n\n\nint main(){\n\tint n;\n\twhile( cin >> n, n != 0 ){\n\t\tmap<string,int> nametbl;\n\n\t\tvector<vector<polygon> > country(10);\n\t\t\n\t\tstring name;\n\t\tint x, y;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tcin >> name;\n\t\t\tint number = nametbl.insert( make_pair(name, nametbl.size()) ).first->second;\n\t\t\t\n\t\t\tpolygon plg;\n\t\t\twhile( cin >> x, x != -1 ){\n\t\t\t\tcin >> y;\n\t\t\t\tplg.push_back( point(x, y) );\n\t\t\t}\n\t\t\t\n\t\t\tplg.push_back( plg[0] );\n\t\t\tcountry[number].push_back(plg);\n\t\t}\n\t\t\n\t\tm = nametbl.size();\n\t\tcountry.resize(m);\n\n\t\tfill(adj, adj + 10, 0);\n\n\t\tfor(int i = 0; i < m - 1; ++i){\n\t\t\tfor(int j = i + 1; j < m; ++j){\n\t\t\t\tif( (adj[i] >> j) & 1 ) continue;\n\n\t\t\t\tif( adjacentcountry(country[i], country[j]) ){\n\t\t\t\t\tadj[i] |= 1 << j;\n\t\t\t\t\tadj[j] |= 1 << i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n/*\ncout<<\"adj\\n\";\nfor(int i = 0; i < m; ++i){\n\tcout<<'\\t'<<i<<\": \"<<bitset<10>(adj[i])<<'\\n';\n}\n*/\n\n\t\tans = 10;\n\t\tfill(color, color + 10, 0);\n\t\tcolor[0] = 1;\n\n\t\tpaint(1, 1);\n\n\t\tcout << ans << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <iostream>\n#include <cmath>\n#define INF 1LL<<5\nusing namespace std;\nstruct P{\n\tint x,y;\n\tP(){}\n\tP(int xx,int yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tP operator +(P p){\n\t\treturn P(x+p.x,y+p.y);\n\t}\n\tP operator -(P p){\n\t\treturn P(x-p.x,y-p.y);\n\t}\n\tP operator *(int d){\n\t\treturn P(x*d,y*d);\n\t}\n\tbool operator ==(const P &p)const{\n\t\treturn (x==p.x && y==p.y);\n\t}\n};\n\ntypedef P Vector;\ntypedef vector<P> Polygon;\nint norm(P p){\n\treturn p.x*p.x+p.y*p.y;\n}\n\nint dot(P a,P b){\n\treturn a.x*b.x+a.y*b.y;\n}\n\nint cross(P a,P b){\n\treturn a.x*b.y-a.y*b.x;\n}\n\nint ccw(P p0,P p1,P p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>0)return 1;\n\tif(cross(a,b)<0)return -1;\n\tif(dot(a,b)<0)return 2;\n\tif(norm(a)<norm(b))return -2;\n\treturn 0;\n}\n\nbool intersect(P p1,P p2,P p3,P p4){\n\tif(ccw(p1,p2,p3)*ccw(p1,p2,p4)>0 || ccw(p3,p4,p1)*ccw(p3,p4,p2)>0)return false;\n\tif(ccw(p1,p2,p3)*ccw(p1,p2,p4)<0 && ccw(p3,p4,p1)*ccw(p3,p4,p2)<0)return true;\n\tif(ccw(p1,p2,p4)==0 && ccw(p1,p2,p3)==0)return true;\n\tif(ccw(p3,p4,p1)==0 && ccw(p3,p4,p2)==0)return true;\n\tif(ccw(p1,p2,p3)==0 && !(p1==p3) && !(p2==p3) && abs(ccw(p1,p2,p4))!=1)return true;\n\tif(ccw(p1,p2,p4)==0 && !(p1==p4) && !(p2==p4) && abs(ccw(p1,p2,p3))!=1)return true;\n\treturn false;\n}\n\n\n\nint n;\nmap<string,int> id;\nPolygon territory[101];\nvector<int> index[101];\nbool edge[11][11];\nvector<int> paint;\nint dp[1<<11];\n\nbool share(int c1,int c2){\n\tfor(int i=0;i<index[c1].size();i++){\n\t\tfor(int j=0;j<index[c2].size();j++){\n\t\t\tint t1=index[c1][i],t2=index[c2][j];\n\t\t\tfor(int k=0;k<territory[t1].size();k++){\n\t\t\t\tP p1=territory[t1][k];\n\t\t\t\tP p2=territory[t1][(k+1)%territory[t1].size()];\n\t\t\t\tfor(int l=0;l<territory[t2].size();l++){\n\t\t\t\t\tP p3=territory[t2][l];\n\t\t\t\t\tP p4=territory[t2][(l+1)%territory[t2].size()];\n\t\t\t\t\tif(intersect(p1,p2,p3,p4)){\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tint all=0;\n\t\tid.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tterritory[i].clear();\n\t\t\tindex[i].clear();\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(id.find(str)==id.end()){\n\t\t\t\tid[str]=all++;\n\t\t\t}\n\t\t\tindex[id[str]].push_back(i);\n\t\t\twhile(1){\n\t\t\t\tint x,y;\n\t\t\t\tscanf(\"%d\",&x);\n\t\t\t\tif(x==-1)break;\n\t\t\t\tscanf(\"%d\",&y);\n\t\t\t\tterritory[i].push_back(P(x,y));\n\t\t\t}\n\t\t}\n\t\tmemset(edge,false,sizeof(edge));\n\t\tfor(int i=0;i<all;i++){\n\t\t\tfor(int j=i+1;j<all;j++){\n\t\t\t\tif(share(i,j)){\n\t\t\t\t\tedge[i][j]=true;\n\t\t\t\t\tedge[j][i]=true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<all;i++){\n\t\t\tfor(int j=0;j<all;j++){\n\t\t\t\tprintf(\"%c%c\",edge[i][j]?'y':'n',j==all-1?'\\n':' ');\n\t\t\t}\n\t\t}\n\t\tpaint.clear();\n\t\tfor(int i=0;i<(1<<all);i++){\n\t\t\tbool flag=true;\n\t\t\tfor(int j=0;j<all;j++){\n\t\t\t\tif(!((i>>j) & 1))continue;\n\t\t\t\tfor(int k=j+1;k<all;k++){\n\t\t\t\t\tif(!((i>>k) & 1))continue;\n\t\t\t\t\tif(edge[j][k])flag=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag)paint.push_back(i);\n\t\t}\n\t\tfill(dp,dp+(1<<all),INF);\n\t\tdp[0]=0;\n\t\tfor(int i=0;i<(1<<all);i++){\n\t\t\tif(dp[i]==INF)continue;\n\t\t\tfor(int j=0;j<paint.size();j++){\n\t\t\t\tint k=paint[j];\n\t\t\t\tdp[i|k]=min(dp[i|k],dp[i]+1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dp[(1<<all)-1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <array>\nusing namespace std;\nconst int inf = 1e9;\nconst double EPS = 1e-10;\nconst double INF = 1e18;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nbool strictItsSP(const L &s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<-EPS;\n}\nbool overlapSS(const L &a, const L &b){\n    return strictItsSP(a, b[0]) || strictItsSP(a, b[1]) ||\n        strictItsSP(b, a[0]) || strictItsSP(b, a[1]) ||\n        (a[0]==b[0] && a[1]==b[1]) || (a[0]==b[1] && a[1]==b[0]);\n}\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        map<string, int> name;\n        vector<vector<L> > edge;\n        int num = 0;\n        for(int i=0; i<n; i++){\n            string city;\n            cin >> city;\n            if(name.count(city) == 0){\n                name[city] = num;\n                num++;\n                edge.push_back(vector<L>());\n            }\n            VP v;\n            while(1){\n                int x,y;\n                cin >> x;\n                if(x == -1) break;\n                cin >> y;\n                v.push_back(P(x, y));\n            }\n            for(int j=0; j<(int)v.size(); j++){\n                edge[name[city]].push_back(L(v[j], v[(j+1)%v.size()]));\n            }\n        }\n\n        vector<vector<bool> > adj(num, vector<bool>(num, false));\n        for(int i=0; i<num; i++){\n            for(int j=i+1; j<num; j++){\n                for(int k=0; k<(int)edge[i].size(); k++){\n                    for(int l=0; l<(int)edge[j].size(); l++){\n                        if(isParallel(edge[i][k], edge[j][l]) && overlapSS(edge[i][k], edge[j][l])){\n                            adj[i][j] = adj[j][i] = true;\n                            k = edge[i].size();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        int ans = inf;\n        vector<int> ord(num);\n        for(int i=0; i<num; i++) ord[i] = i;\n        do{\n            int count = 1;\n            int last = 0;\n            for(int i=1; i<num; i++){\n                for(int j=last; j<i; j++){\n                    if(adj[ord[i]][ord[j]]){\n                        count++;\n                        last = i;\n                        break;\n                    }\n                }\n            }\n            ans = min(ans, count);\n        }while(next_permutation(ord.begin(), ord.end()));\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cmath>\n#include<cstdio>\n#include<string>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\n/*** geometry part ***/\n\nstruct point{\n\tdouble x,y;\n\tpoint():x(0),y(0){}\n\tpoint(double x,double y):x(x),y(y){}\n\tpoint operator-(const point &a)const{ return point(x-a.x,y-a.y); }\n\tbool operator==(const point &a)const{ return abs(x-a.x)<EPS && abs(y-a.y)<EPS; }\n\tbool operator!=(const point &a)const{ return abs(x-a.x)>EPS || abs(y-a.y)>EPS; }\n};\n\ndouble dot(const point &a,const point &b){ return a.x*b.x+a.y*b.y; }\n\ndouble cross(const point &a,const point &b){ return a.x*b.y-a.y*b.x; }\n\nstruct segment{\n\tpoint a,b;\n\tsegment(){}\n\tsegment(const point &a,const point &b):a(a),b(b){}\n};\n\ntypedef vector<point> polygon;\n\nbool cover(const segment &S,const point &p){\n\treturn abs(cross(S.a-p,S.b-p))<EPS && dot(S.a-p,S.b-p)<EPS;\n}\n\n// 二つの線分が長さ正の部分で接しているかどうか\nbool touch(const segment &S,const segment &T){\n\tif(abs(cross(S.b-S.a,T.b-T.a))>EPS) return false; // 平行でないとダメ\n\tif(S.a==T.a && S.b==T.b\n\t|| S.a==T.b && S.b==T.a) return true;\n\treturn cover(S,T.a) && S.a!=T.a && S.b!=T.a\n\t\t|| cover(S,T.b) && S.a!=T.b && S.b!=T.b\n\t\t|| cover(T,S.a) && T.a!=S.a && T.b!=S.a\n\t\t|| cover(T,S.b) && T.a!=S.b && T.b!=S.b;\n}\n\n// 二つの多角形が長さ正の部分で接しているかどうか\nbool touch(const polygon &F,const polygon &G){\n\tint m=F.size(),n=G.size();\n\trep(i,m) rep(j,n) {\n\t\tsegment S(F[i],F[(i+1)%m]);\n\t\tsegment T(G[j],G[(j+1)%n]);\n\t\tif(touch(S,T)) return true;\n\t}\n\treturn false;\n}\n\n/*** end ***/\n\n/*** graph part ***/\n\nint N; // 異なる国の個数\nbool G[10][10]; // 国どうしの接続関係のグラフ\n\nint color[10];\n// 彩色\nint dfs(int u,int next){\n\tif(u==N) return next;\n\n\tint res=N;\n\trep(c,next+1){\n\t\tbool ok=true;\n\t\trep(v,N) if(G[u][v] && color[v]==c) ok=false;\n\t\tif(ok){\n\t\t\tcolor[u]=c;\n\t\t\tres=min(res,dfs(u+1,max(c+1,next)));\n\t\t}\n\t}\n\treturn res;\n}\n\n/*** end ***/\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tstring name[100];\n\t\tpolygon F[100];\n\t\trep(i,n){\n\t\t\tchar s[32]; scanf(\"%s\",s);\n\t\t\tname[i]=s;\n\t\t\twhile(1){\n\t\t\t\tpoint p;\n\t\t\t\tscanf(\"%lf\",&p.x);\n\t\t\t\tif(p.x==-1) break;\n\t\t\t\tscanf(\"%lf\",&p.y);\n\t\t\t\tF[i].push_back(p);\n\t\t\t}\n\t\t}\n\n\t\tmap<string,int> f;\n\t\trep(i,n) if(f.count(name[i])==0) f.insert(make_pair(name[i],f.size()));\n\n\t\tN=f.size();\n\t\trep(u,N) rep(v,N) G[u][v]=false;\n\t\trep(i,n) rep(j,n) {\n\t\t\tint u=f[name[i]],v=f[name[j]];\n\t\t\tif(u!=v && !G[u][v] && touch(F[i],F[j])) G[u][v]=true;\n\t\t}\n\n\t\trep(u,N) color[u]=-1;\n\t\tprintf(\"%d\\n\",dfs(0,0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<vector>\n#include<climits>\n#include<cfloat>\n#include<map>\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1) % P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n \nusing namespace std;\n \ndouble EPS = 1e-10;\nconst double PI = acos(-1);\n\ndouble add(double a, double b){\n  if(abs(a+b) < EPS * (abs(a)+abs(b)))return 0;\n  return a+b;\n}\n\nstruct point{\n  double x, y;\n  point(){}\n  point(double x,double y) : x(x) , y(y){}\n  \n  point operator + (point p){\n    return point(add(x,p.x), add(y,p.y));\n  }\n  \n  point operator - (point p){\n    return point(add(x,-p.x), add(y,-p.y));\n  }\n  \n  point operator * (double d){\n    return point(x*d,y*d);\n  }\n  \n  point operator / (double d){\n    return point(x/d,y/d);\n  }\n  \n  bool operator == ( const point &p ) const {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n  \n  bool operator < (const point &p) const {\n    if(p.x != x)return p.x<x;\n    return p.y < y;\n  }\n};\ntypedef point Vector;\ntypedef pair<point,point> Line;\ntypedef vector<point> Polygon;\n\nclass Segment{\npublic:\n  point p1, p2;\n  Segment(){}\n  Segment(point p1,point p2):p1(p1), p2(p2){}\n};\n\ndouble dot(point a, point b) {\n  return (a.x * b.x + a.y * b.y);\n}\n\ndouble cross(point a, point b) {\n  return (a.x * b.y - a.y * b.x);\n}\n\ndouble norm(point a){\n  return sqrt(a.x*a.x+a.y*a.y);\n}\n\nint is_parallel(point a1, point a2, point b1, point b2) {\n  return cross(a1-a2, b1-b2)==0.0 ;\n}\n\nint isOnSegment(point a, point b, point c) {\n  return cross(b-a, c-a)==0.0 &&\n    (dot(b-a, c-a) > -EPS) &&\n    (dot(a-b, c-b) > -EPS);\n}\n\nint is_intersected_ls(point a1, point a2, point b1, point b2) {\n  \n  if(cross(a1-a2,b1-b2)==0){\n    return isOnSegment(a1,a2,b1) || isOnSegment(a1,a2,b2)\n      || isOnSegment(b1,b2,a1) || isOnSegment(b1,b2,a2);\n  }\n  else {\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n      ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n  }\n}\n\nvector<int>g[11];\nint used[11];\n\nvoid dfs(int v){\n  \n  bool fg[11];\n  fill(fg,fg+11,false);\n  for(int i=0;i<g[v].size();i++){\n    fg[used[g[v][i]]]=true;\n  }\n  \n  for(int i=1;i<11;i++){\n    if(!fg[i]){\n      used[v]=i;\n      break;\n    }\n  }\n\n  for(int i=0;i<g[v].size();i++){\n    if(used[g[v][i]]>0)continue;\n    dfs(g[v][i]);\n  }\n}\n\nint main(void){\n\n  int n;\n  while(cin >> n,n){\n    string s;\n    vector<point>pol[11];\n    map<string,int>id;\n    int sz=1;\n\n    for(int i=0;i<n;i++){\n      cin >> s;\n      if(!id.count(s))sz++,id[s]=i;\n      point in;\n      while(true){\n\tcin >> in.x;\n\tif(in.x<0)break;\n\tcin >> in.y;\n\tpol[id[s]].push_back(in);\n      }\n    }\n\n    for(int i=0;i<11;i++)g[i].clear();\n    \n    for(int i=0;i<sz;i++){\n      for(int j=i+1;j<sz;j++){\n\tfor(int k=0;k<pol[i].size();k++){\n\t  for(int l=0;l<pol[j].size();l++){\n\t    point cri=curr(pol[i],k),nxi=next(pol[i],k);\n\t    point crj=curr(pol[j],l),nxj=next(pol[j],l);\n\n\t    if(is_intersected_ls(cri,nxi,crj,nxj)){\n\t      if(is_parallel(cri,nxi,crj,nxj)){\n\t\tif(cri==crj || nxi==nxj)continue;\n\t\tg[i].push_back(j);\n\t\tg[j].push_back(i);\n\t\tgoto end;\n\t      }\n\t    }\n\t  }\n\t}\n      end:;\n      }\n    }\n\n    fill(used,used+11,0);\n    dfs(0);\n\n    int mx=0;\n    for(int i=0;i<11;i++)mx=max(mx,used[i]);   \n    cout << mx << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point &a, Point &b, Point &c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2, p3=b[j], p4;\n      if(i==a.size()-1 && j==b.size()-1){\n\tp2=a[0];\n\tp4=b[0];\n      }else if(i==a.size()-1){\n\tp2=a[0];\n\tp4=b[j+1];\n      }else if(j==b.size()-1){\n\tp2=a[i+1];\n\tp4=b[0];\n      }else{\n\tp2=a[i+1];\n\tp4=b[j+1];\n      }\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge, vector<Polygon> *country, int n){\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(is_Touch(country[i], country[j])) edge[i].push_back(j), edge[j].push_back(i);\n    }\n  }\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      cin >> name;\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=4;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <complex>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> L;\ntypedef vector<xy_t> polygon;\n\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\n#define EQ(a, b) (abs((a) - (b)) < EPS)\n#define DI(l) ((l).second-(l).first)\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n\ndouble cross(const xy_t &a, const xy_t &b) { return imag(conj(a)*b); }\ndouble dot(const xy_t& a, const xy_t& b) { return real(conj(a)*b); }\n\nint ccw(xy_t a, xy_t b, xy_t c) {\n\tdouble d = cross(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n\nbool parallel(const L &l, const L &m) { return EQ(cross(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(cross(DI(l), m.second-l.first), 0); }\n\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\n\nL shorten(const L &l){\n  xy_t p1 = l.first;\n  xy_t p2 = l.second;\n  \n  if(p1.real() > p2.real()){\n    p1.real() -= EPS;\n    p2.real() += EPS;\n  }else if(p1.real() < p2.real()){\n    p1.real() += EPS;\n    p2.real() -= EPS;\n  }\n\n  if(p1.imag() > p2.imag()){\n    p1.imag() -= EPS;\n    p2.imag() += EPS;\n  }else if(p1.imag() < p2.imag()){\n    p1.imag() += EPS;\n    p2.imag() -= EPS;\n  }\n  return L(p1, p2);\n}\n\nbool share_border(const polygon &p1, const polygon &p2){\n  int n = p1.size();\n  int m = p2.size();\n  REP(i, n)REP(j, m){\n    L l1 = shorten(L(p1[i], p1[(i+1)%n]));\n    L l2 = shorten(L(p2[j], p2[(j+1)%m]));\n    if(sameline(l1, l2) && intersectSS(l1, l2)) return true;\n  } \n  return false;\n}\n\nbool dfs(int v, const vector<vector<bool> > &g, vector<int> &color, int C){\n  int n = g.size();\n  if(v == n) return true;\n  REP(c, C){\n    bool ok = true;\n    REP(i, v) if(g[v][i] && color[i] == c) ok = false;\n    \n    if(ok){\n      color[v] = c;\n      if(dfs(v + 1, g, color, C)) return true;\n      color[v] = -1;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n && n > 0){\n    vector<string> names(n);\n    map<string, int> ID;\n    vector<polygon> polys(n);\n    \n    REP(i, n){\n\n      cin >> names[i];\n      if(ID.find(names[i]) == ID.end()){\n\tint count = ID.size();\n\tID[names[i]] = count;\n      }\n      int x, y;            \n      while(cin >> x && x != -1 && cin >> y){\n\tpolys[i].PB(xy_t(x, y));\n      }\n    }\n\n    int c_size = ID.size();\n    vector<vector<bool> > g(c_size, vector<bool>(c_size, false));    \n    \n    REP(i, n)REP(j, i)if(share_border(polys[i], polys[j])){\n      g[ID[names[i]]][ID[names[j]]] = true;\n      g[ID[names[j]]][ID[names[i]]] = true;      \n    }\n\n    \n    vector<int> color(c_size, -1);\n    // REP(i, c_size)REP(j, c_size) cout << g[i][j] << (j + 1 == c_size ? '\\n': ' ');\n    \n    if(dfs(0, g, color, 1)){\n      cout << 1 << endl;\n    }else if(dfs(0, g, color, 2)){\n      cout << 2 << endl;\n    }else if(dfs(0, g, color, 3)){\n      cout << 3 << endl;\n    }else{\n      cout << 4 << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return x < a.x || x == a.x && y < a.y; }\n\tbool operator==(const Pt &a) const { return x == a.x && y == a.y; }\n\tbool operator!=(const Pt &a) const { return x != a.x || y != a.y; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\n\n// end of library from hos\n\nint iSP2(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) <= 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) <= 0) return +2; // a-b-c\n\treturn 0;\n}\n\ndouble area(vector<Pt> p){\n\tdouble res = 0;\n\trep(i,sz(p)){\n\t\tres += p[i].det(p[(i+1) % sz(p)]);\n\t}\n\treturn res / 2;\n}\n\nint n;\nmap<string,vector<vector<Pt>>> M;\nstring name[11];\nint g[11][11];\nint ok[1<<11];\nint dp[1<<11];\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\twhile(cin>>n && n){\n\t\tM.clear();\n\t\tmemset(g,0,sizeof(g));\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tvector<Pt> p;\n\t\t\tint x,y;\n\t\t\twhile(cin>>x && x!=-1){\n\t\t\t\tcin>>y;\n\t\t\t\tp.pb(Pt(x,y));\n\t\t\t}\n\t\t\tif(area(p) < 0){\n\t\t\t\treverse(p.begin(),p.end());\n\t\t\t}\n\t\t\tM[s].pb(p);\n\t\t}\n\n\t\tint c = 0;\n\t\tforeach(it,M){\n\t\t\tname[c++] = it->fir;\n\t\t}\n\n\t\trep(I,c)rep2(J,I+1,c){\n\t\t\tauto &v1 = M[name[I]], &v2 = M[name[J]];\n\t\t\trep(i,sz(v1))rep(j,sz(v2))rep(ii,sz(v1[i]))rep(jj,sz(v2[j])){\n\t\t\t\tint res1 = iSP2(v1[i][ii], v1[i][(ii+1) % sz(v1[i])], v2[j][jj]);\n\t\t\t\tint res2 = iSP2(v1[i][ii], v1[i][(ii+1) % sz(v1[i])], v2[j][(jj+1) % sz(v2[j])]);\n\t\t\t\tif(res1 > res2) swap(res1, res2);\n\t\t\t\tif((res1 == -2 || res1 == 0) && (res2 == 0 || res2 == +2)){\n\t\t\t\t\t//cout<<name[I]<<\" \"<<name[J]<<\" \"<<v1[i][ii]<<\" \"<<v1[i][(ii+1) % sz(v1[i])]<<\" \"<<v2[j][jj]<<\" \"<<v2[j][(jj+1) % sz(v2[j])]<<endl;\n\t\t\t\t\tg[I][J] = g[J][I] = 1;\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t}\n\t\t\tend:;\n\t\t}\n\n\t\t/*rep(i,c)rep(j,c){\n\t\t\tcout<<g[i][j]<<\" \";if(j==c-1)cout<<endl;\n\t\t}*/\n\n\t\trep(i,1<<c) ok[i]=1, dp[i]=INF;\n\t\tdp[0] = 0;\n\t\trep(mask,1<<c){\n\t\t\trep(i,n)if(mask>>i&1)rep(j,n)if(mask>>j&1){\n\t\t\t\tif(g[i][j]) ok[mask] = 0;\n\t\t\t}\n\t\t}\n\n\t\trep(mask,1<<c){\n\t\t\trep(sub,1<<c)if((mask&sub) == sub && ok[sub]){\n\t\t\t\tdp[mask] = min(dp[mask], dp[mask^sub] + 1);\n\t\t\t}\n\t\t}\n\t\tcout<<dp[(1<<c)-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\n\nconst ld pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ??´?????¨??´????????????\nvector<Point> is_ll2(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tif (cross(sv, tv) != 0)return vector<Point>(1, is_ll(s, t));\n\telse {\n\t\tvector<Point>ans;\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tif (isis_sp(s, t[k]) && find(ans.begin(), ans.end(), t[k]) == ans.end())ans.push_back(t[k]);\n\t\t\tif (isis_sp(t, s[k]) && find(ans.begin(), ans.end(), s[k]) == ans.end())ans.push_back(s[k]);\n\t\t}\n\t\treturn ans;\n\t}\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\t//??????isis_ss?????????\n\t\tassert(false);\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n//???????????????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_circle(const Circle &cir, const  Point& p) {\n\tld dis = abs(cir.p - p);\n\tif (dis > cir.r + eps)return 0;\n\telse if (dis < cir.r - eps)return 2;\n\telse return 1;\n}\n//???lc??????rc??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint circle_in_circle(const Circle &lc, const  Circle&rc) {\n\tld dis = abs(lc.p - rc.p);\n\tif (dis < rc.r - lc.r - eps)return 2;\n\telse if (dis>rc.r - lc.r + eps)return 0;\n\telse return 1;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n//??????????????????????????¢???\nld two_circle_area(const Circle&l, const Circle&r) {\n\tld dis = abs(l.p - r.p);\n\tif (dis > l.r + r.r)return 0;\n\telse if (dis + r.r < l.r) {\n\t\treturn r.r*r.r*pi;\n\t}\n\telse if (dis + l.r < r.r) {\n\t\treturn l.r*l.r*pi;\n\t}\n\telse {\n\t\tld ans = (l.r)*(l.r)*acos((dis*dis + l.r*l.r - r.r*r.r) / (2 * dis*l.r)) +\n\t\t\t(r.r)*(r.r)*acos((dis*dis + r.r*r.r - l.r*l.r) / (2 * dis*r.r)) -\n\t\t\tsqrt(4 * dis*dis*l.r*l.r - (dis*dis + l.r*l.r - r.r*r.r)*(dis*dis + l.r*l.r - r.r*r.r)) / 2;\n\t\treturn ans;\n\t}\n\n}\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\nstruct Edge {\n\tint src, dst;\n\tWeight weight;\n\tEdge(int src, int dst, Weight weight) :\n\t\tsrc(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\nbool check(const vector<Point>&l, const vector<Point>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tfor (int j = 0; j < r.size(); ++j) {\n\t\t\tLine ll(l[i], l[(i + 1) % l.size()]);\n\t\t\tLine rl(r[j], r[(j + 1) % r.size()]);\n\t\t\tif (is_ll2(ll, rl).size() >= 2)return true;\n\t\t}\n\t}\n\treturn false;\n}\nint dfs(const int now, const vector<vector<int>>&edges, vector<int>colors,const int amax) {\n\tif (now == edges.size())return amax;\n\telse {\n\t\tint ans = 22;\n\t\tfor (int c = 0; c <= amax + 1; ++c) {\n\t\t\tbool ok = true;\n\t\t\tfor (int j = 0; j < now; ++j) {\n\t\t\t\tif (edges[now][j] && colors[j] == c)ok = false;\n\t\t\t}\n\t\t\tif (ok) {\n\t\t\t\tcolors.push_back(c);\n\t\t\t\tans = min(ans, dfs(now + 1, edges, colors, max(amax, c)));\n\t\t\t\tcolors.pop_back();\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tvector<pair<int, vector<Point>>>ters;\n\t\tint id = 0;\n\t\twhile (N--) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (mp.find(st) == mp.end())mp[st] = id++;\n\t\t\tvector<Point>ps;\n\t\t\twhile (1) {\n\t\t\t\tint x; cin >> x;\n\t\t\t\tif (x == -1)break;\n\t\t\t\tint y; cin >> y;\n\t\t\t\tPoint p(x, y);\n\t\t\t\tps.push_back(p);\n\t\t\t}\n\t\t\tters.push_back(make_pair(mp[st], ps));\n\t\t}\n\t\tvector<vector<int>>edges(id,vector<int>(id,false));\n\t\tfor (int i = 0; i < ters.size(); ++i) {\n\t\t\tfor (int j = i + 1; j < ters.size(); ++j) {\n\t\t\t\t\n\t\t\t\tif (check(ters[i].second, ters[j].second)) {\n\t\t\t\t\tedges[ters[i].first][ters[j].first] = true;\n\t\t\t\t\tedges[ters[j].first][ters[i].first] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>colors;\n\t\tint ans = dfs(0,edges,colors,-1);\n\t\tcout << ans+1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point &a, Point &b, Point &c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2, p3=b[j], p4;\n      if(i==a.size()-1 && j==b.size()-1){\n\tp2=a[0];\n\tp4=b[0];\n      }else if(i==a.size()-1){\n\tp2=a[0];\n\tp4=b[j+1];\n      }else if(j==b.size()-1){\n\tp2=a[i+1];\n\tp4=b[0];\n      }else{\n\tp2=a[i+1];\n\tp4=b[j+1];\n      }\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nvoid make_graph(vector<int> *edge, vector<Polygon> *country, int n){\n  for(int i=0;i<n;i++){\n    for(int j=i+1;j<n;j++){\n      if(is_Touch(country[i], country[j])) edge[i].push_back(j), edge[j].push_back(i);\n    }\n  }\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=now;i>=0;i--){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      cin >> name;\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=4;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npii operator-(const pii &a,const pii &b){\n    return make_pair(a.first-b.first,a.second-b.second);\n}\n\nvoid solve(int n){\n    map<string,int> t;\n    vector<vector<int>> vs;\n    vector<vector<pii>> ps;\n    int size=0;\n    rep(i,0,n){\n        string str;\n        cin >> str;\n        if(t.find(str)==t.end()){\n            t[str]=size;\n            vs.push_back(vector<int>());\n            ps.push_back(vector<pii>());\n            ++size;\n        }\n        int idx=t[str];\n        vs[idx].push_back(i);\n        while(true){\n            int x,y;\n            cin >> x;\n            if(x==-1) break;\n            cin >> y;\n            ps[idx].push_back(make_pair(x,y));\n        }\n    }\n\n    auto cross=[](pii &a,pii &b){\n        return a.first*b.second-a.second*b.first;\n    };\n\n    vector<vector<int>> graph(size);\n    rep(i,0,size) rep(j,0,i){\n        if([&](){\n            rep(i_,0,ps[i].size()) rep(j_,0,ps[j].size()){\n                pii &p1=ps[i][i_],&p2=ps[i][(i_+1)%ps[i].size()];\n                pii &q1=ps[j][j_],&q2=ps[j][(j_+1)%ps[j].size()];\n                pii a=p1-p2,b=q1-q2;\n                pii c=p1-q2,d=p2-q1;\n                if(cross(a,b)) continue;\n                if(cross(c,d)) continue;\n                if(a.first and (max(p1.first,p2.first)==min(q1.first,q2.first) or min(p1.first,p2.first)==max(q1.first,q2.first))) continue;\n                if(a.second and (max(p1.second,p2.second)==min(q1.second,q2.second) or min(p1.second,p2.second)==max(q1.second,q2.second))) continue;\n                return true;\n            }\n            return false;\n        }()){\n            graph[i].push_back(j);\n            graph[j].push_back(i);\n        }\n    }\n\n    vector<int> dp(1<<size,inf);\n    vector<bool> done(1<<size);\n    dp[0]=0;\n    done[0]=true;\n    rep(i,0,size){\n        dp[1<<i]=1;\n        done[1<<i]=true;\n    }\n    rep(s,0,1<<size) rep(t,0,1<<size){\n        if((s&t)!=t or (s|t)!=s) continue;\n        if(![&](){\n            int d=s&~t;\n            rep(i,0,size){\n                if(!((d>>i)&1)) continue;\n                for(int j:graph[i]) if((d>>j)&1) return false;\n            }\n            return true;\n        }()) continue;\n        dp[s]=min(dp[s],dp[t]+1);\n    }\n\n    cout << dp[(1<<size)-1] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\nconst int MAXV = 50;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 2;   //counter clockwise\n  if (cross(b,c)<-EPS) return -2; //clockwise\n  if (dot(b, c)<-EPS) return 1;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  rep(i,num){\n    bool f = true;\n    rep(j,d){\n      if(g[d][j] && cols[j]==i){\n\tf = false; break;\n      }\n    }\n    if(f){\n      cols[d] = i;\n      dfs(d+1,num);\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<map>\n#define PMAX 100\n#define TMAX 100\n#define CMAX 10\nusing namespace std;\n#define EPS 0.0001\n\nstruct Point{ int x, y;};\n\nclass Territory{\n    public:\n    int npoint;\n    string cname;\n    Point points[PMAX];\n    Territory(){}\n    Territory(string cname):cname(cname){\n\tnpoint = 0;\n    }\n\n    void addPoint( int x, int y ){ \n\tpoints[npoint].x = x;\n\tpoints[npoint++].y = y;\n    }\n};\n\nint ncountry, nterritory;\nTerritory T[TMAX];\nmap<string, int> M; /* name to id */\nbool G[CMAX][CMAX];\n\nbool overlap( Point p1, Point p2, Point p3, Point p4 ){\n    double dx1 = (double)p2.x - p1.x;\n    double dy1 = (double)p2.y - p1.y;\n    double dx2 = (double)p4.x - p3.x;\n    double dy2 = (double)p4.y - p3.y;\n    double dx3 = (double)p3.x - p1.x;\n    double dy3 = (double)p3.y - p1.y;\n    if ( dx1*dy2 != dy1*dx2 ) return false;\n    if ( dx1*dy3 != dy1*dx3 ) return false;\n\n    if ( p1.x != p2.x ){\n\tif ( max( p1.x, p2.x ) <= min( p3.x, p4.x ) ||\n\t     min( p1.x, p2.x ) >= max( p3.x, p4.x ) ) return false;\n    }\n    if ( p1.y != p2.y ){\n\tif ( max( p1.y, p2.y ) <= min( p3.y, p4.y ) ||\n\t     min( p1.y, p2.y ) >= max( p3.y, p4.y ) ) return false;\n    }\n\n    return true;\n}\n\nbool isAdj( Territory t1, Territory t2 ){\n    for ( int i = 0; i < t1.npoint; i++ ){\n\tfor ( int j = 0; j < t2.npoint; j++ ){\n\t    if ( overlap( t1.points[i], t1.points[(i+1)%t1.npoint],\n\t\t\t  t2.points[j], t2.points[(j+1)%t2.npoint] ) ){\n\t\treturn true;\n\t    }\n\t}\n    }\n    return false;\n}\n\nvoid makeGraph(){\n    for ( int i = 0; i < ncountry; i++ ){\n\tfor ( int j = 0; j < ncountry; j++ ) G[i][j] = false;\n    }\n\n    for ( int i = 0; i < nterritory; i++ ){\n\tfor ( int j = 0; j < nterritory; j++ ){\n\t    if ( T[i].cname == T[j].cname ) continue;\n\t    if ( isAdj( T[i], T[j] ) ){\n\t\tG[M[T[i].cname]][M[T[j].cname]] = true;\n\t\tG[M[T[j].cname]][M[T[i].cname]] = true;\n\t    }\n\t}\n    }\n}\n\nint color[CMAX];\nbool used[CMAX+1];\nint mincolor;\n\nvoid recursive( int pos, int ncolor ){\n    if ( pos == ncountry ){\n\tmincolor = min( mincolor, ncolor );\n\treturn;\n    }\n\n    if ( ncolor >= mincolor ) return;\n\n    bool usedt;\n\n    for ( int c = 1; c <= ncountry; c++ ){\n\tfor ( int v = 0; v < ncountry; v++ ){\n\t    if ( G[pos][v] && color[v] == c ) goto nextcolor;\n\t}\n\t\n\tusedt = used[c];\n\tused[c] = true;\n\tcolor[pos] = c;\n\trecursive( pos + 1, usedt ? ncolor : ncolor+1);\n\tused[c] = usedt;\n\n    nextcolor:;\n    } \n\n}\n\nvoid compute(){\n    makeGraph();\n\n    for ( int i = 0; i <= ncountry; i++ ) used[i] = false;\n    for ( int i = 0; i < ncountry; i++ ) color[i] = -1;\n    mincolor = ncountry;\n    recursive(0, 0);\n    cout << mincolor << endl;\n}\n\nbool input(){\n    ncountry = 0;\n    M = map<string, int>();\n    string cname;\n    int x, y;\n    cin >> nterritory;\n    if ( nterritory == 0 ) return false;\n    for ( int i = 0; i < nterritory; i++ ){\n\tcin >> cname;\n\tif ( M.find(cname) == M.end() ) M[cname] = ncountry++;\n\tT[i] = Territory(cname);\n\twhile( cin >> x, x != -1 ){\n\t    cin >> y;\n\t    T[i].addPoint(x, y);\n\t}\n    }\n    return true;\n}\n\nmain(){\n    while( input() ) compute();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\npii operator-(const pii &a,const pii &b){\n    return make_pair(a.first-b.first,a.second-b.second);\n}\n\nvoid solve(int n){\n    map<string,int> t;\n    vector<vector<int>> vs;\n    vector<vector<pii>> ps(n);\n    int size=0;\n    rep(i,0,n){\n        string str;\n        cin >> str;\n        if(t.find(str)==t.end()){\n            t[str]=size;\n            vs.push_back(vector<int>());\n            ++size;\n        }\n        vs[t[str]].push_back(i);\n        while(true){\n            int x,y;\n            cin >> x;\n            if(x==-1) break;\n            cin >> y;\n            ps[i].push_back(make_pair(x,y));\n        }\n    }\n\n    auto cross=[](pii &a,pii &b){\n        return a.first*b.second-a.second*b.first;\n    };\n\n    vector<vector<int>> graph(size);\n    rep(i,0,size) rep(j,0,i){\n        if([&](){\n            rep(k,0,vs[i].size()) rep(l,0,vs[j].size()){\n                rep(i_,0,ps[vs[i][k]].size()) rep(j_,0,ps[vs[j][l]].size()){\n                    pii &p1=ps[vs[i][k]][i_],&p2=ps[vs[i][k]][(i_+1)%ps[vs[i][k]].size()];\n                    pii &q1=ps[vs[j][l]][j_],&q2=ps[vs[j][l]][(j_+1)%ps[vs[j][l]].size()];\n                    pii a=p1-p2,b=q1-q2;\n                    pii c=p1-q1,d=p2-q2;\n                    pii e=p1-q2,f=p2-q1;\n                    if(cross(a,b) or cross(c,d) or cross(e,f)) continue;\n                    if(a.first and (max(p1.first,p2.first)<=min(q1.first,q2.first) or max(q1.first,q2.first)<=min(p1.first,p2.first))) continue;\n                    if(a.second and (max(p1.second,p2.second)<=min(q1.second,q2.second) or max(q1.second,q2.second)<=min(p1.second,p2.second))) continue;\n                    return true;\n                }\n            }\n            return false;\n        }()){\n            graph[i].push_back(j);\n            graph[j].push_back(i);\n        }\n    }\n\n    vector<int> dp(1<<size,inf);\n    dp[0]=0;\n    rep(i,0,size) dp[1<<i]=1;\n    rep(s,0,1<<size) rep(t,0,1<<size){\n        if((s&t)!=t or (s|t)!=s) continue;\n        if(![&](){\n            int d=s&~t;\n            rep(i,0,size){\n                if(!((d>>i)&1)) continue;\n                for(int j:graph[i]) if((d>>j)&1) return false;\n            }\n            return true;\n        }()) continue;\n        dp[s]=min(dp[s],dp[t]+1);\n    }\n\n    cout << dp[(1<<size)-1] << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\ninline int dot(const P &a, const P &b){return a.fs*b.fs + a.sc*b.sc;}\ninline int cross(const P &a, const P &b){return a.fs*b.sc - a.sc*b.fs;}\ninline int norm(const P &a){return a.fs*a.fs + a.sc*a.sc;}\n\ninline int ccw(const P &a,P b,P c){\n  b.fs -= a.fs; b.sc -= a.sc;\n  c.fs -= a.fs; c.sc -= a.sc;\n  if (cross(b,c)>0) return 2;   //counter clockwise\n  if (cross(b,c)<0) return -2; //clockwise\n  if (dot(b, c)<0) return 1;   //c--a--b on line\n  if (norm(b)<norm(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  if(num>0){\n    vi use(num,0);\n    rep(i,d){\n      if(g[d][i])use[cols[i]] = 1;\n    }\n\n    rep(i,num){\n      if(!use[i]){\n\tcols[d] = i;\n\tdfs(d+1,num);\n      }\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for (int i=0; i < (n); i++)\n#define fi first\n#define se second\ntypedef double D; \ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  if(a1==b1&&!isecSP(a1,a2,b2)||a1==b2&&!isecSP(a1,a2,b1)||a2==b1&&!isecSP(a1,a2,b2)||a2==b2&&!isecSP(a1,a2,b1))return 0;\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nstring s[11];\ndouble x,y;\nvector<int>a[11];\nint color[11],ans,n,used[11],yy;\nvoid dfs(int p,int d){//cout<<p<<d<<endl;\n  if(p==n){\n    ans=min(ans,d);\n    return;\n  }\n  int y[12]={},pp=0,pe;\n  r(j,a[p].size())y[a[p][j]]=1;\n  r(i,p)if(s[i]==s[p]){pp++;pe=i;\n    r(j,11)if(s[j]!=s[p]&&y[j]&&color[i]==color[j])return ;\n  }\n  if(pp){\n    color[p]=color[pe];\n    dfs(p+1,d);\n    color[p]=11;\n  }\n  for(int i=0;i<d+2;i++){\n    int f=0;\n    r(j,12)if(y[j]&&i==j)f++;\n    if(!f){\n      color[p]=i;\n      if(i==d+1)dfs(p+1,d+1);\n      else dfs(p+1,d);\n      color[p]=11;\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    ans=1e9;yy=n;\n    r(i,11)color[i]=11;\n    r(i,11)a[i].clear();\n    VP v[n];\n    for(int i=0;i<yy;i++){\n      cin>>s[i];\n        while(cin>>x,x!=-1){\n          cin>>y;\n          v[i].push_back(P(x,y));\n        }\n    }\n    r(i,n)r(j,v[i].size())\n      r(k,n)if(i!=k)r(l,v[k].size())\n        if(isecSS(v[i][j],v[i][(j+1)%(int)v[i].size()],v[k][l],v[k][(l+1)%(int)v[k].size()]))\n          a[i].push_back(k);\n    r(i,n)sort(a[i].begin(),a[i].end());\n    r(i,n)a[i].erase(unique(a[i].begin(),a[i].end()),a[i].end());\n    //r(i,n)cout<<a[i].size()<<endl;\n    color[0]=0;\n    dfs(1,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int mod = 1e9 + 7;\n\ntemplate< typename T = long long >\nT pow_mod(T x, T n, T mod)\n{\n  T ret = 1;\n  while(n > 0) {\n    if(n & 1) ret = 1LL * ret * x % mod;\n    x = 1LL * x * x % mod;\n    n >>= 1;\n  }\n  return ret;\n}\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > 0) return +1;\n    if(cross(b, c) < 0) return -1;\n    if(dot(b, c) <= 0) return +2;\n    if(b.norm() <= c.norm()) return -2;\n    return 0;\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  { //OK\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  { //OK\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  { //OK\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  { //OK\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n};\n\nusing namespace Geometory;\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    map< string, vector< Polygon > > data;\n    vector< string > nums;\n    for(int i = 0; i < N; i++) {\n      string S;\n      cin >> S;\n      int x, y;\n      Polygon polygon;\n      while(cin >> x, ~x) {\n        cin >> y;\n        polygon.push_back(Point(x, y));\n      }\n\n      nums.push_back(S);\n      data[S].push_back(polygon);\n    }\n\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n\n    int sz = (int) nums.size(), g[10][10] = {{}};\n    for(auto &ps : data) {\n      for(auto &qs : data) {\n        if(ps.first == qs.first) continue;\n        int u = lower_bound(begin(nums), end(nums), ps.first) - begin(nums);\n        int v = lower_bound(begin(nums), end(nums), qs.first) - begin(nums);\n        bool crossed = false;\n        for(auto &p : ps.second) {\n          for(auto &q : qs.second) {\n            for(int i = 0; i < p.size(); i++) {\n              for(int j = 0; j < q.size(); j++) {\n                if(Intersect(Segment(curr(p, i), next(p, i)), Segment(curr(q, j), next(q, j)))) {\n                  crossed = true;\n                }\n              }\n            }\n          }\n        }\n        g[u][v] = crossed;\n      }\n    }\n\n\n    vector< int > beet;\n    for(int i = 0; i < 1 << sz; i++) {\n      bool flag = true;\n      for(int j = 0; j < sz; j++) {\n        for(int k = 0; k < j; k++) {\n          if((i >> j) & 1 && (i >> k) & 1 && g[j][k]) flag = false;\n        }\n      }\n      if(flag) beet.push_back(i);\n    }\n\n    vector< int > dp(1 << sz, sz);\n    dp[0] = 0;\n    for(int i = 0; i < 1 << sz; i++) {\n      for(auto &j : beet) dp[i | j] = min(dp[i | j], dp[i] + 1);\n    }\n    cout << dp.back() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\nint n;\nstring str[100];\nvector<pair<int, int>> xy[100];\n//-----------------------------------------------------------------\nbool isAdjacent(int a, int b) {\n\trep(i, 0, xy[a].size()) rep(j, 0, xy[b].size()) {\n\t\tint ii = (i + 1) % xy[a].size();\n\t\tint jj = (j + 1) % xy[b].size();\n\n\t\tint x_a = xy[a][i].first - xy[a][ii].first;\n\t\tint y_a = xy[a][i].second - xy[a][ii].second;\n\t\tint x_b = xy[b][j].first - xy[b][jj].first;\n\t\tint y_b = xy[b][j].second - xy[b][jj].second;\n\n\t\tif (x_a*y_b == x_b*y_a) {\n\t\t\tif (max(xy[a][i].first, xy[a][ii].first) <= min(xy[b][j].first, xy[b][jj].first)) continue;\n\t\t\tif (max(xy[b][j].first, xy[b][jj].first) <= min(xy[a][i].first, xy[a][ii].first)) continue;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n//-----------------------------------------------------------------\nint E[100][100];\nint C[100];\nint solve() {\n\trep(i, 0, n) rep(j, 0, n) E[i][j] = 0;\n\trep(i, 0, n) C[i] = 0;\n\n\trep(i, 0, n) rep(j, i + 1, n) if (isAdjacent(i, j)) E[i][j] = E[j][i] = 1;\n\n\trep(i, 0, n) if(!C[i]){\n\t\tC[i] = 1;\n\n\t\tqueue<int> que;\n\t\trep(j, 0, n) if (!C[j] && E[i][j]) que.push(j);\n\t\twhile (!que.empty()) {\n\t\t\tint j = que.front(); que.pop();\n\t\t\tif (C[j]) continue;\n\n\t\t\tset<int> s;\n\t\t\trep(k, 0, n) if (E[j][k] && C[k]) s.insert(C[k]);\n\t\t\tif (*s.begin() != 1) {\n\t\t\t\tC[j] = 1;\n\t\t\t} else {\n\t\t\t\tint bak = 1;\n\t\t\t\tfor (int k : s) {\n\t\t\t\t\tif (bak == k) {\n\t\t\t\t\t\tbak++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tC[j] = bak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k, 0, n) if (E[j][k] && !C[k]) que.push(k);\n\t\t}\n\t}\n\n\tint ans = -1;\n\trep(i, 0, n) ans = max(ans, C[i]);\n\t/*rep(i, 0, n) cout << C[i] << \" \";\n\tcout << endl;*/\n\treturn ans;\n}\n//-----------------------------------------------------------------\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) return 0;\n\n\t\trep(i, 0, n) {\n\t\t\tcin >> str[i];\n\n\t\t\txy[i].clear();\n\t\t\tint x, y;\n\t\t\twhile (cin >> x) {\n\t\t\t\tif (x < 0) break;\n\t\t\t\tcin >> y;\n\t\t\t\txy[i].push_back({ x, y });\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Point{\n  int x,y;\n  Point operator + (const Point p)const{\n    return (Point){x+p.x,y+p.y};\n  }\n  Point operator - (const Point p)const{\n    return (Point){x-p.x,y-p.y};\n  }\n};\n\nstruct Segment{\n  Point p,v;\n};\n\nint dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n\nint cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n\nbool isParallel(Point a,Point b){\n  return (0==cross(a,b));\n}\n\nint abs(int a){return max(a,-a);}\nbool eq(Point a,Point b){\n  return (a.x==b.x&&a.y==b.y);\n}\n\nbool eq(Segment a,Segment b){\n  if(eq(a.v,b.v)&&eq(a.p,b.p))return true;\n  if(eq(a.p,b.p+b.v)&&eq(a.p+a.v,b.p))return true;\n  return false;\n}\nbool onSegment(Segment s,Point p){\n  Point q=p-s.p;\n  if(!isParallel(s.v,q))return false;\n  if(dot(s.v,q)<=0)return false;\n  if(abs(q.x)>=abs(s.v.x))return false;\n  if(abs(q.y)>=abs(s.v.y))return false;\n  if(eq(s.p,p)||eq(s.p+s.v,p))return false;\n  return true;  \n}\n\n\n\nint n;\nint c;\nmap<string,int> mp;\nvector<Segment> G[10];\nint g[10][10];\n\nbool calc(int a,int b){\n  for(int i=0;i<(int)G[a].size();i++){\n    Segment si=G[a][i];\n    for(int j=0;j<(int)G[b].size();j++){\n      Segment sj=G[b][j];\n      if(!isParallel(si.v,sj.v))continue;\n      if(eq(si,sj))return true;\n\n      if(onSegment(si,sj.p))return true;\n      if(onSegment(si,sj.p+sj.v))return true;\n      if(onSegment(sj,si.p))return true;\n      if(onSegment(sj,si.p+si.v))return true;\n    }\n  }\n}\n\nvoid init(){\n  c=0;\n  mp.clear();\n  \n  for(int i=0;i<10;i++){\n    G[i].clear();\n    for(int j=0;j<10;j++)\n      g[i][j]=0;\n  }\n}\n\nint main(){\n  int id;\n  int px,py;\n  string str;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      cin>>str;\n      if(mp.count(str)==0)mp[str]=id=c++;\n      else id=mp[str];\n      vector<Point> t;\n      while(1){\n        cin>>px;\n        if(px==-1)break;\n        cin>>py;\n        t.push_back((Point){px,py});\n      }\n      int size=t.size();\n      for(int i=0;i<size;i++)\n        G[id].push_back((Segment){t[i],t[(i+1)%size]-t[i]});\n    }\n    \n    for(int i=0;i+1<c;i++){\n      for(int j=i+1;j<c;j++){\n        bool flg=calc(i,j);\n        if(flg)g[i][j]=g[j][i]=1;\n      }\n    }\n\n    vector<int> e;\n    for(int i=0;i<(1<<c);i++){\n      bool flg=true;\n      for(int j=0;j<c;j++){\n        if(i>>j&1){}else continue;\n        for(int k=0;k<c;k++){\n          if(i>>k&1){}else continue;\n          if(g[j][k])flg=false;\n        }\n      }\n      if(flg)e.push_back(i);\n    }\n    \n    int dp[1024];\n    fill(dp,dp+1024,1e8);\n    dp[0]=0;\n    for(int S=0;S<(1<<c);S++){\n      if(dp[S]==1e8)continue;\n      for(int i=0;i<(int)e.size();i++){\n        int T=e[i];\n        dp[S|T]=min(dp[S|T],dp[S]+1);\n      }\n    }\n    cout<<dp[(1<<c)-1]<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <map>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n#define X real()\n#define Y imag()\nconst double EPS = (1e-7);\nconst int INF = 1 << 20;\ndouble dot(P &a, P &b){ return a.X*b.X + a.Y*b.Y;}\ndouble cross(P &a, P &b){ return a.X*b.Y - a.Y*b.X;}\n\nint ccw( P a, P b, P c){\n  b -= a, c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(c) > norm(b) - EPS) return -2;\n  return 0;\n}\n\nbool is_adjacent(vector<P> &A, vector<P> &B){\n  int n = A.size(), m = B.size();\n  for(int i = 0; i < n; ++i){\n    for(int j = 0; j < m; ++j){\n      P x = A[i], y = A[(i+1)%n], z = B[j], w = B[(j+1)%m];\n      int s = ccw(x,y,z), t = ccw(x,y,w);\n      if(abs(s) == 1 or abs(t) == 1) continue;\n      if(s*t > 0) continue;\n      return true;\n    }\n  }\n  return false;\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    map<string, int> M;\n    vector< vector< vector<P> > > V(n);\n    int t = 1;\n    for(int i = 0; i < n; ++i){\n      string s;\n      cin >> s;\n      vector<P> Poly;\n      if(!M[s]){\n        M[s] = t;\n        ++t;\n      }\n      double x;\n      while(cin >> x, x != -1){\n        double y;\n        cin >> y;\n        Poly.emplace_back(x,y);\n      }\n      V[M[s]-1].emplace_back(Poly);\n    }\n    int c = t-1;\n    vector< vector<int> > G(c, vector<int>(c,0));\n    for(int i = 0; i < c; ++i){\n      for(int j = 0; j < i; ++j){\n        for(int k = 0; k < V[i].size(); ++k){\n          for(int l = 0; l < V[j].size(); ++l){\n            if(is_adjacent(V[i][k], V[j][l])) ++G[i][j], ++G[j][i];\n          }\n        }\n      }\n    }\n\n    /*\n    for(int i=0; i<c; i++) {\n      for(int j=0; j<c; j++) {\n        fprintf(stderr, \"%d \", G[i][j]);\n      }\n      fprintf(stderr, \"\\n\");\n    }\n    */\n\n    vector<int> dp(1 << c, INF);\n    dp[0] = 0;\n    for(int bit=0; bit<(1<<c); bit++) {\n      for(int mask=0; mask<(1<<c); mask++) {\n        if((bit & mask) != 0) continue;\n        bool ok = true;\n        for(int i=0; i<c; i++) {\n          for(int j=0; j<c; j++) {\n            if(!(mask >> i & 1)) continue;\n            if(!(mask >> j & 1)) continue;\n            if(G[i][j]) ok = false;\n          }\n        }\n\n        int nbit = bit | mask;\n        if(ok) dp[nbit] = min(dp[nbit], dp[bit] + 1);\n      }\n    }\n    cout << dp[(1<<c) - 1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-9;\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef vector<Polygon> Country;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\ndouble dot(P a,P b){\n  return (conj(a)*b).real();\n}\n\nbool d[100][100];\nint color[10];\nint nv;\n\nint dfs(int x,int n){\n  if(x==nv){\n    return n;\n  }else{\n    int m=99;\n    for(int i=0;i<n+1;i++){\n      bool f=false;\n      for(int j=0;j<x;j++){\n\tf|=d[x][j]&&i==color[j];\n      }\n      if(!f){\n\tcolor[x]=i;\n\tm=min(m,dfs(x+1,max(n,i+1)));\n      }\n    }\n    return m;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    map<string,Country> m;\n    while(n--){\n      string s;\n      cin>>s;\n      Polygon p;\n      for(int x,y;cin>>x,x>=0;){\n\tcin>>y;\n\tp.push_back(P(x,y));\n      }\n      m[s].push_back(p);\n    }\n    vector<Country> c;\n    for(auto e:m){\n      c.push_back(e.second);\n    }\n    nv=c.size();\n    fill(d[0],d[10],false);\n    for(int i=0;i<c.size();i++){\n      for(auto e:c[i]){\n\tfor(int j=0;j<e.size();j++){\n\t  for(int k=0;k<i;k++){\n\t    for(auto f:c[k]){\n\t      for(int l=0;l<f.size();l++){\n\t\tP a=e[j],b=e[(j+1)%e.size()];\n\t\tP x=f[l],y=f[(l+1)%f.size()];\n\t\tif(fabs(cross(a-b,x-b))<eps&&fabs(cross(a-b,y-b))<eps){\n\t\t  double pa,pb,pc,pd;\n\t\t  if(fabs(a.real()-b.real())<eps){\n\t\t    pa=min(a.imag(),b.imag());\n\t\t    pb=max(a.imag(),b.imag());\n\t\t    pc=min(x.imag(),y.imag());\n\t\t    pd=max(x.imag(),y.imag());\n\t\t  }else{\n\t\t    pa=min(a.real(),b.real());\n\t\t    pb=max(a.real(),b.real());\n\t\t    pc=min(x.real(),y.real());\n\t\t    pd=max(x.real(),y.real());\n\t\t  }\n\t\t  if(max(pa,pc)<min(pb,pd)-eps){\n\t\t    d[i][k]=d[k][i]=true;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nchar in[50];\nvector<pair<Pt,Pt> > p[12];\ndouble x[120];\ndouble y[120];\nint g[20][20];\nint col[20];\nint n;\nint solve(int a,int b){\n\tif(a==n)return 1;\n\tfor(int i=1;i<=b;i++){\n\t\tbool ok=true;\n\t\tfor(int j=0;j<a;j++)if(g[a][j]&&col[j]==i)ok=false;\n\t\tif(ok){\n\t\t\tcol[a]=i;\n\t\t\tint res=solve(a+1,b);\n\t\t\tif(res)return 1;\n\t\t}\n\t}\n\treturn 0;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tmap<string,int>m;\n\t\tn=0;\n\t\tfor(int i=0;i<12;i++)p[i].clear();\n\t\tfor(int i=0;i<20;i++)for(int j=0;j<20;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstring tmp=in;\n\t\t\tint at;\n\t\t\tif(m.count(tmp))at=m[tmp];\n\t\t\telse {\n\t\t\t\tat=n;\n\t\t\t\tm[tmp]=n++;\n\t\t\t}\n\t\t\tint s=0;\n\t\t\twhile(1){\n\t\t\t\tscanf(\"%lf\",x+s);\n\t\t\t\tif(x[s]<-0.5)break;\n\t\t\t\tscanf(\"%lf\",y+s);\n\t\t\t\ts++;\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tdouble X=x[i]*cos(1)-y[i]*sin(1);\n\t\t\t\tdouble Y=x[i]*sin(1)+y[i]*cos(1);\n\t\t\t\tx[i]=X;y[i]=Y;\n\t\t\t}\n\t\t\tfor(int i=0;i<s;i++){\n\t\t\t\tp[at].push_back(make_pair(Pt(x[i],y[i]),Pt(x[(i+1)%s],y[(i+1)%s])));\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=i+1;j<a;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(int k=0;k<p[i].size();k++){\n\t\t\t\t\tif(ok)break;\n\t\t\t\t\tfor(int l=0;l<p[j].size();l++){\n\t\t\t\t\t\tif(ok)break;\n\t\t\t\t\t\tif(iLL(p[i][k].first,p[i][k].second,p[j][l].first,p[j][l].second)==-1){\n\t\t\t\t\t\t\tif(max(p[i][k].first.x,p[i][k].second.x)<EPS+min(p[j][l].first.x,p[j][l].second.x))continue;\n\t\t\t\t\t\t\tif(min(p[i][k].first.x,p[i][k].second.x)+EPS>max(p[j][l].first.x,p[j][l].second.x))continue;\n\t\t\t\t\t\t\tok=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ok)g[i][j]=g[j][i]=1;\n\t\t\t}\n\t\t}\n\t\tint ans=n;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=0;j<20;j++)col[j]=0;\n\t\t\tif(solve(0,i)){\n\t\t\t\tans=i;break;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <complex>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\nconst int N = 10;\nconst double EPS = 1.0e-10;\n\nbool is_Online(Point a, Point b, Point c){\n  return abs(a-c)+abs(b-c)<abs(a-b)+EPS;\n}\n\nbool is_touch(Polygon &a, Polygon &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      bool c[4];\n      Point p1=a[i], p2=a[(i+1)%a.size()], p3=b[j], p4=b[(j+1)%b.size()];\n      c[2]=is_Online(p1, p2, p3);\n      c[3]=is_Online(p1, p2, p4);\n      c[0]=is_Online(p3, p4, p1);\n      c[1]=is_Online(p3, p4, p2);\n      if((c[0] && c[1]) || (c[2] && c[3])) return true;\n    }\n  }\n  return false;\n}\n\nbool is_Touch(vector<Polygon> &a, vector<Polygon> &b){\n  for(int i=0;i<a.size();i++){\n    for(int j=0;j<b.size();j++){\n      if(is_touch(a[i], b[j])) return true;\n    }\n  }\n  return false;\n}\n\nint ans;\nvoid dfs(int now, int n, int cnt, vector<int> *G, int *color, bool *used){\n  if(cnt>ans) return;\n  if(now==n){\n    ans=min(ans, cnt);\n    return;\n  }\n  for(int i=0;i<=now;i++){\n    bool f=true;\n    for(int j=0;j<G[now].size();j++){\n      if(color[G[now][j]]==i){\n\tf=false;\n\tbreak;\n      }\n    }\n    if(f){\n      bool tmp=used[i];\n      color[now]=i;\n      if(used[i]){\n\tdfs(now+1, n, cnt, G, color, used);\n      }else{\n\tused[i]=true;\n\tdfs(now+1, n, cnt+1, G, color, used);\n\tused[i]=false;\n      }\n      color[now]=-1;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    vector<Polygon> country[N];\n    int color[N];\n    map<string, int> ntoi;\n    bool used[N];\n    vector<int> G[N];\n    fill(used, used+N, false);\n    int index=0;\n    for(int i=0;i<n;i++){\n      string name;\n      getline(cin, name);\n      getline(cin, name);\n      if(ntoi.find(name)==ntoi.end()){\n\tntoi[name]=index++;\n      }\n      Polygon in;\n      while(1){\n\tPoint t;\n\tcin >> t.real();\n\tif(t.real()==-1) break;\n\tcin >> t.imag();\n\tin.push_back(t);\n      }\n      country[ntoi[name]].push_back(in);\n    }\n    for(int i=0;i<ntoi.size();i++){\n      for(int j=i+1;j<ntoi.size();j++){\n\tif(is_Touch(country[i], country[j])) G[i].push_back(j), G[j].push_back(i);\n      }\n    }\n    fill(color, color+N, -1);\n    ans=10;\n    dfs(0, ntoi.size(), 0, G, color, used);\n    cout << ans << endl;\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EQ(x, y) (abs((x) - (y)) < EPS)\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    double EPS = 1e-6;\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n        bool operator==(const Point& p) const { return EQ(x, p.x) && EQ(y, p.y); }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    double angle(const Point& a) { return atan2(a.y, a.x); } // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    struct Segment {\n        Point a, b;\n        Segment() {}\n        Segment(const Point& a, const Point& b) : a(a), b(b) {}\n        bool operator==(const Segment& s) const {\n            return (a == s.a && b == s.b) || (b == s.a && a == s.b);\n        }\n    };\n    ostream& operator<<(ostream& os, const Segment& s) {\n        return os << \"(\" << s.a << \",\" << s.b << \")\";\n    }\n\n    typedef vector<Point> Polygon;\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    int N;\n    int n;\n    map<string, int> id;\n    vector<string> names;\n    vector<Polygon> P;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        id.clear();\n        names.clear();\n        P.clear(); P.resize(N);\n        n = 0;\n        for (int i = 0; i < N; i++) {\n            string s; cin >> s;\n            names.push_back(s);\n            if (id.count(s) == 0) {\n                id[s] = n++;\n            }\n            while (true) {\n                int x; cin >> x;\n                if (x < 0) break;\n                int y; cin >> y;\n                P[i].push_back(Point(x, y));\n            }\n        }\n        return true;\n    }\n\n    bool parallel(const Segment& s, const Segment& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n\n    bool contains(const Segment& s, const Point& p) {\n        if (s.a == p) return false;\n        if (s.b == p) return false;\n        return ccw(s.a, s.b, p) == 0;\n    }\n\n    bool touch(const Polygon& a, const Polygon& b) {\n        int na = int(a.size());\n        int nb = int(b.size());\n        for (int i = 0; i < na; i++) {\n            Segment s(a[i], a[(i + 1) % na]);\n            for (int j = 0; j < nb; j++) {\n                Segment t(b[j], b[(j + 1) % nb]);\n                if (s == t) return true;\n                if (!parallel(s, t)) continue;\n                if ((contains(s, t.a) || contains(s, t.b)) || \n                            (contains(t, s.a) || contains(t, s.b))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    vector< vector<bool> > G;\n\n    bool check(vector<int>& cs) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (G[i][j] && cs[i] == cs[j]) return false;\n            }\n        }\n        return true;\n    }\n\n    int count(vector<int>& cs) {\n        vector<bool> used(n, false);\n        int ret = 0;\n        for (int i = 0; i < n; i++) {\n            if (cs[i] < 0) continue;\n            if (used[cs[i]]) continue;\n            used[ cs[i] ] = true;\n            ret++;\n        }\n        return ret;\n    }\n\n    int dfs(int v, vector<int>& cs) {\n        if (v == n) return (check(cs) ? count(cs) : 11);\n        int ret = 11;\n        for (int i = 0; i <= v; i++) {\n            int c = 0;\n            for (int j = 0; j < n; j++) {\n                if (G[v][j] && cs[j] == i) goto next;\n            }\n            cs[v] = i;\n            ret = min(ret, dfs(v + 1, cs));\n            cs[v] = -1;\nnext:;\n        }\n        return ret;\n    }\n\n    void solve() {\n        G.clear(); G.resize(n, vector<bool>(n, false));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int x = id[ names[i] ];\n                int y = id[ names[j] ];\n                if (x == y) continue;\n                if (touch(P[i], P[j])) {\n                    G[x][y] = G[y][x] = true;\n                }\n            }\n        }\n        vector<int> cs(n, -1);\n        cs[0] = 0;\n        cout << dfs(1, cs) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EQ(x, y) (abs((x) - (y)) < EPS)\n\nnamespace {\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    double EPS = 1e-6;\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n        bool operator==(const Point& p) const { return EQ(x, p.x) && EQ(y, p.y); }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    double angle(const Point& a) { return atan2(a.y, a.x); } // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    struct Segment {\n        Point a, b;\n        Segment() {}\n        Segment(const Point& a, const Point& b) : a(a), b(b) {}\n        bool operator==(const Segment& s) const {\n            return (a == s.a && b == s.b) || (b == s.a && a == s.b);\n        }\n    };\n    ostream& operator<<(ostream& os, const Segment& s) {\n        return os << \"(\" << s.a << \",\" << s.b << \")\";\n    }\n\n    typedef vector<Point> Polygon;\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    int N;\n    int n;\n    map<string, int> id;\n    vector<string> names;\n    vector<Polygon> P;\n    bool input() {\n        cin >> N;\n        if (N == 0) return false;\n        id.clear();\n        names.clear();\n        P.clear(); P.resize(N);\n        n = 0;\n        for (int i = 0; i < N; i++) {\n            string s; cin >> s;\n            names.push_back(s);\n            if (id.count(s) == 0) {\n                id[s] = n++;\n            }\n            while (true) {\n                int x; cin >> x;\n                if (x < 0) break;\n                int y; cin >> y;\n                P[i].push_back(Point(x, y));\n            }\n        }\n        return true;\n    }\n\n    bool parallel(const Segment& s, const Segment& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n\n    bool contains(const Segment& s, const Point& p) {\n        if (s.a == p) return false;\n        if (s.b == p) return false;\n        return ccw(s.a, s.b, p) == 0;\n    }\n\n    bool touch(const Polygon& a, const Polygon& b) {\n        int na = int(a.size());\n        int nb = int(b.size());\n        for (int i = 0; i < na; i++) {\n            Segment s(a[i], a[(i + 1) % na]);\n            for (int j = 0; j < nb; j++) {\n                Segment t(b[j], b[(j + 1) % nb]);\n                if (s == t) return true;\n                if (!parallel(s, t)) continue;\n                if ((contains(s, t.a) || contains(s, t.b)) || \n                            (contains(t, s.a) || contains(t, s.b))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    vector< vector<bool> > G;\n    void dfs(int v, vector<int>& banned, int& used, int& visited) {\n        if (visited & (1 << v)) return;\n        visited |= (1 << v);\n        int color = -1;\n        for (int i = 0; i < n; i++) {\n            if (banned[v] & (1 << i)) continue;\n            color = i;\n            break;\n        }\n        assert(color >= 0);\n        used |= (1 << color);\n        for (int i = 0; i < n; i++) {\n            if (G[v][i]) banned[i] |= (1 << color);\n        }\n        for (int i = 0; i < n; i++) {\n            dfs(i, banned, used, visited);\n        }\n    }\n    void solve() {\n        G.clear(); G.resize(n, vector<bool>(n, false));\n        for (int i = 0; i < N; i++) {\n            for (int j = i + 1; j < N; j++) {\n                int x = id[ names[i] ];\n                int y = id[ names[j] ];\n                if (x == y) continue;\n                if (touch(P[i], P[j])) {\n                    G[x][y] = G[y][x] = true;\n                }\n            }\n        }\n        int used = 0;\n        int visited = 0;\n        vector<int> banned(n, 0);\n        dfs(0, banned, used, visited);\n        cout << __builtin_popcount(used) << endl;\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x_ = 0.0, double y_ = 0.0):x(x_), y(y_) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ndouble dot(const point& a, const point& b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const point& a, const point& b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\ndouble norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\nint ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\nstruct segment {\n\tpoint a, b;\n\tsegment(point a_, point b_):a(a_), b(b_) {}\n};\n\ntypedef vector<point> polygon;\n\nbool intersect(const segment &s, const segment &t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n\t\t&& ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool intersect(const polygon &P, const polygon &Q) {\n\tpoint p1 = P.back();\n\tfor(const auto &p2 : P) {\n\t\tconst segment s1(p1 + (p2 - p1) * EPS, p2 + (p1 - p2) * EPS);\n\n\t\tpoint q1 = Q.back();\n\t\tfor(const auto &q2 : Q) {\n\t\t\tconst segment s2(q1 + (q2 - q1) * EPS, q2 + (q1 - q2) * EPS);\n\t\t\tif(intersect(s1, s2)) return true;\n\t\t\tq1 = q2;\n\t\t}\n\t\tp1 = p2;\n\t}\n\treturn false;\n}\n\nbool check(int num, const vector<vector<int>> &G) {\n\tvector<int> colors(G.size(), -1);\n\n\tfunction<bool(int)> dfs = [&](int v) {\n\t\tif(v == G.size()) return true;\n\t\tif(G[v].empty()) return dfs(v + 1);\n\n\t\tvector<bool> can(num, true);\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(colors[to] != -1) can[colors[to]] = false;\n\t\t}\n\n\t\tfor(int c = 0; c < num; ++c) {\n\t\t\tif(!can[c]) continue;\n\t\t\tcolors[v] = c;\n\t\t\tif(dfs(v + 1)) return true;\n\t\t}\n\t\tcolors[v] = -1;\n\t\treturn false;\n\t};\n\n\treturn dfs(0);\n}\n\nint calc(const vector<vector<int>> &G) {\n\tfor(int num = 1;; ++num) {\n\t\tif(check(num, G)) return num;\n\t}\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tunordered_map<string, int> converter;\n\t\tvector<int> idx(n);\n\t\tvector<polygon> territories;\n\t\tterritories.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring name;\n\t\t\tcin >> name;\n\t\t\tif(!converter.count(name)) converter.insert({name, converter.size()});\n\t\t\tidx[i] = converter[name];\n\t\t\tpolygon P;\n\t\t\tfor(int x, y; cin >> x && x != -1;) {\n\t\t\t\tcin >> y;\n\t\t\t\tP.emplace_back(x, y);\n\t\t\t}\n\t\t\tterritories.emplace_back(P);\n\t\t}\n\n\t\tconst int V = converter.size();\n\t\tvector<vector<int>> G(V);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = i + 1; j < n; ++j) {\n\t\t\t\tif(idx[i] == idx[j]) continue;\n\t\t\t\tif(intersect(territories[i], territories[j])) {\n\t\t\t\t\tG[idx[i]].emplace_back(idx[j]);\n\t\t\t\t\tG[idx[j]].emplace_back(idx[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(auto &vec : G) {\n\t\t\tsort(vec.begin(), vec.end());\n\t\t\tvec.erase(unique(vec.begin(), vec.end()), vec.end());\n\t\t}\n\n\t\tcout << calc(G) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nstruct Polygon{\n    int id;\n    int V;\n    vector<pi> v;\n};\n\nmap<string,int> name2id;\nint C;\nPolygon read_p(){\n    Polygon ret;\n\n    string name;\n    cin >>name;\n\n    if(!name2id.count(name)) name2id[name] = C++;\n    ret.id = name2id[name];\n\n    int x,y;\n    while(1){\n        cin >>x;\n        if(x==-1) break;\n\n        cin >>y;\n        ret.v.pb({x,y});\n    }\n    ret.V = ret.v.size();\n    return ret;\n}\n\nbool share_edge(pi p1, pi p2, pi q1, pi q2){\n    if(p1>p2) swap(p1,p2);\n    if(q1>q2) swap(q1,q2);\n\n    int px = p2.fi-p1.fi, py = p2.se-p1.se;\n    int pg = __gcd(abs(px), abs(py));\n    px /= pg;\n    py /= pg;\n\n    int qx = q2.fi-q1.fi, qy = q2.se-q1.se;\n    int qg = __gcd(abs(qx), abs(qy));\n    qx /= qg;\n    qy /= qg;\n\n    if(px!=qx || py!=qy) return false;\n\n    if(px == 0){\n        if(p1.fi != q1.fi) return false;\n        return (p1<=q1 && q1<p2) || (q1<=p1 && p1<q2) ;\n    }\n    else{\n        pi tp(p1);\n        int D = p1.fi/px;\n        tp.fi -= px*D;\n        tp.se -= py*D;\n\n        pi tq(q1);\n        D = q1.fi/qx;\n        tq.fi -= qx*D;\n        tq.se -= qy*D;\n        if(tp != tq) return false;\n\n        // cout << p1 << \" \" << p2 << \" \" <<q1 <<\" \" <<q2<<endl;\n        return (p1<=q1 && q1<p2) || (q1<=p1 && p1<q2) ;\n    }\n}\n\nbool check(const Polygon &p, const Polygon &q){\n    rep(i,p.V)rep(j,q.V){\n        if(share_edge(p.v[i], p.v[(i+1)%p.V], q.v[j], q.v[(j+1)%q.V])) return true;\n    }\n    return false;\n}\n\nvector<vector<bool>> adj;\nint ans;\nint col[10];\nvoid dfs(int d, int new_color){\n    if(d==C){\n        ans = min(ans,new_color);\n        return;\n    }\n\n    rep(i,new_color){\n        col[d] = i;\n\n        bool ok = true;\n        rep(j,d){\n            if(adj[d][j] && col[j]==col[d]) ok = false;\n        }\n        if(ok) dfs(d+1,new_color);\n\n        col[d] = -1;\n    }\n\n    col[d] = new_color;\n    dfs(d+1,new_color+1);\n    col[d] = -1;\n}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        name2id.clear();\n        C = 0;\n\n        vector<Polygon> p(n);\n        rep(i,n) p[i] = read_p();\n\n        adj = vector<vector<bool>>(C,vector<bool>(C));\n        rep(i,n)rep(j,i){\n            if(check(p[i],p[j])){\n                adj[p[i].id][p[j].id] = true;\n                adj[p[j].id][p[i].id] = true;\n            }\n        }\n\n        ans = C;\n        rep(i,C) col[i] = -1;\n        dfs(0,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<int> vi;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\nconst int MAXV = 50;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 2;   //counter clockwise\n  if (cross(b,c)<-EPS) return -2; //clockwise\n  if (dot(b, c)<-EPS) return 1;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -1;   //a--b--c on line\n  return 0;                       //on segment\n}\n\nvector<vi> g;\nvi cols;\nint n,m,ans;\n\nvoid dfs(int d, int num){\n  if(num>=ans)return;\n  if(d==m){ ans = num; return; }\n\n  rep(i,num){\n    bool f = true;\n    rep(j,d){\n      if(g[d][j] && cols[j]==i){\n\tf = false; break;\n      }\n    }\n    if(f){\n      cols[d] = i;\n      dfs(d+1,num);\n    }\n  }\n\n  cols[d] = num;\n  dfs(d,num+1);\n}\n\nint main(){\n  while(cin >> n){\n    if(n==0)break;\n\n    map<string,int> country;\n    vi id(n);\n    vector< vector<L> > poly(n);\n\n    m = 0;\n    rep(i,n){\n      string name;\n      cin >> name;\n\n      if(country.find(name)==country.end()){\n\tcountry[name] = m++;\n      }\n      id[i] = country[name];\n      \n      int x,y;\n      vector<P> points;\n\n      for(;;){\n\tcin >> x;\n\tif(x<0)break;\n\tcin >> y;\n\tpoints.pb( P(x,y) );\n      }\n\n      rep(j,points.sz){\n\tpoly[i].pb(L(points[j],points[(j+1)%points.sz]));\n\tif(poly[i][j].sc < poly[i][j].fs)swap(poly[i][j].fs, poly[i][j].sc);\n      }\n    }\n\n    g = vector<vi>(m,vi(m,0));\n\n    rep(i,n)rep(j,i){\n\tbool f = false;\n\tfor(L a : poly[i]){\n\t  for(L b: poly[j]){\n\t    if(abs(ccw(a.fs,a.sc,b.fs))<=1 && abs(ccw(a.fs,a.sc,b.sc))<=1){\n\t      if( (b.fs < a.sc && a.fs < b.sc) || (a.fs < b.sc && b.fs < a.sc) ){\n\t\tf = true; break;\n\t      }\n\t    }\n\t  }\n\t  if(f)break;\n\t}\n\tif(f)g[id[i]][id[j]] = g[id[j]][id[i]] = 1;\n    }\n\n    ans = 10; cols.resize(m);\n    dfs(0,0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\nint n;\nstring str[100];\nvector<pair<int, int>> xy[100];\n//-----------------------------------------------------------------\nbool isAdjacent(int a, int b) {\n\trep(i, 0, xy[a].size()) rep(j, 0, xy[b].size()) {\n\t\tint ii = (i + 1) % xy[a].size();\n\t\tint jj = (j + 1) % xy[b].size();\n\n\t\tint x_a = xy[a][i].first - xy[a][ii].first;\n\t\tint y_a = xy[a][i].second - xy[a][ii].second;\n\t\tint x_b = xy[b][j].first - xy[b][jj].first;\n\t\tint y_b = xy[b][j].second - xy[b][jj].second;\n\n\t\tif (x_a == 0 && x_b == 0) {\n\t\t\tif (max(xy[a][i].second, xy[a][ii].second) <= min(xy[b][j].second, xy[b][jj].second)) continue;\n\t\t\tif (max(xy[b][j].second, xy[b][jj].second) <= min(xy[a][i].second, xy[a][ii].second)) continue;\n\t\t\treturn true;\n\t\t}\n\n\t\tif (x_a*y_b == x_b*y_a) {\n\t\t\tif (max(xy[a][i].first, xy[a][ii].first) <= min(xy[b][j].first, xy[b][jj].first)) continue;\n\t\t\tif (max(xy[b][j].first, xy[b][jj].first) <= min(xy[a][i].first, xy[a][ii].first)) continue;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n//-----------------------------------------------------------------\nint E[100][100];\nint C[100];\nmap<string, set<int>> M;\nint solve() {\n\trep(i, 0, n) rep(j, 0, n) E[i][j] = 0;\n\trep(i, 0, n) C[i] = 0;\n\tM.clear();\n\n\trep(i, 0, n) rep(j, i + 1, n) if (isAdjacent(i, j)) E[i][j] = E[j][i] = 1;\n\trep(i, 0, n) M[str[i]].insert(i);\n\n\tfor (auto p : M) {\n\t\tset<int>& v = p.second;\n\t\t\n\t\tset<int> s;\n\t\ts.insert(0);\n\t\tfor (int i : v) rep(j, 0, n) if (E[i][j]) s.insert(C[j]);\n\t\tint bak = 0;\n\t\tfor (int i : s) {\n\t\t\tif (i != bak) break;\n\t\t\tbak++;\n\t\t}\n\t\tfor (int i : v) C[i] = bak;\n\t}\n\n\t/*rep(i, 0, n) if(!C[i]){\n\t\tC[i] = 1;\n\n\t\tqueue<int> que;\n\t\trep(j, 0, n) if (!C[j] && E[i][j]) que.push(j);\n\t\twhile (!que.empty()) {\n\t\t\tint j = que.front(); que.pop();\n\t\t\tif (C[j]) continue;\n\n\t\t\tset<int> s;\n\t\t\trep(k, 0, n) if (E[j][k] && C[k]) s.insert(C[k]);\n\t\t\tif (*s.begin() != 1) {\n\t\t\t\tC[j] = 1;\n\t\t\t} else {\n\t\t\t\tint bak = 1;\n\t\t\t\tfor (int k : s) {\n\t\t\t\t\tif (bak == k) {\n\t\t\t\t\t\tbak++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tC[j] = bak;\n\t\t\t}\n\t\t\t\n\t\t\trep(k, 0, n) if (E[j][k] && !C[k]) que.push(k);\n\t\t}\n\t}*/\n\n\tint ans = -1;\n\trep(i, 0, n) ans = max(ans, C[i]);\n\t\n\t/*rep(i, 0, n) {\n\t\trep(j, 0, n) cout << E[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\trep(i, 0, n) cout << C[i] << \" \";\n\tcout << endl;*/\n\n\treturn ans;\n}\n//-----------------------------------------------------------------\nint main() {\n\twhile (cin >> n) {\n\t\tif (n == 0) return 0;\n\n\t\trep(i, 0, n) {\n\t\t\tcin >> str[i];\n\n\t\t\txy[i].clear();\n\t\t\tint x, y;\n\t\t\twhile (cin >> x) {\n\t\t\t\tif (x < 0) break;\n\t\t\t\tcin >> y;\n\t\t\t\txy[i].push_back({ x, y });\n\t\t\t}\n\t\t}\n\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tint x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n  int norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const {\n\t\treturn x == p.x && y == p.y;\n\t}\n\n  bool operator != (const Point &p) const {\n\treturn !(*this == p);\n  }\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\nint dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\nint cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) >0) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < 0) return CLOCKWISE;\n\tif (dot(a, b) <= 0) return ONLINE_BACK;\n\tif (a.norm() <= b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nbool intersect(Segment s1, Segment s2){\n  int c1 = ccw(s1.p1, s1.p2, s2.p1);\n  int c2 = ccw(s1.p1, s1.p2, s2.p2);\n  switch(c1){\n  case 2:\n\treturn (c2 == -2 || c2 == 0);\n  case -2:\n\treturn (c2 == 2 || c2 == 0);\n  case 0:\n\treturn (c2 == 2 || c2 == 0 || c2 == -2);\n  }\n  return false;\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin>>N,N){\n\tVS name(N);\n\tmap<string,int> id;\n\tvector<Polygon> poly(N);\n\tREP(i,N){\n\t  cin >> name[i];\n\t  if(!id.count(name[i])) id[name[i]] = SZ(id)-1;\n\t  while(true){\n\t\tint x; cin >> x;\n\t\tif(x < 0) break;\n\t\tint y; cin >> y;\n\t\tpoly[i].PB(Point(x,y));\n\t  }\n\t}\n\n\tint M = SZ(id);\n\tVVI xs(M);\n\tREP(i,N) FOR(j,i+1,N){\n\t  if(name[i] == name[j]) continue;\n\t  bool ok = false;\n\t  for(int i_=0;i_<SZ(poly[i]);++i_){\n\t\tSegment l1;\n\t\tl1.p1 = poly[i][i_];\n\t\tl1.p2 = poly[i][(i_+1)%SZ(poly[i])];\n\t\tfor(int j_=0;j_<SZ(poly[j]);++j_){\n\t\t  Segment l2;\n\t\t  l2.p1 = poly[j][j_];\n\t\t  l2.p2 = poly[j][(j_+1)%SZ(poly[j])];\n\t\t  if(intersect(l1,l2) || intersect(l2,l1)) ok = true;\n\t\t}\n\t  }\n\t  if(ok){\n\t\tint id1 = id[name[i]], id2 = id[name[j]];\n\t\tif(id1 < id2) swap(id1, id2);\n\t\txs[id1].PB(id2);\n\t  }\n\t}\n\n\tVI col(M,0);\n\tREP(i,M){\n\t  vector<bool> use(M+1,false);\n\t  for(int x: xs[i])\n\t\tuse[col[x]] = true;\n\t  for(int c=1;;++c)\n\t\tif(!use[c]){\n\t\t  col[i] = c;\n\t\t  break;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i,M) ans = max(ans, col[i]);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for (int i=0; i < (n); i++)\n#define fi first\n#define se second\ntypedef double D; \ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9; \n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\nbool isecSP(P a1, P a2, P b) {\n  return !ccw(a1, a2, b);\n}\nbool isecSS(P a1, P a2, P b1, P b2) {\n  if(a1==b1&&!isecSP(a1,a2,b2)||a1==b2&&!isecSP(a1,a2,b1)||a2==b1&&!isecSP(a1,a2,b2)||a2==b2&&!isecSP(a1,a2,b1))return 0;\n  return ccw(a1, a2, b1)*ccw(a1, a2, b2) <= 0 &&\n         ccw(b1, b2, a1)*ccw(b1, b2, a2) <= 0;\n}\nstring s[101];\ndouble x,y;\nvector<int>a[101],aa[12];\nint color[11],ans,n,used[101],yy;\nvoid dfs(int p,int d){\n  if(d+1>=ans)return ;\n  if(p==n){\n    ans=min(ans,d+1);\n    return;\n  }\n  int y[12]={},pp=0,pe;\n  r(j,aa[p].size())y[aa[p][j]]=1;\n  for(int i=0;i<d+2;i++){\n    int f=0;\n    r(j,12)if(y[j]&&color[j]==i)f++;\n    if(!f){\n      color[p]=i;\n      if(i==d+1)dfs(p+1,d+1);\n      else dfs(p+1,d);\n      color[p]=11;\n    }\n  }\n}\nint main(){\n  while(cin>>n,n){\n    ans=1e9;yy=n;\n    r(i,11)color[i]=11;\n    r(i,12)aa[i].clear();\n    r(i,101)a[i].clear();\n    VP v[n];\n    for(int i=0;i<yy;i++){\n      cin>>s[i];\n        while(cin>>x,x!=-1){\n          cin>>y;\n          v[i].push_back(P(x,y));\n        }\n    }\n    r(i,n)r(j,v[i].size())\n      r(k,n)if(i!=k)r(l,v[k].size())\n        if(isecSS(v[i][j],v[i][(j+1)%(int)v[i].size()],v[k][l],v[k][(l+1)%(int)v[k].size()]))\n          a[i].push_back(k);\n    r(i,n)sort(a[i].begin(),a[i].end());\n    r(i,n)a[i].erase(unique(a[i].begin(),a[i].end()),a[i].end());\n    //r(i,n)cout<<a[i].size()<<endl;\n    int c=0;\n    map<int,int>m;\n    memset(used,0,sizeof(used));\n    r(i,yy)if(!used[i]){\n      used[i]=1;\n      r(j,yy)if(!used[j]&&s[i]==s[j]){\n        used[j]=1;\n        m[j]=c;\n        r(k,a[j].size())aa[c].push_back(a[j][k]);\n        n--;\n      }\n      m[i]=c;\n      r(k,a[i].size())aa[c].push_back(a[i][k]);\n      c++;\n    }\n    r(i,n)r(j,aa[i].size())aa[i][j]=m[aa[i][j]];\n    r(i,n)sort(aa[i].begin(),aa[i].end());\n    r(i,n)aa[i].erase(unique(aa[i].begin(),aa[i].end()),aa[i].end());\n    color[0]=0;\n    //r(i,aa[0].size())cout<<\"    \"<<aa[0][i]<<endl;\n    dfs(1,0);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n\tvoid out(){\n\t\tcout << p1 << ' ' << p2 << endl;\n\t}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n\tbool operator == (const Segment &a, const Segment &b){\n\t\treturn (a.p1 == b.p1 and a.p2 == b.p2) or (a.p1 == b.p2 and a.p2 == b.p1);\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\nbool isIntersectedLs_(Point a1, Point a2, Point b1, Point b2) {\n\tdouble ax = a1.real(), ay = a1.imag();\n\tdouble bx = a2.real(), by = a2.imag();\n\tdouble cx = b1.real(), cy = b1.imag();\n\tdouble dx = b2.real(), dy = b2.imag();\n\n\tdouble ta = (cx - dx) * (ay - cy) + (cy - dy) * (cx - ax);\n\tdouble tb = (cx - dx) * (by - cy) + (cy - dy) * (cx - bx);\n\tdouble tc = (ax - bx) * (cy - ay) + (ay - by) * (ax - cx);\n\tdouble td = (ax - bx) * (dy - ay) + (ay - by) * (ax - dx);\n\n\treturn tc * td < -EPS and ta * tb < -EPS; // 端点含まず\n\t//return tc * td <= 0 and ta * tb <= 0; // 端点含む\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs_(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint nxt(Polygon& a, int i){\n\treturn a[(i + 1) % a.size()];\n}\n\nbool contain(const Segment& s, const Point& p) {\n    if (s.p1 == p) return 0;\n    if (s.p2 == p) return 0;\n    return ccw(s.p1, s.p2, p) == ON_SEGMENT;\n}\n\nbool isSharedLs(Segment s1, Segment s2){\n\tauto f = [](Segment s1, Segment s2) -> bool{\n\t\tif(isParallel(s1, s2)){\n\t\t\tif(contain(s1, s2.p1) or contain(s1, s2.p2)) return true;\n\t\t}\n\t\treturn false;\n\t};\n\treturn f(s1, s2) or f(s2, s1) or s1 == s2;\n}\n\n\nbool shareBorder(Polygon& a, Polygon& b){\n\trep(i,a.size()){\n\t\trep(j,b.size()){\n\t\t\tSegment s1 = Segment{a[i], nxt(a,i)}, s2 = Segment{b[j], nxt(b,j)};\n\t\t\tif(isSharedLs(s1, s2)) return true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvector<vector<Polygon>> input(int n){\n\tmap<string, vector<Polygon>> ps;\n\trep(i,n){\n\t\tstring name;\n\t\tcin >> name;\n\n\t\tPolygon p;\n\t\tdouble y, x;\n\t\twhile(cin >> y, y != -1){\n\t\t\tcin >> x;\n\t\t\tp.emplace_back(Point(y,x));\n\t\t}\n\t\t//show(name)\n\t\tps[name].emplace_back(p);\n\t}\n\n\tvector<vector<Polygon>> res;\n\tfor(auto i : ps){\n\t\tres.emplace_back(i.second);\n\t}\n\treturn res;\n}\n\nmap<int,int> memo;\nvoid dfs(int pos, vector<vector<bool>>& g, vector<int> c, int bit, int color){\n\tset<int> s;\n\trep(i,g.size()){\n\t\tif(g[pos][i]){\n\t\t\ts.emplace(c[i]);\n\t\t}\n\t}\n\n\tint k = 0;\n\twhile(s.count(k)) k++;\n\tc[pos] = k;\n\n\tbit |= 1 << pos;\n\n\tif(memo.count(bit) and memo[bit] <= max(color, k)) return;\n\n\trep(i,g.size()){\n\t\tif((bit >> i) & 1) continue;\n\t\tdfs(i, g, c, bit, max(color, k));\n\t}\n\tmemo[bit] = max(color, k);\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\t//for(auto i : ps){ show(i.first) for(auto j : i.second){ cout << j << endl; } }\n\t\tvector<vector<Polygon>> countries = input(n); // countries[i] := 国 i が持つ領地\n\t\tint m = countries.size();\n\n\t\tvector<vector<bool>> g(m, vector<bool>(m, 0)); // 国が隣接しているかを表す隣接行列\n\t\trep(i,m){\n\t\t\trep(j,countries[i].size()){\n\t\t\t\trep(k,m){\n\t\t\t\t\trep(l,countries[k].size()){\n\t\t\t\t\t\tif(shareBorder(countries[i][j], countries[k][l])) g[i][k] = g[k][i] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,m){ rep(j,m){ if(g[i][j]) cout << i << ' ' << j << endl; } } cout << endl;\n\n\t\t//int ans = 1e9;\n\t\t//rep(k,n){\n\t\t//\tvector<int> color(m, -1);\n\t\t//\tcolor[k] = 0;\n\t\t//\trep(i,m){\n\t\t//\t\tset<int> s;\n\t\t//\t\trep(j,m){\n\t\t//\t\t\tif(g[i][j]){\n\t\t//\t\t\t\ts.emplace(color[j]);\n\t\t//\t\t\t}\n\t\t//\t\t}\n\n\t\t//\t\tint k = 0;\n\t\t//\t\twhile(s.count(k)) k++; // 隣接している頂点の色に含まれないもののうち、最も小さい色を求める\n\t\t//\t\tcolor[i] = k;\n\t\t//\t}\n\n\t\t//\tset<int> s;\n\t\t//\tfor(auto i : color) s.emplace(i);\n\t\t//\tans = min<int>(ans, s.size());\n\t\t//}\n\t\tint ans = 1e9;\n\t\trep(i,m){\n\t\t\tmemo.clear();\n\t\t\tvector<int> c(m, -1);\n\t\t\tdfs(i, g, c, 0, -1);\n\t\t\tans = min(ans, memo[(1 << m) - 1]);\n\t\t\t//cout << endl;\n\t\t}\n\t\tcout << ans + 1 << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n\nconst double eps=1e-5;\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef vector<Polygon> Country;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\nbool d[100][100];\nint color[10];\nint nv;\n\nint dfs(int x,int n){\n  if(x==nv){\n    return n;\n  }else{\n    int m=99;\n    for(int i=0;i<n+1;i++){\n      bool f=false;\n      for(int j=0;j<x;j++){\n\tf|=d[x][j]&&i==color[j];\n      }\n      if(!f){\n\tcolor[x]=i;\n\tm=min(m,dfs(x+1,max(n,i+1)));\n      }\n    }\n    return m;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    map<string,Country> m;\n    while(n--){\n      string s;\n      cin>>s;\n      Polygon p;\n      for(int x,y;cin>>x,x>=0;){\n\tcin>>y;\n\tp.push_back(P(x,y));\n      }\n      m[s].push_back(p);\n    }\n    vector<Country> c;\n    for(auto e:m){\n      c.push_back(e.second);\n    }\n    nv=c.size();\n    fill(d[0],d[10],false);\n    for(int i=0;i<c.size();i++){\n      for(auto e:c[i]){\n\tfor(int j=0;j<e.size();j++){\n\t  for(int k=0;k<i;k++){\n\t    for(auto f:c[k]){\n\t      for(int l=0;l<f.size();l++){\n\t\tP a=e[j],b=e[(j+1)%e.size()];\n\t\tP x=f[l],y=f[(l+1)%f.size()];\n\t\tif(fabs(cross(a-b,x-b))<eps&&fabs(cross(a-b,y-b)<eps)){\n\t\t  double len=abs(a-b);\n\t\t  if(!(len<abs(x-a)+eps&&len<abs(y-a)+eps||len<abs(x-b)+eps&&len<abs(y-b)+eps)){\n\t\t    d[i][k]=d[k][i]=true;\n\t\t  }\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<dfs(0,0)<<endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1254 Color the Map\n// 2018.3.19 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n\n// 高速数値出力\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n// 整数（負数も）の入力\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') {\n\t\tc = gc();\n\t\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n// 文字列の入力　スペース以下の文字で入力終了\nvoid ins(char *s)\n{\n\tdo *s = gc();\n\twhile (*s++ > ' ');\n\t*(s - 1) = 0;\n}\n\n\n// 文字列のハッシュ関数\n#define HASHSIZ 997\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ + 2], *hashend = hash + HASHSIZ;\n\nint insert(char *s, int id)\n{\n\tunsigned long long i;\n\tint j;\n\tchar *p;\n\tHASH *tp;\n\n\ti = 0, p = s;\n\tfor (j = 0; *p && j < 12; j++) i = (i << 5) + (*p++ + 1 - 'a');\n\ttp = hash + (int)(i % HASHSIZ);\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n\treturn -1;\n}\n\n\n// 平面幾何関連    座標を整数に修正したので、実用性ゼロ\ntypedef struct { int x, y; } PP;\ntypedef struct { PP s, e; } SEG, LINE;\ntypedef struct { int n; PP p[105]; } POLY;   // 多角形に含まれる最大頂点 50\n\n#define INF\t\t\t100000000\n#define EQ(a,b)\t\t((a)==(b))\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\n\nint ppInSeg(PP p, PP p1, PP p2)\n{\n\tint x1 = p1.x, y1 = p1.y, x2 = p2.x, y2 = p2.y;\n\tint d;\n\tif (x1 > x2) { d = x1, x1 = x2, x2 = d; d = y1, y1 = y2, y2 = d; }\n\td = (x1 <= p.x && p.x <= x2 &&\n\t\t((y1 <= y2 && y1 <= p.y && p.y <= y2) ||\n\t\t(y1 > y2 && y2 <= p.y && p.y <= y1))\n\t\t&& (p.y - y1)*(x2 - x1) == (y2 - y1)*(p.x - x1));\n\tif (!d || PPeQ(p, p1) || PPeQ(p, p2)) return 0;\n\treturn 1;\n}\n\n// ２本の直線は平行しているか\nint isParaLL(PP s1s, PP s1e, PP s2s, PP s2e) {\n\treturn EQ((s2e.y - s2s.y)*(s1e.x - s1s.x),\n\t\t      (s1e.y - s1s.y)*(s2e.x - s2s.x));\n}\n\n// 2本の線分は重なっているか\nint overlapSS(PP s1s, PP s1e, PP s2s, PP s2e)\n{\n\tif (!isParaLL(s1s, s1e, s2s, s2e)) return 0;\n\treturn ppInSeg(s1s, s2s, s2e) || ppInSeg(s1e, s2s, s2e) ||\n\t\t   ppInSeg(s2s, s1s, s1e) || ppInSeg(s2e, s1s, s1e) ||\n           (PPeQ(s1s, s2s) && PPeQ(s1e, s2e)) || (PPeQ(s1s, s2e) && PPeQ(s1e, s2s));\n}\n\n// ２つの多角形が隣接（頂点ではなく、線分でオーバラップしているか）\nint intersectPoly(int n1, PP *p1, int n2, PP *p2)\n{\n\tint i, j;\n\n\tfor (i = 0; i < n1; i++)\n\t\tfor (j = 0; j < n2; j++)\n\t\t\tif (overlapSS(p1[i], p1[i + 1], p2[j], p2[j + 1])) return 1;\n\treturn 0;\n}\n\n\n// 本問題関連\ntypedef struct { int id, hi; } T;\nT t[13];\nint N;\nPOLY poly[105];\nchar name[105][25]; int id[105]; int sz;\nint adj[13][50], hi[13];\nint color[13];\n\nint cmp(const void *a, const void *b) { return *(int *)a - *(int *)b; }\nint cmp2(const void *a, const void *b) { return ((T *)b)->hi - ((T *)a)->hi; }\n\nint check(int id, int max)\n{\n\tint i, k;\n\tchar f[13];\n\n\tif (id >= sz) return 1;\n\tmemset(f, 0, sizeof(f));\n\tfor (i = 0; i < hi[id]; i++) {\n\t\tk = color[adj[id][i]];\n\t\tif (k) f[k] = 1;\n\t}\n\tfor (i = 1; i <= max; i++) if (!f[i]) {\n\t\tcolor[id] = i;\n\t\tif (check(id + 1, max)) return 1;\n\t\tcolor[id] = 0;\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tint i, j, k, x, ans;\n\tint id1, id2;\n\tchar f[13];\n\n\twhile (N = in()) {\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tsz = 0;\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tins(name[sz]);\n\t\t\tif ((k = insert(name[sz], sz)) < 0) k = sz++;\n\t\t\tid[i] = k;\n\t\t\tfor (j = 0; (x = in()) >= 0; j++)\n\t\t\t\tpoly[i].p[j].x = x, poly[i].p[j].y = in();\n\t\t\tpoly[i].n = j;\n\t\t\tpoly[i].p[j] = poly[i].p[0];\n\t\t}\n#if 0\n\t\tfor (i = 0; i < N; i++) {\n\t\t\tprintf(\"id=%d, n=%d:\", id[i], poly[i].n);\n\t\t\tfor (j = 0; j < poly[i].n; j++) printf(\" (%d,%d)\", poly[i].p[j].x, poly[i].p[j].y);\n\t\t\tprintf(\"\\n\");\n\t\t}\n#endif\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tx = 0; for (i = 0; i < N; i++) {\n\t\t\tid1 = id[i];\n\t\t\tfor (j = i + 1; j < N; j++) {\n\t\t\t\tid2 = id[j];\n\t\t\t\tif (id1 == id2) continue;\n\t\t\t\tfor (k = 0; k < hi[id1]; k++) if (adj[id1][k] == id2) break;\n\t\t\t\tif (k < hi[id1]) continue;\n\t\t\t\tif (intersectPoly(poly[i].n, poly[i].p, poly[j].n, poly[j].p)) {\n\t\t\t\t\tadj[id1][hi[id1]++] = id2;\n\t\t\t\t\tadj[id2][hi[id2]++] = id1;\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#if 0\n\t\tfor (i = 0; i < sz; i++) {\n\t\t\tprintf(\"adj[%d] \", i);\n\t\t\tfor (j = 0; j < hi[i]; j++) printf(\" %d\", adj[i][j]);\n\t\t\tprintf(\"\\n\");\n\t\t}\n#endif\n\t\tif (x <= 1) ans = x + 1;\n\t\telse {\n\t\t\tfor (i = 0; i < sz; i++) t[i].id = i, t[i].hi = hi[i];\n\t\t\tqsort(t, sz, sizeof(T), cmp2);\n\t\t\tmemset(color, 0, sizeof(color));\n\t\t\tcolor[t[0].id] = 1;\n\t\t\tfor (i = 1; i < sz; i++) {\n\t\t\t\tid1 = t[i].id;\n\t\t\t\tmemset(f, 0, sizeof(f));\n\t\t\t\tfor (j = 0; j < hi[id1]; j++) {\n\t\t\t\t\tif (color[adj[id1][j]]) f[color[adj[id1][j]]] = 1;\n\t\t\t\t}\n\t\t\t\tfor (j = 1; f[j]; j++);\n\t\t\t\tcolor[id1] = j;\n\t\t\t}\n\t\t\tqsort(color, sz, sizeof(int), cmp);\n\t\t\tans = 1; for (i = 1; i < sz; i++) {\n\t\t\t\tif (color[i] != color[i - 1]) ans++;\n\t\t\t}\n#if 0\n\t\t\tif (ans > 2) while (1) {\n\t\t\t\tmemset(color, 0, sizeof(color));\n\t\t\t\tif (!check(0, ans - 1)) break;\n\t\t\t\tans--;\n\t\t\t}\n#endif\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Color the Map\npublic class Main{\n\n\tclass R{\n\t\tList<L> l;\n\t\tboolean u;\n\t\tint color, id;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tl = new ArrayList<L>();\n\t\t\tu = false;\n\t\t\tcolor = 0;\n\t\t}\n\t\tboolean adj(R r){\n\t\t\tfor(L a:l)for(L b:r.l){\n\t\t\t\tdouble x1 = a.t.x-a.s.x, y1 = a.t.y-a.s.y, x2 = b.t.x-b.s.x, y2 = b.t.y-b.s.y;\n\t\t\t\tif(x1*y2-x2*y1!=0)continue;\n\t\t\t\tif(x1==0){\n\t\t\t\t\tif(a.s.x!=b.s.x)continue;\n\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\ta.s.id = a.t.id = 0; b.s.id = b.t.id = 1;\n\t\t\t\t\tp[0] = a.s; p[1] = a.t;\n\t\t\t\t\tp[2] = b.s; p[3] = b.t;\n\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble alpha = y1/x1;\n\t\t\t\t\tdouble beta = a.s.y-alpha*a.s.x;\n\t\t\t\t\tdouble y = b.s.y, x = alpha*b.s.x+beta;\n\t\t\t\t\tif(Math.abs(y-x)<1e-7){\n\t\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\t\ta.s.id = a.t.id = 0; b.s.id = b.t.id = 1;\n\t\t\t\t\t\tp[0] = a.s; p[1] = a.t;\n\t\t\t\t\t\tp[2] = b.s; p[3] = b.t;\n\t\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint id;\n\t\tdouble x, y;\n\t\tpublic P(double x, double y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tid = d;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(x<o.x)return -1;\n\t\t\tif(o.x<x)return 1;\n\t\t\treturn (int) Math.signum(y-o.y);\n\t\t}\n\t\tboolean eq(P p){\n\t\t\treturn Math.abs(x-p.x)<1e-7 && Math.abs(y-p.y)<1e-7;\n\t\t}\n\t}\n\tclass L{\n\t\tP s, t;\n\t\tpublic L(P s, P t) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tif(t.compareTo(s)<0){\n\t\t\t\tP tmp = s;\n\t\t\t\ts = t;\n\t\t\t\tt = tmp;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tR[] c;\n\tint N, min;\n\tboolean[][] adj;\n\t\n\tvoid dfs(int k, int maxcolor){\n\t\tboolean[] u = new boolean[11];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(adj[k][i])u[c[i].color] = true;\n\t\t}\n\t\tif(k==N-1){\n\t\t\tfor(int i=1;i<=maxcolor+1;i++){\n\t\t\t\tif(!u[i]){\n\t\t\t\t\tmin = Math.min(min, Math.max(i, maxcolor));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=maxcolor+1;i++){\n\t\t\tif(!u[i]){\n\t\t\t\tc[k].color = i;\n\t\t\t\tdfs(k+1, Math.max(i, maxcolor));\n\t\t\t\tc[k].color = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint id = 0;\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tc = new R[10];\n\t\t\twhile(n--!=0){\n\t\t\t\tString name = sc.next();\n\t\t\t\tR r;\n\t\t\t\tif(ref.containsKey(name))r = c[ref.get(name)];\n\t\t\t\telse{\n\t\t\t\t\tr = new R(id);\n\t\t\t\t\tc[id] = r;\n\t\t\t\t\tref.put(name, id++);\n\t\t\t\t}\n\t\t\t\tint sx = sc.nextInt(), sy = sc.nextInt();\n\t\t\t\tint px = sx, py = sy;\n\t\t\t\tfor(;;){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tr.l.add(new L(new P(px, py, 0), new P(sx, sy, 0)));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tr.l.add(new L(new P(px, py, 0), new P(x, y, 0)));\n\t\t\t\t\tpx = x; py = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new boolean[id][id];\n\t\t\tfor(int i=0;i<id;i++)for(int j=i+1;j<id;j++){\n\t\t\t\tif(adj[i][j])continue;\n\t\t\t\tif(c[i].adj(c[j])){\n\t\t\t\t\tadj[i][j] = true;\n\t\t\t\t\tadj[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tN = id;\n\t\t\tmin = 10;\n\t\t\tdfs(0, 0);\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Color the Map\npublic class Main{\n\n\tclass R{\n\t\tList<L> l;\n\t\tboolean u;\n\t\tint color, id;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tl = new ArrayList<L>();\n\t\t\tu = false;\n\t\t\tcolor = 0;\n\t\t}\n\t\tboolean adj(R r){\n\t\t\tfor(L a:l)for(L b:r.l){\n\t\t\t\tint x1 = a.x2-a.x1, y1 = a.y2-a.y1, x2 = b.x2-b.x1, y2 = b.y2-b.y1;\n\t\t\t\tif(x1*y2-x2*y1!=0)continue;\n\t\t\t\tif(x1==0){\n\t\t\t\t\tif(a.x1!=b.x1)continue;\n\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\tp[0] = new P(a.x1, a.y1, 0); p[1] = new P(a.x2, a.y2, 0);\n\t\t\t\t\tp[2] = new P(b.x1, b.y1, 1); p[3] = new P(b.x2, b.y2, 1);\n\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble alpha = y1/x1;\n\t\t\t\t\tdouble beta = a.y1-alpha*a.x1;\n\t\t\t\t\tdouble y = b.y1, x = alpha*b.x1+beta;\n\t\t\t\t\tif(Math.abs(y-x)<1e-7){\n\t\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\t\tp[0] = new P(a.x1, a.y1, 0); p[1] = new P(a.x2, a.y2, 0);\n\t\t\t\t\t\tp[2] = new P(b.x1, b.y1, 1); p[3] = new P(b.x2, b.y2, 1);\n\t\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint id;\n\t\tdouble x, y;\n\t\tpublic P(double x, double y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tid = d;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(x<o.x)return -1;\n\t\t\tif(o.x<x)return 1;\n\t\t\treturn (int) Math.signum(y-o.y);\n\t\t}\n\t\tboolean eq(P p){\n\t\t\treturn Math.abs(x-p.x)<1e-7 && Math.abs(y-p.y)<1e-7;\n\t\t}\n\t}\n\tclass L{\n\t\tint x1, y1, x2, y2;\n\t\tpublic L(int x1, int y1, int x2, int y2) {\n\t\t\tif(x1<x2||x1==x2&&y1<y2){\n\t\t\t\tthis.x1 = x1;\n\t\t\t\tthis.y1 = y1;\n\t\t\t\tthis.x2 = x2;\n\t\t\t\tthis.y2 = y2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.x1 = x2;\n\t\t\t\tthis.y1 = y2;\n\t\t\t\tthis.x2 = x1;\n\t\t\t\tthis.y2 = y1;\n\t\t\t}\n\t\t}\n\t}\n\n\tR[] c;\n\tint N, min;\n\tboolean[][] adj;\n\t\n\tvoid dfs(int k, int maxcolor){\n\t\tboolean[] u = new boolean[11];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(adj[k][i])u[c[i].color] = true;\n\t\t}\n\t\tif(k==N-1){\n\t\t\tfor(int i=1;i<=maxcolor+1;i++){\n\t\t\t\tif(!u[i]){\n\t\t\t\t\tmin = Math.min(min, Math.max(i, maxcolor));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<=maxcolor+1;i++){\n\t\t\tif(!u[i]){\n\t\t\t\tc[k].color = i;\n\t\t\t\tdfs(k+1, Math.max(i, maxcolor));\n\t\t\t\tc[k].color = 0;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint id = 0;\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tc = new R[10];\n\t\t\twhile(n--!=0){\n\t\t\t\tString name = sc.next();\n\t\t\t\tR r;\n\t\t\t\tif(ref.containsKey(name))r = c[ref.get(name)];\n\t\t\t\telse{\n\t\t\t\t\tr = new R(id);\n\t\t\t\t\tc[id] = r;\n\t\t\t\t\tref.put(name, id++);\n\t\t\t\t}\n\t\t\t\tint sx = sc.nextInt(), sy = sc.nextInt();\n\t\t\t\tint px = sx, py = sy;\n\t\t\t\tfor(;;){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tr.l.add(new L(px, py, sx, sy));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tr.l.add(new L(px, py, x, y));\n\t\t\t\t\tpx = x; py = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tadj = new boolean[id][id];\n\t\t\tfor(int i=0;i<id;i++)for(int j=i+1;j<id;j++){\n\t\t\t\tif(adj[i][j])continue;\n\t\t\t\tif(c[i].adj(c[j])){\n\t\t\t\t\tadj[i][j] = true;\n\t\t\t\t\tadj[j][i] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tN = id;\n\t\t\tmin = 10;\n\t\t\tdfs(0, 0);\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Color the Map\npublic class Main{\n\n\tclass R{\n\t\tList<L> l;\n\t\tList<R> adj;\n\t\tboolean u;\n\t\tint color, id;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new ArrayList<R>();\n\t\t\tl = new ArrayList<L>();\n\t\t\tu = false;\n\t\t\tcolor = 0;\n\t\t}\n\t\tboolean adj(R r){\n\t\t\tfor(L a:l)for(L b:r.l){\n\t\t\t\tint x1 = a.x2-a.x1, y1 = a.y2-a.y1, x2 = b.x2-b.x1, y2 = b.y2-b.y1;\n\t\t\t\tif(x1*y2-x2*y1!=0)continue;\n\t\t\t\tif(x1==0){\n\t\t\t\t\tif(a.x1!=b.x1)continue;\n\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\tp[0] = new P(a.x1, a.y1, 0); p[1] = new P(a.x2, a.y2, 0);\n\t\t\t\t\tp[2] = new P(b.x1, b.y1, 1); p[3] = new P(b.x2, b.y2, 1);\n\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble alpha = y1/x1;\n\t\t\t\t\tdouble beta = a.y1-alpha*a.x1;\n\t\t\t\t\tdouble y = b.y1, x = alpha*b.x1+beta;\n\t\t\t\t\tif(Math.abs(y-x)<1e-7){\n\t\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\t\tp[0] = new P(a.x1, a.y1, 0); p[1] = new P(a.x2, a.y2, 0);\n\t\t\t\t\t\tp[2] = new P(b.x1, b.y1, 1); p[3] = new P(b.x2, b.y2, 1);\n\t\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint id;\n\t\tdouble x, y;\n\t\tpublic P(double x, double y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tid = d;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(x<o.x)return -1;\n\t\t\tif(o.x<x)return 1;\n\t\t\treturn (int) Math.signum(y-o.y);\n\t\t}\n\t\tboolean eq(P p){\n\t\t\treturn Math.abs(x-p.x)<1e-7 && Math.abs(y-p.y)<1e-7;\n\t\t}\n\t}\n\tclass L{\n\t\tint x1, y1, x2, y2;\n\t\tpublic L(int x1, int y1, int x2, int y2) {\n\t\t\tif(x1<x2||x1==x2&&y1<y2){\n\t\t\t\tthis.x1 = x1;\n\t\t\t\tthis.y1 = y1;\n\t\t\t\tthis.x2 = x2;\n\t\t\t\tthis.y2 = y2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.x1 = x2;\n\t\t\t\tthis.y1 = y2;\n\t\t\t\tthis.x2 = x1;\n\t\t\t\tthis.y2 = y1;\n\t\t\t}\n\t\t}\n\t}\n\n\tR[] c;\n\tint N;\n\t\n\tboolean f(int max){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(c[i].u)continue;\n\t\t\tif(!dfs(i, 1, max))return false;\n\t\t}\n\t\treturn true;\n\t}\n\tboolean dfs(int k, int col, int limit){\n//\t\tSystem.out.println(\"DFS:\" + k + \" Col:\"+col+\" Limit:\"+limit);\n\t\tboolean[] u = new boolean[11];\n\t\tfor(R r:c[k].adj)if(r.u)u[r.color] = true;\n\t\tif(u[col])return false;\n\t\tc[k].color = col; c[k].u = true;\n\t\tboolean f = true;\n\t\tfor(R r:c[k].adj)if(!r.u)f = false;\n\t\tif(f)return true;\n//\t\tfor(int i=0;i<N;i++){\n//\t\t\tSystem.out.println(\"I:\"+i + \" Color:\"+c[i].color);\n//\t\t}\n\t\tfor(int t=1;t<=limit;t++){\n\t\t\tif(t==col)continue;\n\t\t\tfor(R r:c[k].adj){\n\t\t\t\tif(r.u)continue;\n\t\t\t\tif(dfs(r.id, t, limit))return true;\n\t\t\t}\n\t\t}\n\t\tc[k].color = 0; c[k].u = false;\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint id = 0;\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tc = new R[10];\n\t\t\twhile(n--!=0){\n\t\t\t\tString name = sc.next();\n\t\t\t\tR r;\n\t\t\t\tif(ref.containsKey(name))r = c[ref.get(name)];\n\t\t\t\telse{\n\t\t\t\t\tr = new R(id);\n\t\t\t\t\tc[id] = r;\n\t\t\t\t\tref.put(name, id++);\n\t\t\t\t}\n\t\t\t\tint sx = sc.nextInt(), sy = sc.nextInt();\n\t\t\t\tint px = sx, py = sy;\n\t\t\t\tfor(;;){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tr.l.add(new L(px, py, sx, sy));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tr.l.add(new L(px, py, x, y));\n\t\t\t\t\tpx = x; py = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] adj = new boolean[id][id];\n\t\t\tfor(int i=0;i<id;i++)for(int j=i+1;j<id;j++){\n\t\t\t\tif(adj[i][j])continue;\n\t\t\t\tif(c[i].adj(c[j])){\n//\t\t\t\t\tSystem.out.println(\"ADJ: \" + i+\" - \"+j);\n\t\t\t\t\tadj[i][j] = true;\n\t\t\t\t\tadj[j][i] = true;\n\t\t\t\t}\n\t\t\t\tif(adj[i][j]){\n\t\t\t\t\tc[i].adj.add(c[j]);\n\t\t\t\t\tc[j].adj.add(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tN = id;\n\t\t\tfor(int t=1;t<=10;t++){\n\t\t\t\tif(!f(t))continue;\n\t\t\t\tSystem.out.println(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.*;\nimport java.io.*;\nimport java.util.*;\n\n\npublic class Main {\n\t//0156 start\n\tdouble EPS = 1.0e-08;\n\tint ans ,n, m;\n\tboolean [] used;\n\tPoly [] data;\n\tboolean [][] pass;\n\tint [] color;\n\tArrayList<ArrayList<Integer>> country;\n\n\tclass Poly {\n\t\tint id;\n\t\tArrayList<Line2D> lines;\n\t\tpublic Poly(int id,ArrayList<Line2D> lines) {\n\t\t\tthis.id = id;\n\t\t\tthis.lines = lines;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Poly [id=\" + id + \", lines=\" + lines + \"]\";\n\t\t}\n\n\t}\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tdata = new Poly[n];\n\t\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\tcountry = new ArrayList<ArrayList<Integer>>();\n\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tString na = sc.next();\n\t\t\t\tint id = -1;\n\t\t\t\tif(map.containsKey(na)){\n\t\t\t\t\tid = map.get(na);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tmap.put(na, map.size()+1);\n\t\t\t\t\tid = map.get(na);\n\t\t\t\t}\n\t\t\t\tArrayList<Point2D> temp = new ArrayList<Point2D>();\n\t\t\t\twhile(true){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tif(x == -1){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\ttemp.add(new Point2D.Double(x, y));\n\t\t\t\t}\n\t\t\t\tArrayList<Line2D> lines = new ArrayList<Line2D>();\n\t\t\t\tint len = temp.size();\n\t\t\t\tfor(int j = 0; j < len; j++){\n\t\t\t\t\tlines.add( new Line2D.Double(temp.get(j), temp.get((j+1) % len)));\n\t\t\t\t}\n\t\t\t\tdata[i] = new Poly(id, lines);\n\t\t\t}\n\t\t\tm = map.size();\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tcountry.add(new ArrayList<Integer>());\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tcountry.get(data[i].id-1).add(i);\n\t\t\t}\n\n\t\t\t//create graph\n\t\t\tpass = new boolean[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tboolean res = intersect(data[i].lines, data[j].lines);\n\t\t\t\t\tif(res && data[i].id != data[j].id){\n\t\t\t\t\t\tpass[i][j] = true;\n\t\t\t\t\t\tpass[j][i] = true;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tboolean ansf = false;\n\t\t\tfor(int i = 1; i < m; i++){\n\t\t\t\tans = 1 << 24;\n\t\t\t\tused = new boolean[m];\n\t\t\t\tcolor = new int[n];\n\t\t\t\tdfs(0, i, 0);\n\t\t\t\tif(ans != 1 << 24){\n\t\t\t\t\tansf = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ansf){\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(m);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void dfs(int deep,int max,int kind) {\n\t\tif(deep == m){\n\t\t\tans = Math.min(ans, kind);\n\t\t\treturn ;\n\t\t}\n\n\t\tfor(int i = 1; i <= Math.min(max, deep+1); i++){\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 0; j < country.get(deep).size(); j++){\n\t\t\t\tint num = country.get(deep).get(j);\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(! pass[num][k]) continue;\n\t\t\t\t\tif(num == k) continue;\n\t\t\t\t\tif(color[k] != 0 && color[k] == i){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(flg){\n\t\t\t\tfor(int j = 0; j < country.get(deep).size(); j++){\n\t\t\t\t\tcolor[country.get(deep).get(j)] = i;\n\t\t\t\t}\n\t\t\t\tdfs(deep + 1, max, Math.max(kind, i));\n\t\t\t\tfor(int j = 0; j < country.get(deep).size(); j++){\n\t\t\t\t\tcolor[country.get(deep).get(j)] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate boolean intersect(ArrayList<Line2D> a, ArrayList<Line2D> b) {\n\t\tfor(int i = 0; i < a.size();i++){\n\t\t\tfor(int j = 0; j < b.size(); j++){\n\t\t\t\tif(a.get(i).intersectsLine(b.get(j))){\n\t\t\t\t\tPoint2D p1 = sub(a.get(i).getP1(), a.get(i).getP2());\n\t\t\t\t\tPoint2D p2 = sub(b.get(j).getP2(), b.get(j).getP2());\n\t\t\t\t\tif(Math.abs(cross(p1, p2)) < EPS){\n\t\t\t\t\t\tif(isborder(a.get(i), b.get(j)) || isborder(b.get(j), a.get(i))){\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate boolean isborder(Line2D l, Line2D m) {\n\t\tdouble res = l.ptSegDist(m.getP1());\n\t\tif(res < EPS){\n\t\t\tif(l.getP1().distance(m.getP1()) < EPS || l.getP2().distance(m.getP1()) < EPS){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t double res2 = l.ptSegDist(m.getP2());\n\t\tif(res2 < EPS){\n\t\t\tif(l.getP1().distance(m.getP2()) < EPS || l.getP2().distance(m.getP2()) < EPS){\n\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tif(res < EPS && res2 < EPS){\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tprivate Point2D sub(Point2D p2, Point2D p1) {\n\t\tdouble x = p2.getX() - p1.getX();\n\t\tdouble y = p2.getY() - p1.getY();\n\t\treturn new Point2D.Double(x, y);\n\t}\n\n\tprivate double cross(Point2D p1, Point2D p2) {\n\t\tdouble res = p1.getX() * p2.getY() - p1.getY() * p2.getX();\n\t\treturn res;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//Color the Map\npublic class Main{\n\n\tclass R{\n\t\tList<L> l;\n\t\tList<R> adj;\n\t\tboolean u;\n\t\tint color, id;\n\t\tpublic R(int id) {\n\t\t\tthis.id = id;\n\t\t\tadj = new ArrayList<R>();\n\t\t\tl = new ArrayList<L>();\n\t\t\tu = false;\n\t\t\tcolor = 0;\n\t\t}\n\t\tboolean adj(R r){\n\t\t\tfor(L a:l)for(L b:r.l){\n\t\t\t\tint x1 = a.x2-a.x1, y1 = a.y2-a.y1, x2 = b.x2-b.x1, y2 = b.y2-b.y1;\n\t\t\t\tif(x1*y2-x2*y1!=0)continue;\n\t\t\t\tif(x1==0){\n\t\t\t\t\tif(a.x1!=b.x1)continue;\n\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\tp[0] = new P(a.x1, a.y1, 0); p[1] = new P(a.x2, a.y2, 0);\n\t\t\t\t\tp[2] = new P(b.x1, b.y1, 1); p[3] = new P(b.x2, b.y2, 1);\n\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdouble alpha = y1/x1;\n\t\t\t\t\tdouble beta = a.y1-alpha*a.x1;\n\t\t\t\t\tdouble y = b.y1, x = alpha*b.x1+beta;\n\t\t\t\t\tif(Math.abs(y-x)<1e-7){\n\t\t\t\t\t\tP[] p = new P[4];\n\t\t\t\t\t\tp[0] = new P(a.x1, a.y1, 0); p[1] = new P(a.x2, a.y2, 0);\n\t\t\t\t\t\tp[2] = new P(b.x1, b.y1, 1); p[3] = new P(b.x2, b.y2, 1);\n\t\t\t\t\t\tArrays.sort(p);\n\t\t\t\t\t\tif(p[0].id==p[1].id)continue;\n\t\t\t\t\t\tif(!p[1].eq(p[2]))return true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tclass P implements Comparable<P>{\n\t\tint id;\n\t\tdouble x, y;\n\t\tpublic P(double x, double y, int d) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tid = d;\n\t\t}\n\t\tpublic int compareTo(P o) {\n\t\t\tif(x<o.x)return -1;\n\t\t\tif(o.x<x)return 1;\n\t\t\treturn (int) Math.signum(y-o.y);\n\t\t}\n\t\tboolean eq(P p){\n\t\t\treturn Math.abs(x-p.x)<1e-7 && Math.abs(y-p.y)<1e-7;\n\t\t}\n\t}\n\tclass L{\n\t\tint x1, y1, x2, y2;\n\t\tpublic L(int x1, int y1, int x2, int y2) {\n\t\t\tif(x1<x2||x1==x2&&y1<y2){\n\t\t\t\tthis.x1 = x1;\n\t\t\t\tthis.y1 = y1;\n\t\t\t\tthis.x2 = x2;\n\t\t\t\tthis.y2 = y2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.x1 = x2;\n\t\t\t\tthis.y1 = y2;\n\t\t\t\tthis.x2 = x1;\n\t\t\t\tthis.y2 = y1;\n\t\t\t}\n\t\t}\n\t}\n\n\tR[] c;\n\tint N;\n\t\n\tboolean f(int max){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(c[i].u)continue;\n\t\t\tif(!dfs(i, 1, max))return false;\n\t\t}\n\t\treturn true;\n\t}\n\tboolean dfs(int k, int col, int limit){\n//\t\tSystem.out.println(\"DFS:\" + k + \" Col:\"+col+\" Limit:\"+limit);\n\t\tint max = col;\n\t\tboolean[] u = new boolean[11];\n\t\tfor(R r:c[k].adj)if(r.u){\n\t\t\tmax = Math.max(max, r.color);\n\t\t\tu[r.color] = true;\n\t\t}\n\t\tif(u[col])return false;\n\t\tc[k].color = col; c[k].u = true;\n\t\tboolean f = true;\n\t\tfor(R r:c[k].adj)if(!r.u)f = false;\n\t\tif(f)return true;\n//\t\tfor(int i=0;i<N;i++){\n//\t\t\tSystem.out.println(\"I:\"+i + \" Color:\"+c[i].color);\n//\t\t}\n\t\tfor(int t=1;t<=Math.min(max+1, limit);t++){\n\t\t\tif(t==col)continue;\n\t\t\tfor(R r:c[k].adj){\n\t\t\t\tif(r.u)continue;\n\t\t\t\tif(dfs(r.id, t, limit))return true;\n\t\t\t}\n\t\t}\n\t\tc[k].color = 0; c[k].u = false;\n\t\treturn false;\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint id = 0;\n\t\t\tMap<String, Integer> ref = new HashMap<String, Integer>();\n\t\t\tc = new R[10];\n\t\t\twhile(n--!=0){\n\t\t\t\tString name = sc.next();\n\t\t\t\tR r;\n\t\t\t\tif(ref.containsKey(name))r = c[ref.get(name)];\n\t\t\t\telse{\n\t\t\t\t\tr = new R(id);\n\t\t\t\t\tc[id] = r;\n\t\t\t\t\tref.put(name, id++);\n\t\t\t\t}\n\t\t\t\tint sx = sc.nextInt(), sy = sc.nextInt();\n\t\t\t\tint px = sx, py = sy;\n\t\t\t\tfor(;;){\n\t\t\t\t\tint x = sc.nextInt();\n\t\t\t\t\tif(x==-1){\n\t\t\t\t\t\tr.l.add(new L(px, py, sx, sy));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint y = sc.nextInt();\n\t\t\t\t\tr.l.add(new L(px, py, x, y));\n\t\t\t\t\tpx = x; py = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] adj = new boolean[id][id];\n\t\t\tfor(int i=0;i<id;i++)for(int j=i+1;j<id;j++){\n\t\t\t\tif(adj[i][j])continue;\n\t\t\t\tif(c[i].adj(c[j])){\n//\t\t\t\t\tSystem.out.println(\"ADJ: \" + i+\" - \"+j);\n\t\t\t\t\tadj[i][j] = true;\n\t\t\t\t\tadj[j][i] = true;\n\t\t\t\t}\n\t\t\t\tif(adj[i][j]){\n\t\t\t\t\tc[i].adj.add(c[j]);\n\t\t\t\t\tc[j].adj.add(c[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tN = id;\n\t\t\tfor(int t=1;t<=10;t++){\n\t\t\t\tif(!f(t))continue;\n\t\t\t\tSystem.out.println(t);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Line\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef overlap?(l)\n\t\tif @a == 0\n\t\t\treturn false unless l.a == 0\n\t\t\treturn false unless l.b * @c == @b * l.c\n\t\telse\n\t\t\treturn false unless l.a * @b == @a * l.b && l.a * @c + @a * l.c\n\t\tend\n\t\tif @a == 0\n\t\t\treturn true if @x1 <= l.x1 && l.x1 < @x2\n\t\t\treturn true if @x1 < l.x2 && l.x2 <= @x2\n\t\t\treturn true if l.x1 <= @x1 && @x2 <= l.x2\n\t\t\treturn true if @x1 < l.x1 && l.x2 < @x2\n\t\telse\n\t\t\treturn true if @y1 <= l.y1 && l.y1 < @y2\n\t\t\treturn true if @y1 < l.y2 && l.y2 <= @y2\n\t\t\treturn true if l.y1 <= @y1 && @y2 <= l.y2\n\t\t\treturn true if @y1 <= l.y1 && l.y2 <= @y2\n\t\tend\n\t\tfalse\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\t@x1, @y1, @x2, @y2 = @x2, @y2, @x1, @y1 if @y1 > @y2\n\t\t@x1, @y1, @x2, @y2 = @x2, @y2, @x1, @y1 if @x1 > @x2\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\ndef f(graph, color)\n\treturn color.values.max if color.size == graph.size\n\ti = color.size\n\tcandidates = (1..color.values.max+1).to_a - graph[i].map{|j| color[j]}\n\tmin = Float::INFINITY\n\tcandidates.each do |c|\n\t\tnew_color = color.dup\n\t\tnew_color[i] = c\n\t\tx = f(graph, new_color)\n\t\tmin = x if x < min\n\tend\n\tmin\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\tterritory = []\n\tcountry = {}\n\tname_to_idx = {}\n\tn.times do\n\t\tname = gets.chomp\n\t\tc = (name_to_idx[name] ||= name_to_idx.size)\n\t\tpos = []\n\t\tloop do\n\t\t\tx, y = gets.split.map(&:to_i)\n\t\t\tbreak if x == -1\n\t\t\tpos << [x, y]\n\t\tend\n\t\tpos << pos[0]\n\t\tlines = pos.each_cons(2).map do |p1, p2|\n\t\t\tLine::through_two_points(*p1, *p2)\n\t\tend\n\t\tcountry[territory.size] = c\n\t\tterritory << lines\n\tend\n\n\tt_edges = []\n\t(0..territory.size-1).to_a.combination(2) do |i, j|\n\t\tt1, t2 = territory[i], territory[j]\n\t\tif t1.product(t2).any?{|l1, l2| l1.overlap?(l2)}\n\t\t\tt_edges << [i, j]\n\t\tend\n\tend\n\t\n\tgraph = {}\n\t(0..name_to_idx.size-1).each {|i| graph[i] = Set.new}\n\tt_edges.each do |i, j|\n\t\tu = country[i]\n\t\tv = country[j]\n\t\tgraph[u] << v\n\t\tgraph[v] << u\n\tend\n\n\tp f(graph, {0 => 1})\nend"
  },
  {
    "language": "Ruby",
    "code": "### constants\n\nINF = 1 << 30\n\n### subroutines\n\ndef vsub(v0, v1)\n  [v0[0] - v1[0], v0[1] - v1[1]]\nend\n\ndef dotp(v0, v1)\n  v0[0] * v1[0] + v0[1] * v1[1]\nend\n\ndef crossp(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef overwrap?(p0, p1, p2, p3)\n  v01 = vsub(p1, p0)\n  v23 = vsub(p3, p2)\n  return false if crossp(v01, v23) != 0\n\n  v02 = vsub(p2, p0)\n  return false if crossp(v01, v02) != 0\n\n  d023 = dotp(vsub(p2, p0), vsub(p3, p0))\n  d123 = dotp(vsub(p2, p1), vsub(p3, p1))\n  d201 = dotp(vsub(p0, p2), vsub(p1, p2))\n  d301 = dotp(vsub(p0, p3), vsub(p1, p3))\n\n  if d023 < 0 || d123 < 0 || d201 < 0 || d301 < 0 ||\n      (d023 == 0 && d123 == 0 && d201 == 0 && d301 == 0)\n    #p [\"adj?\", p0, p1, p2, p3, d023, d123, d201, d301]\n    return true\n  end\n\n  false\nend\n\ndef adj?(ces0, ces1)\n  ces0.each do |ce0|\n    ces1.each do |ce1|\n      return true if overwrap?(*ce0, *ce1)\n    end\n  end\n  false\nend\n\ndef rec(k, nc)\n  if k >= $ncids\n    $minc = nc if $minc > nc\n    return\n  end\n\n  for c in (0..nc)\n    ng = false\n    for u in $nbrs[k]\n      cu = $cols[u]\n      if cu && cu == c\n        ng = true\n        break\n      end\n    end\n    next if ng\n\n    nc0 = (c == nc) ? nc + 1 : nc\n    next if nc0 > $minc\n\n    $cols[k] = c\n    rec(k + 1, nc0)\n    $cols[k] = nil\n  end\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  cids = {}\n  $ncids = 0\n  cedges = []\n\n  n.times do\n    cname = gets.strip\n    if cids[cname].nil?\n      cids[cname] = $ncids\n      cedges[$ncids] = []\n      $ncids += 1\n    end\n\n    pts = []\n    loop do\n      line =gets.strip\n      break if line == '-1'\n      pts << line.split.map(&:to_i)\n    end\n    pts << pts.first\n\n    ces = cedges[cids[cname]]\n    pts.each_cons(2) do |p0, p1|\n      ces << [p0, p1]\n    end\n  end\n  #p cids\n  #p cedges\n\n  $nbrs = $ncids.times.map{[]}\n\n  for i in (0...$ncids)\n    cedgesi = cedges[i]\n    for j in ((i + 1)...$ncids)\n      cedgesj = cedges[j]\n      if adj?(cedgesi, cedgesj)\n        #p [\"adj?\", i, j]\n        #$nbrs[i] << j\n        $nbrs[j] << i\n      end\n    end\n  end\n  #p $nbrs\n\n  $cols = [nil] * $ncids\n  $minc = INF\n\n  rec(0, 0)\n\n  puts $minc\nend"
  },
  {
    "language": "Ruby",
    "code": "### subroutines\n\ndef vsub(v0, v1)\n  [v0[0] - v1[0], v0[1] - v1[1]]\nend\n\ndef dotp(v0, v1)\n  v0[0] * v1[0] + v0[1] * v1[1]\nend\n\ndef crossp(v0, v1)\n  v0[0] * v1[1] - v0[1] * v1[0]\nend\n\ndef overwrap?(p0, p1, p2, p3)\n  v01 = vsub(p1, p0)\n  v23 = vsub(p3, p2)\n  return false if crossp(v01, v23) != 0\n\n  v02 = vsub(p2, p0)\n  return false if crossp(v01, v02) != 0\n\n  d023 = dotp(vsub(p2, p0), vsub(p3, p0))\n  d123 = dotp(vsub(p2, p1), vsub(p3, p1))\n  d201 = dotp(vsub(p0, p2), vsub(p1, p2))\n  d301 = dotp(vsub(p0, p3), vsub(p1, p3))\n\n  if d023 < 0 || d123 < 0 || d201 < 0 || d301 < 0 ||\n      (d023 == 0 && d123 == 0 && d201 == 0 && d301 == 0)\n    #p [\"adj?\", p0, p1, p2, p3, d023, d123, d201, d301]\n    return true\n  end\n\n  false\nend\n\ndef adj?(ces0, ces1)\n  ces0.each do |ce0|\n    ces1.each do |ce1|\n      return true if overwrap?(*ce0, *ce1)\n    end\n  end\n  false\nend\n\ndef rec(k, nc)\n  if k >= $ncids\n    $minc = nc if $minc > nc\n    return\n  end\n\n  for c in (0..nc)\n    ng = false\n    for u in $nbrs[k]\n      cu = $cols[u]\n      if cu && cu == c\n        ng = true\n        break\n      end\n    end\n    next if ng\n\n    nc0 = (c == nc) ? nc + 1 : nc\n    next if nc0 > $minc\n\n    $cols[k] = c\n    rec(k + 1, nc0)\n    $cols[k] = nil\n  end\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  cids = {}\n  $ncids = 0\n  cedges = []\n\n  n.times do\n    cname = gets.strip\n    if cids[cname].nil?\n      cids[cname] = $ncids\n      cedges[$ncids] = []\n      $ncids += 1\n    end\n\n    pts = []\n    loop do\n      line =gets.strip\n      break if line == '-1'\n      pts << line.split.map(&:to_i)\n    end\n    pts << pts.first\n\n    ces = cedges[cids[cname]]\n    pts.each_cons(2) do |p0, p1|\n      ces << [p0, p1]\n    end\n  end\n  #p cids\n  #p cedges\n\n  $nbrs = $ncids.times.map{[]}\n\n  for i in (0...$ncids)\n    cedgesi = cedges[i]\n    for j in ((i + 1)...$ncids)\n      cedgesj = cedges[j]\n      if adj?(cedgesi, cedgesj)\n        #p [\"adj?\", i, j]\n        #$nbrs[i] << j\n        $nbrs[j] << i\n      end\n    end\n  end\n  #p $nbrs\n\n  $cols = [nil] * $ncids\n  $minc = 4\n\n  rec(0, 0)\n\n  puts $minc\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\n\nclass Line\n\t#ax+by = c   (a > 0 or (a == 0 && b > 0))\n\tdef self.through_two_points(x1, y1, x2, y2)\n\t\ta = y1 - y2\n\t\tb = x2 - x1\n\t\tc = a * x1 + b * y1\n\t\tnew(a, b, c, x1, y1, x2, y2)\n\tend\n\n\tdef overlap?(l)\n\t\tif @a == 0\n\t\t\treturn false unless l.a == 0\n\t\t\treturn false unless l.b * @c == @b * l.c\n\t\telse\n\t\t\treturn false unless l.a * @b == @a * l.b && l.a * @c == @a * l.c\n\t\tend\n\t\tif @a == 0\n\t\t\treturn true if @x1 < l.x1 && l.x1 < @x2\n\t\t\treturn true if @x1 < l.x2 && l.x2 < @x2\n\t\t\treturn true if l.x1 <= @x1 && @x2 <= l.x2\n\t\t\treturn true if @x1 < l.x1 && l.x2 < @x2\n\t\telse\n\t\t\treturn true if @y1 < l.y1 && l.y1 < @y2\n\t\t\treturn true if @y1 < l.y2 && l.y2 < @y2\n\t\t\treturn true if l.y1 <= @y1 && @y2 <= l.y2\n\t\t\treturn true if @y1 <= l.y1 && l.y2 <= @y2\n\t\tend\n\t\tfalse\n\tend\n\n\tprivate_class_method :new\n\n\tdef initialize(*args)\n\t\t@a, @b, @c, @x1, @y1, @x2, @y2 = args\t\n\t\t@x1, @y1, @x2, @y2 = @x2, @y2, @x1, @y1 if @y1 > @y2\n\t\t@x1, @y1, @x2, @y2 = @x2, @y2, @x1, @y1 if @x1 > @x2\n\t\tif @a < 0\n\t\t\t@a *= -1\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\telsif @a == 0 && @b < 0\n\t\t\t@b *= -1\n\t\t\t@c *= -1\n\t\tend\n\tend\n\n\tattr_reader :a, :b, :c, :x1, :y1, :x2, :y2\nend\n\ndef f(graph, color)\n\treturn color.values.max if color.size == graph.size\n\ti = color.size\n\tcandidates = (1..color.values.max+1).to_a - graph[i].map{|j| color[j]}\n\tmin = Float::INFINITY\n\tcandidates.each do |c|\n\t\tnew_color = color.dup\n\t\tnew_color[i] = c\n\t\tx = f(graph, new_color)\n\t\tmin = x if x < min\n\tend\n\tmin\nend\n\nloop do\n\tn = gets.to_i\n\tbreak if n == 0\n\tterritory = []\n\tcountry = {}\n\tname_to_idx = {}\n\tn.times do\n\t\tname = gets.chomp\n\t\tc = (name_to_idx[name] ||= name_to_idx.size)\n\t\tpos = []\n\t\tloop do\n\t\t\tx, y = gets.split.map(&:to_i)\n\t\t\tbreak if x == -1\n\t\t\tpos << [x, y]\n\t\tend\n\t\tpos << pos[0]\n\t\tlines = pos.each_cons(2).map do |p1, p2|\n\t\t\tLine::through_two_points(*p1, *p2)\n\t\tend\n\t\tcountry[territory.size] = c\n\t\tterritory << lines\n\tend\n\n\tt_edges = []\n\t(0..territory.size-1).to_a.combination(2) do |i, j|\n\t\tt1, t2 = territory[i], territory[j]\n\t\tif t1.product(t2).any?{|l1, l2| l1.overlap?(l2)}\n\t\t\tt_edges << [i, j]\n\t\tend\n\tend\n\t\n\tgraph = {}\n\t(0..name_to_idx.size-1).each {|i| graph[i] = Set.new}\n\tt_edges.each do |i, j|\n\t\tu = country[i]\n\t\tv = country[j]\n\t\tnext if u == v\n\t\tgraph[u] << v\n\t\tgraph[v] << u\n\tend\n\n\tp f(graph, {0 => 1})\nend"
  },
  {
    "language": "Python",
    "code": "def main():\n    while 1:\n        N = int(input())\n        if N == 0:\n            break\n        D = {}\n        G = [set() for i in range(N)]\n        cur = 0\n        K = []\n        PS = []\n        for i in range(N):\n            ps = []\n            s = input()\n            if s in D:\n                k = D[s]\n            else:\n                D[s] = k = cur\n                cur += 1\n            while 1:\n                d = input()\n                if d == \"-1\":\n                    break\n                ps.append(list(map(int, d.split())))\n\n            for j in range(i):\n                if k == K[j]:\n                    continue\n                qs = PS[j]\n                ok = 0\n                for k1 in range(len(ps)):\n                    x0, y0 = ps[k1-1]\n                    x1, y1 = ps[k1]\n                    dx = x1 - x0; dy = y1 - y0\n                    for k2 in range(len(qs)):\n                        X0, Y0 = qs[k2-1]\n                        X1, Y1 = qs[k2]\n                        if (X0 - x0)*dy == (Y0 - y0)*dx and (X1 - x0)*dy == (Y1 - y0)*dx:\n                            if dx != 0:\n                                s0 = (X0 - x0); s1 = (X1 - x0)\n                                t = dx\n                            else:\n                                s0 = (Y0 - y0); s1 = (Y1 - y0)\n                                t = dy\n                            if t < 0:\n                                s0 = -s0; s1 = -s1\n                                t = -t\n                            if not s0 < s1:\n                                s0, s1 = s1, s0\n                            if s0 < t and 0 < s1:\n                                break\n                    else:\n                        continue\n                    break\n                else:\n                    continue\n                l = K[j]\n                if k < l:\n                    G[l].add(k)\n                else:\n                    G[k].add(l)\n            K.append(k)\n            PS.append(ps)\n        def dfs(i, cs, ma):\n            if i == cur:\n                return max(cs)+1\n            U = 0\n            for j in G[i]:\n                U |= 1 << cs[j]\n            r = cur\n            for k in range(ma+1):\n                if U & 1 == 0:\n                    cs[i] = k\n                    r = min(r, dfs(i+1, cs, ma))\n                U >>= 1\n            cs[i] = ma+1\n            r = min(r, dfs(i+1, cs, ma+1))\n            return r\n        print(dfs(0, [0]*cur, 0))\nmain()\n\n"
  }
]