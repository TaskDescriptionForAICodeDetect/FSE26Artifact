[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_TOWNS 100\n#define MAX_PORTS 100\n\ntypedef struct {\n    int is_port;\n    int land_dist[MAX_TOWNS];\n    int sea_dist[MAX_PORTS];\n} Town;\n\nTown towns[MAX_TOWNS];\nint port_indices[MAX_PORTS];\nint num_towns, num_ports;\n\nvoid initialize() {\n    for (int i = 0; i < MAX_TOWNS; i++) {\n        towns[i].is_port = 0;\n        for (int j = 0; j < MAX_TOWNS; j++) {\n            towns[i].land_dist[j] = INT_MAX;\n        }\n        for (int j = 0; j < MAX_PORTS; j++) {\n            towns[i].sea_dist[j] = INT_MAX;\n        }\n    }\n}\n\nvoid floyd_warshall_land() {\n    for (int k = 0; k < num_towns; k++) {\n        for (int i = 0; i < num_towns; i++) {\n            for (int j = 0; j < num_towns; j++) {\n                if (towns[i].land_dist[k] != INT_MAX && towns[k].land_dist[j] != INT_MAX &&\n                    towns[i].land_dist[j] > towns[i].land_dist[k] + towns[k].land_dist[j]) {\n                    towns[i].land_dist[j] = towns[i].land_dist[k] + towns[k].land_dist[j];\n                }\n            }\n        }\n    }\n}\n\nvoid floyd_warshall_sea() {\n    for (int k = 0; k < num_ports; k++) {\n        for (int i = 0; i < num_ports; i++) {\n            for (int j = 0; j < num_ports; j++) {\n                if (towns[port_indices[i]].sea_dist[k] != INT_MAX && towns[port_indices[k]].sea_dist[j] != INT_MAX &&\n                    towns[port_indices[i]].sea_dist[j] > towns[port_indices[i]].sea_dist[k] + towns[port_indices[k]].sea_dist[j]) {\n                    towns[port_indices[i]].sea_dist[j] = towns[port_indices[i]].sea_dist[k] + towns[port_indices[k]].sea_dist[j];\n                }\n            }\n        }\n    }\n}\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint find_port_index(int town) {\n    for (int i = 0; i < num_ports; i++) {\n        if (port_indices[i] == town) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nint main() {\n    initialize();\n    int m, q;\n    scanf(\"%d %d %d\", &num_towns, &m, &num_ports);\n\n    for (int i = 0; i < num_ports; i++) {\n        scanf(\"%d\", &port_indices[i]);\n        towns[port_indices[i]].is_port = 1;\n    }\n\n    for (int i = 0; i < m; i++) {\n        int u, v, d;\n        char t[2];\n        scanf(\"%d %d %d %s\", &u, &v, &d, t);\n        if (t[0] == 'L') {\n            towns[u].land_dist[v] = d;\n            towns[v].land_dist[u] = d;\n        } else if (t[0] == 'S') {\n            int u_port = find_port_index(u);\n            int v_port = find_port_index(v);\n            if (u_port != -1 && v_port != -1) {\n                towns[u].sea_dist[v_port] = d;\n                towns[v].sea_dist[u_port] = d;\n            }\n        }\n    }\n\n    for (int i = 0; i < num_towns; i++) {\n        towns[i].land_dist[i] = 0;\n    }\n    for (int i = 0; i < num_ports; i++) {\n        towns[port_indices[i]].sea_dist[i] = 0;\n    }\n\n    floyd_warshall_land();\n    floyd_warshall_sea();\n\n    scanf(\"%d\", &q);\n    int sequence[q];\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &sequence[i]);\n    }\n\n    int dp[q][MAX_PORTS];\n    for (int i = 0; i < q; i++) {\n        for (int j = 0; j < num_ports; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n\n    int first_town = sequence[0];\n    if (towns[first_town].is_port) {\n        int port_idx = find_port_index(first_town);\n        dp[0][port_idx] = 0;\n    } else {\n        for (int j = 0; j < num_ports; j++) {\n            int port_town = port_indices[j];\n            if (towns[first_town].land_dist[port_town] != INT_MAX) {\n                dp[0][j] = towns[first_town].land_dist[port_town];\n            }\n        }\n    }\n\n    for (int i = 1; i < q; i++) {\n        int current_town = sequence[i];\n        int prev_town = sequence[i-1];\n        for (int j = 0; j < num_ports; j++) {\n            if (dp[i-1][j] == INT_MAX) continue;\n            int prev_port = port_indices[j];\n            if (current_town == prev_town) {\n                dp[i][j] = min(dp[i][j], dp[i-1][j]);\n                continue;\n            }\n            if (towns[current_town].is_port) {\n                int current_port = find_port_index(current_town);\n                if (towns[prev_port].sea_dist[current_port] != INT_MAX) {\n                    dp[i][current_port] = min(dp[i][current_port], dp[i-1][j] + towns[prev_port].sea_dist[current_port]);\n                }\n            }\n            if (towns[current_town].land_dist[prev_town] != INT_MAX) {\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + towns[current_town].land_dist[prev_town]);\n            }\n            for (int k = 0; k < num_ports; k++) {\n                int next_port = port_indices[k];\n                if (towns[prev_port].sea_dist[k] != INT_MAX && towns[next_port].land_dist[current_town] != INT_MAX) {\n                    dp[i][k] = min(dp[i][k], dp[i-1][j] + towns[prev_port].sea_dist[k] + towns[next_port].land_dist[current_town]);\n                }\n            }\n        }\n    }\n\n    int result = INT_MAX;\n    for (int j = 0; j < num_ports; j++) {\n        if (dp[q-1][j] < result) {\n            result = dp[q-1][j];\n        }\n    }\n    printf(\"%d\\n\", result == INT_MAX ? -1 : result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Town {\n    int id;\n    bool isPort;\n    vector<pair<int, int>> landRoutes; // to, time\n    vector<pair<int, int>> seaRoutes;  // to, time\n};\n\nint main() {\n    int N, M, P, Q;\n    cin >> N >> M >> P >> Q;\n\n    vector<Town> towns(N + 1); // 1-based indexing\n    for (int i = 1; i <= N; ++i) {\n        towns[i].id = i;\n        char type;\n        cin >> type;\n        towns[i].isPort = (type == 'P');\n    }\n\n    for (int i = 0; i < M; ++i) {\n        int u, v, t;\n        char type;\n        cin >> u >> v >> t >> type;\n        if (type == 'L') {\n            towns[u].landRoutes.emplace_back(v, t);\n            towns[v].landRoutes.emplace_back(u, t);\n        } else {\n            towns[u].seaRoutes.emplace_back(v, t);\n            towns[v].seaRoutes.emplace_back(u, t);\n        }\n    }\n\n    vector<int> sequence(Q);\n    for (int i = 0; i < Q; ++i) {\n        cin >> sequence[i];\n    }\n\n    // Precompute shortest land distances between all pairs of towns on the same island\n    vector<vector<int>> landDist(N + 1, vector<int>(N + 1, INT_MAX));\n    for (int u = 1; u <= N; ++u) {\n        landDist[u][u] = 0;\n        for (const auto& route : towns[u].landRoutes) {\n            int v = route.first;\n            int t = route.second;\n            landDist[u][v] = min(landDist[u][v], t);\n        }\n    }\n\n    // Floyd-Warshall for land routes\n    for (int k = 1; k <= N; ++k) {\n        for (int i = 1; i <= N; ++i) {\n            for (int j = 1; j <= N; ++j) {\n                if (landDist[i][k] != INT_MAX && landDist[k][j] != INT_MAX) {\n                    landDist[i][j] = min(landDist[i][j], landDist[i][k] + landDist[k][j]);\n                }\n            }\n        }\n    }\n\n    // Precompute shortest sea distances between all pairs of ports\n    vector<vector<int>> seaDist(N + 1, vector<int>(N + 1, INT_MAX));\n    for (int u = 1; u <= N; ++u) {\n        if (!towns[u].isPort) continue;\n        seaDist[u][u] = 0;\n        for (const auto& route : towns[u].seaRoutes) {\n            int v = route.first;\n            int t = route.second;\n            if (towns[v].isPort) {\n                seaDist[u][v] = min(seaDist[u][v], t);\n            }\n        }\n    }\n\n    // Floyd-Warshall for sea routes\n    for (int k = 1; k <= N; ++k) {\n        if (!towns[k].isPort) continue;\n        for (int i = 1; i <= N; ++i) {\n            if (!towns[i].isPort) continue;\n            for (int j = 1; j <= N; ++j) {\n                if (!towns[j].isPort) continue;\n                if (seaDist[i][k] != INT_MAX && seaDist[k][j] != INT_MAX) {\n                    seaDist[i][j] = min(seaDist[i][j], seaDist[i][k] + seaDist[k][j]);\n                }\n            }\n        }\n    }\n\n    // DP[i][p] = min time to reach sequence[i] with last port p\n    vector<vector<int>> dp(Q, vector<int>(N + 1, INT_MAX));\n    int firstTown = sequence[0];\n    if (towns[firstTown].isPort) {\n        dp[0][firstTown] = 0;\n    } else {\n        for (int p = 1; p <= N; ++p) {\n            if (!towns[p].isPort) continue;\n            if (landDist[p][firstTown] != INT_MAX) {\n                dp[0][p] = landDist[p][firstTown];\n            }\n        }\n    }\n\n    for (int i = 1; i < Q; ++i) {\n        int current = sequence[i];\n        int prev = sequence[i - 1];\n        for (int p = 1; p <= N; ++p) {\n            if (!towns[p].isPort) continue;\n            if (dp[i - 1][p] == INT_MAX) continue;\n\n            // Option 1: Stay on land\n            if (landDist[prev][current] != INT_MAX) {\n                if (dp[i][p] > dp[i - 1][p] + landDist[prev][current]) {\n                    dp[i][p] = dp[i - 1][p] + landDist[prev][current];\n                }\n            }\n\n            // Option 2: Use sea routes\n            for (int q = 1; q <= N; ++q) {\n                if (!towns[q].isPort) continue;\n                if (landDist[prev][p] == INT_MAX) continue;\n                if (seaDist[p][q] == INT_MAX) continue;\n                if (landDist[q][current] == INT_MAX) continue;\n\n                int total = dp[i - 1][p] - landDist[p][prev] + landDist[p][prev] + seaDist[p][q] + landDist[q][current];\n                if (dp[i][q] > total) {\n                    dp[i][q] = total;\n                }\n            }\n        }\n    }\n\n    int result = INT_MAX;\n    for (int p = 1; p <= N; ++p) {\n        if (towns[p].isPort) {\n            result = min(result, dp[Q - 1][p]);\n        }\n    }\n\n    if (result == INT_MAX) {\n        cout << \"impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Town {\n    int id;\n    boolean isPort;\n    List<Edge> edges;\n\n    Town(int id, boolean isPort) {\n        this.id = id;\n        this.isPort = isPort;\n        this.edges = new ArrayList<>();\n    }\n}\n\nclass Edge {\n    Town destination;\n    int time;\n    boolean isSeaRoute;\n\n    Edge(Town destination, int time, boolean isSeaRoute) {\n        this.destination = destination;\n        this.time = time;\n        this.isSeaRoute = isSeaRoute;\n    }\n}\n\npublic class PostOfficeRoute {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int P = scanner.nextInt();\n\n        Town[] towns = new Town[N + 1];\n        for (int i = 1; i <= N; i++) {\n            boolean isPort = scanner.nextInt() == 1;\n            towns[i] = new Town(i, isPort);\n        }\n\n        for (int i = 0; i < M; i++) {\n            int U = scanner.nextInt();\n            int V = scanner.nextInt();\n            int T = scanner.nextInt();\n            int S = scanner.nextInt();\n            boolean isSeaRoute = S == 1;\n            towns[U].edges.add(new Edge(towns[V], T, isSeaRoute));\n            towns[V].edges.add(new Edge(towns[U], T, isSeaRoute));\n        }\n\n        int[] sequence = new int[P];\n        for (int i = 0; i < P; i++) {\n            sequence[i] = scanner.nextInt();\n        }\n\n        int totalTime = 0;\n        Town currentTown = towns[sequence[0]];\n        Town lastPort = currentTown.isPort ? currentTown : null;\n\n        for (int i = 1; i < P; i++) {\n            Town nextTown = towns[sequence[i]];\n            int[] dist = new int[N + 1];\n            Arrays.fill(dist, Integer.MAX_VALUE);\n            dist[currentTown.id] = 0;\n\n            PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n            pq.add(new int[]{currentTown.id, 0});\n\n            while (!pq.isEmpty()) {\n                int[] current = pq.poll();\n                int townId = current[0];\n                int time = current[1];\n\n                if (townId == nextTown.id) {\n                    totalTime += time;\n                    break;\n                }\n\n                if (time > dist[townId]) continue;\n\n                for (Edge edge : towns[townId].edges) {\n                    int newTime = time + edge.time;\n                    if (edge.isSeaRoute) {\n                        if (lastPort != null && newTime < dist[edge.destination.id]) {\n                            dist[edge.destination.id] = newTime;\n                            pq.add(new int[]{edge.destination.id, newTime});\n                        }\n                    } else {\n                        if (newTime < dist[edge.destination.id]) {\n                            dist[edge.destination.id] = newTime;\n                            pq.add(new int[]{edge.destination.id, newTime});\n                        }\n                    }\n                }\n            }\n\n            currentTown = nextTown;\n            if (currentTown.isPort) {\n                lastPort = currentTown;\n            }\n        }\n\n        System.out.println(totalTime);\n    }\n}",
    "timestamp": "2025-08-05 21:16:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass PostOfficeRouter {\n    private static final int INF = Integer.MAX_VALUE;\n\n    static class Location {\n        String name;\n        int island;\n        boolean isPort;\n\n        Location(String name, int island, boolean isPort) {\n            this.name = name;\n            this.island = island;\n            this.isPort = isPort;\n        }\n    }\n\n    static class Route {\n        int from;\n        int to;\n        int time;\n\n        Route(int from, int to, int time) {\n            this.from = from;\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    public static int calculateShortestRoute(List<Location> locations, Map<String, List<Route>> routes) {\n        int totalTime = 0;\n        Location currentLocation = locations.get(0);\n\n        for (int i = 1; i < locations.size(); i++) {\n            Location nextLocation = locations.get(i);\n            int minTime = findShortestPath(currentLocation, nextLocation, routes);\n\n            if (minTime == INF) {\n                return -1;  // Impossible route\n            }\n\n            totalTime += minTime;\n            currentLocation = nextLocation;\n        }\n\n        return totalTime;\n    }\n\n    private static int findShortestPath(Location start, Location end, Map<String, List<Route>> routes) {\n        if (start.island == end.island) {\n            return findLandRoute(start, end, routes);\n        } else {\n            return findSeaRoute(start, end, routes);\n        }\n    }\n\n    private static int findLandRoute(Location start, Location end, Map<String, List<Route>> routes) {\n        Queue<String> queue = new LinkedList<>();\n        Map<String, Integer> distances = new HashMap<>();\n        queue.offer(start.name);\n        distances.put(start.name, 0);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            if (current.equals(end.name)) {\n                return distances.get(current);\n            }\n\n            for (Route route : routes.getOrDefault(current, new ArrayList<>())) {\n                if (route.to == end.island) {\n                    String nextLocation = route.name;\n                    int newDistance = distances.get(current) + route.time;\n                    if (!distances.containsKey(nextLocation) || newDistance < distances.get(nextLocation)) {\n                        distances.put(nextLocation, newDistance);\n                        queue.offer(nextLocation);\n                    }\n                }\n            }\n        }\n\n        return INF;\n    }\n\n    private static int findSeaRoute(Location start, Location end, Map<String, List<Route>> routes) {\n        // Sea route implementation with additional port town requirement\n        // Similar to land route but considering sea travel restrictions\n        // This is a simplified placeholder\n        return INF;\n    }\n\n    public static void main(String[] args) {\n        // Example usage and testing\n        List<Location> locations = Arrays.asList(\n            new Location(\"Town1\", 1, true),\n            new Location(\"Town2\", 2, true),\n            new Location(\"Village3\", 2, false)\n        );\n\n        Map<String, List<Route>> routes = new HashMap<>();\n        // Populate routes map with actual routes between locations\n    }\n}",
    "timestamp": "2025-08-05 21:16:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define MAX_TOWNS 100\n#define MAX_ISLANDS 10\n\ntypedef struct {\n    int x, y;\n    int island;\n} Location;\n\ntypedef struct {\n    int travel_time[MAX_TOWNS][MAX_TOWNS];\n    bool is_port[MAX_TOWNS];\n} TransportNetwork;\n\nint calculate_shortest_route(Location* route, int route_length, TransportNetwork* network) {\n    int total_time = 0;\n    int current_port = -1;\n\n    for (int i = 0; i < route_length - 1; i++) {\n        Location start = route[i];\n        Location end = route[i + 1];\n        int land_time = network->travel_time[start.x][end.x];\n        int sea_time = INT_MAX;\n\n        // Check sea route requirements\n        if (start.island != end.island) {\n            // Find nearest port for sea travel\n            for (int j = 0; j < MAX_TOWNS; j++) {\n                if (network->is_port[j] && route[j].island == start.island) {\n                    for (int k = 0; k < MAX_TOWNS; k++) {\n                        if (network->is_port[k] && route[k].island == end.island) {\n                            int potential_time = network->travel_time[start.x][j] + \n                                                 network->travel_time[j][k] + \n                                                 network->travel_time[k][end.x];\n                            sea_time = (potential_time < sea_time) ? potential_time : sea_time;\n                        }\n                    }\n                }\n            }\n        }\n\n        total_time += (land_time < sea_time) ? land_time : sea_time;\n    }\n\n    return total_time;\n}\n\nint main() {\n    TransportNetwork network = {0};\n    Location route[MAX_TOWNS];\n    int route_length;\n\n    // Input network details and route would be added here\n    \n    int shortest_route_time = calculate_shortest_route(route, route_length, &network);\n    printf(\"Shortest route time: %d\\n\", shortest_route_time);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Location {\n    int x, y;\n    bool isPort;\n    int island;\n};\n\nint calculateDistance(const Location& a, const Location& b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nint findShortestRoute(vector<Location>& locations) {\n    int totalTime = 0;\n    int n = locations.size();\n    \n    for (int i = 0; i < n - 1; ++i) {\n        Location& current = locations[i];\n        Location& next = locations[i + 1];\n        \n        if (current.island == next.island) {\n            // Land route within same island\n            totalTime += calculateDistance(current, next);\n        } else {\n            // Sea route between islands\n            bool foundPort = false;\n            for (int j = 0; j < n; ++j) {\n                if (locations[j].island == current.island && locations[j].isPort) {\n                    // Return to port before sea travel\n                    totalTime += calculateDistance(current, locations[j]);\n                    totalTime += calculateDistance(locations[j], next);\n                    foundPort = true;\n                    break;\n                }\n            }\n            \n            if (!foundPort) {\n                return -1; // No valid route\n            }\n        }\n    }\n    \n    return totalTime;\n}\n\nint main() {\n    int numLocations;\n    cin >> numLocations;\n    \n    vector<Location> locations(numLocations);\n    \n    for (int i = 0; i < numLocations; ++i) {\n        cin >> locations[i].x >> locations[i].y >> locations[i].isPort >> locations[i].island;\n    }\n    \n    int shortestTime = findShortestRoute(locations);\n    \n    if (shortestTime == -1) {\n        cout << \"No valid route\" << endl;\n    } else {\n        cout << shortestTime << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:16:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\nclass Graph:\n    def __init__(self):\n        self.adjacency_list = {}\n        self.travel_time = {}\n\n    def add_edge(self, src, dest, time, is_sea_route=False):\n        if src not in self.adjacency_list:\n            self.adjacency_list[src] = []\n        if dest not in self.adjacency_list:\n            self.adjacency_list[dest] = []\n        self.adjacency_list[src].append((dest, time, is_sea_route))\n\ndef dijkstra(graph, start_node, end_node):\n    heap = [(0, start_node)]\n    visited = set()\n    min_times = {start_node: 0}\n    \n    while heap:\n        curr_time, node = heapq.heappop(heap)\n        if node in visited:\n            continue\n        visited.add(node)\n\n        if node == end_node:\n            return curr_time\n\n        for neighbor, travel_time, is_sea_route in graph.adjacency_list.get(node, []):\n            if is_sea_route and 'port' not in node:\n                continue\n            next_time = curr_time + travel_time\n            if (neighbor not in min_times or next_time < min_times[neighbor]):\n                min_times[neighbor] = next_time\n                heapq.heappush(heap, (next_time, neighbor))\n    \n    return float('inf')\n\ndef shortest_travel_time(towns, routes, travel_order):\n    graph = Graph()\n    for src, dest, time, is_sea_route in routes:\n        graph.add_edge(src, dest, time, is_sea_route)\n        graph.add_edge(dest, src, time, is_sea_route)\n\n    total_time = 0\n    for i in range(len(travel_order) - 1):\n        start = travel_order[i]\n        end = travel_order[i + 1]\n        time = dijkstra(graph, start, end)\n        if time == float('inf'):\n            return -1\n        total_time += time\n    \n    return total_time\n\ntowns = [\"A\", \"B\", \"C_port\", \"D_port\", \"E\"]\nroutes = [\n    (\"A\", \"B\", 5, False),\n    (\"B\", \"C_port\", 10, False),\n    (\"C_port\", \"D_port\", 20, True),\n    (\"D_port\", \"E\", 5, False),\n    (\"B\", \"D_port\", 50, False),\n    (\"A\", \"C_port\", 15, False)\n]\ntravel_order = [\"A\", \"C_port\", \"E\"]\nprint(shortest_travel_time(towns, routes, travel_order))",
    "timestamp": "2025-08-13 05:36:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\nclass PostOffice {\n\n    static class Edge {\n        int destination, time;\n        boolean isSeaRoute;\n\n        Edge(int destination, int time, boolean isSeaRoute) {\n            this.destination = destination;\n            this.time = time;\n            this.isSeaRoute = isSeaRoute;\n        }\n    }\n\n    public static int shortestTime(int n, int[][] landRoutes, int[][] seaRoutes, int[] sequence) {\n        Map<Integer, List<Edge>> graph = new HashMap<>();\n        \n        // Building land routes graph\n        for (int[] route : landRoutes) {\n            graph.computeIfAbsent(route[0], k -> new ArrayList<>()).add(new Edge(route[1], route[2], false));\n            graph.computeIfAbsent(route[1], k -> new ArrayList<>()).add(new Edge(route[0], route[2], false));\n        }\n\n        // Building sea routes graph\n        for (int[] route : seaRoutes) {\n            graph.computeIfAbsent(route[0], k -> new ArrayList<>()).add(new Edge(route[1], route[2], true));\n            graph.computeIfAbsent(route[1], k -> new ArrayList<>()).add(new Edge(route[0], route[2], true));\n        }\n        \n        int totalTime = 0;\n        for (int i = 0; i < sequence.length - 1; i++) {\n            int current = sequence[i];\n            int next = sequence[i + 1];\n            totalTime += findShortestPath(graph, current, next);\n        }\n        \n        return totalTime;\n    }\n\n    private static int findShortestPath(Map<Integer, List<Edge>> graph, int start, int end) {\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        Map<Integer, Integer> minTime = new HashMap<>();\n        pq.offer(new int[]{start, 0});\n        minTime.put(start, 0);\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int node = current[0];\n            int time = current[1];\n\n            if (node == end) {\n                return time;\n            }\n\n            if (time > minTime.getOrDefault(node, Integer.MAX_VALUE)) {\n                continue;\n            }\n\n            for (Edge edge : graph.getOrDefault(node, Collections.emptyList())) {\n                int newTime = time + edge.time;\n                if (newTime < minTime.getOrDefault(edge.destination, Integer.MAX_VALUE)) {\n                    minTime.put(edge.destination, newTime);\n                    pq.offer(new int[]{edge.destination, newTime});\n                }\n            }\n        }\n\n        return Integer.MAX_VALUE; // Return this if there's no path, which shouldn't happen in the problem constraints\n    }\n\n    public static void main(String[] args) {\n        int n = 6;\n        int[][] landRoutes = {\n            {1, 2, 5},\n            {2, 3, 10},\n            {3, 4, 2},\n            {4, 5, 2}\n        };\n\n        int[][] seaRoutes = {\n            {1, 3, 20},\n            {3, 5, 15}\n        };\n\n        int[] sequence = {1, 3, 5};\n\n        int result = shortestTime(n, landRoutes, seaRoutes, sequence);\n        System.out.println(\"The shortest traveling time is: \" + result);\n    }\n}",
    "timestamp": "2025-08-13 05:36:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_TOWNS 100\n#define MAX(a, b) ((a) > (b) ? (a) : (b))\n#define MIN(a, b) ((a) < (b) ? (a) : (b))\n\nint travelTime[MAX_TOWNS][MAX_TOWNS];\nint seaRouteTime[MAX_TOWNS][MAX_TOWNS];\nint n;  // number of towns\nint m;  // number of locations in the sequence\n\nint calculateShortestRoute(int locations[]) {\n    int dp[MAX_TOWNS][MAX_TOWNS];\n    for (int i = 0; i < MAX_TOWNS; i++) {\n        for (int j = 0; j < MAX_TOWNS; j++) {\n            dp[i][j] = INT_MAX;\n        }\n    }\n    dp[0][0] = 0;\n\n    for (int i = 0; i < m - 1; i++) {\n        int currentTown = locations[i];\n        int nextTown = locations[i + 1];\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j] < INT_MAX) {\n                dp[i + 1][j] = MIN(dp[i + 1][j], dp[i][j] + travelTime[currentTown][nextTown]);\n                if (j != currentTown) {\n                    dp[i + 1][currentTown] = MIN(dp[i + 1][currentTown], dp[i][j] + seaRouteTime[j][currentTown] + seaRouteTime[currentTown][nextTown]);\n                }\n            }\n        }\n    }\n    \n    int shortestTime = INT_MAX;\n    int lastTown = locations[m - 1];\n    for (int j = 0; j < n; j++) {\n        shortestTime = MIN(shortestTime, dp[m - 1][j]);\n    }\n    return shortestTime;\n}\n\nint main() {\n    printf(\"Enter number of towns: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter travel times between each pair of towns:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &travelTime[i][j]);\n        }\n    }\n    printf(\"Enter sea route times between each pair of port towns:\\n\");\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &seaRouteTime[i][j]);\n        }\n    }\n    printf(\"Enter number of towns in the sequence: \");\n    scanf(\"%d\", &m);\n    int locations[m];\n    printf(\"Enter the sequence of towns: \");\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d\", &locations[i]);\n    }\n    \n    int result = calculateShortestRoute(locations);\n    printf(\"Shortest travel time: %d\\n\", result);\n    return 0;\n}",
    "timestamp": "2025-08-13 05:36:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\nimport heapq\n\nclass PostOfficeRouter:\n    def __init__(self, islands: List[List[Tuple[str, int]]]):\n        self.islands = islands\n        self.memo = {}\n\n    def calculate_shortest_route(self, locations: List[str]) -> int:\n        def dijkstra(start: str, end: str, island_index: int) -> int:\n            island = self.islands[island_index]\n            distances = {town: float('inf') for town, _ in island}\n            distances[start] = 0\n            pq = [(0, start)]\n\n            while pq:\n                current_dist, current_town = heapq.heappop(pq)\n                \n                if current_town == end:\n                    return current_dist\n\n                if current_dist > distances[current_town]:\n                    continue\n\n                for town, time in island:\n                    if town == current_town:\n                        continue\n                    distance = current_dist + time\n                    if distance < distances[town]:\n                        distances[town] = distance\n                        heapq.heappush(pq, (distance, town))\n\n            return float('inf')\n\n        def find_island_index(town: str) -> int:\n            for i, island in enumerate(self.islands):\n                if any(town == t for t, _ in island):\n                    return i\n            return -1\n\n        total_time = 0\n        current_port = None\n\n        for i in range(len(locations) - 1):\n            start, end = locations[i], locations[i+1]\n            start_island = find_island_index(start)\n            end_island = find_island_index(end)\n\n            if start_island == end_island:\n                route_key = (start, end, start_island)\n                if route_key not in self.memo:\n                    self.memo[route_key] = dijkstra(start, end, start_island)\n                total_time += self.memo[route_key]\n            else:\n                if current_port is None:\n                    current_port = start if start.endswith('Port') else end\n\n                port_route_key = (start, current_port, start_island)\n                sea_route_key = (current_port, end, end_island)\n\n                if port_route_key not in self.memo:\n                    self.memo[port_route_key] = dijkstra(start, current_port, start_island)\n                if sea_route_key not in self.memo:\n                    self.memo[sea_route_key] = dijkstra(current_port, end, end_island)\n\n                total_time += self.memo[port_route_key] + self.memo[sea_route_key]\n                current_port = end if end.endswith('Port') else start\n\n        return total_time",
    "timestamp": "2025-08-13 05:37:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    K = int(data[idx])\n    idx += 1\n    \n    # Read islands: 1-based indexing\n    island_of = [0] * (N + 1)\n    for i in range(1, N + 1):\n        island_of[i] = int(data[idx])\n        idx += 1\n    \n    # Read ports: 1-based indexing\n    ports = [False] * (N + 1)\n    for _ in range(K):\n        town = int(data[idx])\n        ports[town] = True\n        idx += 1\n    \n    # Build adjacency list for land routes (undirected)\n    adj_land = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        u = int(data[idx])\n        v = int(data[idx + 1])\n        t = int(data[idx + 2])\n        adj_land[u].append((v, t))\n        adj_land[v].append((u, t))\n        idx += 3\n    \n    # Dijkstra's algorithm for land routes within an island\n    def dijkstra(start, island):\n        dist = [float('inf')] * (N + 1)\n        dist[start] = 0\n        heap = [(0, start)]\n        while heap:\n            current_dist, u = heapq.heappop(heap)\n            if current_dist > dist[u]:\n                continue\n            for v, t in adj_land[u]:\n                if island_of[v] == island and dist[v] > dist[u] + t:\n                    dist[v] = dist[u] + t\n                    heapq.heappush(heap, (dist[v], v))\n        return dist\n    \n    # Read sequence of towns to visit\n    S = int(data[idx])\n    idx += 1\n    sequence = []\n    for _ in range(S):\n        town = int(data[idx])\n        sequence.append(town)\n        idx += 1\n    \n    total_time = 0\n    current_pos = sequence[0]\n    last_port = current_pos if ports[current_pos] else None\n    \n    # Precompute distances from each port to all towns on the same island\n    port_distances = {}\n    for town in range(1, N + 1):\n        if ports[town]:\n            port_distances[town] = dijkstra(town, island_of[town])\n    \n    for i in range(1, S):\n        next_pos = sequence[i]\n        current_island = island_of[current_pos]\n        next_island = island_of[next_pos]\n        \n        if current_island == next_island:\n            # Land route\n            dist = dijkstra(current_pos, current_island)\n            total_time += dist[next_pos]\n            current_pos = next_pos\n            if ports[current_pos]:\n                last_port = current_pos\n        else:\n            # Sea route: must go to last_port, then to next_port\n            if not ports[current_pos]:\n                if last_port is None:\n                    # No previous port, impossible\n                    print(-1)\n                    return\n                dist = dijkstra(current_pos, current_island)\n                total_time += dist[last_port]\n                current_pos = last_port\n            \n            # Now current_pos is a port\n            # Find the nearest port in next_island to next_pos\n            min_time = float('inf')\n            best_port = None\n            for town in range(1, N + 1):\n                if ports[town] and island_of[town] == next_island:\n                    # Distance from town to next_pos on next_island\n                    if town not in port_distances:\n                        port_distances[town] = dijkstra(town, next_island)\n                    dist_to_next_pos = port_distances[town][next_pos]\n                    total_candidate = 1 + dist_to_next_pos  # 1 is the sea travel time\n                    if total_candidate < min_time:\n                        min_time = total_candidate\n                        best_port = town\n            \n            if min_time == float('inf'):\n                print(-1)\n                return\n            \n            total_time += min_time\n            current_pos = next_pos\n            last_port = best_port if ports[next_pos] else best_port\n    \n    print(total_time)\n\nsolve()",
    "timestamp": "2025-08-13 05:37:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nconst int INF = numeric_limits<int>::max();\n\nstruct Town {\n    int island;\n    bool isPort;\n};\n\nvector<vector<int>> landTimes;  // land travel times\nvector<vector<int>> seaTimes;   // sea travel times\nvector<Town> towns;             // town information\n\nint findShortestTime(vector<int>& sequence) {\n    int n = sequence.size();\n    vector<vector<int>> dp(n, vector<int>(n, INF));\n\n    // Base case: starting at the first town\n    dp[0][sequence[0]] = 0;\n\n    for (int i = 1; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (dp[i - 1][j] == INF) continue;\n            \n            int currentTown = sequence[i];\n            \n            // Using land route\n            dp[i][currentTown] = min(dp[i][currentTown], dp[i - 1][j] + landTimes[j][currentTown]);\n\n            // Using sea route if current town is a port\n            if (towns[currentTown].isPort && towns[j].isPort && towns[currentTown].island != towns[j].island) {\n                dp[i][currentTown] = min(dp[i][currentTown], dp[i - 1][j] + seaTimes[j][currentTown]);\n            }\n        }\n    }\n\n    int minTime = INF;\n    for (int j = 0; j < n; ++j) {\n        minTime = min(minTime, dp[n - 1][j]);\n    }\n\n    return minTime;\n}\n\nint main() {\n    int numTowns, numIslands;\n    cin >> numTowns >> numIslands;\n\n    towns.resize(numTowns);\n    landTimes.resize(numTowns, vector<int>(numTowns));\n    seaTimes.resize(numTowns, vector<int>(numTowns));\n\n    for (int i = 0; i < numTowns; ++i) {\n        int island, isPort;\n        cin >> island >> isPort;\n        towns[i] = {island, isPort};\n    }\n\n    for (int i = 0; i < numTowns; ++i) {\n        for (int j = 0; j < numTowns; ++j) {\n            cin >> landTimes[i][j];\n        }\n    }\n\n    for (int i = 0; i < numTowns; ++i) {\n        for (int j = 0; j < numTowns; ++j) {\n            cin >> seaTimes[i][j];\n        }\n    }\n\n    int sequenceLength;\n    cin >> sequenceLength;\n    vector<int> sequence(sequenceLength);\n    for (int i = 0; i < sequenceLength; ++i) {\n        cin >> sequence[i];\n    }\n\n    cout << findShortestTime(sequence) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:11"
  }
]