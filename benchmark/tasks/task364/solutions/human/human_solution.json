[
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nLL dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\twhile (cin >> n >> m&&(n&&m)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tREP(i, 201)REP(j, r)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tLL ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 205\n#define maxr 1005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nint fl[maxn][maxn],fs[maxn][maxn],dp[maxr][maxn],n,m,r,a[maxn];\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m) && (n+m)>0){\n\t\tmemset(fl,0x3f,sizeof(fl));\n\t\tmemset(fs,0x3f,sizeof(fs));\n\t\tfor(int i=1;i<=n;i++) fs[i][i] = fl[i][i] = 0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u,v,w;\n\t\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t\tchar c;\n\t\t\twhile(scanf(\"%c\",&c) && (c!='S'&&c!='L'));\n\t\t\tif(c == 'S') fs[u][v] = fs[v][u] = min(fs[u][v],w);\n\t\t\telse fl[u][v] = fl[v][u] = min(fl[u][v],w);\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=1;i<=r;i++) scanf(\"%d\",&a[i]);\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tfl[i][j] = min(fl[i][j],fl[i][k] + fl[k][j]);\n\t\t\t\t\tfs[i][j] = min(fs[i][j],fs[i][k] + fs[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0x3f,sizeof(dp));\n//\t\ta[0] = 1;\n\t\tfor(int i=1;i<=n;i++) dp[1][i] = fs[a[1]][i] + fl[i][a[1]];\n\t\tfor(int i=2;i<=r;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tll res;\n\t\t\t\t\tif(j==k) res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][a[i]];\n\t\t\t\t\telse res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][k] + (ll)fs[k][j] + (ll)fl[j][a[i]];\n\t\t\t\t\tdp[i][j] = min((ll)dp[i][j],res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans = min(ans,dp[r][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nvoid chmin(int &a, int b) {\n     a = min(a, b);\n}\n\nconst int INF = 1 << 25;\nint N, M, R;\nint dl[210][210], ds[210][210], dist[1010][210], op[1010];\n\nint main() {\n    while(scanf(\"%d%d\", &N, &M)) {\n        if(N == M && M == 0) break;\n        for(int i=0; i<N; i++) {\n            fill(dl[i], dl[i] + N, INF);\n            fill(ds[i], ds[i] + N, INF);\n            dl[i][i] = ds[i][i] = 0;\n        }\n\n        for(int i=0; i<M; i++) {\n            int x, y, t; char s;\n            scanf(\" %d%d%d %c\", &x, &y, &t, &s);\n            x--; y--;\n            if(s == 'L') {\n                chmin(dl[x][y], t);\n                chmin(dl[y][x], t);\n            }\n            else {\n                chmin(ds[x][y], t);\n                chmin(ds[y][x], t);\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    chmin(dl[i][j], dl[i][k] + dl[k][j]);\n                    chmin(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        scanf(\"%d\", &R);\n        for(int i=0; i<R; i++) {\n            scanf(\"%d\", &op[i]); op[i]--;\n            fill(dist[i], dist[i] + N, INF);\n        }\n\n        dist[0][op[0]] = 0;\n        for(int i=0; i<R-1; i++) {\n            for(int j=0; j<N; j++) {\n                if(dist[i][j] == INF) continue;\n                int cur = op[i], nxt = op[i+1];\n\n                // land only\n                chmin(dist[i+1][j], dist[i][j] + dl[cur][nxt]);\n\n                // land + sea\n                for(int k=0; k<N; k++) {\n                    chmin(dist[i+1][k], dist[i][j] + dl[cur][j] + ds[j][k] + dl[k][nxt]);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", *min_element(dist[R-1], dist[R-1] + N));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<queue>\n\n\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n\nconst int INF = 1<<28;\n\n\nint main(){\n\n\twhile(1){\t\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\tvector<vector<int>> L(n+1,vector<int>(n+1,INF));\n\t\tvector<vector<int>> S(n+1,vector<int>(n+1,INF));\n\n\t\tint from,to,dist,r;string sl;\t\n\t\tvector<int> z(r+1);\n\n\t\trep(i,m){\n\t\t\tcin >> from >> to >> dist >> sl;\n\t\t\tif(sl==\"L\"){\n\t\t\t\tL[from][to]=dist;\n\t\t\t\tL[to][from]=dist;\n\t\t\t}else{\n\t\t\t\tS[from][to]=dist;\n\t\t\t\tS[to][from]=dist;\n\t\t\t}\n\t\t}\n\t\n\t\trep(i,n+1){\n\t\t\tL[i][i]=0;\n\t\t\tS[i][i]=0;\n\t\t}\n\n\t\tcin >> r;\n\t\trep(i,r) cin >> z[i];\n\n\t\tfor(int k=0;k<n+1;++k){\n\t\t\tfor(int i=0;i<n+1;++i){\n\t\t\t\tfor(int j=0;j<n+1;++j) L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int k=0;k<n+1;++k){\n\t\t\tfor(int i=0;i<n+1;++i){\n\t\t\t\tfor(int j=0;j<n+1;++j) S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t}\n\t\t}\n\n\t\tint dp[r][n+1]; \n\t\tfill_n((int *)dp,sizeof(dp)/sizeof(int),INF);\n\t\tdp[0][z[0]] = 0;\n\t\tfor (int i = 1; i < r; i++) {\n\t\t\t//????????????\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (dp[i-1][j] != INF) {\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + L[z[i-1]][z[i]];\n\t\t\t\t} \n\t\t\t}\n\n\t\t\t//????????????\n\t\t\tfor(int j = 1; j<= n; j++){\n\t\t\t\tfor(int k = 1;k<= n;k++){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + L[z[i-1]][j] + S[j][k] + L[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\n\t\t cout << *min_element(dp[r - 1], dp[r - 1]+n+1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n\nint n,m,r;\nconst int INF=1e7;\nint land[200][200],sea[200][200],z[1000];\ntypedef pair<int,int> P;\n\nint main(){\n\n\n\twhile(cin>>n>>m,n){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) land[i][j]=sea[i][j]=INF;\n\t\t\tland[i][i]=sea[i][i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tx--; y--;\n\t\t\tif(s==\"S\"){\n\t\t\t\tsea[x][y]=min(sea[x][y],t);\n\t\t\t\tsea[y][x]=min(sea[y][x],t);\n\t\t\t}else{\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=min(land[y][x],t);\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin>>r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin>>z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\t//dp[i][j] 0~i?????§???????????????????????????j???????°???????\n\t\tvector<vector<int> > dp(2001,vector<int>(201,INF));\n\t\tdp[0][z[0]]=0;\n\t\t\n\t\tstack<P> st;\n\t\tst.push(P(0,z[0]));\n\t\tint res=INF;\n\t\twhile(!st.empty()){\n\t\t\t\n\t\t\tP p=st.top(); st.pop();\n\t\t\tint idx=p.first,ship=p.second;\n\t\t\t\n\t\t\t//cout<<\"idx=\"<<idx<<\" ship=\"<<ship<<\" cost=\"<<dp[idx][ship]<<endl;\n\t\t\t\n\t\t\tif(idx==r-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint nidx=idx+1;\n\t\t\t\n\t\t\t//????????§?§????\n\t\t\tif(land[z[idx]][z[nidx]]!=INF){\n\t\t\t\tif(dp[nidx][ship]>dp[idx][ship]+land[z[idx]][z[nidx]]){\n\t\t\t\t\tdp[nidx][ship]=dp[idx][ship]+land[z[idx]][z[nidx]];\n\t\t\t\t\tst.push(P(nidx,ship));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//v?????§?????§?§????????????????????????§?§????\n\t\t\tfor(int v=0;v<n;v++){\n\t\t\t\tif(sea[ship][v]==INF || land[v][z[nidx]]==INF) continue;\n\t\t\t\t\n\t\t\t\tif(dp[nidx][v]>dp[idx][ship]+sea[ship][v]+land[v][z[nidx]]){\n\t\t\t\t\tdp[nidx][v]=dp[idx][ship]+sea[ship][v]+land[v][z[nidx]];\n\t\t\t\t\tst.push(P(nidx,v));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres=min(res,dp[r-1][i]);\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) {\n  for (int k = 1; k <= n; ++k) {\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while (scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n\n    while (m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if (tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n\n    for (int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    d[1][b[1]] = 0;\n    for (int i = 1; i <= n; ++i) {\n      d[1][i] = min(d[b[1]][i], s[1][b[1]] + l[i][b[1]]);\n    }\n\n    for (int i = 2; i <= r; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (l[j][b[i]] >= INF) continue;\n        for (int k = 1; k <= n; ++k) {\n          if (d[i - 1][k] >= INF) continue;\n          if (j == k) {\n            if (l[b[i - 1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][b[i]]);\n            }\n          } else {\n            if (l[b[i - 1]][k] < INF && s[k][j] < INF && l[j][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-10\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(ALL(v));v.erase(unique(ALL(v)),v.end());\n#define pb push_back\n\nll n,m;\n\nll solve() {\n\tvector<vector<int>> l(n,vector<int>(n,INF));\n\tvector<vector<int>> s(n,vector<int>(n,INF));\n\tREP(i,n) l[i][i]=s[i][i]=0;\n\tREP(i,m) {\n\t\tint x,y,t;\n\t\tchar sl;\n\t\tcin>>x>>y>>t>>sl;\n\t\tx--; y--;\n\t\tif(sl=='L') l[x][y]=l[y][x]=min(t,l[y][x]);\n\t\tif(sl=='S') s[x][y]=s[y][x]=min(t,s[y][x]);\n\t}\n\tvector<vector<vector<int>>> l_wf(n+1,vector<vector<int>>(n,vector<int>(n,INF)));\n\tvector<vector<vector<int>>> s_wf(n+1,vector<vector<int>>(n,vector<int>(n,INF)));\n\tREP(i,n) REP(j,n) l_wf[0][i][j]=l[i][j];\n\tREP(i,n) REP(j,n) s_wf[0][i][j]=s[i][j];\n\tFOR(i,1,n+1) REP(j,n) REP(k,n) {\n\t\tl_wf[i][j][k]=min(l_wf[i-1][j][k],l_wf[i-1][j][i-1]+l_wf[i-1][i-1][k]);\n\t\ts_wf[i][j][k]=min(s_wf[i-1][j][k],s_wf[i-1][j][i-1]+s_wf[i-1][i-1][k]);\n\t}\n\tll r;\n\tcin>>r;\n\tvector<ll> z(r);\n\tREP(i,r) cin>>z[i];\n\tREP(i,r) z[i]--;\n\tvector<vector<ll>> dp(2,vector<ll>(n,INF*INF));\n\tdp[0][z[0]]=0;\n\tFOR(i,1,r) REP(j,n) {\n\t\tdp[i%2][j]=INF*INF;\n\t\tdp[i%2][j]=min(dp[i%2][j],dp[!(i%2)][j]+l_wf[n][z[i-1]][z[i]]);\n\t\tREP(k,n) {\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[!(i%2)][k]+l_wf[n][z[i-1]][k]+s_wf[n][k][j]+l_wf[n][j][z[i]]);\n\t\t}\n\t}\n\tll ret=INF*INF;\n\tREP(j,n) ret=min(ret,dp[!(r%2)][j]);\n\treturn ret;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n>>m;\n\t\tif(n==0&&m==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nstatic int N, M, R;\n\nstruct Node {\n\tint id;\n\tint d;\n};\n\nstatic vector<Node> gl[201];\nstatic vector<Node> gs[201];\n\nstatic int dist_l[201][201];\nstatic int dist_s[201][201];\n\nstatic int dest[1001];\n\n\n\nstatic void flood()\n{\n\tint i, j, k;\n\n\tfor (i=1; i<=N; i++) {\n\t\tdist_l[i][i] = 0;\n\t\tfor (j=i+1; j<=N; j++) {\n\t\t\tdist_l[i][j] = dist_l[j][i] = INT_MAX;\n\t\t}\n\t}\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=0; j<gl[i].size(); j++) {\n\t\t\tint t = gl[i][j].id;\n\t\t\tint d = gl[i][j].d;\n\t\t\tif (dist_l[i][t] > d)\n\t\t\t\tdist_l[i][t] = dist_l[t][i] = d;\n\t\t}\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (i=1; i<=N; i++) {\n\t\tdist_s[i][i]=0;\n\t\tfor (j=i+1; j<=N; j++) {\n\t\t\tdist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t}\n\t}\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=0; j<gs[i].size(); j++) {\n\t\t\tint id = gs[i][j].id;\n\t\t\tint d = gs[i][j].d;\n\t\t\tif (dist_s[i][id] > d) \n\t\t\t\tdist_s[i][id] = dist_s[id][i] = d;\n\t\t}\n\t}\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t/*\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=i; j<=N; j++) {\n\t\t\tprintf(\"dist_l[%d][%d]=%d\\n\", i, j, dist_l[i][j]);\n\t\t}\n\t}\n\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=i; j<=N; j++) {\n\t\t\tprintf(\"dist_s[%d][%d]=%d\\n\", i, j, dist_s[i][j]);\n\t\t}\n\t}\n\t*/\n}\n\n\n\nstatic void solve()\n{\n\tflood();\n\n\tint s_start[201];\n\tint s_end[201];\n\n\tint i, j;\n\n\tfor (i=1; i<=N; i++)\n\t\ts_start[i] = INT_MAX;\n\ts_start[dest[0]] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_end[j] = INT_MAX;\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (s_start[j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (s_end[j] > s_start[j]+total_land_cost)\n\t\t\t\t\t\ts_end[j] = s_start[j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (s_end[k] > c1+c2+c3+s_start[j]) {\n\t\t\t\t\t\ts_end[k] = c1+c2+c3+s_start[j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_start[j] = s_end[j];\n/*\n\t\tprintf(\"start=%d, end=%d\\n\", start, end);\n\t\tprintf(\"s_end[]= \");\n\t\tfor (j=1; j<=N; j++)\n\t\t\tprintf(\"%d \", s_end[j]);\n\t\tprintf(\"\\n\");\n*/\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > s_start[i])\n\t\t\tmin = s_start[i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tNode node;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tgl[i].clear();\n\t\t\tgs[i].clear();\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tnode.d = t; node.id = y;\n\t\t\t\tgs[x].push_back(node);\n\t\t\t\tnode.id = x;\n\t\t\t\tgs[y].push_back(node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode.d = t; node.id = y;\n\t\t\t\tgl[x].push_back(node);\n\t\t\t\tnode.id = x;\n\t\t\t\tgl[y].push_back(node);\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\t\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\t\tdest[0] = dest[1];\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,i,j,k,r,a[205],ans,map[205][205][2],dp[1005][205];\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n==0&&m==0)\n\t\t\tbreak;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tmap[i][j][0]=map[i][j][1]=1000000;\n\t\t\t}\n\t\t\tmap[i][i][0]=map[i][i][1]=0;\n\t\t}\n\t\tint x,y,t,o;\n\t\tchar s;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%d %d %d %c\",&x,&y,&t,&s);\n\t\t\tif(s=='L')\n\t\t\t\to=0;\n\t\t\tif(s=='S')\n\t\t\t\to=1;\n\t\t\tmap[x][y][o]=min(map[x][y][o],t);\n\t\t\tmap[y][x][o]=map[x][y][o];\n\t\t}\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\t\tmap[i][j][0]=min(map[i][j][0],map[i][k][0]+map[k][j][0]);\n\t\t\t\t\t\tmap[i][j][1]=min(map[i][j][1],map[i][k][1]+map[k][j][1]);\t\n\t\t\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tdp[i][j]=1000000;\n\t\tdp[1][a[1]]=0;\n\t\tfor(i=2;i<=r;i++)\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+map[a[i-1]][a[i]][0]);\n\t\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+map[a[i-1]][j][0]+map[j][k][1]+map[k][a[i]][0]);\n\t\t\t}\n\t\tans=2147483647;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=min(ans,dp[r][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nint N, M;\n\nstruct State\n{\n    ll pos, spos, dist;\n};\n\nbool operator<(const State &e, const State &f)\n{\n    return e.dist > f.dist;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> N >> M, N || M)\n    {\n        // 陸路での距離, 海路での距離\n        ll road[N][N], ship[N][N];\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                if (i != j)\n                {\n                    road[i][j] = ship[i][j] = INF;\n                }\n                else\n                {\n                    road[i][j] = ship[i][j] = 0;\n                }\n            }\n        }\n        for (int i = 0; i < M; i++)\n        {\n            int x, y, t;\n            string sl;\n            cin >> x >> y >> t >> sl;\n            x--;\n            y--;\n            if (sl == \"S\")\n                ship[x][y] = ship[y][x] = t;\n            else\n                road[x][y] = road[y][x] = t;\n        }\n        int R;\n        cin >> R;\n        vector<int> z(R);\n        for (int i = 0; i < R; i++)\n        {\n            cin >> z[i];\n            z[i]--;\n        }\n        ll dp[R][N];\n        for (int i = 0; i < R; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                dp[i][j] = INF;\n            }\n        }\n        for (int k = 0; k < N; k++)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                for (int j = 0; j < N; j++)\n                {\n                    road[i][j] = min(road[i][j], road[i][k] + road[k][j]);\n                    ship[i][j] = min(ship[i][j], ship[i][k] + ship[k][j]);\n                }\n            }\n        }\n        priority_queue<State> q;\n        dp[0][z[0]] = 0;\n        q.push(State{0, z[0], 0});\n        while (!q.empty())\n        {\n            State state = q.top();\n            q.pop();\n            int idx = state.pos;\n            int st = z[idx], gt = z[idx + 1];\n            int mt = state.spos, dis = state.dist;\n            if (dp[idx][mt] < dis)\n                continue;\n            // 陸路のみ\n            if (dp[idx][mt] + road[st][gt] < dp[idx + 1][mt])\n            {\n                dp[idx + 1][mt] = dp[idx][mt] + road[st][gt];\n                if (idx + 2 < R)\n                {\n                    q.push(State{idx + 1, mt, dp[idx + 1][mt]});\n                }\n            }\n            for (int i = 0; i < N; i++)\n            {\n                if (dp[idx][mt] + road[st][mt] + ship[mt][i] + road[i][gt] < dp[idx + 1][i])\n                {\n                    dp[idx + 1][i] = dp[idx][mt] + road[st][mt] + ship[mt][i] + road[i][gt];\n                    if (idx + 2 < R)\n                    {\n                        q.push(State{idx + 1, i, dp[idx + 1][i]});\n                    }\n                }\n            }\n        }\n        ll res = INF;\n        for (int i = 0; i < N; i++)\n            res = min(res, dp[R - 1][i]);\n        cout << res << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nvoid chmin(int &a, int b) {\n     a = min(a, b);\n}\n\nconst int INF = 1 << 25;\nint N, M, R;\nint dl[210][210], ds[210][210], dist[1010][210], op[1010];\n\nint main() {\n    while(scanf(\"%d%d\", &N, &M)) {\n        if(N == M && M == 0) break;\n        for(int i=0; i<N; i++) {\n            fill(dl[i], dl[i] + N, INF);\n            fill(ds[i], ds[i] + N, INF);\n            dl[i][i] = ds[i][i] = 0;\n        }\n\n        for(int i=0; i<M; i++) {\n            int x, y, t; char s;\n            scanf(\" %d%d%d %c\", &x, &y, &t, &s);\n            x--; y--;\n            if(s == 'L') {\n                chmin(dl[x][y], t);\n                chmin(dl[y][x], t);\n            }\n            else {\n                chmin(ds[x][y], t);\n                chmin(ds[y][x], t);\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    chmin(dl[i][j], dl[i][k] + dl[k][j]);\n                    chmin(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        scanf(\"%d\", &R);\n        for(int i=0; i<R; i++) {\n            scanf(\"%d\", &op[i]); op[i]--;\n            fill(dist[i], dist[i] + N, INF);\n        }\n\n        dist[0][op[0]] = 0;\n        for(int i=0; i<R-1; i++) {\n            for(int j=0; j<N; j++) {\n                if(dist[i][j] == INF) continue;\n                int cur = op[i], nxt = op[i+1];\n\n                // land only\n                chmin(dist[i+1][j], dist[i][j] + dl[cur][nxt]);\n\n                // land + sea\n                for(int k=0; k<N; k++) {\n                    chmin(dist[i+1][k], dist[i][j] + dl[cur][j] + ds[j][k] + dl[k][nxt]);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", *min_element(dist[R-1], dist[R-1] + N));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct edge{\n    int to,cost;\n    bool S;\n    edge(int a,int b,bool c):to(a),cost(b),S(c){}\n};\n\nstruct data{\n    int pos,cost,ship;\n    data(int a,int b,int c):pos(a),cost(b),ship(c){}\n    bool operator<(const data &d)const{\n        return cost>d.cost;\n    }\n};\n\nint N,M,T;\nvector<edge>G[200];\nvector<int>task;\nint dist[200][200];\nconst int INF=1001001001;\nvoid solve(){\n    priority_queue<data>Q;\n\n    for(int i=0;i<T-1;i++){\n        if(i==0){\n            for(int j=0;j<N;j++)fill_n(dist[j],N,INF);\n            dist[task[0]][task[0]]=0;\n            Q.push(data(task[0],0,task[0]));\n        }\n        else{\n            for(int j=0;j<N;j++)if(task[i]!=j)fill_n(dist[j],N,INF);\n            for(int j=0;j<N;j++){\n                Q.push(data(task[i],dist[task[i]][j],j));\n            }\n        }\n\n        while(Q.size()){\n            data d=Q.top();Q.pop();\n\n            if(dist[d.pos][d.ship]<d.cost)continue;\n\n            for(int j=0;j<G[d.pos].size();j++){\n                edge &e=G[d.pos][j];\n                if(e.S){\n                    if(d.pos!=d.ship)continue;\n                    if(dist[e.to][e.to]<=d.cost+e.cost)continue;\n                    dist[e.to][e.to]=d.cost+e.cost;\n                    Q.push(data(e.to,d.cost+e.cost,e.to));\n                }\n                else{\n                    if(dist[e.to][d.ship]<=d.cost+e.cost)continue;\n                    dist[e.to][d.ship]=d.cost+e.cost;\n                    Q.push(data(e.to,d.cost+e.cost,d.ship));\n                }\n            }\n        }\n    }\n\n    int ans=INF;\n    for(int i=0;i<N;i++)ans=min(ans,dist[task[T-1]][i]);\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(0);\n    \n    while(cin>>N>>M,N||M){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].push_back(edge(b,c,(d=='S')));\n            G[b].push_back(edge(a,c,(d=='S')));\n        }\n        cin>>T;\n        task.resize(T);\n        for(int i=0;i<T;i++)cin>>task[i],task[i]--;\n\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e13)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\n\nll N, M;\nll load[205][205];\nll marine[205][205];\nll dist[1005][205];\nbool chmin(ll &a, ll b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint z[1005];\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(true) {\n        cin >> N >> M;\n        if(N == 0) break;\n        for(int i = 1; i <= N; i++) {\n            for(int j = 1; j <= N; j++) {\n                load[i][j] = INF;\n                marine[i][j] = INF;\n            }\n            load[i][i] = 0;\n            marine[i][i] = 0;\n        }\n        while(M--) {\n            ll u, v, c;\n            char s;\n            cin >> u >> v >> c >> s;\n            if(s == 'L') {\n                chmin(load[u][v], c);\n                chmin(load[v][u], c);\n            } else {\n                chmin(marine[u][v], c);\n                chmin(marine[v][u], c);\n            }\n        }\n        for(int i = 1; i <= N; i++) {\n            for(int j = 1; j <= N; j++) {\n                for(int k = 1; k <= N; k++) {\n                    chmin(load[j][k], load[j][i] + load[i][k]);\n                    chmin(marine[j][k], marine[j][i] + marine[i][k]);\n                }\n            }\n        }\n        ll R;\n        cin >> R;\n        for(int i = 1; i <= R; i++) cin >> z[i];\n        z[0] = 1;\n        for(ll i = 1; i <= N; i++) {\n            for(int j = 0; j <= R; j++) {\n                dist[j][i] = INF;\n            }\n        }\n        dist[1][z[1]] = 0;\n        for(int query = 2; query <= R; query++) {\n            for(int before = 1; before <= N; before++) {\n                chmin(dist[query][before], dist[query-1][before] + load[z[query-1]][z[query]]);\n                for(int after = 1; after <= N; after++) {\n                    chmin(dist[query][after], dist[query-1][before] + load[z[query-1]][before] + marine[before][after] + load[after][z[query]]);\n                }\n            }\n            for(int i = 1; i <= N; i++) {\n                //cerr << query << \" \" << i << \" \" << dist[query][i] << endl;\n            }\n        }\n        ll ans = INF;\n        for(int i = 1; i <= N; i++) {\n            chmin(ans, dist[R][i]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint N, M, R;\nint sea[200][200], land[200][200];\nll dp[2][200];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int x, y, t;\n    char _c;\n    while(cin >> N >> M && N){\n        rep(i, N) rep(j, N)\n          sea[i][j] = land[i][j] = i == j ? 0: INF;\n        rep(i, M){\n            cin >> x >> y >> t >> _c; --x; --y;\n            if(_c == 'L')\n              land[x][y] = land[y][x] = min(land[x][y], t);\n            else\n              sea[x][y] = sea[y][x] = min(sea[x][y], t);\n        }\n        \n        rep(k, N) rep(i, N) rep(j, N){\n            sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n        }\n        \n        rep(i, 2) rep(j, 200) dp[i][j] = INF;\n        int crr = 0, nxt = 1, from, to;\n        cin >> R;\n        rep(i, R){\n            cin >> to; --to;\n            rep(j, 200) dp[nxt][j] = INF;\n            if(i == 0){\n                dp[crr][to] = 0;\n                from = to;\n                continue;\n            }\n            rep(j, N){\n                //from,to (through land)\n                //corner case(because in general recursion, land[from][to] mistaken as land[from][j] + land[j][to])\n                dp[nxt][j] = min(dp[nxt][j], dp[crr][j] + (ll)land[from][to]);\n                rep(k, N)//from, k, j, to (through land, sea, land)\n                  dp[nxt][j] = min(dp[nxt][j], dp[crr][k] + (ll)land[from][k] + (ll)sea[k][j] + (ll)land[j][to]);\n            }\n            swap(crr, nxt);\n            swap(from, to);\n        }\n        \n        ll ans = INF;\n        rep(i, N) ans = min(ans, dp[crr][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n  \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n  \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n  \nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n  \nint main(){\n    while(1){\n        int n,m;\n        static LL ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static LL sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)return 0;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static LL dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tint ret=INF;\n    \trep1(i,n){\n    \t\tret=min(ret,(int)dp[r-1][i]);\n    \t}\n          \n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\nint dp[1000][200];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(dp[0],dp[1001],INF);\n\t   dp[0][now]=0;\n\t    \n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nint dp[200][200][1001];\nstruct State{\n\tint pos;\n\tint hune;\n\tint r;\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tvector<vector<int> > g(N);\n\t\tvector<vector<int> > ti(N);\n\t\tvector<vector<char> > sl(N);\n\t\t\n\t\tint res = 0;\n\t\tint a, b, c;\n\t\tchar d;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t\tti[a].push_back(c);\n\t\t\tti[b].push_back(c);\n\t\t\tsl[a].push_back(d);\n\t\t\tsl[b].push_back(d);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> A(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> A[i];\n\t\t\tA[i]--;\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k <= R; k++) {\n\t\t\t\t\tdp[i][j][k] = (int)1 << 60;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdp[A[0]][A[0]][1] = 0;\n\t\tqueue<State> qu;\n\t\tqu.push(State{ A[0], A[0],1 });\n\t\tState t;\n\t\twhile ((int)qu.size() > 0) {\n\t\t\tState st = qu.front(); qu.pop();\n\t\t\t//cerr << st.pos << \" \" << st.hune << \" \" << st.r << endl;\n\t\t\tif (st.r == R)continue;\n\t\t\tfor (int i = 0; i < g[st.pos].size(); i++) {\n\t\t\t\tif (st.pos == st.hune || sl[st.pos][i] == 'L') {\n\t\t\t\t\tt.pos = g[st.pos][i];\n\t\t\t\t\tif (sl[st.pos][i] == 'S') {\n\t\t\t\t\t\tt.hune = g[st.pos][i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tt.hune = st.hune;\n\t\t\t\t\t}\n\t\t\t\t\tt.r = st.r;\n\t\t\t\t\tif (A[st.r] == g[st.pos][i]) {\n\t\t\t\t\t\tt.r++;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[t.pos][t.hune][t.r] > dp[st.pos][st.hune][st.r] + ti[st.pos][i]) {\n\t\t\t\t\t\tdp[t.pos][t.hune][t.r] = dp[st.pos][st.hune][st.r] + ti[st.pos][i];\n\t\t\t\t\t\tqu.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = (int)1 << 60;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, dp[A[R - 1]][i][R]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// 21:22 ~\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tint d, z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nint dp[1005][205][205];\t\t// z, boat, n\n\nint solve(){\n\tpriority_queue<ST> que;\n\tdp[0][ Z[0] ][ Z[0] ] = 0;\n\tque.push( ST{0, 0, Z[0], Z[0]} );\n\twhile( !que.empty() ){\n\t\tint d = que.top().d;\n\t\tint z = que.top().z;\n\t\tint b = que.top().b;\n\t\tint n = que.top().n;\n\t\tque.pop();\n\t\tif( dp[z][b][n] < d || z+1 >= R ) continue;\n\t\trep(k, 2) if( !k || b == n ){\n\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\tint to = _v.first;\n\t\t\t\tint cost = _v.second;\n\t\t\t\tint nz = z, nb = b;\n\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\tif( k ) nb = to;\n\t\t\t\tif( chmin( dp[nz][nb][to], dp[z][b][n] + cost) ){\n\t\t\t\t\tque.push( ST{ dp[nz][nb][to], nz, nb, to } );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(b,N) rep(n,N){\n\t\tchmin( ans, dp[R-1][b][n] );\n\t}\n\treturn ans;\n}\n\nint main(){\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\trep(i,M){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            /*if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }*/\n            rep(j,n){\n                cmin(dp[i+1][j],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][k],dp[i][j] + Ld[v[i]][j] + Sd[j][k] + Ld[k][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n\nconst lint INF = 1ll << 30;\ninline void chmin(lint &a, lint b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1000];\n\nlint solve()\n{\n\tstatic lint ldist[200][200];\n\tstatic lint sdist[200][200];\n\tstatic lint dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1000 * 200, INF);\n\tdp[0][z[0]] = 0;\n\tfor (int i = 0; i < r - 1; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tchmin(dp[i + 1][j], dp[i][j] + ldist[src][dst]);\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tlint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r - 1], dp[r]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl == \"L\") ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint N,M;\n\twhile(cin>>N>>M,N){\n\t\tvector<vector<long long>>L(N,vector<long long>(N));\n\t\tvector<vector<long long>>S(N,vector<long long>(N));\n\t\tfor(int i=0;i<N;++i){\n\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\tL[i][j]=0;\n\t\t\t\t\tS[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tL[i][j]=1e8;\n\t\t\t\t\tS[i][j]=1e8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<M;++i){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tif(sl=='L'){\n\t\t\t\tL[x][y]=t;\n\t\t\t\tL[y][x]=t;\n\t\t\t}else{\n\t\t\t\tS[x][y]=t;\n\t\t\t\tS[y][x]=t;\n\t\t\t}\n\t\t}\n\t\tint R;\n\t\tcin>>R;\n\t\tvector<int>z(R);\n\t\tfor(int i=0;i<R;++i){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tz[i]=--a;\n\t\t}\n\t\tfor(int k=0;k<N;++k){\n\t\t\tfor(int i=0;i<N;++i){\n\t\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long>>dp(R,vector<long long>(N,1e10));\n\t\tdp[0][z[0]]=0;\n\t\tlong long ans=1e18;\n\t\tfor(int i=1;i<R;++i){\n\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\tdp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n\t\t\t\tfor(int k=0;k<N;++k){\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+L[z[i-1]][k]+S[k][j]+L[j][z[i]]);\n\t\t\t\t}\n\t\t\t\tif(i==R-1){\n\t\t\t\t\tans=min(ans,dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e8;\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > adjL(n, vector<int>(n, inf)), adjS(n, vector<int>(n, inf));\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl=='L'){\n\t\t\t\tadjL[x][y] = adjL[y][x] = min(adjL[x][y], t);\n\t\t\t}else{\n\t\t\t\tadjS[x][y] = adjS[y][x] = min(adjS[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tadjL[i][i]=0;\n\t\t\tadjS[i][i]=0;\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0; i<r; i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tadjL[i][j] = min(adjL[i][j], adjL[i][k]+adjL[k][j]);\n\t\t\t\t\tadjS[i][j] = min(adjS[i][j], adjS[i][k]+adjS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<vector<int> > > dp(2, vector<vector<int> >(n, vector<int>(n, inf)));\n\t\tdp[0][z[0]][z[0]] = 0;\n\t\tfor(int i=0; i<r-1; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tdp[(i+1)%2][j][k] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k==j){\n\t\t\t\t\t\tdp[(i+1)%2][z[i+1]][k] = min(dp[(i+1)%2][z[i+1]][k], dp[i%2][z[i]][j]+adjL[z[i]][z[i+1]]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[(i+1)%2][z[i+1]][k] = min(dp[(i+1)%2][z[i+1]][k], dp[i%2][z[i]][j]+adjL[z[i]][j]+adjS[j][k]+adjL[k][z[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=inf;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tans = min(ans, dp[(r-1)%2][z[r-1]][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int INF=100000000;\nconst int MAX_V = 201;\nint n,m,r;\nint land[MAX_V][MAX_V];\nint sea[MAX_V][MAX_V];\nint citys[1001];\nvoid calcLandMinDist(){\n    for(int i = 0; i < MAX_V; i++)\n        for(int j = 0; j < MAX_V; j++)\n            for(int k = 0; k < MAX_V; k++)\n                land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n}\nvoid calcSeaMinDist(){\n    for(int i = 0; i < MAX_V; i++)\n        for(int j = 0; j < MAX_V; j++)\n            for(int k = 0; k < MAX_V; k++)\n                sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n}\nint dp[201][201];\n// WzæªidxÌÔÚÌÆ±ëÅA{[gªboatÌm[hÉ éÆ«ÌÅ¬zBÔ\nint rec(int idx,int boat){\n    if(idx==r)\n        return 0;\n    if(dp[idx][boat]!=INF)\n        return dp[idx][boat];\n    int minTime=INF;\n    // ¤ÌÝðgÁÄB·éê\n    minTime=min(minTime,rec(idx+1,boat)+land[citys[idx-1]][citys[idx]]);\n    // CàgÁÄB·éê\n    // »ÝÌboatÌÊu©çBÅ«é`¬·×ÄÉÂ¢Ä·\n    for(int i = 0; i < n; i++){\n        minTime=min(minTime,rec(idx+1,i)+land[citys[idx-1]][boat]\n        + sea[boat][i] + land[i][citys[idx]]);\n    }\n    return dp[idx][boat]=minTime;\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    land[i][j]=sea[i][j]=0;\n                else\n                    land[i][j]=sea[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char kind;\n            cin>>from>>to>>cost>>kind;\n            from--;to--;\n            if(kind=='L')\n                land[from][to]=land[to][from]=cost;\n            else\n                sea[from][to]=sea[to][from]=cost;\n        }\n        cin>>r;\n        for(int i = 0; i < r; i++){\n            cin>>citys[i];\n            citys[i]--;\n        }\n        calcLandMinDist();calcSeaMinDist();\n        // dpÅÅZ£ðßé\n        for(int i = 0; i < 201; i++)\n            for(int j = 0; j < 201; j++)dp[i][j]=INF;\n        int res=rec(1,citys[0]);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}\n/*\nÈº¦ÍÅ«P[XÅªöxÅoÍ³êéªAAOJÅÍà¿ëñTLE·éR[h\n_CNXg@ðgpµÄð¼Éð¢Ä¢é\n*/\n//struct edge{\n//\tint to;\n//\tint cost;\n//    char kind;\n//};\n//\n//class Situation{\n//public:\n//\tint cost;\n//\tint node;\n//    int boat;\n//    int obj;\n//\n//\tSituation(int cost_,int node_,int boat_,int obj_){\n//\t\tcost=cost_;\n//        node=node_;\n//        boat=boat_;\n//        obj=obj_;\n//\t}\n//\tSituation();\n//\n//\tbool operator<(const Situation &s)const{\n//\t\treturn s.cost < this->cost;\n//\t}\n//};\n//\n//int V;\n//int n,m;\n//\n//vector<int> objLands;\n//\n//const int MAX_V = 205;\n//const int MAX_M = 1001;\n//vector<edge> G[MAX_V];\n//int d[MAX_V][MAX_M][MAX_V];\n//const int INF = 1000000000;\n//\n//void dijkstra(int s){\n//\tpriority_queue<Situation> que;\n//    for(int i = 0; i < MAX_V; i++)\n//        for(int j = 0; j < MAX_M; j++)\n//            for(int k = 0; k < MAX_V; k++)\n//                d[i][j][k]=INF;\n//    d[s][0][s] = 0;\n//    que.push(Situation(0,s,s,0));\n//\twhile(!que.empty()){\n//\t\tSituation p = que.top();\n//\t\tque.pop();\n//        int node=p.node;\n//        int boat=p.boat;\n//        int cost=p.cost;\n//        int obj=p.obj;\n//        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n//\t\tif(d[node][obj][boat] < cost)\n//            continue;\n//\t\tfor(int i = 0; i < G[node].size(); i++){\n//\t\t\tedge &e = G[node][i];\n//            int toObj=obj;\n//            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n//            if(objLands[obj]==e.to)\n//                toObj++;\n//            // ¤ÌêÆCÌêÅêí¯\n//            if(e.kind=='L'){\n//                // ÅZ£\n//                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n//                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n//                    if(toObj!=objLands.size())\n//                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n//                }\n//            }\n//            else{\n//                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n//                if(boat==node){\n//                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n//                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n//                        if(toObj!=objLands.size())\n//                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n//                    }\n//                }\n//            }\n//\t\t}\n//\t}\n//}\n//\n//int main(){\n//\n//    while(cin>>n>>m&&!(n==0&&m==0)){\n//        objLands.clear();\n//        for(int i = 0; i < MAX_V; i++)\n//            G[i].clear();\n//        for(int i = 0; i < m; i++){\n//            int from,to,cost;\n//            char c;\n//            cin>>from>>to>>cost>>c;\n//            from--;to--;\n//            edge e;\n//            e.cost=cost;e.kind=c;e.to=to;\n//            G[from].push_back(e);\n//            e.to=from;\n//            G[to].push_back(e);\n//        }\n//        int t;\n//        cin>>t;\n//        int s;\n//        for(int i = 0; i < t; i++){\n//            if(i==0){\n//                cin>>s;\n//                s--;\n//            }\n//            else{\n//                int b;\n//                cin>>b;\n//                b--;\n//                objLands.push_back(b);\n//            }\n//        }\n//        dijkstra(s);\n//        int minCost=INF;\n//        for(int i = 0; i < n; i++){\n//            for(int j = 0; j < n; j++)\n//                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n//        }\n//        cout<<minCost<<endl;\n//    }\n//    return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define inf 0x3f3f3f3f3f3f\n#define maxn (210)\n#define ll long long\n#define il inline\n#define RG register\nusing namespace std;\nil int gi(){ RG int x=0,q=1; RG char ch=getchar(); while( ( ch<'0' || ch>'9' ) && ch!='-' ) ch=getchar();\n  if( ch=='-' ) q=-1,ch=getchar(); while(ch>='0' && ch<='9') x=x*10+ch-48,ch=getchar(); return q*x; }\n\nchar s[2];\nint n,m,w;\nint L[maxn][maxn],S[maxn][maxn],Q[maxn*5];\nll C[maxn*5][maxn];\n\nil ll dfs(int n,int m,int w){  \n  for(RG int k=1;k<=n;++k){  \n    for(RG int i=1;i<=n;++i)    \n      for(RG int j=1;j<=n;++j){  \n        S[i][j]=min(S[i][j],S[i][k]+S[k][j]);  \n        L[i][j]=min(L[i][j],L[i][k]+L[k][j]);  \n      }  \n  }  \n  C[1][Q[1]]=0;  \n  for(RG int i=1;i<=w;++i) \n    for(RG int j=1;j<=n;++j){  \n      C[i][j]=min(C[i][j],C[i-1][j]+L[Q[i-1]][Q[i]]);\n      for(RG int k=1;k<=n;++k){  \n        C[i][k]=min(C[i][k],C[i-1][j]+L[Q[i-1]][j]+S[j][k]+L[k][Q[i]]);  \n      }  \n    }  \n  RG ll ans=inf;  \n  for(RG int  i=1;i<=n;++i) ans=min(ans,C[w][i]);  \n  return ans;  \n} \n\nil void init(){\n  memset(L,inf,sizeof(L));  \n  memset(S,inf,sizeof(S));  \n  memset(C,inf,sizeof(C));  \n  for(RG int i=1;i<=n;++i) L[i][i]=S[i][i]=0;\n}\n\nint main(){  \n  while(scanf(\"%lld%lld\",&n,&m),n|m){  \n    init();  \n    for(int i=1;i<=m;++i){  \n      RG int a=gi(),b=gi(),c=gi();\n      scanf(\"%s\",s);  \n      if(s[0]=='S') S[a][b]=S[b][a]=min(S[a][b],c);   \n      else L[a][b]=L[b][a]=min(L[a][b],c);  \n    }   \n    w=gi();  \n    for(RG int i=1;i<=w;++i) Q[i]=gi();\n    printf(\"%lld\\n\",dfs(n,m,w));  \n  }  \n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint const MAX_N = 210;\nint const MAX_R = 1010;\nint const INF = 1<<29;\nll dpl[MAX_N][MAX_N];\nll dps[MAX_N][MAX_N];\nll dp[MAX_R][MAX_N];\nll N, M, R;\nint z[MAX_R];\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      dpl[i][i] = dps[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n        dpl[i][j] = dpl[j][i] = INF;\n        dps[i][j] = dps[j][i] = INF;\n      }\n    }\n    \n    for(int i=0; i<M; i++) {\n      int x, y, c; char ls;\n      cin >> x >> y >> c >> ls; x--, y--;\n      if(ls == 'L') {\n        dpl[x][y] = dpl[y][x] = c;\n      }\n      else {\n        dps[x][y] = dps[y][x] = c;\n      }\n    }\n    \n    int r; cin >> r;\n    for(int i=0; i<r; i++) {\n      cin >> z[i]; z[i] --;\n    }\n    \n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          dpl[i][j] = min(dpl[i][j], dpl[i][k]+dpl[k][j]);\n          dps[i][j] = min(dps[i][j], dps[i][k]+dps[k][j]);\n        }\n      }\n    }\n\n    fill(dp[0], dp[0]+MAX_R*MAX_N, 0);\n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++)\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s] + dpl[z[i-1]][s] + dps[s][t] + dpl[t][z[i]]);\n          dp[i][t] = min(dp[i][t], dp[i-1][t] + dpl[z[i-1]][z[i]]);\n        }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(n,n,INF);\n        auto Sd = vectors(n,n,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(200+1,200+1,INF);\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define ve vector\nconst ll INF=0x3f3f3f3f3f3f;\n\nvoid floyd(vector<vector<ll>> &a,ll n){\n\tfor (ll i = 1; i <= n; i++) {\n\t\tfor (ll j = 1; j <= n; j++) {\n\t\t\tfor (ll k = 1; k <= n; k++) {\n\t\t\t\ta[k][j]=a[j][k]=min(a[j][i]+a[i][k],a[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tll n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0 && m==0)break;\n\t\tvector<vector<ll>> s(n+1,vector<ll>(n+1,INF));\n\t\tfor (ll i = 1; i <= n; i++) {\n\t\t\ts[i][i]=0;\n\t\t}\n\t\tvector<vector<ll>> l=s;\n\t\tfor (ll i = 0; i < m; i++){\n\t\t\tll x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='S'){\n\t\t\t\ts[y][x]=s[x][y]=min(s[x][y],t);\n\t\t\t}\n\t\t\telse l[y][x]=l[x][y]=min(l[x][y],t);\n\t\t}\n\t\tfloyd(l,n);\n\t\tfloyd(s,n);\n\t\tll r;\n\t\tcin>>r;\n\t\tvector<ll> z;\n\t\tfor (ll i = 0; i < r; i++){\n\t\t\tll t;\n\t\t\tcin>>t;\n\t\t\tz.push_back(t);\n\t\t}\n\t\tve<ve<ll>> dp(r,ve<ll>(n+1,INF));\n\t\tdp[0][z[0]]=0;\n\t\tfor (ll i = 1; i <= r-1; i++) {\n\t\t\tfor (ll j = 1; j <= n; j++) {\n\t\t\t\tfor (ll k = 1; k <= n; k++) {\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ret=INF;\n\t\tfor(ll i=1;i<=n;i++)ret=min(ret,dp[r-1][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<ll,P> State;\n\nconst ll INF = 1001001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Edge{\n    int to, cost;\n};\n\nll dl[200][200], ds[200][200], dp[1000][200];\nint N, M, R;\nint Z[1000];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        \n        REP(i, 200){\n            REP(j, 200){\n                if(i == j){\n                    dl[i][j] = 0;\n                    ds[i][j] = 0;\n                }else{\n                    dl[i][j] = INF;\n                    ds[i][j] = INF;\n                }\n            }\n        }\n\n        REP(i, M){\n            int from, to, cost;\n            char c;\n            std::cin >> from >> to >> cost >> c;\n            from--; to--;\n\n            if(c == 'L'){\n                dl[from][to] = std::min(dl[from][to], static_cast<ll>(cost));\n                dl[to][from] = std::min(dl[to][from], static_cast<ll>(cost));\n            }else if(c == 'S'){\n                ds[from][to] = std::min(ds[from][to], static_cast<ll>(cost));\n                ds[to][from] = std::min(ds[to][from], static_cast<ll>(cost));\n            }\n        }\n\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    dl[i][j] = std::min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = std::min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        std::cin >> R;\n        REP(i, R){\n            std::cin >> Z[i];\n            Z[i]--;\n        }\n\n        REP(i, 1000){\n            REP(j, 200){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][Z[0]] = 0;\n        \n        REP(i, R-1){\n            REP(j, N){\n                REP(k, N){\n                    dp[i+1][j] = std::min(dp[i+1][j], dp[i][k] + dl[Z[i]][k] + ds[k][j] + dl[j][Z[i+1]]);\n                }\n            }\n        }\n\n        ll res = INF;\n        REP(i, N){\n            res = std::min(res, dp[R-1][i]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tLL n,m;\n\t\tstatic LL ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n\t\tstatic LL sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n\t\t\n\t\tscanf(\"%I64d%I64d\",&n,&m); if(n==0&&m==0)break;\n\t\trep(i,m){\n\t\t\tLL x,y,t; char sl;\n\t\t\tscanf(\"%I64d%I64d%I64d %c\",&x,&y,&t,&sl);\n\t\t\tif(sl=='L'){\n\t\t\t\tld[x][y]=t;\n\t\t\t\tld[y][x]=t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsd[x][y]=t;\n\t\t\t\tsd[y][x]=t;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n\t\trep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n\t\t\n\t\t/*rep1(i,n){\n\t\t\trep1(j,n){\n\t\t\t\tcout<<sd[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\tLL r,z;\n\t\tstatic LL dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n\t\t\n\t\tscanf(\"%I64d\",&r);\n\t\tscanf(\"%I64d\",&z);\n\t\tdp[0][z]=0;\n\t\t\n\t\tLL ret=INF;\n\t\trep1(i,r-1){\n\t\t\tscanf(\"%I64d\",&z);\n\t\t\trep1(j,n){\n\t\t\t\tif(ld[j][z]!=INF){\n\t\t\t\t\trep1(k,n){\n\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+sd[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i!=r-1){\n\t\t\t\t\t\tif(dp[i][j]!=INF)dp[i][j]+=2*ld[j][z];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j]+=ld[j][z];\n\t\t\t\t\t\tret=min(ret,dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%I64d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j][k]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  int n, m;\n  cin >> n >> m;\n\n  vector< vector<int> > l, s;\n  l.resize(n);\n  s.resize(n);\n \n  int x, y, t;\n  char sl;\n\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  l[i].push_back(INF);\n\t  s[i].push_back(INF);\n\t}\n  }\n\n  for(int i = 0; i < n; i++){\n\tl[i][i] = 0;\n\ts[i][i] = 0;\n  }\n\n  for(int i = 0; i < m; i++){\n\tcin >> x >> y >> t >> sl;\n\tif(sl == 'L'){\n\t  l[x-1][y-1] = t;\n\t  l[y-1][x-1] = t;\n\t}\n\telse{\n\t  s[x-1][y-1] = t;\n\t  s[y-1][x-1] = t;\n\t}\n  }\n\n  solve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n  int r;\n  cin >> r;\n\n  vector<int> root;\n  for(int i = 0; i < r; i++){\n\tint area;\n\tcin >> area;\n\troot.push_back(area-1);\n  } \n\n  cout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\nconst int inf=(int)1e9;\nconst double PI=acos(-1.0);\n  \n  \n  \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        ll land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<201;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;ll t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=min(sea[x][y],t);\n        sea[y][x]=min(sea[x][y],t);\n      }else{\n        land[x][y]=min(sea[x][y],t);\n        land[y][x]=min(sea[x][y],t);\n      }\n    }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    ldp[i][j]=min(ldp[i][k]+ldp[k][j],ldp[i][j]);\n                    sdp[i][j]=min(sdp[i][k]+sdp[k][j],sdp[i][j]);\n                }\n            }\n        }\n        int r;cin>>r;\n        int a[1001];\n        for(int i=0;i<r;i++){\n            cin>>a[i];\n            a[i]--;\n        }\n        int dp[1001][201];\n        for(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n        dp[0][a[0]]=0;\n        for(int i=0;i<r-1;i++){\n            for(int j=0;j<n;j++){\n                if(dp[i][j]==inf)continue;\n                for(int k=0;k<n;k++){\n                    dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][j]+sdp[j][k]+ldp[k][a[i+1]]);\n                    if(j==k)dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][a[i+1]]);\n                }\n            }\n        }\n        /*for(int i=0;i<r;i++){\n            for(int j=0;j<n;j++){\n                cerr<<dp[i][j]<<\" \";\n            }\n            cerr<<\"\\n\";\n        }*/\n        int ans=inf;\n        for(int i=0;i<n;i++){\n            ans=min(ans,dp[r-1][i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+2][NMAX+2];\n\tll sdp[NMAX+2][NMAX+2];\n\tll dp[NMAX+2][RMAX+2];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=min(ldp[x][y],t);\n\t\t\t\tldp[y][x]=min(ldp[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=min(sdp[x][y],t);\n\t\t\t\tsdp[y][x]=min(sdp[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=R;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tif(j==k) dp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t\telse dp[j][i]=min(dp[j][i],dp[k][i-1]+ldp[bzi][zi]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 1e15\n\nint main(void){\n  \n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int x, y;\n    long long t;\n    string sl;\n    vector<vector<long long int> > Lmatrix(n, vector<long long int>(n, INF));\n    vector<vector<long long int> > Smatrix(n, vector<long long int>(n, INF));\n\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      --x;\n      --y;\n      if(sl == \"L\"){\n        Lmatrix[x][y] = min(Lmatrix[x][y], t);\n        Lmatrix[y][x] = min(Lmatrix[y][x], t);\n      }\n      else{\n        Smatrix[x][y] = min(Smatrix[x][y], t);\n        Smatrix[y][x] = min(Smatrix[y][x], t);    \n      }\n    }\n\n    // ???????????£???\n    for(int i = 0; i < n; i++)\n      Lmatrix[i][i] = Smatrix[i][i] = 0;\n    \n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          Lmatrix[i][j] = min(Lmatrix[i][j], Lmatrix[i][k] + Lmatrix[k][j]);\n          Smatrix[i][j] = min(Smatrix[i][j], Smatrix[i][k] + Smatrix[k][j]);\n        }\n      }\n    }\n    \n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){\n      cin >> z[i];\n      --z[i];\n    }\n\n    // result[i][j]: i?????????????§?????????????j???????????´????????????????????§???????°??????????\n    vector<vector<long long int> > result(r, vector<long long int>(n, INF));\n    result[0][z[0]] = 0;\n    \n    // z[i]??????z[i + 1]????§????????????????m1??????m2?????§???????????????     \n    for(int i = 0; i < r - 1; i++){\n      int start = z[i];\n      int goal = z[i + 1];\n      for(int j = 0; j < n; j++)\n        result[i + 1][j] = result[i][j] + Lmatrix[start][goal];\n      \n      for(int m1 = 0; m1 < n; m1++){\n        for(int m2 = 0; m2 < n; m2++){\n          long long int cost = result[i][m1] + Lmatrix[start][m1] + Smatrix[m1][m2] + Lmatrix[m2][goal];          \n          result[i + 1][m2] = min(result[i + 1][m2], cost);\n        }\n      }\n    }\n\n    long long int ans = INF;\n    for(int i = 0; i < n; i++){ ans = min(ans, result[r - 1][i]); }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nint n,m,r;\nvi route;\nvvi L,S;\n\nint solve(){\n    vvi dp(r,vi(n,INF));\n    dp[0][0]=0;\n        //i番目の集配が終了した時点で、頂点jに船を乗り捨てているときの累計コスト\n    rep(p,r-1){\n        int s=route[p],t=route[p+1];\n        rep(i,n)rep(j,n){\n            //cout<<s<<\"->\"<<i<<\"->\"<<j<<\"->\"<<t<<endl;\n            //cout<<vi{dp[p][i],L[s][i],S[i][j],L[j][t]}<<endl;\n            if(dp[p][i]!=INF and L[s][i]!=INF and S[i][j]!=INF and L[j][t]!=INF){\n                dp[p+1][j]=min(dp[p+1][j],dp[p][i]+L[s][i]+S[i][j]+L[j][t]);\n            }\n        }\n        //cout<<p+1<<\":\"<<dp[p+1]<<endl;\n    }\n    return *min_element(all(dp[r-1]));\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\twhile(cin>>n>>m,n){\n\t    L=vvi(n,vi(n,INF));\n\t    S=vvi(n,vi(n,INF));\n\t    rep(_,m){\n\t        int x,y,t; char c;\n\t        cin>>x>>y>>t>>c;\n\t        x--;y--;\n\t        (c=='L'?L:S)[x][y]=(c=='L'?L:S)[y][x]=t;\n\t    }\n\t    rep(k,n)rep(i,n)rep(j,n)if(i!=j){\n\t        if(L[i][k]!=INF&&L[k][j]!=INF)\n\t            L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t        if(S[i][k]!=INF&&S[k][j]!=INF)\n\t            S[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t    }else L[i][i]=S[i][i]=0;\n\t    cin>>r;\n\t    route.resize(r);\n\t    rep(i,r){\n\t        cin>>route[i];\n\t        route[i]--;\n\t    }\n\t    cout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint d1[205][205], d2[205][205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, n) REP(j, n) {\n      d1[i][j] = i==j?0:INF;\n      d2[i][j] = i==j?0:INF;\n    }\n    REP(i, m) {\n      int x, y, c;\n      char t;\n      cin >> x >> y >> c >> t;\n      x--, y--;\n      if(t == 'L') {\n        d1[x][y] = d1[y][x] = c;\n      } else {\n        d2[x][y] = d2[y][x] = c;\n      }\n    }\n\n    REP(k, n) REP(i, n) REP(j, n) {\n      chmin(d1[i][j], d1[i][k] + d1[k][j]);\n      chmin(d2[i][j], d2[i][k] + d2[k][j]);\n    }\n\n    int r;\n    cin >> r;\n    VI cur(n, INF), nxt(n, INF);\n    int now;\n    cin >> now; now--;\n    REP(i, n) cur[i] = i==now?0:INF;\n    REP(i, r-1) {\n      int g;\n      cin >> g; g--;\n\n      REP(j, n) {\n        // (now, j) からスタートする\n        REP(k, n) {\n          // (g, k) を目的とする\n          // 陸でnow->j 船でj->k 陸でk->g\n          chmin(nxt[k], cur[j] + d1[now][j] + d2[j][k] + d1[k][g]);\n        }\n      }\n\n      cur = nxt;\n      nxt.assign(n, INF);\n      now = g;\n    }\n\n    int ret = INF;\n    REP(i, n) chmin(ret, cur[i]);\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const MAX_R = 1010;\nint const MAX_N = 210;\nint const INF = 1<<29;\n\nint dl[MAX_N][MAX_N];\nint ds[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];\nint z[MAX_R];\nint N, M, R;\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dl[x][y] = dl[y][x] = INF;\n        ds[x][y] = ds[y][x] = INF;\n      }\n      dl[x][y] = dl[y][x] = ds[x][y] = ds[y][x] = 0;\n    }\n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dl[x][y] = dl[y][x] = t;\n      }\n      else {\n        ds[x][y] = ds[y][x] = t;\n      }\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k]+dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j]);\n        }\n    \n    cin >> R;\n    for(int i=0; i<R; i++) { cin >> z[i]; z[i]--; }\n    \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    \n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++) {\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s]+dl[z[i-1]][s]+ds[s][t]+dl[t][z[i]]);\n        }\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nconstexpr ll LL_INF = 1e15;\n\nll dist1[200][200], dist2[200][200];\nll dp[1000][200];\n\n/*\n * 2 <= N <= 200\n * 1 <= M <= 10000\n * 1 <= xi, yi <= N\n * 1 <= ti <= 1000\n * 1 <= R <= 1000\n * 1 <= zi <= N\n */\n\nint main(void) {\n    while (true) {\n        int i, j, k, n, m;\n        scanf(\"%d%d\",&n,&m);\n        if (n == 0 && m == 0) break;\n        REP (i,n) REP (j,n) {\n            dist1[i][j] = i == j ? 0 : LL_INF;\n            dist2[i][j] = i == j ? 0 : LL_INF;\n        }\n        REP (i,m) {\n            int x, y, t;\n            char sl;\n            scanf(\"%d %d %d %c\",&x,&y,&t,&sl);\n            x--; y--;\n            if (sl == 'S') {\n                dist1[x][y] = min<ll>(dist1[x][y],t);\n                dist1[y][x] = dist1[x][y];\n            }\n            else {\n                dist2[x][y] = min<ll>(dist2[x][y],t);\n                dist2[y][x] = dist2[x][y];\n            }\n        }\n        REP (k,n) REP (i,n) REP (j,n) {\n            dist1[i][j] = min(dist1[i][j],dist1[i][k] + dist1[k][j]);\n            dist2[i][j] = min(dist2[i][j],dist2[i][k] + dist2[k][j]);\n        }\n        int r;\n        scanf(\"%d\",&r);\n        int pre;\n        scanf(\"%d\",&pre);\n        pre--;\n        REP (i,r) REP (j,n) dp[i][j] = LL_INF;\n        dp[0][pre] = 0;\n        REP (i,r-1) {\n            int x;\n            scanf(\"%d\",&x);\n            x--;\n            REP (j,n) {\n                dp[i+1][j] = min(dp[i+1][j],dp[i][j] + dist2[pre][x]);\n                REP (k,n) dp[i+1][j] = min(dp[i+1][j],dp[i][k] + dist2[pre][k] + dist1[k][j] + dist2[j][x]);\n            }\n            pre = x;\n        }\n        ll ans = LL_INF;\n        REP (j,n) ans = min(ans,dp[r-1][j]);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 210;\nconst int R = 1010;\nll ds[N][N], dl[N][N];\n\nll dp[R][N];\n\nll inf = 1e16;\nconst int DEBUG = 0;\n\nint main(void){\n  int n, m;\n  while (cin >> n >> m && n) {\n    REP(i, 0, n) {\n      REP(j, 0, n) {\n\tds[i][j] = dl[i][j] = i == j ? 0 : inf;\n      }\n    }\n    REP(loop_cnt, 0, m) {\n      int i, j;\n      ll t;\n      char sl;\n      cin >> i >> j >> t >> sl;\n      i--, j--;\n      if (sl == 'S') {\n\tds[i][j] = min(ds[i][j], t);\n\tds[j][i] = min(ds[j][i], t);\n      } else {\n\tdl[i][j] = min(dl[i][j], t);\n\tdl[j][i] = min(dl[j][i], t);\n      }\n    }\n    REP(k, 0, n) {\n      REP(i, 0, n) {\n\tREP(j, 0, n) {\n\t  ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t  dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t}\n      }\n    }\n    int r;\n    cin >> r;\n    VI z(r);\n    REP(i, 0, r) {\n      cin >> z[i];\n      z[i]--;\n    }\n    REP(i, 0, R) {\n      REP(j, 0, N) {\n\tdp[i][j] = inf;\n      }\n    }\n    dp[0][z[0]] = 0;\n    REP(i, 1, r) {\n      REP(j, 0, n) {\n\tREP(k, 0, n) {\n\t  ll sdist = dl[z[i - 1]][j] + ds[j][k] + dl[k][z[i]];\n\t  dp[i][k] = min(dp[i][k], dp[i - 1][j] + sdist);\n\t  if (j == k) {\n\t    ll ldist = dl[z[i - 1]][z[i]];\n\t    dp[i][j] = min(dp[i][j], dp[i - 1][j] + ldist);\n\t  }\n\t  if (DEBUG) {\n\t    cerr << \"dp[\" << i << \",\" << k << \"]=\" << dp[i][k] << endl;\n\t  }\n\t}\n      }\n    }\n    ll mi = inf;\n    REP(i, 0, n) {\n      mi = min(mi, dp[r - 1][i]);\n    }\n    cout << mi << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 210;\nconst int MAX_R = 1010;\nconst int INF = 1e9 + 7;\n\nclass E{\n  public:\n    int t, c, b;\n    E(){}\n    E(int _t, int _c, int _b){ t = _t; c = _c; b = _b; }\n};\n\nclass C{\n  public:\n    int t, n, s, c;\n    C();\n    C(int _t, int _n, int _s, int _c) { t = _t; n = _n; s = _s; c = _c; }\n    bool operator > (const C &_) const { return t != _.t ? t > _.t : c < _.c; }\n};\n\nint closed[MAX_N][MAX_N][MAX_R];\n\nint solve(vector< vector<E> > &G, vector<int> &v, int N, int R){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(0, 0, 0, 1));\n  REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_R) closed[i][j][k] = INF;\n  closed[v[0]][v[0]][0] = 0;\n  while(!open.empty()){\n    C tmp = open.top(); open.pop();\n    int n = tmp.n, t = tmp.t, s = tmp.s, c = tmp.c;\n    if(c >= v.size()) continue;\n    REP(i, G[n].size()){\n      int next = G[n][i].t, cost = G[n][i].c, f = G[n][i].b;\n      int nc = (v[c] == next ? c + 1 : c), nt = t + cost, ns = (f ? next : s);\n      if((f && s != n) || closed[next][ns][nc] <= nt) continue;\n      closed[next][ns][nc] = nt;\n      open.push(C(nt, next, ns, nc));\n    }\n  }\n  int ans = INF;\n  REP(i, N) ans = min(ans, closed[v[N - 1]][i][R]);\n  return ans;\n}\n\nint main() {\n  int N, M;\n  while(cin >>N >>M && N){\n    vector< vector<E> > G(N);\n    REP(i, M){\n      int f, t, c; char a;\n      cin >>f >>t >>c >>a;\n      --f; --t;\n      G[f].push_back(E(t, c, (a == 'L' ? 0 : 1)));\n      G[t].push_back(E(f, c, (a == 'L' ? 0 : 1)));\n    }\n    int R; cin >>R;\n    vector<int> v(R);\n    REP(i, R) { cin >>v[i]; --v[i]; }\n    cout <<solve(G, v, N, R) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 1010;\nconst ll INF = 0x1f1f1f1f1f1f1f1f;\nll odr[maxn],cost[maxn][maxn],sea_path[maxn][maxn],land_path[maxn][maxn],n,m,w;\n\nvoid init() {\n    memset(cost,INF, sizeof(cost));\n    memset(sea_path,INF, sizeof(sea_path));\n    memset(land_path,INF, sizeof(land_path));\n    char s[5];\n    for(int i=0;i<m;i++) {\n        ll a,b,c;\n        scanf(\"%lld%lld%lld%s\",&a,&b,&c,s);\n        if(s[0] == 'S')\n            sea_path[a][b] = sea_path[b][a] = min(sea_path[a][b],c);\n        else\n            land_path[a][b] = land_path[b][a] = min(land_path[a][b],c);\n    }\n\n    scanf(\"%lld\",&w);\n    for(int i=1;i<=w;i++)\n        scanf(\"%lld\",&odr[i]);\n\n}\n\nvoid Floyd() {\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++) {\n                sea_path[i][j] = min(sea_path[i][j],sea_path[i][k]+sea_path[k][j]);\n                land_path[i][j] = min(land_path[i][j],land_path[i][k]+land_path[k][j]);\n            }\n}\n\nvoid get_ans() {\n    for(int i=1;i<=n;i++)\n        sea_path[i][i] = land_path[i][i] = 0;\n    cost[1][odr[1]] = 0;\n    for(int i=1;i<=w;i++) {\n        for(int j=1;j<=n;j++) {\n            cost[i][j] = min(cost[i][j],cost[i-1][j]+land_path[odr[i-1]][odr[i]]);\n            for(int k=1;k<=n;k++) {\n                cost[i][k] = min(cost[i][k],cost[i-1][j]+land_path[odr[i-1]][j]+sea_path[j][k]+land_path[k][odr[i]]);\n            }\n        }\n    }\n    ll Min = 1e12;\n    for(int i=1;i<=n;i++)\n        Min = min(cost[w][i],Min);\n    printf(\"%lld\\n\",Min);\n}\n\nint main() {\n    while(scanf(\"%lld%lld\",&n,&m) && n+m) {\n        init();\n        Floyd();\n        get_ans();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\twhile (cin >> n >> m && (n&&m)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tfor (int i = 1; i <= 200; i++)for (int j = 0; j < r; j++)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tint ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dp[1001][200];\nint L[200][200];\nint S[200][200];\nchar str[2];\nint z[1000];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tL[i][j]=S[i][j]=111111111;\n\t\tfor(int i=0;i<a;i++)L[i][i]=S[i][i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint c,d,e;\n\t\t\tscanf(\"%d%d%d%s\",&c,&d,&e,str);\n\t\t\tc--;d--;\n\t\t\tif(str[0]=='S')S[c][d]=S[d][c]=min(S[c][d],e);\n\t\t\telse L[c][d]=L[d][c]=min(L[c][d],e);\n\t\t}\n\t\tfor(int k=0;k<a;k++)\n\t\t\tfor(int i=0;i<a;i++)\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t}\n\t\tint r;\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=0;i<r;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tdp[i][j]=2111111111;\n\t\tfor(int i=0;i<r;i++){scanf(\"%d\",z+i);z[i]--;}\n\t\tdp[0][z[0]]=0;\n\t\tfor(int i=0;i<r-1;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(dp[i][j]>=2111111111)continue;\n\t\t\t\tif(L[z[i]][z[i+1]]<111111111)dp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[z[i]][z[i+1]]);\n\t\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\t\tif(L[z[i]][j]<111111111&&S[j][k]<111111111&&L[k][z[i+1]]<111111111)dp[i+1][k]=min(dp[i+1][k],dp[i][j]+L[z[i]][j]+S[j][k]+L[k][z[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=2111111111;\n\t\tfor(int i=0;i<a;i++)ret=min(ret,dp[r-1][i]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000000\nint d[200][200];\nint se[200][200];\nint dp[2][200];\nint z[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\td[i][j]=INF;\n\t\tse[i][j]=INF;\n\t\tif(i==j){\n\t\t\td[i][j]=0;\n\t\t\tse[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar p;\n\t\tscanf(\"%d %d %d %c\",&a,&b,&c,&p);\n\t\ta--;b--;\n\t\tif(p=='L'){\n\t\t\td[a][b]=min(d[a][b],c);\n\t\t\td[b][a]=min(d[b][a],c);\n\t\t}\n\t\tif(p=='S'){\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++){\n\t\tscanf(\"%d\",&z[i]);\n\t\tz[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][z[0]]=0;\n\tfor(i=1;i<p;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i%2][j]=INF;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][k]+d[z[i-1]][k]+se[k][j]+d[j][z[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+d[z[i-1]][z[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(p+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\n\nint g[201][201][2];\nint dp[1010][201];\nint dist[201][201];\nint diss[201][201];\n\nint main()\n{\n\tint n, m;\n\twhile(cin>>n>>m, n||m) {\n\t\tfill(g[0][0], g[201][0], inf);\n\t\tfill(dist[0], dist[201], inf);\n\t\tfill(diss[0], diss[201], inf);\n\t\trep(i,0,m) {\n\t\t\tint a,b,c;\n\t\t\tchar d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--; b--;\n\t\t\tif (d=='L') {\n\t\t\t\tif (c < g[a][b][0]) {\n\t\t\t\t\tg[a][b][0] = c;\n\t\t\t\t\tg[b][a][0] = c;\n\t\t\t\t\tdist[a][b] = c;\n\t\t\t\t\tdist[b][a] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c < g[a][b][1]) {\n\t\t\t\t\tg[a][b][1] = c;\n\t\t\t\t\tg[b][a][1] = c;\n\t\t\t\t\tdiss[a][b] = c;\n\t\t\t\t\tdiss[b][a] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r; cin>>r;\n\t\tVi v;\n\t\trep(i,0,r) {\n\t\t\tint t; cin>>t;\n\t\t\tt--;\n\t\t\tv.pb(t);\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d g[i][j][1]=%d\\n\",i,j,g[i][j][1]);\n\n\t\t// ????????????????????????????????¢\n\t\trep(k,0,n) rep(i,0,n) rep(j,0,n) {\n\t\t\tdist[k][k] = 0;\n\t\t\tif (g[i][k][0]==inf || g[k][j][0]==inf) continue;\n\t\t\tif (dist[i][j] > dist[i][k] + dist[k][j]) {\n\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d dist[i][j]=%d\\n\",i,j,dist[i][j]);\n\n\t\t// ?°´?????????????????????????????¢\n\t\trep(k,0,n) rep(i,0,n) rep(j,0,n) {\n\t\t\tdiss[k][k] = 0;\n\t\t\tif (g[i][k][1]==inf || g[k][j][1]==inf) continue;\n\t\t\tif (diss[i][j] > diss[i][k] + diss[k][j]) {\n\t\t\t\tdiss[i][j] = diss[i][k] + diss[k][j];\n\t\t\t\tdiss[j][i] = diss[i][j];\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d diss[i][j]=%d\\n\",i,j,diss[i][j]);\n\n\t\tfill(dp[0], dp[1010], inf);\n\t\tdp[0][v[0]] = 0;\n\t\trep(i, 0, r - 1) {\n\t\t\tint from = v[i], to = v[i + 1];\n\t\t\t//debug(i);\n\t\t\trep(j, 0, n) {\n\t\t\t\tif (dp[i][j] == inf) continue;\n\t\t\t\t// ??????????????????\n\t\t\t\tif (dist[from][to] != inf)\n\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dist[from][to]);\n\t\t\t\t// ????????????\n\t\t\t\trep(k, 0, n) {\n\t\t\t\t\tif (dist[from][j] == inf || diss[j][k] == inf || dist[k][to] == inf) continue; // ????????????????????§k?????§????????§to?????§\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[from][j] + diss[j][k] + dist[k][to]);\n\t\t\t\t\t//printf(\"from=%d j=%d k=%d to=%d | dp[i][j]=%d dist[from][j]=%d diss[j][k]=%d dist[k][to]=%d\\n\",\n\t\t\t\t\t\t//from, j, k, to, dp[i][j], dist[from][j], diss[j][k], dist[k][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\t\trep(i,0,n) ans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200;\nconst int MAX_R = 1000;\n\nconst int INF = 1 << 28;\n\n/* typedef */\n\n/* global variables */\n\nint n, m, r;\nint zs[MAX_R];\nint lds[MAX_N][MAX_N], sds[MAX_N][MAX_N];\nint dists[2][MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0) break;\n\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < n; j++) lds[i][j] = sds[i][j] = INF;\n      lds[i][i] = sds[i][i] = 0;\n    }\n\n    for (int i = 0; i < m; i++) {\n      int x, y, t;\n      string sl;\n      cin >> x >> y >> t >> sl;\n      x--, y--;\n\n      if (sl == \"L\")\n\tlds[x][y] = lds[y][x] = t;\n      else\n\tsds[x][y] = sds[y][x] = t;\n    }\n\n    cin >> r;\n    for (int i = 0; i < r; i++) cin >> zs[i], zs[i]--;\n\n    for (int k = 0; k < n; k++)\n      for (int i = 0; i < n; i++)\n\tfor (int j = 0; j < n; j++) {\n\t  int ld = lds[i][k] + lds[k][j];\n\t  if (lds[i][j] > ld) lds[i][j] = ld;\n\t  int sd = sds[i][k] + sds[k][j];\n\t  if (sds[i][j] > sd) sds[i][j] = sd;\n\t}\n\n    int cur = 0, nxt = 1, z0 = zs[0];\n    for (int i = 0; i < n; i++) dists[cur][i] = INF;\n    dists[cur][z0] = 0;\n\n    for (int ri = 1; ri < r; ri++) {\n      int z1 = zs[ri];\n      for (int i = 0; i < n; i++) dists[nxt][i] = INF;\n\n      for (int i = 0; i < n; i++) {\n\tif (dists[cur][i] >= INF) continue;\n\tfor (int j = 0; j < n; j++) {\n\t  int d =\n\t    dists[cur][i] +\n\t    ((i == j) ? lds[z0][z1] : lds[z0][i] + sds[i][j] + lds[j][z1]);\n\t  if (dists[nxt][j] > d) dists[nxt][j] = d;\n\t}\n      }\n\n      cur ^= 1;\n      nxt ^= 1;\n      z0 = z1;\n    }\n\n    int min_d = INF;\n    for (int i = 0; i < n; i++)\n      if (min_d > dists[cur][i]) min_d = dists[cur][i];\n\n    cout << min_d << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 201\n#define MAX_R 1001\n#define INF 1<<28\n\nint land[MAX_N][MAX_N];  // 陸路のみを使った最短経路長\nint sea[MAX_N][MAX_N];   // 海路のみを使った最短経路長\n\nint z[MAX_R];\n\nint N, M;\nint R;\n\nbool init() {\n    cin >> N >> M;\n    if (N == 0 && M == 0) return false;\n\n    for (int i = 1; i <= N; i++) \n        for (int j = 1; j <= N; j++) {\n            if (i == j) {\n                land[i][j] = 0;\n                sea[i][j] = 0;\n            } else {\n                land[i][j] = INF;\n                sea[i][j] = INF;\n            }\n        }\n\n    for (int i = 0; i < M; i++) {\n        int x, y, t; char c;\n        cin >> x >> y >> t >> c;\n        if (c == 'L') {\n            land[x][y] = t;\n            land[y][x] = t;\n        } else {\n            sea[x][y] = t;\n            sea[y][x] = t;\n        }\n    }\n\n//    for (int i = 1; i <= N; i++) {\n//        for (int j = 1; j <= N; j++) {\n//            cout << land[i][j] << ' ';\n//        }\n//        cout << endl;\n//    }\n\n    for (int k = 1; k <= N; k++) \n        for (int i = 1; i <= N; i++) \n            for (int j = 1; j <= N; j++) {\n                land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n                sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            }\n\n    cin >> R;\n    for (int i = 0; i < R; i++) \n        cin >> z[i];\n\n    return true;\n}\n\nint main() {\n    while (init()) {\n        int dp[R][N+1]; // dp[p][q] -- p番目まで集配, 町qに船\n        for (int i = 0; i < R; i++) for (int j = 0; j <= N; j++) dp[i][j] = INF;\n        dp[0][z[0]] = 0;\n        for (int i = 1; i < R; i++) {\n            // 陸路のみで移動\n            for (int j = 1; j <= N; j++) {\n                if (dp[i-1][j] != INF) {\n                    dp[i][j] = dp[i-1][j] + land[z[i-1]][z[i]];\n                } \n            }\n            // 海路を使用\n            //\n            // jまで船にのるため戻り, 船でkに行く.\n            // その後陸路でz[i]に向かう.\n            for (int j = 1; j <= N; j++) {\n                for (int k = 1; k <= N; k++) {\n                    dp[i][k] = \n                        min(dp[i][k], \n                            dp[i-1][j] + land[z[i-1]][j] + sea[j][k] + land[k][z[i]]);\n                }\n            }\n        }\n\n//        for (int i = 1; i <= N; i++) {\n//            for (int j = 1; j <= N; j++) {\n//                cout << land[i][j] << ' ';\n//            }\n//            cout << endl;\n//        }\n\n//        for (int i = 0; i < R; i++) {\n//            for (int j = 1; j <= N; j++) {\n//                cout << dp[i][j] << ' ';\n//            }\n//            cout << endl;\n//        }\n\n        int min_time = INF;\n        for (int i = 1; i <= N; i++) {\n            min_time = min(min_time, dp[R-1][i]);\n        }\n        cout << min_time << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 205;\nconst int MAX_R = 1005;\n\nint sd[MAX_N][MAX_N];\nint ld[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                sd[i][j] = INF;\n                ld[i][j] = INF;\n            }\n        }\n        rep(i,m){\n            int p,q,r;\n            string s;\n            cin >> p >> q >> r >> s;\n            if(s == \"L\"){\n                ld[p-1][q-1] = r;\n                ld[q-1][p-1] = r;\n            }else{\n                sd[p-1][q-1] = r;\n                sd[q-1][p-1] = r;\n            }\n        }\n        rep(i,n){\n            ld[i][i] = 0;\n            sd[i][i] = 0;\n        }\n        for(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tld[i][j] = min(ld[i][j],ld[i][k]+ld[k][j]);\n                    sd[i][j] = min(sd[i][j],sd[i][k]+sd[k][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n        int R;\n        cin >> R;\n        vector<int> vec(R);\n        rep(i,R){\n            cin >> vec[i];\n            vec[i]--;\n        }\n        rep(i,R){\n            rep(j,n){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][vec[0]] = 0;\n        rep(i,R-1){\n            rep(j,n){\n                rep(k,n){\n                    if(k == j){\n                        dp[i+1][j] = min((ll)dp[i+1][j],(ll)dp[i][j]+ld[vec[i]][vec[i+1]]);\n                    }else{\n                        dp[i+1][j] = min((ll)dp[i+1][j],(ll)dp[i][k]+ld[vec[i]][k]+sd[k][j]+ld[j][vec[i+1]]);\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n){\n            ans = min(ans,dp[R-1][i]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[50][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int j=0;j<200;j++){\n\t\tfor(int k=0;k<200;k++){\n\t\t\tcost[0][j][k]=INF;\n\t\t}\n\t}\n\tmemset(reset,false,sizeof(reset));\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(0,0))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\treturn nc;\n\t\t}\n\t\tif(now==rt[np]){\n\t\t\tnp++;\n\t\t\tif(reset[np]==false){\n\t\t\t\tfor(int i=0;i<200;i++){\n\t\t\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\t\t\tcost[np%20][i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset[np]=true;\n\t\t\t}\n\t\t}\n\t\tif(cost[np%20][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np%20][e.t][ns]){\n\t\t\t\tcost[np%20][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np%20][e.t][e.t]){\n\t\t\t\t\tcost[np%20][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\nint dp[1001][200];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(dp[0],dp[1001],INF);\n\t   dp[0][now]=0;\n\t    \n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        rep(i,r-1){\n            /*if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }*/\n            rep(j,n){\n                cmin(dp[i+1][j],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][k],dp[i][j] + Ld[v[i]][j] + Sd[j][k] + Ld[k][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint cost[201][201][201];\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nclass state{\npublic:\n\tint now,cost,ship,done;\n\tstate(int now,int cost,int ship,int done):now(now),cost(cost),done(done),ship(ship){}\n};\n\nbool operator < (state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tfor(int i=0;i<201;i++){\n\t\t\tfor(int j=0;j<201;j++)\n\t\t\t\tfor(int z=0;z<201;z++)\n\t\t\t\t\tcost[i][j][z]=1000000000;\n\t\t}\n\n\t\tvector<vector<edge> > grand(201);\n\t\tvector<vector<edge> >sea(201);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint cost,in,out; \n\t\t\tchar kind;\n\t\t\tcin>>in>>out>>cost>>kind;\n\t\t\tif(kind=='L'){\n\t\t\t\tgrand[in].push_back(edge(out,cost));\n\t\t\t\tgrand[out].push_back(edge(in,cost));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsea[in].push_back(edge(out,cost));\n\t\t\t\tsea[out].push_back(edge(in,cost));\n\t\t\t}\n\t\t}\n\t\tint first,n;\n\t\tcin>>n;\n\t\tvector<int> dest(n-1);\n\t\tcin>>first;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tcin>>dest[i];\n\t\t}\n\t\t\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(first,0,first,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate t=Q.top(); Q.pop();\n\t\t\t\n\t\t\tif(t.now==dest[t.done]) t.done++;\n//\t\t\tcout<<t.now<<\" \"<<t.ship<<\" \"<<t.cost<<\" \"<<t.done<<endl;\n\t\t\tif(t.cost>=cost[t.now][t.ship][t.done]) continue;\n\t\t\tif(t.done==n-1){cout<<t.cost<<endl; break;}\n\t\t\tcost[t.now][t.ship][t.done]=t.cost;\n\n\n\t\t\tif(t.ship==t.now){\n\t\t\t\tfor(int i=0;i<sea[t.now].size();i++){\n\t\t\t\t\tQ.push(state(sea[t.now][i].to,t.cost+sea[t.now][i].cost,sea[t.now][i].to,t.done));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<grand[t.now].size();i++){\n\t\t\t\tQ.push(state(grand[t.now][i].to,t.cost+grand[t.now][i].cost,t.ship,t.done));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(1001,1001,INF);\n        auto Sd = vectors(1001,1001,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1001,1001,INF);\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,r)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\n\nconst int MAX_V=210;\nll dL[MAX_V][MAX_V];\nll dS[MAX_V][MAX_V];\nint V;\nvoid warshall_floyd(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n  return;\n}\nvoid warshall_floyd2(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n  return;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdL[i][j]=0;\n      else\n\tdL[i][j]=llINF;\n    }\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdS[i][j]=0;\n      else\n\tdS[i][j]=llINF;\n    }\n    V=n;\n    for(int i=0;i<m;i++){\n      ll x,y,t;\n      char s;\n      cin>>x>>y>>t;\n      cin>>s;\n      x--;y--;\n      if(s=='L'){\n\tdL[x][y]=t;\n\tdL[y][x]=t;\n      }else{\n\tdS[x][y]=t;\n\tdS[y][x]=t;\n      }\n    }\n    warshall_floyd();\n    warshall_floyd2();\n    int r;cin>>r;\n    ll dp[r+10][n+10];\n    for(int i=0;i<r+10;i++)\n      for(int j=0;j<n+10;j++)\n\t  dp[i][j]=llINF;\n    int fffff;cin>>fffff;\n    dp[0][fffff-1]=0;\n    int v[r+10];\n    v[0]=fffff-1;\n    for(int i=1;i<r;i++){\n      cin>>v[i];\n      v[i]--;\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\t//if(dp[i-1][j]!=INF){\n\t  for(int k=0;k<n;k++){\n\t    dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[v[i-1]][j]+dS[j][k]+dL[k][v[i]]);\n\t  }\n\t  //}\n      }\n    }\n    ll ans=llINF;\n    for(int j=0;j<n;j++){\n      // cout<<dp[i][j]<<\" \";\n      ans=min(ans,dp[r-1][j]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8;\nconst int MAX_V = 205;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tint riku[MAX_V][MAX_V];\n\t\tint umi[MAX_V][MAX_V];\n\t\tinit(riku);\n\t\tinit(umi);\n\t\trep(i,m){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl[0] == 'L') riku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\telse umi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t}\n\t\twarshallFloyd(riku, n);\n\t\twarshallFloyd(umi, n);\n\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i,r) cin >> z[i];\n\t\tfor(auto& i : z) i--;\n\n\t\tvector<vector<int>> dp(r, vector<int>(n, INF));\n\t\tdp[0][z[0]] = 0;\n\t\trep(i,r - 1){\n\t\t\tint cur = z[i];\n\t\t\tint nxt = z[i + 1];\n\t\t\trep(j,n){\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + riku[cur][nxt]);\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + riku[cur][j] +\n\t\t\t\t\t\t\tumi[j][k] + riku[k][nxt]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,n) cout << dp.back()\n\n\t\tcout << *min_element(all(dp.back())) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst long long inf = 1LL<<55;\nint main()\n{\n  int n,m;\n  while(cin>>n>>m&&n&&m){\n    long long sea[n][n];\n    long long land[n][n];\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if( i!=j ){\n          sea[i][j]=land[i][j]=inf;\n        }else{\n          sea[i][j]=land[i][j]=0;\n        }\n      }\n    }\n    for(int i = 0; i < m; ++i){\n      int x,y;\n      long long t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x;\n      --y;\n      if( sl == 'S' ){\n        sea[x][y]=min(sea[x][y],t);\n        sea[y][x]=min(sea[y][x],t);\n      }else{\n        land[x][y]=min(land[x][y],t);\n        land[y][x]=min(land[y][x],t);\n      }\n    }\n    for(int k=0;k<n;++k){\n      for(int i=0;i<n;++i){\n        for(int j=0;j<n;++j){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    int R;\n    int cur,ship;\n    int prez,z;\n    cin >> R;\n    cin >> z;\n    long long A[R][200][200];\n    --z;\n    cur = ship = z;\n    for(int i = 0; i < R;++i){\n      for(int j = 0; j < 200; ++j){\n        for(int k = 0; k < 200; ++k){\n          A[i][j][k] = inf;\n        }\n      }\n    }\n    A[0][cur][ship] = 0;\n    for(int i = 1; i < R; ++i){\n      prez = z;\n      cin >> z;\n      --z;\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          A[i][z][k] = min( A[i][z][k], A[i-1][prez][j] + land[prez][j] + sea[j][k] + land[k][z] );\n        }\n      }\n    }\n    long long res = inf;\n    for(int i = 0; i < n; ++i){\n      res = min( res, A[R-1][z][i] );\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\nstruct node{\n    int index,boat,next,cost;\n    node(int index,int boat,int next,int cost):index(index),boat(boat),next(next),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nstruct edge{\n\tint lcost,scost;\n\tedge(int lcost,int scost):lcost(lcost),scost(scost){}\n\tedge(){}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\n\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\ntypedef vector<vvi> vvvi;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tstatic edge graph[200][200];\n\t\tREP(i,n)REP(j,n){\n\t\t\tgraph[i][j]=edge(NONE,NONE);\n\t\t}\n        REP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tswitch(sl){\n\t\t\tcase 'S':\n\t\t\t\tgraph[x-1][y-1].scost=t;\n\t\t\t\tgraph[y-1][x-1].scost=t;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tgraph[x-1][y-1].lcost=t;\n\t\t\t\tgraph[y-1][x-1].lcost=t;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n        }\n\t\tint r;\n\t\tcin>>r;\n\t\tvi order(r);\n\t\tREP(i,r){\n\t\t\tcin>>order[i];\n\t\t\torder[i]--;\n\t\t}\t\n        \n        priority_queue<node> q;\n\t\tint neeext=order[0]==0?1:0;\n        q.push(node(0,0,neeext,0));\n\t\tstatic int cost[200][200][1001];\n\t\tREP(i,n)REP(j,n)REP(k,r+1){\n\t\t\tcost[i][j][k]=MAX;\n\t\t}\n        cost[0][0][neeext]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.boat][cnode.next]<cnode.cost){\n                continue;\n            }\n            REP(i,n){\n\t\t\t\tif(i!=cnode.index&&graph[cnode.index][i].lcost!=NONE){\n\t\t\t\t\tint newcost=cnode.cost+graph[cnode.index][i].lcost;\n\t\t\t\t\tint next=cnode.next+(order[cnode.next]==i);\n\t\t\t\t\tif(cost[i][cnode.boat][next]>newcost){\n\t\t\t\t\t\tcost[i][cnode.boat][next]=newcost;\n\t\t\t\t\t\tif(next<r){\n\t\t\t\t\t\t\tq.push(node(i,cnode.boat,next,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n\t\t\t\tif(i!=cnode.index&&graph[cnode.index][i].scost!=NONE&&cnode.boat==cnode.index){\n\t\t\t\t\tint newcost=cnode.cost+graph[cnode.index][i].scost;\n\t\t\t\t\tint next=cnode.next+(order[cnode.next]==i);\n\t\t\t\t\tif(cost[i][i][next]>newcost){\n\t\t\t\t\t\tcost[i][i][next]=newcost;\n\t\t\t\t\t\tif(next<r){\n\t\t\t\t\t\t\tq.push(node(i,i,next,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n            }\n        }\n\t\tint ans=MAX;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tans=min(ans,cost[i][j][r]);\n\t\t\t}\n\t\t}\n        cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll inf=0x1f1f1f1f1f1f1f1f;//?造了一个三倍之后不会溢出的?..... \nconst ll maxn=205;\nll land[maxn][maxn],sea[maxn][maxn],num[maxn],cost[maxn][maxn];\nvoid init(int n)\n{\n\tmemset(land,inf,sizeof(land));\n\tmemset(sea,inf,sizeof(sea));\n\tmemset(cost,inf,sizeof(cost));\n\tfor(ll i=1;i<=n;++i)\n\t{\n\t\tsea[i][i]=land[i][i]=0;\n\t}\n}\nll slove(ll n,ll m,ll w)\n{\n\tfor(ll k=1;k<=n;++k)\n\t{\n\t\tfor(ll i=1;i<=n;++i)\n\t\t{\n\t\t\tfor(ll j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcost[1][num[1]]=0;\n\tfor(ll i=1;i<=w;++i)\n\t{\n\t\tfor(ll j=1;j<=n;++j)\n\t\t{\n\t\t\tcost[i][j]=min(cost[i][j],cost[i-1][j]+land[num[i-1]][num[i]]);\n\t\t\tfor(ll k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tcost[i][k]=min(cost[i][k],\n\t\t\t\tcost[i-1][j]+land[num[i-1]][j]+sea[j][k]+land[k][num[i]]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=inf;\n\tfor(ll i=1;i<=n;++i)\n\t{\n\t\tans=min(ans,cost[w][i]);\n\t}\n\t//return *min_element(cost[w],cost[w]+n+1);\n\treturn ans;\n}\nint main()\n{\n\tll n,m;\n\twhile(scanf(\"%lld%lld\",&n,&m),n|m)\n\t{\n\t\tinit(n);\n\t\tfor(ll i=0;i<m;++i)\n\t\t{\n\t\t\tll a,b,c;char ch[10];\n\t\t\tscanf(\"%lld%lld%lld%s\",&a,&b,&c,ch);\n\t\t\tif(ch[0]=='S')\n\t\t\t{\n\t\t\t\tsea[a][b]=sea[b][a]=min(sea[a][b],c);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tland[a][b]=land[b][a]=min(land[a][b],c);\n\t\t\t}\n\t\t}\n\t\tll w;\n\t\tscanf(\"%lld\",&w);\n\t\tfor(ll i=1;i<=w;++i)\n\t\t{\n\t\t\tscanf(\"%lld\",&num[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",slove(n,m,w));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define INT_MAX 100000\n\nusing namespace std;\n\nint lmap[201][201],smap[201][201];\nint dp[201][2];\nvector<int> order;\n\nint main(){\n  int n,m,r,i,j,k;\n  while(scanf(\"%d %d\",&n,&m),n){\n    order.clear();\n    for(i=0;i<201;i++){\n      for(j=0;j<201;j++)\n\tlmap[i][j]=smap[i][j]=INT_MAX;\n      dp[i][0]=dp[i][1]=0;\n    }\n\n    for(i=0;i<m;i++){\n      int x,y,t;\n      char w;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&w);\n      if(w=='L')\n\tlmap[x][y]=lmap[y][x]=min(lmap[x][y],t);\n      else\n\tsmap[x][y]=smap[y][x]=min(smap[x][y],t);\n    }\n    \n    scanf(\"%d\",&r);\n    for(i=0;i<r;i++){\n      scanf(\"%d\",&j);\n      order.push_back(j);\n    }\n\n    for(i=1;i<=n;i++) lmap[i][i]=smap[i][i]=0;\n\n    for(k=1;k<=n;k++)\n      for(i=1;i<=n;i++)\n\tfor(j=1;j<=n;j++){\n\t  lmap[i][j] = min(lmap[i][j],lmap[i][k]+lmap[k][j]);\n\t  smap[i][j] = min(smap[i][j],smap[i][k]+smap[k][j]);\n\t}\n    \n    for(i=r-2;i>=0;i--)\n      for(j=1;j<=n;j++){\n\tint mint=INT_MAX;\n\tfor(k=1;k<=n;k++){\n\t  int tmp;\n\t  if(k!=j)\n\t    tmp = dp[k][~i&1]+lmap[order[i+1]][k]+smap[k][j]+lmap[j][order[i]];\n\t  else\n\t    tmp = dp[k][~i&1]+lmap[order[i+1]][order[i]];\n\t  mint = min(mint,tmp);\n\t}\n\tdp[j][i&1] = mint;\n      }\n\n    printf(\"%d\\n\",dp[order[0]][0]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 5;\n\nclass Edge\n{\npublic:\n    int to;\n    long long cost;\n    Edge(){};\n    Edge(int to0, long long cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<long long>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<long long,int> ,vector<pair<long long,int> >, greater<pair<long long,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<long long, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<long long> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edgesLand(n), edgesSea(n);\n        for(int i=0; i<m; ++i){\n            int x, y, t;\n            char c;\n            cin >> x >> y >> t >> c;\n            -- x;\n            -- y;\n            if(c == 'L'){\n                edgesLand[x].push_back(Edge(y, t));\n                edgesLand[y].push_back(Edge(x, t));\n            }else{\n                edgesSea[x].push_back(Edge(y, t));\n                edgesSea[y].push_back(Edge(x, t));\n            }\n        }\n\n        vector<vector<long long> > costLand, costSea;\n        shortestPath(edgesLand, costLand);\n        shortestPath(edgesSea, costSea);\n\n        int r;\n        cin >> r;\n        vector<int> z(r, 0);\n        for(int i=0; i<r; ++i){\n            cin >> z[i];\n            -- z[i];\n        }\n\n        vector<long long> dp(n, INF);\n        dp[z[0]] = 0;\n        for(int i=1; i<r; ++i){\n            vector<long long> next(n, INF);\n            for(int j=0; j<n; ++j)\n                next[j] = min(next[j], dp[j] + costLand[z[i-1]][z[i]]);\n\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<n; ++k){\n                    long long cost = costLand[z[i-1]][j] + costSea[j][k] + costLand[k][z[i]];\n                    next[k] = min(next[k], dp[j] + cost);\n                }\n            }\n\n            dp.swap(next);\n        }\n\n        cout << *min_element(dp.begin(), dp.end()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long \n#define INF 0x3f3f3f3f\n#define MAX 300\nLL e1[MAX][MAX],e2[MAX][MAX];\nLL f[1100][MAX],a[MAX],inf;\nvoid init(int N){\n\tmemset(e1,INF,sizeof(e1));\n\tmemset(e2,INF,sizeof(e2));\n\tmemset(f,INF,sizeof(f));\n\tinf=f[1][1];\n\t//cout<<inf<<endl;\n\tfor(int i=1;i<=N;++i) e1[i][i]=e2[i][i]=0;\n}\nint main(){\n\tint N,M,i,j,k,u,v,R;\n\tLL w;\n\tchar str[10];\n\twhile(scanf(\"%d%d\",&N,&M)==2){\n\t\tif(N==0&&M==0) break;\n\t\tinit(N);\n\t\twhile(M--){\n\t\t\tscanf(\"%d%d%lld\",&u,&v,&w);\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(!strcmp(str,\"L\")){\n\t\t\t\tif(w<e1[u][v]){\n\t\t\t\t\te1[u][v]=e1[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(w<e2[u][v]){\n\t\t\t\t\te2[u][v]=e2[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e1[i][j]==inf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te1[i][k]=min(e1[i][k],e1[i][j]+e1[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e2[i][j]==inf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te2[i][k]=min(e2[i][k],e2[i][j]+e2[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=1;i<=R;++i) scanf(\"%lld\",a+i);\n\t\tfor(i=1;i<=N;++i) \n\t\tf[1][i]=e1[a[1]][i]+e2[a[1]][i];\n\t//\tf[1][a[1]]=0;\n\t\tfor(i=1;i<=R;++i){\n\t\t\tfor(j=1;j<=N;++j){\n\t\t\t\tif(f[i][j]!=inf){\n\t\t\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\t\t\tif(e2[j][k]!=inf&&e1[a[i]][j]!=inf&&e1[a[i+1]][k]!=inf)\n\t\t\t\t\t\tf[i+1][k]=min(\n\t\t\t\t\t\tf[i+1][k],f[i][j]+e1[a[i]][j]+e1[a[i+1]][k]+e2[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLL ans=inf;\n\t\tfor(i=1;i<=N;++i) ans=min(ans,f[R][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\nstruct node{\n    int index,boat,next,cost;\n    node(int index,int boat,int next,int cost):index(index),boat(boat),next(next),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nstruct edge{\n\tint lcost,scost;\n\tedge(int lcost,int scost):lcost(lcost),scost(scost){}\n\tedge(){}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\n\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\ntypedef vector<vvi> vvvi;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tstatic edge graph[200][200];\n\t\tREP(i,n)REP(j,n){\n\t\t\tif(i==j){\n\t\t\t\tgraph[i][j]=edge(0,0);\n\t\t\t}else{\n\t\t\t\tgraph[i][j]=edge(MAX,MAX);\n\t\t\t}\n\t\t}\n        REP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tswitch(sl){\n\t\t\tcase 'S':\n\t\t\t\tgraph[x-1][y-1].scost=min(graph[x-1][y-1].scost,t);\n\t\t\t\tgraph[y-1][x-1].scost=min(graph[y-1][x-1].scost,t);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tgraph[x-1][y-1].lcost=min(graph[x-1][y-1].lcost,t);\n\t\t\t\tgraph[y-1][x-1].lcost=min(graph[y-1][x-1].lcost,t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n        }\n\t\tint r;\n\t\tcin>>r;\n\t\tvi order(r);\n\t\tREP(i,r){\n\t\t\tcin>>order[i];\n\t\t\torder[i]--;\n\t\t}\n\t\tREP(k,n)REP(i,n)REP(j,n){\n\t\t\tgraph[i][j].lcost=min(graph[i][j].lcost,graph[i][k].lcost+graph[k][j].lcost);\n\t\t\tgraph[i][j].scost=min(graph[i][j].scost,graph[i][k].scost+graph[k][j].scost);\n\t\t}\n\n\t\tstatic int dp[1001][200];\n\t\tREP(i,r+1){\n\t\t\tREP(j,n){\n\t\t\t\tdp[i][j]=MAX;\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=0;\n\t\tfor(int post=-1;post<r-1;post++){\n\t\t\tREP(boat,n){\n\t\t\t\tif(post==-1){\n\t\t\t\t\tdp[post+1][0]=min(dp[post+1][0],graph[0][order[post+1]].lcost);\n\t\t\t\t\tREP(via,n){\n\t\t\t\t\t\tdp[post+1][via]=min(dp[post+1][via],graph[0][via].scost+graph[via][order[post+1]].lcost);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdp[post+1][boat]=min(dp[post+1][boat],dp[post][boat]+graph[order[post]][order[post+1]].lcost);\n\t\t\t\t\tREP(via,n){\n\t\t\t\t\t\tdp[post+1][via]=min(dp[post+1][via],dp[post][order[post]]+graph[order[post]][via].scost+graph[via][order[post+1]].lcost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n\t\tint ans=MAX;\n\t\tREP(i,n){\n\t\t\tans=min(ans,dp[r-1][i]);\n\t\t}\n        cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Weight = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n};\nusing Graph = vector<vector<Edge>>;\n\nvoid add_bidirectional_edge(Graph& graph, int src, int dst, int weight) {\n    graph[src].push_back((Edge){src, dst, weight});\n    graph[dst].push_back((Edge){dst, src, weight});\n}\n\n// Verified: AOJ 2251 (Merry Christmas)\nvector<vector<Weight>> warshall_floyd(Graph graph) {\n    static const Weight inf = numeric_limits<Weight>::max() / 10;\n    vector<vector<Weight>> dist(graph.size(), vector<Weight>(graph.size(), inf));\n    REP(u, graph.size()) dist[u][u] = 0;\n    REP(u, graph.size()) for (auto& e : graph[u]) dist[e.src][e.dst] = e.weight;\n    REP(w, graph.size()) REP(u, graph.size()) REP(v, graph.size())\n        dist[u][v] = min(dist[u][v], dist[u][w] + dist[w][v]);\n    return dist;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M;\n    while (cin>>N>>M, N|M) {\n        Graph land(N), sea(N);\n        REP(i, M) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n            if (sl == 'L')\n                add_bidirectional_edge(land, x, y, t);\n            else\n                add_bidirectional_edge(sea, x, y, t);\n        }\n        int R; cin >> R;\n        vector<int> order(R);\n        REP(i, R) {\n            int o; cin >> o;\n            order[i] = o-1;\n        }\n\n        if (R == 1) {\n            cout << \"0\\n\";\n            continue;\n        }\n\n        auto dist_land = warshall_floyd(land);\n        auto dist_sea  = warshall_floyd(sea);\n\n        vector<vector<Weight>> dp(2, vector<Weight>(N, INT_MAX/10));\n        dp[1][order[0]] = 0;\n        REP(i, R-1) {\n            int curr = i%2, prev = 1-i%2;\n            int u = order[i], v = order[i+1];\n            REP(q, N) {\n                Weight value = dp[prev][q] + dist_land[u][v];\n                REP(p, N) {\n                    value = min(value, dp[prev][p] + dist_land[u][p] + dist_sea[p][q] + dist_land[q][v]);\n                }\n                dp[curr][q] = value;\n            }\n        }\n        cout << *min_element(dp[(R-2)%2].begin(), dp[(R-2)%2].end()) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<ll,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Edge{\n    int to, cost;\n};\n\nint dl[200][200], ds[200][200];\nint N, M, R;\nint Z[1000];\nstd::vector<Edge> Gl[200], Gs[200];\n\nint dijkstra(){\n    int d[1000][200];\n    REP(i, 1000){\n        REP(j, 200){\n            d[i][j] = INF;\n        }\n    }\n    \n    // State: (コスト, (今いるところ, 船を置いたところ))\n    std::priority_queue<State> q;\n    d[0][0] = 0;\n    q.push(mp(0, mp(0, 0)));\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int cost = s.first;\n        P p = s.second;\n\n        if(p.first == R-1){continue;}\n        if(d[p.first][p.second] < cost){continue;}\n\n        // A->陸->B\n        if(d[p.first+1][p.second] > cost + dl[Z[p.first]][Z[p.first+1]]){\n            d[p.first+1][p.second] = cost + dl[Z[p.first]][Z[p.first+1]];\n            q.push(mp(d[p.first+1][p.second], mp(p.first+1, p.second)));\n        }\n\n        // A->陸->C->海->D->陸->B\n        for(auto &e : Gs[p.second]){\n            if(d[p.first+1][e.to] > cost + dl[Z[p.first]][p.second] + e.cost + dl[e.to][Z[p.first+1]]){\n                d[p.first+1][e.to] = cost + dl[Z[p.first]][p.second] + e.cost + dl[e.to][Z[p.first+1]];\n                q.push(mp(d[p.first+1][e.to], mp(p.first+1, e.to)));\n            }\n        }\n    }\n\n    int res = INF;\n    REP(i, N){\n        res = std::min(res, d[R-1][i]);\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, 200){\n            REP(j, 200){\n                if(i == j){\n                    dl[i][j] = 0;\n                    ds[i][j] = 0;\n                }else{\n                    dl[i][j] = INF;\n                    ds[i][j] = INF;\n                }\n            }\n        }\n\n        REP(i, 200){\n            Gl[i].clear();\n            Gs[i].clear();\n        }\n\n        REP(i, M){\n            int from, to, cost;\n            char c;\n            std::cin >> from >> to >> cost >> c;\n            from--; to--;\n\n            if(c == 'L'){\n                dl[from][to] = cost;\n                dl[to][from] = cost;\n            }else if(c == 'S'){\n                ds[from][to] = cost;\n                ds[to][from] = cost;\n            }\n        }\n\n        std::cin >> R;\n        REP(i, R){\n            std::cin >> Z[i];\n            Z[i]--;\n        }\n\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    dl[i][j] = std::min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = std::min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        REP(i, N){\n            REP(j, N){\n                if(dl[i][j] < INF){\n                    Gl[i].push_back({j, dl[i][j]});\n                    Gl[j].push_back({i, dl[i][j]});\n                }\n                if(ds[i][j] < INF){\n                    Gs[i].push_back({j, ds[i][j]});\n                    Gs[j].push_back({i, ds[i][j]});\n                }\n            }\n        }\n\n        std::cout << dijkstra() << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dist[1000][100][100];\nvector<pii> edgel[100],edges[100];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\t(sl == 'L' ? edgel[x] : edges[x]).push_back(mp(y, t));\n\t\t\t(sl == 'L' ? edgel[y] : edges[y]).push_back(mp(x, t));\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, r)\trep(j, n)\trep(k, n)\tdist[i][j][k] = mod;\n\t\tdist[0][z[0]][z[0]] = 0;\n\t\tpriority_queue<tuple<int, int, int, int>> pq;\n\t\tpq.push(mt(0, 0, z[0], z[0]));\n\t\tint ret = mod;\n\t\twhile (!pq.empty()) {\n\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\tint d, pos, fpos, phase;\n\t\t\ttie(d, phase, pos, fpos) = it;\td *= -1;\n\t\t\tif (d > dist[phase][pos][fpos])\tcontinue;\n\t\t\tif(DEBUG)\tcout << d << \" \" << phase << \" \" << pos << \" \" << fpos << endl;\n\t\t\tif (phase == r - 1) {\n\t\t\t\tret = min(ret, d);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, edgel[pos].size()) {\n\t\t\t\tint to = edgel[pos][i].fst, add = edgel[pos][i].scn;\n\t\t\t\tint np = phase + (to == z[phase + 1] ? 1 : 0);\n\t\t\t\tif (dist[np][to][fpos] > dist[phase][pos][fpos] + add) {\n\t\t\t\t\tdist[np][to][fpos] = dist[phase][pos][fpos] + add;\n\t\t\t\t\tpq.push(mt(-dist[np][to][fpos], np, to, fpos));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos == fpos) {\n\t\t\t\trep(i, edges[pos].size()) {\n\t\t\t\t\tint to = edges[pos][i].fst, add = edges[pos][i].scn;\n\t\t\t\t\tint np = phase + (to == z[phase + 1] ? 1 : 0);\n\t\t\t\t\tif (dist[np][to][to] > dist[phase][pos][fpos] + add) {\n\t\t\t\t\t\tdist[np][to][to] = dist[phase][pos][fpos] + add;\n\t\t\t\t\t\tpq.push(mt(-dist[np][to][to], np, to, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t\trep(i, n) {\n\t\t\tedgel[i].clear();\tedges[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint q[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) {\n  for(int i = 1; i <= n; ++i) {\n    for(int j = 1; j <= n; ++j) {\n      for(int k = 1; k <= n; ++k) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while(scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n    memset(q, 0x3f, sizeof(q));\n\n    while(m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if(tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n    b[0] = 1;\n    for(int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    for(int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if(s[i][j] < INF && l[i][j] < INF) {\n          q[i][j] = s[i][j] + l[i][j];\n        }\n      }\n    }\n\n    d[0][1] = 0;\n\n    for(int i = 1; i <= r; ++i) {\n      for(int j = 1; j <= n; ++j) {\n        if(l[j][b[i]] >= INF) continue;\n        for(int k = 1; k <= n; ++k) {\n          if(d[i-1][k] >= INF) continue;\n          if(j == k){\n            if(l[b[i-1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i-1][k] + l[b[i-1]][b[i]]);\n            }\n          } else{\n            if(l[b[i-1]][k] < INF && s[k][j] < INF) {\n              d[i][j] = min(d[i][j], d[i-1][k] + l[b[i-1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n#include <cfloat>\n\nusing std::cerr;\nusing std::cin;\nusing std::cout;\nusing std::endl;\n\ntemplate<typename CostType>\n/// \\brief 辺の情報\nstruct Edge{\n  int      to;\n  CostType cost;\n\n  Edge(int t, CostType c): to(t), cost(c){\n  }\n};\n\ntemplate<typename CostType>\nclass Graph{\n\nprivate:\n\n  /// \\brief adjacent_list_[n]=ノードnの隣接リストを表すvector<Edge>\n  std::vector<std::vector<Edge<CostType>>> adjacent_list_;\n\npublic:\n\n  /// \\brief 頂点数\n  const int NODE_SIZE_;\n\n  /// \\brief コンストラクタ\n  /// \\param node_size 頂点数\n  explicit Graph(const int node_size): NODE_SIZE_(node_size),\n                                       adjacent_list_(node_size){\n  }\n\n  /// \\brief 有向グラフの辺を生やす\n  /// \\param from 辺の根本の頂点の番号\n  /// \\param to 辺の先の頂点の番号\n  /// \\param cost 辺のコスト\n  void SetDirectedEdge(const int from, const int to, const CostType cost){\n    adjacent_list_[from].push_back(Edge<CostType>(to, cost));\n  }\n\n  /// \\brief 無向グラフの辺を生やす\n  /// \\param node_a 一方の頂点の番号\n  /// \\param node_b もう一方の頂点の番号\n  /// \\param cost 辺のコスト\n  void\n  SetUndirectedEdge(const int node_a, const int node_b, const CostType cost){\n    SetDirectedEdge(node_a, node_b, cost);\n    SetDirectedEdge(node_b, node_a, cost);\n  }\n\n  /// \\brief ある頂点の隣接リストを取得\n  /// \\param node_num 頂点の番号\n  /// \\return 隣接リスト\n  std::vector<Edge<CostType>> GetAdjacentList(int node_num) const{\n    return adjacent_list_[node_num];\n  }\n};\n\n/// \\brief ダイクストラ法により，ある頂点からの最短経路を求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param start_node どの頂点から最短経路を求めるか\n/// \\param INF CostType型で十分大きい値\n/// \\return グラフの各頂点への最短経路を示す配列(到達不可能なときはINF)，負の辺が入っていた場合はsize0の配列\ntemplate<typename CostType>\nstd::vector<CostType>\nDijkstra(const Graph<CostType>& graph, const int start_node, CostType INF){\n  struct Info{\n    int      node;\n    CostType cost;\n\n    Info(int n, CostType c): node(n), cost(c){\n    };\n\n    bool operator>(const Info& another) const{\n      return cost > another.cost;\n    }\n  };\n\n  std::vector<CostType>                                            min_cost\n                                                                       (graph\n                                                                            .NODE_SIZE_);\n  std::priority_queue<Info, std::vector<Info>, std::greater<Info>> pq;\n  for(int                                                          i = 0;\n      i < min_cost.size(); i++){\n    min_cost[i] = (i == start_node) ? 0 : INF;\n  }\n  pq.push(Info(start_node, 0));\n\n  while(!pq.empty()){\n    Info current_info = pq.top();\n    pq.pop();\n    if(min_cost[current_info.node] != current_info.cost){ continue; }\n    const std::vector<Edge<CostType>>\n        & adjacency_list = graph.GetAdjacentList(current_info.node);\n    for(auto e:adjacency_list){\n      if(min_cost[e.to] > min_cost[current_info.node] + e.cost){\n        min_cost[e.to] = min_cost[current_info.node] + e.cost;\n        pq.push(Info(e.to, min_cost[e.to]));\n      }\n    }\n  }\n\n  return min_cost;\n\n}\n\n/// \\brief ベルマンフォード法により，ある頂点からの最短経路を求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param start_node どの頂点から最短経路を求めるか\n/// \\param INF CostType型で十分大きい値\n/// \\return グラフの各頂点への最短経路を示す配列(到達不可能なときはINF)，負の閉路がある場合はsize0の配列\ntemplate<typename CostType>\nstd::vector<CostType>\nBellmanFord(const Graph<CostType>& graph, const int start_node, CostType INF){\n  std::vector<CostType> min_cost(graph.NODE_SIZE_);\n  for(int               i = 0; i < min_cost.size(); i++){\n    min_cost[i] = (i == start_node) ? 0 : INF;\n  }\n\n  for(int loop = 0; loop < graph.NODE_SIZE_; loop++){\n    for(int from = 0; from < graph.NODE_SIZE_; from++){\n      if(min_cost[from] == INF){ continue; }\n      std::vector<Edge<CostType>> adjacent_list = graph.GetAdjacentList(from);\n      for(auto                    e:adjacent_list){\n        CostType next_cost = min_cost[from] + e.cost;\n        if(next_cost < min_cost[e.to]){\n          if(loop == graph.NODE_SIZE_ - 1){\n            return std::vector<CostType>(0);\n          }else{\n            min_cost[e.to] = next_cost;\n          }\n        }\n      }\n    }\n  }\n\n  return min_cost;\n}\n\n/// \\brief ワーシャルフロイド法により，全点対の最小コストを求める\n/// \\tparam CostType 辺のコストの型\n/// \\param graph グラフ\n/// \\param INF CostType型で十分大きい値\n/// \\return hoge[from][to]=from→toの最小コスト(到達できないときはINF)，\n///         負の閉路がある場合は0行の二次元配列みたいなvector\ntemplate<typename CostType>\nstd::vector<std::vector<CostType>>\nWarshallFloyd(const Graph<CostType>& graph, const CostType INF){\n  std::vector<std::vector<CostType>> min_cost;\n  for(int                            r = 0; r < graph.NODE_SIZE_; r++){\n    std::vector<CostType> rowvec;\n    for(int               c = 0; c < graph.NODE_SIZE_; c++){\n      rowvec.push_back((r == c) ? 0 : INF);\n    }\n    min_cost.push_back(rowvec);\n  }\n\n  for(int from = 0; from < graph.NODE_SIZE_; from++){\n    for(auto e:graph.GetAdjacentList(from)){\n      min_cost[from][e.to] = e.cost;\n    }\n  }\n\n  for(int k = 0; k < graph.NODE_SIZE_; k++){\n    for(int i = 0; i < graph.NODE_SIZE_; i++){\n      for(int j = 0; j < graph.NODE_SIZE_; j++){\n        if(min_cost[i][k] == INF || min_cost[k][j] == INF){ continue; }\n        min_cost[i][j] =\n            std::min(min_cost[i][j], min_cost[i][k] + min_cost[k][j]);\n      }\n    }\n  }\n\n  for(int i = 0; i < graph.NODE_SIZE_; i++){\n\n    if(min_cost[i][i] < 0){\n      std::vector<std::vector<CostType>> result(0);\n      return result;\n    }\n\n  }\n\n  return min_cost;\n}\n\nint main(){\n  cout << std::fixed << std::setprecision(16);\n  cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  while(true){\n    int n,m;\n    cin>>n>>m;\n    if(n==0) break;\n\n\n    Graph<int> graph_land(n+1),graph_sea(n+1);\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      cin>>x>>y>>t>>s;\n      if(s=='L'){\n        graph_land.SetUndirectedEdge(x,y,t);\n      }else{\n        graph_sea.SetUndirectedEdge(x,y,t);\n      }\n    }\n\n    const int INF=INT32_MAX/4;\n\n    std::vector<std::vector<int>> min_cost_land=WarshallFloyd(graph_land,INF);\n    std::vector<std::vector<int>> min_cost_sea=WarshallFloyd(graph_sea,INF);\n\n    int dp[1001][201]={};\n    int r;\n    cin>>r;\n    for(int i=0;i<=r;i++){\n      for(int j=0;j<=n;j++){\n        dp[i][j]=INF;\n\n      }\n    }\n\n    std::vector<int> z(r+1);\n    for(int i=1;i<=r;i++){\n      cin >> z[i];\n    }\n    dp[1][z[1]]=0;\n    for(int q=2;q<=r;q++){\n      for(int port_from=1;port_from<=n;port_from++){\n        for(int port_to=1;port_to<=n;port_to++){\n          if(port_from==port_to){\n            //直接陸路で\n            dp[q][port_from]=std::min(dp[q][port_from],dp[q-1][port_from]+min_cost_land[z[q-1]][z[q]]);\n          }else{\n            int prev_to_port=min_cost_land[z[q-1]][port_from];\n            int port_to_port=min_cost_sea[port_from][port_to];\n            int port_to_next=min_cost_land[port_to][z[q]];\n            dp[q][port_to]=std::min(dp[q][port_to],dp[q-1][port_from]+prev_to_port+port_to_port+port_to_next);\n          }\n        }\n      }\n    }\n\n    int result=INF;\n    for(int i=1;i<=n;i++){\n      result=std::min(result,dp[r][i]);\n    }\n    cout<<result<<endl;\n  }\n\n\n\n\n\n\n\n\n\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<int,int,int> tpl;\n    static int dist[200][200][1001];\n    fill_n((int*)dist,200*200*1001,inf);\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    dist[z[0]][z[0]][1]=true;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        if(d>dist[p1][p2][num]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p2][num_]) continue;\n            dist[p_][p2][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p2,num_)));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p_][num_]) continue;\n            dist[p_][p_][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p_,num_)));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<LL>> riku(n,vector<LL>(n,INF));\n    vector<vector<LL>> kai(n,vector<LL>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    LL x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    // for(int i=0;i<n;i++){\n    //   for(int j=0;j<n;j++){\n    //     cout << kai[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    int r;\n    cin >> r;\n    vector<LL> z(r);\n    for(int i=0;i<r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<LL>> dp(r,vector<LL>(n,INF));\n    dp[0][z[0]]=0;\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    // for(int i=0;i<r;i++){\n    //   for(int j=0;j<n;j++){\n    //     cout << dp[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    LL ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing i64 = long long;\n\nconst i64 MOD = i64(1e9) + 7;\nconst i64 INF = i64(1e18) + 7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\n\nbool solve(){\n    int n, m;\n    cin >> n >> m;\n    if(!n){\n        return false;\n    }\n    vector<vector<i64>> dist_l(n, vector<i64>(n, INF));\n    vector<vector<i64>> dist_s(n, vector<i64>(n, INF));\n    for(int i = 0; i < n; ++i){\n        dist_l[i][i] = 0;\n        dist_s[i][i] = 0;\n    }\n    for(int i = 0; i < m; ++i){\n        int x, y;\n        i64 t;\n        string s;\n        cin >> x >> y >> t >> s;\n        --x, --y;\n        auto& dist = (s == \"S\" ? dist_s : dist_l);\n        chmin(dist[x][y], t);\n        chmin(dist[y][x], t);\n    }\n\n    for(int l = 0; l < 10; ++l)\n        for(int k = 0; k < n; ++k)\n            for(int i = 0; i < n; ++i)\n                for(int j = 0; j < n; ++j){\n                    chmin(dist_l[i][j], dist_l[i][k] + dist_l[k][j]);\n                    chmin(dist_s[i][j], dist_s[i][k] + dist_s[k][j]);\n                }\n\n    int r;\n    cin >> r;\n    int v;\n    cin >> v;\n    --v;\n    vector<i64> dp(n, INF);\n    dp[v] = 0;\n\n    for(int _ = 0; _ < r - 1; ++_){\n        vector<i64> nex(n, INF);\n        int prev = v;\n        cin >> v;\n        --v;\n\n        for(int i = 0; i < n; ++i)\n            chmin(nex[i], dp[i] + dist_l[prev][v]);\n        for(int i = 0; i < n; ++i)\n            for(int j = 0; j < n; ++j)\n                chmin(nex[j], dp[i] + dist_l[prev][i] + dist_s[i][j] + dist_l[j][v]);\n        dp = move(nex);\n    }\n    i64 ans = INF;\n    for(int j = 0; j < n; ++j)\n        chmin(ans, dp[j]);\n    cout << ans << endl;\n    return true;\n}\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            /*if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }*/\n            rep(j,n){\n                cmin(dp[i+1][j],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][k],dp[i][j] + Ld[v[i]][j] + Sd[j][k] + Ld[k][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int INF=100000000;\nconst int MAX_V = 201;\nint n,m,r;\nint land[MAX_V][MAX_V];\nint sea[MAX_V][MAX_V];\nint citys[1001];\nvoid calcLandMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n}\nvoid calcSeaMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n}\nint dp[201][201];\n// WzæªidxÌÔÚÌÆ±ëÅA{[gªboatÌm[hÉ éÆ«ÌÅ¬zBÔ\nint rec(int idx,int boat){\n    if(idx==r)\n        return 0;\n    if(dp[idx][boat]!=INF)\n        return dp[idx][boat];\n    int minTime=INF;\n    // ¤ÌÝðgÁÄB·éê\n    minTime=min(minTime,rec(idx+1,boat)+land[citys[idx-1]][citys[idx]]);\n    // CàgÁÄB·éê\n    // »ÝÌboatÌÊu©çBÅ«é`¬·×ÄÉÂ¢Ä·\n    for(int i = 0; i < n; i++){\n        minTime=min(minTime,rec(idx+1,i)+land[citys[idx-1]][boat]\n        + sea[boat][i] + land[i][citys[idx]]);\n    }\n    return dp[idx][boat]=minTime;\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < MAX_V; i++){\n            for(int j = 0; j < MAX_V; j++){\n                if(i==j)\n                    land[i][j]=sea[i][j]=0;\n                else\n                    land[i][j]=sea[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char kind;\n            cin>>from>>to>>cost>>kind;\n            from--;to--;\n            if(kind=='L')\n                land[from][to]=land[to][from]=cost;\n            else\n                sea[from][to]=sea[to][from]=cost;\n        }\n        cin>>r;\n        for(int i = 0; i < r; i++){\n            cin>>citys[i];\n            citys[i]--;\n        }\n        calcLandMinDist();calcSeaMinDist();\n        // dpÅÅZ£ðßé\n        for(int i = 0; i < 201; i++)\n            for(int j = 0; j < 201; j++)dp[i][j]=INF;\n        int res=rec(1,citys[0]);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}\n/*\nÈº¦ÍÅ«P[XÅªöxÅoÍ³êéªAAOJÅÍà¿ëñTLE·éR[h\n_CNXg@ðgpµÄð¼Éð¢Ä¢é\n*/\n//struct edge{\n//\tint to;\n//\tint cost;\n//    char kind;\n//};\n//\n//class Situation{\n//public:\n//\tint cost;\n//\tint node;\n//    int boat;\n//    int obj;\n//\n//\tSituation(int cost_,int node_,int boat_,int obj_){\n//\t\tcost=cost_;\n//        node=node_;\n//        boat=boat_;\n//        obj=obj_;\n//\t}\n//\tSituation();\n//\n//\tbool operator<(const Situation &s)const{\n//\t\treturn s.cost < this->cost;\n//\t}\n//};\n//\n//int V;\n//int n,m;\n//\n//vector<int> objLands;\n//\n//const int MAX_V = 205;\n//const int MAX_M = 1001;\n//vector<edge> G[MAX_V];\n//int d[MAX_V][MAX_M][MAX_V];\n//const int INF = 1000000000;\n//\n//void dijkstra(int s){\n//\tpriority_queue<Situation> que;\n//    for(int i = 0; i < MAX_V; i++)\n//        for(int j = 0; j < MAX_M; j++)\n//            for(int k = 0; k < MAX_V; k++)\n//                d[i][j][k]=INF;\n//    d[s][0][s] = 0;\n//    que.push(Situation(0,s,s,0));\n//\twhile(!que.empty()){\n//\t\tSituation p = que.top();\n//\t\tque.pop();\n//        int node=p.node;\n//        int boat=p.boat;\n//        int cost=p.cost;\n//        int obj=p.obj;\n//        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n//\t\tif(d[node][obj][boat] < cost)\n//            continue;\n//\t\tfor(int i = 0; i < G[node].size(); i++){\n//\t\t\tedge &e = G[node][i];\n//            int toObj=obj;\n//            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n//            if(objLands[obj]==e.to)\n//                toObj++;\n//            // ¤ÌêÆCÌêÅêí¯\n//            if(e.kind=='L'){\n//                // ÅZ£\n//                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n//                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n//                    if(toObj!=objLands.size())\n//                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n//                }\n//            }\n//            else{\n//                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n//                if(boat==node){\n//                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n//                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n//                        if(toObj!=objLands.size())\n//                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n//                    }\n//                }\n//            }\n//\t\t}\n//\t}\n//}\n//\n//int main(){\n//\n//    while(cin>>n>>m&&!(n==0&&m==0)){\n//        objLands.clear();\n//        for(int i = 0; i < MAX_V; i++)\n//            G[i].clear();\n//        for(int i = 0; i < m; i++){\n//            int from,to,cost;\n//            char c;\n//            cin>>from>>to>>cost>>c;\n//            from--;to--;\n//            edge e;\n//            e.cost=cost;e.kind=c;e.to=to;\n//            G[from].push_back(e);\n//            e.to=from;\n//            G[to].push_back(e);\n//        }\n//        int t;\n//        cin>>t;\n//        int s;\n//        for(int i = 0; i < t; i++){\n//            if(i==0){\n//                cin>>s;\n//                s--;\n//            }\n//            else{\n//                int b;\n//                cin>>b;\n//                b--;\n//                objLands.push_back(b);\n//            }\n//        }\n//        dijkstra(s);\n//        int minCost=INF;\n//        for(int i = 0; i < n; i++){\n//            for(int j = 0; j < n; j++)\n//                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n//        }\n//        cout<<minCost<<endl;\n//    }\n//    return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define min(a,b)((a)<(b)?(a):(b))\n#define inf 0x01010101\nstruct State{\n\tint cost,rito,boat;\n\tState(int cost,int rito,int boat):cost(cost),rito(rito),boat(boat){}\n\tbool operator<(const State& r)const{return cost<r.cost;}\n};\nint N;//¬ºÌ\nint Edge[2][201][201];//[¤H0,CH1][¬º][¬º]\nint Cost[201][201];//[¡³ñÌÊu][DÌÊu]:=ÅZÚ®Ô\nvoid Dijkstra(int*C,int start,int dest){\n\tint boat,rito,boatmin,ritomin,c,cmin;\n\tstd::priority_queue<State> que;\n\tmemset(Cost,1,sizeof(Cost));//inf\n\tmemcpy(Cost+start,C,sizeof(int)*201);//startÊuÅÌóÔ\n\tfor(boat=1;boat<=N;boat++){\n\t\tif(C[boat]<inf){\n\t\t\tque.push(State(C[boat],start,boat));\n\t\t}\n\t}\n\tfor(;!que.empty();){\n\t\t//¢èÌóÔÌàAÅZÌàÌðIð\n\t\tritomin=que.top().rito;\n\t\tboatmin=que.top().boat;\n\t\tcmin=que.top().cost;\n\t\tque.pop();\n\t\t//×ÚóÔðXV\n\t\tfor(rito=1;rito<=N;rito++){\n\t\t\t//¤H\n\t\t\tc=Cost[ritomin][boatmin]+Edge[0][ritomin][rito];\n\t\t\tif(c<Cost[rito][boatmin]){\n\t\t\t\tCost[rito][boatmin]=c;\n\t\t\t\tque.push(State(c,rito,boatmin));\n\t\t\t}\n\t\t\t//»±ÉDª êÎCH\n\t\t\tif(ritomin==boatmin){\n\t\t\t\tc=Cost[ritomin][boatmin]+Edge[1][ritomin][rito];\n\t\t\t\tif(c<Cost[rito][rito]){\n\t\t\t\t\tCost[rito][rito]=c;\n\t\t\t\t\tque.push(State(c,rito,rito));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(C,Cost+dest,sizeof(int)*201);//destÊuÅÌóÔ\n}\nint main(){\n\tint M,R,z;\n\tint C[201];//[DÌÊu]:=ÅZÚ®Ô\n\tfor(;scanf(\"%d%d\",&N,&M)*N;){\n\t\tmemset(Edge,1,sizeof(Edge));//inf\n\t\tfor(;M--;){\n\t\t\tint x,y,t,s;\n\t\t\tchar sl[2];\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,sl);\n\t\t\ts=sl[0]=='L'?0:1;\n\t\t\tEdge[s][x][y]=min(Edge[s][x][y],t);\n\t\t\tEdge[s][y][x]=min(Edge[s][y][x],t);\n\t\t}\n\t\tscanf(\"%d%d\",&R,&z);\n\t\tmemset(C,1,sizeof(C));//inf\n\t\tC[z]=0;\n\t\tfor(;--R;){\n\t\t\tint Z;\n\t\t\tscanf(\"%d\",&Z);\n\t\t\tDijkstra(C,z,Z);\n\t\t\tz=Z;\n\t\t}\n\t\t{\n\t\t\tint c=1<<20;\n\t\t\tfor(z=1;z<=N;z++)\n\t\t\t\tc=min(c,C[z]);\n\t\t\tprintf(\"%d \\n\",c);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 29;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nll dist[1010][210], d1[210][210], d2[210][210];\n\nint solve_testcase() {\n    int N, M; scanf(\" %d %d\", &N, &M);\n    if(N == 0 and M == 0) return 1;\n\n    fill(d1[0], d1[N], LONGINF);\n    fill(d2[0], d2[N], LONGINF);\n    for(int i=0; i<N; i++) d1[i][i] = d2[i][i] = 0;\n    for(int i=0; i<M; i++) {\n        ll u, v, c; char tp; cin >> u >> v >> c >> tp;\n        u--; v--;\n        if(tp == 'L') {\n            chmin(d1[u][v], c);\n            chmin(d1[v][u], c);\n        }\n        if(tp == 'S') {\n            chmin(d2[u][v], c);\n            chmin(d2[v][u], c);\n        }\n    }\n\n    for(int k=0; k<N; k++) {\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                chmin(d1[i][j], d1[i][k] + d1[k][j]);\n                chmin(d2[i][j], d2[i][k] + d2[k][j]);\n            }\n        }\n    }\n\n    int R; scanf(\"%d\", &R);\n    vector<int> z(R);\n    for(int i=0; i<R; i++) scanf(\"%d\", &z[i]), z[i]--;\n\n    fill(dist[0], dist[R], LONGINF);\n    dist[0][ z[0] ] = 0;\n    for(int i=0; i+1<R; i++) {\n        int u = z[i], v = z[i+1];\n        for(int j=0; j<N; j++) {\n            if(dist[i][j] == LONGINF) continue;\n            // land only\n            {\n                ll cost = d1[u][v];\n                chmin(dist[i+1][j], dist[i][j] + cost);\n            }\n\n            // land -> sea -> land\n            for(int k=0; k<N; k++) {\n                ll cost = d1[u][j] + d2[j][k] + d1[k][v];\n                chmin(dist[i+1][k], dist[i][j] + cost);\n            }\n        }\n    }\n\n    ll ans = *min_element(dist[R-1], dist[R-1] + N);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n\nint main() {\n    while(!solve_testcase());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<30);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &st) const { return d > st.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n\n    \n    for(int k=0;k<n;k++){\n      L[k][k] = S[k][k] = 0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int l=0;l<2;l++){\n\t    if(l == 0){\n\t      if(L[i][k] >= INF || L[k][j] >= INF) continue;\n\t      L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t    }\n\t    else{\n\t      if(S[i][k] >= INF || S[k][j] >= INF) continue;\n\t      S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > dp(2,vector<int>(n,INF));\n    dp[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){\n      for(int j=0;j<n;j++){\n\tif(dp[0][j] >= INF || L[dest[i-1]][j] >= INF) continue;\n\tfor(int k=0;k<n;k++){\n\t  if(S[j][k] >= INF || L[k][dest[i]] >= INF) continue;\n\t  dp[1][k] = min(dp[1][k], dp[0][j] + L[dest[i-1]][j] + S[j][k] + L[k][dest[i]]);\n\t}\n      }\n      dp[0].assign(dp[1].begin(),dp[1].end());\n      dp[1].assign(n,INF);\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;i++) ans = min(ans,dp[0][i]);\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 500000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<int>> riku(n,vector<int>(n,INF));\n    vector<vector<int>> kai(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    int x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    int r;\n    cin >> r;\n    vector<int> z(r+1);\n    z[0]=0;\n    for(int i=1;i<=r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<int>> dp(r+1,vector<int>(n,INF));\n    dp[0][0]=0;\n    for(int i=1;i<=r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\n\n\nconst int INF = 1 << 28;\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0) return false;\n\n    vector<vector<int>> ld = vector<vector<int>>(N, vector<int>(N, INF));\n    vector<vector<int>> sd = vector<vector<int>>(N, vector<int>(N, INF));\n    REP(i, N) ld[i][i] = 0;\n    REP(i, N) sd[i][i] = 0;\n    \n    REP(i, M) {\n        int x, y, t;\n        string sl;\n        cin >> x >> y >> t >> sl;\n        x--; y--;\n        if (sl == \"L\") {\n            ld[x][y] = t;\n            ld[y][x] = t;\n        } else {\n            sd[x][y] = t;\n            sd[y][x] = t;\n        }\n    }\n    int R;\n    vector<int> Z;\n    cin >> R;\n    REP(i, R) {\n        int z;\n        cin >> z;\n        Z.push_back(z - 1);\n    }\n\n\n    REP(i, N) REP(j, N) REP(k, N)\n        ld[j][k] = min(ld[j][k], ld[j][i] + ld[i][k]);\n    REP(i, N) REP(j, N) REP(k, N)\n        sd[j][k] = min(sd[j][k], sd[j][i] + sd[i][k]);\n\n\n    vector<vector<int>> dp = vector<vector<int>>(R, vector<int>(N, INF));\n    dp[0][Z[0]] = 0;\n\n    REP(i, R-1) REP(j, N) REP(k, N) {\n        dp[i+1][k] = min(dp[i+1][k],\n                         dp[i][j] + ld[Z[i]][j] + sd[j][k] + ld[k][Z[i+1]]);\n    }\n\n    int ans = INF;\n    REP(i, N) ans = min(ans, dp[R-1][i]);\n    cout << ans << endl;\n    \n    return true;\n}\n\n\nint main() {\n    while (solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#define MAX1 201\n#define MAX2 1001\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  bool LS; //0->L , 1->S\n  P(int to=0,int cost=0,bool LS=false):to(to),cost(cost),LS(LS){}\n};\n\nstruct Pox\n{\n  int p,bp,fp;//bp -> position of boat\n  Pox(int p=0,int bp=0,int fp=0):p(p),bp(bp),fp(fp){}\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint mincost[MAX1][MAX1][MAX2];\n\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      VVP G(N);\n      rep(i,MAX1)rep(j,MAX1)rep(k,MAX2)mincost[i][j][k] = inf;\n\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char sl;\n\t  cin >> x >> y >> t >> sl;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,(sl == 'S')));\n\t  G[y].push_back(P(x,t,(sl == 'S')));\n\t}\n      cin >> R;\n      vector<int> z(R);\n      rep(i,R)\n\t{\n\t  cin >> z[i];\n\t  z[i]--; \n\t}\n\n      deque<Pox> deq;\n      //priority_queue<Pox> deq;\n      deq.push_back(Pox(z[0],z[0],0));\n      mincost[z[0]][z[0]][0] = 0;\n      int ans = (1<<29);\n\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  //cout << pox.p << \" \"  << pox.bp << \" \" << pox.fp << endl; \n\n\t  bool inc = false;\n\t  if(pox.p == z[pox.fp])\n\t    pox.fp++,inc = true;\t    \n\n\t  if(pox.fp >= R)\n\t    {\n\t      //cout << \"&&&\" << endl;\n\t      ans = min(ans,mincost[pox.p][pox.bp][pox.fp-1]);\n\t      break;\n\t    }\n\n\t  Pox prev = deq.front();\n\t  int prevCost = mincost[prev.p][prev.bp][prev.fp];\t   \n\n\t  for(int i=0;i<G[pox.p].size();i++)\n\t    {\n\t      P next = G[pox.p][i];\n\n\t      if(next.LS)\n\t\t{// S\n\t\t  //cout << \"in S, \" << endl;\n\t\t  //cout << \" mincost[\"<<pox.p<<\"][\"<<pox.bp<<\"][\"<<pox.fp<<\"] = \" <<  mincost[pox.p][pox.bp][pox.fp-inc] << endl;\n\t\t  //cout << mincost[next.to][next.to][pox.fp] << \" >? \" << mincost[pox.p][pox.bp][pox.fp-inc]+ next.cost << endl;\n\t\t  //cout << endl;\n\t\t  if(pox.p != pox.bp)continue; // cannot move to the next\n\n\t\t  if(mincost[next.to][next.to][pox.fp] > mincost[pox.p][pox.bp][pox.fp-inc]+ next.cost)\n\t\t    {\n\t\t      int newCost = mincost[pox.p][pox.bp][pox.fp-inc]+ next.cost;\n\t\t      mincost[next.to][next.to][pox.fp] = newCost;\n\t\t      if(newCost < prevCost)\n\t\t\tdeq.push_front(Pox(next.to,next.to,pox.fp));\n\t\t      else \n\t\t\tdeq.push_back(Pox(next.to,next.to,pox.fp));\n\t\t    }\n\t\t}\n\t      else \n\t\t{// L\n\t\t  //cout << \"in L, \" << endl;\n\t\t  //cout << \" mincost[\"<<pox.p<<\"][\"<<pox.bp<<\"][\"<<pox.fp<<\"] = \" <<  mincost[pox.p][pox.bp][pox.fp-inc] << endl;\n\t\t  //cout << mincost[next.to][pox.bp][pox.fp] << \" >?\" <<  mincost[pox.p][pox.bp][pox.fp-inc] + next.cost << endl;\n\t\t  //cout << endl;\n\t\t  if(mincost[next.to][pox.bp][pox.fp] > mincost[pox.p][pox.bp][pox.fp-inc] + next.cost)\n\t\t    {\n\t\t      int newCost = mincost[pox.p][pox.bp][pox.fp-inc] + next.cost;\n\t\t      mincost[next.to][pox.bp][pox.fp] = newCost;\n\t\t      if(newCost < prevCost)\n\t\t\tdeq.push_front(Pox(next.to,pox.bp,pox.fp));\n\t\t      else\n\t\t\tdeq.push_back(Pox(next.to,pox.bp,pox.fp));\n\t\t    }\n\t\t}\n\t    }\n\t}   \n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <set>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <map>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define DEB 0\n#define REP(i,a,n) for(int i=(a); i<(int)(n); i++)\n#define rep(i,n) REP(i,0,n)\n\nclass state{\npublic:\n  int r,v,f,c;\n  state(int _r, int _v, int _f, int _c){\n    r=_r; v=_v; f=_f; c=_c;\n  }\n  bool operator<(const state& a)const{\n    return c > a.c;\n  }\n};\nconst int inf = INT_MAX;\nint n,m;\nint edge[2][210][210]; // 0 = umi, 1 = riku\nint dp[1010][210][210]; // [ツ妥ョツ配ツ閉ィ][ツ個サツ催敖地][ツ船ツづ個暗環置]\nint taku[1010];\n\nint main(){\n  while(cin>>n>>m,n|m){\n    // init\n    rep(i,210)rep(j,210)edge[0][i][j]=edge[1][i][j]=inf;\n    rep(i,1001)rep(j,210)rep(k,210)dp[i][j][k]=inf;\n    \n    rep(i,m){\n      int a,b,c;\n      char l;\n      scanf(\" %d %d %d %c \",&a,&b,&c,&l);\n      a--; b--;\n      if( l=='S' ){\n        edge[0][a][b] = min(c, edge[0][a][b]);\n        edge[0][b][a] = min(c, edge[0][b][a]);\n      }else{\n        edge[1][a][b] = min(c, edge[1][a][b]);\n        edge[1][b][a] = min(c, edge[1][b][a]);\n      }\n    }\n\n#if DEB\n    puts(\"umi\");\n    rep(i,n){\n      rep(j,n){\n        printf(\"%d \",edge[0][i][j]==inf ? -1 : edge[0][i][j]);\n      }\n      puts(\"\");\n    }\n    puts(\"rku\");\n    rep(i,n){\n      rep(j,n){\n        printf(\"%d \",edge[1][i][j]==inf ? -1 : edge[1][i][j]);\n      }\n      puts(\"\");\n    }\n#endif    \n    \n    int R; cin>>R;\n    rep(i,R){\n      int a; scanf(\"%d \",&a);\n      taku[i] = a-1;\n    }\n\n    int ans = -1;\n    priority_queue<state> q;\n    if( taku[0]==0 ){\n      dp[1][0][0] = 0;\n      q.push(state(1,0,0,0));\n    }else{\n      dp[0][0][0] = 0;\n      q.push(state(0,0,0,0));\n    }\n\n    \n    while( !q.empty() ){\n      state s = q.top(); q.pop();\n#if DEB\n      printf(\"r:%d, v:%d, f:%d, c:%d\\n\",s.r, s.v, s.f, s.c);\n#endif      \n\n      if( s.r==R ){ ans = s.c; break; }\n      rep(i,n){\n        int ne = s.r;\n        if( i==taku[s.r] ) ne++;\n\n        //printf(\"i:%d   s.v:%d  s.f:%d,  edge:%d\\n\",i,s.v, s.f, edge[0][s.v][i]);\n        \n        if( edge[1][s.v][i]!=inf ){ //riku\n          if( dp[ne][i][s.f] > edge[1][s.v][i] + s.c ){\n            int d = edge[1][s.v][i] + s.c;\n            dp[ne][i][s.f] = d;\n#if DEB\n            printf(\"riku :: ne:%d i:%d , f:%d, d:%d\\n\",ne,i,s.f,d);\n#endif            \n            q.push(state(ne, i, s.f, d));\n          }\n        }\n        if( s.v==s.f && edge[0][s.v][i]!=inf ){ // umi\n          if( dp[ne][i][i] > edge[0][s.v][i] + s.c ){\n            int d = edge[0][s.v][i] + s.c;\n            dp[ne][i][i] = d;\n#if DEB\n            printf(\"umi :: ne:%d i:%d , f:%d, d:%d\\n\",ne,i,i,d);\n#endif               \n            q.push(state(ne, i, i, d));\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<cmath>\n#include<set>\n#include<map>\n#include<stack>\n#include<queue>\n#include<algorithm>\n#define LL long long\nusing namespace std;\n\nconst int maxn=210,inf=1e8;\nint n,m,dl[maxn][maxn],ds[maxn][maxn],r,city[1010],dp[1010][maxn];\n\nint main(void){\n    while(scanf(\"%d %d\",&n,&m)!=EOF && (n+m)){\n        int i,j,k;\n        for(i=1;i<=n;i++){\n            for(j=1;j<=n;j++){\n                dl[i][j]=ds[i][j]=inf;\n            }\n            dl[i][i]=ds[i][i]=0;\n        }\n        for(i=1;i<=m;i++){\n            int u,v,t;\n            char c;\n            scanf(\"%d %d %d %c\",&u,&v,&t,&c);\n            if(c=='L'){\n                dl[u][v]=min(dl[u][v],t);\n                dl[v][u]=dl[u][v];\n            }\n            else{\n                ds[u][v]=min(ds[u][v],t);\n                ds[v][u]=ds[u][v];\n            }\n        }\n        scanf(\"%d\",&r);\n        for(i=1;i<=r;i++) scanf(\"%d\",&city[i]);\n        for(k=1;k<=n;k++){\n            for(i=1;i<=n;i++){\n                for(j=1;j<=n;j++){\n                    dl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n                    ds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n                }\n            }\n        }\n        for(i=1;i<=r;i++){\n            for(j=1;j<=n;j++){\n                dp[i][j]=inf;\n            }\n        }\n        for(k=1;k<=n;k++){\n            dp[1][k]=ds[city[1]][k]+dl[k][city[1]];\n        }\n        for(i=2;i<=r;i++){\n            for(k=1;k<=n;k++){\n                for(j=1;j<=n;j++){\n                    if(j!=k){\n                        dp[i][k]=min(dp[i][k],dp[i-1][j]+dl[city[i-1]][j]+ds[j][k]+dl[k][city[i]]);\n                    }\n                    else{\n                        dp[i][k]=min(dp[i][k],dp[i-1][k]+dl[city[i-1]][city[i]]);\n                    }\n                }\n            }\n        }\n        int ans=inf;\n        for(i=1;i<=n;i++){\n            ans=min(ans,dp[r][i]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = 10000000;\nint land[200][200];\nint sea[200][200];\nint dp[1000][200];\n\nint main() {\n    int N,M,R,x,y,i,j,k,t;\n  string s;\n  while(cin>>N>>M, N|M) {\n\n    rep(i,200) {\n      rep(j,200) land[i][j] = sea[i][j] = inf;\n      land[i][i] = sea[i][i] = 0;\n    }\n\n    rep(i,M) {\n      cin>>x>>y>>t>>s;\n      x--,y--;\n      if(s == \"S\") {\n\tsea[x][y] = min(t, sea[x][y]);\n\tsea[y][x] = sea[x][y];\n      }else{\n\tland[x][y] = min(t, land[x][y]);\n\tland[y][x] = land[x][y];\n      }\n    }\n\n    rep(k,N) {\n      rep(i,N) {\n\trep(j,N) {\n\t  sea[i][j] = min(sea[i][k]+sea[k][j], sea[i][j]);\n\t  land[i][j] = min(land[i][k]+land[k][j], land[i][j]);\n\t}\n      }\n    }\n\n    cin>>R;\n    vector<int> path;\n    rep(i,1000) rep(j,200) dp[i][j] = inf;\n    rep(i, R) {\n      int kt;\n      cin>>kt;\n      kt--;\n      path.push_back(kt);\n    }\n\n    dp[0][path[0]] = 0;\n    for(i=1; i<R; ++i) {\n      for(j=0; j<N; ++j) {\n\tdp[i][j] = min(dp[i-1][j]+land[path[i-1]][path[i]],dp[i][j]);\n\n\tfor(k=0; k<N; ++k) {\n\t  int t = dp[i-1][j]+land[path[i-1]][j]+sea[j][k]+land[k][path[i]];\n\t  dp[i][k] = min(dp[i][k], t);\n\t}\n\t//cout<<i<<\": \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n\n    int ans = inf;\n    rep(i,N) {\n      ans = min(ans, dp[R-1][i]);\n      //cout<<i<<\" : \"<<dp[R-1][i]<<endl;\n    }\n\n    cout<<ans<<endl;\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define chmin(a,b) a=min(a,(b))\n\nusing namespace std;\nint main(void)\n{\n  const LL INF=2012345678;\n  for(;;){\n    int n,m;\n    cin >> n >> m;\n    if(!n&&!m) return 0;\n    LL wf[2][256][256];\n    REP(l,2) REP(i,n+1) REP(j,n+1) wf[l][i][j]=INF;\n    REP(l,2) REP(i,n+1) wf[l][i][i]=0;\n    REP(i,m){\n      LL x,y,t;\n      string s;\n      cin >> x >> y >> t >> s;\n      chmin(wf[s==\"L\"?0:1][x][y],t);\n      chmin(wf[s==\"L\"?0:1][y][x],t);\n    }\n    REP(l,2) REP(k,n+1) REP(i,n+1) REP(j,n+1) chmin(wf[l][i][j],wf[l][i][k]+wf[l][k][j]);\n    int r;\n    cin >> r;\n    vector<int> z;\n    z.resize(r);\n    REP(i,r) cin >> z[i];\n    LL cost[1024][256];\n    // i, boat\n    REP(i,r) REP(j,n+1) cost[i][j]=INF;\n    cost[0][z[0]]=0;\n    REP(i,r-1) REP(pre,n+1) REP(suc,n+1){\n      if(pre==suc) chmin(cost[i+1][suc],cost[i][pre]+wf[0][z[i]][z[i+1]]);\n      chmin(cost[i+1][suc],cost[i][pre]+wf[0][z[i]][pre]+wf[1][pre][suc]+wf[0][suc][z[i+1]]);\n    }\n    LL answer=INF;\n    REP(i,n+1) chmin(answer,cost[r-1][i]);\n    cout << answer << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Weight = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n};\nusing Graph = vector<vector<Edge>>;\n\nvoid add_bidirectional_edge(Graph& graph, int src, int dst, int weight) {\n    graph[src].push_back((Edge){src, dst, weight});\n    graph[dst].push_back((Edge){dst, src, weight});\n}\n\n// Verified: AOJ 2251 (Merry Christmas)\nvector<vector<Weight>> warshall_floyd(Graph graph) {\n    static const Weight inf = numeric_limits<Weight>::max() / 20;\n    vector<vector<Weight>> dist(graph.size(), vector<Weight>(graph.size(), inf));\n    REP(u, graph.size()) dist[u][u] = 0;\n    REP(u, graph.size()) for (auto& e : graph[u]) dist[e.src][e.dst] = e.weight;\n    REP(w, graph.size()) REP(u, graph.size()) REP(v, graph.size())\n        dist[u][v] = min(dist[u][v], dist[u][w] + dist[w][v]);\n    return dist;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M;\n    while (cin>>N>>M, N|M) {\n        Graph land(N), sea(N);\n        REP(i, M) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n            if (sl == 'L')\n                add_bidirectional_edge(land, x, y, t);\n            else\n                add_bidirectional_edge(sea, x, y, t);\n        }\n        int R; cin >> R;\n        vector<int> order(R);\n        REP(i, R) {\n            cin >> order[i];\n            --order[i];\n        }\n\n        if (R == 1) {\n            cout << \"0\\n\";\n            continue;\n        }\n\n        auto dist_land = warshall_floyd(land);\n        auto dist_sea  = warshall_floyd(sea);\n\n        vector<vector<int>> dp(2, vector<int>(N, 1e8));\n        dp[1][0] = 0;\n        REP(i, R-1) {\n            int curr = i%2, prev = 1-i%2;\n            int u = order[i], v = order[i+1];\n            REP(q, N) {\n                int value = 1e8;\n                REP(p, N) {\n                    if (p == q)\n                        value = min(value, dp[prev][p] + dist_land[u][v]);\n                    else\n                        value = min(value, dp[prev][p] + dist_land[u][p] + dist_sea[p][q] + dist_land[q][v]);\n                }\n                dp[curr][q] = value;\n            }\n        }\n        cout << *min_element(dp[(R-2)%2].begin(), dp[(R-2)%2].end()) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define INF (1ll<<58)\n\nlong long land[200][200] , ship[200][200] ;\n\t\nint main(){\n\tlong long n,m;\n\twhile(cin >> n >> m && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tlong long a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tlong long r; cin >> r;\n\t\tlong long R[1000];\t\n\t\trep(i,r)cin >> R[i] , R[i]--;\n\t\t\n\t\tlong long dp[2][200];\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tlong long newCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,200)dp[bit%2][j] = INF;\n\t\t}\n\t\tlong long ret = INF;\n\t\trep(i,n){\n\t\t\tret = min(dp[(r-1)%2][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint main(){\n    int n, m, x, y, t, r;\n    char sl;\n    while(scanf(\"%d%d\", &n, &m) &&  n!=0){\n        vector< vector<ll> > st(n, vector<ll>(n, LLONG_MAX)), lt(n, vector<ll>(n, LLONG_MAX));\n        rep(n){\n            st[i][i] = 0LL;\n            lt[i][i] = 0LL;\n        }\n        rep(m){\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'S'){\n                st[x][y] = t;\n                st[y][x] = t;\n            }else{\n                lt[x][y] = t;\n                lt[y][x] = t;\n            }\n        }\n\n        repp(k, n){\n            repp(i, n){\n                repp(j, n){\n                    if(st[i][k] != LLONG_MAX && st[k][j] != LLONG_MAX)\n                        st[i][j] = min(st[i][j], st[i][k] + st[k][j]);\n                    if(lt[i][k] != LLONG_MAX && lt[k][j] != LLONG_MAX)\n                        lt[i][j] = min(lt[i][j], lt[i][k] + lt[k][j]);\n                }\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(r){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // dp[i][j]: z[i]にいる，お船はjにあるときの最短時間\n        ll dp[r][n];\n        fill(dp[0], dp[r], LLONG_MAX);\n        dp[0][0] = 0LL;\n        repp(zi, r-1){\n            repp(j, n){\n                if(dp[zi][j] == LLONG_MAX) continue;\n                // 今の街に船があるなら，目的の街までor途中まで船で行ける\n                if(z[zi] == j){\n                    // z[zi]からkまで船で，kからz[zi+1]まで陸路で\n                    repp(k, n){\n                        if(st[z[zi]][k] != LLONG_MAX && lt[k][z[zi+1]] != LLONG_MAX){\n                            dp[zi+1][k] = min(dp[zi+1][k], dp[zi][j]+st[z[zi]][k]+lt[k][z[zi+1]]);\n                        }\n                    }\n                }\n                if(lt[z[zi]][z[zi+1]] != LLONG_MAX){\n                    dp[zi+1][j] = min(dp[zi+1][j], dp[zi][j] + lt[z[zi]][z[zi+1]]);\n                }\n            }\n        }\n\n        // rep(r){\n        //     repp(j, n){\n        //         printf(\"%5lld\", (dp[i][j] == LLONG_MAX?-1:dp[i][j]));\n        //     }\n        //     printf(\"\\n\");\n        // }\n\n        ll ans = LLONG_MAX;\n        repp(j, n){\n            ans = min(ans, dp[r-1][j]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) {\n  for (int k = 1; k <= n; ++k) {\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while (scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n\n    while (m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if (tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n\n    for (int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    for (int i = 1; i <= n; ++i) {\n      d[1][i] = min(d[1][i], s[b[1]][i] + l[i][b[1]]);\n    }\n\n    for (int i = 2; i <= r; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (l[j][b[i]] >= INF) continue;\n        for (int k = 1; k <= n; ++k) {\n          if (d[i - 1][k] >= INF) continue;\n          if (j == k) {\n            if (l[b[i - 1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][b[i]]);\n            }\n          } else {\n            if (l[b[i - 1]][k] < INF && s[k][j] < INF && l[j][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll l[201][201];\nll s[201][201];\nll dp[1001][201];\n\n\nint main(){\n\tint n,m,r;\n\twhile(cin >> n >> m && n!=0){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tl[i][j] = inf;\n\t\t\t\ts[i][j] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tl[i][j] = 0;\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(c=='L'){\n\t\t\t\tl[x][y] = t;\n\t\t\t\tl[y][x] = t;\n\t\t\t}else{\n\t\t\t\ts[x][y] = t;\n\t\t\t\ts[y][x] = t;\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tl[i][j] = min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j] = min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x11111111\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_cities;\n  int total_roads;\n\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n\n    int sea[201][201];\n    int land[201][201];\n    memset(sea,0x11,sizeof(sea));\n    memset(land,0x11,sizeof(land));\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int src,dst,time;\n      char type[2];\n      scanf(\"%d %d %d %s\",&src,&dst,&time,type);\n      if(type[0] == 'S'){\n\tsea[src][dst] = min(sea[src][dst],time);\n\tsea[dst][src] = min(sea[dst][src],time);\n      }\n      else if(type[0] == 'L'){\n\tland[src][dst] = min(land[src][dst],time);\n\tland[dst][src] = min(land[dst][src],time);\n      }\n    }\n    for(int src=1;src<=total_cities;src++){\n      int dst = src;\n      sea[src][dst] = 0;\n      land[src][dst] = 0;\n    }\n    int total_routes;\n    int routes[1001];\n    scanf(\"%d\",&total_routes);\n    for(int route_idx = 0; route_idx < total_routes; route_idx++){\n      int route;\n      scanf(\"%d\",&route);\n      routes[route_idx] = route;\n    }\n\n    int dp[201][201];\n    memset(dp,0x11,sizeof(dp));\n\n    for(int mid=1;mid<=total_cities;mid++){\n      for(int src=1;src<=total_cities;src++){\n\tfor(int dst=1;dst<=total_cities;dst++){\n\t  land[src][dst] = min(land[src][dst],land[src][mid] + land[mid][dst]);\n\t  sea[src][dst] = min(sea[src][dst],sea[src][mid] + sea[mid][dst]);\n\t}\n      }\n    }\n    \n    int ship[1001][201]; // ship[route_idx][city] = cost\n    memset(ship,0x11,sizeof(ship));\n    ship[0][routes[0]] = 0;\n\n    for(int route_idx = 1; route_idx < total_routes; route_idx++){\n      int prev_target = routes[route_idx - 1];\n      int target = routes[route_idx];\n\n      for(int mid1 = 1; mid1 <= total_cities; mid1++){\n\tship[route_idx][mid1] = min(ship[route_idx][mid1],ship[route_idx-1][mid1] + land[prev_target][target]);\n\n\tfor(int mid2 = 1; mid2 <= total_cities; mid2++){\n\t  ship[route_idx][mid2] = min(ship[route_idx][mid2],\n\t\t\t\t      ship[route_idx-1][mid1] + land[prev_target][mid1] + sea[mid1][mid2] + land[mid2][target]);\n\t}\n      }\n    }\n    int res = INF;\n    for(int city=1;city<=total_cities;city++){\n      res = min(ship[total_routes-1][city],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nint n, m;\nint walk[200][200], swim[200][200];\nint dp[1000][200];\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n >> m;\n    while (n || m) {\n        rep(i, 200) rep(j, 200) walk[i][j] = swim[i][j] = INF;\n        rep(i, m) {\n            int3(x, y, t);\n            string st;\n            cin >> st;\n            if (st[0] == 'L') {\n                walk[y-1][x-1] = walk[x-1][y-1] = min(walk[x-1][y-1], t);\n            } else {\n                swim[y-1][x-1] = swim[x-1][y-1] = min(swim[x-1][y-1], t);\n            }\n        }\n        Int(r);\n        vector<int> data(r);\n        for (int i = 0; i < r; i++) {\n            cin >> data[i];\n            data[i]--;\n        }\n\n        rep(i, n) walk[i][i] = swim[i][i] = 0;\n        rep(k, n) rep(i, n) rep(j, n) {\n            walk[i][j] = min(walk[i][j], walk[i][k] + walk[k][j]);\n            swim[i][j] = min(swim[i][j], swim[i][k] + swim[k][j]);\n        }\n        rep(i, 1000) rep(j, 200) dp[i][j] = INF;\n        dp[0][data[0]] = 0;\n\n        rep(i, r-1) rep(j, n) rep(k, n) {\n            if (j != k) \n            dp[i+1][k] = min(dp[i+1][k], dp[i][j] + walk[data[i]][j]\n                    + swim[j][k] + walk[k][data[i+1]]);\n            else \n            dp[i+1][k] = min(dp[i+1][k], \n                    dp[i][j] + walk[data[i]][data[i+1]]);\n        }\n\n        int ans = INF;\n        rep(i, n) ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n        cin >> n >> m;\n    }\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e8;\nconst int MAX_V = 256;\nconst int MAX_R = 1024;\nint dl[MAX_V][MAX_V];\nint ds[MAX_V][MAX_V];\nint dp[MAX_R][MAX_V];\nint Z[MAX_R];\nint N, M;\n\nvoid floyd()\n{\n    for (int k = 0; k < N; ++k)\n    {\n        for (int i = 0; i < N; ++i)\n        {\n            for (int j = 0; j < N; ++j)\n            {\n                dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n                ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (scanf(\"%d%d\", &N, &M) == 2 && N)\n    {\n        fill(dl[0], dl[0] + MAX_V * MAX_V, INF);\n        fill(ds[0], ds[0] + MAX_V * MAX_V, INF);\n        for (int i = 0; i < N; ++i)\n        {\n            dl[i][i] = ds[i][i] = 0;\n        }\n        int x, y, t;\n        char s;\n        for (int i = 0; i < M; ++i)\n        {\n            scanf(\"%d%d%d\", &x, &y, &t);\n            cin >> s;\n            --x, --y;\n            if (s == 'L')\n            {\n                dl[x][y] = min(dl[x][y], t);\n                dl[y][x] = dl[x][y];\n            }\n            else\n            {\n                ds[x][y] = min(ds[x][y], t);\n                ds[y][x] = ds[x][y];\n            }\n        }\n        int R;\n        scanf(\"%d\", &R);\n        for (int i = 0; i < R; ++i)\n        {\n            scanf(\"%d\", &Z[i]);\n            --Z[i];\n        }\n        floyd();\n        fill(dp[0], dp[0] + MAX_R * MAX_V, INF);\n        dp[0][Z[0]] = 0;\n        for (int i = 1; i < R; ++i)\n        {\n            for (int j = 0; j < N; ++j)\n            {\n                for (int k = 0; k < N; ++k)\n                {\n                    if (j == k)\n                    {\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[Z[i - 1]][Z[i]]);\n                    }\n                    else\n                    {\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[Z[i - 1]][k] + ds[k][j] + dl[j][Z[i]]);\n                    }\n                }\n            }\n        }\n        int res = *min_element(dp[R - 1], dp[R - 1] + N);\n        printf(\"%d\\n\", res);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \n#define INF 1e8\n#define MAX_V 256\n#define MAX_R 1024\nint dl[MAX_V][MAX_V];\t//\td[u][v]表示?e=(u,v)的??，不存在的?候等于无?大或者d[i][i] = 0\nint ds[MAX_V][MAX_V];\nint z[MAX_R];\nint dp[MAX_R][MAX_V];\t// dp[i][j] := 已?去了第i个?子后，船停在第j个?子里\nint N;\t\t\t\t\t//\t?点数\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n \n\tint M;\n\twhile (cin >> N >> M , N || M)\n\t{\n// \t\tmemset(dl, 0x3f, sizeof(dl));\n// \t\tmemset(ds, 0x3f, sizeof(ds));\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = ds[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = ds[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tfor (int i = 0; i < M; ++i)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t--x; --y;\n\t\t\tif (s == 'L')\n\t\t\t{\n\t\t\t\tdl[x][y] = min(dl[x][y], t);\n\t\t\t\tdl[y][x] = dl[x][y];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds[x][y] = min(ds[x][y], t);\n\t\t\t\tds[y][x] = ds[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint R;\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; ++i)\n\t\t{\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n \n\t\t// warshall_floyd\n\t\tfor (int k = 0; k < N; ++k)\n\t\t{\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// end of warshall_floyd\n \n\t\t// dp\n\t\t// 尼?3个0x3f3f3f3f加起来溢出了\n\t\t//memset(dp, 0x3f, sizeof(dp));\n\t\tfor (int i = 0; i < R; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\t// 去了首个?子后，船放在第i个?子里\n\t\t\t\t\t\t// 坐船去\t // 坐11路?回来\n\t\t\tdp[0][i] = ds[z[0]][i] + dl[i][z[0]];\n\t\t}\n\t\tfor (int i = 1; i < R; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t{\n\t\t\t\t\t\t//                          i-1站     + 从i-1站走旱路去j+ 从j走水路去k+从k走旱路去i\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[z[i - 1]][j] + ds[j][k] + dl[k][z[i]]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// j == k                   i-1站     + 从i-1站走旱路去i\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + dl[z[i - 1]][z[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tcout << *min_element(dp[R - 1], dp[R - 1] + N) << endl;\n\t}\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n\nconst lint INF = 1ll << 30;\ninline void chmin(lint &a, lint b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1001];\n\nlint solve()\n{\n\tstatic lint ldist[200][200];\n\tstatic lint sdist[200][200];\n\tstatic lint dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1001 * 200, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tlint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r], dp[r + 1]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl == \"L\") ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n\n    typedef tuple<ll,int,int> tpl;\n    ll dist[200][200];\n    fill_n((ll*)dist,200*200,infll);\n    dist[z[0]][z[0]]=0;\n    rep(i,1,r){\n        priority_queue<tpl,vector<tpl>,greater<tpl>> que;\n        rep(j,0,n){\n            rep(k,0,n){\n                if(dist[j][k]==inf) continue;\n                if(j==z[i-1]) que.push(make_tuple(dist[j][k],j,k));\n                else dist[j][k]=inf;\n            }\n        }\n        while(!que.empty()){\n            auto t=que.top();\n            que.pop();\n            ll d=get<0>(t);\n            int p1=get<1>(t),p2=get<2>(t);\n            if(d>dist[p1][p2]) continue;\n            for(auto &e:graph[p1][0]){\n                ll d_=d+e.second;\n                int p_=e.first;\n                if(d_>=dist[p_][p2]) continue;\n                dist[p_][p2]=d_;\n                que.push(make_tuple(d_,p_,p2));\n            }\n            if(p1!=p2) continue;\n            for(auto &e:graph[p1][1]){\n                ll d_=d+e.second;\n                int p_=e.first;\n                if(d_>=dist[p_][p_]) continue;\n                dist[p_][p_]=d_;\n                que.push(make_tuple(d_,p_,p_));\n            }\n        }\n    }\n    ll ans=infll;\n    rep(i,0,n) ans=min(ans,dist[z.back()][i]);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\nint main(void){\n\n\tint N,M;\n\tint x,y,t;\n\tchar sl;\n\tint R,zi;\n\tint bzi;\n\tint ans;\n\tint ldp[NMAX+1][NMAX+1];\n\tint sdp[NMAX+1][NMAX+1];\n\tint dp[NMAX+1][RMAX+1];\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=t;\n\t\t\t\tldp[y][x]=t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=t;\n\t\t\t\tsdp[y][x]=t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tdp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include    <iostream>\n#include    <cstdio>\n#include    <cstdlib>\n#include    <algorithm>\n#include    <vector>\n#include    <cstring>\n#include    <queue>\n#include    <complex>\n#include    <stack>\n#define LL long long\n#define dob double\n#define int LL\nusing namespace std;\n\nconst int N = 210;\nconst int R = 1010;\nLL n,m,Q,land[N][N],sea[N][N],f[R][N],Cit[N];\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n  return x*res;\n}\n\nmain()\n{\n  /*freopen(\"Mr._Rito_Post_Office .in\",\"r\",stdin);\n    freopen(\"Mr._Rito_Post_Office .out\",\"w\",stdout);*/\n  while((n=gi())+(m=gi())){\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)\n        land[i][j]=sea[i][j]=1e12;\n    for(int i=1;i<=n;++i)\n      land[i][i]=sea[i][i]=0;\n    for(int i=1;i<=m;++i){\n      int u=gi(),v=gi(),c=gi();\n      char type;scanf(\"%c\",&type);\n      if(type=='L')\n        land[u][v]=land[v][u]=min(land[u][v],c);\n      else sea[u][v]=sea[v][u]=min(sea[u][v],c);\n    }\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)\n        for(int k=1;k<=n;++k)\n          if(i!=j && i!=k && j!=k){\n            land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          }\n    Q=gi();\n    for(int i=0;i<=Q;++i)\n      for(int j=0;j<=n;++j)\n        f[i][j]=1e12;\n    for(int i=1;i<=Q;++i)Cit[i]=gi();\n    f[1][Cit[1]]=0;\n    for(int i=2;i<=Q;++i)\n      for(int j=1;j<=n;++j){\n        f[i][j]=min(f[i][j],f[i-1][j]+land[Cit[i-1]][Cit[i]]);\n        for(int k=1;k<=n;++k)\n          f[i][j]=min(f[i][j],f[i-1][k]+land[Cit[i-1]][k]+sea[j][k]+land[j][Cit[i]]);\n      }\n    for(int i=1;i<=n;++i)\n      f[0][0]=min(f[0][0],f[Q][i]);\n    printf(\"%lld\\n\",f[0][0]);\n  }\n  \n  /*fclose(stdin);\n    fclose(stdout);*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x11111111\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nint main(){\n  int total_cities;\n  int total_roads;\n\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n\n    int sea[201][201];\n    int land[201][201];\n    memset(sea,0x11,sizeof(sea));\n    memset(land,0x11,sizeof(land));\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int src,dst,time;\n      char type[2];\n      scanf(\"%d %d %d %s\",&src,&dst,&time,type);\n      if(type[0] == 'S'){\n\tsea[src][dst] = min(sea[src][dst],time);\n\tsea[dst][src] = min(sea[dst][src],time);\n      }\n      else if(type[0] == 'L'){\n\tland[src][dst] = min(land[src][dst],time);\n\tland[dst][src] = min(land[dst][src],time);\n      }\n    }\n    for(int src=1;src<=total_cities;src++){\n      int dst = src;\n      sea[src][dst] = 0;\n      land[src][dst] = 0;\n    }\n    int total_routes;\n    int routes[1001];\n    scanf(\"%d\",&total_routes);\n    for(int route_idx = 0; route_idx < total_routes; route_idx++){\n      int route;\n      scanf(\"%d\",&route);\n      routes[route_idx] = route;\n    }\n\n    int dp[201][201];\n    memset(dp,0x11,sizeof(dp));\n\n    for(int mid=1;mid<=total_cities;mid++){\n      for(int src=1;src<=total_cities;src++){\n\tfor(int dst=1;dst<=total_cities;dst++){\n\t  land[src][dst] = min(land[src][dst],land[src][mid] + land[mid][dst]);\n\t  sea[src][dst] = min(sea[src][dst],sea[src][mid] + sea[mid][dst]);\n\t}\n      }\n    }\n    \n    int ship[1001][201]; // ship[route_idx][city] = cost\n    memset(ship,0x11,sizeof(ship));\n    ship[0][routes[0]] = 0;\n    for(int route_idx = 1; route_idx < total_routes; route_idx++){\n      int prev_target = routes[route_idx - 1];\n      int target = routes[route_idx];\n\n      for(int mid1 = 1; mid1 <= total_cities; mid1++){\n\tfor(int mid2 = 1; mid2 <= total_cities; mid2++){\n\t  ship[route_idx][mid2] = min(ship[route_idx][mid2],\n\t\t\t\t      ship[route_idx-1][mid1] + land[prev_target][mid1] + sea[mid1][mid2] + land[mid2][target]);\n\t}\n      }\n    }\n    int res = INF;\n    for(int city=1;city<=total_cities;city++){\n      res = min(ship[total_routes-1][city],res);\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 100\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+1][NMAX+1];\n\tll sdp[NMAX+1][NMAX+1];\n\tll dp[NMAX+1][RMAX+1];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=t;\n\t\t\t\tldp[y][x]=t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=t;\n\t\t\t\tsdp[y][x]=t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tdp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <limits>\n#include <queue>\n#include <vector>\n#include <utility>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconstexpr int MAX_N = 200, MAX_R = 1000, INF = std::numeric_limits<int>::max()>>2;\n\nstruct edge\n{\n  int to, cost;\n  bool ship;\n\n  edge( int to, int cost, bool ship )\n  : to(to), cost(cost), ship(ship)\n  {}\n};\n\nstruct State\n{\n  int dist, v, ord, shipP;\n\n  State( int dist, int v, int ord, int shipP )\n  : dist(dist), v(v), ord(ord), shipP(shipP)\n  {}\n\n  bool operator< ( const State &s ) const\n  { return this->dist > s.dist; }\n};\n\nint N, M;\nstd::vector<edge> G[MAX_N];\nint R;\nint z[MAX_R];\nint dp[MAX_N][MAX_R][MAX_N];\n\nint main()\n{\n  while( scanf( \"%d%d\", &N, &M ), N|M )\n  {\n    rep( i, N )\n      G[i].clear();\n\n    rep( i, M )\n    {\n      int x, y, t;\n      char sl;\n      scanf( \"%d%d%d %c\", &x, &y, &t, &sl );\n      --x; --y;\n      //putchar(sl);\n      G[x].push_back( edge( y, t, sl=='S' ) );\n      G[y].push_back( edge( x, t, sl=='S' ) );\n    }\n\n    scanf( \"%d\", &R );\n    rep( i, R )\n      scanf( \"%d\", z+i ), --z[i];\n\n    std::priority_queue<State> pque;\n    pque.push( State( 0, z[0], 0, 0 ) );\n    std::fill( (int*)dp, (int*)(dp+N), INF );\n    dp[z[0]][0][0] = 0;\n\n    while( !pque.empty() )\n    {\n      State st = pque.top(); pque.pop();\n\n      if( st.dist > dp[st.v][st.ord][st.shipP] || st.ord == R-1 )\n        continue;\n\n      //printf( \"[%d %d %d %d]\\n\", st.dist, st.v, st.ord, st.shipP );\n\n      for( auto e : G[st.v] )\n      {\n        int nord = e.to == z[st.ord+1] ? st.ord+1 : st.ord;\n        \n        if( st.shipP == st.v && e.ship && dp[e.to][nord][e.to] > dp[st.v][st.ord][st.shipP]+e.cost )\n        {\n          dp[e.to][nord][e.to] = dp[st.v][st.ord][st.shipP]+e.cost;\n          pque.push( State( dp[e.to][nord][e.to], e.to, nord, e.to ) );\n        }\n\n        if( !e.ship && dp[e.to][nord][st.shipP] > dp[st.v][st.ord][st.shipP]+e.cost )\n        {\n          dp[e.to][nord][st.shipP] = dp[st.v][st.ord][st.shipP]+e.cost;\n          pque.push( State( dp[e.to][nord][st.shipP], e.to, nord, st.shipP ) );\n        }\n      }\n    }\n\n    int ans = INF;\n    rep( i, N )\n      ans = std::min( ans, dp[z[R-1]][R-1][i] );\n\n    printf( \"%d\\n\", ans );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define INT_MAX 100000\n\nusing namespace std;\n\nint lmap[201][201],smap[201][201];\nint dp[201][2];\nvector<int> order;\n\nint main(){\n  int n,m,r,i,j,k;\n  while(scanf(\"%d %d\",&n,&m),n){\n    order.clear();\n    for(i=0;i<201;i++){\n      for(j=0;j<201;j++)\n\tlmap[i][j]=smap[i][j]=INT_MAX;\n      dp[i][0]=dp[i][1]=0;\n    }\n\n    for(i=0;i<m;i++){\n      int x,y,t;\n      char w;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&w);\n      if(w=='L')\n\tlmap[x][y]=lmap[y][x]=min(lmap[x][y],t);\n      else\n\tsmap[x][y]=smap[y][x]=min(smap[x][y],t);\n    }\n    \n    scanf(\"%d\",&r);\n    for(i=0;i<r;i++){\n      scanf(\"%d\",&j);\n      order.push_back(j);\n    }\n\n    for(i=1;i<=n;i++) lmap[i][i]=smap[i][i]=0;\n\n    for(k=1;k<=n;k++)\n      for(i=1;i<=n;i++)\n\tfor(j=1;j<=n;j++){\n\t  lmap[i][j] = min(lmap[i][j],lmap[i][k]+lmap[k][j]);\n\t  smap[i][j] = min(smap[i][j],smap[i][k]+smap[k][j]);\n\t}\n    \n    // for(i=1;i<=n;i++){\n    //   for(j=1;j<=n;j++)\n    // \tif(lmap[i][j]<INT_MAX)\n    // \t  printf(\"%3d \",lmap[i][j]);\n    // \telse\n    // \t  printf(\"--- \");\n    //   putchar('\\n');\n    // }\n    // putchar('\\n');\n    // for(i=1;i<=n;i++){\n    //   for(j=1;j<=n;j++)\n    // \tif(smap[i][j]<INT_MAX)\n    // \t  printf(\"%3d \",smap[i][j]);\n    // \telse\n    // \t  printf(\"--- \");\n    //   putchar('\\n');\n    // }\n    // putchar('\\n');\n\n    for(i=r-2;i>=0;i--)\n      for(j=1;j<=n;j++){\n\tint mint=INT_MAX;\n\tfor(k=1;k<=n;k++){\n\t  int tmp;\n\t  if(k!=j)\n\t    tmp = dp[k][~i&1]+lmap[order[i+1]][k]+smap[k][j]+lmap[j][order[i]];\n\t  else\n\t    tmp = dp[k][~i&1]+lmap[order[i+1]][order[i]];\n\t  mint = min(mint,tmp);\n\t}\n\tdp[j][i&1] = mint;\n      }\n\n    printf(\"%d\\n\",dp[order[0]][0]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FI first\n#define SE second\n#define mp make_pair\n#define pb push_back\n#define fin(x) freopen(x,\"r\",stdin)\n#define fout(x) freopen(x,\"w\",stdout)\n#define mem(a,b) memset(a,b,sizeof(a))\nusing namespace std;\n//typedef long long int;\ntypedef pair<int,int> pii;\nconst int INF=1<<25;\nconst double pi=acos(-1);\nconst int MAX=205;\nint Land[MAX][MAX];\nint Sail[MAX][MAX];\nint N,M;\nint Min(int &x,int v)\n{x=min(x,v);}\nint dp[10010][MAX];\nint main()\n{\n\twhile(cin>>N>>M&&(N|M))\n\t{\t\t\n\t\tint i,j,k;\n\t\tfor(i=1;i<=N;i++)\n\t\t{\n\t\t\tfill(Land[i],Land[i]+MAX,INF);\n\t\t\tfill(Sail[i],Sail[i]+MAX,INF);\n\t\t\tfill(dp[0],dp[0]+MAX,INF);\n\t\t\tLand[i][i]=Sail[i][i]=0;\n\t\t}\n\t\twhile(M--)\n\t\t{\n\t\t\tint u,v,len;\n\t\t\tchar ch;\n\t\t\tcin>>u>>v>>len>>ch;\n\t\t\tif(ch=='L')\n\t\t\t{\n\t\t\t\tMin(Land[u][v],len);\n\t\t\t\tMin(Land[v][u],len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMin(Sail[u][v],len);\n\t\t\t\tMin(Sail[v][u],len);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=N;i++)\n\t\t{\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{\n\t\t\t\tfor(k=1;k<=N;k++)\n\t\t\t\t{\n\t\t\t\t\tMin(Land[i][j],Land[i][k]+Land[k][j]);\n\t\t\t\t\tLand[j][i]=Land[i][j];\n\t\t\t\t\tMin(Sail[i][j],Sail[i][k]+Sail[k][j]);\n\t\t\t\t\tSail[j][i]=Sail[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint R;\n\t\tcin>>R;\n\t\tint start;\n\t\tcin>>start;\n\t\tdp[0][start]=0;\n\t\tfor(i=1;i<R;i++)\n\t\t{\n\t\t\tint x;\n\t\t\tcin>>x;\n\t\t\tfill(dp[i],dp[i]+MAX,INF);\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{\n\t\t\t\tMin(dp[i][j],dp[i-1][j]+Land[x][start]);\n\t\t\t}\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{\n\t\t\t\tfor(k=1;k<=N;k++)\n\t\t\t\t{\n\t\t\t\t\tMin(dp[i][k],dp[i-1][j]+Sail[j][k]+Land[x][k]+Land[start][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=x;\n\t\t}\n\t\tint ans=INF;\n\t\tfor(i=1;i<=N;i++)Min(ans,dp[R-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][j] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int k = 0; k < n; k++){\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n  \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n  \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n  \nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n  \nint main(){\n    while(1){\n        int n,m;\n        static LL ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static LL sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)return 0;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static LL dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tint ret=1000000000;\n    \trep1(i,n){\n    \t\tret=min(ret,(int)dp[r-1][i]);\n    \t}\n          \n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define ll long long\n#define fi first\n#define fs sirst\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n \nint n,m;\nint riku[1111][1111], umi[1111][1111];\nvec dp;\n \nvoid solve() {\n    REP(i, n) REP(j, n) riku[i][j] = umi[i][j] = 1 << 28;\n    REP(i, n) riku[i][i] = umi[i][i] = 0;\n \n    REP(_, m) {\n        int x, y, c; char s;\n        cin >> x >> y >> c >> s;\n        x--; y--;\n        if (s == 'L') riku[x][y] = min(riku[x][y], c), riku[y][x] = min(riku[y][x], c);\n        else umi[x][y] = min(umi[x][y], c), umi[y][x] = min(umi[y][x], c);\n    }\n \n    int r;\n    cin >> r;\n    vec a(r,0);\n    REP(i, r) cin >> a[i], a[i]--;\n     \n    REP(k, n) {\n        REP(i, n) {\n            REP(j, n) {\n                riku[i][j] = min(riku[i][j],riku[i][k] + riku[k][j]);\n                umi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n            }\n        }\n    }\n \n    dp.assign(n, 1 << 28);\n    dp[a[0]] = 0;\n \n    REP(i, r-1) {\n        vec tmp(n, 1 << 28);\n        REP(j, n) {\n            tmp[j] = min(tmp[j], dp[j] + riku[a[i]][a[i + 1]]);\n \n            int base = riku[a[i]][j];\n            REP(k, n) {\n                tmp[k] = min(tmp[k], dp[j] + base + umi[j][k] + riku[k][a[i + 1]]);\n            }\n        }\n        dp = tmp;\n    }\n    int ans = 1 << 30;\n    REP(i, n) ans = min(ans, dp[i]);\n \n    cout << ans << endl;\n}\n \nint main() {\n    while (cin >> n >> m, n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nint main(void){\n  int N, M, R;\n  while (cin >> N >> M) \n    {\n      if (N == 0 && M == 0)\n\tbreak;\n      int x,y,t;\n      char sl;\n      vector<VI> land(N, VI(N, INT_MAX/4)), sea(N, VI(N, INT_MAX/4));\n      REP(i,0,M)\n\t{\n\t  cin >> x >> y >> t >> sl;\n\t  if (sl == 'L') \n\t    {\n\t      land[x-1][y-1] = t;\n\t      land[y-1][x-1] = t;\n\t    }\n\t  else\n\t    {\n\t      sea[x-1][y-1] = t;\n\t      sea[y-1][x-1] = t;\n\t    }\n\t}\n      cin >> R;\n      VI z(R);\n      REP(i,0,R)\n\t{\n\t  cin >> z[i];\n\t  z[i]--;\n\t}\n      REP(i,0,N)\n\t{\n\t  land[i][i] = 0;\n\t  sea[i][i] = 0;\n\t}\n      for (int r = 0; r < N; r++)\n\tfor (int p = 0; p < N; p++)\n\t  for (int q = 0; q < N; q++)\n\t    {\n\t      if (land[p][q] > land[p][r] + land[r][q])\n\t\tland[p][q] = land[p][r] + land[r][q];\n\t      if (sea[p][q] > sea[p][r] + sea[r][q])\n\t\tsea[p][q] = sea[p][r] + sea[r][q];\n\t    }\n      /*\n      cout << \"land:\"<<endl;\n      REP(i,0,N)\n\t{\n\t  REP(j,0,N)\n\t    cout << land[i][j] << \"\\t\";\n\t  cout << endl; \n\t}\n       cout << \"sea\"<<endl;\n      REP(i,0,N)\n\t{\n\t  REP(j,0,N)\n\t\tcout << sea[i][j] << \"\\t\";\n\t  cout << endl; \n\t}*/\n      vector<vector<ll> > dp(N, vector<ll>(R, INT_MAX/2));\n      dp[0][z[0]] = 0;\n      REP(i,1,R)\n\t{\n\t  REP(j,0,N)\n\t    {\n\t      //cout << \"j=\"<< j <<endl;\n\t      REP(k, 0, N)\n\t\t{\n\t\t  dp[i][j] = min(dp[i][j], dp[i-1][k] + land[z[i-1]][k]+ sea[k][j] + land[j][z[i]]);\n\t\t  //cout << dp[i-1][k] <<\"+\"<< sea[k][j] <<\"+\"<< land[j][z[i]] << \"\\t\";\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  /*\n\t  REP(i,0,R)\n\t    {\n\t      REP(j,0,N)\n\t\tcout << dp[i][j] << \"\\t\";\n\t      cout << endl; \n\t    }\n\t  cout << endl;\n\t  */\n\t}\n      ll min_cost = dp[R-1][0];\n      REP(i, 1,R)\n\tmin_cost = min(min_cost, dp[R-1][i]);\n      cout << min_cost<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\n#include<numeric>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(const vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(const vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nbool solve(void){\n\tint i,j,k,n,m;cin>>n>>m;\n\tif(n==0){return false;}\n\tvector<vector<llint>>land(n,vector<llint>(n,big));\n\tvector<vector<llint>>ship(n,vector<llint>(n,big));\n\tfor(i=0;i<n;i++){land[i][i]=0;ship[i][i]=0;}\n\tfor(i=0;i<m;i++){\n\t\tint x,y,t;char c;\n\t\tcin>>x>>y>>t>>c;x--;y--;\n\t\tif(c=='L'){mineq(land[x][y],t);mineq(land[y][x],t);}\n\t\t\t  else{mineq(ship[x][y],t);mineq(ship[y][x],t);}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tmineq(land[j][k],land[j][i]+land[i][k]);\n\t\t\t\tmineq(ship[j][k],ship[j][i]+ship[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint R,mae;cin>>R>>mae;R--;mae--;\n\tvector<llint>dco(n,big);dco[mae]=0;\n\twhile(R--){\n\t\tint bas;cin>>bas;bas--;\n\t\tvector<llint>dp=dco;\n\t\tfor(i=0;i<n;i++){dp[i]+=land[mae][bas];}//陸\n\t\t//海\n\t\tvector<llint>aaa(n,big);\n\t\tfor(i=0;i<n;i++){dco[i]+=land[mae][i];}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tmineq(aaa[j],dco[i]+ship[i][j]);\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<n;i++){mineq(dp[i],aaa[i]+land[i][bas]);}\n\t\tdco=dp;mae=bas;\n\t}\n\tllint ans=big;\n\tfor(i=0;i<n;i++){mineq(ans,dco[i]);}\n\tcout<<ans<<endl;\n\treturn true;\n}\nint main(void){\n\tcout<<fixed<<setprecision(20);\n\tcin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\nstruct node{\n    int index,boat,next,cost;\n    node(int index,int boat,int next,int cost):index(index),boat(boat),next(next),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nstruct edge{\n\tint lcost,scost;\n\tedge(int lcost,int scost):lcost(lcost),scost(scost){}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\n\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\ntypedef vector<vvi> vvvi;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n        vve graph(n,ve(n,edge(NONE,NONE)));\n        REP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tswitch(sl){\n\t\t\tcase 'S':\n\t\t\t\tgraph[x-1][y-1].scost=t;\n\t\t\t\tgraph[y-1][x-1].scost=t;\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tgraph[x-1][y-1].lcost=t;\n\t\t\t\tgraph[y-1][x-1].lcost=t;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n        }\n\t\tint r;\n\t\tcin>>r;\n\t\tvi order(r);\n\t\tREP(i,r){\n\t\t\tcin>>order[i];\n\t\t\torder[i]--;\n\t\t}\t\n        \n        priority_queue<node> q;\n\t\tint neeext=order[0]==0?1:0;\n        q.push(node(0,0,neeext,0));\n        vvvi cost(n,vvi(n,vi(r+1,MAX)));\n        cost[0][0][neeext]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.index][cnode.boat][cnode.next]<cnode.cost){\n                continue;\n            }\n            REP(i,n){\n\t\t\t\tif(i!=cnode.index&&graph[cnode.index][i].lcost!=NONE){\n\t\t\t\t\tint newcost=cnode.cost+graph[cnode.index][i].lcost;\n\t\t\t\t\tint next=cnode.next+(order[cnode.next]==i);\n\t\t\t\t\tif(cost[i][cnode.boat][next]>newcost){\n\t\t\t\t\t\tcost[i][cnode.boat][next]=newcost;\n\t\t\t\t\t\tif(next<r){\n\t\t\t\t\t\t\tq.push(node(i,cnode.boat,next,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n\t\t\t\tif(i!=cnode.index&&graph[cnode.index][i].scost!=NONE&&cnode.boat==cnode.index){\n\t\t\t\t\tint newcost=cnode.cost+graph[cnode.index][i].scost;\n\t\t\t\t\tint next=cnode.next+(order[cnode.next]==i);\n\t\t\t\t\tif(cost[i][i][next]>newcost){\n\t\t\t\t\t\tcost[i][i][next]=newcost;\n\t\t\t\t\t\tif(next<r){\n\t\t\t\t\t\t\tq.push(node(i,i,next,newcost));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n            }\n        }\n\t\tint ans=MAX;\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tans=min(ans,cost[i][j][r]);\n\t\t\t}\n\t\t}\n        cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",*min_element(dp[r-1].begin(),dp[r-1].end()));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int MAX_SIZE = 10000;\n\nstruct edge{\n\tint to;\n\tint cost;\n    char kind;\n};\n\nclass Situation{\npublic:\n\tint cost;\n\tint node;\n    int boat;\n    int obj;\n\n\tSituation(int cost_,int node_,int boat_,int obj_){\n\t\tcost=cost_;\n        node=node_;\n        boat=boat_;\n        obj=obj_;\n\t}\n\tSituation();\n\n\tbool operator<(const Situation &s)const{\n\t\treturn s.cost < this->cost;\n\t}\n};\n\nint V;\nint n,m;\n\nvector<int> objLands;\n\nconst int MAX_V = 205;\nvector<edge> G[MAX_V];\nint d[MAX_V][MAX_V][MAX_V];\nconst int INF = 1000000000;\n\nvoid dijkstra(int s){\n\tpriority_queue<Situation> que;\n    for(int i = 0; i < MAX_V; i++)\n        for(int j = 0; j < MAX_V; j++)\n            for(int k = 0; k < MAX_V; k++)\n                d[i][j][k]=INF;\n    d[s][0][s] = 0;\n    que.push(Situation(0,s,s,0));\n\twhile(!que.empty()){\n\t\tSituation p = que.top();\n\t\tque.pop();\n        int node=p.node;\n        int boat=p.boat;\n        int cost=p.cost;\n        int obj=p.obj;\n        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n\t\tif(d[node][obj][boat] < cost)\n            continue;\n\t\tfor(int i = 0; i < G[node].size(); i++){\n\t\t\tedge &e = G[node][i];\n            int toObj=obj;\n            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n            if(objLands[obj]==e.to)\n                toObj++;\n            // ¤ÌêÆCÌêÅêí¯\n            if(e.kind=='L'){\n                // ÅZ£\n                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n                    if(toObj!=objLands.size())\n                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n                }\n            }\n            else{\n                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n                if(boat==node){\n                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n                        if(toObj!=objLands.size())\n                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n                    }\n                }\n            }\n\t\t}\n\t}\n}\n\nint main(){\n\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        objLands.clear();\n        for(int i = 0; i < MAX_V; i++)\n            G[i].clear();\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char c;\n            cin>>from>>to>>cost>>c;\n            from--;to--;\n            edge e;\n            e.cost=cost;e.kind=c;e.to=to;\n            G[from].push_back(e);\n            e.to=from;\n            G[to].push_back(e);\n        }\n        int t;\n        cin>>t;\n        int s;\n        for(int i = 0; i < t; i++){\n            if(i==0){\n                cin>>s;\n                s--;\n            }\n            else{\n                int b;\n                cin>>b;\n                b--;\n                objLands.push_back(b);\n            }\n        }\n        dijkstra(s);\n        int minCost=INF;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++)\n                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n        }\n        cout<<minCost<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\nclass NODE{\npublic:\n\tint cost,pos,shipPos;\n\tNODE(int a,int b,int c){cost = a , pos = b , shipPos = c;};\n};\nbool operator < (const NODE & a, const NODE &b){\n\treturn a.cost > b.cost;\n}\nvector< vector<NODE> > land;\nvector< vector<NODE> > ship;\n\n\nint done[200][200];\nvoid dijkstra(int s,int t,int z){\n\tpriority_queue<NODE> Q;\n\tQ.push(NODE(0,s,z));\n\trep(i,200)rep(j,200)done[i][j] = INF; \n\twhile(!Q.empty()){\n\t\tNODE q = Q.top(); Q.pop();\n\t\t//cout << q.pos << \" \" << q.shipPos << endl;\n\t\tif(done[q.pos][q.shipPos] > q.cost){\n\t\t\tdone[q.pos][q.shipPos] = q.cost;\n\t\t}else continue;\n\t\t\n\t\tif(q.pos == q.shipPos){\n\t\t\trep(i,ship[q.pos].size()){\n\t\t\t\tQ.push( NODE(q.cost+ship[q.pos][i].cost,ship[q.pos][i].pos,ship[q.pos][i].pos) );\n\t\t\t}\n\t\t}\n\t\trep(i,land[q.pos].size()){\n\t\t\tQ.push( NODE(q.cost+land[q.pos][i].cost,land[q.pos][i].pos,q.shipPos) );\n\t\t}\n\t}\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m , n){\n\t\t//rep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\tland.clear() , ship.clear();\n\t\tland.resize(n) , ship.resize(n);\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tint a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a].push_back(NODE(c,b,0)),land[b].push_back(NODE(c,a,0));\n\t\t\telse ship[a].push_back(NODE(c,b,0)),ship[b].push_back(NODE(c,a,0));\n\t\t}\n\t\tint r; cin >> r;\n\t\tint R[1000];\n\t\trep(i,r){\n\t\t\tcin >> R[i] , R[i]--;\n\t\t}\n\t\tint dp[2][200][200];\n\t\trep(i,2)rep(j,200)rep(k,200)dp[i][j][k] = INF;\n\t\tdp[0][R[0]][R[0]] = 0;\n\t\trep(bit,r-1){\n\t\t\trep(sp,200){\n\t\t\t\tif(dp[bit%2][R[bit]][sp] != INF){\n\t\t\t\t\t//cout << bit << \" \" << sp << \" cost is \" << dp[bit%2][R[bit]][sp] << \"[[\" << endl;\n\t\t\t\t\tdijkstra(R[bit],R[bit+1],sp);\n\t\t\t\t\trep(j,200)dp[(bit+1)%2][R[bit+1]][j] = \n\t\t\t\t\t\tmin( dp[(bit+1)%2][R[bit+1]][j],dp[bit%2][R[bit]][sp]+done[R[bit+1]][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,200)rep(j,200)dp[bit%2][i][j] = INF;\n\t\t}\n\t\tint ret = INF;\n\t\trep(i,200){\n\t\t\tret = min(dp[(r-1)%2][R[r-1]][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nconst int INF  = 10000 * 10000;\nconst int MAXN = 210;\nconst int MAXR = 1010;\n\nint l_dist[MAXN][MAXN];\nint s_dist[MAXN][MAXN];\nint dp[MAXR][MAXN];\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, R;\n\n  while (cin >> N >> M && N + M){\n    fill(&l_dist[0][0], &l_dist[0][0] + MAXN * MAXN, INF);\n    fill(&s_dist[0][0], &s_dist[0][0] + MAXN * MAXN, INF);\n    fill(&dp[0][0], &dp[0][0] + MAXN * MAXN, INF);\n\n    REP(i, N){\n      l_dist[i][i] = 0;\n      s_dist[i][i] = 0;\n    }\n\n    REP(i, M){\n      int x, y, t;\n      string sl;\n      \n      cin >> x >> y >> t >> sl; x--, y--;\n      if (sl == \"L\"){\n        l_dist[x][y] = l_dist[y][x] = min(l_dist[x][y], t);\n      } else {\n        s_dist[x][y] = s_dist[y][x] = min(s_dist[x][y], t);\n      }\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      l_dist[i][j] = min(l_dist[i][j], l_dist[i][k] + l_dist[k][j]);\n      s_dist[i][j] = min(s_dist[i][j], s_dist[i][k] + s_dist[k][j]);\n    }\n\n    cin >> R;\n    vector<int> zs(R);\n    REP(i, R){\n      cin >> zs[i]; zs[i]--;\n    }\n\n    dp[0][zs[0]] = 0;\n    \n    REP2(i, 1, R) REP(u, N) if (dp[i - 1][u] < INF){\n      // cout << i - 1 << \" \" << u << endl;\n      int cz = zs[i - 1];\n      int nz = zs[i];\n\n      dp[i][u] = min(dp[i][u], dp[i - 1][u] + l_dist[cz][nz]);\n      \n      REP(v, N){\n        dp[i][v] = min(dp[i][v], dp[i - 1][u] + l_dist[cz][u] + s_dist[u][v] + l_dist[v][nz]);\n      }\n    }\n    \n    int res = INF;\n    REP(i, N){\n      res = min(res, dp[R - 1][i]);\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n\nconst lint INF = 1ll << 56;\ninline void chmin(lint &a, lint b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1001];\n\nlint solve()\n{\n\tstatic lint ldist[200][200];\n\tstatic lint sdist[200][200];\n\tstatic lint dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1001 * 200, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tchmin(dp[i + 1][j], dp[i][j] + ldist[src][dst]);\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tlint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r], dp[r + 1]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl == \"L\") ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\twhile (cin >> n >> m && (n)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tfor (int i = 1; i <= 200; i++)for (int j = 0; j < r; j++)dp[j][i] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tint ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e8;\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > adjL(n, vector<int>(n, inf)), adjS(n, vector<int>(n, inf));\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl=='L'){\n\t\t\t\tadjL[x][y] = adjL[y][x] = min(adjL[x][y], t);\n\t\t\t}else{\n\t\t\t\tadjS[x][y] = adjS[y][x] = min(adjS[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tadjL[i][i]=0;\n\t\t\tadjS[i][i]=0;\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0; i<r; i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tadjL[i][j] = min(adjL[i][j], adjL[i][k]+adjL[k][j]);\n\t\t\t\t\tadjS[i][j] = min(adjS[i][j], adjS[i][k]+adjS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(r, vector<int>(n, inf));\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=0; i<r-1; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k==j){\n\t\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j]+adjL[z[i]][z[i+1]]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j]+adjL[z[i]][j]+adjS[j][k]+adjL[k][z[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=inf;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tans = min(ans, dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\nint N, M, R;\nint ds[200][200],dl[200][200];//ship walk\nint list[1000];\nint dp[1000][200];\n\nint main() {\n\twhile (cin >> N >> M, N + M) {\n\t\tfor (int i = 0; i < N; i++)for (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i == j)dl[i][j] = ds[i][j] = 0;\n\t\t\telse dl[i][j] = ds[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, cost;\n\t\t\tchar c;\n\t\t\tcin >> a >> b >> cost >> c;\n\t\t\ta--, b--;\n\t\t\tif (c == 'L') dl[a][b] = min(cost, dl[a][b]), dl[b][a] = dl[a][b];\n\t\t\telse ds[a][b] = min(cost, ds[a][b]), ds[b][a] = ds[a][b];\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++)cin >> list[i],list[i]--;\n\t\t//???????????£??????????????????\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; i++)for (int j = 0; j < N; j++)dp[i][j] = INF;\n\t\t//dp[i][j] := i???????????????????????°??§???j?????????????????¨??????????????¨?????????????????????????????????\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdp[0][i] = ds[list[0]][i] + dl[i][list[0]];\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k)dp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[list[i]][list[i - 1]]);\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[list[i - 1]][k] + ds[k][j] + dl[j][list[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; i++)ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n,m;\nint dl[200][200], ds[200][200],dp[1001][200];\nconst int inf = 500000000;\n\nint main() {\n while(cin >> n >> m, n) {\n  for (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dl[i][j] = ds[i][j] = inf;\n  for (int i = 0; i < n; i++)dl[i][i] = ds[i][i] = 0;\n  for (int i = 0; i < m; i++) {\n   int x,y,t;\n   char c;\n   cin >> x >> y >> t >> c;\n   x--, y--;\n   if (c == 'L') {\n    dl[x][y] = min(dl[x][y],t);\n    dl[y][x] = min(dl[y][x], t);\n   } else {\n    ds[x][y] = min(ds[x][y],t);\n    ds[y][x] = min(ds[y][x], t);\n   }\n  }\n  for (int k = 0; k < n; k++) {\n   for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n     dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n     ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n    }\n   }\n  }\n  int r, initz, pos;\n  cin >> r >> initz;\n  for (int i = 0; i < r; i++)for (int j = 0; j < n; j++)dp[i][j] = inf;\n  dp[0][initz] = 0;\n  pos = initz;\n  for (int i = 1; i < r; i++) {\n   int z;\n   cin >> z;\n   z--;\n   for (int j = 0; j < n; j++) {\n    dp[i][j] = min(dp[i][j], dp[i-1][j] + dl[pos][z]);\n    for (int k = 0; k < n; k++) {\n     dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[pos][k] + ds[k][j] + dl[j][z]);\n    }\n   }\n   pos = z;\n  }\n  int ans = inf;\n  for (int i = 0; i < n; i++) {\n   ans = min(ans, dp[r-1][i]);\n  }\n  cout << ans << endl;\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := 集配先\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      if(dp[i][j] == inf)continue;\n\n\t      //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t      //dp[i+1][j] = min(dp[i+1][j],\n\t\t\t\t //\t       dp[i][j]+LG[v[i]][v[i+1]]);\n\t      //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl; \n\t      rep(k,N)\n\t\t{\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t\t   dp[i][j] + SG[j][k] + LG[v[i]][j] + LG[k][v[i+1]]);\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t      \n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\nint cnt = 0;\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (M >= 10000) { cnt++; }\n\t\tif (cnt >= 2) { return 0; }\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint const MAX_N = 210;\nint const MAX_R = 1010;\nint const INF = 1<<29;\nll dpl[MAX_N][MAX_N];\nll dps[MAX_N][MAX_N];\nll dp[MAX_R][MAX_N];\nll N, M, R;\nint z[MAX_R];\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      dpl[i][i] = dps[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n        dpl[i][j] = dpl[j][i] = INF;\n        dps[i][j] = dps[j][i] = INF;\n      }\n    }\n    \n    for(int i=0; i<M; i++) {\n      int x, y, c; char ls;\n      cin >> x >> y >> c >> ls; x--, y--;\n      if(ls == 'L') {\n        dpl[x][y] = dpl[y][x] = c;\n      }\n      else {\n        dps[x][y] = dps[y][x] = c;\n      }\n    }\n    \n    int r; cin >> r;\n    for(int i=0; i<r; i++) {\n      cin >> z[i]; z[i] --;\n    }\n    \n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          dpl[i][j] = min(dpl[i][j], dpl[i][k]+dpl[k][j]);\n          dps[i][j] = min(dps[i][j], dps[i][k]+dps[k][j]);\n        }\n      }\n    }\n\n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++)\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s] + dpl[z[i-1]][s] + dps[s][t] + dpl[t][z[i]]);\n          dp[i][t] = min(dp[i][t], dp[i-1][t] + dpl[z[i-1]][z[i]]);\n        }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nint parent[210],height[201];\nint N,M;\n\nstruct Info{\n\tint shima_id;\n\tbool isMinato;\n};\n\nint getParent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = getParent(parent[id]);\n\t}\n}\n\nbool isSame(int a, int b){\n\treturn getParent(a) == getParent(b);\n}\n\nvoid unite(int a,int b){\n\tint a_parent = getParent(a);\n\tint b_parent = getParent(b);\n\n\tif(a_parent == b_parent)return;\n\n\tif(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tif(height[a_parent] == height[b_parent])height[b_parent]++;\n\t\tparent[a_parent] = b_parent;\n\t}\n}\n\nvoid init_array(){\n\tfor(int i = 0; i < N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tInfo info[N];\n\tfor(int i = 0; i < N; i++)info[i].isMinato = false;\n\n\tint land_dist[N][N],sea_dist[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(i != k){\n\t\t\t\tland_dist[i][k] = BIG_NUM;\n\t\t\t\tsea_dist[i][k] = BIG_NUM;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tland_dist[i][k] = 0;\n\t\t\t\tsea_dist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tinit_array();\n\n\tvector<int> MINATO[N];\n\n\tint from,to,time;\n\tchar buf[2];\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %s\",&from,&to,&time,buf);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(buf[0] == 'L'){\n\t\t\tland_dist[from][to] = min(land_dist[from][to],time);\n\t\t\tland_dist[to][from] = min(land_dist[to][from],time);\n\t\t\tunite(from,to);\n\t\t}else{\n\t\t\tsea_dist[from][to] = min(sea_dist[from][to],time);\n\t\t\tsea_dist[to][from] = min(sea_dist[to][from],time);\n\n\t\t\tinfo[from].isMinato = true;\n\t\t\tinfo[to].isMinato = true;\n\t\t}\n\t}\n\n\tfor(int a = 0; a < N; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tif(land_dist[b][a] == BIG_NUM)continue;\n\t\t\tfor(int c = 0; c < N; c++){\n\t\t\t\tif(land_dist[a][c] == BIG_NUM)continue;\n\t\t\t\tland_dist[b][c] = min(land_dist[b][c],land_dist[b][a] + land_dist[a][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < N; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tif(sea_dist[b][a] == BIG_NUM)continue;\n\t\t\tfor(int c = 0; c < N; c++){\n\t\t\t\tif(sea_dist[a][c] == BIG_NUM)continue;\n\t\t\t\tsea_dist[b][c] = min(sea_dist[b][c],sea_dist[b][a] + sea_dist[a][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool check[N];\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\tfor(int i = 0; i < N; i++)check[getParent(i)]  = true;\n\n\tint shima_id = 0,table[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(check[i]){\n\t\t\ttable[i] = shima_id++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tinfo[i].shima_id = table[parent[i]];\n\t\tif(info[i].isMinato == true){\n\t\t\tMINATO[info[i].shima_id].push_back(i);\n\t\t}\n\t}\n\n\tint R;\n\tscanf(\"%d\",&R);\n\n\tint sche[R];\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d\",&sche[i]);\n\t\tsche[i]--;\n\t}\n\n\tint min_Cost[R][N];\n\n\tfor(int i = 0; i < R; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tmin_Cost[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tmin_Cost[0][sche[0]] = 0;\n\n\tint current_town,next_town,current_shima_id,next_shima_id,tmp,next_minato;\n\n\tfor(int i = 0; i < R-1; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(min_Cost[i][k] == BIG_NUM)continue;\n\n\t\t\tcurrent_town = sche[i];\n\t\t\tnext_town = sche[i+1];\n\t\t\tcurrent_shima_id = info[current_town].shima_id;\n\t\t\tnext_shima_id = info[next_town].shima_id;\n\n\t\t\tif(current_shima_id == next_shima_id){\n\n\t\t\t\tif(land_dist[current_town][next_town] != BIG_NUM){\n\t\t\t\t\tmin_Cost[i+1][k] = min(min_Cost[i+1][k],min_Cost[i][k]+land_dist[current_town][next_town]);\n\t\t\t\t}\n\n\t\t\t\ttmp = land_dist[current_town][k];\n\t\t\t\tfor(int a = 0; a < MINATO[current_shima_id].size();a++){\n\t\t\t\t\tnext_minato = MINATO[current_shima_id][a];\n\t\t\t\t\tif(next_minato == k)continue;\n\n\t\t\t\t\tif(sea_dist[k][next_minato] != BIG_NUM && land_dist[next_minato][next_town] != BIG_NUM){\n\t\t\t\t\t\tmin_Cost[i+1][next_minato] = min(min_Cost[i+1][next_minato],min_Cost[i][k]+tmp+sea_dist[k][next_minato]+land_dist[next_minato][next_town]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}else{\n\n\t\t\t\ttmp = land_dist[current_town][k];\n\n\t\t\t\tfor(int a = 0; a < MINATO[next_shima_id].size();a++){\n\t\t\t\t\tnext_minato = MINATO[next_shima_id][a];\n\n\t\t\t\t\tif(sea_dist[k][next_minato] != BIG_NUM && land_dist[next_minato][next_town] != BIG_NUM){\n\t\t\t\t\t\tmin_Cost[i+1][next_minato] = min(min_Cost[i+1][next_minato],min_Cost[i][k]+tmp+sea_dist[k][next_minato]+land_dist[next_minato][next_town]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\tfor(int i = 0; i < N; i++)ans = min(ans,min_Cost[R-1][i]);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tint d, z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nint dp[205][205];\t\t// boat, n\nint ans[205];  // boat\n\nint solve(){\n\tpriority_queue<ST> que;\n\tint d, z, b, n;\n\t//dp[ Z[0] ][ Z[0] ] = 0;\n\tans[ Z[0] ] = 0;\n\trep(i,R-1){\n\t\trep(b,N) if( ans[b] < INF ){\n\t\t\tque.push( ST{ans[b], i, b, Z[i]} );\n\t\t}\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\twhile( !que.empty() ){\n\t\t\tST st = que.top();\n\t\t\tque.pop();\n\t\t\td = st.d;\n\t\t\tz = st.z;\n\t\t\tb = st.b;\n\t\t\tn = st.n;\n\t\t\tif( !chmin(dp[b][n], d) ) continue;\n\t\t\t//dp[b][n] = d;\n\t\t\t//cout << \"hit \" << d << \" \" << z << \" \" << b << \" \" << n << endl;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\t\tint to = _v.first;\n\t\t\t\t\tint cost = _v.second;\n\t\t\t\t\tint nz = z, nb = b;\n\t\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\t\tif( k ) nb = to;\n\t\t\t\t\tif( dp[nb][to] > dp[b][n] + cost ){\n\t\t\t\t\t\tint nd = dp[b][n] + cost;\n\t\t\t\t\t\tif( nz == z ){\n\t\t\t\t\t\t\tque.push( ST{ nd, nz, nb, to } );\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tchmin( ans[nb], nd );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = INF;\n\trep(b,N){\n\t\tchmin( ret, ans[b] );\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x, y, t;\n\tchar sl;\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tlong long int CL[300][300], CS[300][300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tCL[i][j] = INF;\n\t\t\t\tCS[i][j] = INF;\n\t\t\t}\n\t\t\tCL[i][i] = 0;\n\t\t\tCS[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(str == \"L\"){\n\t\t\t\tCL[u][v] = cost;\n\t\t\t\tCL[v][u] = cost;\n\t\t\t}else{\n\t\t\t\tCS[u][v] = cost;\n\t\t\t\tCS[v][u] = cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tCL[i][j] = min(CL[i][j], CL[i][k] + CL[k][j]);\n\t\t\tCS[i][j] = min(CS[i][j], CS[i][k] + CS[k][j]);\n\t\t}\n\t\t\n\t\tint R, pre, num;\n\t\tcin >> R;\n\t\tcin >> pre;\n\t\tpre--;\n\t\t\n\t\tlong long int ans = INF, DP1[300], DP2[300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tDP1[i] = INF;\n\t\t}\n\t\tDP1[pre] = 0;\n\t\tfor(int i = 1; i < R; i++){\n\t\t\tcin >> num;\n\t\t\tnum--;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tDP2[j] = DP1[j] + CL[pre][num];\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tDP2[j] = min(DP2[j], CL[pre][k] + DP1[k] + CS[k][j] + CL[j][num]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(DP1, DP2);\n\t\t\tpre = num;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans = min(ans, DP1[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e8;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint ldist[210][210];\nint sdist[210][210];\nint dp[210], dp2[210];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n)\tldist[i][j] = sdist[i][j] = (i == j ? 0 : inf);\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)\trep(i, n)\trep(j, n) {\n\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tcin\t>> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, n)\tdp[i] = ldist[i][z[0]];\n\t\trep(i, n)\tdp2[i] = inf;\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n)\trep(k, n) {\n\t\t\t\tdp2[j] = min(dp2[j], dp[k] + ldist[z[i - 1]][k] + sdist[k][j] + ldist[j][z[i]]);\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tdp[j] = dp2[j];\n\t\t\t\tdp2[j] = inf;\n\t\t\t}\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int INF = 10000000;\nconst int MAX_V = 210;\nconst int MAX_R = 1010;\nint dl[MAX_V][MAX_V];\nint ds[MAX_V][MAX_V];\nint n, m, r;\nint x, y, t;\nchar type[3];\n\nint order[MAX_R];\nint dp[MAX_R][MAX_V];\n\n\n\nint main() {\n    while(scanf(\"%d%d\", &n, &m) != EOF && n) {\n        for(int i = 0; i < MAX_V; i++) {\n            fill(dl[i], dl[i] + MAX_V, INF);\n            fill(ds[i], ds[i] + MAX_V, INF);\n        }\n        for(int i = 0; i < m; i++) {\n            scanf(\"%d%d%d%s\", &x, &y, &t, type);\n            if(type[0] == 'L') {\n                dl[x][y] = min(dl[x][y], t);\n                dl[y][x] = min(dl[y][x], t);\n            } else {\n                ds[x][y] = min(ds[x][y], t);\n                ds[y][x] = min(ds[y][x], t);\n            }\n        }\n\n        for(int i = 1; i <= n; i++) {\n            ds[i][i] = 0;\n            dl[i][i] = 0;\n        }\n\n        for(int k = 1; k <= n; k++) {\n            for(int i = 1; i <= n; i++) {\n                for(int j = 1; j <= n; j++) {\n                    dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        scanf(\"%d\", &r);\n        for(int i = 1; i <= r; i++) {\n            scanf(\"%d\", &order[i]);\n        }\n        \n        for(int i = 0; i < MAX_R; i++) {\n            fill(dp[i], dp[i] + MAX_V, INF);\n        }\n        \n        for(int i = 1; i <= n; i++) {\n            dp[1][i] = ds[order[1]][i] + dl[i][order[1]];\n        }\n        for(int i = 2; i <= r; i++) {\n            for(int j = 1; j <= n; j++) {\n                if(dl[order[i]][j] == INF) continue;\n                for(int k = 1; k <= n; k++) {\n                    if(j == k) {\n                        if(dl[order[i-1]][order[i]] == INF) continue;\n                        dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[order[i-1]][order[i]]);\n                    }\n                    else {\n                        if(dl[order[i-1]][k] == INF || ds[k][j] == INF || dl[j][order[i]] == INF) continue;\n                        dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[order[i-1]][k] + ds[k][j] + dl[j][order[i]]);\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        for(int i = 1; i <= n; i++) {\n            ans = min(ans, dp[r][i]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nusing namespace std;\n\n#define N 205\n#define R 1005\n#define INF INT_MAX\n\nint hl[N][N], sl[N][N];\nint pack[R];\n\nint dp[R][N];\n\nint n, m, r;\n\nvoid warshall_floyd(){\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (hl[i][k] != INF && hl[k][j] != INF){\n\t\t\t\t\thl[i][j] = min(hl[i][j], hl[i][k] + hl[k][j]);\n\t\t\t\t}\n\t\t\t\tif (sl[i][k] != INF && sl[k][j] != INF){\n\t\t\t\t\tsl[i][j] = min(sl[i][j], sl[i][k] + sl[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solve(){\n\twarshall_floyd();\n\tfor (int i = 0; i < r; i++){\n\t\tfor (int j = 0; j < n; j++) dp[i][j] = INF;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tif (sl[pack[0]][i] != INF && hl[i][pack[0]] != INF)\n\t\t\tdp[0][i] = sl[pack[0]][i] + hl[i][pack[0]];\n\t}\n\tfor (int i = 1; i < r; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tif (k == j){\n\t\t\t\t\tif (dp[i - 1][j] != INF && hl[pack[i - 1]][pack[i]] != INF)\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + hl[pack[i - 1]][pack[i]]);\n\t\t\t\t}else{\n\t\t\t\t\tif (dp[i - 1][j] != INF && hl[pack[i - 1]][j] != INF && sl[j][k] != INF && hl[k][pack[i]] != INF)\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + hl[pack[i - 1]][j] + sl[j][k] + hl[k][pack[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint rst = INF;\n\tfor (int i = 0; i < n; i++){\n\t\trst = min(rst, dp[r - 1][i]);\n\t}\n\treturn rst;\n}\n\nint main(){\n\twhile (~scanf(\"%d %d\", &n, &m)){\n\t\tif (n == 0 && m == 0) break;\n\t\tint from, to, t;\n\t\tchar type;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\thl[i][j] = sl[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\thl[i][j] = sl[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tscanf(\"%d %d %d %c\", &from, &to, &t, &type);\n\t\t\tfrom--, to--;\n\t\t\tif (type == 'L'){\n\t\t\t\thl[from][to] = min(t, hl[from][to]);\n\t\t\t\thl[to][from] = hl[from][to];\n\t\t\t}else{\n\t\t\t\tsl[from][to] = min(t, sl[from][to]);\n\t\t\t\tsl[to][from] = sl[from][to];\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tscanf(\"%d\", &pack[i]);\n\t\t\tpack[i]--;\n\t\t}\n\t\tint ans = solve();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=205;\nconst int MAX_M=10000;\nconst int MAX_R=1005;\nconst int INF=0x3f3f3f3f;\n\nint land[MAX_N][MAX_N];\nint water[MAX_N][MAX_N];\nint N, M, R;\nint dp[MAX_R][MAX_N];\nint dest[MAX_R];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    while((cin>>N>>M) && N>0){\n        memset(land, 0x3f, sizeof(land));\n        memset(water, 0x3f, sizeof(water));\n        memset(dp, 0x3f, sizeof(dp));\n        int x, y, t; char sl;\n        for(int i=0; i<M; i++){\n            scanf(\"%d %d %d %c \", &x, &y, &t, &sl);\n            --x; --y;\n            if(sl=='L'){\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=land[x][y];\n\t\t\t}\n            else {\n\t\t\t\twater[x][y]=min(water[x][y], t);\n\t\t\t\twater[y][x]=water[x][y];\n\t\t\t}\n        }\n        for(int i=0; i<N; i++) water[i][i]=land[i][i]=0;\n        for(int i=0; i<N; i++){\n        \tfor(int j=0; j<N; j++){\n            \tfor(int k=0; k<N; k++){\n                \tland[j][k]=min(land[j][k], land[j][i]+land[i][k]);\n                \twater[j][k]=min(water[j][k], water[j][i]+water[i][k]);\n            \t}\n        \t}\n   \t    }\n        cin>>R;\n        for(int i=0; i<R; i++) {\n\t\t\tcin>>dest[i]; --dest[i];\n\t\t}\n        for(int i=0; i<N; i++) dp[0][i]=water[dest[0]][i]+land[dest[0]][i];\n        int pre=dest[0], z, t;\n        for(int i=1; i<R; i++){\n            z=dest[i]; \n            for(int j=0; j<N; j++){\n                int mincost=INF;\n                for(int k=0; k<N; k++){\n                    if(dp[i-1][k]!=INF && water[j][k]!=INF \n                    && land[pre][k]!=INF && land[z][j]!=INF){\n                        if(j==k) t=dp[i-1][k]+land[pre][z];\n                        else t=dp[i-1][k]+water[k][j]+land[pre][k]+land[j][z];\n                        mincost=min(mincost, t);\n                    }\n                }\n                dp[i][j]=mincost;\n            }\n            pre=z;\n        }\n        int mincost=INF;\n        for(int i=0; i<N; i++) mincost=min(mincost, dp[R-1][i]);\n        cout<<mincost<<endl;\n    }\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<unsigned char,unsigned char,short> tpl;\n    //static int dist[200][200][1001];\n    //fill_n((int*)dist,200*200*1001,inf);\n    map<tpl,int> dist;\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    //dist[z[0]][z[0]][1]=true;\n    dist[make_tuple(z[0],z[0],1)]=0;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        //if(d>dist[p1][p2][num]) continue;\n        if(d>dist[t.second]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n\n        if(p1==z[num]){\n            auto t_=make_tuple(p1,p2,num+1);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d>=tmp) continue;\n            dist[t_]=d;\n            que.push(make_pair(d,t_));\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p2,num_);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            //if(d_>=dist[p_][p2][num_]) continue;\n            if(d_>=tmp) continue;\n            //dist[p_][p2][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p_,num_);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d_>=tmp) continue;\n            //dist[p_][p_][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n    }\n    cout << 0 << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long LINT;\ntypedef vector<int> VI;\ntypedef vector<LINT> VL;\ntypedef vector<VL> VVL;\n\nconst LINT INF = 1LL << 35;\n\nint main() {\n\tint n, m;\n\t\n\twhile ( cin >> n >> m, n | m ) {\n\t\tVVL L( n, VL( n, INF ) ),\n\t\t\tS( n, VL( n, INF ) );\n\t\t\n\t\tfor ( int i = 0; i < m; ++i ) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t\n\t\t\tswitch ( s ) {\n\t\t\tcase 'L':\n\t\t\t\tL[x - 1][y - 1] = L[y - 1][x - 1] = min<LINT>( t, L[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tS[x - 1][y - 1] = S[y - 1][x - 1] = min<LINT>( t, S[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\t\n\t\tVI Z( r, 0 );\n\t\t\n\t\tfor ( int i = 0; i < r; ++i ) {\n\t\t\tcin >> Z[i];\n\t\t\t--Z[i];\n\t\t}\n\t\t// end of input\n\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tL[i][i] = S[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\t\tL[i][j] = min( L[i][j], L[i][k] + L[k][j] );\n\t\t\t\t\tS[i][j] = min( S[i][j], S[i][k] + S[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVVL d( r, VL( n, INF ) );\n\t\td[0][Z[0]] = 0;\n\t\tfor ( int i = 0; i + 1 < r; ++i ) {\n\t\t\tint from = Z[i], to = Z[i + 1];\n\t\t\td[i + 1][to] = min( d[i + 1][to], d[i][from] + S[from][to] );\n\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\td[i + 1][to] = min( d[i + 1][to], d[i][j] + L[from][j] + S[j][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][j] + L[from][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][from] + S[from][j] + L[j][to] );\n\t\t\t}\n\t\t}\n\n\t\tLINT ans = INF;\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tans = min( ans, d[r - 1][i] );\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n   \n    dp[1][z[1]]=0;\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           if(k!=j) dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        dp[0][v[0]]=0;/*\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }*/\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship;\n\tint job, cost;\n\tP(int now, int ship, int job, int cost) :now(now), ship(ship), job(job), cost(cost) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\n\nint flag[201][201][1000];\npriority_queue< P, vector<P>, greater<P> >que;\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tvector<pii> a[300][2];\n\t\tvi b;\n\t\tINT(n); INT(m);\n\t\tif ( !n )break;\n\t\tFOR(i, m)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\ta[x][sl == 'L'].emplace_back(y, t);\n\t\t\ta[y][sl == 'L'].emplace_back(x, t);\n\t\t}\n\t\tINT(r);\n\t\tFOR(i, r)\n\t\t{\n\t\t\tINT(z);\n\t\t\tb.push_back(z);\n\t\t}\n\t\tmemset(flag, -1, sizeof flag);\n\t\tflag[b[0]][b[0]][1] = 0;\n\t\tpriority_queue< P, vector<P>, greater<P> > empty;\n\t\tswap(que, empty);\n\t\tque.emplace(b[0], b[0], 1, 0);\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif ( now.job == b.size() )\n\t\t\t{\n\t\t\t\tcout << now.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( now.now == now.ship )\n\t\t\t{\n\t\t\t\tFOR(i, a[now.now][0].size())\n\t\t\t\t{\n\t\t\t\t\tP next = now;\n\t\t\t\t\tnext.now = next.ship = a[now.now][0][i].first;\n\t\t\t\t\tnext.cost += a[now.now][0][i].second;\n\t\t\t\t\tif ( next.now == b[next.job] )next.job++;\n\t\t\t\t\tint flg = flag[next.now][next.ship][next.job];\n\t\t\t\t\tif ( flg == -1 || flg > next.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t\tflag[next.now][next.ship][next.job] = next.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(i, a[now.now][1].size())\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tnext.now = a[now.now][1][i].first;\n\t\t\t\tnext.cost += a[now.now][1][i].second;\n\t\t\t\tif ( next.now == b[next.job] )next.job++;\n\t\t\t\tint flg = flag[next.now][next.ship][next.job];\n\t\t\t\tif ( flg == -1 || flg > next.cost )\n\t\t\t\t{\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tflag[next.now][next.ship][next.job] = next.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 210;\nconst int MAX_R = 1010;\nconst int INF = 1e9 + 7;\n\nclass E{\n  public:\n    int t, c, b;\n    E(){}\n    E(int _t, int _c, int _b){ t = _t; c = _c; b = _b; }\n};\n\nclass C{\n  public:\n    int t, n, s, c;\n    C();\n    C(int _t, int _n, int _s, int _c) { t = _t; n = _n; s = _s; c = _c; }\n    bool operator > (const C &_) const { return t != _.t ? t > _.t : c < _.c; }\n};\n\nint closed[MAX_N][MAX_N][MAX_R];\n\nint solve(vector< vector<E> > &G, vector<int> &v, int N, int R){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(0, 0, 0, 1));\n  REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_R) closed[i][j][k] = INF;\n  closed[v[0]][v[0]][0] = 0;\n  while(!open.empty()){\n    C tmp = open.top(); open.pop();\n    int n = tmp.n, t = tmp.t, s = tmp.s, c = tmp.c;\n    REP(i, G[n].size()){\n      int next = G[n][i].t, cost = G[n][i].c, f = G[n][i].b;\n      int nc = (v[c] == next ? c + 1 : c), nt = t + cost, ns = (f ? next : s);\n      if((f && s != n) || closed[next][ns][nc] <= nt) continue;\n      closed[next][ns][nc] = nt;\n      if(nc < v.size()) open.push(C(nt, next, ns, nc));\n      open.push(C(nt, next, ns, nc));\n    }\n  }\n  int ans = INF;\n  REP(i, N) ans = min(ans, closed[v[N - 1]][i][R]);\n  return ans;\n}\n\nint main() {\n  int N, M;\n  while(cin >>N >>M && N){\n    vector< vector<E> > G(N);\n    REP(i, M){\n      int f, t, c; char a;\n      cin >>f >>t >>c >>a;\n      --f; --t;\n      G[f].push_back(E(t, c, (a == 'L' ? 0 : 1)));\n      G[t].push_back(E(f, c, (a == 'L' ? 0 : 1)));\n    }\n    int R; cin >>R;\n    vector<int> v(R);\n    REP(i, R) { cin >>v[i]; --v[i]; }\n    cout <<solve(G, v, N, R) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define INF 100000000\t\n\nlong long land[200][200] , ship[200][200] ;\n\nint main(){\n\tlong long n,m;\n\twhile(cin >> n >> m , n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tlong long a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tlong long r; cin >> r;\n\t\tlong long R[1000];\n\t\trep(i,r){\n\t\t\tcin >> R[i] , R[i]--;\n\t\t}\n\t\tlong long dp[2][200][200];\n\t\trep(i,2)rep(j,200)rep(k,200)dp[i][j][k] = INF;\n\t\tdp[0][R[0]][R[0]] = 0;\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\tif(dp[bit%2][R[bit]][cur] != INF){\n\t\t\t\t\trep(next,n){\n\t\t\t\t\t\tlong long newCost = dp[bit%2][R[bit]][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\t\tdp[(bit+1)%2][R[bit+1]][next] = \n\t\t\t\t\t\tmin( dp[(bit+1)%2][R[bit+1]][next],newCost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,200)rep(j,200)dp[bit%2][i][j] = INF;\n\t\t}\n\t\tlong long ret = INF;\n\t\trep(i,200){\n\t\t\tret = min(dp[(r-1)%2][R[r-1]][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e15:1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\n\nstruct L: public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std{\n\tbool operator < (const P &a, const P &b){\n\t\treturn real(a) != real(b) ? real(a)<real(b) :imag(a)<imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\n\nP projection(L a, P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p-projection(l,p));\n}\n\n\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\n\nvector<L> tangentCC(C a, C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L> l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\t\n\tif(abs(a.r-b.r)<d-EPS){\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\t\n\t}else if(abs(a.r-b.r)<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvi L(n,vi(n,inf));\n\t\tvvi S(n,vi(n,inf));\n\t\trep(i,n)L[i][i]=S[i][i]=0;\n\t\trep(i,m){\n\t\t\tll a,b,c;char d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tif(d=='L')L[a][b]=L[b][a]=min(L[a][b],c);\n\t\t\tif(d=='S')S[a][b]=S[b][a]=min(S[a][b],c);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t}\n\t\tint R;cin>>R;\n\t\tvi r(R);\n\t\trep(i,R)cin>>r[i];\n\t\trep(i,R)r[i]--;\n\t\tvvi dp(R,vi(n,inf));\n\t\tdp[0][0]=0;\n\t\trep(i,R-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[r[i]][r[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+L[r[i]][j]+S[j][k]+L[k][r[i+1]]);\n\t\t\t}\n\t\t}\n//\t\trep(i,R){rep(j,n)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\tll out=inf;\n\t\trep(i,n)out=min(out,dp[R-1][i]);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#define MAXN 220\n#define ll long long\nconst ll inf=0x1f1f1f1f1f1f1f1f;\nusing namespace std;\nint n,m,r;\nll mp[3200][3200][2],dis[3200][3200][2],dp[2010][3200];\nint id[30100];\n\nvoid pre(){\n    memset(dis,inf,sizeof(dis));\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++) dis[i][j][0]=mp[i][j][0],dis[i][j][1]=mp[i][j][1];\n    for(int i=1;i<=n;i++) dis[i][i][0]=dis[i][i][1]=0;\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++){\n                if(i==j||j==k||k==i) continue;\n                dis[i][j][0]=min(dis[i][j][0],dis[i][k][0]+dis[k][j][0]);\n                dis[i][j][1]=min(dis[i][j][1],dis[i][k][1]+dis[k][j][1]);\n            }\n}\n\nvoid DP(){\n    memset(dp,inf,sizeof(dp));\n    dp[0][1]=0;\n    for(int i=1;i<=r;i++){\n        for(int k=1;k<=n;k++){\n            int x=id[i-1],y=id[i];\n            dp[i][k]=min(dp[i][k],dp[i-1][k]+dis[x][y][0]);\n            for(int j=1;j<=n;j++){\n                if(dp[i-1][j]==inf) continue;\n                if(x==y) dp[i][k]=dp[i-1][k];\n                else dp[i][k]=min(dp[i][k],dp[i-1][j]+dis[x][j][0]+dis[j][k][1]+dis[k][y][0]);\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(1){\n        memset(mp,inf,sizeof(mp));\n        scanf(\"%d%d\",&n,&m);\n        if(!n&&!m) break;\n        for(int i=1;i<=m;i++){\n            int x,y,z;char c;\n            scanf(\"%d%d%d%c%c\",&x,&y,&z,&c,&c);\n            if(c=='L') mp[x][y][0]=min(mp[x][y][0],(ll)z),mp[y][x][0]=min(mp[y][x][0],(ll)z);\n            else mp[x][y][1]=min(mp[x][y][1],(ll)z),mp[y][x][1]=min(mp[y][x][1],(ll)z);\n        }\n        pre();\n        scanf(\"%d\",&r);\n        memset(id,0,sizeof(id));\n        id[0]=1;\n        for(int i=1;i<=r;i++) scanf(\"%d\",&id[i]);\n        DP();\n        ll ans=inf;\n        for(int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    int dis1=L[z[i-1]][k];\n                    int dis2=W[k][j];\n                    int dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\n\n#define fs first\n#define sc second\n\nconst LL MOD = 1e9+7;\nconst double EPS = 1e-10;\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>bool chmin(T &a, const T &b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a,make_vector<T>(b,ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) {\n        is >> e;\n    }\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    edge &operator=(const int &x) {\n        to = x;\n        return *this;\n    }\n\n    operator int() const { return to; }\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\ntemplate<typename T>\nusing Edges = vector<edge<T>>;\ntemplate<typename T>\nusing WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate<typename T>\nusing MatrixGraph = vector<vector<T>>;\n\ntemplate<typename T>\nvoid warshall_floyd(MatrixGraph<T> &g) {\n    const auto INF = numeric_limits<T>::max();\n    for(int k = 0; k < g.size(); k++) {\n        for(int i = 0; i < g.size(); i++) {\n            for(int j = 0; j < g.size(); j++) {\n                if(g[i][k] == INF || g[k][j] == INF) continue;\n                g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n            }\n        }\n    }\n}\n\ntemplate<typename T>\nvoid dijkstra(\n        const WeightedGraph<T> &g,\n        vector<T> &dist,\n        int s)\n{\n    const auto INF = numeric_limits<T>::max();\n    dist.assign(g.size(), INF);\n\n    using Pi = pair< T, int >;\n    priority_queue<Pi, vector<Pi>, greater<Pi>> que;\n    dist[s] = 0;\n    que.emplace(dist[s], s);\n    while(!que.empty()) {\n        T cost;\n        int idx;\n        tie(cost, idx) = que.top();\n        que.pop();\n        if(dist[idx] < cost) continue;\n        for(auto &e : g[idx]) {\n            auto next_cost = cost + e.cost;\n            if(dist[e.to] <= next_cost) continue;\n            dist[e.to] = next_cost;\n            que.emplace(dist[e.to], e.to);\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 && m == 0) {\n            break;\n        }\n\n        vector<int> x(m), y(m), t(m);\n        vector<char> sl(m);\n\n        const int INF = numeric_limits<int>::max();\n\n        auto S = make_vector<int>(n, n, INF),\n             L = make_vector<int>(n, n, INF);\n        for (int i = 0; i < n; ++i) {\n            S[i][i] = L[i][i] = 0;\n        }\n\n        for (int i = 0; i < m; ++i) {\n            cin >> x[i] >> y[i] >> t[i] >> sl[i];\n            --x[i], --y[i];\n            if (sl[i] == 'S') {\n                chmin(S[x[i]][y[i]], t[i]);\n                chmin(S[y[i]][x[i]], t[i]);\n            } else {\n                chmin(L[x[i]][y[i]], t[i]);\n                chmin(L[y[i]][x[i]], t[i]);\n            }\n        }\n\n        int R; cin >> R;\n        vector<int> z(R);\n        for (int i = 0; i < R; ++i) {\n            cin >> z[i]; --z[i];\n        }\n\n        warshall_floyd(S);\n        warshall_floyd(L);\n\n        auto dist = make_vector<int>(R, n, INF);\n        dist[0][z[0]] = 0;\n        for (int i = 1; i < R; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (dist[i-1][j] == INF) continue;\n                if (L[z[i-1]][z[i]] != INF) {\n                    chmin(dist[i][j], dist[i-1][j] + L[z[i-1]][z[i]]);\n                }\n                for (int k = 0; k < n; ++k) {\n                    if (L[z[i-1]][j] != INF &&\n                        S[j][k] != INF &&\n                        L[k][z[i]] != INF) {\n                        chmin(dist[i][k], dist[i-1][j]\n                                + L[z[i-1]][j] + S[j][k] + L[k][z[i]]);\n                    }\n                }\n            }\n        }\n        int ans = *min_element(dist[R-1].begin(), dist[R-1].end());\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON_\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\n#define INF (1e8)\nstatic const double PI (3.14159265358979323846);\nstatic const double EPS (1e-10);\n\ntypedef long long int ll;\ntypedef unsigned long long int ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n#define FOR(i, b, e) for (typeof(b) i = (b); assert((i) <= (e)), i != (e); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((ll)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (1ULL << (n))\n#define BITOF(n, m) ((n) >> (m) & 1)\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, __VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n#endif/*}}}*/\n\n#define MAX_V 200\n\nint dl[MAX_V][MAX_V];\nint ds[MAX_V][MAX_V];\n\nint main(int argc, char const* argv[])\n{\n\tint N, M;\n\twhile (cin >> N >> M, N || M) {\n\t\tREP (i, MAX_V) {\n\t\t\tREP (j, MAX_V) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tdl[i][j] = 0; ds[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tdl[i][j] = INF;\n\t\t\t\t\tds[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP (i, M) {\n\t\t\tint x, y, t; char s;\n\t\t\tcin >> x >> y >> t >> s; --x; --y;\n\t\t\tif (s == 'L') {\n\t\t\t\tdl[x][y] = dl[y][x] = min(dl[x][y], t);\n\t\t\t} else {\n\t\t\t\tds[x][y] = ds[y][x] = min(ds[x][y], t);\n\t\t\t}\n\t\t}\n\t\tint R; cin >> R;\n\t\tvector<int> towns;\n\t\tREP (i, R) {\n\t\t\tint z; cin >> z; --z;\n\t\t\ttowns.PB(z);\n\t\t}\n\n\t\t// Warshall Floyd\n\t\tREP (k, N) {\n\t\t\tREP (i, N) {\n\t\t\t\tREP (j, N) {\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t#define MAX_R 1000\n\t\tint dp[MAX_R][MAX_V];\n\t\tREP (i, MAX_R) {\n\t\t\tREP (j, MAX_V) {\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tint rito = towns[0];\n\t\tint ship = towns[0];\n\t\tdp[0][ship] = 0;\n\t\tFOR (i, 1, R) {\n\t\t\tint rfrom = towns[i-1];\n\t\t\tint rto = towns[i];\n\t\t\tdprt(\"Rito \\\"Next town is #%d.\\\"\\n\", rto);\n\t\t\tREP (j, N) {\n\t\t\t\tdprt(\"\\tI will put my ship on town #%d.\\n\", j);\n\t\t\t\tint sto = j;\n\t\t\t\tREP (k, N) {\n\t\t\t\t\tint sfrom = k;\n\t\t\t\t\tdprt(\"\\t\\tWhen I was on #%d and ship was on #%d, cost was %d\\n\", rfrom, sfrom, dp[i-1][sfrom]);\n\t\t\t\t\tdp[i][sto] = min(dp[i][sto], dp[i-1][sfrom] + dl[rfrom][sfrom] + ds[sfrom][sto] + dl[sto][rto]);\n\t\t\t\t\tif (sfrom == sto) {\n\t\t\t\t\t\tdp[i][sto] = min(dp[i][sto], dp[i-1][sfrom] + dl[rfrom][rto]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdprt(\"\\tIt costs %d\\n\", dp[i][sto]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tREP (i, N) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tif(R == 1) {\n\t\t\tcout << 1 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[z[0]][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + land[A][B]);\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nconst int MAX_Z=1e3+5;\nconst int MAX_N=2*1e2+5;\nconst long long  INF=1e15+7;\nlong long G[2][MAX_N][MAX_N];\nint z[MAX_Z];\nlong long dp[MAX_Z][MAX_N];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m && n>0&&m>0){\n\trep(l,2)rep(i,MAX_N)rep(j,MAX_N)G[l][i][j]=(i!=j)?INF:0;\n\trep(i,MAX_Z)rep(j,MAX_N)dp[i][j]=INF;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,t;\n\t\tchar s;\n//\t\tscanf(\"%d%d%d%c\",&x,&y,&t,&s);\n\t\tcin>>x>>y>>t>>s;\n\t\tif(s=='L')G[0][x][y]=G[0][y][x]=min(G[0][x][y],(long long)t);\n\t\telse G[1][x][y]=G[1][y][x]=min(G[1][x][y],(long long)t);\n\t}\n\tint r;\n\tcin>>r;\n\tfor(int i=0;i<r;i++){\n\t\tcin>>z[i];\n\t}\n\trep(l,2)rep(k,n)rep(i,n)rep(j,n)G[l][i+1][j+1]=min(G[l][i+1][j+1],G[l][i+1][k+1]+G[l][k+1][j+1]);\n\tdp[0][z[0]]=0;\n\trep(i,r-1){\n\t\trep(j,n){\n\t\t\trep(k,n){\n\t\t\t\tif(k==j)dp[i+1][j+1]=min(dp[i+1][j+1],dp[i][k+1]+G[0][z[i]][z[i+1]]);\n\t\t\t\telse{\n\t\t\t\t\tdp[i+1][j+1]=min(dp[i+1][j+1],\n\t\t\t\t\t\t\tdp[i][k+1]+G[0][z[i]][k+1]+G[1][k+1][j+1]+G[0][j+1][z[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=INF;\n\trep(i,n)ans=min(ans,dp[r-1][i+1]);\n\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\n\nconst int MN = 220;\nconst int MR = 1100;\nconst ll INF = 1e9;\n\nll dp[MR][MN];\nll dist[MN][MN];\nll distS[MN][MN];\n\nbool solve() {\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            dist[i][j] = INF;\n            distS[i][j] = INF;\n            if (i == j) {\n                dist[i][j] = 0;\n                distS[i][j] = 0;\n            }\n        }\n    }\n    int n, m;\n    cin >> n >> m;\n    if (!n) return false;\n    for (int i = 0; i < m; i++) {\n        int x, y; ll t; char s;\n        cin >> x >> y >> t >> s; x--; y--;\n        if (s == 'L') {\n            dist[x][y] = dist[y][x] = min(dist[x][y], t);\n        } else {\n            distS[x][y] = distS[y][x] = min(distS[x][y], t);\n        }\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n                distS[i][j] = min(distS[i][j], distS[i][k]+distS[k][j]);\n            }\n        }\n    }\n\n    int r;\n    cin >> r;\n    int z0; cin >> z0; z0--;\n    fill_n(dp[0], n, INF);\n    dp[0][z0] = 0;\n    int b = z0;\n    r--;\n    for (int i = 0; i < r; i++) {\n        int p;\n        cin >> p; p--;\n        for (int j = 0; j < n; j++) {\n            dp[i+1][j] = dp[i][j] + dist[b][p];\n            for (int k = 0; k < n; k++) {\n                dp[i+1][j] = min(dp[i+1][j], dp[i][k]+dist[b][k]+distS[k][j]+dist[j][p]);\n            }\n        }\n        b = p;\n    }\n    ll ans = INF;\n    for (int i = 0; i < n; i++) {\n        ans = min(ans, dp[r][i]);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int MAXN = 222;\nconst int MAXR = 1111;\nconst ll INF = 1ll<<55;\nint N, M, R;\n// d1: land d2: sea\nll d1[MAXN][MAXN], d2[MAXN][MAXN];\nint z[MAXR];\n\nll dp[MAXR][MAXN];\n\nll dfs(int turn, int ship) {\n\tll& ret = dp[turn][ship];\n\tif (ret >= 0) return ret;\n\tif (turn == R-1) return ret = 0;\n\t// 徒歩\n\tret = d1[z[turn]][z[turn+1]] + dfs(turn+1, ship);\n\t// 船\n\tfor (int v = 0; v < N; v++) {\n\t\tll tmp = d1[z[turn]][ship] + d2[ship][v] + d1[v][z[turn+1]];\n\t\tif (tmp >= INF) continue;\n\t\ttmp += dfs(turn+1, v);\n\t\tret = min(ret, tmp);\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N >> M) {\n    \tif (N==0 && M==0) break;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tfor (int j = 0; j < N; j++) {\n    \t\t\td1[i][j] = d2[i][j] = INF;\n    \t\t}\n    \t\td1[i][i] = d2[i][i] = 0;\n    \t}\n    \tfor (int i = 0; i < M; i++) {\n    \t\tint x, y, t;\n    \t\tchar sl;\n    \t\tcin >> x >> y >> t >> sl;\n    \t\tx--; y--;\n    \t\tif (sl == 'L') {\n    \t\t\td1[x][y] = min<ll>(d1[x][y], t);\n    \t\t\td1[y][x] = d1[x][y];\n    \t\t} else {\n    \t\t\td2[x][y] = min<ll>(d2[x][y], t);\n    \t\t\td2[y][x] = d2[x][y];\n    \t\t}\n    \t}\n    \tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n    \t\td1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n    \t\td2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n    \t}\n    \tcin >> R;\n    \tfor (int i = 0; i < R; i++) {\n    \t\tcin >> z[i];\n    \t\tz[i]--;\n    \t}\n    \tmemset(dp, -1, sizeof(dp));\n    \tcout << dfs(0, z[0]) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 100\n#define INF 100000000\n\nint main(void){\n\n\tint N,M;\n\tint x,y,t;\n\tchar sl;\n\tint R,zi;\n\tint bzi;\n\tint ans;\n\tint ldp[NMAX+1][NMAX+1];\n\tint sdp[NMAX+1][NMAX+1];\n\tint dp[NMAX+1][RMAX+1];\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=t;\n\t\t\t\tldp[y][x]=t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=t;\n\t\t\t\tsdp[y][x]=t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tdp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\n\nconst int maxn = 1010;\nconst ll INF = 1e12;\nll odr[maxn],cost[maxn][maxn],sea_path[maxn][maxn],land_path[maxn][maxn],n,m,w;\n\nvoid init() {\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            cost[i][j] = sea_path[i][j] = land_path[i][j] = INF;\n    char s[5];\n    for(int i=0;i<m;i++) {\n        ll a,b,c;\n        scanf(\"%lld%lld%lld%s\",&a,&b,&c,s);\n        if(s[0] == 'S')\n            sea_path[a][b] = sea_path[b][a] = min(sea_path[a][b],c);\n        else\n            land_path[a][b] = land_path[b][a] = min(land_path[a][b],c);\n    }\n\n    scanf(\"%lld\",&w);\n    for(int i=1;i<=w;i++)\n        scanf(\"%lld\",&odr[i]);\n\n}\n\nvoid Floyd() {\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++) {\n                sea_path[i][j] = min(sea_path[i][j],sea_path[i][k]+sea_path[k][j]);\n                land_path[i][j] = min(land_path[i][j],land_path[i][k]+land_path[k][j]);\n            }\n}\n\nvoid get_ans() {\n    for(int i=1;i<=n;i++)\n        sea_path[i][i] = land_path[i][i] = 0;\n    cost[1][odr[1]] = 0;\n    for(int i=1;i<=w;i++) {\n        for(int j=1;j<=n;j++) {\n            cost[i][j] = min(cost[i][j],cost[i-1][j]+land_path[odr[i-1]][odr[i]]);\n            for(int k=1;k<=n;k++) {\n                cost[i][k] = min(cost[i][k],cost[i-1][j]+land_path[odr[i-1]][j]+sea_path[j][k]+land_path[k][odr[i]]);\n            }\n        }\n    }\n    ll Min = 1e12;\n    for(int i=1;i<=n;i++)\n        Min = min(cost[w][i],Min);\n    printf(\"%lld\\n\",Min);\n}\n\nint main() {\n    while(scanf(\"%lld%lld\",&n,&m) && n+m) {\n        init();\n        Floyd();\n        get_ans();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define pb push_back\n#define MAX 200\ntypedef pair<int,int> pi;\n#define INF (1145141919/3)\nint N,M,R;\nint G[MAX][MAX], H[MAX][MAX];\nint dp[MAX][2];\nint main()\n{\n  while(true)\n    {\n      cin>>N>>M;\n      if(N==0||M==0)return 0;\n      rep(i,N)\n\t{\n\t  rep(j,N)\n\t    {\n\t      G[i][j]=INF;\n\t      H[i][j]=INF;\n\t      if(i==j)\n\t\t{\n\t\t  G[i][j]=0;\n\t\t  H[i][j]=0;\n\t\t}\n\t    }\n\t}\n      rep(i,M)\n\t{\n\t  int x,y,t; char sl;\n\t  cin>>x>>y>>t>>sl;\n\t  x--; y--;\n\t  if(sl=='L')\n\t    {\n\t      G[x][y]=min(t,G[x][y]);\n\t      G[y][x]=min(t,G[y][x]);\n\t    }\n\t  else\n\t    {\n\t      H[x][y]=min(t,H[x][y]);\n\t      H[y][x]=min(t,H[y][x]);\n\t    }\n\t}\n      rep(k,N)\n\t{\n\t  rep(i,N)\n\t    {\n\t      rep(j,N)\n\t\t{\n\t\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\t  H[i][j]=min(H[i][j],H[i][k]+H[k][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,N)\n\t{\n\t  dp[i][0]=INF;\n\t  dp[i][1]=INF;\n\t}\n      \n      cin>>R;      \n      int now;\n      cin>>now;\n      now--;\n      dp[now][1]=0;\n      rep(i,R-1)\n\t{\n\t  int z;\n\t  cin>>z;\n\t  z--;\n\t  \n\t  rep(j,N)//j ni hune wo oiteiku\n\t    {\n\t      dp[j][i%2]=min(INF,dp[j][(i+1)%2]+G[now][z]);//hune wo tsukawanai\n\t      rep(k,N)//k ni hune wo toriniiku\n\t\t{\n\t\t  dp[j][i%2]=min(dp[j][i%2],dp[k][(i+1)%2]+G[now][k]+H[k][j]+G[j][z]);\n\t\t}\n\t    }\n\t  /*rep(j,N)\n\t    {\n\t      cout << dp[j][i%2] << \" \";\n\t    }\n\t    cout << endl;*/\n\t  now=z;\n\t}\n      int ans = INF;\n      rep(k,N)\n\t{\n\t  ans=min(ans,dp[k][R%2]);\n\t}\n      cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<24;\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\n\nstruct Edge {\n  int to, cost;\n};\n\nint N, M;\nint G[2][MAX_N][MAX_N];\nint R;\nint Z[MAX_R];\nvector<Edge> E[2][MAX_N];\n\nstruct State {\n  int p, sp, t, c;\n  bool operator < (const State &s) const {\n    if(c != s.c) return c > s.c;\n    if(t != s.t) return t < s.t;\n    if(p != s.p) return p > s.p;\n    if(sp != s.sp) return sp > s.sp;\n  }\n};\nint cost[MAX_N][MAX_N][MAX_R];\n\nint solve() {\n  State s;\n  s.p = s.sp = Z[0];\n  s.c = s.t = 0;\n\n  priority_queue<State> que;\n  que.push(s);\n\n  for(int i = 0; i < N; ++i)\n    for(int j = 0; j < N; ++j)\n      fill(cost[i][j], cost[i][j]+R, INF);\n\n  cost[s.p][s.sp][s.t] = s.c;\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(cost[s.p][s.sp][s.t] != s.c) continue;\n\n    //cost[s.p][s.sp][s.t] = s.c;\n    if(Z[s.t] == s.p) {\n      ++s.t;\n      cost[s.p][s.sp][s.t] = s.c;\n      if(s.t == R) {\n\treturn s.c;\n      }\n    }\n\n    State t;\n    for(int i = 0; i < E[0][s.p].size(); ++i) {\n      t.p = E[0][s.p][i].to;\n      t.sp = s.sp;\n      t.c = s.c + E[0][s.p][i].cost;\n      t.t = s.t;\n      if(cost[t.p][t.sp][t.t] > t.c) {\n\tcost[t.p][t.sp][t.t] = t.c;\n\tque.push(t);\n      }\n    }\n    if(s.sp == s.p) {\n      for(int i = 0; i < E[1][s.p].size(); ++i) {\n\tt.p = t.sp = E[1][s.p][i].to;\n\tt.c = s.c + E[1][s.p][i].cost;\n\tt.t = s.t;\n\tif(cost[t.p][t.sp][t.t] > t.c) {\n\t  cost[t.p][t.sp][t.t] = t.c;\n\t  que.push(t);\n\t}\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> N >> M && (N || M)) {\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < 2; ++j) {\n\tfill(G[j][i], G[j][i]+N, INF);\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      int a, b, t, ind;\n      char c;\n      cin >> a >> b >> t >> c;\n      --a; --b;\n      ind = (c == 'L') ? 0 : 1;\n      G[ind][a][b] = min(G[ind][a][b], t);\n      G[ind][b][a] = min(G[ind][b][a], t);\n    }\n\n    for(int i = 0; i < 2; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tE[i][j].clear();\n      }\n    }\n\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tfor(int j = 0; j < N; ++j) {\n\t  if(G[k][i][j] != INF)\n\t    E[k][i].push_back((Edge){j, G[k][i][j]});\n\t}\n      }\n    }\n\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      cin >> Z[i];\n      --Z[i];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nLL dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\twhile (cin >> n >> m&&n&&m) {\n\t\tfor (int i = 1; i <= 200; i++) {\n\t\t\tfor (int j = 1; j <= 200; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= 200; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tREP(i, 201)REP(j, 201)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tLL ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\n#define MAX (1000*1000)\n\nint memo[2][200];\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m), n+m){\n    int sea[n][n], land[n][n];\n    REP(i,n) REP(j,n) sea[i][j] = land[i][j] = (i==j ? 0 : MAX);\n    \n    REP(i,m){\n      int a,b,t;\n      char c;\n      scanf(\"%d%d%d %c\",&a,&b,&t,&c); a--; b--;\n      if(c == 'L') land[a][b] = land[b][a] = t;\n      else         sea[a][b]  = sea[b][a]  = t;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n)\n      if(land[i][k] + land[k][j] < land[i][j])\n\tland[i][j] = land[i][k] + land[k][j];\n    REP(k,n) REP(i,n) REP(j,n)\n      if(sea[i][k] + sea[k][j] < sea[i][j])\n\tsea[i][j] = sea[i][k] + sea[k][j];\n\n    /*\n    puts(\"land:\");\n    REP(i,n){REP(j,n)printf(\"%9d\",land[i][j]);puts(\"\");}\n    puts(\"sea:\");\n    REP(i,n){REP(j,n)printf(\"%9d\",sea[i][j]);puts(\"\");}\n    */\n\n    int r; scanf(\"%d\",&r);\n    int z[r];\n    REP(i,r){scanf(\"%d\",&z[i]); z[i]--;}\n    if(r == 1){\n      printf(\"0\\n\");\n      continue;\n    }\n\n    REP(i,n) memo[0][i] = min(MAX, sea[z[0]][i] + land[i][z[1]]);\n\n    for(int i=1; i<r-1; i++){\n      int *dist = memo[i%2];\n      int *src  = memo[(i+1)%2];\n      //printf(\"dist = %d, src = %d z[i]=%d, z[i+1]=%d\\n\",i%2,(i+1)%2,z[i],z[i+1]);\n      //REP(j,n) printf(\"%9d\",src[j]); \n      REP(j,n) dist[j] = min(MAX, src[j] + land[z[i]][z[i+1]]);\n      REP(j,n) REP(k,n) dist[j] = min(dist[j], src[k] + land[z[i]][k] + sea[k][j] + land[j][z[i+1]]);\n      //printf(\" => \");\n      //REP(j,n) printf(\"%9d\",dist[j]); puts(\"\");\n    }\n    int ans = INT_MAX;\n    REP(i,n) ans = min(ans, memo[(r-2)%2][i]);\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int dist1[200][200], dist2[200][200];\n    REP(i, N)REP(j, N){\n      dist1[i][j] = (i != j) ? INF : 0;\n      dist2[i][j] = (i != j) ? INF : 0;\n    }\n    REP(i, M){\n      int x, y, t;\n      char sl;\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      x--; y--;\n      if(sl == 'L') dist1[x][y] = dist1[y][x] = t;\n      else dist2[x][y] = dist2[y][x] = t;\n    }\n    REP(k, N)REP(i, N)REP(j, N){\n      dist1[i][j] = min(dist1[i][j], dist1[i][k] + dist1[k][j]);\n      dist2[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j]);\n    }\n    int R; cin>>R;\n    vector<int> z(R);\n    REP(i, R) {\n      cin>>z[i];\n      z[i]--;\n    }\n    int d[1001][200];\n    REP(i, 1001)fill(d[i], d[i] + N, INF);\n    d[0][z[0]] = 0;\n    REP(i, R - 1)REP(fship, N)REP(toship,N){\n      d[i+1][toship] = min(d[i][fship] + dist1[z[i]][fship] + dist2[fship][toship] + dist1[toship][z[i+1]], d[i+1][toship]);\n    }\n    int ans = INF;\n    REP(i, N) ans = min(ans, d[R-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int INF=1e15;\n\nvector<vector<long long int>> get_dis(vector<map<int,long long int>> &edge){\n  vector<vector<long long int>> d(edge.size(),vector<long long int>(edge.size(),INF));\n  for(int i=0;i<edge.size();i++){\n    for(int j=0;j<edge.size();j++){\n      if(edge[i].count(j)){\n        d[i][j]=edge[i][j];\n      }\n    }\n\n  }\n  for(int k=0;k<edge.size();k++){\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge.size();j++){\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n  }\n  return d;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    vector<map<int,long long int>> land_edge(n);\n    vector<map<int,long long int>> sea_edge(n);\n    for(int i=0;i<n;i++){\n      land_edge[i][i]=0;\n      sea_edge[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;\n      long long int t;\n      char sl;\n      cin>>x>>y>>t;\n      x--,y--;\n      cin>>sl;\n      if(sl=='L'){\n\tif(land_edge[x].count(y)){\n\t  land_edge[x][y]=min(land_edge[x][y],t);\n\t  land_edge[y][x]=min(land_edge[y][x],t);\n\t}\n\telse{\n\t  land_edge[x][y]=t;\n\t  land_edge[y][x]=t;\n\t}\n      }\n      else{\n\tif(sea_edge[x].count(y)){\n\t  sea_edge[x][y]=min(sea_edge[x][y],t);\n\t  sea_edge[y][x]=min(sea_edge[y][x],t);\n\t}\n\telse{\n\t  sea_edge[x][y]=t;\n\t  sea_edge[y][x]=t;\n\t}\n      }\n\n    }\n    auto land_d=get_dis(land_edge);\n    auto sea_d=get_dis(sea_edge);\n\n    \n    int r;\n    cin>>r;\n    vector<vector<long long int>> dp(r,vector<long long int>(n,INF));\n    int from,to;\n    cin>>from;\n    from--;\n    dp[0][from]=0;\n    for(int task=0;task<r-1;task++){\n      cin>>to;\n      to--;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  dp[task+1][j]=min(dp[task+1][j],dp[task][i]+land_d[from][i]+sea_d[i][j]+land_d[j][to]);\n\t}\n      }\n      from=to;\n    }\n    cout<<*min_element(dp[r-1].begin(),dp[r-1].end())<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint n, m;\nint rikuro[201][201], kairo[201][201];\nint result[201][201][201];\n\nint solve(vector<int> z, int r)\n{\n\tvector<vector<long long int> > result(1001, vector<long long int>(201, mod));\n\tresult[0][z[0]] = 0;\n\tfor(int i = 0; i < r - 1; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tif(z[i] == j) result[i + 1][k] = min(result[i + 1][k], result[i][j] + kairo[j][k] + rikuro[k][z[i + 1]]);\n\t\t\t\telse result[i + 1][k] = min(result[i + 1][k], result[i][j] + rikuro[z[i]][k] + kairo[j][k] + rikuro[k][z[i + 1]]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = mod;\n\tfor(int i = 0; i < n; i++){\n\t\tans = min(ans, result[r - 1][i]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\trikuro[i][j] = mod;\n\t\t\t\tkairo[i][j] = mod;\n\t\t\t}\n\t\t\trikuro[i][i] = 0;\n\t\t\tkairo[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(sl == 'S'){\n\t\t\t\tkairo[x][y] = t;\n\t\t\t\tkairo[y][x] = t;\n\t\t\t} else {\n\t\t\t\trikuro[x][y] = t;\n\t\t\t\trikuro[y][x] = t;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tkairo[i][j] = min(kairo[i][j], kairo[i][k] + kairo[k][j]);\n\t\t\t\t\trikuro[i][j] = min(rikuro[i][j], rikuro[i][k] + rikuro[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z;\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tint tmpz;\n\t\t\tcin >> tmpz;\n\t\t\ttmpz--;\n\t\t\tz.push_back(tmpz);\n\t\t}\n\t\tcout << solve(z, r) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nlong long dis1[210][210];\nlong long dis2[210][210];\nlong long dp[2][210];\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    rep (i, n) rep (j, n) dis1[i][j] = 1e9;\n    rep (i, n) rep (j, n) dis2[i][j] = 1e9;\n    rep (i, n) dis1[i][i] = 0;\n    rep (i, n) dis2[i][i] = 0;\n    rep (i, m) {\n      long long x, y, t;\n      string sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if (sl == \"L\") dis1[x][y] = dis1[y][x] = min(dis1[y][x], t);\n      else dis2[x][y] = dis2[y][x] = min(dis2[y][x], t);\n    }\n    rep (i, n) rep (j, n) rep (k, n) dis1[i][j] = min(dis1[i][j], dis1[i][k] + dis1[k][j]);\n    rep (i, n) rep (j, n) rep (k, n) dis2[i][j] = min(dis2[i][j], dis2[i][k] + dis2[k][j]);\n    int r, p;\n    cin >> r >> p;\n    --p;\n    rep (i, 2) rep (j, n) dp[i][j] = 1e18;\n    dp[p][p] = 0;\n    rep (_, r - 1) {\n      int q;\n      cin >> q;\n      --q;\n      rep (i, n) rep (j, n) dp[1][j] = min(dp[1][j], dp[0][i] + dis1[p][i] + dis2[i][j] + dis1[j][q]);\n      rep (i, n) dp[0][i] = dp[1][i];\n      rep (i, n) dp[1][i] = 1e18;\n      p = q;\n    }\n    long long res = 1e18;\n    rep (i, n) res = min(res, dp[0][i]);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        cout << __LINE__ << endl;\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define inf 1e8\nconst int maxn = 10000+5;\nint aim[maxn],land[maxn][maxn],sea[maxn][maxn],dp[maxn][maxn];\n\nint main()\n{\n    int N,M,R;\n    while(scanf(\"%d%d\",&N,&M)!=EOF)\n    {\n        if(N == 0 && M == 0)\n            break;\n        for(int i=1;i<=N;++i)\n        {\n            fill(land[i],land[i]+1+N,inf);\n            fill(sea[i],sea[i]+1+N,inf);\n            land[i][i]=0,sea[i][i]=0;\n        }\n        for(int i=1; i<=M; ++i)\n        {\n            int a,b,c;\n            char d;\n            scanf(\"%d%d%d %c\",&a,&b,&c,&d);\n//            cout<<\"d == \"<<d<<endl;\n            if(d=='S')\n                sea[a][b]=sea[b][a]=min(sea[a][b],c);\n            else\n                land[a][b]=land[b][a]=min(land[a][b],c);\n        }\n        for(int i=0;i<=M;++i)\n            fill(dp[i],dp[i]+1+N,inf);\n        scanf(\"%d\",&R);\n        for(int i=1;i<=R;++i)\n            scanf(\"%d\",&aim[i]);\n\n        for(int k=1; k<=N; ++k)\n            for(int i=1; i<=N; ++i)\n                for(int j=1; j<=N; ++j)\n                {\n                    sea[i][j]=min(sea[i][j], sea[i][k] + sea[k][j]);\n                    land[i][j]=min(land[i][j], land[i][k] + land[k][j]);\n                }\n        dp[1][aim[1]]=0;\n        for(int i=1;i<=R;++i)// 第几个aim\n            for(int j=1;j<=N;++j)// 船在第几个city\n        {\n            dp[i][j] = min(dp[i][j], dp[i - 1][j] + land[aim[i - 1]][aim[i]]);\n            /// 枚??一次船停的位置\n            for(int k=1;k<=N;++k)\n            {\n                dp[i][k] = min(dp[i][k], dp[i - 1][j] + land[aim[i - 1]][j] + sea[j][k] + land[k][aim[i]]);\n            }\n        }\n        cout<<*min_element(dp[R]+1,dp[R]+1+N)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const MAX_R = 1010;\nint const MAX_N = 210;\nint const INF = 1<<29;\n\nlong long dl[MAX_N][MAX_N];\nlong long ds[MAX_N][MAX_N];\nlong long dp[MAX_R][MAX_N];\nint z[MAX_R];\nint N, M, R;\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dl[i][j] = dl[j][i] = INF;\n        ds[i][j] = ds[j][i] = INF;\n      }\n      dl[i][i] = dl[i][i] = ds[i][i] = ds[i][i] = 0;\n    }\n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dl[x][y] = dl[y][x] = t;\n      }\n      else {\n        ds[x][y] = ds[y][x] = t;\n      }\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k]+dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j]);\n        }\n    \n    cin >> R;\n    for(int i=0; i<R; i++) { cin >> z[i]; z[i]--; }\n    \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    \n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++) {\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s]+dl[z[i-1]][s]+ds[s][t]+dl[t][z[i]]);\n        }\n        dp[i][s] = min(dp[i][s], dp[i-1][s]+dl[z[i-1]][z[i]]);\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int maxn = 1010;\nconst int INF = 1e8;\nint odr[maxn],cost[maxn][maxn],sea_path[maxn][maxn],land_path[maxn][maxn],n,m,w;\n\nvoid init() {\n    for(int i=0;i<=n;i++)\n        for(int j=0;j<=n;j++)\n            cost[i][j] = sea_path[i][j] = land_path[i][j] = INF;\n    char s[5];\n    for(int i=0;i<m;i++) {\n        int a,b,c;\n        scanf(\"%d%d%d%s\",&a,&b,&c,s);\n        if(s[0] == 'S')\n            sea_path[a][b] = sea_path[b][a] = min(sea_path[a][b],c);\n        else\n            land_path[a][b] = land_path[b][a] = min(land_path[a][b],c);\n    }\n\n    scanf(\"%d\",&w);\n    for(int i=1;i<=w;i++)\n        scanf(\"%d\",&odr[i]);\n\n}\n\nvoid Floyd() {\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++) {\n                sea_path[i][j] = min(sea_path[i][j],sea_path[i][k]+sea_path[k][j]);\n                land_path[i][j] = min(land_path[i][j],land_path[i][k]+land_path[k][j]);\n            }\n}\n\nvoid get_ans() {\n    for(int i=1;i<=n;i++)\n        sea_path[i][i] = land_path[i][i] = 0;\n    cost[1][odr[1]] = 0;\n    for(int i=1;i<=w;i++) {\n        for(int j=1;j<=n;j++) {\n            cost[i][j] = min(cost[i][j],cost[i-1][j]+land_path[odr[i-1]][odr[i]]);\n            for(int k=1;k<=n;k++) {\n                cost[i][k] = min(cost[i][k],cost[i-1][j]+land_path[odr[i-1]][j]+sea_path[j][k]+land_path[k][odr[i]]);\n            }\n        }\n    }\n    int Min = 0x7f7f7f7f;\n    for(int i=1;i<=n;i++)\n        Min = min(cost[w][i],Min);\n    printf(\"%d\\n\",Min);\n}\n\nint main() {\n    while(scanf(\"%d%d\",&n,&m) && n+m) {\n        init();\n        Floyd();\n        get_ans();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dist[1010][110][110];\nvector<pii> edgel[110],edges[110];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0)\tbreak;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tscanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n\t\t\tx--;\ty--;\n\t\t\t(sl == 'L' ? edgel[x] : edges[x]).push_back(mp(y, t));\n\t\t\t(sl == 'L' ? edgel[y] : edges[y]).push_back(mp(x, t));\n\t\t}\n\t\tint r;\tscanf(\"%d\", &r);\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tscanf(\"%d\", &z[i]);\tz[i]--;\n\t\t}\n\t\trep(i, r)\trep(j, n)\trep(k, n)\tdist[i][j][k] = mod;\n\t\tdist[0][z[0]][z[0]] = 0;\n\t\tpriority_queue<tuple<int, int, int, int>> pq;\n\t\tpq.push(mt(0, 0, z[0], z[0]));\n\t\tint ret = mod;\n\t\twhile (!pq.empty()) {\n\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\tint d, pos, fpos, phase;\n\t\t\ttie(d, phase, pos, fpos) = it;\td *= -1;\n\t\t\tif (d > dist[phase][pos][fpos])\tcontinue;\n\t\t\tif(DEBUG)\tcout << d << \" \" << phase << \" \" << pos << \" \" << fpos << endl;\n\t\t\tif (phase == r - 1) {\n\t\t\t\tret = min(ret, d);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, edgel[pos].size()) {\n\t\t\t\tint to = edgel[pos][i].fst, add = edgel[pos][i].scn;\n\t\t\t\tint np = phase + (to == z[phase + 1] ? 1 : 0);\n\t\t\t\tif (dist[np][to][fpos] > dist[phase][pos][fpos] + add) {\n\t\t\t\t\tdist[np][to][fpos] = dist[phase][pos][fpos] + add;\n\t\t\t\t\tpq.push(mt(-dist[np][to][fpos], np, to, fpos));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos == fpos) {\n\t\t\t\trep(i, edges[pos].size()) {\n\t\t\t\t\tint to = edges[pos][i].fst, add = edges[pos][i].scn;\n\t\t\t\t\tint np = phase + (to == z[phase + 1] ? 1 : 0);\n\t\t\t\t\tif (dist[np][to][to] > dist[phase][pos][fpos] + add) {\n\t\t\t\t\t\tdist[np][to][to] = dist[phase][pos][fpos] + add;\n\t\t\t\t\t\tpq.push(mt(-dist[np][to][to], np, to, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t\trep(i, n) {\n\t\t\tedgel[i].clear();\tedges[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<LL>> riku(n,vector<LL>(n,INF));\n    vector<vector<LL>> kai(n,vector<LL>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    LL x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    int r;\n    cin >> r;\n    vector<LL> z(r+1);\n    z[0]=0;\n    for(int i=1;i<=r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<LL>> dp(r+1,vector<LL>(n,INF));\n    dp[0][0]=0;\n    for(int i=1;i<=r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    LL ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nconst Int MAX = 222;\nconst Int INF = 1e15;\nInt dL[MAX][MAX];\nInt dS[MAX][MAX];\n\nsigned main(){\n  Int n,m;\n  while(cin>>n>>m,n){\n    for(Int i=0;i<MAX;i++)\n      for(Int j=0;j<MAX;j++)\n        dL[i][j]=dS[i][j]=(i==j?0:INF);\n\n    for(Int i=0;i<m;i++){\n      Int x,y,t;\n      char s;\n      cin>>x>>y>>t>>s;\n      x--;y--;\n      if(s=='L'){\n        chmin(dL[x][y],t);\n        chmin(dL[y][x],t);\n      }\n      if(s=='S'){\n        chmin(dS[x][y],t);\n        chmin(dS[y][x],t);\n      }\n    }\n\n    for(Int k=0;k<n;k++)\n      for(Int i=0;i<n;i++)\n        for(Int j=0;j<n;j++)\n          chmin(dL[i][j],dL[i][k]+dL[k][j]);\n\n    for(Int k=0;k<n;k++)\n      for(Int i=0;i<n;i++)\n        for(Int j=0;j<n;j++)\n          chmin(dS[i][j],dS[i][k]+dS[k][j]);\n\n    Int r;\n    cin>>r;\n    vector<Int> zs(r);\n    for(Int i=0;i<r;i++) cin>>zs[i],zs[i]--;\n\n    vector<Int> dp(n,INF);\n    dp[zs[0]]=0;\n\n    for(Int t=0;t+1<r;t++){\n      Int u=zs[t],v=zs[t+1];\n\n      vector<Int> nx(n,INF);\n      for(Int i=0;i<n;i++){\n        // only land\n        chmin(nx[i],dp[i]+dL[u][v]);\n        // with sea\n        for(Int j=0;j<n;j++)\n          chmin(nx[j],dp[i]+dL[u][i]+dS[i][j]+dL[j][v]);\n      }\n\n      swap(dp,nx);\n    }\n\n    cout<<*min_element(dp.begin(),dp.end())<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    int dis1=L[z[i-1]][k];\n                    int dis2=W[k][j];\n                    int dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 10000000000LL\nusing namespace std;\ntypedef long long ll;\n\nint N, M, R, X, Y, T, Z[1000];\nchar SL;\nll d[2][200][200];\nll dp[1000][200];\n\nint main(void) {\n  while(cin >> N >> M, N || M) {\n    REP(w, 0, 2) REP(i, 0, N) REP(j, 0, N) d[w][i][j] = (i == j ? 0 : INF);\n    REP(i, 0, M) {\n      cin >> X >> Y >> T >> SL;\n      d[SL == 'L'][X - 1][Y - 1] = T;\n      d[SL == 'L'][Y - 1][X - 1] = T;\n    }\n\n    REP(w, 0, 2) REP(k, 0, N) REP(i, 0, N) REP(j, 0, N) {\n      d[w][i][j] = min(d[w][i][j], d[w][i][k] + d[w][k][j]);\n    }\n\n    cin >> R;\n    REP(i, 0, R) cin >> Z[i], Z[i]--;\n\n    REP(i, 0, R) REP(j, 0, N) dp[i][j] = INF;\n    dp[0][Z[0]] = 0;\n\n    REP(i, 1, R) {\n      REP(j, 0, N) {\n        dp[i][j] = min(dp[i][j], dp[i - 1][j] + d[1][Z[i - 1]][Z[i]]);\n      }\n      REP(j, 0, N) REP(k, 0, N) {\n        dp[i][k] = min(dp[i][k], dp[i - 1][j] + d[1][Z[i - 1]][j] + d[0][j][k] + d[1][k][Z[i]]);\n      }\n    }\n\n    ll ans = INF;\n    REP(i, 0, N) ans = min(ans, dp[R - 1][i]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[201];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   scanf(\"%d %d\", &N, &M);\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n   \n    dp[1][1]=0;\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 500000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<int>> riku(n,vector<int>(n,INF));\n    vector<vector<int>> kai(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    int x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    int r;\n    cin >> r;\n    vector<int> z(r+1);\n    z[0]=0;\n    for(int i=1;i<=r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<int>> dp(r+1,vector<int>(n,INF));\n    dp[0][0]=0;\n    for(int i=1;i<=r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct E{\n  int d,t;\n  bool s;\n};\n\nstruct S{\n  int t,x,p,b;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    vector<E> e[201];\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      E a={y,t,sl=='S'};\n      e[x].push_back(a);\n      E b={x,t,sl=='S'};\n      e[y].push_back(b);\n    }\n    int r;\n    cin>>r;\n    int z[1000];\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n    }\n    priority_queue<S> que;\n    S is={0,0,z[0],z[0]};\n    que.push(is);\n    int p[201][201]={{}};\n    fill(p[0],p[201],false);\n    for(;;){\n      S c=que.top();\n      if(c.x==r-1)break;\n      que.pop();\n      if(p[c.p][c.b]>=c.x+1)continue;\n      p[c.p][c.b]=c.x+1;\n      for(int i=0;i<e[c.p].size();i++){\n\tE ce=e[c.p][i];\n\tif(!ce.s||c.b==c.p){\n\t  S n={c.t+ce.t,c.x+(ce.d==z[c.x+1]),ce.d,ce.s?ce.d:c.b};\n\t  if(p[n.p][n.b]<n.x+1){\n\t    que.push(n);\n\t  }\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e8;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint ldist[210][210];\nint sdist[210][210];\nint dp[210], dp2[210];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n)\tldist[i][j] = sdist[i][j] = (i == j ? 0 : inf);\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)\trep(i, n)\trep(j, n) {\n\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tcin\t>> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, n)\tdp[i] = ldist[i][z[0]];\n\t\trep(i, n)\tdp2[i] = inf;\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n)\tdp2[j] = dp[j] + ldist[z[i - 1]][z[i]];\n\t\t\trep(j, n)\trep(k, n) {\n\t\t\t\tdp2[j] = min(dp2[j], dp[k] + ldist[z[i - 1]][k] + sdist[k][j] + ldist[j][z[i]]);\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tdp[j] = dp2[j];\n\t\t\t\tdp2[j] = inf;\n\t\t\t}\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\ntypedef long long  ll;\n\nconst ll inf=1LL<<53;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint n,m;\n\nll lcost[210][210];\nll scost[210][210];\nll dp[1010][210];\n\nint r;\nint z[1010];\n\nint main(void){\n\t\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,210)rep(j,210) lcost[i][j]=scost[i][j]=((i==j)?0:inf);\n\n\t\trep(i,m){\n\t\t\tll x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;y--;\n\t\t\tif(sl=='S'){\n\t\t\t\tscost[x][y]=min(scost[x][y],t);\n\t\t\t\tscost[y][x]=min(scost[y][x],t);\n\t\t\t}else{\n\t\t\t\tlcost[x][y]=min(lcost[x][y],t);\n\t\t\t\tlcost[y][x]=min(lcost[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tcin >> r;\n\t\trep(i,r){cin >> z[i];z[i]--;}\n\n\t\trep(k,n)rep(i,n)rep(j,n) scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n) lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n\n\t\trep(i,1010)rep(j,210) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n)rep(k,n){\n\t\t\t dp[i+1][k]=min(dp[i+1][k],dp[i][k]+lcost[z[i]][z[i+1]]);\n\t\t\t dp[i+1][k]=min(dp[i+1][k],dp[i][j]+lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]]);\n\t\t}\n\t\tll ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl; \n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 26)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Short_S[MAX_N][MAX_N], Short_L[MAX_N][MAX_N]; // Shortest_Path\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nvoid Shortest(int start, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (mode == \"Sea\")\n\t\t{\n\t\t\tShort_S[start][i] = D[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShort_L[start][i] = D[i];\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tShortest(i, \"Land\");\n\t\t\tShortest(i, \"Sea\");\n\t\t}\n\n\t\tfor (int i = 0; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tint Land_Only = Short_L[Z[i - 1]][Z[i]];\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tdp[i][k] = min(dp[i - 1][k] + Land_Only, dp[i][k]);\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Short_L[Z[i - 1]][j];\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Short_S[j][k];\n\n\t\t\t\t\t\tint Land_2 = Short_L[k][Z[i]];\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\n\n\t\t// ------ Variable Value ------ //\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}\n\n// Time : O ( R * N ^ 2 + N ^ 3 )"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  // for(int i = 1; i < r; i++){\n  // \tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n  // \t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n  // \t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n  // \t\telse dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][root[i]] );\n  // \t  }\n  // \t}\n  // }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tdp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t  }\n\t  dp[i][j] = min( dp[i][j], dp[i-1][j] + l[root[i-1]][root[i]] );\n\t}\n  }\n\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nconst int N = 222;\nconst int R = 1111;\n\nclass E{\n\tpublic:\n\tint to;\n\tint cost;\n\tstring kind;\n\tE(int to,int cost,string kind):to(to),cost(cost),kind(kind){}\n};\n\nint n,m;\nvector<E> edge[N];\nvector<int> move;\n\n\nbool init(){\n\tcin>>n>>m;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i].clear();\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring s;\n\t\tcin>>a>>b>>c>>s;\n\t\tedge[a].push_back(E(b,c,s));\n\t\tedge[b].push_back(E(a,c,s));\n\t}\n\t\n\tint r;\n\tcin>>r;\n\t\n\tmove.clear();\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\treturn true;\n}\n\nclass Q{\n\tpublic:\n\tint val;\n\tint pos,num,fune;\n\tQ(int pos,int num,int fune,int val):\n\t\tpos(pos),num(num),fune(fune),val(val){}\n\tbool operator<(const Q& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\nint visit[N][R][N];\n\nint dijk(){\n\t\n\trep(i,n+1)rep(j,move.size())rep(k,n+1)visit[i][j][k]=0;\n\t\n\tpriority_queue<Q> que;\n\tque.push(Q(move[0],1,1,0));\n\t\n\twhile(!que.empty()){\n\t\tQ u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.pos][u.num][u.fune]==1)continue;\n\t\tvisit[u.pos][u.num][u.fune]=1;\n\t\t\n\t\t//printf(\"**%d %d %d %d\\n\",u.pos,u.num,u.fune,u.val);\n\t\t\n\t\tint next = u.num;\n\t\tif(u.pos==move[u.num]){\n\t\t\tnext++;\n\t\t}\n\t\t\n\t\tif(next==n){\n\t\t\treturn u.val;\n\t\t}\n\t\t\n\t\tif(u.pos==u.fune){\n\t\t\trep(i,edge[u.pos].size()){\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.kind!=\"S\")continue;\n\t\t\t\tque.push(Q(e.to, next, e.to, u.val+e.cost));\n\t\t\t}\n\t\t}\n\t\trep(i,edge[u.pos].size()){\n\t\t\tE e = edge[u.pos][i];\n\t\t\tif(e.kind!=\"L\")continue;\n\t\t\tque.push(Q(e.to, next, u.fune, u.val+e.cost));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint solve(){\n\treturn dijk();\n}\n\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nstatic int N, M, R;\n\n\n\nstatic int dist_l[201][201];\nstatic int dist_s[201][201];\n\nstatic int dest[1001];\n\n\n\nstatic void flood()\n{\n\tint i, j, k;\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n\nstatic int dp[1001][201];\n\nstatic void solve()\n{\n\tflood();\n\n\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tdp[0][1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (dp[i][j] > dp[i-1][j]+total_land_cost)\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tdist_l[i][i] = dist_s[i][i] = 0;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tif (dist_s[x][y] > t)\n\t\t\t\t\tdist_s[x][y] = dist_s[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_l[x][y] > t)\n\t\t\t\t\tdist_l[x][y] = dist_l[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n//mplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  //cout<<from<<\",\"<<to<<\":\"<<cost<<endl;\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,cap,(int)g[from].size()-1,cost});\n}\nCost INF=5e15;\n//dij\nint n,m,r; \nCost dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    //cout<<p;\n    if(v/n/n==r)return p.X;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n  return -1;\n}\nint fun(int p,int b,int r_){\n  return p+b*n+r_*n*n;\n}\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  while(cin>>n>>m,n){\n    vector<int> a(m),b(m),c(m);\n    vector<char> ch(m);\n    rep(i,m){\n      cin>>a[i]>>b[i]>>c[i]>>ch[i];\n      --a[i]; --b[i];\n    }\n    cin>>r;\n    vector<int> pos(r);\n    rep(i,r){\n      cin>>pos[i]; --pos[i];\n    }\n    //cout<<pos;\n    Graph g(n*n*(r+1));\n    rep(j,n)rep(k,r)\n      add_edge(g,fun(pos[k],j,k),fun(pos[k],j,k+1),1,0);\n    rep(i,m){\n      if(ch[i]=='L'){\n\trep(j,n)rep(k,r)\n\t  add_edge(g,fun(a[i],j,k),fun(b[i],j,k),1,c[i]);\n      }else{\n\trep(k,r)\n\t  add_edge(g,fun(a[i],a[i],k),fun(b[i],b[i],k),1,c[i]);\n      }\n    }\n    vector<Cost> dist(n*n*(r+1));\n    //cout<<\"g.size()\"<<g.size()<<endl;\n    cout<<dij(g,fun(pos[0],pos[0],0),dist)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int INF=500000000;\nconst int MAX_V = 210;\nconst int MAX_R = 1010;\nint n,m,r;\nint land[MAX_V][MAX_V];\nint sea[MAX_V][MAX_V];\nint citys[MAX_R];\nvoid calcLandMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n}\nvoid calcSeaMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n}\nint dp[MAX_R][MAX_V];\n// WzæªidxÌÔÚÌÆ±ëÅA{[gªboatÌm[hÉ éÆ«ÌÅ¬zBÔ\nint rec(int idx,int boat){\n    if(idx==r)\n        return 0;\n    if(dp[idx][boat]!=INF)\n        return dp[idx][boat];\n    int minTime=INF;\n    // ¤ÌÝðgÁÄB·éê\n    minTime=min(minTime,rec(idx+1,boat)+land[citys[idx-1]][citys[idx]]);\n    // CàgÁÄB·éê\n    // »ÝÌboatÌÊu©çBÅ«é`¬·×ÄÉÂ¢Ä·\n    for(int i = 0; i < n; i++){\n        minTime=min(minTime,rec(idx+1,i)+land[citys[idx-1]][boat]\n        + sea[boat][i] + land[i][citys[idx]]);\n    }\n    return dp[idx][boat]=minTime;\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)\n                if(i==j)\n                    land[i][j]=sea[i][j]=0;\n                else\n                    land[i][j]=sea[i][j]=INF;\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char kind;\n            cin>>from>>to>>cost>>kind;\n            from--;to--;\n            if(kind=='L'){\n                land[from][to]=min(land[from][to],cost);\n                land[to][from]=min(land[to][from],cost);\n            }\n            else{\n                sea[from][to]=min(sea[from][to],cost);\n                sea[to][from]=min(sea[to][from],cost);\n            }\n        }\n        cin>>r;\n        for(int i = 0; i < r; i++){\n            cin>>citys[i];\n            citys[i]--;\n        }\n        calcLandMinDist();\n        calcSeaMinDist();\n        // dpÅÅZ£ðßé\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < n; j++)dp[i][j]=INF;\n        //dp[0][citys[0]]=0;\n        //// Wzæ\n        //for(int i = 1; i < r; i++){\n        //    // ¡Ì{[gÌê\n        //    for(int j = 0; j < n; j++){\n        //        dp[i][j]=min(dp[i][j],dp[i-1][j]+land[citys[i-1]][citys[i]]);\n        //        // Ì{[gÌê\n        //        for(int k = 0; k < n; k++){\n        //            dp[i][k]=min(dp[i][k],dp[i-1][j]+land[citys[i-1]][j]\n        //            +sea[j][k]+land[k][citys[i]]);\n        //        }\n        //    }\n        //}\n        int res=rec(1,citys[0]);\n        //int res=INF;\n        //for(int i = 0; i < n; i++)\n        //    res=min(res,dp[r-1][i]);\n        cout<<res<<endl;\n    }\n    return 0;\n}\n/*\nÈº¦ÍÅ«P[XÅªöxÅoÍ³êéªAAOJÅÍà¿ëñTLE·éR[h\n_CNXg@ðgpµÄð¼Éð¢Ä¢é\n*/\n//struct edge{\n//\tint to;\n//\tint cost;\n//    char kind;\n//};\n//\n//class Situation{\n//public:\n//\tint cost;\n//\tint node;\n//    int boat;\n//    int obj;\n//\n//\tSituation(int cost_,int node_,int boat_,int obj_){\n//\t\tcost=cost_;\n//        node=node_;\n//        boat=boat_;\n//        obj=obj_;\n//\t}\n//\tSituation();\n//\n//\tbool operator<(const Situation &s)const{\n//\t\treturn s.cost < this->cost;\n//\t}\n//};\n//\n//int V;\n//int n,m;\n//\n//vector<int> objLands;\n//\n//const int MAX_V = 205;\n//const int MAX_M = 1001;\n//vector<edge> G[MAX_V];\n//int d[MAX_V][MAX_M][MAX_V];\n//const int INF = 1000000000;\n//\n//void dijkstra(int s){\n//\tpriority_queue<Situation> que;\n//    for(int i = 0; i < MAX_V; i++)\n//        for(int j = 0; j < MAX_M; j++)\n//            for(int k = 0; k < MAX_V; k++)\n//                d[i][j][k]=INF;\n//    d[s][0][s] = 0;\n//    que.push(Situation(0,s,s,0));\n//\twhile(!que.empty()){\n//\t\tSituation p = que.top();\n//\t\tque.pop();\n//        int node=p.node;\n//        int boat=p.boat;\n//        int cost=p.cost;\n//        int obj=p.obj;\n//        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n//\t\tif(d[node][obj][boat] < cost)\n//            continue;\n//\t\tfor(int i = 0; i < G[node].size(); i++){\n//\t\t\tedge &e = G[node][i];\n//            int toObj=obj;\n//            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n//            if(objLands[obj]==e.to)\n//                toObj++;\n//            // ¤ÌêÆCÌêÅêí¯\n//            if(e.kind=='L'){\n//                // ÅZ£\n//                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n//                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n//                    if(toObj!=objLands.size())\n//                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n//                }\n//            }\n//            else{\n//                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n//                if(boat==node){\n//                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n//                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n//                        if(toObj!=objLands.size())\n//                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n//                    }\n//                }\n//            }\n//\t\t}\n//\t}\n//}\n//\n//int main(){\n//\n//    while(cin>>n>>m&&!(n==0&&m==0)){\n//        objLands.clear();\n//        for(int i = 0; i < MAX_V; i++)\n//            G[i].clear();\n//        for(int i = 0; i < m; i++){\n//            int from,to,cost;\n//            char c;\n//            cin>>from>>to>>cost>>c;\n//            from--;to--;\n//            edge e;\n//            e.cost=cost;e.kind=c;e.to=to;\n//            G[from].push_back(e);\n//            e.to=from;\n//            G[to].push_back(e);\n//        }\n//        int t;\n//        cin>>t;\n//        int s;\n//        for(int i = 0; i < t; i++){\n//            if(i==0){\n//                cin>>s;\n//                s--;\n//            }\n//            else{\n//                int b;\n//                cin>>b;\n//                b--;\n//                objLands.push_back(b);\n//            }\n//        }\n//        dijkstra(s);\n//        int minCost=INF;\n//        for(int i = 0; i < n; i++){\n//            for(int j = 0; j < n; j++)\n//                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n//        }\n//        cout<<minCost<<endl;\n//    }\n//    return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\"\\n\");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nvoid solve(int N, int M) {\n    vector<vector<int>> gl(N, vector<int>(N, INF));\n    vector<vector<int>> gs(N, vector<int>(N, INF));\n    REP(i, M) {\n        int x, y, t;\n        char ls;\n        cin >> x >> y >> t >> ls;\n        x--, y--;\n        if (ls == 'L') {\n            gl[x][y] = gl[y][x] = t;\n        } else {\n            gs[x][y] = gs[y][x] = t;\n        }\n    }\n\n    REP(i, N) gl[i][i] = gs[i][i] = 0;\n    REP(i, N) REP(j, N) REP(k, N) chmin(gl[j][k], gl[j][i] + gl[i][k]);\n    REP(i, N) REP(j, N) REP(k, N) chmin(gs[j][k], gs[j][i] + gs[i][k]);\n\n    int R;\n    cin >> R;\n    vector<int> z(R);\n    REP(i, R) {\n        cin >> z[i];\n        z[i]--;\n    }\n\n    vector<vector<int>> dp(R, vector<int>(N, INF));\n    function<int(int,int)> rec = [&](int i, int s) {\n        auto& DP = dp[i][s];\n        if (DP != INF) return DP;\n        if (i == R - 1) return 0LL;\n        \n        int land = gl[z[i]][z[i + 1]] + rec(i + 1, s);\n        chmin(DP, land);\n        REP(v, N) {\n            int sea = gl[z[i]][s] + gs[s][v] + gl[v][z[i + 1]] + rec(i + 1, v);\n            chmin(DP, sea);\n        }\n        return DP;\n    };\n    cout << rec(0, z[0]) << endl;\n}\nsigned main() {\n    while (1) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        solve(N, M);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(n,n,INF);\n        auto Sd = vectors(n,n,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        auto v = vectors(r,INF);\n        rep(i,r) cin >> v[i],--v[i];\n        auto dp = vectors(n,n,INF);\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Sd[v[i]][k];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e15:1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\n\nstruct L: public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std{\n\tbool operator < (const P &a, const P &b){\n\t\treturn real(a) != real(b) ? real(a)<real(b) :imag(a)<imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\n\nP projection(L a, P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p-projection(l,p));\n}\n\n\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\n\nvector<L> tangentCC(C a, C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L> l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\t\n\tif(abs(a.r-b.r)<d-EPS){\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\t\n\t}else if(abs(a.r-b.r)<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvi L(n,vi(n,inf));\n\t\tvvi S(n,vi(n,inf));\n\t\trep(i,n)L[i][i]=S[i][i]=0;\n\t\trep(i,m){\n\t\t\tll a,b,c;char d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tif(d=='L')L[a][b]=L[b][a]=min(L[a][b],c);\n\t\t\tif(d=='S')S[a][b]=S[b][a]=min(S[a][b],c);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t}\n\t\tint R;cin>>R;\n\t\tvi r(R);\n\t\trep(i,R)cin>>r[i];\n\t\trep(i,R)r[i]--;\n\t\tvvi dp(R,vi(n,inf));\n\t\tdp[r[0]][0]=0;\n\t\trep(i,R-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[r[i]][r[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+L[r[i]][j]+S[j][k]+L[k][r[i+1]]);\n\t\t\t}\n\t\t}\n//\t\trep(i,R){rep(j,n)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\tll out=inf;\n\t\trep(i,n)out=min(out,dp[R-1][i]);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m,r;\nint dl[222][222];\nint ds[222][222];\nint dp[1111][222];\nint rs[1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,222)rep(j,222){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n      dist[i][j]=INF;\n    }\n    rep(i,m){\n      int x,y,t; string sl;\n      cin>>x>>y>>t>>sl; x--; y--;\n      if(sl==\"L\"){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    cin>>r;\n    rep(i,r){\n      cin>>rs[i];\n      rs[i]--;\n    }\n    dp[0][rs[0]]=0;\n    rep(i,r-1){\n      int crt=rs[i],nxt=rs[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        if(crt==j){\n          rep(k,n)minch(dp[i+1][k],dp[i][j]+dl[crt][j]+ds[j][k]+dl[k][nxt]);\n        }\n        rep(k,n)minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n      }\n    }\n    int res=INF;\n    rep(j,222)minch(res,dp[r][j]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<string>\n#define inf 0x3f3f3f3f\nusing namespace std;\nint land[205][205], sea[205][205], tar[1005], dp[1005][205];\nint main()\n{\n\tint n, m, i, j, k, r;\n\twhile (scanf(\"%d%d\",&n,&m),n+m)\n\t{\n\t\tmemset(land, inf, sizeof(land));\n\t\tmemset(sea, inf, sizeof(sea));\n\t\tmemset(dp, inf, sizeof(dp));\n\t\tfor (int i = 1; i <= m; i++)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tstring str;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tcin >> str;\n\t\t\tif (str == \"S\")\n\t\t\t\tsea[a][b] = sea[b][a] = c;\n\t\t\telse\n\t\t\t\tland[a][b] = land[b][a] = c;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++)\n\t\t\tscanf(\"%d\", tar + i);\n\t\tfor(int k=1;k<=n;k++)\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t{\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t//dp[i][j]代表到达了第i个要求达到的小镇tar[i]，船停在j镇。所花费的最小时间\n\t\tdp[1][tar[1]] = 0;\n\t\tfor(int i=1;i<=r;i++)\n\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + land[tar[i - 1]][tar[i]]);\n\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\tdp[i][k] = min((long long)dp[i][k], (long long)dp[i - 1][j] + land[tar[i - 1]][j] + sea[j][k] + land[k][tar[i]]);\n\t\t\t}\n\t\tint ans = inf;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tans = min(ans, dp[r][i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL INF = 1e14;\n\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, R;\n  while(cin >> N >> M, N){\n\tfill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n\tfill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n\n\tREP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n\tREP(i,M){\n\t  LL x, y, t; char c;\n\t  cin >> x >> y >> t >> c;\n\t  --x, --y;\n\t  if(c == 'L')\n\t\tdist_L[x][y] = dist_L[y][x] = min(dist_L[x][y], t);\n\t  else\n\t\tdist_S[x][y] = dist_S[y][x] = min(dist_S[x][y], t);\n\t}\n\t\n\tREP(k,N) REP(i,N) REP(j,N){\n\t  dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n\t  dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n\t}\n\n\tcin >> R;\n\tVI RS(R);\n\tREP(i,R){\n\t  cin >> RS[i];\n\t  --RS[i];\n\t}\n\n\t// dp[i][j] :<=> i番目まで訪問が終わって船の位置がjのときの最小コスト\n\tfill((LL*)dp, (LL*)dp+1001*201, INF);\n\tdp[0][RS[0]] = 0;\n\tREP(i,R-1){\n\t  REP(u,N){\n\t\tREP(v,N){\n\t\t  dp[i+1][v] = min(dp[i+1][v],\n\t\t\t\t\t\t   // Rs[i] -> uを陸で、u -> vを海で、v->RS[i+1]を陸で移動\n\t\t\t\t\t\t   dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n\t\t\t\t\t\t   );\n\t\t}\n\t\t//陸のみ\n\t\tdp[i+1][u] = min(dp[i+1][u], dp[i][u]+dist_L[RS[i]][RS[i+1]]);\n\t  }\n\t}\n\n\tLL ans = INF;\n\tREP(u,N) ans = min(ans, dp[R-1][u]);\n\tcout << ans << endl;\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nint main() {\n\tint n, m;\n\tstd::cin >> n >> m;\n\twhile (n != 0 && m != 0) {\n\t\tstd::vector<std::vector<int>> on_land(n, std::vector<int>(n, 1000000));\n\t\tstd::vector<std::vector<int>> on_ship(n, std::vector<int>(n, 1000000));\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\t\ton_land[i][i] = on_ship[i][i] = 0;\n\t\t\t}\n\t\t\tfor (auto i = 0; i < m; ++i) {\n\t\t\t\tstd::cin >> x >> y >> t >> s;\n\t\t\t\tswitch (s) {\n\t\t\t\tcase 'L': \n\t\t\t\t\tif (on_land[x - 1][y - 1] > t) {\n\t\t\t\t\t\ton_land[x - 1][y - 1] = on_land[y - 1][x - 1] = t;\n\t\t\t\t\t}\n\t\t\t\t\t\t  break;\n\t\t\t\tdefault:\n\t\t\t\t\tif (on_ship[x - 1][y - 1] > t) {\n\t\t\t\t\t\ton_ship[x - 1][y - 1] = on_ship[y - 1][x - 1] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto mid = 0; mid < n; ++mid) for (auto from = 0; from < n; ++from) for (auto to = from + 1; to < n; ++to) {\n\t\t\t\tif (on_land[from][mid] + on_land[mid][to] < on_land[from][to])\n\t\t\t\t\ton_land[from][to] = on_land[to][from] = on_land[from][mid] + on_land[mid][to];\n\t\t\t\tif (on_ship[from][mid] + on_ship[mid][to] < on_ship[from][to])\n\t\t\t\t\ton_ship[from][to] = on_ship[to][from] = on_ship[from][mid] + on_ship[mid][to];\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> vec_a(n, 1000000);\n\t\tstd::vector<int> vec_b(n, 1000000);\n\t\tint r, from, to;\n\t\tstd::cin >> r;\n\t\tauto *from_vec = &vec_a;\n\t\tauto *to_vec = &vec_b;\n\t\tstd::cin >> from;\n\t\tvec_a[from - 1] = 0;\n\t\tfor (auto i = 1; i < r; ++i) {\n\t\t\tstd::cin >> to;\n\t\t\tfor (auto ship_from = 0; ship_from < n; ++ship_from) {\n\t\t\t\tif ((*to_vec)[ship_from] > (*from_vec)[ship_from] + on_land[from - 1][to - 1])\n\t\t\t\t\t(*to_vec)[ship_from] = (*from_vec)[ship_from] + on_land[from - 1][to - 1];\n\t\t\t\tfor (auto ship_to = 0; ship_to < n; ++ship_to) {\n\t\t\t\t\tif ((*to_vec)[ship_to] > (*from_vec)[ship_from] + on_land[from - 1][ship_from] + on_ship[ship_from][ship_to] + on_land[ship_to][to - 1])\n\t\t\t\t\t\t(*to_vec)[ship_to] = (*from_vec)[ship_from] + on_land[from - 1][ship_from] + on_ship[ship_from][ship_to] + on_land[ship_to][to - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto temp = to_vec;\n\t\t\tto_vec = from_vec; from_vec = temp;\n\t\t\tfor (auto &vec : (*to_vec)) vec = 1000000;\n\t\t\tfrom = to;\n\t\t}\n\t\tint min = 1000000;\n\t\tfor (const auto v : (*from_vec)) {\n\t\t\tif (min > v) min = v;\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t\tstd::cin >> n >> m;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 500000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint N, M, R;\nint sea[200][200], land[200][200], z[1000];\nll dp[1000][200];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int x, y, t;\n    char _c;\n    while(cin >> N >> M && N){\n        rep(i, N) rep(j, N)\n          sea[i][j] = land[i][j] = i == j ? 0: INF;\n        rep(i, M){\n            cin >> x >> y >> t >> _c; --x; --y;\n            if(_c == 'L')\n              land[x][y] = land[y][x] = min(land[x][y], t);\n            else\n              sea[x][y] = sea[y][x] = min(sea[x][y], t);\n        }\n        cin >> R;\n        rep(i, R){\n            cin >> z[i];\n            --z[i];\n        }\n\n        rep(k, N) rep(i, N) rep(j, N){\n            sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n        }\n\n        rep(i, 1000) rep(j, 200) dp[i][j] = INF;\n        dp[0][z[0]] = 0;\n\n        REP(i, 1, R) rep(j, N) rep(k, N)\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] + (ll)land[z[i - 1]][k] + (ll)sea[k][j] + (ll)land[j][z[i]]);\n        \n        ll ans = INF;\n        rep(i, N) ans = min(ans, dp[R - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\nusing ll = long long;\nusing P = pair<ll, ll>;\nll GCD(ll a, ll b) { return b?GCD(b, a%b):a; }\nll LCM(ll a, ll b) { return a/GCD(a, b)*b; }\n\nconst ll INF = 1e18;\nint n, m;\n\nint main() {\n    while(1) {\n        cin >> n >> m;\n        if(n == 0 && m == 0) break;\n        ll Landdp[n][n];\n        ll Seadp[n][n];\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i == j) Landdp[i][j] = 0;\n                else Landdp[i][j] = INF;\n            }\n        }\n        for(int i = 0; i < n; ++i) {\n            for(int j = 0; j < n; ++j) {\n                if(i == j) Seadp[i][j] = 0;\n                else Seadp[i][j] = INF;\n            }\n        }\n        for(int i = 0; i < m; ++i) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'L') {\n                Landdp[x][y] = t;\n                Landdp[y][x] = t;\n            }else {\n                Seadp[x][y] = t;\n                Seadp[y][x] = t;\n            }\n        }\n        for(int k = 0; k < n; ++k) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    chmin(Landdp[i][j], Landdp[i][k]+Landdp[k][j]);\n                }\n            }\n        }\n        for(int k = 0; k < n; ++k) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    chmin(Seadp[i][j], Seadp[i][k]+Seadp[k][j]);\n                }\n            }\n        }\n\n        int R; cin >> R;\n        vector<int> zyun(R, 0);\n        for(int i = 0; i < R; ++i) {\n            cin >> zyun.at(i); zyun.at(i)--;\n        }\n\n        ll dp[R+1][n+1];\n        for(int i = 0; i <= R; ++i) {\n            for(int j = 0; j <= n; ++j) {\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][zyun.at(0)] = 0;\n\n        // 陸路のみか、陸路→海路→陸路\n        // dp[i][j] : 頂点jに舟がある状態でi番目の配達先に訪れる\n        // 舟の場所が異なる : i番目の配達先→k(舟があるところ)→j(目的地)→i+1番目の配達先\n        // 舟の場所が一緒 : i番目の配達先→i+1番目の配達先\n        for(int i = 0; i < R-1; ++i) {\n            for(int j = 0; j < n; ++j) {\n                for(int k = 0; k < n; ++k) {\n                    if(j != k) {\n                        chmin(dp[i+1][j], dp[i][k] + Landdp[zyun.at(i)][k] + Seadp[k][j] + Landdp[j][zyun.at(i+1)]);\n                    }else {\n                        chmin(dp[i+1][j], dp[i][j] + Landdp[zyun.at(i)][zyun.at(i+1)]);\n                    }\n                }\n            }\n        }\n\n        ll ans = INF;\n        for(int j = 0; j < n; ++j) {\n            chmin(ans, dp[R-1][j]);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, disl[210][210], diss[210][210], h, V[1010];\nlong long dp[1010][210], ans;\n\nvoid init() {\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tdisl[i][j] = diss[i][j] = ((i == j) ? 0 : 0x3f3f3f3f);\n\t\n\tmemset(dp, 0x3f3f3f3f, sizeof dp);\n\tans = 0x3f3f3f3f3f3f3f3f;\n}\n\nint main() {\n\tint u, v, w; char ch;\n\twhile(scanf(\"%d%d\", &n, &m) && (n || m)) {\n\t\tinit();\n\t\tfor(int i = 1; i <= m; ++i) {\n\t\t\tscanf(\"%d%d%d %c\", &u, &v, &w, &ch);\n\t\t\tif(ch == 'L') disl[u][v] = disl[v][u] = min(disl[u][v], w);\n\t\t\telse diss[u][v] = diss[v][u] = min(diss[u][v], w);\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; ++k)\n\t\t\tfor(int i = 1; i <= n; ++i)\n\t\t\t\tfor(int j = i + 1; j <= n; ++j) {\n\t\t\t\t\tdisl[i][j] = disl[j][i] = min(disl[i][j], disl[i][k] + disl[k][j]);\n\t\t\t\t\tdiss[i][j] = diss[j][i] = min(diss[i][j], diss[i][k] + diss[k][j]);\n\t\t\t\t}\n\t\t\n\t\tscanf(\"%d\", &h);\n\t\tfor(int i = 1; i <= h; ++i) scanf(\"%d\", &V[i]);\n\t\tdp[0][1] = 0;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tfor(int j = 1; j <= n; ++j)\n\t\t\t\tfor(int k = 1; k <= n; ++k)\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + disl[V[i - 1]][j] + diss[j][k] + disl[k][V[i]]);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tif(dp[h][i] < ans) ans = dp[h][i];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINT_MAX)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<LL>> warshall_floyd(std::vector<std::vector<LL>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INT_MAX and matrix.at(m).at(e) != INT_MAX) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        vector<vector<LL>> matrix1(N, vector<LL>(N, INT_MAX)), matrix2(N, vector<LL>(N, INT_MAX));\n        FOR(i, 0, M) {\n            int X, Y, T;\n            char S;\n            cin >> X >> Y >> T >> S;\n            X--; Y--;\n            if (S == 'L') {\n                matrix1[X][Y] = T;\n                matrix1[Y][X] = T;\n            }\n            else if (S == 'S') {\n                matrix2[X][Y] = T;\n                matrix2[Y][X] = T;\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> route(R);\n        FOR(i, 0, R) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        matrix1 = warshall_floyd(matrix1);\n        matrix2 = warshall_floyd(matrix2);\n\n        vector<vector<LL>> dp(R, vector<LL>(N, INF));\n        dp[0][route[0]] = 0;\n\n        FOR(i, 0, R - 1) {\n            int now = route[i];\n            int next = route[i + 1];\n\n            FOR(j, 0, N) {\n                if (dp[i][j] == INF) {\n                    continue;\n                }\n\n                FOR(k, 0, N) {\n                    // 船がjにあるとき、町nowから町jに陸路、町jから町kに海路、町kから町nextに陸路でいく\n                    LL dist = dp[i][j] + matrix1[now][j] + matrix2[j][k] + matrix1[k][next];\n                    dp[i + 1][k] = min(dp[i + 1][k], dist);\n                }\n            }\n        }\n\n        LL ans = INF;\n        FOR(i, 0, N) {\n            ans = min(ans, dp[R - 1][i]);\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector<int> z;\nint Land[210][210];\nint Sea[210][210];\nlong long dp[1001][210];\n\n#define INF (1<<29)\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    z.clear();\n    for(int i=0; i<N; i++) {\n      Land[i][i] = Sea[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n\tLand[i][j] = Land[j][i] = INF;\n\tSea[i][j] = Sea[j][i] = INF;\n      }\n    }\n    \n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n\tLand[x][y] = Land[y][x] = min(Land[x][y], t); // taju hen ari\n      }\n      else {\n\tSea[x][y] = Sea[y][x] = min(Sea[x][y], t); // taju hen ari\n      }\n    }\n    \n    int R; cin >> R;\n    z.resize(R);\n    for(int i=0; i<R; i++) {\n      cin >> z[i]; z[i] --;\n    }\n    \n    // warshall floyd\n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t  Land[i][j] = min(Land[i][j], Land[i][k]+Land[k][j]);\n\t  Sea[i][j] = min(Sea[i][j], Sea[i][k]+Sea[k][j]);\n\t}\n    \n    fill(dp[0], dp[0]+1001*210, INF);\n    dp[0][z[0]] = 0;\n    for(int i=1; i<R; i++) {\n      for(int u=0; u<N; u++) {\n\tfor(int v=0; v<N; v++) {\n\t  dp[i][v] = min(dp[i][v], dp[i-1][u] + Land[z[i-1]][u] + Sea[u][v] + Land[v][z[i]]);\n\t  dp[i][v] = min(dp[i][v], dp[i-1][v] + Land[z[i-1]][z[i]]);\n\t}\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[3][200][200];\nint dp[1001][200];\n \nint main(){\n \n \n\twhile(scanf(\"%d %d\",&n,&m),n){\n\n\t\tfill(&d[0][0][0],&d[3][0][0],INF);\n\t\t\n\t\tfor(int i=0;i<n;i++) d[0][i][i]=d[1][i][i]=0;\n/*\t\t\n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n*/\t\n\n\n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t\t\n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(&dp[0][0],&dp[1001][0],INF);\n\t   dp[0][now]=0;\n\t\t\n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t\t\n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[z[0]][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PI;\nint distL[200][200];\nint distS[200][200];\nint dp[2][200];\nint z[1000];\nint main() {\n\tint N, M;\n\twhile (cin >> N >> M, N) {\n\t\tfill((int*)distL, (int*)(distL + 200), 1 << 25);\n\t\tfill((int*)distS, (int*)(distS + 200), 1 << 25);\n\t\tfor (int i = 0; i < N; i++) distL[i][i] = distS[i][i] = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar sl[2];\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif (sl[0] == 'L') {\n\t\t\t\tdistL[x][y] = distL[y][x] = min(distL[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdistS[x][y] = distS[y][x] = min(distS[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdistL[i][j] = min(distL[i][j], distL[i][k] + distL[k][j]);\n\t\t\t\t\tdistS[i][j] = min(distS[i][j], distS[i][k] + distS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfill((int*)dp, (int*)(dp + 2), 1 << 25);\n\t\tdp[0][z[0]] = 0;\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k) dp[i % 2][k] = min(dp[i % 2][k], dp[(i - 1) % 2][j] + distL[z[i - 1]][z[i]]);\n\t\t\t\t\telse dp[i % 2][k] = min(dp[i % 2][k], dp[(i - 1) % 2][j] + distL[z[i - 1]][j] + distS[j][k] + distL[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) dp[(i - 1) % 2][j] = 1 << 25;\n\t\t}\n\t\tint ans = 1 << 25;\n\t\tfor (int i = 0; i < N; i++) ans = min(ans, dp[(R - 1) % 2][i]);\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef int Weight;\n\nconst int MAX_N = 201;\nconst int MAX_R = 1002;\nconst int INF = 10000;\nint N, M, R;\nint dS[MAX_N][MAX_N];  // 海路\nint dL[MAX_N][MAX_N];  // 陸路\nint dp[MAX_R][MAX_N];  //\nint z[MAX_R];\n\nvoid warshall_floyd(int d[MAX_N][MAX_N])\n{\n    for (int k = 0; k < N; k++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main()\n{\n    while (cin >> N >> M, N || M) {\n        // Initial\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++) {\n                dp[i][j] = INF;\n                if (i == j)\n                    dL[i][j] = dS[i][j] = 0;\n                else\n                    dL[i][j] = dS[i][j] = INF;\n            }\n\n        // Input\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char c;\n\n            cin >> x >> y >> t >> c;\n            x--, y--;\n\n            if (c == 'S' && dS[x][y] > t) // 海路\n                dS[x][y] = dS[y][x] = t;\n            else if (c == 'L' && dL[x][y] > t) // 陸路\n                dL[x][y] = dL[y][x] = t;\n        }\n\n        cin >> R;\n        for (int i = 0; i < R; i++) {\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // Warshall-Floyd\n        warshall_floyd(dL);\n        warshall_floyd(dS);\n\n        dp[0][z[0]] = 0;\n        for (int i = 0; i < R - 1; i++) {\n            for (int j = 0; j < N; j++) {\n                int from = z[i], to = z[i + 1];\n\n                if (dp[i][j] == INF)\n                    continue;\n\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dL[from][to]);\n                for (int k = 0; k < N; k++)\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dL[from][j] +\n                                       dS[j][k] + dL[k][to]);\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < N; i++)\n            ans = min(ans, dp[R - 1][i]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\nusing namespace std;\n\nconst int INF = 1<<24;\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nint N, M;\nint G[2][MAX_N][MAX_N];\nint R;\nint Z[MAX_R];\n\nstruct State {\n  int p, sp, t, c;\n  bool operator < (const State &s) const {\n    if(c != s.c) return c > s.c;\n    if(t != s.t) return t > s.t;\n    if(p != s.p) return p > s.p;\n    if(sp != s.sp) return sp > s.sp;\n  }\n};\nint cost[MAX_N][MAX_N][MAX_R];\n\nint solve() {\n  State s;\n  s.p = s.sp = Z[0];\n  s.c = s.t = 0;\n\n  priority_queue<State> que;\n  que.push(s);\n\n  for(int i = 0; i < N; ++i)\n    for(int j = 0; j < N; ++j)\n      fill(cost[i][j], cost[i][j]+R, INF);\n\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(cost[s.p][s.sp][s.t] != INF) continue;\n\n    cost[s.p][s.sp][s.t] = s.c;\n    if(Z[s.t] == s.p) {\n      ++s.t;\n      cost[s.p][s.sp][s.t] = s.c;\n      if(s.t == R) {\n\treturn s.c;\n      }\n    }\n\n    for(int i = 0; i < N; ++i) {\n      if(G[0][s.p][i] != INF) {\n\tState t = s;\n\tt.c += G[0][s.p][i];\n\tt.p = i;\n\tif(cost[t.p][t.sp][t.t] == INF) {\n\t  que.push(t);\n\t}\n      }\n      if(s.sp == s.p && G[1][s.p][i] != INF) {\n\tState t = s;\n\tt.c += G[1][s.p][i];\n\tt.p = t.sp = i;\n\tif(cost[t.p][t.sp][t.t] == INF) {\n\t  que.push(t);\n\t}\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> N >> M && (N || M)) {\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < 2; ++j) {\n\tfill(G[j][i], G[j][i]+N, INF);\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      int a, b, t, ind;\n      char c;\n      cin >> a >> b >> t >> c;\n      --a; --b;\n      ind = (c == 'L') ? 0 : 1;\n      G[ind][a][b] = min(G[ind][a][b], t);\n      G[ind][b][a] = min(G[ind][b][a], t);\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      cin >> Z[i];\n      --Z[i];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];//水路\nint l[210][210];//?路\nint d[1010][210];//dp\nint b[1010];//目?路?\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) \n{\n\tfor (int k = 1; k <= n; ++k) \n\t{\n\t\tfor (int i = 1; i <= n; ++i) \n\t\t{\n\t\t\tfor (int j = 1; j <= n; ++j) \n\t\t\t{\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() \n{\n\tint n, m, r;\n\tint u, v, c;\n\tchar tp[2];\n\n\twhile (scanf(\"%d%d\", &n, &m) != EOF && n) \n\t{\n\t\tmemset(s, INF, sizeof(s));\n\t\tmemset(l, INF, sizeof(l));\n\t\tmemset(d, INF, sizeof(d));\n\n\t\twhile (m--) \n\t\t{\n\t\t\tscanf(\"%d%d%d%s\", &u, &v, &c, tp);\n\t\t\tif (tp[0] == 'L') \n\t\t\t{\n\t\t\t\tl[u][v] = min(l[u][v], c);\n\t\t\t\tl[v][u] = min(l[v][u], c);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\ts[u][v] = min(s[u][v], c);\n\t\t\t\ts[v][u] = min(s[v][u], c);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= n; ++i) \n\t\t{\n\t\t\tl[i][i] = 0;\n\t\t\ts[i][i] = 0;\n\t\t}\n\n\t\tscanf(\"%d\", &r);\n\n\t\tfor (int i = 1; i <= r; ++i) \n\t\t{\n\t\t\tscanf(\"%d\", &b[i]);\n\t\t}\n\n\t\tFloyd(n);\n\n\t\tfor (int i = 1; i <= n; ++i) \n\t\t{\n\t\t\td[1][i] = min(d[1][i], s[b[1]][i] + l[i][b[1]]);\n\t\t}\n\n\t\tfor (int i = 1; i <= r; ++i) \n\t\t{\n\t\t\tfor (int j = 1; j <= n; ++j) \n\t\t\t{\n\t\t\t\t//if (l[j][b[i]] >= INF) continue;\n\t\t\t\tfor (int k = 1; k <= n; ++k) \n\t\t\t\t{\n\t\t\t\t\t//if (d[i - 1][k] >= INF) continue;\n\t\t\t\t\tif (j == k) \n\t\t\t\t\t{\n\t\t\t\t\t\tif (l[b[i - 1]][b[i]] < INF) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][b[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\t//三个INF可能上溢\n\t\t\t\t\t\tif (l[b[i - 1]][k] < INF && s[k][j] < INF && l[j][b[i]] < INF) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][k] + s[k][j] + l[j][b[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int j = 1; j <= n; ++j) \n\t\t{\n\t\t\tans = min(ans, d[r][j]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int MAXN = 202;\nconst int MAXR = 1002;\nconst int INF = 1<<28;\n\nint N, M;\nint land[MAXN][MAXN], sea[MAXN][MAXN];\nint R;\nint Z[MAXR];\n\nint dp[MAXR][MAXN];\n\nvoid warshallFloyd(int n, int g[MAXN][MAXN]) {\n  for(int k = 0; k < n; ++k) {\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    for(int i = 0; i < MAXN; ++i) {\n      for(int j = 0; j < MAXN; ++j) {\n        land[i][j] = sea[i][j] = (i == j) ? 0 : INF;\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      if(sl == 'L') {\n        land[x][y] = land[y][x] = min(land[x][y], t);\n      } else {\n        sea[x][y] = sea[y][x] = min(sea[x][y], t);\n      }\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      cin >> Z[i];\n      --Z[i];\n    }\n\n    warshallFloyd(N, land);\n    warshallFloyd(N, sea);\n\n    fill(dp[0], dp[MAXR], INF);\n    dp[0][Z[0]] = 0;\n    for(int i = 0; i+1 < R; ++i) {\n      for(int j = 0; j < N; ++j) {\n        if(dp[i][j] == INF) continue;\n        int a = Z[i];\n        int b = Z[i+1];\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j] + land[a][b]);\n        for(int k = 0; k < N; ++k) {\n          dp[i+1][k] = min(dp[i+1][k],\n                           dp[i][j] + land[a][j] + sea[j][k] + land[k][b]);\n        }\n      }\n    }\n\n    int res = INF;\n    for(int j = 0; j < N; ++j) {\n      res = min(res, dp[R-1][j]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e15:1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\n\nstruct L: public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std{\n\tbool operator < (const P &a, const P &b){\n\t\treturn real(a) != real(b) ? real(a)<real(b) :imag(a)<imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\n\nP projection(L a, P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p-projection(l,p));\n}\n\n\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\n\nvector<L> tangentCC(C a, C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L> l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\t\n\tif(abs(a.r-b.r)<d-EPS){\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\t\n\t}else if(abs(a.r-b.r)<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvi L(n,vi(n,inf));\n\t\tvvi S(n,vi(n,inf));\n\t\trep(i,n)L[i][i]=S[i][i]=0;\n\t\trep(i,m){\n\t\t\tll a,b,c;char d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tif(d=='L')L[a][b]=L[b][a]=min(L[a][b],c);\n\t\t\tif(d=='S')S[a][b]=S[b][a]=min(S[a][b],c);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t}\n\t\tint R;cin>>R;\n\t\tvi r(R);\n\t\trep(i,R)cin>>r[i];\n\t\trep(i,R)r[i]--;\n\t\tvvi dp(R,vi(n,inf));\n\t\tdp[0][r[0]]=0;\n\t\trep(i,R-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[r[i]][r[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+L[r[i]][j]+S[j][k]+L[k][r[i+1]]);\n\t\t\t}\n\t\t}\n//\t\trep(i,R){rep(j,n)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\tll out=inf;\n\t\trep(i,n)out=min(out,dp[R-1][i]);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\n\nconst ll INF = 1LL << 60;\n\nint solve() {\n    int N, M; cin >> N >> M;\n    if (N == 0) return 0;\n    \n    vector<vector<ll>> dist_l(N, vector<ll>(N, INF));\n    vector<vector<ll>> dist_s(N, vector<ll>(N, INF));\n    REP(i, N) dist_l[i][i] = 0;\n    REP(i, N) dist_s[i][i] = 0;\n    REP(_, M) {\n        int x, y; ll t; char sl; cin >> x >> y >> t >> sl;\n        if (sl == 'S') {\n            dist_s[x - 1][y - 1] = min(dist_s[x - 1][y - 1], t);\n            dist_s[y - 1][x - 1] = min(dist_s[y - 1][x - 1], t);\n        } else {\n            dist_l[x - 1][y - 1] = min(dist_l[x - 1][y - 1], t);\n            dist_l[y - 1][x - 1] = min(dist_l[y - 1][x - 1], t);\n        }\n    }\n\n\n    REP(i, N) REP(j, N) REP(k, N)\n        dist_s[j][k] = min(dist_s[j][k], dist_s[j][i] + dist_s[i][k]);\n    REP(i, N) REP(j, N) REP(k, N)\n        dist_l[j][k] = min(dist_l[j][k], dist_l[j][i] + dist_l[i][k]);\n\n\n    int R; cin >> R;\n    vector<int> dests;\n    REP(_, R) {\n        int r; cin >> r;\n        dests.push_back(r - 1);\n    }\n\n\n    vector<vector<ll>> dp(R, vector<ll>(N, INF));\n    dp[0][dests[0]] = 0;\n\n    REP2(i, 1, R) REP(j, N) REP(k, N) {\n        dp[i][j] = min(dp[i][j], dp[i-1][k] + dist_l[dests[i-1]][k] + dist_s[k][j] + dist_l[j][dests[i]]);\n        if (j == k)\n            dp[i][j] = min(dp[i][j], dp[i-1][k] + dist_l[dests[i-1]][dests[i]]);\n\n    }\n\n    ll ans = INF;\n    REP(i, N) ans = min(ans, dp[R-1][i]);\n    cout << ans << endl;\n\n    return 1;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#define RG register\n#define IL inline\n#define pi acos(-1.0)\n\n#define inf 1e8\nusing namespace std;\n\nint n,m,R;\nint land[300][300],water[300][300],dp[1005][300];\nint a[1005];\n\nvoid pre(){\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++){\n          land[i][j]=land[j][i]=inf;\n          water[i][j]=water[j][i]=inf;\n        }\n    for(int i=1;i<=n;i++)\n         land[i][i]=0,water[i][i]=0;\n}\n\nvoid floyd(){\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++){\n                if(k==i||k==j||i==j) continue;\n                water[i][j]=min(water[i][j],water[i][k]+water[k][j]);\n                land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            }\n}\n\nint main(){\n    while(1){\n     scanf(\"%d%d\",&n,&m);\n     if(n==0&&m==0) break;\n     pre();\n     for(int i=1;i<=m;i++){\n         int l,r; string str;\n         int w;\n         scanf(\"%d%d%d\",&l,&r,&w);\n         cin>>str;\n         if(str==\"L\") land[l][r]=land[r][l]=min(land[r][l],w);\n         else water[l][r]=water[r][l]=min(water[r][l],w);\n    }\n    floyd();\n    scanf(\"%d\",&R);\n    for(int i=1;i<=R;i++)\n        for(int j=1;j<=n;j++)\n          dp[i][j]=inf;\n    for(int i=1;i<=R;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n      dp[1][i]=water[a[1]][i]+land[i][a[1]];//第一次出发可以将船停到任意处再坐船回到当前目标点\n   \n   for(int i=1;i<=R;++i){\n   \t\tfor(int j=1;j<=n;++j){\n   \t\t\tif(dp[i][j]!=inf){\n   \t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+land[a[i]][a[i+1]]);\n   \t\t\t\tfor(int k=1;k<=n;++k){\n   \t\t\t\t\tdp[i+1][k]=min(dp[i+1][k],\n\t\t\t\t\tdp[i][j]+land[a[i]][j]+water[j][k]+land[a[i+1]][k]\n\t\t\t\t\t   );\n\t\t\t\t   }\n\t\t\t   }\n\t\t   }\n   }\n     int minn=inf;\n     for(int i=1;i<=n;i++)\n        minn=min(minn,dp[R][i]);\n     printf(\"%d\\n\",minn);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=(k);i++)\n#define INF ((int)1<<28)\n#define mk(i,j) make_pair(i,j)\n\n#define N 200\n#define M 10000\n#define R 1000\nint sdst[N][N];\nint ldst[N][N];\nint dp[R+1][N];\n\nusing namespace std;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n)break;\n\t\trep(i,n)rep(j,n){\n\t\t\tsdst[i][j] = ldst[i][j] = i==j?0:INF;\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin >> x >> y >> t;\n\t\t\tx--;y--;\n\t\t\tcin >> s;\n\t\t\tif(s[0]=='L'){\n\t\t\t\tldst[x][y] = ldst[y][x] = min(ldst[x][y],t);\n\t\t\t}else{\n\t\t\t\tsdst[x][y] = sdst[y][x] = min(sdst[x][y],t);\n\t\t\t}\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tldst[i][j] = min(ldst[i][j],ldst[i][k] + ldst[k][j]);\n\t\t\tsdst[i][j] = min(sdst[i][j],sdst[i][k] + sdst[k][j]);\n\t\t}\n\t\tint r,zp;\n\t\tcin >> r;\n\t\trep(i,r)rep(j,n)dp[i][j]=INF;\n\t\tcin >> zp;\n\t\tzp--;\n\t\tdp[0][zp]=0;\n\t\trep(i,r-1){\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t\trep(j,n)rep(k,n){\n\t\t\t\tdp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t dp[i][j] + (j==k?ldst[zp][z]:ldst[zp][j] + sdst[j][k] + ldst[k][z]));\n\t\t\t}\n\t\t\tzp = z;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i,n)ans = min(dp[r-1][i],ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#define MAX1 201\n#define MAX2 1001\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  bool LS; //0->L , 1->S\n  P(int to=0,int cost=0,bool LS=false):to(to),cost(cost),LS(LS){}\n};\n\nstruct Pox\n{\n  int p,cost,bp,fp;//bp -> position of boat\n  Pox(int p=0,int bp=0,int fp=0):p(p),bp(bp),fp(fp){}\n};\n\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint mincost[MAX1][MAX1][MAX2];\n\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      VVP G(N);\n      rep(i,MAX1)rep(j,MAX1)rep(k,MAX2)mincost[i][j][k] = inf;\n\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char sl;\n\t  cin >> x >> y >> t >> sl;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,(sl == 'S')));\n\t  G[y].push_back(P(x,t,(sl == 'S')));\n\t}\n      cin >> R;\n      vector<int> z(R);\n      rep(i,R)\n\t{\n\t  cin >> z[i];\n\t  z[i]--; \n\t}\n\n      deque<Pox> deq;\n      deq.push_back(Pox(z[0],z[0],0));\n      mincost[z[0]][z[0]][0] = 0;\n      int ans = (1<<29);\n\n      while(!deq.empty())\n\t{\n\t  Pox pox = deq.front(); deq.pop_front();\n\t  //cout << pox.p << \" \"  << pox.bp << \" \" << pox.fp << endl; \n\n\t  bool inc = false;\n\t  if(pox.p == z[pox.fp])\n\t    pox.fp++,inc = true;\n\t    \n\n\t  if(pox.fp >= R)\n\t    {\n\t      //cout << \"&&&\" << endl;\n\t      ans = min(ans,mincost[pox.p][pox.bp][pox.fp-1]);\n\t      continue;\n\t    }\n\t   \n\n\t  for(int i=0;i<G[pox.p].size();i++)\n\t    {\n\t      P next = G[pox.p][i];\n\n\t      if(next.LS)\n\t\t{// S\n\t\t  //cout << \"in S, \" << endl;\n\t\t  //cout << \" mincost[\"<<pox.p<<\"][\"<<pox.bp<<\"][\"<<pox.fp<<\"] = \" <<  mincost[pox.p][pox.bp][pox.fp-inc] << endl;\n\t\t  //cout << mincost[next.to][next.to][pox.fp] << \" >? \" << mincost[pox.p][pox.bp][pox.fp-inc]+ next.cost << endl;\n\t\t  //cout << endl;\n\t\t  if(pox.p != pox.bp)continue; // cannot move to the next\n\n\t\t  if(mincost[next.to][next.to][pox.fp] > mincost[pox.p][pox.bp][pox.fp-inc]+ next.cost)\n\t\t    {\n\t\t      mincost[next.to][next.to][pox.fp] = mincost[pox.p][pox.bp][pox.fp-inc]+ next.cost;\n\t\t      deq.push_back(Pox(next.to,next.to,pox.fp));\n\t\t    }\n\t\t}\n\t      else \n\t\t{// L\n\t\t  //cout << \"in L, \" << endl;\n\t\t  //cout << \" mincost[\"<<pox.p<<\"][\"<<pox.bp<<\"][\"<<pox.fp<<\"] = \" <<  mincost[pox.p][pox.bp][pox.fp-inc] << endl;\n\t\t  //cout << mincost[next.to][pox.bp][pox.fp] << \" >?\" <<  mincost[pox.p][pox.bp][pox.fp-inc] + next.cost << endl;\n\t\t  //cout << endl;\n\t\t  if(mincost[next.to][pox.bp][pox.fp] > mincost[pox.p][pox.bp][pox.fp-inc] + next.cost)\n\t\t    {\n\t\t      mincost[next.to][pox.bp][pox.fp] = mincost[pox.p][pox.bp][pox.fp-inc] + next.cost;\n\t\t      deq.push_back(Pox(next.to,pox.bp,pox.fp));\n\t\t    }\n\t\t}\n\t    }\n\t}   \n\n      cout << ans << endl;\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 500000000\nint le[200][200];\nint se[200][200];\nint dp[2][200];\nint q[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tle[i][j]=INF;\n\t\t\tse[i][j]=INF;\n\t\t}\n\t\tle[i][i]=0;\n\t\tse[i][i]=0;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar t;\n\t\tscanf(\"%d %d %d %c\",&a,&b,&c,&t);\n\t\ta--;b--;\n\t\tif(t=='L'){\n\t\t\tle[a][b]=min(le[a][b],c);\n\t\t\tle[b][a]=min(le[b][a],c);\n\t\t}\n\t\telse{\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tle[i][j]=min(le[i][j],le[i][k]+le[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint nq;\n\tscanf(\"%d\",&nq);\n\tfor(i=0;i<nq;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t\tq[i]--;\n\t}\n\tfor(i=0;i<n;i++){dp[0][i]=se[q[0]][i]+le[i][q[0]];}\n\tfor(i=1;i<nq;i++){\n\t\tfor(j=0;j<n;j++)dp[i%2][j]=INF;\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][k]=min(dp[i%2][k],dp[(i+1)%2][j]+le[q[i-1]][j]+se[j][k]+le[k][q[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+le[q[i-1]][q[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(nq+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<unsigned char,unsigned char,short> tpl;\n    //static int dist[200][200][1001];\n    //fill_n((int*)dist,200*200*1001,inf);\n    map<tpl,int> dist;\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    //dist[z[0]][z[0]][1]=true;\n    dist[make_tuple(z[0],z[0],1)]=0;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        //if(d>dist[p1][p2][num]) continue;\n        if(d>dist[t.second]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p2,num_);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            //if(d_>=dist[p_][p2][num_]) continue;\n            if(d_>=tmp) continue;\n            //dist[p_][p2][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p2,num_)));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p_,num_);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d_>=tmp) continue;\n            //dist[p_][p_][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n    }\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        if(pos==route[i+1]) continue; // really?\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    int res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define inf 100000000\n\nusing namespace std;\n\nint N, M;\nint SG[205][205], LG[205][205];\nint R;\nint z[1005];\n\nint dp[1005][205];\nint Sdist[205][205], Ldist[205][205];\n\nvoid WarshallFloyd(int G[205][205], int dist[205][205])\n{\n\tfor(int k = 1; k <= N; k++){\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> N >> M;\n\t\tif(N == 0 && M == 0) break;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tSG[i][j] = LG[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tint x, y, t; char sl;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif(sl == 'S') SG[x][y] = SG[y][x] = min(SG[x][y], t);\n\t\t\tif(sl == 'L') LG[x][y] = LG[y][x] = min(LG[x][y], t);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tSdist[i][j] = SG[i][j];\n\t\t\t\tLdist[i][j] = LG[i][j];\n\t\t\t\tif(i == j) Sdist[i][j] = Ldist[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tWarshallFloyd(SG, Sdist);\n\t\tWarshallFloyd(LG, Ldist);\n\t\t\n\t\t\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) cin >> z[i];\n\t\t\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tfor(int j = 1; j <= N; j++) dp[i][j] = inf;\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\t\n\t\tint d;\n\t\tfor(int i = 1; i < R; i++){\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\t\tif(j == k){\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + Ldist[z[i-1]][z[i]]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\td = Ldist[z[i-1]][j] + Sdist[j][k] + Ldist[k][z[i]];\n\t\t\t\t\tif(d > inf) d = inf;\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + d);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = inf;\n\t\tfor(int i = 1; i <= N; i++) ans = min(ans, dp[R-1][i]);\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                //if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                //    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                //}\n                assert(z[i]<N);\n                if (dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <queue>\n#include <string.h>\n#include <stdio.h>\n\ntypedef long long ll;\nusing namespace std;\n\ntypedef vector<vector<pair<int, int> > > graph_t;\ntypedef vector<tuple<int, int, int>> edges_t;\nconst int INF = 1e9+1;\n\nint solve(int N, const edges_t &roads, const edges_t &searoute, const vector<int> &path)\n{\n\tvector<vector<int>> gr;\n\tgr.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tgr[i].resize(N, INF);\n\t\tgr[i][i] = 0;\n\t}\n\tfor (auto i = roads.begin(); i != roads.end(); ++i) {\n\t\tint s = get<0>(*i);\n\t\tint e = get<1>(*i);\n\t\tint d = get<2>(*i);\n\t\tgr[s][e] = min(gr[s][e], d);\n\t\tgr[e][s] = min(gr[e][s], d);\n\t}\n\tfor (int k = 0; k < N; k++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tgr[i][j] = min(gr[i][j], gr[i][k] + gr[k][j]);\n\t\t}\n\t}\n\t\n\tvector<vector<int>> gs;\n\tgs.resize(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tgs[i].resize(N, INF);\n\t\tgs[i][i] = 0;\n\t}\n\tfor (auto i = searoute.begin(); i != searoute.end(); ++i) {\n\t\tint s = get<0>(*i);\n\t\tint e = get<1>(*i);\n\t\tint d = get<2>(*i);\n\t\tgs[s][e] = min(gs[s][e], d);\n\t\tgs[e][s] = min(gs[e][s], d);\n\t}\n\tfor (int k = 0; k < N; k++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t\tgs[i][j] = min(gs[i][j], gs[i][k] + gs[k][j]);\n\t\t}\n\t}\n\n\tvector<vector<int>> dp; // [??????????????????][????????´???]\n\tdp.resize(path.size());\n\tfor (auto i = dp.begin(); i != dp.end(); ++i)\n\t\ti->resize(N+1, INF);\n\tfor (int j = 0; j < N; j++) {\n\t\tdp[0][j] = min(INF, gs[path[0]][j] + gr[j][path[0]]);\n\t\t//cout << \"dp[\" << 0 << \"][\" << j << \"] = \" << dp[0][j] << endl;\n\t}\n\tfor (int i = 1; i < (int)path.size(); i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tint d = INF;\n\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\tif (l == j) {\n\t\t\t\t\td = min((ll)d, (ll)dp[i-1][l] + gr[path[i-1]][path[i]]);\n\t\t\t\t} else {\n\t\t\t\t\tll e = (ll)dp[i-1][l] + gs[l][j];\n\t\t\t\t\te += gr[path[i-1]][l];\n\t\t\t\t\te += gr[j][path[i]];\n\t\t\t\t\td = min((ll)d, e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i][j] = d;\n\t\t\t//cout << \"dp[\" << i << \"][\" << j << \"] = \" << d << endl;\n\t\t}\n\t}\n\tint ans = INF;\n\tfor (int i = 0; i < N; i++) {\n\t\tans = min(ans, dp[path.size()-1][i]);\n\t}\n\treturn ans;\n}\n\nvoid solve_stdio()\n{\n\twhile (true) {\n\t\tint N, M;\n\t\tif (!(cin >> N >> M))\n\t\t\tbreak;\n\t\tif (N == 0 || M == 0)\n\t\t\tbreak;\n\t\tedges_t roads;\n\t\tedges_t searoute;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint s, e, t;\n\t\t\tstring sl;\n\t\t\tcin >> s >> e >> t >> sl;\n\t\t\ts--; e--;\n\t\t\tif (sl == \"L\")\n\t\t\t\troads.emplace_back(s, e, t);\n\t\t\telse\n\t\t\t\tsearoute.emplace_back(s, e, t);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> path;\n\t\tpath.resize(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t\tpath[i] = z;\n\t\t}\n\t\tint ans = solve(N, roads, searoute, path);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve_stdio();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n#include<array>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconstexpr int INF = (1 << 30);\nconstexpr int siz = 200;\n\n\n//名前の通り。　N個の独立した要素を併合するときに使用\nclass UnionFind {\npublic:\n\tvector<int>rank, parent;\n\t//初期化\n\tUnionFind(int size) {\n\t\trank.resize(size, 0);\n\t\tparent.resize(size, 0);\n\t\tREP(i, size)parent[i] = i;\n\t}\n\t//木の根を求める\n\tint find(int x) {\n\t\tif (parent[x] == x)return x;\n\t\telse return parent[x] = find(parent[x]);\n\t}\n\t//xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])\n\t\t\tparent[x] = y;\n\t\telse {\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t//xとyが同じ集合に属するか否か\n\tbool same(int x, int y) {\n\t\treturn (find(x) == find(y));\n\t}\n\t//parentの内容を出力\n\tvoid debug() {\n\t\tfor (auto num : parent) {\n\t\t\tcout << num << \" \";\n\t\t}\n\t\tcout << \"more:\" << endl;\n\t\tREP(i, parent.size()) {\n\t\t\tcout << find(i) << \" \";\n\n\t\t}\n\t\tcout << endl << \"more:\" << endl;\n\t\tfor (auto num : parent) {\n\t\t\tcout << num << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nstruct Stage{\n\tStage(){\n\t\tcin >> N >> M;\n\t\tif (!N)return;\n\n\t\tint x, y, t;\n\t\tstring sl;\n\t\tfor (auto& v : load)fill(v.begin(), v.end(), INF);\n\t\tfor (auto& v : sea)fill(v.begin(), v.end(), INF);\n\t\tfill(havePort.begin(), havePort.end(), false);\n\t\tREP(i, N)load[i][i] = sea[i][i] = 0;\n\t\tREP(i, M)\n\t\t{\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif (sl == \"L\") {\n\t\t\t\tload[x][y] = load[y][x] = t;\n\t\t\t\tuf.unite(x, y);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t\thavePort[x] = havePort[y] = true;\n\t\t\t}\n\t\t}\n\n\t\tint R;cin >> R;\n\t\tREP(i, R)\n\t\t{\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tz.push_back(t);\n\t\t}\n\t}\n\t\n\tbool is_end(){\n\t\treturn N == 0;\n\t}\n\t\n\tvoid action()\n\t{\n\t\twarshall_floyd(load);\n\t\twarshall_floyd(sea);\n\t\t\n\t\tvector<vector<int>> dp(z.size(), vector<int>(N, INF));\n\t\tdp[0][z[0]] = 0;\n\t\tFOR(i, 1, z.size()){\n\n\t\t\tREP(j, N) REP(k, N) {\n\t\t\t\tint fromL = z[i - 1];\n\t\t\t\tint fromS = k;\n\t\t\t\tint toS = j;\n\t\t\t\tint toL = z[i];\n\n\t\t\t\tint befTime = dp[i - 1][k];\n\t\t\t\tint timeLS = load[fromL][fromS];\n\t\t\t\tint timeSS = sea[fromS][toS];\n\t\t\t\tint timeSL = load[toS][toL];\n\n\t\t\t\tif (max(max(befTime, timeLS), max(timeSS, timeSL)) == INF)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i][j] = min(dp[i][j], befTime + timeLS + timeSS + timeSL);\n\t\t\t}\n\t\t}\n\t\tcout << *min_element(dp.back().begin(), dp.back().end()) << endl;\n\n\t\t/*\n\t\tint bef = 0;\n\t\tint now = 0;\n\t\tfill(time.begin(), time.end(), INF);\n\t\ttime[z[0]] = 0;\n\n\t\twarshall_floyd(load);\n\t\twarshall_floyd(sea);\n\n\t\twhile (now < z.size()) {\n\t\t\tvector<int> route;\n\t\t\twhile (now < z.size() && uf.same(bef, now)) {\n\t\t\t\troute.push_back(now);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tbef = now;\n\t\t\tupdate(route);\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tREP(i, N)if (uf.same(i, z.back()))\n\t\t{\n\t\t\tres = min(res, time[i] - load[i][z.back()]);\n\t\t}\n\t\tcout << res << endl;\n\t\t*/\n\t}\n\t\nprivate:\n\tint N, M;\n\tUnionFind uf = UnionFind(siz);//陸のセット作成\n\tarray<int, siz> time;\n\tarray<bool, siz> havePort;\n\tarray<array<int, siz>, siz> load, sea;\t\n\tvector<int> z;\n\t\n\tvoid warshall_floyd(array<array<int, siz>,siz>& edge)\n\t{\n\t\tREP(k, siz)REP(i, siz)REP(j, siz)\n\t\t\tif (edge[i][k] != INF && edge[j][k] != INF)\n\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\t}\n\n\tvoid update(vector<int> route)\n\t{\n\t\tarray<int, siz> besttime;\n\t\tfill(besttime.begin(), besttime.end(), INF);\n\t\tREP(port, N)\n\t\t\tif (havePort[port] && uf.same(route.back(),port)) \n\t\t\t{\n\t\t\t\tbesttime[port] = act_route(port, route);\n\t\t\t}\n\t\ttime = besttime;\n\t}\n\n\tint act_route(\n\t\tconst int& port, \n\t\tconst vector<int>& route)\n\t{\n\t\tint best = INF;\n\t\tREP(i, N)if (time[i] != INF)\n\t\t{\n\t\t\tint sum = time[i];\n\t\t\tsum += sea[i][port];\n\t\t\tREP(j, route.size() - 1)\n\t\t\t{\n\t\t\t\tsum += load[route[i]][route[i + 1]];\n\t\t\t}\n\t\t\tsum += load[route.back()][port];\n\t\t\tbest = min(best, sum);\n\t\t}\n\t\treturn best;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile(true){\n\t\tStage stage;\n\t\tif(stage.is_end())break;\n\t\tstage.action();\n\t}\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL INF = 1e14;\n\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, R;\n  while(cin >> N >> M, N){\n\tfill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n\tfill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n\n\tREP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n\tREP(i,M){\n\t  LL x, y, t; char c;\n\t  cin >> x >> y >> t >> c;\n\t  --x, --y;\n\t  if(c == 'L')\n\t\tdist_L[x][y] = dist_L[y][x] = min(dist_L[x][y], t);\n\t  else\n\t\tdist_S[x][y] = dist_S[y][x] = min(dist_S[x][y], t);\n\t}\n\t\n\tREP(k,N) REP(i,N) REP(j,N){\n\t  dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n\t  dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n\t}\n\n\tcin >> R;\n\tVI RS(R);\n\tREP(i,R){\n\t  cin >> RS[i];\n\t  --RS[i];\n\t}\n\n\t// dp[i][j] :<=> i???????????§?¨???????????????£??????????????????j?????¨??????????°??????????\n\tfill((LL*)dp, (LL*)dp+1001*201, INF);\n\tdp[0][RS[0]] = 0;\n\tREP(i,R-1){\n\t  REP(u,N){\n\t\tif(dp[i][u] >= INF) continue;\n\t\tREP(v,N){\n\t\t  dp[i+1][v] = min(dp[i+1][v],\n\t\t\t\t\t\t   // Rs[i] -> u????????§???u -> v????????§???v->RS[i+1]????????§?§????\n\t\t\t\t\t\t   dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n\t\t\t\t\t\t   );\n\t\t}\n\t  }\n\t}\n\n\tLL ans = INF;\n\tREP(u,N) ans = min(ans, dp[R-1][u]);\n\tcout << ans << endl;\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n || m){\n        auto Ld = vectors(301,301,(ll)INF);\n        auto Sd = vectors(301,301,(ll)INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                Ld[b][a] = Ld[a][b] = min(Ld[a][b],c);\n            }else{\n                Sd[b][a] = Sd[a][b] = min(Sd[a][b],c);\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(301,301,(ll)INF);\n        dp[0][v[0]] = 0;\n        rep(i,r){\n            if(i  ==  0)continue;\n            rep(j,n){\n                rep(k,n){\n                    if(j != k)cmin(dp[i][j],dp[i-1][k] + Ld[v[i-1]][k] + Sd[k][j] + Ld[j][v[i]]);\n                    else cmin(dp[i][j],dp[i-1][j] + Ld[v[i-1]][v[i]]);\n                }\n            }\n        }\n        int ans = INF;\n        for(auto val : dp[r-1]) cmin(ans, val);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\nint dp[1000][200];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(dp[0],dp[1001],INF);\n\t   dp[0][now]=0;\n\t    \n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct E{\n  int d,t;\n  bool s;\n};\n\nstruct S{\n  int t,x,p,b;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    vector<E> e[201];\n    int d[201][201];\n    fill(d[0],d[201],1<<29);\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      E a={y,t,sl=='S'};\n      e[x].push_back(a);\n      E b={x,t,sl=='S'};\n      e[y].push_back(b);\n      if(sl=='L'){\n\td[x][y]=d[y][x]=min(d[y][x],t);\n      }\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int r;\n    cin>>r;\n    int z[1000];\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n    }\n    priority_queue<S> que;\n    S is={0,0,z[0],z[0]};\n    que.push(is);\n    int p[201][201]={{}};\n    fill(p[0],p[201],false);\n    for(;;){\n      S c=que.top();\n      if(c.x==r-1)break;\n      que.pop();\n      if(p[c.p][c.b]>=c.x+1)continue;\n      p[c.p][c.b]=c.x+1;\n      if(c.p!=c.b&&d[c.p][z[c.x+1]]==1<<29){\n\tS n={c.t+d[c.p][c.b],c.x,c.b,c.b};\n\tque.push(n);\n      }else{\n\tfor(int i=0;i<e[c.p].size();i++){\n\t  E ce=e[c.p][i];\n\t  if(!ce.s||c.b==c.p){\n\t    S n={c.t+ce.t,c.x+(ce.d==z[c.x+1]),ce.d,ce.s?ce.d:c.b};\n\t    if(p[n.p][n.b]<n.x+1){\n\t      que.push(n);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll l[201][201];\nll s[201][201];\nll dp[1001][201];\n\n\nint main(){\n\tint n,m,r;\n\twhile(cin >> n >> m && n!=0){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tl[i][j] = inf;\n\t\t\t\ts[i][j] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tl[i][j] = 0;\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y;\n\t\t\tll t;\n\t\t\tchar c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(c=='L'){\n\t\t\t\tl[x][y] = min(l[x][y],t);\n\t\t\t\tl[y][x] = min(l[x][y],t);\n\t\t\t}else{\n\t\t\t\ts[x][y] = min(s[x][y],t);\n\t\t\t\ts[y][x] = min(s[x][y],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tl[i][j] = min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j] = min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][z[i-1]]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < r; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[r-1], dp[r-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst int INF = 1 << 30;\n\nint main(){\n    while(true){\n        int N,M;\n        cin >> N >> M;\n        if(N == 0 and M == 0) break;\n        vector<vector<vector<int> > > dist(2,vector<vector<int> >(N,vector<int>(N,INF)));\n        for(int i=0;i<M;i++){\n            int x,y,t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;y--;\n            int isl = (sl=='L')?0:1;\n            dist[isl][x][y] = min(dist[isl][x][y],t);\n            dist[isl][y][x] = min(dist[isl][y][x],t);\n        }\n        for(int i=0;i<N;i++){\n            dist[0][i][i] = dist[1][i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[0][i][j] = min(dist[0][i][j],dist[0][i][k]+dist[0][k][j]);\n                    dist[1][i][j] = min(dist[1][i][j],dist[1][i][k]+dist[1][k][j]);\n                }\n            }\n        }\n        int R;\n        cin >> R;\n        vector<int> togo(R);\n        for(int i=0;i<R;i++){\n            cin >> togo[i];\n            togo[i]--;\n        }\n        vector<vector<int> > dp(R,vector<int>(N,INF));\n        dp[0][togo[0]] = 0;\n        for(int i=0;i<R-1;i++){\n            for(int j=0;j<N;j++){\n                if(dp[i][j] == INF) continue;\n                for(int k=0;k<N;k++){\n                    dp[i+1][k] = min(dp[i+1][k],dp[i][j] + \n                            dist[0][togo[i]][j] +\n                            dist[1][j][k] +\n                            dist[0][k][togo[i+1]]);\n                }\n            }\n        }\n        int ret = INF;\n        for(int i=0;i<N;i++){\n            ret = min(ret,dp[R-1][i]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint result[101][101][10001];\nvector<pair<int, pair<short int, bool> > > adjlist[201];\n\nint dijk(vector<int>& z, int n){\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < z.size(); k++){\n        result[i][j][k] = INF;\n      }\n    }\n  }\n\n  \n  //vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<short int, pair<short int, short int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    for(int i = 0; i <= n; i++){\n      adjlist[i].resize(0);\n    }\n    \n    int x, y, t;\n    string sl;\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(z, n + 1);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\"\\n\");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        //#define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nvoid solve(int N, int M) {\n    vector<vector<int>> gl(N, vector<int>(N, INF));\n    vector<vector<int>> gs(N, vector<int>(N, INF));\n    REP(i, M) {\n        int x, y, t;\n        char ls;\n        cin >> x >> y >> t >> ls;\n        x--, y--;\n        if (ls == 'L') {\n            gl[x][y] = gl[y][x] = t;\n        } else {\n            gs[x][y] = gs[y][x] = t;\n        }\n    }\n\n    REP(i, N) gl[i][i] = gs[i][i] = 0;\n    REP(i, N) REP(j, N) REP(k, N) chmin(gl[j][k], gl[j][i] + gl[i][k]);\n    REP(i, N) REP(j, N) REP(k, N) chmin(gs[j][k], gs[j][i] + gs[i][k]);\n\n    int R;\n    cin >> R;\n    vector<int> z(R);\n    REP(i, R) {\n        cin >> z[i];\n        z[i]--;\n    }\n\n    vector<vector<int>> dp(R, vector<int>(N, INF));\n    function<int(int,int)> rec = [&](int i, int s) {\n        auto& DP = dp[i][s];\n        if (DP != INF) return DP;\n        if (i == R - 1) return DP = 0LL;\n        \n        int ret = INF;\n        int land = gl[z[i]][z[i + 1]] + rec(i + 1, s);\n        chmin(ret, land);\n        REP(v, N) {\n            int sea = gl[z[i]][s] + gs[s][v] + gl[v][z[i + 1]];\n            if (sea >= INF) continue;\n            sea += rec(i + 1, v);\n            chmin(ret, sea);\n        }\n        return DP = ret;\n    };\n    cout << rec(0, z[0]) << endl;\n}\nsigned main() {\n    while (1) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        solve(N, M);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\n\nint dp[1010][201];\nint dist[201][201];\nint diss[201][201];\n\nint main()\n{\n\tint n, m;\n\twhile(cin>>n>>m, n||m) {\n\t\tfill(dist[0], dist[201], inf);\n\t\tfill(diss[0], diss[201], inf);\n\t\trep(i,0,m) {\n\t\t\tint a,b,c;\n\t\t\tchar d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--; b--;\n\t\t\tif (d=='L') {\n\t\t\t\tif (c < dist[a][b]) {\n\t\t\t\t\tdist[a][b] = c;\n\t\t\t\t\tdist[b][a] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c < diss[a][b]) {\n\t\t\t\t\tdiss[a][b] = c;\n\t\t\t\t\tdiss[b][a] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r; cin>>r;\n\t\tVi v;\n\t\trep(i,0,r) {\n\t\t\tint t; cin>>t;\n\t\t\tt--;\n\t\t\tv.pb(t);\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d g[i][j][1]=%d\\n\",i,j,g[i][j][1]);\n\n\t\t// ????????????????????????????????¢\n\t\trep(k,0,n) rep(i,0,n) rep(j,0,n) {\n\t\t\tdist[k][k] = 0;\n\t\t\tif (dist[i][k]==inf || dist[k][j]==inf) continue;\n\t\t\tif (dist[i][j] > dist[i][k] + dist[k][j]) {\n\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d dist[i][j]=%d\\n\",i,j,dist[i][j]);\n\n\t\t// ?°´?????????????????????????????¢\n\t\trep(k,0,n) rep(i,0,n) rep(j,0,n) {\n\t\t\tdiss[k][k] = 0;\n\t\t\tif (diss[i][k]==inf || diss[k][j]==inf) continue;\n\t\t\tif (diss[i][j] > diss[i][k] + diss[k][j]) {\n\t\t\t\tdiss[i][j] = diss[i][k] + diss[k][j];\n\t\t\t\tdiss[j][i] = diss[i][j];\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d diss[i][j]=%d\\n\",i,j,diss[i][j]);\n\n\t\tfill(dp[0], dp[1010], inf);\n\t\tdp[0][v[0]] = 0;\n\t\trep(i, 0, r - 1) {\n\t\t\tint from = v[i], to = v[i + 1];\n\t\t\t//debug(i);\n\t\t\trep(j, 0, n) {\n\t\t\t\tif (dp[i][j] == inf) continue;\n\t\t\t\t// ??????????????????\n\t\t\t\tif (dist[from][to] != inf)\n\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dist[from][to]);\n\t\t\t\t// ????????????\n\t\t\t\trep(k, 0, n) {\n\t\t\t\t\tif (dist[from][j] == inf || diss[j][k] == inf || dist[k][to] == inf) continue; // ????????????????????§k?????§????????§to?????§\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist[from][j] + diss[j][k] + dist[k][to]);\n\t\t\t\t\t//printf(\"from=%d j=%d k=%d to=%d | dp[i][j]=%d dist[from][j]=%d diss[j][k]=%d dist[k][to]=%d\\n\",\n\t\t\t\t\t\t//from, j, k, to, dp[i][j], dist[from][j], diss[j][k], dist[k][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\t\trep(i,0,n) ans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define inf 1e8\n\nusing namespace std;\n\nint n, m, s[202][202], h[202][202], dp[1024][202], l[1024];\n\nint main()\n{\n\tint i, j, k, x, y, z;\n\tchar c[2];\n\twhile (scanf(\"%d%d\", &n, &m) && (n || m))\n\t{\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tfill(h[i], h[i] + n + 1, inf);\n\t\t\tfill(s[i], s[i] + n + 1, inf);\n\t\t\tfill(dp[i], dp[i] + n + 1, inf);\n\t\t\th[i][i] = s[i][i] = 0;\n\t\t}\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%s\", &x, &y, &z, c);\n\t\t\tif (c[0] == 'L')\n\t\t\t{\n\t\t\t\th[y][x] = min(h[y][x], z);\n\t\t\t\th[x][y] = h[y][x];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[y][x] = min(s[y][x], z);\n\t\t\t\ts[x][y] = s[y][x];\n\t\t\t}\n\t\t}\n\t\tfor (k = 1; k <= n; k++)\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t\t{\n\t\t\t\t\th[i][j] = min(h[i][j], h[i][k] + h[k][j]);\n\t\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++)\n\t\t\tscanf(\"%d\", &l[i]);\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tdp[0][j] = s[l[0]][j] + h[j][l[0]];\n\t\tfor (i = 1; i < m; i++)\n\t\t{\n\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tfor (k = 1; k <= n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + h[l[i-1]][j] + s[j][k] + h[k][l[i]]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][k] + h[l[i-1]][l[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *min_element(dp[m-1] + 1, dp[m-1] + n + 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n\nint n,m,r;\nconst int INF=1e7;\nint land[200][200],sea[200][200],z[1000];\ntypedef pair<int,int> P;\n\nint main(){\n\n\n\twhile(cin>>n>>m,n){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) land[i][j]=sea[i][j]=INF;\n\t\t\tland[i][i]=sea[i][i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tx--; y--;\n\t\t\tif(s==\"S\"){\n\t\t\t\tsea[x][y]=min(sea[x][y],t);\n\t\t\t\tsea[y][x]=min(sea[y][x],t);\n\t\t\t}else{\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=min(land[y][x],t);\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin>>r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin>>z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(1001,vector<int>(201,INF));\n\t\tdp[0][z[0]]=0;\n\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\n\t\t\t\t//z[i]???????????????????????¨??°???z[i-1]\n\t\t\t\t\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t//????????????j?????§?§???????j??????k????????????k??????z[i]?????????\t\t\t\t\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//????????§?§????\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\t}\n\t\t}\n\n\n\t\tint res=INF;\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres=min(res,dp[r-1][i]);\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\n \ntemplate<class T>inline string toString(T x){\n        ostringstream sout; sout<<x; return sout.str();\n}\nconst ll MOD=1e9+7;\nconst int inf=(ll)1e9;\nconst double PI=acos(-1.0);\n \n \n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int ldp[201][201];\n        int sdp[201][201];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                ldp[i][j]=inf;\n                sdp[i][j]=inf;\n            }\n        }\n        for(int i=0;i<n;i++){\n            ldp[i][i]=0;\n            sdp[i][i]=0;\n        }\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L'){\n                ldp[a][b]=c;\n                ldp[b][a]=c;\n            }else{\n                sdp[a][b]=c;\n                sdp[b][a]=c;\n            }\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    ldp[i][j]=min(ldp[i][k]+ldp[k][j],ldp[i][j]);\n                    sdp[i][j]=min(sdp[i][k]+sdp[k][j],sdp[i][j]);\n                }\n            }\n        }\n        int r;cin>>r;\n        int a[1002];\n        for(int i=0;i<r;i++){\n            cin>>a[i];\n            a[i]--;\n        }\n        int dp[1001][201];\n        for(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n        dp[0][a[0]]=0;\n        for(int i=0;i<r-1;i++){\n            for(int j=0;j<n;j++){\n                if(dp[i][j]==inf)continue;\n                for(int k=0;k<n;k++){\n                    dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][j]+sdp[j][k]+ldp[k][a[i+1]]);\n                    if(j==k)dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][a[i+1]]);\n                }\n            }\n        }\n        /*for(int i=0;i<r;i++){\n            for(int j=0;j<n;j++){\n                cerr<<dp[i][j]<<\" \";\n            }\n            cerr<<\"\\n\";\n        }*/\n        int ans=inf;\n        for(int i=0;i<201;i++){\n            ans=min(ans,dp[r-1][i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 2200 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2200)\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<limits>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconst int MAX_N = 200, MAX_R = 1000, INF = std::numeric_limits<int>::max()>>4;\n\nint N, M, R;\nint land[MAX_N][MAX_N], sea[MAX_N][MAX_N];\nint dp[MAX_R+1][MAX_N];\nint z[MAX_N];\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &N, &M ), N|M )\n\t{\n\t\trep( i, N ) rep( j, N )\n\t\t\tland[i][j] = sea[i][j] = i==j?0:INF;\n\n\t\trep( i, M )\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl[2];\n\n\t\t\tscanf( \"%d%d%d%s\", &x, &y, &t, sl );\n\t\t\t--x; --y;\n\n\t\t\tauto mat = *sl=='L'?land:sea;\n\t\t\tmat[x][y] = mat[y][x] = std::min( mat[x][y], t );\n\t\t}\n\n\t\tscanf( \"%d\", &R );\n\t\trep( i, R )\n\t\t\tscanf( \"%d\", z+i ), --z[i];\n\n\t\trep( k, N ) rep( i, N ) rep( j, N )\n\t\t{\n\t\t\tland[i][j] = std::min( land[i][j], land[i][k]+land[k][j] );\n\t\t\tsea[i][j] = std::min( sea[i][j], sea[i][k]+sea[k][j] );\n\t\t}\n\n\t\trep( i, R+1 ) rep( j, N+1 )\n\t\t\tdp[i][j] = INF;\n\t\t\n\t\tdp[0][z[0]] = 0;\n\t\trep( i, R-1 ) rep( j, N ) rep( k, N )\n\t\t{\n\t\t\tif( j != k )\n\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][k]+land[z[i]][k]+sea[k][j]+land[j][z[i+1]] );\n\t\t\telse\n\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][j]+land[z[i]][z[i+1]] );\n\t\t}\n\n\t\tprintf( \"%d\\n\", *std::min_element( dp[R-1], dp[R-1]+N ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nvi p;\nusing t = vector<pair<int, void*>>;\nvpii ki;\nt* c(int i) {\n\tif (ki.size() == i)return nullptr;\n\tt* a=new t(ki[i].second + 1);\n\trep(j, ki[i].second + 1) {\n\t\t(*a)[j].second = c(i + 1);\n\t}\n\treturn a;\n}\nvoid add(int k, int i, t* a) {\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second+0);\n\t(*a)[s].first++;\n\tif (i == ki.size() - 1) {\n\t\treturn;\n\t}\n\tadd(k, i + 1, (t*)((*a)[s].second));\n}\nll cnt(int k, int i, t*a) {\n\tll c = 0;\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second + 0);\n\tif (i == ki.size() - 1) {\n\t\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += (*a)[j].first;\n\t\treturn c;\n\t}\n\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += cnt(k, i + 1, (t*)((*a)[j].second));\n\treturn c;\n}\nint lw[200][200], sw[200][200];\nint dp[2][200];\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tfill(lw[0], lw[200], numeric_limits<int>::max() / 8);\n\t\tfill(sw[0], sw[200], numeric_limits<int>::max() / 8);\n\t\trep(i, n)lw[i][i] = 0;\n\t\trep(i, n)sw[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tcmin(lw[x - 1][y - 1], t);\n\t\t\t\tcmin(lw[y - 1][x - 1], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmin(sw[x - 1][y - 1], t);\n\t\t\t\tcmin(sw[y - 1][x - 1], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(lw[i][j], lw[i][k] + lw[k][j]);\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(sw[i][j], sw[i][k] + sw[k][j]);\n\t\t}\n\t\tfill(dp[0], dp[1], numeric_limits<int>::max() / 8);\n\t\tint r;\n\t\tcin >> r;\n\t\tvi z(r);\n\t\trep(i, r)cin >> z[i];\n\t\tint prev = z[0] - 1;\n\t\tdp[0][z[0] - 1] = 0;\n\t\trep(i, r) {\n\t\t\tfill(dp[i & 1^1], dp[(i&1^1) + 1], numeric_limits<int>::max() / 8);\n\t\t\trep(j, n)rep(k, n) {\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][j] + sw[j][k] + lw[k][z[i] - 1]);\n\t\t\t}\n\t\t\tprev = z[i] - 1;\n\t\t}\n\t\tint ans = numeric_limits<int>::max() / 8;\n\t\trep(i, n)cmin(ans, dp[r & 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint main(){\n  int N, M;\n  int city[2][200][200];\n  int dp[1000][200];\n  int R, z[1000];\n\n  while(cin >> N >> M, N){\n    \n    fill_n( **city, 2 * 200 * 200, INF);\n    fill_n( *dp, 1000 * 200, INF);\n\n    for(int i = 0; i < M; i++){\n      int a, b, t;\n      char c;\n      cin >> a >> b >> t >> c;\n      a--, b--;\n      if(c == 'L'){\n        city[0][a][b] = city[0][b][a] = t;\n      }else{\n        city[1][a][b] = city[1][b][a] = t;\n      }\n    }\n    cin >> R;\n    for(int i = 0; i < R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    for(int l = 0; l < 2; l++){\n      for(int k = 0; k < N; k++){\n        city[l][k][k] = 0;\n        for(int i = 0; i < N; i++){\n          for(int j = 0; j < N; j++){\n            city[l][i][j] = min( city[l][i][j], city[l][i][k] + city[l][k][j]);\n          }\n        }\n      }\n    }\n    dp[0][z[0]] = 0;\n    for(int i = 0; i < R - 1; i++){\n      for(int j = 0; j < N; j++){ //船を止めてある場所\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < N; k++){ //次船を止める場所\n          if(j == k){\n            dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + city[0][z[i]][z[i + 1]]);\n          }else{\n            dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + city[0][z[i]][j] + city[1][j][k] + city[0][k][z[i + 1]]);\n          }\n        }\n      }\n    }\n    cout << *min_element( dp[R - 1], dp[R]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nint n,m,r;\nvi route;\nvvi L,S;\n\nint solve(){\n    vvi dp(r,vi(n,INF));\n    dp[0][route[0]]=0;\n        //i番目の集配が終了した時点で、頂点jに船を乗り捨てているときの累計コスト\n    rep(p,r-1){\n        int s=route[p],t=route[p+1];\n        rep(i,n)rep(j,n){\n            //cout<<s<<\"->\"<<i<<\"->\"<<j<<\"->\"<<t<<endl;\n            //cout<<vi{dp[p][i],L[s][i],S[i][j],L[j][t]}<<endl;\n            if(dp[p][i]!=INF and L[s][i]!=INF and S[i][j]!=INF and L[j][t]!=INF){\n\t\t\t\tif(i==j)\n\t\t\t\t\tdp[p+1][j]=min(dp[p+1][j],dp[p][i]+L[s][t]);\n\t\t\t\telse\n\t\t\t\t\tdp[p+1][j]=min(dp[p+1][j],dp[p][i]+L[s][i]+S[i][j]+L[j][t]);\n            }\n        }\n        //cout<<p+1<<\":\"<<dp[p+1]<<endl;\n    }\n    return *min_element(all(dp[r-1]));\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\twhile(cin>>n>>m,n){\n\t    L=vvi(n,vi(n,INF));\n\t    S=vvi(n,vi(n,INF));\n\t    rep(_,m){\n\t        int x,y,t; char c;\n\t        cin>>x>>y>>t>>c;\n\t        x--;y--;\n\t\t\tt=min((c=='L'?L:S)[x][y],t);\n\t        (c=='L'?L:S)[x][y]=(c=='L'?L:S)[y][x]=t;\n\t    }\n\t    rep(k,n)rep(i,n)rep(j,n)if(i!=j){\n\t        if(L[i][k]!=INF&&L[k][j]!=INF)\n\t            L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t        if(S[i][k]!=INF&&S[k][j]!=INF)\n\t            S[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t    }else L[i][j]=S[i][j]=0;\n\t    cin>>r;\n\t    route.resize(r);\n\t    rep(i,r){\n\t        cin>>route[i];\n\t        route[i]--;\n\t    }\n\t    cout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\nint dp[1000][200];\n \nint main(){\n \n \n\twhile(scanf(\"%d %d\",&n,&m),n){\n\n\t\tfill(&d[0][0][0],&d[3][0][0],INF);\n\t\t\n\t\tfor(int i=0;i<n;i++) d[0][i][i]=d[1][i][i]=0;\n/*\t\t\n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n*/\t\n\n\n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t\t\n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(&dp[0][0],&dp[1001][0],INF);\n\t   dp[0][now]=0;\n\t\t\n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t\t\n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX;\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tvvl ldist(N, vl(N, INF));\n\t\tvvl sdist(N, vl(N, INF));\n\t\tll x, y, t;\n\t\tchar sl;\n\t\tREP(i, M) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tldist[x][y] = min(ldist[x][y], t);\n\t\t\t\tldist[y][x] = min(ldist[y][x], t);\n\t\t\t} else {\n\t\t\t\tsdist[x][y] = min(sdist[x][y], t);\n\t\t\t\tsdist[y][x] = min(sdist[y][x], t);\n\t\t\t}\n\t\t}\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvi z(R);\n\t\tint tmp;\n\t\tREP(i, R) {\n\t\t\tcin >> tmp;\n\t\t\tz[i] = tmp-1;\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tldist[j][k] = min(ldist[j][k], ldist[j][i]+ldist[i][k]);\n\t\t\t\t\tsdist[j][k] = min(sdist[j][k], sdist[j][i]+sdist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tldist[i][i] = sdist[i][i] = 0;\n\t\t}\n\n\t\tvvl dp(R, vl(N, INF));\n\t\tdp[0][z[0]] = 0;\n\t\tREP(i, R-1) {\n\t\t\tint from = z[i], to = z[i+1];\n\t\t\tREP(before, N) {\n\t\t\t\tif(dp[i][before] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tREP(after, N) {\n\t\t\t\t\tll cost = INF;\n\t\t\t\t\tcost = min(cost, ldist[from][before] + sdist[before][after] + ldist[after][to]);\n\t\t\t\t\tif(before == after) {\n\t\t\t\t\t\tcost = min(cost, ldist[from][to]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i+1][after] = min(dp[i+1][after], dp[i][before]+cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint dp[1010][300]={0};\nint L[201][201],S[201][201];\nsigned main(){\n\n\t\n\n\tint n,m;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) return 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tL[i][j]=inf;\n\t\t\t\tS[i][j]=inf;\n\t\t\t}\n\t\t\tL[i][i]=0;\n\t\t\tS[i][i]=0;\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tif(s==\"S\"){\n\t\t\t\tS[x][y]=min(S[x][y],t);\n\t\t\t\tS[y][x]=min(S[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tL[x][y]=min(L[x][y],t);\n\t\t\t\tL[y][x]=min(L[y][x],t);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t}\n\t\tfor(int i=0;i<1010;i++)for(int j=0;j<300;j++)dp[i][j]=inf;\n\t\tvector<int>ve;\n\t\tve.pb(-1);\n\t\tint r;\n\t\tcin>>r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint rt;\n\t\t\tcin>>rt;\n\t\t\tve.pb(rt);\n\t\t}\n\t\tdp[0][ve[1]]=0;\n\t\t\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t//\t\tif(dp[i-1][j]>=inf) continue;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(k!=j)\tdp[i][j]=min(dp[i][j],dp[i-1][k]+L[ve[i]][k]+S[k][j]+L[j][ve[i+1]]);\n\t\t\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][k]+L[ve[i]][ve[i+1]]);\n\t\t\t\t}\n\t\t\t//\tcout<<\"dp \"<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t\t}\n\t\t}\n\tint ans=inf;\n\t\tfor(int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n\t\tcout<<ans<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const MAX_R = 1010;\nint const MAX_N = 210;\nint const INF = 1<<29;\n\nlong long dl[MAX_N][MAX_N];\nlong long ds[MAX_N][MAX_N];\nlong long dp[MAX_R][MAX_N];\nint z[MAX_R];\nint N, M, R;\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dl[i][j] = dl[j][i] = INF;\n        ds[i][j] = ds[j][i] = INF;\n      }\n      dl[i][i] = dl[i][i] = ds[i][i] = ds[i][i] = 0;\n    }\n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dl[x][y] = dl[y][x] = t;\n      }\n      else {\n        ds[x][y] = ds[y][x] = t;\n      }\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k]+dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j]);\n        }\n    \n    cin >> R;\n    for(int i=0; i<R; i++) { cin >> z[i]; z[i]--; }\n    \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    \n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++) {\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s]+dl[z[i-1]][s]+ds[s][t]+dl[t][z[i]]);\n        }\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define N 1000000000\nusing namespace std;\n\nint L[210][210],S[210][210];\nint dp[1100][210];\nint n,m;\nint x,y,t;\nchar s;\nint r,z[1100];\n\nint main(){\n  while(cin >> n >> m ,n||m){\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tif(i==j){\n\t  L[i][j] = 0;\n\t  S[i][j] = 0;\n\t}else{\n\t  L[i][j] = N;\n\t  S[i][j] = N;\n\t}\n      }\n    }\n\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> s;\n      if(s=='L'){\n\tL[x][y] = t;\n\tL[y][x] = t;\n      }else{\n\tS[x][y] = t;\n\tS[y][x] = t;\n      }\n    }\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  L[i][j] = min(L[i][j] , L[i][k] + L[k][j]);\n\n    for(int k=1;k<=n;k++)\n      for(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t  S[i][j] = min(S[i][j] , S[i][k] + S[k][j]);\n\n    cin >> r;\n    for(int i=0;i<r;i++)cin >> z[i];\n\n    for(int i=0;i<r;i++){\n      for(int j=1;j<=n;j++){\n\tdp[i][j] = N;\n      }\n    }\n \n    dp[0][z[0]] = 0;\n\n    for(int i=1;i<r;i++){\n      for(int j=1;j<=n;j++){\n\tif(L[z[i-1]][z[i]] != N){\n\t  dp[i][j] = min(dp[i][j],dp[i-1][j] + L[z[i-1]][z[i]]);\n\t}\n\tfor(int k=1;k<=n;k++){\n\t  if(S[j][k] != N && L[k][z[i]] !=N){\n\t    dp[i][k] = min(dp[i][k],dp[i-1][j] + L[z[i-1]][j] + S[j][k] + L[k][z[i]]);\n\t  }\n\t}\n      }\n    }\n    int ans = N;\n    for(int i=1;i<=n;i++)ans = min(ans,dp[r-1][i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> Q2;\nvector<tuple<long long, long long, int>> Y[MAX_N];\nvector<tuple<long long, long long, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N], DIST2[MAX_N];\nlong long COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nlong long PATH[MAX_N][MAX_N][MAX_N];\nlong long cnt;\n\nvoid dijkstra3() {\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST2[j] = INF;\n\t\t\tCOLOR2[j] = WHITE;\n\t\t}\n\t\tDIST2[i] = 0;\n\t\tCOLOR2[i] = GRAY;\n\t\tQ2.push(make_pair(0, i));\n\t\twhile (!Q2.empty()) {\n\t\t\tpair<long long, long long>pa = Q2.top(); Q2.pop();\n\t\t\tlong long a11 = pa.first;\n\t\t\tlong long a12 = pa.second;\n\t\t\tCOLOR2[a12] = BLACK;\n\t\t\tfor (int j = 0; j < Y[a12].size(); j++) {\n\t\t\t\tlong long a13 = get<0>(Y[a12][j]);\n\t\t\t\tlong long a14 = get<1>(Y[a12][j]);\n\t\t\t\tlong long a15 = get<2>(Y[a12][j]);\n\t\t\t\tif (a15 == 1) {\n\t\t\t\t\tlong long a16 = a11 + a14;\n\t\t\t\t\tif (DIST2[a13] > a16 && COLOR2[a13] != BLACK) {\n\t\t\t\t\t\tDIST2[a13] = a16;\n\t\t\t\t\t\tCOLOR2[a13] = GRAY;\n\t\t\t\t\t\tQ2.push(make_pair(DIST2[a13], a13));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (DIST2[j] != INF) {\n\t\t\t\tX[i].push_back(make_tuple(j, DIST2[j], 1));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST2[j] = INF;\n\t\t\tCOLOR2[j] = WHITE;\n\t\t}\n\t\tDIST2[i] = 0;\n\t\tCOLOR2[i] = GRAY;\n\t\tQ2.push(make_pair(0, i));\n\t\twhile (!Q2.empty()) {\n\t\t\tpair<long long, long long>pa = Q2.top(); Q2.pop();\n\t\t\tlong long a11 = pa.first;\n\t\t\tlong long a12 = pa.second;\n\t\t\tCOLOR2[a12] = BLACK;\n\t\t\tfor (int j = 0; j < Y[a12].size(); j++) {\n\t\t\t\tlong long a13 = get<0>(Y[a12][j]);\n\t\t\t\tlong long a14 = get<1>(Y[a12][j]);\n\t\t\t\tlong long a15 = get<2>(Y[a12][j]);\n\t\t\t\tif (a15 == 0) {\n\t\t\t\t\tlong long a16 = a11 + a14;\n\t\t\t\t\tif (DIST2[a13] > a16 && COLOR2[a13] != BLACK) {\n\t\t\t\t\t\tDIST2[a13] = a16;\n\t\t\t\t\t\tCOLOR2[a13] = GRAY;\n\t\t\t\t\t\tQ2.push(make_pair(DIST2[a13], a13));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tif (DIST2[j] != INF) {\n\t\t\t\tX[i].push_back(make_tuple(j, DIST2[j], 0));\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tY[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tY[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tY[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tY[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tdijkstra3();\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = min(PATH[i][j][k], DIST[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+2][NMAX+2];\n\tll sdp[NMAX+2][NMAX+2];\n\tll dp[NMAX+2][RMAX+2];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=min(ldp[x][y],t);\n\t\t\t\tldp[y][x]=min(ldp[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=min(sdp[x][y],t);\n\t\t\t\tsdp[y][x]=min(sdp[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=R;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\tcout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tif(j==k) dp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t\telse dp[j][i]=min(dp[j][i],dp[k][i-1]+ldp[bzi][zi]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int dist1[200][200], dist2[200][200];\n    REP(i, N)REP(j, N){\n      dist1[i][j] = (i != j) ? INF : 0;\n      dist2[i][j] = (i != j) ? INF : 0;\n    }\n    REP(i, M){\n      int x, y, t;\n      char sl;\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      x--; y--;\n      if(sl == 'L') {\n        dist1[x][y] = dist1[y][x] = min(t, dist1[y][x]);\n      } else{\n        dist2[x][y] = dist2[y][x] = min(t, dist2[y][x]);\n      }\n    }\n    REP(k, N)REP(i, N)REP(j, N){\n      dist1[i][j] = min(dist1[i][j], dist1[i][k] + dist1[k][j]);\n      dist2[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j]);\n    }\n    int R; cin>>R;\n    vector<int> z(R);\n    REP(i, R) {\n      cin>>z[i];\n      z[i]--;\n    }\n    int d[1001][200];\n    REP(i, 1001)fill(d[i], d[i] + N, INF);\n    d[0][z[0]] = 0;\n    REP(i, R - 1)REP(fship, N)REP(toship,N){\n      d[i+1][toship] = min(d[i][fship] + dist1[z[i]][fship] + dist2[fship][toship] + dist1[toship][z[i+1]], d[i+1][toship]);\n    }\n    int ans = INF;\n    REP(i, N) ans = min(ans, d[R-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nint parent[210],height[201];\nint N,M;\n\nstruct Info{\n\tInfo(){\n\t\tshima_id = -1;\n\t\tisMinato = false;\n\t}\n\tint shima_id;\n\tbool isMinato;\n};\n\nint getParent(int id){\n\tif(parent[id] == id)return id;\n\telse{\n\t\treturn parent[id] = getParent(parent[id]);\n\t}\n}\n\nbool isSame(int a, int b){\n\treturn getParent(a) == getParent(b);\n}\n\nvoid unite(int a,int b){\n\tint a_parent = getParent(a);\n\tint b_parent = getParent(b);\n\n\tif(a_parent == b_parent)return;\n\n\tif(height[a_parent] > height[b_parent]){\n\t\tparent[b_parent] = a_parent;\n\t}else{\n\t\tif(height[a_parent] == height[b_parent])height[b_parent]++;\n\t\tparent[a_parent] = b_parent;\n\t}\n}\n\nvoid init_array(){\n\tfor(int i = 0; i < N; i++){\n\t\tparent[i] = i;\n\t\theight[i] = 0;\n\t}\n}\n\nvoid func(){\n\n\tInfo info[N];\n\n\tint land_dist[N][N],sea_dist[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(i != k){\n\t\t\t\tland_dist[i][k] = BIG_NUM;\n\t\t\t\tsea_dist[i][k] = BIG_NUM;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tland_dist[i][k] = 0;\n\t\t\t\tsea_dist[i][k] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tinit_array();\n\n\tvector<int> MINATO[N];\n\n\tint from,to,time;\n\tchar buf[2];\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %s\",&from,&to,&time,buf);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(buf[0] == 'L'){\n\t\t\tland_dist[from][to] = min(land_dist[from][to],time);\n\t\t\tland_dist[to][from] = min(land_dist[to][from],time);\n\t\t\tunite(from,to);\n\t\t}else{\n\t\t\tsea_dist[from][to] = min(sea_dist[from][to],time);\n\t\t\tsea_dist[to][from] = min(sea_dist[to][from],time);\n\n\t\t\tinfo[from].isMinato = true;\n\t\t\tinfo[to].isMinato = true;\n\t\t}\n\t}\n\n\tfor(int a = 0; a < N; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tif(land_dist[a][b] == BIG_NUM)continue;\n\t\t\tfor(int c = 0; c < N; c++){\n\t\t\t\tif(land_dist[b][c] == BIG_NUM)continue;\n\t\t\t\tland_dist[a][c] = min(land_dist[a][c],land_dist[a][b] + land_dist[b][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int a = 0; a < N; a++){\n\t\tfor(int b = 0; b < N; b++){\n\t\t\tif(sea_dist[a][b] == BIG_NUM)continue;\n\t\t\tfor(int c = 0; c < N; c++){\n\t\t\t\tif(sea_dist[b][c] == BIG_NUM)continue;\n\t\t\t\tsea_dist[a][c] = min(sea_dist[a][c],sea_dist[a][b] + sea_dist[b][c]);\n\t\t\t}\n\t\t}\n\t}\n\n\n\tbool check[N];\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\tfor(int i = 0; i < N; i++)check[getParent(i)]  = true;\n\n\tint shima_id = 0,table[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(check[i]){\n\t\t\ttable[i] = shima_id++;\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tinfo[i].shima_id = table[parent[i]];\n\t\tif(info[i].isMinato == true){\n\t\t\tMINATO[info[i].shima_id].push_back(i);\n\t\t}\n\t}\n\n\tint R;\n\tscanf(\"%d\",&R);\n\n\tint sche[R];\n\tfor(int i = 0; i < R; i++){\n\t\tscanf(\"%d\",&sche[i]);\n\t\tsche[i]--;\n\t}\n\n\tint min_Cost[R][N];\n\n\tfor(int i = 0; i < R; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tmin_Cost[i][k] = BIG_NUM;\n\t\t}\n\t}\n\n\tmin_Cost[0][sche[0]] = 0;\n\n\tint current_town,next_town,current_shima_id,next_shima_id,tmp,next_minato;\n\n\tfor(int i = 0; i < R-1; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(min_Cost[i][k] == BIG_NUM)continue;\n\n\t\t\tcurrent_town = sche[i];\n\t\t\tnext_town = sche[i+1];\n\t\t\tcurrent_shima_id = info[current_town].shima_id;\n\t\t\tnext_shima_id = info[next_town].shima_id;\n\n\t\t\tif(current_shima_id == next_shima_id){\n\n\t\t\t\tmin_Cost[i+1][k] = min(min_Cost[i+1][k],min_Cost[i][k]+land_dist[current_town][next_town]);\n\n\t\t\t\ttmp = land_dist[current_town][k];\n\t\t\t\tfor(int a = 0; a < MINATO[current_shima_id].size();a++){\n\t\t\t\t\tnext_minato = MINATO[current_shima_id][a];\n\t\t\t\t\tif(next_minato == k)continue;\n\n\t\t\t\t\tmin_Cost[i+1][next_minato] = min(min_Cost[i+1][next_minato],min_Cost[i][k]+tmp+sea_dist[k][next_minato]+land_dist[next_minato][next_town]);\n\t\t\t\t}\n\n\t\t\t}else{\n\n\t\t\t\ttmp = land_dist[current_town][k];\n\n\t\t\t\tfor(int a = 0; a < MINATO[next_shima_id].size();a++){\n\t\t\t\t\tnext_minato = MINATO[next_shima_id][a];\n\n\t\t\t\t\tmin_Cost[i+1][next_minato] = min(min_Cost[i+1][next_minato],min_Cost[i][k] + tmp + sea_dist[k][next_minato] + land_dist[next_minato][next_town]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = BIG_NUM;\n\tfor(int i = 0; i < N; i++)ans = min(ans,min_Cost[R-1][i]);\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF=10000000;\n\nint n,m;\nint ldist[203][203];\nint sdist[203][203];\nint z[1003];\nint dp[1003][203];\n\nvoid solve() {\n    rep(i,203) rep(j,203) ldist[i][j]=sdist[i][j]=INF;\n    rep(i,203) ldist[i][i]=sdist[i][i]=0;\n    rep(i,m) {\n        int s,t,cost;\n        char c;\n        cin>>s>>t>>cost>>c;\n        if(c=='L') ldist[s][t]=ldist[t][s]=min(ldist[s][t],cost);\n        if(c=='S') sdist[s][t]=sdist[t][s]=min(sdist[s][t],cost);\n    }\n    rep(k,n) rep(i,n) rep(j,n) { \n        ldist[i][j]=min(ldist[i][j],ldist[i][k]+ldist[k][j]);\n        sdist[i][j]=min(sdist[i][j],sdist[i][k]+sdist[k][j]);\n    }\n\n    int R;\n    cin>>R;\n    rep(i,R) cin>>z[i];\n    //集配順,船の位置のDP\n\n    rep(i,1003) rep(j,203) dp[i][j]=INF;\n    dp[0][z[0]]=0;\n\n    for(int i=1;i<R;i++) rep(j,n+1) {\n        dp[i][j]=min(dp[i][j],dp[i-1][j]+ldist[z[i-1]][z[i]]);\n        rep(k,n+1) {\n            dp[i][k]=min(dp[i][k],dp[i-1][j]+ldist[z[i-1]][j]+\n                    sdist[j][k]+ldist[k][z[i]]);\n        }\n    }\n    int ans=INF;\n    rep(i,n+1) ans=min(ans,dp[R-1][i]);\n    cout<<ans<<endl;\n\n\n    \n}\nint main() {\n    while(cin>>n>>m) {\n        if(n+m==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int INF=1e16;\n\nvector<vector<long long int>> get_dis(vector<map<int,long long int>> &edge){\n  vector<vector<long long int>> d(edge.size(),vector<long long int>(edge.size(),INF));\n  for(int i=0;i<edge.size();i++){\n    for(int j=0;j<edge.size();j++){\n      if(edge[i].count(j)){\n        d[i][j]=edge[i][j];\n      }\n    }\n\n  }\n  for(int k=0;k<edge.size();k++){\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge.size();j++){\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n  }\n  return d;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    vector<map<int,long long int>> land_edge(n);\n    vector<map<int,long long int>> sea_edge(n);\n    for(int i=0;i<n;i++){\n      land_edge[i][i]=0;\n      sea_edge[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;\n      long long int t;\n      char sl;\n      cin>>x>>y>>t;\n      x--,y--;\n      cin>>sl;\n      if(sl=='L'){\n\tif(land_edge[x].count(y)){\n\t  land_edge[x][y]=min(land_edge[x][y],t);\n\t  land_edge[y][x]=min(land_edge[y][x],t);\n\t}\n\telse{\n\t  land_edge[x][y]=t;\n\t  land_edge[y][x]=t;\n\t}\n      }\n      else{\n\tif(sea_edge[x].count(y)){\n\t  sea_edge[x][y]=min(sea_edge[x][y],t);\n\t  sea_edge[y][x]=min(sea_edge[y][x],t);\n\t}\n\telse{\n\t  sea_edge[x][y]=t;\n\t  sea_edge[y][x]=t;\n\t}\n      }\n\n    }\n    auto land_d=get_dis(land_edge);\n    auto sea_d=get_dis(sea_edge);\n\n    \n    int r;\n    cin>>r;\n    vector<vector<long long int>> dp(r,vector<long long int>(n,INF));\n    int from,to;\n    cin>>from;\n    from--;\n    dp[0][from]=0;\n    for(int task=0;task<r-1;task++){\n      cin>>to;\n      to--;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(i==j) dp[task+1][j]=min(dp[task+1][j],dp[task][j]+land_d[from][to]);\n\t  else dp[task+1][j]=min(dp[task+1][j],dp[task][i]+land_d[from][i]+sea_d[i][j]+land_d[j][to]);\n\t}\n      }\n\n      from=to;\n    }\n    cout<<*min_element(dp[r-1].begin(),dp[r-1].end())<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nint main(void){\n  int N, M, R;\n  while (cin >> N >> M) \n    {\n      if (N == 0 && M == 0)\n\tbreak;\n      int x,y,t;\n      char sl;\n      vector<VI> land(N, VI(N, INT_MAX/4)), sea(N, VI(N, INT_MAX/4));\n      REP(i,0,M)\n\t{\n\t  cin >> x >> y >> t >> sl;\n\t  if (sl == 'L') \n\t    {\n\t      land[x-1][y-1] = t;\n\t      land[y-1][x-1] = t;\n\t    }\n\t  else\n\t    {\n\t      sea[x-1][y-1] = t;\n\t      sea[y-1][x-1] = t;\n\t    }\n\t}\n      cin >> R;\n      VI z(R);\n      REP(i,0,R)\n\t{\n\t  cin >> z[i];\n\t  z[i]--;\n\t}\n      REP(i,0,N)\n\t{\n\t  land[i][i] = 0;\n\t  sea[i][i] = 0;\n\t}\n      for (int r = 0; r < N; r++)\n\tfor (int p = 0; p < N; p++)\n\t  for (int q = 0; q < N; q++)\n\t    {\n\t      if (land[p][q] > land[p][r] + land[r][q])\n\t\tland[p][q] = land[p][r] + land[r][q];\n\t      if (sea[p][q] > sea[p][r] + sea[r][q])\n\t\tsea[p][q] = sea[p][r] + sea[r][q];\n\t    }\n      /*\n      cout << \"land:\"<<endl;\n      REP(i,0,N)\n\t{\n\t  REP(j,0,N)\n\t    cout << land[i][j] << \"\\t\";\n\t  cout << endl; \n\t}\n       cout << \"sea\"<<endl;\n      REP(i,0,N)\n\t{\n\t  REP(j,0,N)\n\t\tcout << sea[i][j] << \"\\t\";\n\t  cout << endl; \n\t}*/\n      vector<vector<ll> > dp(N, vector<ll>(R, INT_MAX/2));\n      dp[0][z[0]] = 0;\n      REP(i,1,R)\n\t{\n\t  REP(j,0,N)\n\t    {\n\t      //cout << \"j=\"<< j <<endl;\n\t      REP(k, 0, N)\n\t\t{\n\t\t  dp[i][j] = min(dp[i][j], dp[i-1][k] + land[z[i-1]][k]+ sea[k][j] + land[j][z[i]]);\n\t\t  //cout << dp[i-1][k] <<\"+\"<< sea[k][j] <<\"+\"<< land[j][z[i]] << \"\\t\";\n\t\t}\n\t      //cout << endl;\n\t    }\n\t  /*\n\t  REP(i,0,R)\n\t    {\n\t      REP(j,0,N)\n\t\tcout << dp[i][j] << \"\\t\";\n\t      cout << endl; \n\t    }\n\t  cout << endl;\n\t  */\n\t}\n      ll min_cost = dp[R-1][0];\n      REP(i, 1,R)\n\tmin_cost = min(min_cost, dp[R-1][i]);\n      cout << min_cost<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint d1[205][205], d2[205][205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, n) REP(j, n) {\n      d1[i][j] = i==j?0:INF;\n      d2[i][j] = i==j?0:INF;\n    }\n    REP(i, m) {\n      int x, y, c;\n      char t;\n      cin >> x >> y >> c >> t;\n      x--, y--;\n      if(t == 'L') {\n        chmin(d1[x][y], c);\n        chmin(d1[y][x], c);\n      } else {\n        chmin(d2[x][y], c);\n        chmin(d2[y][x], c);\n      }\n    }\n\n    REP(k, n) REP(i, n) REP(j, n) {\n      chmin(d1[i][j], d1[i][k] + d1[k][j]);\n      chmin(d2[i][j], d2[i][k] + d2[k][j]);\n    }\n\n    int r;\n    cin >> r;\n    VI cur(n, INF), nxt(n, INF);\n    int now;\n    cin >> now; now--;\n    REP(i, n) cur[i] = i==now?0:INF;\n    REP(i, r-1) {\n      int g;\n      cin >> g; g--;\n\n      REP(j, n) {\n        // (now, j) からスタートする\n        REP(k, n) {\n          // (g, k) を目的とする\n          // 陸でnow->j 船でj->k 陸でk->g\n          int tmp = d1[now][j] + d2[j][k] + d1[k][g];\n          // 陸だけで移動\n          if(j == k) chmin(tmp, d1[now][g]);\n          chmin(nxt[k], cur[j] + tmp);\n        }\n      }\n      // cout << nxt << endl;\n\n      cur = nxt;\n      nxt.assign(n, INF);\n      now = g;\n    }\n\n    int ret = INF;\n    REP(i, n) chmin(ret, cur[i]);\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x334334334334\n\ntypedef long long int LLI;\n\nint n;\nint m;\nint R;\nint z[1419];\nLLI dp[1145][1419];\nLLI mindL[1145][1419];\nLLI mindS[1145][1419];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    fill(mindL[0], mindL[n+1], INF);\n    fill(mindS[0], mindS[n+1], INF);\n    for (int i=1; i<=n; i++) {\n      mindL[i][i] = 0;\n      mindS[i][i] = 0;\n    }\n\n    for (int i=0; i<m; i++) {\n      char sl;\n      int x, y;\n      LLI t;\n      scanf(\"%d%d%lld %c\", &x, &y, &t, &sl);\n      if (sl == 'L') {\n        mindL[x][y] = min(mindL[x][y], t);\n        mindL[y][x] = min(mindL[y][x], t);\n      } else {\n        mindS[x][y] = min(mindS[x][y], t);\n        mindS[y][x] = min(mindS[y][x], t);\n      }\n    }\n\n    for (int k=1; k<=n; k++) {\n      for (int i=1; i<=n; i++) {\n        for (int j=1; j<=n; j++) {\n          mindL[i][j] = min(mindL[i][j], mindL[i][k] + mindL[k][j]);\n          mindL[j][i] = min(mindL[j][i], mindL[j][k] + mindL[k][i]);\n          mindS[i][j] = min(mindS[i][j], mindS[i][k] + mindS[k][j]);\n          mindS[j][i] = min(mindS[j][i], mindS[j][k] + mindS[k][i]);\n        }\n      }\n    }\n\n    scanf(\"%d\", &R);\n    fill(dp[0], dp[R+1], INF);\n\n    scanf(\"%d\", &z[0]);\n    dp[0][z[0]] = 0;\n    for (int i=1; i<R; i++) {\n      scanf(\"%d\", &z[i]);\n      for (int j=1; j<=n; j++) {\n        for (int k=1; k<=n; k++) {\n          LLI t = dp[i-1][j] + mindL[z[i-1]][j] + mindS[j][k] + mindL[k][z[i]];\n          dp[i][k] = min(dp[i][k], t);\n        }\n      }\n    }\n\n    LLI ans = INF;\n    for (int i=1; i<=n; i++) ans = min(ans, dp[R-1][i]);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &s) const { return d > s.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n  bool operator < (const State2 &s) const { return d > s.d;}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > ans(2,vector<int>(n,INF));\n    ans[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){    \n\n      for(int j=0;j<n;j++){\n\tif(ans[0][j] >= INF) continue;\t\n\n\tpriority_queue<State> Q;\n\tvector<vector<State2> > d(n,vector<State2>(n));\n\tState u(ans[0][j],dest[i-1],j), v;\n\td[dest[i-1]][j].d = ans[0][j];\n\tQ.push(u);\n\n\twhile(!Q.empty()){\n\t  u = Q.top();\n\t  Q.pop();\n\n\t  if(d[u.n][u.s].f) continue;\n\t  if(u.n == dest[i]){\n\t    ans[1][u.s] = min(ans[1][u.s],u.d);\n\t    continue;\n\t  }\n\t  d[u.n][u.s].f = true;\n\n\t  for(int k=0;k<n;k++){\n\t    if(!d[k][u.s].f && d[u.n][u.s].d + L[u.n][k] < d[k][u.s].d){\n\t      v = u;\n\t      v.d = d[k][u.s].d = d[u.n][u.s].d + L[u.n][k];\n\t      v.n = k;\n\t      Q.push(v);\n\t    }\n\t    if(u.s == u.n){\n\t      if(!d[k][k].f && d[u.n][u.s].d + S[u.n][k] < d[k][k].d){\n\t\tv = u;\n\t\tv.d = d[k][k].d = d[u.n][u.s].d + S[u.n][k];\n\t\tv.s = v.n = k;\n\t\tQ.push(v);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      ans[0].assign(ans[1].begin(),ans[1].end());\n      //for(int j=0;j<n;j++) if(ans[0][j] != INF) cout << ans[0][j] << \" \";\n      ans[1].assign(n,INF);\n    }\n\n    int ans2 = INF;\n    for(int i=0;i<n;i++) ans2 = min(ans2,ans[0][i]);\n    cout << ans2 << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][now]=0;\n\t    \n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1].begin(),dp[r-1].end()));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\nstruct edge\n{\n\tint s, t, w;\n\tedge(int s, int t, int w) :s(s), w(w), t(t) {}\n\tedge() { s = -1, w = -1, t = -1; }\n};\n\nint land[203][203], sea[203][203];\nint order[1003];\nint dp[1003][203];\n\nsigned main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M,R, x, y, t,z;\n\tchar s;\n\twhile (true)\n\t{\n\t\tcin >> N >> M;\n\t\tif (N + M == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\trep(i, 0, N)rep(j, 0, N)if (i != j)land[i][j] = INF, sea[i][j] = INF;\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--, y--;\n\t\t\tif (s == 'L')\n\t\t\t{\n\t\t\t\tchmin(land[x][y], t);\n\t\t\t\tland[y][x] = land[x][y];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tchmin(sea[x][y], t);\n\t\t\t\tsea[y][x] = sea[x][y];\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\trep(i, 0, R)\n\t\t{\n\t\t\tcin >> z;\n\t\t\torder[i] = z - 1;\n\t\t}\n\n\t\trep(k, 0, N)rep(i, 0, N)rep(j, 0, N)\n\t\t{\n\t\t\tif (land[i][k] != INF&&land[k][j] != INF)chmin(land[i][j], land[i][k] + land[k][j]);\n\t\t\tif (sea[i][k] != INF&&sea[k][j] != INF)chmin(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t}\n\n\t\trep(i, 0, R)rep(j, 0, N)dp[i][j] = INF;\n\t\tdp[0][order[0]] = 0;\n\n\t\trep(i, 0, R - 1)\n\t\t{\n\t\t\trep(j, 0, N)\n\t\t\t{\n\t\t\t\tif (dp[i][j] == INF)\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + land[order[i]][order[i + 1]]);\n\t\t\t\trep(k, 0, N)\n\t\t\t\t{\n\t\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + land[order[i]][j] + sea[j][k] + land[k][order[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tchmin(ans, dp[R - 1][i]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 214748360012345\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to;\n  long cost;\n  char type;\n};\n\ntypedef pair<long, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(c=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<long> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(i!=r-2 && e.type=='L' && !(uf.same(nxtp, route[i+1]) || uf.same(nxtp, ship))) continue;\n          long nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    long res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL<<60;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N) {\n        vector<vector<long long> > dps(N, vector<long long>(N, INF)), dpl(N, vector<long long>(N, INF));\n        for (int v = 0; v < N; ++v) dps[v][v] = dpl[v][v] = 0;\n        for (int e = 0; e < M; ++e) {\n            int x, y;\n            long long w;\n            char type;\n            cin >> x >> y >> w >> type;\n            --x, --y;\n            if (type == 'L') chmin(dpl[x][y], w), chmin(dpl[y][x], w);\n            else chmin(dps[x][y], w), chmin(dps[y][x], w);\n        }\n        for (int k = 0; k < N; ++k) {\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    dpl[i][j] = min(dpl[i][j], dpl[i][k] + dpl[k][j]);\n                    dps[i][j] = min(dps[i][j], dps[i][k] + dps[k][j]);\n                }\n            }\n        }\n        \n        int R; cin >> R;\n        vector<int> v(R);\n        for (int i = 0; i < R; ++i) cin >> v[i], --v[i];\n        \n        vector<vector<long long> > dp(R, vector<long long>(N, INF));\n        dp[0][0] = 0;\n        for (int i = 0; i < R-1; ++i) {\n            for (int j = 0; j < N; ++j) {\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + dpl[v[i]][v[i+1]]);\n                for (int k = 0; k < N; ++k) {\n                    dp[i+1][k] = min(dp[i+1][k], dp[i][j] + dpl[v[i]][j] + dps[j][k] + dpl[k][v[i+1]]);\n                }\n            }\n        }\n        long long res = INF;\n        for (int i = 0; i < N; ++i) {\n            res = min(res, dp[R-1][i]);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nvi p;\nusing t = vector<pair<int, void*>>;\nvpii ki;\nt* c(int i) {\n\tif (ki.size() == i)return nullptr;\n\tt* a=new t(ki[i].second + 1);\n\trep(j, ki[i].second + 1) {\n\t\t(*a)[j].second = c(i + 1);\n\t}\n\treturn a;\n}\nvoid add(int k, int i, t* a) {\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second+0);\n\t(*a)[s].first++;\n\tif (i == ki.size() - 1) {\n\t\treturn;\n\t}\n\tadd(k, i + 1, (t*)((*a)[s].second));\n}\nll cnt(int k, int i, t*a) {\n\tll c = 0;\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second + 0);\n\tif (i == ki.size() - 1) {\n\t\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += (*a)[j].first;\n\t\treturn c;\n\t}\n\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += cnt(k, i + 1, (t*)((*a)[j].second));\n\treturn c;\n}\nint lw[200][200], sw[200][200];\nint dp[2][200];\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tfill(lw[0], lw[200], numeric_limits<int>::max() / 8);\n\t\tfill(sw[0], sw[200], numeric_limits<int>::max() / 8);\n\t\trep(i, n)lw[i][i] = 0;\n\t\trep(i, n)sw[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tcmin(lw[x - 1][y - 1], t);\n\t\t\t\tcmin(lw[y - 1][x - 1], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmin(sw[x - 1][y - 1], t);\n\t\t\t\tcmin(sw[y - 1][x - 1], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(lw[i][j], lw[i][k] + lw[k][j]);\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(sw[i][j], sw[i][k] + sw[k][j]);\n\t\t}\n\t\tfill(dp[0], dp[1], numeric_limits<int>::max() / 8);\n\t\tint r;\n\t\tcin >> r;\n\t\tvi z(r);\n\t\trep(i, r)cin >> z[i];\n\t\tint prev = z[0] - 1;\n\t\tdp[0][z[0] - 1] = 0;\n\t\trep(i, r) {\n\t\t\tfill(dp[i & 1^1], dp[(i&1^1) + 1], numeric_limits<int>::max() / 8);\n\t\t\trep(j, n)rep(k, n) {\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][j] + sw[j][k] + lw[k][z[i] - 1]);\n\t\t\t\tcmin(dp[i & 1 ^ 1][j], dp[i & 1][j] + lw[prev][z[i] - 1]);\n\t\t\t}\n\t\t\tprev = z[i] - 1;\n\t\t}\n\t\tint ans = numeric_limits<int>::max() / 8;\n\t\trep(i, n)cmin(ans, dp[r & 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <climits>\n\n#include <cstdio>\n \nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst int IPPAI = 214748364;\n\nint umi[210][210];\nint riku[210][210];\n\nint cmpl[1010][210]; //??????????????§?????????????????????\nbool used[1010][210];\n\nbool solve(void) {\n    int N, M;\n   \n    cin >> N >> M;\n    if ( N == 0 ) { return false; }\n   \n    REP(i, 210) REP(j, 210) {\n        int a = (i==j) ? 0 : IPPAI;\n        umi[i][j] = a;\n        riku[i][j] = a;\n    }\n   \n    REP(i, M) {\n        int x, y, l;\n        char ty;\n        cin >> x >> y >> l >> ty;\n       \n        if (ty == 'L') {\n            riku[x][y] = l;\n            riku[y][x] = l;\n        } else {\n            umi[x][y] = l;\n            umi[y][x] = l;\n        }\n    }\n   \n    // ???\n    for(int k=1; k<=N; k++) {\n        for(int i=1; i<=N; i++) {\n            for(int j=1; j<=N; j++) {\n                umi[i][j] = std::min(umi[i][j], umi[i][k] + umi[k][j]);\n                riku[i][j] = std::min(riku[i][j], riku[i][k] + riku[k][j]);\n            }\n        }\n    }\n\n    int R;\n    int list[1010];\n    cin >> R;\n    REP(i, R) { cin >> list[i]; }\n   \n    typedef pair<int, pair<int, int> > P;\n    priority_queue<P, vector<P>, greater<P> > que;\n   \n    REP(i, 210) REP(f, 1010) {\n        cmpl[f][i] = IPPAI;\n        used[f][i] = false;\n    }\n    cmpl[0][ list[0] ] = 0;\n    que.push( make_pair(0, make_pair(0, list[0]) ) );\n   \n    while ( !que.empty() ) {\n        P p = que.top(); que.pop();\n        pair<int, int> pa = p.second;\n       \n        int adv = pa.first;\n        int nowpos  = list[adv];\n        int funepos = pa.second;\n       \n        if ( cmpl[adv][funepos] < p.first ) { continue; }\n        if ( adv+1 >= R ) { continue; }\n       \n        for(int i=1; i<=N; i++) {\n            // 1????????????????????????i???\n           \n            int nextpos = list[adv+1];\n           \n            int cost;\n           \n\t\t   //cout << \"adv=\" << adv << \", funepos=\" << funepos << \", i=\" << i << endl;\n            // ??????????????????\n            if ( funepos == i ) {\n                if ( riku[nowpos][nextpos] == IPPAI ) { continue; }\n                cost = riku[nowpos][nextpos];\n            } else {\n                // ????????\\?????´??????????????°???????????§????????§??????\n                if ( riku[nowpos][funepos] == IPPAI ) { continue; }\n                cost = riku[nowpos][funepos];\n               \n                // ?????§ i ?????§?§??????????\n                if ( umi[funepos][i] == IPPAI ) { continue; }\n                cost += umi[funepos][i];\n           \n                if ( riku[i][nextpos] == IPPAI ) { continue; }\n                cost += riku[i][nextpos];\n\t\t\t\t\n\t\t\t\tcout << riku[nowpos][funepos] << \" \" << umi[funepos][i] << \" \" << riku[i][nextpos] << endl;\n            }\n\t\t\t//cout << \"cost = \" << cost << endl;\n           \n            if ( cmpl[adv+1][i] > cmpl[adv][funepos] + cost ) {\n                cmpl[adv+1][i] = cmpl[adv][funepos] + cost;\n                que.push( make_pair(cmpl[adv+1][i], make_pair(adv+1, i) ) );\n            }\n        }\n    }\n   \n    int ret = IPPAI;\n    for(int i=1; i<=N; i++) {\n        ret = std::min(ret, cmpl[R-1][i]);\n    }\n\t\n\tcout << ret << endl;\n   \n    return true;\n}\n\nint main(void) {\n    while( solve() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n//mplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  //cout<<from<<\",\"<<to<<\":\"<<cost<<endl;\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,cap,(int)g[from].size()-1,cost});\n}\nCost INF=5e15;\n//dij\nint n,m,r; \nCost dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    //cout<<p;\n    if(v/n/n==r)return p.X;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n  return -1;\n}\nint fun(int p,int b,int r_){\n  return p+b*n+r_*n*n;\n}\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  while(cin>>n>>m,n){\n    vector<int> a(m),b(m),c(m);\n    vector<char> ch(m);\n    rep(i,m){\n      cin>>a[i]>>b[i]>>c[i]>>ch[i];\n      --a[i]; --b[i];\n    }\n    cin>>r;\n    vector<int> pos(r);\n    rep(i,r){\n      cin>>pos[i]; --pos[i];\n    }\n    //cout<<pos;\n    Graph g(n*n*(r+1));\n    rep(j,n)rep(k,r)\n      add_edge(g,fun(pos[k],j,k),fun(pos[k],j,k+1),1,0);\n    rep(i,m){\n      if(ch[i]=='L'){\n\trep(j,n)rep(k,r)\n\t  add_edge(g,fun(a[i],j,k),fun(b[i],j,k),1,c[i]);\n      }else{\n\trep(k,r)\n\t  add_edge(g,fun(a[i],a[i],k),fun(b[i],b[i],k),1,c[i]);\n      }\n    }\n    vector<Cost> dist(n*n*(r+1));\n    //cout<<\"g.size()\"<<g.size()<<endl;\n    cout<<dij(g,fun(pos[0],pos[0],0),dist)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint main(){\n  int N, M;\n  int city[2][200][200];\n  int dp[2][200];\n  int R, z[1000];\n\n  while(cin >> N >> M, N){\n    \n    fill_n( **city, 2 * 200 * 200, INF);\n    fill_n( *dp, 2 * 200, INF);\n\n    for(int i = 0; i < M; i++){\n      int a, b, t;\n      char c;\n      cin >> a >> b >> t >> c;\n      a--, b--;\n      if(c == 'L'){\n        city[0][a][b] = city[0][b][a] = t;\n      }else{\n        city[1][a][b] = city[1][b][a] = t;\n      }\n    }\n    cin >> R;\n    for(int i = 0; i < R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    for(int l = 0; l < 2; l++){\n      for(int k = 0; k < N; k++){\n        city[l][k][k] = 0;\n        for(int i = 0; i < N; i++){\n          for(int j = 0; j < N; j++){\n            city[l][i][j] = min( city[l][i][j], city[l][i][k] + city[l][k][j]);\n          }\n        }\n      }\n    }\n    dp[0][z[0]] = 0;\n    for(int i = 0; i < R - 1; i++){\n      for(int j = 0; j < N; j++) dp[!(i&1)][j] = INF;\n      for(int j = 0; j < N; j++){ //船を止めてある場所\n        if(dp[i&1][j] == INF) continue;\n        for(int k = 0; k < N; k++){ //次船を止める場所\n          if(j == k){\n            dp[!(i&1)][k] = min( dp[!(i&1)][k], dp[i&1][j] + city[0][z[i]][z[i + 1]]);\n          }else{\n            dp[!(i&1)][k] = min( dp[!(i&1)][k], dp[i&1][j] + city[0][z[i]][j] + city[1][j][k] + city[0][k][z[i + 1]]);\n          }\n        }\n      }\n    }\n    cout << *min_element( dp[!(R&1)], dp[R&1]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n\nll dp[1010][210];\nll riku[210][210], fune[210][210];\n\n\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n | m)) {\n\t\trep(i, 1010) rep(j, 210) dp[i][j] = LINF;\n\t\trep(i, 210) rep(j, 210) riku[i][j] = fune[i][j] = (i == j ? 0LL : LINF);\n\t\trep(i, m) {\n\t\t\tint a, b;\n\t\t\tll t;\n\t\t\tchar c;\n\t\t\tcin >> a >> b >> t >> c;\n\t\t\ta--; b--;\n\t\t\tif(c == 'L') riku[a][b] = riku[b][a] = min(riku[a][b], t);\n\t\t\telse fune[a][b] = fune[b][a] = min(fune[a][b], t);\n\t\t}\n\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\tfune[i][j] = min(fune[i][j], fune[i][k] + fune[k][j]);\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvi v(r);\n\t\trep(i, r) cin >> v[i], v[i]--;\n\t\tdp[v[0]][v[0]] = 0LL;\n\t\trep(i, r - 1) {\n\t\t\trep(j, n) if(dp[i][j] != LINF) {\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + riku[v[i]][v[i+1]]);\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j] + riku[v[i]][j] + fune[j][k] + riku[k][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = LINF;\n\t\tfor(int i = 0; i < 210; i++) ans = min(ans, dp[r-1][i]);\n\t\tcout<<ans<<endl;\n \t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    int land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<n;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      int b;cin>>b;b--;\n      a[i]=b;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    int dp[1001][201];\n    for(int i=0;i<r;i++)for(int j=0;j<n;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          if(land[a[i]][j]==inf)continue;\n          if(sea[j][k]==inf)continue;\n          if(land[k][a[i+1]]==inf)continue;\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n        }\n      }\n    }\n    int ans=inf;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <string.h>\nusing namespace std;\nlong long n, m;\nlong long l[210][210];\nlong long s[210][210];\nlong long dp[1010][210];// 到?第i个?子，船在j?\nlong long t[1010];\nint main()\n{\n    while(scanf(\"%lld%lld\", &n, &m), n || m )\n    {\n        memset(l, 1, sizeof(l));\n        memset(s, 1, sizeof(s));\n        memset(dp, 1, sizeof(dp));\n        for(long long i = 0; i < m; i++)\n        {\n            long long a, b, c;\n            char x;\n            scanf(\"%lld%lld%lld %c\", &a, &b, &c, &x);\n            if(x == 'L')\n                l[a][b] = l[b][a] = min(l[a][b], c);\n            else\n                s[a][b] = s[b][a] = min(s[a][b], c);\n        }\n        for(long long i = 1; i <= n; i++)\n            l[i][i] = s[i][i] = 0;\n        for(long long k = 1; k <= n; k++)\n            for(long long i = 1; i <= n; i++)\n                for(long long j = 1; j <= n; j++)\n                {\n                    l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                    s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n                }\n        long long r;\n        scanf(\"%lld\", &r);\n        for(long long i = 0; i < r; i++)\n            scanf(\"%lld\", &t[i]);\n\n\n        dp[ t[0] ][ 1 ] = min(s[1][ t[0] ], l[1][ t[0] ]);\n\n\n        for(long long i = 1; i < r; i++)\n        {\n            for(long long j = 1; j <= n; j++) // 枚?第 i - 1 个?子的船的位置\n            {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + l[ t[i - 1] ][ t[i] ]); // 走?路\n                for(long long k = 1; k <= n; k++) // 枚?第 i 个?子的船的位置\n                {\n                    dp[i][k] = min(dp[i][k], dp[i - 1][j] + l[ t[i - 1] ][ j ] + s[ j ][ k ] + l[ k ][ t[i] ]); // 走水路\n                }\n            }\n        }\n        long long ans;\n        for(long long i = 1; i <= n; i++)\n        {\n            if(i == 1)\n                ans = dp[r - 1][i];\n            else\n                ans = min(ans, dp[r - 1][i]);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<25\nusing namespace std;\n\nint n,m,r;\nint s[201][201],t[201][201],z[1001],dp[1001][201];\n\nvoid init(){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)s[i][j]=0;\n      else s[i][j]=inf;\n      if(i==j)t[i][j]=0;\n      else t[i][j]=inf;\n    }\n    for(int j=0;j<1001;j++)dp[j][i]=inf;\n  }\n}\n\nvoid wf(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n\tt[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int a,b,d;\n  char c;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>c;\n      a--;b--;\n      if(c=='L'){\n\tt[a][b]=min(d,t[a][b]);\n\tt[b][a]=min(d,t[b][a]);\n      }\n      else {\n\ts[a][b]=min(d,s[a][b]);\n\ts[b][a]=min(d,s[b][a]);\n      }\n    }\n    cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n      z[i]--;\n    }\n\n    wf();\n    int ans=inf;\n    for(int i=0;i<n;i++)dp[0][i]=s[z[0]][i];\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]+t[z[i-1]][k]+s[k][j]+t[z[i]][j]);\n\t  dp[i][j]=min(dp[i][j],dp[i-1][j]+t[z[i-1]][z[i]]);\n\t  if(i==r-1)ans=min(ans,dp[i][j]);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e8;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint ldist[210][210];\nint sdist[210][210];\nint dp[210], dp2[210];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n)\tldist[i][j] = sdist[i][j] = (i == j ? 0 : inf);\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L')\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\telse\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t}\n\t\trep(k, n)\trep(i, n)\trep(j, n) {\n\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tcin\t>> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, n)\tdp[i] = (i == z[0] ? 0 : inf);\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n)\tdp2[j] = dp[j] + ldist[z[i - 1]][z[i]];\n\t\t\trep(j, n)\trep(k, n) {\n\t\t\t\tdp2[j] = min(dp2[j], dp[k] + ldist[z[i - 1]][k] + sdist[k][j] + ldist[j][z[i]]);\n\t\t\t}\n\t\t\trep(j, n)\tdp[j] = dp2[j];\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\n#define INF 100000000\n\nstruct P {\n    int from, cost, i, boat;\n\n    bool operator >(const P& p) const {\n        return cost > p.cost;\n    }\n};\n\nstruct Edge {\n    int to, cost;\n    bool road;\n};\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N|M) {\n        vector<vector<Edge>> E(N);\n        REP(i, M) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;\n            y--;\n            E[x].push_back({y, t, sl=='L'});\n            E[y].push_back({x, t, sl=='L'});\n        }\n        int R;\n        cin >> R;\n        vi order(R);\n        REP(i, R) {\n            int z;\n            cin >> z;\n            z--;\n            order[i] = z;\n        }\n\n        vector<vvi> G(N, vvi(N, vi(R, INF)));\n\n        priority_queue<P, vector<P>, greater<P>> que;\n        que.push({order[0], 0, 1, order[0]});\n        while (!que.empty()) {\n            P p = que.top(); que.pop();\n            if (p.i == R) {\n                cout << p.cost << endl;\n                break;\n            }\n            for (Edge e : E[p.from]) {\n                bool ok = e.road || p.boat == p.from;\n                if (!ok) continue;\n                int cost = p.cost + e.cost;\n                int boat = e.road ? p.boat : e.to;\n                if (G[e.to][boat][p.i] > cost) {\n                    G[e.to][boat][p.i] = cost;\n                    int i = e.to == order[p.i] ? p.i+1 : p.i;\n                    que.push({e.to, cost, i, boat});\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstatic const int INF = 1000000;\nint distS[200][200], distL[200][200];\nint route[10000];\nint dp[10000][200];\n\nint main()\n{\n  int N, M;\n  while (cin >> N >> M && !(N == 0 && M == 0)) {\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        distS[i][j] = distL[i][j] = INF;\n      }\n      distS[i][i] = distL[i][i] = 0;\n    }\n\n    for (int i = 0; i < M; i++) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      x--;  y--;\n      if (sl == 'S') {\n        distS[x][y] = distS[y][x] = t;\n      } else {\n        distL[x][y] = distL[y][x] = t;\n      }\n    }\n\n    int R;\n    cin >> R;\n    for (int i = 0; i < R; i++) {\n      cin >> route[i];\n      route[i]--;\n    }\n\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          distS[i][j] = min(distS[i][j], distS[i][k] + distS[k][j]);\n          distL[i][j] = min(distL[i][j], distL[i][k] + distL[k][j]);\n        }\n      }\n    }\n\n    for (int j = 0; j < N; j++) {\n      dp[0][j] = distS[route[0]][j];\n    }\n    for (int i = 1; i < R; i++) {\n      for (int j = 0; j < N; j++) {\n        dp[i][j] = dp[i-1][j] + distL[route[i-1]][route[i]];\n        for (int k = 0; k < N; k++) {\n          dp[i][j] = min(dp[i][j], dp[i-1][k] + distL[route[i-1]][k] + distS[k][j] + distL[j][route[i]]);\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < N; i++) {\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint result[101][101][10001];\n\nint dijk(vector<vector<pair<int, pair<int, bool> > > > adjlist, vector<int>& z){\n  int n = adjlist.size();\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < z.size(); k++){\n        result[i][j][k] = INF;\n      }\n    }\n  }\n\n  \n  //vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<int, pair<int, int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int x, y, t;\n    string sl;\n    vector<vector<pair<int, pair<int, bool> > > > adjlist(n + 1);\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(adjlist, z);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int INF = 1000000000;\nstatic int land_mat[200][200];\nstatic int sea_mat[200][200];\n\nint main(){\n\tios_base::sync_with_stdio(false);;\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){ break; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tland_mat[i][j] = sea_mat[i][j] = INF;\n\t\t\t}\n\t\t\tland_mat[i][i] = sea_mat[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint a, b, c;\n\t\t\tstring t;\n\t\t\tcin >> a >> b >> c >> t;\n\t\t\t--a; --b;\n\t\t\tif(t[0] == 'S'){\n\t\t\t\tsea_mat[a][b] = min(sea_mat[a][b], c);\n\t\t\t\tsea_mat[b][a] = min(sea_mat[b][a], c);\n\t\t\t}else{\n\t\t\t\tland_mat[a][b] = min(land_mat[a][b], c);\n\t\t\t\tland_mat[b][a] = min(land_mat[b][a], c);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tland_mat[i][j] = min(\n\t\t\t\t\t\tland_mat[i][j], land_mat[i][k] + land_mat[k][j]);\n\t\t\t\t\tsea_mat[i][j] = min(\n\t\t\t\t\t\tsea_mat[i][j], sea_mat[i][k] + sea_mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\tint answer = 0;\n\t\tvector<int> cur(n, INF);\n\t\tcur[z[0]] = 0;\n\t\tfor(int i = 1; i < r; ++i){\n\t\t\tconst int u = z[i - 1], v = z[i];\n\t\t\tvector<int> from_dist(n, INF);\n\t\t\tvector<int> to_dist(n, INF);\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tfrom_dist[j] = land_mat[u][j];\n\t\t\t\tto_dist[j] = land_mat[j][v];\n\t\t\t}\n\t\t\tvector<int> next(n, INF);\n\t\t\tif(land_mat[u][v] < INF){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif(cur[j] >= INF){ continue; }\n\t\t\t\t\tnext[j] = cur[j] + land_mat[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(cur[j] >= INF){ continue; }\n\t\t\t\tif(from_dist[j] >= INF){ continue; }\n\t\t\t\tfor(int k = 0; k < n; ++k){\n\t\t\t\t\tif(to_dist[k] >= INF){ continue; }\n\t\t\t\t\tconst int sea_dist = sea_mat[j][k];\n\t\t\t\t\tif(sea_dist >= INF){ continue; }\n\t\t\t\t\tnext[k] = min(next[k], cur[j] + from_dist[j] + to_dist[k] + sea_dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.swap(next);\n\t\t}\n\t\tcout << *min_element(cur.begin(), cur.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint d1[205][205],d2[205][205];\nint d[205][205];\nint v[205];\nint M=1061109567;\nint main()\n{\n\tint n,m,p;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(n&&m){\n\tmemset(d1,0x3f,sizeof d1);\n\tmemset(d2,0x3f,sizeof d2);\n\tmemset(d,0x3f,sizeof d);\n\tfor(int i=1;i<=n;i++)\n\t\td1[i][i]=d2[i][i]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b,d;\n\t\tchar c;\n\t\tscanf(\"%d%d%d %c\",&a,&b,&d,&c);\n\t\tif(c=='L'){\n\t\t\td1[a][b]=min(d1[a][b],d);\n\t\t\td1[b][a]=min(d1[b][a],d);\n\t\t}\n\t\telse{\n\t\t\td2[a][b]=min(d2[a][b],d);\n\t\t\td2[b][a]=min(d2[b][a],d);\n\t\t}\n\t}\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(d1[i][k]!=M&&d1[k][j]!=M&&d1[i][k]+d1[k][j]<d1[i][j])\n\t\t\t\t\td1[i][j]=d1[i][k]+d1[k][j];\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(d2[i][k]!=M&&d2[k][j]!=M&&d2[i][k]+d2[k][j]<d2[i][j])\n\t\t\t\t\td2[i][j]=d2[i][k]+d2[k][j];\n\tscanf(\"%d\",&p);\n\tfor(int i=1;i<=p;i++)\n\t\tscanf(\"%d\",&v[i]);\n\tv[0]=1;\n\td[0][1]=0;\n\tfor(int i=1;i<=p;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t//printf(\"%d %d %d %d %d\\n\",d[i-1][j],d1[v[i-1]][j],d2[j][k],d1[k][v[i]],d[i][k]);\n\t\t\t\tif(d[i-1][j]!=M&&d1[v[i-1]][j]!=M&&d2[j][k]!=M&&d1[k][v[i]]!=M&&d[i-1][j]+d1[v[i-1]][j]+d2[j][k]+d1[k][v[i]]<d[i][k])\n\t\t\t\t\td[i][k]=d[i-1][j]+d1[v[i-1]][j]+d2[j][k]+d1[k][v[i]];\n\t\t\t}\n\t}\n\tint ans=M;\n\tfor(int j=1;j<=n;j++)\n\t\tans=min(d[p][j],ans);\n\tprintf(\"%d\\n\",ans);\n\tscanf(\"%d%d\",&n,&m);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        const ll inf = ten(14);\n        ll l[256][256], s[256][256];\n        rep(i, n) rep(j, n)\n            l[i][j] = s[i][j] = i == j ? 0 : inf;\n        while (m--)\n        {\n            int x, y;\n            ll t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if (sl == 'L')\n                l[x][y] = l[y][x] = min(l[x][y], t);\n            else\n                s[x][y] = s[y][x] = min(s[x][y], t);\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(l[i][j], l[i][k] + l[k][j]);\n            chmin(s[i][j], s[i][k] + s[k][j]);\n        }\n\n        int r, z[1024];\n        cin >> r;\n        input(z, r);\n        rep(i, r)\n            --z[i];\n\n        ll dp[1024][256];\n        rep(i, r) rep(j, n)\n            dp[i][j] = inf;\n        dp[0][z[0]] = 0;\n        rep(i, r - 1) rep(j, n) rep(k, n)\n            chmin(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n        ll res = *min_element(dp[r - 1], dp[r - 1] + n);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum\n{\n    MAX_V = 300 + 10, MAX_Z = 2000 + 50\n};\n\nconst long long INF = 1000000000000;\nlong long dp[MAX_Z][MAX_V];\nlong long SG[MAX_V][MAX_V], LG[MAX_V][MAX_V];\nint rt[MAX_Z], rtl;\nint n, m;\n\nvoid floyd()\n{\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = min(SG[i][j], SG[i][k] + SG[k][j]);\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                LG[i][j] = min(LG[i][j], LG[i][k] + LG[k][j]);\n    for(int i = 1; i <= n; i++)\n        LG[i][i] = SG[i][i] = 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n+m)\n    {\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = LG[i][j] = INF;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y;\n            long long cs;\n            char tp;\n            scanf(\"%d %d %lld %c\", &x, &y, &cs, &tp);\n            if(tp == 'S')\n            {\n                SG[x][y] = min(SG[x][y], cs);\n                SG[y][x] = min(SG[y][x], cs);\n            }\n            else\n            {\n                LG[x][y] = min(LG[x][y], cs);\n                LG[y][x] = min(LG[y][x], cs);\n            }\n        }\n        scanf(\"%d\", &rtl);\n        for(int i = 1; i <= rtl; i++)\n            scanf(\"%d\", &rt[i]);\n\n        floyd();\n        for(int i = 1; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                dp[i][j] = INF;\n\n        dp[1][rt[1]] = 0;\n        for(int i = 2; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                for(int k = 1; k <= n; k++)\n                {\n                    if(j != k)\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[k][rt[i - 1]] + SG[k][j] + LG[j][rt[i]]);\n                    else\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[rt[i-1]][rt[i]]);\n                }\n\n        long long ans = *min_element(dp[rtl] + 1, dp[rtl] + n + 1);\n        if(ans == INF);\n        else printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\ntypedef long long  ll;\n\nconst ll inf=1LL<<53;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint n,m;\n\nll lcost[210][210];\nll scost[210][210];\nll dp[1010][210];\n\nint r;\nint z[1010];\n\nint main(void){\n\t\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,210)rep(j,210) lcost[i][j]=scost[i][j]=((i==j)?0:inf);\n\n\t\trep(i,m){\n\t\t\tll x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;y--;\n\t\t\tif(sl=='S'){\n\t\t\t\tscost[x][y]=min(scost[x][y],t);\n\t\t\t\tscost[y][x]=min(scost[y][x],t);\n\t\t\t}else{\n\t\t\t\tlcost[x][y]=min(lcost[x][y],t);\n\t\t\t\tlcost[y][x]=min(lcost[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tcin >> r;\n\t\trep(i,r){cin >> z[i];z[i]--;}\n\n\t\trep(k,n)rep(i,n)rep(j,n) scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n) lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n\n\t\trep(i,1010)rep(j,210) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n)rep(k,n) dp[i+1][k]=min(dp[i+1][k],dp[i][j]+lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]]);\n\t\tll ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl; \n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL<<60;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N) {\n        vector<vector<long long> > dps(N, vector<long long>(N, INF)), dpl(N, vector<long long>(N, INF));\n        for (int v = 0; v < N; ++v) dps[v][v] = dpl[v][v] = 0;\n        for (int e = 0; e < M; ++e) {\n            int x, y;\n            long long w;\n            char type;\n            cin >> x >> y >> w >> type;\n            --x, --y;\n            if (type == 'L') chmin(dpl[x][y], w), chmin(dpl[y][x], w);\n            else chmin(dps[x][y], w), chmin(dps[y][x], w);\n        }\n        for (int k = 0; k < N; ++k) {\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    dpl[i][j] = min(dpl[i][j], dpl[i][k] + dpl[k][j]);\n                    dps[i][j] = min(dps[i][j], dps[i][k] + dps[k][j]);\n                }\n            }\n        }\n        \n        int R; cin >> R;\n        vector<int> v(R);\n        for (int i = 0; i < R; ++i) cin >> v[i], --v[i];\n        \n        vector<vector<long long> > dp(R, vector<long long>(N, INF));\n        dp[0][v[0]] = 0;\n        for (int i = 0; i < R-1; ++i) {\n            for (int j = 0; j < N; ++j) {\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + dpl[v[i]][v[i+1]]);\n                for (int k = 0; k < N; ++k) {\n                    dp[i+1][k] = min(dp[i+1][k], dp[i][j] + dpl[v[i]][j] + dps[j][k] + dpl[k][v[i+1]]);\n                }\n            }\n        }\n        long long res = INF;\n        for (int i = 0; i < N; ++i) {\n            res = min(res, dp[R-1][i]);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//{??????(???)?????????(???)?????????(???)??????, ??????(???)??????}??¨???????§?????????°?????????????????£?????????.\n//??????????§??????????????????¶????????????????????????(????????????????????°, ????????´???)???????????§???????????§DP?????§????????????\n//?§?????????????????????¶???????????????O(N)?????????????????????O(N^3)???????¨??????§???????§?O(1)?????§???????????§???O(RN^2)???DP????????£????????????????????????\n#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nvoid chmin(int &a, int b) {\n\ta = min(a, b);\n}\n\nint INF = 1145141919;\nint n, m;\nint cost[2][200][200];\nint r;\nint z[1000];\nint dp[1000][200];\n\nvoid initCost() {\n\tint i, j, k;\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < n; j++) for (k = 0; k < n; k++) cost[i][j][k] = INF;\n\t\tfor (j = 0; j < n; j++) cost[i][j][j] = 0;\n\t}\n}\n\nvoid initDp() {\n\tint i, j;\n\tfor (i = 0; i < r; i++) for (j = 0; j < n; j++) dp[i][j] = INF;\n}\n\nsigned main() {\n\tint i, j, k, l;\n\t\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\tinitCost();\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tint s, d, c; char type;\n\t\t\tcin >> s >> d >> c >> type;\n\t\t\ts--; d--;\n\t\t\tif (type == 'L') {\n\t\t\t\tcost[0][s][d] = c;\n\t\t\t\tcost[0][d][s] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcost[1][s][d] = c;\n\t\t\t\tcost[1][d][s] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> r;\n\t\tfor (i = 0; i < r; i++) { cin >> z[i]; z[i]--; }\n\t\t\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\t\t\tchmin(cost[i][j][k], cost[i][j][l] + cost[i][l][k]);\n\t\t\n\t\tinitDp();\n\t\tdp[0][0] = 0;\n\t\tfor (i = 0; i < r - 1; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t//???z[i]???(???)???z[i+1]\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + cost[0][z[i]][z[i + 1]]);\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t//???z[i]???j???(???)???k???z[i+1]\n\t\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost[0][z[i]][j] + cost[1][j][k] + cost[0][k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (i = 0; i < n; i++) chmin(ans, dp[r - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nstatic int N, M, R;\n\n\n\nstatic int dist_l[201][201];\nstatic int dist_s[201][201];\n\nstatic int dest[1001];\n\n\n\nstatic void flood()\n{\n\tint i, j, k;\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n\n\nstatic void solve()\n{\n\tflood();\n\n\tint s_start[201];\n\tint s_end[201];\n\n\tint i, j;\n\n\tfor (i=1; i<=N; i++)\n\t\ts_start[i] = INT_MAX;\n\ts_start[1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_end[j] = INT_MAX;\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (s_start[j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (s_end[j] > s_start[j]+total_land_cost)\n\t\t\t\t\t\ts_end[j] = s_start[j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (s_end[k] > c1+c2+c3+s_start[j]) {\n\t\t\t\t\t\ts_end[k] = c1+c2+c3+s_start[j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_start[j] = s_end[j];\n/*\n\t\tprintf(\"start=%d, end=%d\\n\", start, end);\n\t\tprintf(\"s_end[]= \");\n\t\tfor (j=1; j<=N; j++)\n\t\t\tprintf(\"%d \", s_end[j]);\n\t\tprintf(\"\\n\");\n*/\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > s_start[i])\n\t\t\tmin = s_start[i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tdist_l[i][i] = dist_s[i][i] = 0;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tif (dist_s[x][y] > t)\n\t\t\t\t\tdist_s[x][y] = dist_s[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_l[x][y] > t)\n\t\t\t\t\tdist_l[x][y] = dist_l[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<unsigned char,unsigned char,short> tpl;\n    //static int dist[200][200][1001];\n    //fill_n((int*)dist,200*200*1001,inf);\n    map<tpl,ll> dist;\n    priority_queue<pair<ll,tpl>,vector<pair<ll,tpl>>,greater<pair<ll,tpl>>> que;\n    //dist[z[0]][z[0]][1]=true;\n    dist[make_tuple(z[0],z[0],1)]=0;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        ll d=t.first;\n        int p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        //if(d>dist[p1][p2][num]) continue;\n        if(d>dist[t.second]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n\n        if(p1==z[num]){\n            auto t_=make_tuple(p1,p2,num+1);\n            ll tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d>=tmp) continue;\n            dist[t_]=d;\n            que.push(make_pair(d,t_));\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first;\n            ll d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p2,num_);\n            ll tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            //if(d_>=dist[p_][p2][num_]) continue;\n            if(d_>=tmp) continue;\n            //dist[p_][p2][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first;\n            ll d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p_,num_);\n            ll tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d_>=tmp) continue;\n            //dist[p_][p_][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n \nstruct edge{\n    int t,c;\n    edge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[200][200][2];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n \nint dijk(){\n    for(int i=0;i<r-1;i++){\n    \tpriority_queue<PP,vector<PP>,greater<PP> > que;\n    \tif(i==0)que.push(PP(0,P(rt[i],rt[i])));\n    \telse{\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tque.push(PP(cost[rt[i]][j][1],P(rt[i],j)));\n    \t\t}\n    \t}\n    \tfor(int j=0;j<n;j++){\n    \t\tfor(int k=0;k<n;k++){\n    \t\t\tcost[j][k][0]=cost[j][k][1]=INF;\n    \t\t}\n    \t}\n    \twhile(que.size()){\n    \t\tPP p=que.top();\n    \t\tque.pop();\n    \t\tint c=p.first,v=p.second.first,sh=p.second.second;\n    \t\tif(c>=INF)continue;\n    \t\tif(c>cost[v][sh][0])continue;\n    \t\tif(v==rt[i+1])cost[v][sh][1]=c;\n    \t\tif(i==r-2 && v==rt[i+1])return c;\n    \t\tfor(int i=0;i<l[v].size();i++){\n    \t\t\tedge e=l[v][i];\n    \t\t\tif(c+e.c<cost[e.t][sh][0]){\n    \t\t\t\tcost[e.t][sh][0]=c+e.c;\n    \t\t\t\tque.push(PP(c+e.c,P(e.t,sh)));\n    \t\t\t}\n    \t\t}\n    \t\tif(sh==v)for(int i=0;i<s[v].size();i++){\n    \t\t\tedge e=s[v][i];\n    \t\t\tif(c+e.c<cost[e.t][e.t][0]){\n    \t\t\t\tcost[e.t][e.t][0]=c+e.c;\n    \t\t\t\tque.push(PP(c+e.c,P(e.t,e.t)));\n    \t\t\t}\n    \t\t}\n    \t}\n    }\n}\n \nint main(void){\n    while(1){\n        for(int i=0;i<200;i++){\n            l[i].clear();\n            s[i].clear();\n        }\n        cin >> n >> m;\n        if(n==0 && m==0)break;\n        for(int i=0;i<m;i++){\n            int a,b,ti;\n            string ls;\n            cin >> a >> b >> ti >> ls;\n            if(ls==\"L\"){\n                l[a-1].push_back(edge(b-1,ti));\n                l[b-1].push_back(edge(a-1,ti));\n            }\n            if(ls==\"S\"){\n                s[a-1].push_back(edge(b-1,ti));\n                s[b-1].push_back(edge(a-1,ti));\n            }\n        }\n        cin >> r;\n        for(int i=0;i<r;i++){\n            cin >> rt[i];\n            rt[i]--;\n        }\n        cout << dijk() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAOJ 2200 Mr. Rito Post Office\n\n????????°???????????????????????????ACM-ICPC Japan??????????????????????¨?????????????????????????\n?????????????\\?????????????????????°??????????????¨?????????????????????????°´????????±??????????????°?°´\n??????????????¨????????¨X????????????????°±?????¨X????????????????????????????????????????¬??????°?°´???\n??????????????°X?????????????????????????????´?????????????????\\???????°´????????±?????????????????????\n?????§???????????????????????????????????????????????????????????¶?????????????????????????????????????¬?\n??§???????????????ABCB??????B????????????????????°????¬?????????????\n\n????????°???????????????\nN M\nx1 y1 t1 sl1\nx2 y2 t2 sl2\n???\nxM yM tM slM\nR\nz1 z2 ??? zR\n\nN (2 ??? N ??? 200) ??????????????°??????M (1 ??? M ??? 10000) ?????±???????°´????????????\n??°??????????¬¬2?????°?¬¬M + 1????????????????????°??????????????\\xi yi?????°???????????±?´? ti\n(1 ??? ti ??? 1000)??¶??´???sli ???L??¶??¨????????±??????S??¶??¨???????°´?????????????????????\n?????\\??????????????\\?????????????????¶???????????????????????????\n\nM + 2??????R????????????????????????????????°??????M + 3???????????????????????????????????????\n\n????§???¶????????????????????¨?¬¬??????????????????????????????????????°?????????????????????\n\n????????°??????0 0?????¶?????¨????????¢???\n\n */\n#include <assert.h>\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define SZ(a) (int)(a).size()\n#define FOR(i,a,b) for (int i=(a); i<=(b); ++i)\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define ALL(c) c.begin(), c.end()\n#define CLR(c,n) memset(c, n, sizeof(c))\n#define TR(it, c) for(typeof(c.begin()) it = c.begin();it != c.end(); ++it)\n#define CONTAIN(it, c) (c.find(it) != c.end())\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntemplate <class T> void checkmin(T &a, T b) { if (b<a) a=b; }\ntemplate <class T> void checkmax(T &a, T b) { if (b>a) a=b; }\nconst int INF = 0x1F1F1F1F;\n\nconst int N = 200;\n\nint distL[N][N], distS[N][N];\nint dp[2][N];\nint n, m;\n\nint main(int argc, char *argv[]) {\n  int x, y, t;\n  char sl;\n  while (scanf(\"%d %d\", &n, &m) == 2 && n + m > 0) {\n    CLR(distL, INF);\n    CLR(distS, INF);\n    REP(i, n) distL[i][i] = distS[i][i] = 0;\n    while (m--) {\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      --x;\n      --y;\n      switch (sl) {\n        case 'L':\n          checkmin(distL[x][y], t);\n          checkmin(distL[y][x], t);\n          break;\n        case 'S':\n          checkmin(distS[x][y], t);\n          checkmin(distS[y][x], t);\n          break;\n      }\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      checkmin(distL[i][j], distL[i][k] + distL[k][j]);\n      checkmin(distS[i][j], distS[i][k] + distS[k][j]);\n    }\n    int current = 0, prev = 1, src=0, dst=0;\n    CLR(dp, INF);\n    scanf(\"%d\", &m);\n    scanf(\"%d\", &dst);\n    dp[current][--dst] = 0;\n    while (--m) {\n      src = dst;\n      scanf(\"%d\", &dst);\n      --dst;\n      swap(current, prev);\n      CLR(dp[current], INF);\n      REP(i, n) {\n\tif (dp[prev][i] == INF) continue;\n\tif (distL[src][dst] != INF)\n\t  checkmin(dp[current][i], dp[prev][i] + distL[src][dst]);\n\tif (distL[src][i] == INF) continue;\n\tREP(j, n) {\n\t  if (distL[src][i] != INF && distS[i][j] != INF && distL[j][dst] != INF) {\n\t    checkmin(dp[current][j], dp[prev][i] + distL[src][i] + distS[i][j] + distL[j][dst]);\n\t  }\n\t}\n      }\n      //cerr << \"NEXT=\" << dst + 1 << \" \";\n      //int bestIdx = min_element(dp[current], dp[current] + n) - dp[current];\n      //cerr << \" BEST=\" << bestIdx + 1 << \" VAL=\" << dp[current][bestIdx] << endl;\n    }\n    printf(\"%d\\n\", *min_element(dp[current], dp[current] + n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n  \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n  \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n  \nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n  \nint main(){\n    while(1){\n        int n,m;\n        static LL ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static LL sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)break;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static LL dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tLL ret=INF;\n    \trep1(i,n){\n    \t\tret=min(ret,dp[r-1][i]);\n    \t}\n          \n        printf(\"%I64d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_N];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A2, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\nconst int inf=(int)1e9;\nconst double PI=acos(-1.0);\n \n \n \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int ldp[201][201];\n        int sdp[201][201];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                ldp[i][j]=inf;\n                sdp[i][j]=inf;\n            }\n        }\n        for(int i=0;i<n;i++){\n            ldp[i][i]=0;\n            sdp[i][i]=0;\n        }\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L'){\n                ldp[a][b]=c;\n                ldp[b][a]=c;\n            }else{\n                sdp[a][b]=c;\n                sdp[b][a]=c;\n            }\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    ldp[i][j]=min(ldp[i][k]+ldp[k][j],ldp[i][j]);\n                    sdp[i][j]=min(sdp[i][k]+sdp[k][j],sdp[i][j]);\n                }\n            }\n        }\n        int r;cin>>r;\n        int a[1001];\n        for(int i=0;i<r;i++){\n            cin>>a[i];\n            a[i]--;\n        }\n        int dp[1001][201];\n        for(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n        dp[0][a[0]]=0;\n        for(int i=0;i<r-1;i++){\n            for(int j=0;j<n;j++){\n                if(dp[i][j]==inf)continue;\n                for(int k=0;k<n;k++){\n                    dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][j]+sdp[j][k]+ldp[k][a[i+1]]);\n                    if(j==k)dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][a[i+1]]);\n                }\n            }\n        }\n        /*for(int i=0;i<r;i++){\n            for(int j=0;j<n;j++){\n                cerr<<dp[i][j]<<\" \";\n            }\n            cerr<<\"\\n\";\n        }*/\n        int ans=inf;\n        for(int i=0;i<n;i++){\n            ans=min(ans,dp[r-1][i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           if(j!=k) dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tint d, z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nint dp[1005][205][205];\t\t// z, boat, n\n\nint solve(){\n\tpriority_queue<ST> que;\n\tdp[0][ Z[0] ][ Z[0] ] = 0;\n\trep(i,R){\n\t\trep(b,N) rep(n,N) if( dp[i][b][n] < INF ){\n\t\t\tque.push( ST{dp[i][b][n], i, b, n} );\n\t\t}\n\t\twhile( !que.empty() ){\n\t\t\tint d = que.top().d;\n\t\t\tint z = que.top().z;\n\t\t\tint b = que.top().b;\n\t\t\tint n = que.top().n;\n\t\t\tque.pop();\n\t\t\tif( dp[z][b][n] < d || z+1 >= R ) continue;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\t\tint to = _v.first;\n\t\t\t\t\tint cost = _v.second;\n\t\t\t\t\tint nz = z, nb = b;\n\t\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\t\tif( k ) nb = to;\n\t\t\t\t\tif( chmin( dp[nz][nb][to], dp[z][b][n] + cost) ){\n\t\t\t\t\t\tif( nz == z )\n\t\t\t\t\t\t\tque.push( ST{ dp[nz][nb][to], nz, nb, to } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(b,N) rep(n,N){\n\t\tchmin( ans, dp[R-1][b][n] );\n\t}\n\treturn ans;\n}\n\nint main(){\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\trep(i,M){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\nstruct node{\n    int index,boat,next,cost;\n    node(int index,int boat,int next,int cost):index(index),boat(boat),next(next),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nstruct edge{\n\tint lcost,scost;\n\tedge(int lcost,int scost):lcost(lcost),scost(scost){}\n\tedge(){}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\n\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\ntypedef vector<vvi> vvvi;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tstatic edge graph[200][200];\n\t\tREP(i,n)REP(j,n){\n\t\t\tif(i==j){\n\t\t\t\tgraph[i][j]=edge(0,0);\n\t\t\t}else{\n\t\t\t\tgraph[i][j]=edge(MAX,MAX);\n\t\t\t}\n\t\t}\n        REP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tswitch(sl){\n\t\t\tcase 'S':\n\t\t\t\tgraph[x-1][y-1].scost=min(graph[x-1][y-1].scost,t);\n\t\t\t\tgraph[y-1][x-1].scost=min(graph[y-1][x-1].scost,t);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tgraph[x-1][y-1].lcost=min(graph[x-1][y-1].lcost,t);\n\t\t\t\tgraph[y-1][x-1].lcost=min(graph[y-1][x-1].lcost,t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n        }\n\t\tint r;\n\t\tcin>>r;\n\t\tvi order(r);\n\t\tREP(i,r){\n\t\t\tcin>>order[i];\n\t\t\torder[i]--;\n\t\t}\n\t\tREP(k,n)REP(i,n)REP(j,n){\n\t\t\tgraph[i][j].lcost=min(graph[i][j].lcost,graph[i][k].lcost+graph[k][j].lcost);\n\t\t\tgraph[i][j].scost=min(graph[i][j].scost,graph[i][k].scost+graph[k][j].scost);\n\t\t}\n\n\t\tstatic int dp[1001][200];\n\t\tREP(i,r+1){\n\t\t\tREP(j,n){\n\t\t\t\tdp[i][j]=MAX;\n\t\t\t}\n\t\t}\n\t\tfor(int post=-1;post<r-1;post++){\n\t\t\tREP(boat,n){\n\t\t\t\tif(post==-1){\n\t\t\t\t\tdp[post+1][boat]=graph[order[0]][boat].scost;\n\t\t\t\t}else{\n\t\t\t\t\tdp[post+1][boat]=min(dp[post+1][boat],dp[post][boat]+graph[order[post]][order[post+1]].lcost);\n\t\t\t\t\tREP(via,n){\n\t\t\t\t\t\tdp[post+1][boat]=min(dp[post+1][boat],dp[post][via]+graph[order[post]][via].lcost+graph[via][boat].scost+graph[boat][order[post+1]].lcost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n\t\tint ans=MAX;\n\t\tREP(i,n){\n\t\t\tans=min(ans,dp[r-1][i]);\n\t\t}\n        cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint dijk(vector<vector<pair<int, pair<int, bool> > > > adjlist, vector<int>& z){\n  int n = adjlist.size();\n  vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<int, pair<int, int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int x, y, t;\n    string sl;\n    vector<vector<pair<int, pair<int, bool> > > > adjlist(n + 1);\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(adjlist, z);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[50][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int j=0;j<200;j++){\n\t\tfor(int k=0;k<200;k++){\n\t\t\tcost[0][j][k]=INF;\n\t\t}\n\t}\n\tmemset(reset,false,sizeof(reset));\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(rt[0],rt[0]))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\treturn nc;\n\t\t}\n\t\tif(now==rt[np]){\n\t\t\tnp++;\n\t\t\tif(reset[np]==false){\n\t\t\t\tfor(int i=0;i<200;i++){\n\t\t\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\t\t\tcost[np%20][i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset[np]=true;\n\t\t\t}\n\t\t\tcost[np%20][now][ns]=nc;\n\t\t}\n\t\tif(cost[np%20][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np%20][e.t][ns]){\n\t\t\t\tcost[np%20][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np%20][e.t][e.t]){\n\t\t\t\t\tcost[np%20][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#define MAXN 220\n#define ll long long\nusing namespace std;\nint n,m,r;\nll mp[220][220][2],dis[220][220][2],dp[1010][220],inf;\nint id[1010];\n\nvoid pre(){\n\tmemset(dis,127/3,sizeof(dis));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) dis[i][j][0]=mp[i][j][0],dis[i][j][1]=mp[i][j][1];\n\tfor(int i=1;i<=n;i++) dis[i][i][0]=dis[i][i][1]=0;\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(i==j||j==k||k==i) continue;\n\t\t\t\tdis[i][j][0]=min(dis[i][j][0],dis[i][k][0]+dis[k][j][0]);\n\t\t\t\tdis[i][j][1]=min(dis[i][j][1],dis[i][k][1]+dis[k][j][1]);\n\t\t\t}\n}\n\nvoid DP(){\n\tmemset(dp,127/3,sizeof(dp));inf=dp[0][0];\n\tdp[0][1]=0;\n\tfor(int i=1;i<=r;i++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tint x=id[i-1],y=id[i];\n\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][k]+dis[x][y][0]);\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(dp[i-1][j]==inf) continue;\n\t\t\t\tif(x==y) dp[i][k]=dp[i-1][k];\n\t\t\t\telse dp[i][k]=min(dp[i][k],dp[i-1][j]+dis[x][j][0]+dis[j][k][1]+dis[k][y][0]);\n\t\t\t\t//if(j==k) dp[i][k]=min(dp[i][k],dp[i-1][j]+dis[x][y][0]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tmemset(mp,127/3,sizeof(mp));\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(!n&&!m) break;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y,z;char c;\n\t\t\tscanf(\"%d%d%d%c%c\",&x,&y,&z,&c,&c);\n\t\t\tif(c=='L') mp[x][y][0]=min(mp[x][y][0],(ll)z),mp[y][x][0]=min(mp[y][x][0],(ll)z);\n\t\t\telse mp[x][y][1]=min(mp[x][y][1],(ll)z),mp[y][x][1]=min(mp[y][x][1],(ll)z);\n\t\t}\n\t\tpre();\n\t\tscanf(\"%d\",&r);\n\t\tmemset(id,0,sizeof(id));\n\t\tid[0]=1;\n\t\tfor(int i=1;i<=r;i++) scanf(\"%d\",&id[i]);\n\t\tDP();\n\t\tll ans=inf;\n\t\tfor(int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nconst int INF = 0xfffffff;\n\nvoid warshall_floyd(vector<vector<int> >& d) {\n\tint v = d.size();\n\tfor(int i = 0; i < v; ++i)\n\t\tfor(int j = 0; j < v; ++j)\n\t\t\tfor(int k = 0; k < v; ++k)\n\t\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tfor(int n, m; cin >> n >> m, n | m;) {\n\t\tvector<vector<int> > riku(n, vector<int>(n, INF));\n\t\tvector<vector<int> > umi(n, vector<int>(n, INF));\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\triku[i][i] = umi[i][i] = 0;\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\t\n\t\t\tif(sl == 'S')\n\t\t\t\tumi[x][y] = umi[y][x] = min(umi[y][x], t);\n\t\t\telse\n\t\t\t\triku[x][y] = riku[y][x] = min(riku[y][x], t);\n\t\t}\n\t\t\n\n\t\twarshall_floyd(riku);\n\t\twarshall_floyd(umi);\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\t\n\t\tvector<int> z(r);\n\t\tfor(int i = 0; i < r; ++i) {\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\n\t\tvector<vector<int> > dp(r, vector<int>(n, INF));\n\t\tdp[0][z[0]] = 0;\n\n\t\tfor(int i = 0; i < r - 1; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + riku[z[i]][z[i + 1]]);\n\t\t\t\tfor(int k = 0; k < n; ++k) {\n\t\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + riku[z[i]][j] + umi[j][k] + riku[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *min_element(dp[r - 1].begin(), dp[r - 1].end()) << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long int LL;\nconst LL INF = 1LL << 55;\n\nvector<vector<LL>> sea, land;\nvector<int> z;\nint n, m, r;\nvector<vector<LL>> dp;\n\nLL dfs(int cur, int ship) {\n    LL ret = dp[cur][ship];\n    if (ret >= 0) return ret;\n    if (cur == r - 1) return 0;\n    ret = land[z[cur]][z[cur + 1]] + dfs(cur + 1, ship);\n    for (int i = 0; i < n; i++) {\n        LL tmp = land[z[cur]][ship] + sea[ship][i] + land[i][z[cur + 1]];\n        if (tmp >= INF) continue;\n        tmp += dfs(cur + 1, i);\n        ret = min(ret, tmp);\n    }\n    dp[cur][ship] = ret;\n    return ret;\n}\n\nint main() {\n    while (cin >> n >> m, n | m) {\n        sea.clear(); land.clear(); z.clear(); dp.clear();\n        sea.resize(n, vector<LL>(n, INF));\n        land.resize(n, vector<LL>(n, INF));\n\n        for (int i = 0; i < n; i++) {\n            sea[i][i] = land[i][i] = 0;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int tx, ty, tt;\n            char tsl;\n            cin >> tx >> ty >> tt >> tsl;\n            tx--; ty--;\n            if (tsl == 'L') {\n                land[tx][ty] = tt;\n                land[ty][tx] = tt;\n            } else {\n                sea[tx][ty] = tt;\n                sea[ty][tx] = tt;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    land[j][k] = min(land[j][k], land[j][i] + land[i][k]);\n                    sea[j][k] = min(sea[j][k], sea[j][i] + sea[i][k]);\n                }\n            }\n        }\n\n        cin >> r;\n        z.resize(r);\n        for (int i = 0; i < r; i++) {\n            int tz;\n            cin >> tz;\n            z[i] = tz - 1;\n        }\n        dp.resize(r, vector<LL>(n, -1));\n        cout << dfs(0, z[0]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\nconst LL INF = (LL)1e9 + 7;\nint main(){\n\twhile (1){\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N + M == 0)return 0;\n\t\tVVLL umi(N + 1, VLL(N + 1, INF)), riku(N + 1, VLL(N + 1, INF));\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\tumi[i][i] = riku[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tLL x, y, t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tif (c == 'L')riku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\telse umi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t}\n\t\tfor (int k = 1; k < N + 1; k++)for (int i = 1; i < N + 1; i++)for (int j = 1; j < N + 1; j++){\n\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\tumi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tVLL pos(R + 1);\n\t\tfor (int i = 1; i < R+1; i++){\n\t\t\tcin >> pos[i];\n\t\t}\n\t\tVVLL dp(R + 1, VLL(N + 1, INF));\n\t\tdp[1][1] = 0;\n\t\tfor (int i = 2; i < R+1; i++){\n\t\t\tfor (int x = 1; x < N+1; x++){\n\t\t\t\tdp[i][x] = dp[i - 1][x] + riku[pos[i - 1]][pos[i]];\n\t\t\t\tfor (int y = 1; y < N+1; y++){\n\t\t\t\t\tdp[i][x] = min(dp[i][x],dp[i-1][y] + riku[pos[i-1]][y] + umi[y][x] + riku[x][pos[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 1; i < N + 1; i++)\n\t\t\tres = min(dp[R][i], res);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include    <iostream>\n#include    <cstdio>\n#include    <cstdlib>\n#include    <algorithm>\n#include    <vector>\n#include    <cstring>\n#include    <queue>\n#include    <complex>\n#include    <stack>\n#define LL long long\n#define dob double\nusing namespace std;\n\nconst int N = 210;\nconst int R = 1010;\nconst int Inf = 1<<28;\nint n,m,Q,land[N][N],sea[N][N],f[R][N],Cit[R],Ans;\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n  return x*res;\n}\n\nmain()\n{\n  /*freopen(\"Mr._Rito_Post_Office .in\",\"r\",stdin);\n    freopen(\"Mr._Rito_Post_Office .out\",\"w\",stdout);*/\n  while(1){\n    n=gi();m=gi();\n    if(n+m==0)break;\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)\n        land[i][j]=sea[i][j]=Inf;\n    for(int i=1;i<=n;++i)\n      land[i][i]=sea[i][i]=0;\n    for(int i=1;i<=m;++i){\n      int u,v,c;char type;\n      scanf(\"%d%d%d %c\",&u,&v,&c,&type);\n      if(type=='L')\n        land[u][v]=land[v][u]=min(land[u][v],c);\n      else sea[u][v]=sea[v][u]=min(sea[u][v],c);\n    }\n    for(int k=1;k<=n;++k)\n      for(int i=1;i<=n;++i)\n        for(int j=1;j<=n;++j){\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n        }\n    Q=gi();\n    for(int i=0;i<=Q;++i)\n      for(int j=0;j<=n;++j)\n        f[i][j]=Inf;Ans=Inf;\n    for(int i=1;i<=Q;++i)Cit[i]=gi();\n    f[1][Cit[1]]=0;\n    for(int i=2;i<=Q;++i)\n      for(int j=1;j<=n;++j){\n        f[i][j]=min(f[i][j],f[i-1][j]+land[Cit[i-1]][Cit[i]]);\n        for(int k=1;k<=n;++k)\n          f[i][j]=min(f[i][j],f[i-1][k]+land[Cit[i-1]][k]+sea[j][k]+land[j][Cit[i]]);\n      }\n    for(int i=1;i<=n;++i)\n      Ans=min(Ans,f[Q][i]);\n    printf(\"%d\\n\",Ans);\n  }\n  \n  /*fclose(stdin);\n    fclose(stdout);*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 10001;\n\nint a[1001];\nint s[201][201], l[201][201], dp[1001][201];\nint n, m, q;\n\nvoid init() {\n    for(int k = 1; k <= n; k ++) {\n        for(int i = 1; i <= n; i ++) {\n            for(int j = 1; j <= n; j ++) {\n                s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n                l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    memset(dp, INF, sizeof(dp));\n    dp[0][1] = 0, a[0] = 1;\n    for(int i = 1; i <= q; i ++) {\n        for(int j = 1; j <= n; j ++) {\n            for(int k = 1; k <= n; k ++) {\n                if(dp[i-1][k] == INF || l[a[i-1]][k] == INF || s[k][j] == INF || l[j][a[i]] == INF) continue;\n                dp[i][j] = min(dp[i][j], dp[i-1][k] + l[a[i-1]][k] + s[k][j] + l[j][a[i]]);\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 1; i <= n; i ++) \n        ans = min(ans, dp[q][i]);\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    while(scanf(\"%d%d\", &n, &m) != EOF && (n+m)) {\n        memset(s, INF, sizeof(s));\n        memset(l, INF, sizeof(l));\n        for(int i = 1; i <= n; i ++) \n            s[i][i] = 0, l[i][i] = 0;\n        while(m --) {\n            int u, v, w; \n            char o[2];\n            scanf(\"%d%d%d%s\", &u, &v, &w, o);\n            if(o[0] == 'L' && w < l[u][v]) l[u][v] = w, l[v][u] = w;\n            if(o[0] == 'S' && w < s[u][v]) s[u][v] = w, s[v][u] = w;\n        }   scanf(\"%d\", &q);\n        for(int i = 1; i <= q; i ++) {\n            scanf(\"%d\", &a[i]);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mem(a) memset(a,2,sizeof(a))\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int mn=205;\n\nint n,m,r;\nint l[mn][mn];\nint s[mn][mn];//sea\nint c[mn];\nll d[1005][mn];\n\nll dp(int k,int t){\n    if (k==r) return 0;\n    ll &ans=d[k][t];\n    if (ans) return ans;\n    ans=1e18;\n    for(int i=1;i<=n;i++){//next boat position\n\n\t\tif (s[i][t]>1e7) continue;\n\t\tif (l[c[k]][t]>1e7||l[i][c[k+1]]>1e7) continue;\n        ll u=0ll+l[c[k]][t]+l[i][c[k+1]]+s[i][t]+dp(k+1,i);\n        //printf(\"%d %d %d %lld\\n\",k,t,i,u);\n        ans=min(u,ans);\n    }\n    //printf(\"%d %d %lld\\n\",k,t,ans);\n    return ans;\n}\n\nchar S[6];\n\nint main() {\n\twhile(~scanf(\"%d%d\",&n,&m)&&n){\n        mem(l);mem(s);\n        for(int i=1;i<=n;i++) l[i][i]=s[i][i]=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u,v,w;\n\t\t\tscanf(\"%d%d%d%s\",&u,&v,&w,S);\n\t\t\tif (S[0]=='L') l[u][v]=l[v][u]=min(w,l[u][v]);\n\t\t\telse s[u][v]=s[v][u]=min(w,s[u][v]);\n\t\t}\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n                    l[i][j]=min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j]=min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tscanf(\"%d\",&c[i]);\n\t\t}\n\t\tmemset(d,0,sizeof d);\n\t\tprintf(\"%lld\\n\",dp(1,1));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>;\nstatic const long long INF = 1e18;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, m; \n    while (cin >> n >> m && n && m) {\n        vvll dl(n, vll(n, INF)), ds(n, vll(n, INF));\n        rep(i, n) dl[i][i] = ds[i][i] = 0;\n\n        rep(i, m) {\n            ll x, y, t; char sl; cin >> x >> y >> t >> sl; x--; y--;\n            (sl == 'L' ? dl : ds)[x][y] = (sl == 'L' ? dl : ds)[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n) \n            chmin(dl[i][j], dl[i][k]+dl[k][j]), chmin(ds[i][j], ds[i][k]+ds[k][j]);\n\n        ll r; cin >> r;\n        vll z(r); rep(i, r) { cin >> z[i]; z[i]--; } \n\n        // ??????j???????????????i?????????????????????????????????????????????\n        vvll dp(r+1, vll(n, INF));\n        dp[0][z[0]] = 0;\n        rep(i, r) rep(j, n) { // j?????????\n            if (dp[i][j] == INF) continue;\n            rep(k, n) { // k???j?????????????????????, k????????????z[i]?????????\n                if (ds[j][k] == INF) continue;\n                ll tmp = (dp[i][j]/*????????§????????£????????????*/ + \n                        dl[i?z[i-1]:z[0]][j]/*j?????????????????????*/ +\n                        ds[j][k]/*j??????k????§????*/ + \n                        dl[k][z[i]]/*k??????????????´???????§????*/);\n                chmin(dp[i+1][k], tmp);\n            }\n            if (dl[i?z[i-1]:z[0]][z[i]] != INF)\n                chmin(dp[i+1][j], \n                        dp[i][j]/*????????§????????£????????????*/ + \n                        dl[i?z[i-1]:z[0]][z[i]]/*????????´???????§????*/);\n        }\n\n        ll ret = INF;\n        rep(j, n) \n            chmin(ret, dp[r][j]);\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+1][NMAX+1];\n\tll sdp[NMAX+1][NMAX+1];\n\tll dp[NMAX+1][RMAX+1];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=t;\n\t\t\t\tldp[y][x]=t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=t;\n\t\t\t\tsdp[y][x]=t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tdp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<26\nusing namespace std;\n\nint n,m,r;\nint s[201][201],t[201][201],z[1001],dp[1001][201];\n\nvoid init(){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)s[i][j]=0;\n      else s[i][j]=inf;\n      if(i==j)t[i][j]=0;\n      else t[i][j]=inf;\n    }\n    for(int j=0;j<1001;j++)dp[i][j]=inf;\n  }\n}\n\nvoid wf(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n\tt[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int a,b,d;\n  char c;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>c;\n      a--;b--;\n      if(c=='L'){\n\tt[a][b]=min(d,t[a][b]);\n\tt[b][a]=min(d,t[b][a]);\n      }\n      else {\n\ts[a][b]=min(d,s[a][b]);\n\ts[b][a]=min(d,s[b][a]);\n      }\n    }\n    cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n      z[i]--;\n    }\n\n    wf();\n    int ans=inf;\n    for(int i=0;i<n;i++)dp[0][i]=s[z[0]][i];\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]+t[z[i-1]][k]+s[k][j]+t[z[i]][j]);\n\t  if(i==r-1)ans=min(ans,dp[i][j]);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < r; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[r-1], dp[r-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\n\nconst int N   = 200;\nconst ll inf =(1LL<<58);\n\nll land[N][N];\nll sea[N][N];\n\nvoid wf(int n,ll mat[N][N]){\n  rep(k,n)rep(i,n)rep(j,n)mat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);\n}\n\n\nll dp[1000][N];\nll solve(int n,vector<int> &in,int s){\n  wf(n,land);\n  wf(n,sea);\n  rep(i,in.size())rep(j,n)dp[i][j]=inf;\n\n  dp[0][s]=0;\n\n  REP(i,1,in.size()){\n    rep(j,n){\n      rep(k,n){\n\tdp[i][k]=min(dp[i][k],\n\t\t     dp[i-1][j]+land[in[i-1]][j]+sea[j][k]+land[k][in[i]]);\n      }\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+land[in[i-1]][in[i]]);\n    }\n  }\n\n  ll ret = inf;\n  rep(i,n)ret=min(ret,dp[in.size()-1][i]);\n  return ret;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n){\n      rep(j,n)sea[i][j]=land[i][j]=inf;\n      sea[i][i]=0;land[i][i]=0;\n    }\n    rep(i,m){\n      int f,t;ll c;char tmp;\n      cin>>f>>t>>c>>tmp;\n      f--;t--;\n      if (tmp == 'L')land[f][t]=land[t][f]=min(land[t][f],c);\n      if (tmp == 'S')sea[f][t] =sea[t][f] =min( sea[t][f],c);\n    }\n\n    int q;\n    cin>>q;\n    vector<int> in(q);\n    rep(i,q)cin>>in[i],in[i]--;\n    cout << solve(n,in,in[0]) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000000\nint d[200][200];\nint se[200][200];\nint dp[2][200];\nint z[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\td[i][j]=INF;\n\t\tse[i][j]=INF;\n\t\tif(i==j){\n\t\t\td[i][j]=0;\n\t\t\tse[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar p;\n\t\tscanf(\"%d %d %d %c\",&a,&b,&c,&p);\n\t\ta--;b--;\n\t\tif(p=='L'){\n\t\t\td[a][b]=min(d[a][b],c);\n\t\t\td[b][a]=min(d[b][a],c);\n\t\t}\n\t\tif(p=='S'){\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++){\n\t\tscanf(\"%d\",&z[i]);\n\t\tz[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][z[0]]=0;\n\tfor(i=1;i<p;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i%2][j]=INF;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][k]+d[z[i-1]][k]+se[k][j]+d[j][z[i]]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(p+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\n#define inf (1<<28)\n#define ll long long\n#define db double\n#define c233 cout<<\"233\"<<endl\n#define mem(s) memset(s,0,sizeof(s))\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\nconst int N=205;\nconst int M=1050;\nusing namespace std;\n\nint l[N][N],s[N][N],dp[M][N],way[M];\nint n,m,r,ans;\n\nvoid fre(){\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n}\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=(x<<1)+(x<<3)+ch-48,ch=getchar();\n  return x*res;\n}\n\nvoid init(){\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      l[i][j]=s[i][j]=inf;\n  for(int i=1;i<=n;i++)\n    l[i][i]=s[i][i]=0;\n  for(int i=1;i<=m;i++){\n    int a,b,c;\n    char d;\n    scanf(\"%d%d%d %c\",&a,&b,&c,&d);\n    if(d=='L')l[a][b]=l[b][a]=min(l[a][b],c);\n    if(d=='S')s[a][b]=s[b][a]=min(s[a][b],c);\n  }\n  r=gi();\n  for(int i=1;i<=r;i++)\n    way[i]=gi();\n}\n\nvoid pre(){\n  for(int k=1;k<=n;k++)\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++){\n\tl[i][j]=min(l[i][j],l[i][k]+l[k][j]);\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n      }\n  for(int i=1;i<=r;i++)\n    for(int j=1;j<=n;j++)\n      dp[i][j]=inf;\n  ans=inf;\n}\n\nvoid work(){\n  dp[1][way[1]]=0;\n  for(int i=2;i<=r;i++)\n    for(int j=1;j<=n;j++){\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+l[way[i-1]][way[i]]);\n      for(int k=1;k<=n;k++)\n\tdp[i][k]=min(dp[i][k],dp[i-1][j]+l[way[i-1]][j]+s[j][k]+l[k][way[i]]);\n    }\n  for(int i=1;i<=n;i++)\n    ans=min(ans,dp[r][i]);\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  //fre();\n  while(1){\n    n=gi();m=gi();\n    if(n==0&&m==0)break;\n    init();\n    pre();\n    work();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//34\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define INF (1<<28)\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    int d[2][201][201];\n    fill(d[0][0],d[2][0],INF);\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      int s=sl=='L';\n      d[s][x][y]=d[s][y][x]=min(d[s][y][x],t);\n    }\n    for(int i=0;i<2;i++){\n      for(int j=1;j<=n;j++){\n\td[i][j][j]=0;\n      }\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  for(int l=1;l<=n;l++){\n\t    d[i][k][l]=min(d[i][k][l],d[i][k][j]+d[i][j][l]);\n\t  }\n\t}\n      }\n    }\n    int r;\n    cin>>r;\n    int p[2][201];\n    fill(p[0],p[2],INF);\n    int s;\n    cin>>s;\n    p[0][s]=0;\n    for(int i=0;i<r-1;i++){\n      int z;\n      cin>>z;\n      int b=i&1;\n      fill(p[!b],p[!b+1],INF);\n      for(int j=1;j<=n;j++){\n\tp[!b][j]=min(p[!b][j],p[b][j]+d[1][s][z]);\n\tfor(int k=1;k<=n;k++){\n\t  p[!b][k]=min(p[!b][k],p[b][j]+d[1][s][j]+d[0][j][k]+d[1][k][z]);\n\t}\n      }\n      s=z;\n    }\n    cout<<*min_element(p[~r&1],p[(~r&1)+1])<<endl;\n  }\n  return 0;\n}\n\t  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\n// const int inf = 1ll << 60;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        d[i][j] = c;\n        d[j][i] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n    void disp() {\n        printVV(d);\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<WarshallFloyd> wf(2, WarshallFloyd(n));\n        rep(i, m) {\n            int a, b, c;\n            char t;\n            cin >> a >> b >> c >> t;\n            a--, b--;\n            wf[t == 'S'].setDist(a, b, c);\n        }\n\n        rep(k, 2) wf[k].calc();\n\n        int q;\n        cin >> q;\n        int s = -1;\n        vi a(n, inf);\n        rep(i, q) {\n            int t;\n            cin >> t;\n            t--;\n            if (i == 0) {\n                a[t] = 0;\n            }\n            else {\n                vi b(n, inf);\n                rep(j, n) {\n                    rep(k, n) {\n                        chmin(b[k], a[j] + wf[0].getDist(s, j) + wf[1].getDist(j, k) + wf[0].getDist(k, t));\n                    }\n                }\n                a = b;\n            }\n            s = t;\n        }\n\n        cout << *min_element(all(a)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define eb emplace_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define llbidx(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y) // 二要素間の距離\n#define deg2rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad2deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n#define Find(set, element) set.find(element) != set.end()\n#define Decimal(x) printf(\"%.10f\\n\", x) // 小数点を10桁まで表示\n// debug用\n#define PrintVec(x) for (auto elementPrintVec: x) { cout << elementPrintVec << \" \"; } cout << endl;\n\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PLL;\n\nint POWINT(int x, int n) {\n  int ret = 1;\n  rep(i, 0, n) ret *= x;\n  return ret;\n};\n\nll POWLL(int x, int n) {\n  ll ret = 1;\n  rep(i, 0, n) ret *= x;\n  return ret;\n};\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\nstatic const int INF = 1e9+7;\n\nstruct state {\n  int s, ship;\n};\n\nint main() {\n  int N, M;\n  while (cin >> N >> M, N+M) {\n    vector<vector<int>> l_g(N, vector<int> (N, INF));\n    vector<vector<int>> s_g(N, vector<int> (N, INF));\n\n    vector<vector<int>> l_dist(N, vector<int> (N, INF));\n    vector<vector<int>> s_dist(N, vector<int> (N, INF));\n    rep(i, 0, N) {\n      l_dist[i][i] = s_dist[i][i] = 0;\n    }\n\n\n    int x, y, t;\n    char sl;\n    rep(i, 0, M) {\n      cin >> x >> y >> t >> sl;\n      x--;\n      y--;\n      if (sl == 'L') {\n        l_g[x][y] = min(l_g[x][y], t);\n        l_g[y][x] = min(l_g[y][x], t);\n        l_dist[x][y] = min(l_dist[x][y], t);\n        l_dist[y][x] = min(l_dist[y][x], t);\n      } else {\n        s_g[x][y] = min(s_g[x][y], t);\n        s_g[y][x] = min(s_g[y][x], t);\n        s_dist[x][y] = min(s_dist[x][y], t);\n        s_dist[y][x] = min(s_dist[y][x], t);\n      }\n    }\n\n    rep(k, 0, N) {\n      rep(i, 0, N) {\n        rep(j, 0, N) {\n          l_dist[i][j] = min(l_dist[i][j], l_dist[i][k] + l_dist[k][j]);\n          s_dist[i][j] = min(s_dist[i][j], s_dist[i][k] + s_dist[k][j]);\n        }\n      }\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i, 0, r) {\n      cin >> z[i];\n      z[i]--;\n    }\n\n    vector<int> dp(N, INF);\n    dp[z[0]] = 0;\n\n    rep(i, 1, r) {\n      vector<int> next(N, INF);\n      rep (from, 0, N) { // ship from\n        if (dp[from] == INF) continue;\n        next[from] = min(next[from], dp[from] + l_dist[z[i - 1]][z[i]]); // not use ship\n        rep (to , 0, N) { // ship to\n          next[to] = min(next[to], dp[from] + l_dist[z[i - 1]][from] + s_dist[from][to] + l_dist[to][z[i]]);\n        }\n      }\n      dp = next;\n    }\n\n\n    cout << *min_element(begin(dp), end(dp)) << endl;\n  }\n\n  return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][z[i-1]]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < n; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[n-1], dp[n-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e15:1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\n\nstruct L: public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std{\n\tbool operator < (const P &a, const P &b){\n\t\treturn real(a) != real(b) ? real(a)<real(b) :imag(a)<imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\n\nP projection(L a, P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p-projection(l,p));\n}\n\n\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\n\nvector<L> tangentCC(C a, C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L> l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\t\n\tif(abs(a.r-b.r)<d-EPS){\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\t\n\t}else if(abs(a.r-b.r)<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvi L(n,vi(n,inf));\n\t\tvvi S(n,vi(n,inf));\n\t\trep(i,n)L[i][i]=S[i][i]=0;\n\t\trep(i,m){\n\t\t\tll a,b,c;char d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tif(d=='L')L[a][b]=L[b][a]=min(L[a][b],c);\n\t\t\tif(d=='S')S[a][b]=S[b][a]=min(S[a][b],c);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t}\n\t\tint R;cin>>R;\n\t\tvi r(R);\n\t\trep(i,R)cin>>r[i];\n\t\trep(i,R)r[i]--;\n\t\tvvi dp(R,vi(n,inf));\n\t\tdp[0][r[0]]=0;\n\t\trep(i,R-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[r[i]][r[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+L[r[i]][j]+S[j][k]+L[k][r[i+1]]);\n\t\t\t}\n\t\t}\n//\t\trep(i,R){rep(j,n)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\tll out=inf;\n\t\trep(i,n)out=min(out,dp[R-1][i]);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint land[200][200];\ntypedef pair<int,int>P;\nvector<P>sea[200];\n\nint R,z[1000];\n\nconst int INF = 0x0f0f0f0f;\n\nint memo[200][1000];\nint Solve(int boat, int index)\n{\n\tif(index >= R)\n\t\treturn 0;\n\tint &ref = memo[boat][index];\n\tif(ref >= 0)\n\t\treturn ref;\n\tint from = z[index-1];\n\tint to = z[index];\n\n\tref = land[from][to] + Solve(boat,index+1);\n\n\tfor(int i=0;i<sea[boat].size();++i)\n\t{\n\t\tP p=sea[boat][i];\n\t\tref = min(ref, land[from][boat]+p.second+land[p.first][to] + Solve(p.first,index+1));\n\t}\n\treturn ref;\n}\n\nint main()\n{\n\tint n,m,i,j,k;\n\tint x,y,t;\n\tchar c;\n\tint seaTemp[200][200];\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tfor(i=0;i<n;++i)\n\t\t\tsea[i].clear();\n\t\tmemset(land,INF,sizeof(land));\n\t\tmemset(seaTemp,INF,sizeof(seaTemp));\n\t\tfor(i=0;i<n;++i)\n\t\t\tland[i][i]=0;\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&t,&c);\n\t\t\t--x,--y;\n\t\t\tif(c=='L')\n\t\t\t\tland[y][x]=land[x][y] = min(land[y][x],t);\n\t\t\telse\n\t\t\t\tseaTemp[y][x]=seaTemp[x][y]=min(seaTemp[y][x],t);\n\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=0; i<R; ++i)\n\t\t{\n\t\t\tscanf(\"%d\",z+i);\n\t\t\t--z[i];\n\t\t}\n\n\t\tfor(k=0;k<n;++k)\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tfor(j=0;j<n;++j)\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t{\n\t\t\t\tif(seaTemp[i][j]==INF)continue;\n\t\t\t\tsea[i].push_back(P(j,seaTemp[i][j]));\n\t\t\t\tsea[j].push_back(P(i,seaTemp[i][j]));\n\t\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tprintf(\"%d\\n\",Solve(z[0],1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][z[i-1]]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < n; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[n-1], dp[n-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M,R;\nvector<int> A;\nll edgeL [201] [201],edgeS [201] [201];\nll dp [1001] [201];\nconst ll INF = 1e18;\n\nint main()\n{\n\twhile(cin >> N >> M && N){\n\t\tfill(edgeL [0],edgeL [201],INF);\n\t\tfill(edgeS [0],edgeS [201],INF);\n\t\tFOR(i,1,N + 1){\n\t\t\tedgeL [i] [i] = 0;\n\t\t\tedgeS [i] [i] = 0;\n\t\t}\n\t\tFOR(i,0,M){\n\t\t\tint u,v,w;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> w >> c;\n\t\t\tif(c == 'L'){\n\t\t\t\tchmin(edgeL [u] [v],(ll) w);\n\t\t\t\tchmin(edgeL [v] [u],(ll) w);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchmin(edgeS [u] [v],(ll) w);\n\t\t\t\tchmin(edgeS [v] [u],(ll) w);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tA.assign(R,0);\n\t\tFOR(i,0,R){\n\t\t\tscanf(\"%d\",&A [i]);\n\t\t}\n\n\t\tFOR(k,1,N + 1) FOR(i,1,N + 1) FOR(j,1,N + 1){\n\t\t\tchmin(edgeL [i] [j],edgeL [i] [k] + edgeL [k] [j]);\n\t\t\tedgeL [j] [i] = edgeL [i] [j];\n\t\t\tchmin(edgeS [i] [j],edgeS [i] [k] + edgeS [k] [j]);\n\t\t\tedgeS [j] [i] = edgeS [i] [j];\n\t\t}\n\n\t\tfill(dp [0],dp [1001],INF);\n\t\tdp [1] [1] = 0;\n\t\tFOR(i,1,R) FOR(j,1,N + 1) if(dp [i] [j] < INF){\n\t\t\tchmin(dp [i + 1] [j],dp [i] [j] + edgeL [A [i - 1]] [A [i]]);\n\t\t\tFOR(nxt,1,N + 1){\n\t\t\t\tchmin(dp [i + 1] [nxt],dp [i] [j] + edgeL [A [i - 1]] [j] + edgeS [j] [nxt] + edgeL [nxt] [A [i]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",*min_element(dp [R],dp [R + 1]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<27;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Matrix &g, Matrix &dist) {\n  int n = g.size();\n  dist = g;\n  REP(k, n) REP(i, n) REP(j, n)\n    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n}\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n) {\n    Matrix gl(n,Array(n,INF));\n    Matrix gs(n,Array(n,INF));\n    set<int> ses;\n    REP(i,n) {\n      gl[i][i] = 0;\n    }\n    REP(i,m) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      a--;b--;\n      char ch;\n      cin >> ch;\n      if (ch=='L') {\n        gl[a][b] = c;\n        gl[b][a] = c;\n      }else {\n        gs[a][b] = c;\n        gs[b][a] = c;\n        ses.insert(a);\n        ses.insert(b);\n      }\n    }\n    FOR(it,ses)\n      gs[*it][*it] = 0;\n    int t;\n    cin >> t;\n    int z[t];\n    REP(i,t) {\n      cin >> z[i];\n      z[i]--;\n    }\n    Matrix distl, dists;\n    shortestPath(gl, distl);\n    shortestPath(gs, dists);\n    vector<int> ikerul[n], ikerus[n];\n    REP(i,n) {\n      FOR(jt,ses) {\n        int j =*jt;\n        if (dists[i][j]!=INF)\n          ikerus[i].push_back(j);\n        if (distl[i][j]!=INF)\n          ikerul[i].push_back(j);\n      }\n    }\n\n    int dp[t][n];\n    REP(i,t)REP(j,n)dp[i][j] = INF;\n    dp[0][z[0]] = 0;\n    int cnt = 0;\n    REP(i,t-1) {\n      REP(j, n) {\n        REP(k, n) {\n          int tmp;\n          if (j==k) tmp = distl[z[i]][z[i+1]];\n          else tmp = distl[z[i]][j] + dists[j][k] + distl[k][z[i+1]];\n          dp[i+1][k] = min(dp[i+1][k], dp[i][j] + tmp);\n        }\n      }\n    }\n    cout << *min_element(dp[t-1], dp[t-1]+n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint l[222][222], w[222][222];\nint s[1111];\nconst int inf = 2e8;\nint n, m;\nint dp[1111][222];\n\nvoid floyd(int a[222][222]){\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\ta[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\t// freopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfill(l[i], l[i]+n+1, inf);\n\t\t\tfill(w[i], w[i]+n+1, inf);\n\t\t\tl[i][i] = 0;\n\t\t\tw[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u, v, t;\n\t\t\tchar op[2];\n\t\t\tcin >> u >> v >> t >> op;\n\t\t\t// cout << u << endl;\n\t\t\tif(op[0] == 'L'){\n\t\t\t\tl[u][v] = min(l[u][v], t);\n\t\t\t\tl[v][u] = min(l[v][u], t);\n\t\t\t} else{\n\t\t\t\tw[u][v] = min(w[u][v], t);\n\t\t\t\tw[v][u] = min(w[v][u], t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloyd(l);\n\t\t/*for(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tcout << l[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tfloyd(w);\n\t\tint len;\n\t\tcin >> len;\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tfill(dp[i], dp[i]+n+1, inf);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tdp[0][i] = w[1][i];\n\t\t}\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + l[s[i-1]][k] + w[k][j] + l[j][s[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << *min_element(dp[len]+1, dp[len]+n+1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, r;\n\nint g[2][201][201];\nint dp[201][1001];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m, n){\n\t\tREP(i, n)REP(j, n) g[0][i][j] = g[1][i][j] = i==j ? 0 : INF;\n\t\tREP(i, m){\n\t\t\tint u,v,t;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> t >> c;u--;v--;\n\t\t\tchmin(g[c=='S'][u][v], t);\n\t\t\tchmin(g[c=='S'][v][u], t);\n\t\t}\n\t\tREP(l, 2)REP(k, n)REP(i, n)REP(j, n) g[l][i][j] = min(g[l][i][j], g[l][i][k] + g[l][k][j]);\n\t\tmemset(dp, 63, sizeof(dp));\n\t\tcin >> r;\n\t\tint p;\n\t\tcin >> p;p--;\n\t\tdp[0][p] = 0;\n\t\tREP(i, r-1){\n\t\t\tint x;\n\t\t\tcin >> x; x--;\n\t\t\tREP(j, n){\n\t\t\t\t// p->x\n\t\t\t\tchmin(dp[i+1][j], dp[i][j]+g[0][p][x]);\n\t\t\t\tREP(k, n){\t// p->j->k->x\n\t\t\t\t\tchmin(dp[i+1][k], dp[i][j]+g[0][p][j]+g[1][j][k]+g[0][k][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = x;\n\t\t}\n\t\tcout << *min_element(&dp[r-1][0], &dp[r][0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=(k);i++)\n#define INF ((int)1.e8)\n#define mk(i,j) make_pair(i,j)\n\n#define N 210\n#define M 10010\n#define R 1010\nint sdst[N][N];\nint ldst[N][N];\nint dp[R+1][N];\n\nusing namespace std;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n)break;\n\t\trep(i,n)rep(j,n){\n\t\t\tsdst[i][j] = ldst[i][j] = i==j?0:INF;\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin >> x >> y >> t;\n\t\t\tx--;y--;\n\t\t\tcin >> s;\n\t\t\tif(s[0]=='L'){\n\t\t\t\tldst[x][y] = ldst[y][x] = min(ldst[x][y],t);\n\t\t\t}else{\n\t\t\t\tsdst[x][y] = sdst[y][x] = min(sdst[x][y],t);\n\t\t\t}\n\t\t\t//cout << x << \" \" << y << \" \" << t << \" \" << s << endl;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tldst[i][j] = min(ldst[i][j],ldst[i][k] + ldst[k][j]);\n\t\t\tsdst[i][j] = min(sdst[i][j],sdst[i][k] + sdst[k][j]);\n\t\t}\n\t\tint r,zp;\n\t\tcin >> r;\n\t\trep(i,r)rep(j,n)dp[i][j]=INF;\n\t\tcin >> zp;\n\t\tzp--;\n\t\tdp[0][zp]=0;\n\t\trep(i,r-1){\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t\trep(j,n)rep(k,n){\n\t\t\t\tdp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t dp[i][j] + (j==k?ldst[zp][z]:ldst[zp][j] + sdst[j][k] + ldst[k][z]));\n\t\t\t}\n\t\t\tzp = z;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i,n)ans = min(dp[r-1][i],ans);\n\n\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\tif(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",res);\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\nvoid Floyd_Warshall(vector< vector< int64 > >& graph){\n  for(int k = 0; k < graph.size(); k++){\n    for(int i = 0; i < graph.size(); i++){\n      for(int j = 0; j < graph.size(); j++){\n        graph[i][j] = min( graph[i][j], graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n  return ;\n}\n\nint main(){\n  int N, M, R, z[1000];\n  vector< vector< int64 > > Road_graph, Sea_graph;\n  int64 dp[1000][200];\n\n  while(cin >> N >> M, N){\n    \n    Road_graph = vector< vector< int64 > >( N, vector< int64 >( N, INF));\n    Sea_graph  = vector< vector< int64 > >( N, vector< int64 >( N, INF));\n    for(int i = 0; i < N; i++){\n      Road_graph[i][i] = Sea_graph[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if(sl == 'L') Road_graph[x][y] = Road_graph[y][x] = t;\n      else          Sea_graph [x][y] = Sea_graph [y][x] = t;\n    }\n    cin >> R;\n    for(int i = 0; i < R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    Floyd_Warshall(Road_graph);\n    Floyd_Warshall( Sea_graph);\n\n    //dp[idx][船の場所]\n    fill_n( *dp, 1000 * 200, INF);\n    dp[0][z[0]] = 0;\n    for(int i = 0; i < R - 1; i++){\n      for(int j = 0; j < N; j++){ //船の場所\n        if(dp[i][j] == INF) continue;\n        dp[i + 1][j] = min( dp[i + 1][j], dp[i][j] + Road_graph[z[i]][z[i + 1]]);\n        for(int k = 0; k < N; k++){\n          int64 Cost = Road_graph[z[i]][j] + Sea_graph[j][k] + Road_graph[k][z[i + 1]];\n          if(Cost > INF) continue;\n          dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + Cost);\n        }\n      }\n    }\n    int64 ret = INF;\n    for(int i = 0; i < N; i++){\n      ret = min( ret, dp[R - 1][i]);\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct CWW{CWW(){ios::sync_with_stdio(false);cin.tie(0);}}cww;\ntypedef long long LL;\nconst LL INF=1e16;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nint main(){\n    for(int N,M;cin>>N>>M,N+M;){\n\tVV riku(N,V(N,INF)),umi(N,V(N,INF));\n\tfor(int i=0;i<N;i++)riku[i][i]=umi[i][i]=0;\n\twhile(M--){\n\t    int a,b;LL t;string s;\n\t    cin>>a>>b>>t>>s;\n\t    a--;b--;\n\t    if(s==\"L\")riku[a][b]=riku[b][a]=t;\n\t    else umi[a][b]=umi[b][a]=t;\n\t}\n\tfor(int k=0;k<N;k++)\n\t    for(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t    riku[i][j]=min(riku[i][j],riku[i][k]+riku[k][j]);\t    \n\t\t    umi[i][j]=min(umi[i][j],umi[i][k]+umi[k][j]);\n\t\t}\n\tint R;\n\tcin>>R;\n\tvector<int> z(R);\n\tfor(auto &it:z){\n\t    cin>>it;it--;\n\t}\n\tVV dp(R,V(N,INF));\n\tdp[0][z[0]]=0;\n\tfor(int i=1;i<R;i++){\n\t    for(int j=0;j<N;j++){\n\t\tdp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n\t\tfor(int k=0;k<N;k++)\n\t\t    dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+umi[k][j]+riku[j][z[i]]);\n\t    }\n\t}\n\tLL res=INF;\n\tfor(auto &it:dp.back())res=min(res,it);\n\tcout<<res<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nint n,m,R;\nlong long land[300][300],water[300][300],dp[1005][300];\nint a[1005];\nlong long min(long long a, long long b)\n{\n    if (a < b) return a;\n    else return b;\n}\nvoid pre(){\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++){\n          land[i][j]=land[j][i]=inf;\n          water[i][j]=water[j][i]=inf;\n        }\n    for(int i=1;i<=n;i++)\n         land[i][i]=0,water[i][i]=0;\n}\n\nvoid floyd(){\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++){\n                if(k==i||k==j||i==j) continue;\n                water[i][j]=min(water[i][j],water[i][k]+water[k][j]);\n                land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            }\n}\n\nint main(){\n    while(1){\n     scanf(\"%d%d\",&n,&m);\n     if(n==0&&m==0) break;\n     pre();\n     for(int i=1;i<=m;i++){\n         int l,r; string str;\n         long long w;\n         scanf(\"%d%d%lld\",&l,&r,&w);\n         cin>>str;\n         if(str==\"L\") land[l][r]=land[r][l]=min(land[r][l],w);\n         else water[l][r]=water[r][l]=min(water[r][l],w);\n    }\n    floyd();\n    scanf(\"%d\",&R);\n    for(int i=1;i<=R;i++)\n        for(int j=1;j<=n;j++)\n          dp[i][j]=inf;\n    for(int i=1;i<=R;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n      dp[1][i]=water[a[1]][i]+land[i][a[1]];//第一次出发可以将船停到任意处再坐船回到当前目标点\n    for(int i=2;i<=R;i++)//目的地\n     for(int j=1;j<=n;j++)//上一次的下船点\n     {\n         dp[i][j]=min(dp[i][j],land[a[i-1]][a[i]]+dp[i-1][j]);//走陆地\n         for(int k=1;k<=n;k++)//新的下船点\n         dp[i][k]=min(dp[i][k],dp[i-1][j]+land[a[i-1]][j]+water[j][k]+land[k][a[i]]);//走水路\n     }\n         \n     long long minn=inf;\n     for(int i=1;i<=n;i++)\n        minn=min(minn,dp[R][i]);\n     printf(\"%lld\\n\",minn);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 205\n#define maxr 1005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nint fl[maxn][maxn],fs[maxn][maxn],dp[maxr][maxn],n,m,r,a[maxn];\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m) && (n+m)>0){\n\tmemset(fl,0x3f,sizeof(fl));\n\tmemset(fs,0x3f,sizeof(fs));\n\tfor(int i=1;i<=n;i++) fs[i][i] = fl[i][i] = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tchar c;\n\t\twhile(scanf(\"%c\",&c) && (c!='S'&&c!='L'));\n\t\tif(c == 'S') fs[u][v] = fs[v][u] = min(fs[u][v],w);\n\t\telse fl[u][v] = fl[v][u] = min(fl[u][v],w);\n\t}\n\tscanf(\"%d\",&r);\n\tfor(int i=1;i<=r;i++) scanf(\"%d\",&a[i]);\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfl[i][j] = min(fl[i][j],fl[i][k] + fl[k][j]);\n\t\t\t\tfs[i][j] = min(fs[i][j],fs[i][k] + fs[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\ta[0] = 1;\n\tfor(int i=1;i<=n;i++) dp[0][i] = fs[1][i] + fl[i][1];\n\tfor(int i=1;i<=r;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tll res;\n\t\t\t\tif(j==k) res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][a[i]];\n\t\t\t\telse res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][k] + (ll)fs[k][j] + (ll)fl[j][a[i]];\n\t\t\t\tdp[i][j] = min((ll)dp[i][j],res);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = inf;\n\tfor(int i=1;i<=n;i++){\n\t\tans = min(ans,dp[r][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nconst int MAX_V = 205;\nconst int MAX_R = 1005;\nint gl[MAX_V][MAX_V], gs[MAX_V][MAX_V];\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M, N||M){\n\t\tinit(gl);\n\t\tinit(gs);\n\t\trep(i,M){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tgl[x][y] = gl[y][x] = min(t, gl[x][y]);\n\t\t\t}else{\n\t\t\t\tgs[x][y] = gs[y][x] = min(t, gs[x][y]);\n\t\t\t}\n\t\t}\n\t\twarshallFloyd(gl,N);\n\t\twarshallFloyd(gs,N);\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> z(R);\n\t\trep(i,R){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tint dp[MAX_R][MAX_V];\n\t\trep(i,MAX_V) rep(j,MAX_V) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\n\t\trep(i,R - 1){\n\t\t\tint cur = z[i];\n\t\t\tint next = z[i + 1];\n\t\t\t//rep(j,N) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][next]);\n\t\t\trep(j,N){\n\t\t\t\trep(k,N){\n\t\t\t\t\tassert(i + 1 < R);\n\t\t\t\t\tassert(cur < N);\n\t\t\t\t\tassert(next < N);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\t\t\t//show(dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,R){\n\t\t//\trep(j,N){\n\t\t//\t\tif(dp[i][j] >= INF) cout << \"_\";\n\t\t//\t\telse cout << dp[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint mini = INT_MAX;\n\t\trep(i,N){\n\t\t\tmini = min(mini, dp[R - 1][i]);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<unsigned char,unsigned char,short> tpl;\n    //static int dist[200][200][1001];\n    //fill_n((int*)dist,200*200*1001,inf);\n    map<tpl,int> dist;\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    //dist[z[0]][z[0]][1]=true;\n    dist[make_tuple(z[0],z[0],1)]=0;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        //if(d>dist[p1][p2][num]) continue;\n        if(d>dist[t.second]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n\n        if(p1==z[num]){\n            auto t_=make_tuple(p1,p2,num+1);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d>=tmp) continue;\n            dist[t_]=d;\n            que.push(make_pair(d,t_));\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p2,num_);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            //if(d_>=dist[p_][p2][num_]) continue;\n            if(d_>=tmp) continue;\n            //dist[p_][p2][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            auto t_=make_tuple(p_,p_,num_);\n            int tmp=(dist.find(t_)==dist.end()?inf:dist[t_]);\n            if(d_>=tmp) continue;\n            //dist[p_][p_][num_]=d_;\n            dist[t_]=d_;\n            que.push(make_pair(d_,t_));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<28;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint g1[200][200];\nint g2[200][200];\nint dist[2][200];\nint z[1000];\nint main() {\n  int n, m;\n  while(scanf(\"%d%d\",&n,&m),n||m) {\n    REP(i,n)REP(j,n)g1[i][j]=g2[i][j]=INF;\n    REP(i,n)g1[i][i]=g2[i][i]=0;\n    REP(i,m) {\n      int a,b,c;\n      char t;\n      scanf(\"%d%d%d %c \",&a,&b,&c,&t);\n      a--;b--;\n      if (t=='L') g1[b][a]=g1[a][b]=min(g1[a][b],c);\n      else g2[b][a]=g2[a][b]=min(g2[a][b],c);\n    }\n    REP(k,n)REP(i,n)REP(j,n)g1[i][j]=min(g1[i][j],g1[i][k]+g1[k][j]),g2[i][j]=min(g2[i][j],g2[i][k]+g2[k][j]);\n    int r;scanf(\"%d\",&r);\n    REP(i,r) {\n      scanf(\"%d\",z+i);\n      z[i]--;\n    }\n    REP(i,n)dist[0][i] = INF;\n    dist[0][z[0]] = 0;\n    int p;\n    REP(i,r-1) {\n      int *now = dist[i&1];\n      int *nxt = dist[(i+1)&1];\n      REP(j,n)nxt[j]=INF;\n      REP(j,n)REP(k,n) {\n        if (j==k) nxt[k]=min(nxt[k],now[j]+g1[z[i]][z[i+1]]);\n        else nxt[k] = min(nxt[k], now[j]+g1[z[i]][j]+g2[j][k]+g1[k][z[i+1]]);\n      }\n      //REP(i,n) cout << nxt[i] << \" \";cout<<endl;\n    }\n    int ans = INF;\n    REP(i,n) ans=min(ans, dist[(r-1)&1][i]);\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\n#define INF 10000000000LL\nusing namespace std;\ntypedef long long ll;\n\nint N, M, R, X, Y, T, Z[1000];\nchar SL;\nll d[2][200][200];\nll dp[1000][200][2];\n\nint main(void) {\n  while(cin >> N >> M, N || M) {\n    REP(w, 0, 2) REP(i, 0, N) REP(j, 0, N) d[w][i][j] = (i == j ? 0 : INF);\n    REP(i, 0, M) {\n      cin >> X >> Y >> T >> SL;\n      d[SL == 'L'][X - 1][Y - 1] = T;\n      d[SL == 'L'][Y - 1][X - 1] = T;\n    }\n\n    REP(w, 0, 2) REP(k, 0, N) REP(i, 0, N) REP(j, 0, N)\n      d[w][i][j] = min(d[w][i][j], d[w][i][k] + d[w][k][j]);\n\n    cin >> R;\n    REP(i, 0, R) cin >> Z[i], Z[i]--;\n\n    REP(i, 0, R) REP(j, 0, N) REP(k, 0, 2) dp[i][j][k] = INF;\n    REP(i, 0, 2) dp[0][Z[0]][i] = 0;\n\n    REP(i, 1, R) {\n      REP(j, 0, N) REP(k, 0, N)\n        dp[i][k][1] = min(dp[i][k][1], dp[i - 1][j][1] + d[1][Z[i - 1]][j] + d[0][j][k] + d[1][k][Z[i]]);\n    }\n\n    ll ans = INF;\n    REP(i, 0, N) REP(j, 0, 2) ans = min(ans, dp[R - 1][i][j]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int INF = 1<<30;\n\nint cost[2][201][201];\nbool used[201][201][1001];\n\nstruct t_node {\n    int pos;\n    int ship;\n    int time;\n    int delindex;\n    bool visit[201];\n    t_node(int p, int s, int t, int d) {\n        pos = p;\n        ship = s;\n        time = t;\n        delindex = d;\n    }\n};\nbool operator<( const t_node& lhs, const t_node &rhs ) {\n    return lhs.time > rhs.time;\n}\n\nint main() {\n    int n, m;\n    while( cin >> n >> m, n||m ) {\n        memset( used, 0, sizeof(used) );\n        rep(i,2) rep(j,201) rep(k,201) cost[i][j][k] = INF;\n        rep(i, m) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            int s = (sl=='L' ? 0 : 1);\n            cost[s][x][y] = cost[s][y][x] = t;\n        }\n        int r;\n        cin >> r;\n        vector<int> deliver(r);\n        rep(i, r) {\n            cin >> deliver[i];\n        }\n        priority_queue<t_node> que;\n        que.push( t_node(1, 1, 0, 0) );\n        while( !que.empty() ) {\n            t_node tn = que.top();\n            que.pop();\n            if( used[tn.pos][tn.ship][tn.delindex] ) {\n                continue;\n            }\n            used[tn.pos][tn.ship][tn.delindex] = true;\n            if( deliver[tn.delindex] == tn.pos ) {\n                tn.delindex++;\n                if( tn.delindex == r ) {\n                    cout << tn.time << endl;\n                    break;\n                }\n            }\n            rep(j, (tn.pos==tn.ship ? 2 : 1)) {\n                rep(i, n+1) {\n                    if( cost[j][tn.pos][i] < INF ) {\n                        que.push( t_node( i, (j==1 ? i : tn.ship), tn.time+cost[j][tn.pos][i], tn.delindex ) );\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(1001,1001,INF);\n        auto Sd = vectors(1001,1001,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1001,1001,INF);\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 10000000000000ll;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tchar sl;\n\tint N, M, R;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<vector<ll>> umi(N, vector<ll>(N, INF)), riku(N, vector<ll>(N, INF));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tumi[i][i] = riku[i][i] = 0;\n\t\t}\n\t\tfor (ll i = 0, x, y, t; i < M; i++) {\n\t\t\tcin >> x >> y >> t >> sl; x--; y--;\n\t\t\tif (sl == 'S') {\n\t\t\t\tumi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\triku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tumi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tvector<ll> z(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> z[i]; z[i]--;\n\t\t}\n\t\tvector<vector<ll>> d(R, vector<ll>(N, INF));\n\t\td[0][z[0]] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (umi[z[0]][i] != INF && riku[i][z[0]] != INF) {\n\t\t\t\td[0][i] = min(d[0][i], umi[z[0]][i] + riku[i][z[0]]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\td[i][j] = min(d[i][j], d[i - 1][j] + riku[z[i - 1]][z[i]]);\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\td[i][k] = min(d[i][k], d[i - 1][j] + riku[z[i - 1]][j] + umi[j][k] + riku[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, d[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint cost[201][201][201];\n#define INF 100000000\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nclass state{\npublic:\n\tint now,cost,ship;\n\tstate(int now,int cost,int ship):now(now),cost(cost),ship(ship){}\n};\n\nbool operator < (state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tfor(int i=0;i<201;i++){\n\t\t\tfor(int j=0;j<201;j++)\n\t\t\t\tfor(int z=0;z<201;z++)\n\t\t\t\t\tcost[i][j][z]=1000000000;\n\t\t}\n\n\t\tvector<vector<edge> > grand(201);\n\t\tvector<vector<edge> >sea(201);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint cost,in,out; \n\t\t\tchar kind;\n\t\t\tcin>>in>>out>>cost>>kind;\n\t\t\tif(kind=='L'){\n\t\t\t\tgrand[in].push_back(edge(out,cost));\n\t\t\t\tgrand[out].push_back(edge(in,cost));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsea[in].push_back(edge(out,cost));\n\t\t\t\tsea[out].push_back(edge(in,cost));\n\t\t\t}\n\t\t}\n\t\tint first,n;\n\t\tcin>>n;\n\t\tvector<int> dest(n-1);\n\t\tcin>>first;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tcin>>dest[i];\n\t\t}\n\n\t\tfor(int k=0;k<n-1;k++){\n//\t\t\tcout<<k<<\"!!!!!!!\\n\";\n\t\t\tpriority_queue<state> Q;\n\t\t\tif(k==0) Q.push(state(first,0,first));\n\t\t\telse{\n\t\t\t\tfor(int i=0;i<=n;i++){\n\t\t\t\t\tif(cost[dest[k-1]][i][k-1]<INF){\n\t\t\t\t\t\tQ.push(state(dest[k-1],cost[dest[k-1]][i][k-1],i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint temp[201][201];\n\t\t\tfor(int i=0;i<201;i++)\n\t\t\t\tfor(int j=0;j<201;j++)\n\t\t\t\t\ttemp[i][j]=INF;\n\n\t\t\twhile(!Q.empty()){\n\t\t\t\tstate t=Q.top(); Q.pop();\n//\t\t\tcout<<\"now \"<<t.now<<\" \"<<t.cost<<endl;\n\t\t\t\tif(temp[t.now][t.ship]<=t.cost) continue;\n\t\t\t\ttemp[t.now][t.ship]=t.cost;\n\t\t\t\tif(t.now==dest[k]){cost[t.now][t.ship][k]=t.cost;continue;}\n\t\t\t\tif(t.now==t.ship){\n\t\t\t\t\tfor(int i=0;i<sea[t.now].size();i++){\n\t\t\t\t\t\tQ.push(state(sea[t.now][i].to,t.cost+sea[t.now][i].cost,sea[t.now][i].to));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<grand[t.now].size();i++)\n\t\t\t\t\tQ.push(state(grand[t.now][i].to,t.cost+grand[t.now][i].cost,t.ship));\n\t\t\t}\n\t\t}\n\t\tint ans=INF;\n\t\tfor(int i=0;i<201;i++)\n\t\t\tfor(int j=0;j<201;j++)\n\t\t\t\tans=min(ans,cost[i][j][n-2]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define inf 1000\n\nint N,M;\nint disL[200][200];//隣接行列の重みバージョン陸\nint disS[200][200];//海\nint r ;\nint z[1000];\nint disP[1000][100]={};\n\n/*町番号は0からN-1とする（入力は1からN）*/\n\n/*町Z(num)からZr（終点）への最短時間（船が町shipにある状況で）を返す\nz  宅配順列の何番目か0->(r-1)\nship 船のある町番号0->N-1\n*/\nint recur(int num,int ship){\n  int land,sea=inf,sm=ship,sp,i;\n\n  if(disP[num][ship]!=0)return disP[num][ship];\n  if(num>=r-1)return 0;\n  land=disL[z[num]][z[num+1]]+recur(num+1,ship);\n  \n  for(i=0;i<N;i++){\n    sp=disL[ z[num] ][ship] + disS[ship][i] + disL[i][ z[num+1] ] + recur(num+1,i);\n    if(sea>sp){\n      sea=sp;\n    }\n  }\n  disP[num][ship]=min(land,sea);\n  return disP[num][ship];\n}\n\n\nint main(){\n  int i,j,k,x,y,t;\n  char ch;\n  while(true){\n\n    for(i=0;i<1000;i++)\n      for(j=0;j<100;j++)\n\tdisP[i][j]=0;\n\n    /*入力処理*/\n    cin >>N>>M;\n    if(N==0 && M==0)break;\n    for(i=0;i<M;i++){\n      for(j=0;j<M;j++){\n\tif(i!=j){\n\t  disL[i][j]=inf;\n\t  disS[i][j]=inf;\n\t}\n\telse {\n\t  disL[i][i]=0;\n\t  disS[i][i]=0;\n\t}\n      }\n    }\n    \n\n    /*陸路海路それぞれの最小値をセット*/\n    for(i=0;i<M;i++){\n      cin >>x>>y>>t>>ch;\n      if(ch=='L'){\n\tdisL[x-1][y-1]=min(disL[x-1][y-1],t);\n\tdisL[y-1][x-1]=min(disL[y-1][x-1],t);\n      }\n      else if(ch=='S'){\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n      }\n    }\n\n    priority_queue<int> p_que;\n    /*陸、海それぞれで各町同士の最短経路を出す*/  \n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tfor(k=0;k<N;k++){\n\t  disL[j][k]=min(disL[j][k],disL[j][i]+disL[i][k]);\n\t  disS[j][k]=min(disS[j][k],disS[j][i]+disS[i][k]);\n\t}\n      }\n    }\n    cin >> r;\n    for(i=0;i<r;i++){\n      cin >> j;\n      z[i]=j-1;//町番号は0からN-1にする\n    }\n    cout << recur(0,z[0]) <<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINT_MAX)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<LL>> warshall_floyd(std::vector<std::vector<LL>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INT_MAX and matrix.at(m).at(e) != INT_MAX) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        vector<vector<LL>> matrix1(N, vector<LL>(N, INT_MAX)), matrix2(N, vector<LL>(N, INT_MAX));\n        FOR(i, 0, M) {\n            int X, Y, T;\n            char S;\n            cin >> X >> Y >> T >> S;\n            X--; Y--;\n            if (S == 'L') {\n                matrix1[X][Y] = T;\n                matrix1[Y][X] = T;\n            }\n            else if (S == 'S') {\n                matrix2[X][Y] = T;\n                matrix2[Y][X] = T;\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> route(R);\n        FOR(i, 0, R) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        matrix1 = warshall_floyd(matrix1);\n        matrix2 = warshall_floyd(matrix2);\n\n        vector<vector<LL>> dp(R, vector<LL>(N, INF));\n        dp[0][route[0]] = 0;\n\n        FOR(i, 0, R - 1) {\n            int now = route[i];\n            int next = route[i + 1];\n\n            FOR(j, 0, N) {\n                FOR(k, 0, N) {\n                    // 船がjにあるとき、町nowから町jに陸路、町jから町kに海路、町kから町nextに陸路でいく\n                    LL dist = dp[i][j] + matrix1[now][j] + matrix2[j][k] + matrix1[k][next];\n                    dp[i + 1][k] = min(dp[i + 1][k], dist);\n                }\n            }\n        }\n\n        LL ans = INF;\n        FOR(i, 0, N) {\n            ans = min(ans, dp[R - 1][i]);\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            /*if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }*/\n            rep(j,n){\n                cmin(dp[i+1][k],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define INF 500000000\n\nint main(void){\n  \n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int x, y, t;\n    string sl;\n    vector<vector<int> > Lmatrix(n, vector<int>(n, INF));\n    vector<vector<int> > Smatrix(n, vector<int>(n, INF));\n    for(int i = 0; i < n; i++)\n      Lmatrix[i][i] = Smatrix[i][i] = 0;\n\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      --x;\n      --y;\n      if(sl == \"L\"){\n        Lmatrix[x][y] = min(Lmatrix[x][y], t);\n        Lmatrix[y][x] = min(Lmatrix[y][x], t);\n      }\n      else{\n        Smatrix[x][y] = min(Smatrix[x][y], t);\n        Smatrix[y][x] = min(Smatrix[y][x], t);    \n      }\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){\n      cin >> z[i];\n      --z[i];\n    }\n\n    // ???????????£???\n    for(int k = 0; k < n; k++){\n      for(int i = 0; i < n; i++){\n        for(int j = 0; j < n; j++){\n          Lmatrix[i][j] = min(Lmatrix[i][j], Lmatrix[i][k] + Lmatrix[k][j]);\n          Smatrix[i][j] = min(Smatrix[i][j], Smatrix[i][k] + Smatrix[k][j]);\n        }\n      }\n    }\n\n    // result[i][j]: i?????????????§?????????????j???????????´????????????????????§???????°??????????\n    vector<vector<int> > result(r + 1, vector<int>(n, INF));\n    result[0][z[0]] = 0;\n    \n    // z[i]??????z[i + 1]????§????????????????m1??????m2?????§???????????????     \n    for(int i = 0; i < r - 1; i++){\n      for(int m1 = 0; m1 < n; m1++){\n        for(int m2 = 0; m2 < n; m2++){\n          int start = z[i];\n          int goal = z[i + 1];\n          int cost = result[i][m1] + Lmatrix[start][m1] + Smatrix[m1][m2] + Lmatrix[m2][goal];\n          result[i + 1][m2] = min(result[i + 1][m2], cost);\n        }\n      } \n    }\n\n    int ans = INF;\n    for(int i = 0; i < n; i++){ ans = min(ans, result[r - 1][i]); }\n    cout << ans << endl;\n    \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Weight = long long;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n};\nusing Graph = vector<vector<Edge>>;\n\nvoid add_bidirectional_edge(Graph& graph, int src, int dst, int weight) {\n    graph[src].push_back((Edge){src, dst, weight});\n    graph[dst].push_back((Edge){dst, src, weight});\n}\n\n// Verified: AOJ 2251 (Merry Christmas)\nvector<vector<Weight>> warshall_floyd(Graph graph) {\n    static const Weight inf = numeric_limits<Weight>::max() / 20;\n    vector<vector<Weight>> dist(graph.size(), vector<Weight>(graph.size(), inf));\n    REP(u, graph.size()) dist[u][u] = 0;\n    REP(u, graph.size()) for (auto& e : graph[u]) dist[e.src][e.dst] = e.weight;\n    REP(w, graph.size()) REP(u, graph.size()) REP(v, graph.size())\n        dist[u][v] = min(dist[u][v], dist[u][w] + dist[w][v]);\n    return dist;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M;\n    while (cin>>N>>M, N|M) {\n        Graph land(N), sea(N);\n        REP(i, M) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n            if (sl == 'L')\n                add_bidirectional_edge(land, x, y, t);\n            else\n                add_bidirectional_edge(sea, x, y, t);\n        }\n        int R; cin >> R;\n        vector<int> order(R+1);\n        REP(i, R) {\n            int o; cin >> o;\n            order[i+1] = o-1;\n        }\n\n        auto dist_land = warshall_floyd(land);\n        auto dist_sea  = warshall_floyd(sea);\n\n        vector<vector<Weight>> dp(2, vector<Weight>(N, 1e16));\n        dp[1][0] = 0;\n        REP(i, R) {\n            int curr = i%2, prev = 1-i%2;\n            int u = order[i], v = order[i+1];\n            REP(q, N) {\n                Weight value = 1e16;\n                REP(p, N) {\n                    if (p == q)\n                        value = min(value, dp[prev][p] + dist_land[u][v]);\n                    else\n                        value = min(value, dp[prev][p] + dist_land[u][p] + dist_sea[p][q] + dist_land[q][v]);\n                }\n                dp[curr][q] = value;\n            }\n        }\n        cout << *min_element(dp[(R-1)%2].begin(), dp[(R-1)%2].end()) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const MAX_N = 210;\nint const INF = 1<<29;\n\nint dl[MAX_N][MAX_N];\nint ds[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];\nint z[MAX_R];\nint N, M, R;\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dl[x][y] = dl[y][x] = INF;\n        ds[x][y] = ds[y][x] = INF;\n      }\n      dl[x][y] = dl[y][x] = ds[x][y] = ds[y][x] = 0;\n    }\n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dl[x][y] = dl[y][x] = t;\n      }\n      else {\n        ds[x][y] = ds[y][x] = t;\n      }\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k]+dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j]);\n        }\n    \n    cin >> R;\n    for(int i=0; i<R; i++) { cin >> z[i]; z[i]--; }\n    \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    \n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++) {\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s]+dl[z[i-1]][s]+ds[s][t]+dl[t][z[i]]);\n        }\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tint d, z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nint dp[205][205];\t\t// boat, n\nint ans[205];  // boat\n\nint solve(){\n\tpriority_queue<ST> que;\n\tint d, z, b, n;\n\t//dp[ Z[0] ][ Z[0] ] = 0;\n\tans[ Z[0] ] = 0;\n\trep(i,R-1){\n\t\trep(b,N) if( ans[b] < INF ){\n\t\t\tque.push( ST{ans[b], i, b, Z[i]} );\n\t\t}\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\twhile( !que.empty() ){\n\t\t\tST st = que.top();\n\t\t\tque.pop();\n\t\t\td = st.d;\n\t\t\tz = st.z;\n\t\t\tb = st.b;\n\t\t\tn = st.n;\n\t\t\tif( dp[b][n] < d ) continue;\n\t\t\tdp[b][n] = d;\n\t\t\t//cout << \"hit \" << d << \" \" << z << \" \" << b << \" \" << n << endl;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\t\tint to = _v.first;\n\t\t\t\t\tint cost = _v.second;\n\t\t\t\t\tint nz = z, nb = b;\n\t\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\t\tif( k ) nb = to;\n\t\t\t\t\tif( chmin( dp[nb][to], dp[b][n] + cost) ){\n\t\t\t\t\t\tif( nz == z ){\n\t\t\t\t\t\t\tque.push( ST{ dp[nb][to], nz, nb, to } );\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tchmin( ans[nb], dp[nb][to] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = INF;\n\trep(b,N){\n\t\tchmin( ret, ans[b] );\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x, y, t;\n\tchar sl;\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nlong long int dp[10001][200];\n\nint main() {\n\t/*int N; cin >> N;\n\twhile (N--) {\n\t\tstring ast, bst; cin >> ast >> bst;\n\t\treverse(ast.begin(), ast.end());\n\t\tfor (char c : ast) {\n\t\t\tswitch (c) {\n\t\t\tcase 'A': {\n\t\t\t\treverse(bst.begin(), bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'C': {\n\t\t\t\trotate(bst.begin(), bst.begin() + 1, bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'J':{\n\t\t\t\t\t\t  rotate(bst.begin(), bst.end() - 1, bst.end());\n\t\t\t\t\t  }\n\t\t\t\t\t break;\n\t\t\tcase 'E': {\n\t\t\t\tbst = string(bst.begin() + (bst.size() + 1) / 2, bst.end()) + string(bst.begin() + bst.size() / 2, bst.begin()+(bst.size()+1)/2) + string(bst.begin(), bst.begin() + bst.size() / 2);\n\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'M': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '9')return '0';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c + 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'P': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '0')return '9';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c - 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\t\n\t\t\n\t\tcout << bst << endl;\n\t}*/\n\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < 10001; ++i) {\n\t\t\tfor (int j = 0; j < 200; ++j) {\n\t\t\t\tdp[i][j] = 999999999999;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>stimes(N, vector<long long int>(N, 999999999999)),ltimes(N, vector<long long int>(N,999999999999));\n\n\t\t\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; long long int  t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--; y--;\n\t\t\tif (c == 'L') {\n\t\t\t\tltimes[x][y] = min(ltimes[x][y], t);\n\t\t\t\tltimes[y][x] = min(ltimes[y][x], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstimes[x][y] = min(stimes[x][y], t);\n\t\t\t\tstimes[y][x] = min(stimes[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tltimes[i][i] = 0;\n\t\t\tstimes[i][i] = 0;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tltimes[i][j] = min(ltimes[i][j], ltimes[i][k] + ltimes[k][j]);\n\t\t\t\t\tstimes[i][j] = min(stimes[i][j], stimes[i][k] + stimes[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R; cin >> R;\n\t\tvector<int>vs(R);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tcin >> vs[i];\n\t\t\tvs[i]--;\n\t\t}\n\t\tdp[vs[0]][0] = 0;\n\t\tfor (int time = 0; time< R-1; ++time) {\n\t\t\tfor (int f= 0; f < N; ++f) {\n\t\t\t\tfor (int t = 0; t < N; ++t) {\n\t\t\t\t\tdp[time + 1][t] = min(dp[time + 1][t], dp[time][f] + ltimes[vs[time]][f] + stimes[f][t] + ltimes[t][vs[time + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 999999999999;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\n\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dp[200][200];\nint ldist[200][200];\nint sdist[200][200];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n)\tldist[i][j] = sdist[i][j] = (i == j ? 0 : inf);\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)\trep(i, n)\trep(j, n) {\n\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t}\n\t\trep(i, n)\trep(j, n)\tdp[i][j] = (i == j ? 0 : inf);\n\t\trep(i, n)\trep(j, n) {\n\t\t\tif (i == j)\tcontinue;\n\t\t\tdp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i]);\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, n)\tif (i != z[0])\trep(j, n)\tdp[i][j] = inf;\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n)\tif (j != z[i - 1])\trep(k, n) {\n\t\t\t\tdp[j][k] = min(dp[j][k], dp[z[i - 1]][k] + ldist[z[i - 1]][j]);\n\t\t\t}\n\t\t\trep(j, n)\trep(k, n)\tdp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k]);\n\t\t\trep(j, n)\trep(k, n)\tif (j != k) {\n\t\t\t\tdp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j]);\n\t\t\t}\n\t\t\trep(j, n)\tif (j != z[i])\trep(k, n)\tdp[j][k] = inf;\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[z[r - 1]][i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<queue>\n#include<vector>\n#define INF 100000000\n#define pb push_back\n\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nint d[200][200][2];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tvector<vector<P> > s(n);\n\t\tvector<vector<P> > l(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;x--,y--;\n\t\t\tif(sl=='L'){\n\t\t\t\tl[x].pb(P(y,t));\n\t\t\t\tl[y].pb(P(x,t));\n\t\t\t}else{\n\t\t\t\ts[x].pb(P(y,t));\n\t\t\t\ts[y].pb(P(x,t));\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin>>r;\n\t\tvector<int> town(r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin>>town[i];\n\t\t\ttown[i]--;\n\t\t}\n\t\t\n\t\t\n\t\t//回った数,現在の町、船の位置、\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\td[i][j][k]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpriority_queue<PPP,vector<PPP> , greater<PPP> > que;\n\t\tque.push(PPP(1,PP(0,P(town[0],town[0]))));\n\t\t//tn dist　ship pos\n\t\t\td[town[0]][town[0]][1]=0;\n\t\t\tint ntn=1;\n\t\t\twhile(!que.empty()){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tPPP t=que.top();\n\t\t\t\tque.pop();\n\t\t\t\tint dist=t.second.first,tn=t.first,ship=t.second.second.first,pos=t.second.second.second;\n\t\t\t\t//cout<<\"---------- tn\"<<tn<<\" sp\"<<ship<<\" pos\"<<pos<<\" d\"<<dist<<endl;\n\t\t\t\tif(tn==r){\n\t\t\t\t\tcout<<d[pos][ship][tn%2]<<endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tn!=ntn){\n\t\t\t\t\t\n\t\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\t\td[i][j][(tn+1)%2]=INF;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tntn=tn;\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(dist>d[pos][ship][tn%2]){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(ship==pos){\n\t\t\t\t\tfor(int i=0;i<s[pos].size();i++){\n\t\t\t\t\t\tP e=s[pos][i];\n\t\t\t\t\t\tint to=e.first,cost=e.second;\n\t\t\t\t\t\tint plus=0;\n\t\t\t\t\t\tif(town[tn]==to){\n\t\t\t\t\t\t\tplus=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//\tcout << \"ck\" << to << endl;\n\t\t\t\t\t\tif(d[to][to][(tn+plus)%2]>cost+d[pos][ship][tn%2]){\n\t\t\t\t\t\t//\tcout << \"push\" << to << endl;\n\t\t\t\t\t\t\tque.push(PPP(tn+plus,PP(cost+d[pos][ship][tn%2],P(to,to))));\n\t\t\t\t\t\t\td[to][to][(tn+plus)%2]=cost+d[pos][ship][tn%2];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<l[pos].size();i++){\n\t\t\t\t\t\n\t\t\t\t\tP e=l[pos][i];\n\t\t\t\t\tint to=e.first,cost=e.second;\n\t\t\t\t\tint plus=0;\n\t\t\t\t\tif(town[tn]==to){\n\t\t\t\t\t\tplus=1;\n\t\t\t\t\t}\n\t\t\t\t\tif(d[to][ship][(tn+plus)%2]>cost+d[pos][ship][tn%2]){\n\t\t\t\t\t\tque.push(PPP(tn+plus,PP(cost+d[pos][ship][tn%2],P(ship,to))));\n\t\t\t\t\t\td[to][ship][(tn+plus)%2]=cost+d[pos][ship][tn%2];\n\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\n\t\t\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include    <iostream>\n#include    <cstdio>\n#include    <cstdlib>\n#include    <algorithm>\n#include    <vector>\n#include    <cstring>\n#include    <queue>\n#include    <complex>\n#include    <stack>\n#define LL long long int\n#define dob double\nusing namespace std;\n\nconst int N = 210;\nconst int R = 1010;\nint n,m,Q,land[N][N],sea[N][N],f[R][N],Cit[N];\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n  return x*res;\n}\n\nint main()\n{\n  /*freopen(\"Mr._Rito_Post_Office .in\",\"r\",stdin);\n    freopen(\"Mr._Rito_Post_Office .out\",\"w\",stdout);*/\n  while((n=gi())+(m=gi())){\n    memset(land,127/3,sizeof(land));\n    memset(sea,137/3,sizeof(sea));\n    for(int i=1;i<=n;++i)\n      land[i][i]=sea[i][i]=0;\n    for(int i=1;i<=m;++i){\n      int u=gi(),v=gi(),c=gi();\n      char type;scanf(\"%c\",&type);\n      if(type=='L')\n        land[u][v]=land[v][u]=min(land[u][v],c);\n      else sea[u][v]=sea[v][u]=min(sea[u][v],c);\n    }\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)\n        for(int k=1;k<=n;++k)\n          if(i!=j && i!=k && j!=k){\n            land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n            //printf(\"Ld[%d][%d] = %d  Se[%d][%d] = %d\\n\",i,j,land[i][j],i,j,sea[i][j]);\n          }\n    memset(f,127/3,sizeof(f));\n    Q=gi();Cit[0]=1;f[0][1]=0;\n    for(int i=1;i<=Q;++i)Cit[i]=gi();\n    //1代表有船，0代表没船。\n    for(int i=1;i<=Q;++i)\n      for(int j=1;j<=n;++j)\n        for(int k=1;k<=n;++k)\n          f[i][j]=min(1ll*f[i][j],1ll*f[i-1][k]+1ll*land[Cit[i-1]][k]+1ll*sea[j][k]+1ll*land[j][Cit[i]]);\n    for(int i=1;i<=n;++i)\n      f[0][0]=min(f[0][0],f[Q][i]);\n    printf(\"%d\\n\",f[0][0]);\n  }\n  \n  /*fclose(stdin);\n    fclose(stdout);*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 100\n#define MAX_R 1020\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q2;\nvector<tuple<long long, long long, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N], DIST2[MAX_N];\nlong long COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nlong long PATH[MAX_N][MAX_N][MAX_N];\nlong long DP[MAX_R][MAX_N];\nlong long cnt;\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n\tcnt = 0;\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (M >= 10000) { return 0; }\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = DIST[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tlong long start = travel[i];\n\t\t\t\tlong long goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e9;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tchar sl;\n\tint N, M, R;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<vector<ll>> umi(N, vector<ll>(N, INF)), riku(N, vector<ll>(N, INF));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tumi[i][i] = riku[i][i] = 0;\n\t\t}\n\t\tfor (ll i = 0, x, y, t; i < M; i++) {\n\t\t\tcin >> x >> y >> t >> sl; x--; y--;\n\t\t\tif (sl == 'S') {\n\t\t\t\tumi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\triku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tumi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tvector<ll> z(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> z[i]; z[i]--;\n\t\t}\n\t\tvector<vector<ll>> d(R, vector<ll>(N, INF));\n\t\td[0][z[0]] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (umi[z[0]][i] != INF && riku[i][z[0]] != INF) {\n\t\t\t\td[0][i] = min(d[0][i], umi[z[0]][i] + riku[i][z[0]]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\td[i][k] = min(d[i][k], d[i - 1][j] + riku[z[i - 1]][j] + umi[j][k] + riku[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, d[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  int n, m;\n  long long int INF = 1e14;\n  while(cin >> n >> m, n){\n    vector< vector<long long int> > L(n, vector<long long int>(n, INF)), S = L;\n    int x, y, t;\n    char s;\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> t >> s;\n      --x;--y;\n      if(s == 'L'){\n        L[x][y] = t;\n        L[y][x] = t;\n      }else{\n        S[x][y] = t;\n        S[y][x] = t;\n      }\n    }\n    for(int i = 0; i < n; ++i){\n      S[i][i] = 0;\n      L[i][i] = 0;\n    }\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          L[i][j] = min(L[i][j], L[i][k] + L[k][j]);\n          S[i][j] = min(S[i][j], S[i][k] + S[k][j]);\n        }\n      }\n    }\n    /*\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", L[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", S[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n    int r;\n    cin >> r;\n    vector<int> Z(r);\n    for(int i = 0; i < r; ++i){\n      cin >> Z[i];\n      --Z[i];\n    }\n    vector< vector<long long int> > DP(r, vector<long long int>(n,INF));\n    DP[0][Z[0]] = 0;\n    for(int i = 1; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          DP[i][k] = min(DP[i][k], DP[i-1][j] + L[Z[i-1]][j] + S[j][k] + L[k][Z[i]]);\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", DP[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i) ans = min(ans, DP[r-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//can solve problem with negative loop/cycle\n//worst O(V^3)\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\nconst int INF = 0x7fffffff;\nconst int MAXV=200+5;\nconst int MAXR=1000+5;\n\nint schedule[MAXR];\nint V;\n\nstruct Node {\n    int mina; // can use any way\n    int minl; // only use land way\n    int mins; // only use sea way\n    int pre_ship_pos;\n};\n\nNode dd[MAXV][MAXV];  //d[u][v] means cost[u][v], d[i][i]=0, no edge = INF\nNode min_dis[MAXV][MAXR];\n\n//return false means have negative loop, true means no negative loop\nbool warshall_floyd(Node d[][MAXV])\n{\n    for(int k=0;k<V;++k)\n    {\n        for(int i=0;i<V;++i)\n        {\n            for(int j=0;j<V;++j)\n            {\n                if(d[i][k].minl!=INF && d[k][j].minl!=INF)\n                {\n                    if(d[i][j].minl > d[i][k].minl+d[k][j].minl)\n                    {\n                        d[i][j].minl = d[i][k].minl + d[k][j].minl;\n                        if(d[i][j].minl<d[i][j].mina)\n                        {\n                            d[i][j].mina = d[i][j].minl;\n                            d[i][j].pre_ship_pos = i;\n                        }\n                    }\n                }\n                if(d[i][k].mins!=INF && d[k][j].mins!=INF)\n                {\n                    if(d[i][j].mins > d[i][k].mins+d[k][j].mins)\n                    {\n                        d[i][j].mins = d[i][k].mins + d[k][j].mins;\n                        if(d[i][j].mins<=d[i][j].mina)\n                        {\n                            d[i][j].mina = d[i][j].mins;\n                            d[i][j].pre_ship_pos = j;\n                        }\n                    }\n                }\n                if(d[i][k].mins!=INF && d[k][j].mina!=INF)\n                {\n                    if(d[i][j].mina > d[i][k].mins+d[k][j].mina)\n                    {\n                        d[i][j].mina = d[i][k].mins + d[k][j].mina;\n                        d[i][j].pre_ship_pos = k;\n                    }\n                }\n                if(i==j&&d[i][i].mina<0)\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n\nvoid init()\n{\n    for(int i=0;i<V;++i) {\n        for(int j=0;j<V;++j) {\n            dd[i][j] = dd[i][j] = Node{INF, INF, INF, -1};\n        }\n        dd[i][i] = dd[i][i] = {0, 0, 0, i};\n    }\n}\n\nvoid solve(int R)\n{\n    for(int i=0;i<R;++i){\n        for(int j=0;j<V;++j)\n            min_dis[j][i] = Node{INF,INF,INF,-1};\n    }\n    min_dis[schedule[0]][0] = Node {0,0,0,schedule[0]};   \n    for(int i=1;i<R;++i) {\n        int from = schedule[i-1];\n        int to = schedule[i];\n        for(int j=0;j<V;++j) {\n            if(dd[from][to].minl!=INF && min_dis[j][i-1].mina!=INF)\n                min_dis[j][i].mina = min(min_dis[j][i].mina, min_dis[j][i-1].mina + dd[from][to].minl);\n            //if(j==to && dd[from][to].mins!=INF && min_dis[j][i-1].mina!=INF)\n                //min_dis[j][i].mina = min(min_dis[j][i].mina, min_dis[j][i-1].mina + dd[from][to].minl);\n            for(int k=0;k<V;++k)\n            {\n                if(min_dis[k][i-1].mina!=INF && dd[from][k].minl!=INF && dd[k][j].mins!=INF && dd[j][to].minl!=INF)\n                min_dis[j][i].mina = min(min_dis[j][i].mina, min_dis[k][i-1].mina+dd[from][k].minl+dd[k][j].mins+dd[j][to].minl);\n            }\n        }\n    }\n\n    int ans = INF;\n    for(int j=0;j<V;++j) \n    {\n        ans = min(ans, min_dis[j][R-1].mina);\n    }\n    printf(\"%d\\n\", ans);\n}\n\nint main()\n{\n    int M;\n    while(scanf(\"%d%d\", &V, &M)!=EOF) {\n        if(V==0 && M==0) break;\n        init();\n        int u,v,w; char t;\n        for(int i=0;i<M;++i) {\n            scanf(\"%d %d %d %c\", &u, &v, &w, &t);\n            u--; v--;\n            if(t=='S') {\n                if(w<dd[u][v].mins)\n                    dd[u][v].mins = dd[v][u].mins = w;\n                if(w<dd[u][v].mina) {\n                    dd[u][v].mina = dd[v][u].mina = w;\n                    dd[u][v].pre_ship_pos = v;\n                    dd[v][u].pre_ship_pos = u;\n                }\n            } else {\n                if(w<dd[u][v].minl) \n                    dd[u][v].minl = dd[v][u].minl = w;\n                if(w<dd[u][v].mina) {\n                    dd[u][v].mina = dd[v][u].mina = w;\n                    dd[u][v].pre_ship_pos = u;\n                    dd[v][u].pre_ship_pos = v;\n                }\n            }\n        }\n        int R;\n        scanf(\"%d\", &R);\n        int tmp;\n        for(int i=0;i<R;++i){\n            scanf(\"%d\", &tmp);\n            schedule[i] = tmp-1;\n        }\n        warshall_floyd(dd);\n        solve(R);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct st{\n  int d,v,b;\n  st(){}\n  st(int d,int v,int b):d(d),v(v),b(b){}\n};\nstruct edge{\n  int to,cost,s;\n  edge(){}\n  edge(int to,int cost,int s):to(to),cost(cost),s(s){}\n};\nint dp[2][222][222];\nvector<edge> G[222];\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    for(int i=0;i<222;i++) G[i].clear();\n    int x[m],y[m],t[m];\n    char sl[m];\n    for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i]>>sl[i];\n    int r;\n    cin>>r;\n    int z[r];\n    for(int i=0;i<r;i++) cin>>z[i];\n    for(int i=0;i<m;i++){\n      x[i]--;y[i]--;\n      G[x[i]].emplace_back(y[i],t[i],sl[i]=='S');\n      G[y[i]].emplace_back(x[i],t[i],sl[i]=='S');\n    }\n    for(int i=0;i<r;i++) z[i]--;\n    memset(dp,-1,sizeof(dp));\n    deque<st> q;\n    q.emplace_back(1,z[0],z[0]);\n    dp[1][z[0]][z[0]]=0;\n    int pre=1;\n    int ans=1LL<<55LL;\n    while(!q.empty()){\n      st p=q.front();q.pop_front();\n      int d=p.d,v=p.v,b=p.b;\n      if(d==r){\n\tans=min(ans,dp[d%2][v][b]);\n\tcontinue;\n      }\n      //cout<<d<<\" \"<<v<<\" \"<<b<<\":\"<<dp[d%2][v][b]<<endl;\n      if(pre!=p.d)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    dp[!(d%2)][i][j]=-1;\n      pre=d;\n      for(edge& e:G[v]){\n\tint nv=e.to,nb=b,nd=d;\n\tif(e.s){\n\t  if(v==b) nb=nv;\n\t  else continue;\n\t}\n\tif(nv==z[d]){\n\t  nd++;\n\t  if(dp[nd%2][nv][nb]<0||dp[nd%2][nv][nb]>dp[d%2][v][b]+e.cost){\n\t    //cout<<e.s<<\":\"<<nd<<\" \"<<nv<<\" \"<<nb<<endl;\n\t    dp[nd%2][nv][nb]=dp[d%2][v][b]+e.cost;\n\t    q.emplace_back(nd,nv,nb);\n\t  }\n\t}else{\n\t  if(dp[nd%2][nv][nb]<0||dp[nd%2][nv][nb]>dp[d%2][v][b]+e.cost){\n\t    dp[nd%2][nv][nb]=dp[d%2][v][b]+e.cost;\n\t    q.emplace_front(nd,nv,nb);\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 29)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nint Shortest(int start, int goal, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[goal];\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i <= MAX_R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Shortest(Z[i - 1], j, \"Land\");\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Shortest(j, k, \"Sea\");\n\n\t\t\t\t\t\tint Land_2 = Shortest(k, Z[i], \"Land\");\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n    int d[N];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<n;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint v1[203][203],v2[203][203],a1,a2,a3,n,m;\nint dp[1001][203][203],t,x;\nchar c;\nint main(){\n  while(cin>>n>>m,n){\n    int ans=1e8;\n    r(i,1001)r(j,203)r(k,203)dp[i][j][k]=1e8;\n    r(i,203)r(j,203)v1[a1][a2]=v2[a1][a2]=1e8;\n    r(i,n){\n      cin>>a1>>a2>>a3>>c;\n      a1--,a2--;\n      if(c=='L')v1[a1][a2]=v1[a2][a1]=a3;\n      else v2[a1][a2]=v2[a2][a1]=a3;\n    }\n    r(k,n)r(i,n)r(j,n){\n      v1[i][j]=min(v1[i][j],v1[i][k]+v1[k][j]);\n      v2[i][j]=min(v2[i][j],v2[i][k]+v2[k][j]);\n    }\n    cin>>t>>x;\n    dp[0][x][x]=0;\n    for(int k=0;k<t-1;k++){\n      cin>>x;\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(dp[k][i][j]!=1e8){\n            dp[k+1][x][j]=min(dp[k+1][x][j],dp[k][i][j]+v1[i][x]);\n            dp[k+1][x][x]=min(dp[k+1][x][x],dp[k][i][j]+v1[i][j]+v2[j][x]);\n          }\n        }\n      }\n    }\n    r(i,203)ans=min(ans,dp[t-1][x][i]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef int Weight;\n\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nconst int INF = 10000;\nint N, M, R;\nint dS[MAX_N][MAX_N];  // 海路\nint d[MAX_N][MAX_N];  // 全点対最短距離\nint z[MAX_R];\n\nvoid warshall_floyd(int d[MAX_N][MAX_N])\n{\n    for (int k = 0; k < N; k++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main()\n{\n    while (cin >> N >> M, N || M) {\n        // Initial\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++) {\n                if (i == j)\n                    d[i][j] = dS[i][j] = 0;\n                else\n                    d[i][j] = dS[i][j] = INF;\n            }\n\n        // Input\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char c;\n\n            cin >> x >> y >> t >> c;\n            x--, y--;\n\n            if (d[x][y] != INF || d[x][y] > t)\n                d[x][y] = d[y][x] = t;\n            if (c == 'S') // 海路\n                dS[x][y] = dS[y][x] = t;\n        }\n\n        cin >> R;\n        for (int i = 0; i < R; i++) {\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // Warshall-Floyd\n        warshall_floyd(d);\n        warshall_floyd(dS);\n\n        int ans = dS[z[0]][z[1]];\n        for (int i = 1; i < R - 1; i++)\n            ans += d[z[i]][z[i + 1]];\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n#define ma 23456789\nint sea[200][200];\nint load[200][200];\nint dp[1001][200];\nint to[1000] = {0};\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int2(n, m);\n    if(!(n | m))break;\n    rep(i, n)rep(j, n){\n      sea[i][j] = ma;\n      if(i == j)sea[i][j] = 0;\n    }\n    rep(i, n)rep(j, n){\n      load[i][j] = ma;\n      if(i == j)load[i][j] = 0;\n    }\n    rep(i, m){\n      int x, y, t;\n      char sl;\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      --x; --y;\n      if(sl == 'S'){\n        sea[x][y] = t;\n        sea[y][x] = t;\n      }else{\n        load[x][y] = t;\n        load[y][x] = t;\n      }\n    }\n\n    rep(k, n)rep(i, n)rep(j, n){\n      sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n    }\n    rep(k, n)rep(i, n)rep(j, n){\n      load[i][j] = min(load[i][j], load[i][k] + load[k][j]);\n    }\n\n    int(r);\n    rep(i, r + 1)rep(j, n)dp[i][j] = ma;\n    dp[0][0] = 0;\n    rep(j, n)dp[0][j] = min(dp[0][j], sea[0][j] + load[j][0]);\n\n    to[0] = 0;\n    rep1(i, r + 1){\n      scanf(\"%d\", &to[i]); --to[i];\n      rep(j, n)rep(k, n){\n        dp[i][j] = min(dp[i][j], dp[i - 1][k] + load[to[i - 1]][k] + sea[k][j] + load[j][to[i]]);\n      }\n    }\n\n    int res = ma;\n    rep(j, n)res = min(res, dp[r][j]);\n    pri(res);\n\n    //rep(i, r + 1)rep(j, n)pri3(i, j, dp[i][j]);\n\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\n\nint g[201][201][2];\nint dp[1010][201];\nint dist[201][201];\nint diss[201][201];\n\nint main()\n{\n\tint n, m;\n\twhile(cin>>n>>m, n||m) {\n\t\tfill(g[0][0], g[201][0], inf);\n\t\tfill(dist[0], dist[201], inf);\n\t\tfill(diss[0], diss[201], inf);\n\t\trep(i,0,m) {\n\t\t\tint a,b,c;\n\t\t\tchar d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--; b--;\n\t\t\tif (d=='L') {\n\t\t\t\tif (c < g[a][b][0]) {\n\t\t\t\t\tg[a][b][0] = c;\n\t\t\t\t\tg[b][a][0] = c;\n\t\t\t\t\tdist[a][b] = c;\n\t\t\t\t\tdist[b][a] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (c < g[a][b][1]) {\n\t\t\t\t\tg[a][b][1] = c;\n\t\t\t\t\tg[b][a][1] = c;\n\t\t\t\t\tdiss[a][b] = c;\n\t\t\t\t\tdiss[b][a] = c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r; cin>>r;\n\t\tVi v;\n\t\trep(i,0,r) {\n\t\t\tint t; cin>>t;\n\t\t\tt--;\n\t\t\tv.pb(t);\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d g[i][j][1]=%d\\n\",i,j,g[i][j][1]);\n\n\t\t// ????????????????????????????????¢\n\t\trep(k,0,n) rep(i,0,n) rep(j,0,n) {\n\t\t\tdist[k][k] = 0;\n\t\t\tif (g[i][k][0]==inf || g[k][j][0]==inf) continue;\n\t\t\tif (dist[i][j] > dist[i][k] + dist[k][j]) {\n\t\t\t\tdist[i][j] = dist[i][k] + dist[k][j];\n\t\t\t\tdist[j][i] = dist[i][j];\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d dist[i][j]=%d\\n\",i,j,dist[i][j]);\n\n\t\t// ?°´?????????????????????????????¢\n\t\trep(k,0,n) rep(i,0,n) rep(j,0,n) {\n\t\t\tdiss[k][k] = 0;\n\t\t\tif (g[i][k][1]==inf || g[k][j][1]==inf) continue;\n\t\t\tif (diss[i][j] > diss[i][k] + diss[k][j]) {\n\t\t\t\tdiss[i][j] = diss[i][k] + diss[k][j];\n\t\t\t\tdiss[j][i] = diss[i][j];\n\t\t\t}\n\t\t}\n\t\t//rep(i,0,n-1) rep(j,i+1,n) printf(\"i=%d j=%d diss[i][j]=%d\\n\",i,j,diss[i][j]);\n\n\t\tfill(dp[0], dp[1010], inf);\n\t\tdp[0][v[0]] = 0;\n\t\trep(i,0,n) rep(j,0,r-1) {\n\t\t\tif (dp[i][j] == inf) continue;\n\t\t\tint from = v[j], to = v[j+1];\n\t\t\t// ??????????????????\n\t\t\tif (dist[from][to] != inf)\n\t\t\t\tdp[i][j+1] = min(dp[i][j+1], dp[i][j] + dist[from][to]);\n\t\t\t// ????????????\n\t\t\trep(k,0,n) { // k?????§?°´??????k????????????\n\t\t\t\tif (dist[from][i]==inf || diss[i][k]==inf || dist[k][to]==inf) continue; // ????????????????????§k?????§????????§to?????§\n\t\t\t\tdp[k][j+1] = min(dp[k][j+1], dp[i][j] + dist[from][i] + diss[i][k] + dist[k][to]);\n\t\t\t\t//printf(\"from=%d i=%d k=%d to=%d | dp[i][j]=%d dist[from][i]=%d diss[i][k]=%d dist[k][to]=%d\\n\",\n\t\t\t\t\t//from,i,k,to,dp[i][j], dist[from][i], diss[i][k], dist[k][to]);\n\t\t\t}\n\t\t}\n\n\t\tint ans = inf;\n\t\trep(i,0,n) ans = min(ans, dp[i][r-1]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 1e8;\nint s[1111];\nint l[222][222], w[222][222];\nint dp[1111][222];\n\nint main(int argc, char const *argv[])\n{\n\t// freopen(\"in.txt\", \"r\", stdin);\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint n, m;\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tif(i == j) {l[i][j] = 0, w[i][j] = 0;}\n\t\t\t\telse{l[i][j] = inf, w[i][j] = inf;}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u, v, t;\n\t\t\tchar op[2];\n\t\t\tcin >> u >> v >> t >> op;\n\t\t\tif(op[0] == 'L'){\n\t\t\t\tl[u][v] = min(l[u][v], t);\n\t\t\t\tl[v][u] = l[u][v];\n\t\t\t} else {\n\t\t\t\tw[u][v] = min(w[u][v], t);\n\t\t\t\tw[v][u] = w[u][v];\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\tl[i][j] = min(l[i][j], l[i][k]+l[k][j]);\n\t\t\t\t\tw[i][j] = min(w[i][j], w[i][k]+w[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint len; \n\t\tcin >> len;\n\t\t// cout << len << endl;\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tdp[1][i] = w[s[1]][i] + l[i][s[1]];\n\t\t}\n\t\tfor(int i = 2; i <= len; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + l[s[i-1]][k] + w[k][j] + l[j][s[i]]);\n\t\t\t\t\tif(j==k) dp[i][j] = min(dp[i][j], dp[i-1][k] + l[s[i-1]][s[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*for(int i = 1; i <= len; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tcout << dp[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tcout << *min_element(dp[len]+1, dp[len]+n+1) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define INF (1000000000)\n\nlong long land[200][200] , ship[200][200] ;\n\t\nint main(){\n\tlong long n,m;\n\twhile(cin >> n >> m && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tlong long a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tlong long r; cin >> r;\n\t\tlong long R[1000];\t\n\t\trep(i,r)cin >> R[i] , R[i]--;\n\t\t\n\t\tlong long dp[2][200];\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tlong long newCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,200)dp[bit%2][j] = INF;\n\t\t}\n\t\tlong long ret = INF;\n\t\trep(i,n){\n\t\t\tret = min(dp[(r-1)%2][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n,m;\nint dl[200][200], ds[200][200],dp[1001][200];\nconst int inf = 1000000000;\n\nint main() {\n while(cin >> n >> m, n) {\n  for (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dl[i][j] = ds[i][j] = inf;\n  for (int i = 0; i < n; i++)dl[i][i] = ds[i][i] = 0;\n  for (int i = 0; i < m; i++) {\n   int x,y,t;\n   char c;\n   cin >> x >> y >> t >> c;\n   x--, y--;\n   if (c == 'L') {\n    dl[x][y] = min(dl[x][y],t);\n    dl[y][x] = min(dl[y][x], t);\n   } else {\n    ds[x][y] = min(ds[x][y],t);\n    ds[y][x] = min(ds[y][x], t);\n   }\n  }\n  for (int k = 0; k < n; k++) {\n   for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n     dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n     ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n    }\n   }\n  }\n  int r, initz, pos;\n  cin >> r >> initz;\n  for (int i = 0; i < r; i++)for (int j = 0; j < n; j++)dp[i][j] = inf;\n  dp[0][initz] = 0;\n  pos = initz;\n  for (int i = 1; i < r; i++) {\n   int z;\n   cin >> z;\n   z--;\n   for (int j = 0; j < n; j++) {\n    dp[i][j] = min(dp[i][j], dp[i-1][j] + dl[pos][z]);\n    for (int k = 0; k < n; k++) {\n     dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[pos][k] + ds[k][j] + dl[j][z]);\n    }\n   }\n   pos = z;\n  }\n  int ans = inf;\n  for (int i = 0; i < n; i++) {\n   ans = min(ans, dp[r-1][i]);\n  }\n  cout << ans << endl;\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        const ll inf = ten(14);\n        ll land[256][256], sea[256][256];\n        rep(i, n) rep(j, n)\n            land[i][j] = sea[i][j] = i == j ? 0 : inf;\n        while (m--)\n        {\n            int x, y;\n            ll t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if (sl == 'L')\n                land[x][y] = land[y][x] = min(land[x][y], t);\n            else\n                sea[x][y] = sea[y][x] = min(sea[x][y], t);\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(land[i][j], land[i][k] + land[k][j]);\n            chmin(sea[i][j], sea[i][k] + sea[k][j]);\n        }\n\n        int r, z[1024];\n        cin >> r;\n        input(z, r);\n        rep(i, r)\n            --z[i];\n\n        ll dp[1024][256];\n        rep(i, r) rep(j, n)\n            dp[i][j] = inf;\n        dp[0][z[0]] = 0;\n        rep(i, r - 1) rep(j, n)\n        {\n            chmin(dp[i + 1][j], dp[i][j] + land[z[i]][z[i + 1]]);\n            rep(k, n)\n                chmin(dp[i + 1][k], dp[i][j] + land[z[i]][j] + sea[j][k] + land[k][z[i + 1]]);\n        }\n        ll res = *min_element(dp[r - 1], dp[r - 1] + n);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// ???????????£???????????????\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0xfffffff;\n\nstruct ST{\n\tll d;\n\tint z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nint v[2][205][205];\nint Z[1005];\nint dp[1005][205];\t\t// z, boat\nint ans[205];  // boat\n\nint solve(){\n\tpriority_queue<ST> que;\n\tll d, z, b, n;\n\n\tFill( dp, INF );\n\tdp[ 0 ][ Z[0] ] = 0;\n\tFill( ans, INF );\n\tans[ Z[0] ] = 0;\n\trep(z,R-1){\n\t\trep(b,N){\n\t\t\tchmin( dp[z+1][b], dp[z][b] + v[0][ Z[z] ][ Z[z+1] ] );\n\t\t\trep(nb, N){\n\t\t\t\tchmin( dp[z+1][nb], dp[z][b] + v[0][ Z[z] ][b] + v[1][b][nb] + v[0][nb][ Z[z+1] ] );\n\t\t\t}\n\t\t}\n\t\t//rep(b,N) cout << \"dp[\" << z+1 << \"][\" << b << \"] = \" << dp[z+1][b] << endl;\n\t\tcontinue;\n\t\trep(b,N) if( ans[b] < INF ){\n\t\t\tque.push( ST{ans[b], z, b, Z[z]} );\n\t\t}\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\twhile( !que.empty() ){\n\t\t\tST st = que.top();\n\t\t\tque.pop();\n\t\t\td = st.d;\n\t\t\t//z = st.z;\n\t\t\tb = st.b;\n\t\t\tn = st.n;\n\t\t\tif( dp[b][n] < d ) continue;\n\t\t\tdp[b][n] = d;\n//\t\t\tcout << \"hit \" << d << \" \" << z << \" \" << b << \" \" << n << endl;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t//\tfor(auto _v: v[k][n]){\n\t\t\t//\t\tint to = _v.first;\n\t\t\t//\t\tll cost = dp[b][n] + _v.second;\n\t\t\t//\t\tint nz = z, nb = b;\n\t\t\t//\t\tif( k ) nb = to;\n\t\t\t//\t\t//if( to == Z[z+1] ) nz++;\n\t\t\t//\t\tif( to == Z[z+1] ){\n\t\t\t//\t\t\tchmin( ans[nb], cost );\n\t\t\t//\t\t}else if( chmin(dp[nb][to], cost) ){\n\t\t\t//\t\t\tque.push( ST{ cost, nz, nb, to } );\n\t\t\t//\t\t}\n\t\t\t//\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = INF;\n\trep(b,N){\n\t\t//chmin( ret, ans[b] );\n\t\tchmin( ret, dp[R-1][b] );\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x, y, t;\n\tchar sl;\n\n\twhile(cin >> N >> M, N|M){\n\t\tFill(v, INF);\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x][y] = t;\n\t\t\t\tv[0][y][x] = t;\n\t\t\t}else{\n\t\t\t\tv[1][x][y] = t;\n\t\t\t\tv[1][y][x] = t;\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\n\t\trep(l,2) rep(i,N) v[l][i][i] = 0;\n\t\trep(l,2) rep(k,N) rep(i,N) rep(j,N) {\n\t\t\tchmin( v[l][i][j], v[l][i][k] + v[l][k][j] );\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  Created by Running Photon on 2015-04-10\n//  Copyright (c) 2015 Running Photon. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n#define ll long long\n#define CLR(x) memset(x, 0, sizeof x)\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int maxn = 2e2 + 10;\n\nint n, m;\nint costl[maxn][maxn], costs[maxn][maxn];\nint dp[1005][maxn];\nint a[1005];\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\twhile(scanf(\"%d%d\", &n, &m) && n && m){\n\t\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){\n\t\t\tcostl[i][j] = costs[i][j] = i == j ? 0 : (inf / 3);\n\t\t}\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tchar s[2];\n\t\t\tint x, y, val;\n\t\t\tscanf(\"%d%d%d%s\", &x, &y, &val, s);\n\t\t\tif(s[0] == 'L') costl[x][y] = costl[y][x] = min(val, costl[y][x]);\n\t\t\telse costs[x][y] = costs[y][x] = min(val, costs[y][x]);\n\t\t}\n\t\tint num;\n\t\tscanf(\"%d\", &num);\n\t\tfor(int i = 1; i <= num; scanf(\"%d\", a + i++));\n\t\tfor(int k = 1; k <= n; k++) for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){\n\t\t\tcosts[i][j] = min(costs[i][j], costs[i][k] + costs[k][j]);\n\t\t\tcostl[i][j] = min(costl[i][j], costl[i][k] + costl[k][j]);\n\t\t}\n\t\tmemset(dp, 0x3f, sizeof dp);\n\t\tdp[1][a[1]] = 0;\n\t\tint ans = inf;\n\t\tfor(int i = 1; i <= num; i++) for(int j = 1; j <= n; j++){\n\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + costl[a[i-1]][a[i]]);\n\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + costl[a[i-1]][j] + costs[j][k] + costl[k][a[i]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[n][i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000000\nint le[200][200];\nint se[200][200];\nint dp[2][200];\nint q[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tle[i][j]=INF;\n\t\t\tse[i][j]=INF;\n\t\t}\n\t\tle[i][i]=0;\n\t\tse[i][i]=0;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar t;\n\t\tscanf(\"%d %d %d %c\",&a,&b,&c,&t);\n\t\ta--;b--;\n\t\tif(t=='L'){\n\t\t\tle[a][b]=min(le[a][b],c);\n\t\t\tle[b][a]=min(le[b][a],c);\n\t\t}\n\t\telse{\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tle[i][j]=min(le[i][j],le[i][k]+le[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint nq;\n\tscanf(\"%d\",&nq);\n\tfor(i=0;i<nq;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t\tq[i]--;\n\t}\n\tfor(i=0;i<n;i++){dp[0][i]=se[q[0]][i]+le[i][q[0]];}\n\tfor(i=1;i<nq;i++){\n\t\tfor(j=0;j<n;j++)dp[i%2][j]=INF;\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][k]=min(dp[i%2][k],dp[(i+1)%2][j]+le[q[i-1]][j]+se[j][k]+le[k][q[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+le[q[i-1]][q[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(nq+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <utility>\n#include <vector>\n\nint testcase_ends() {\n  size_t n, m;\n  scanf(\"%zu %zu\", &n, &m);\n  if (n == 0) return 1;\n\n  intmax_t inf = 1e9;\n  std::vector<std::vector<intmax_t>> dl(n, std::vector<intmax_t>(n, inf));\n  auto ds = dl;\n  for (size_t i = 0; i < n; ++i) dl[i][i] = 0;\n\n  for (size_t i = 0; i < m; ++i) {\n    size_t x, y;\n    intmax_t t;\n    char c;\n    scanf(\"%zu %zu %jd %c\", &x, &y, &t, &c);\n    --x;\n    --y;\n    if (c == 'S') {\n      ds[x][y] = ds[y][x] = t;\n      ds[x][x] = ds[y][y] = 0;\n    } else if (c == 'L') {\n      dl[x][y] = dl[y][x] = t;\n    }\n  }\n\n  for (size_t k = 0; k < n; ++k)\n    for (size_t i = 0; i < n; ++i)\n      for (size_t j = 0; j < n; ++j) {\n        dl[i][j] = std::min(dl[i][j], dl[i][k]+dl[k][j]);\n        ds[i][j] = std::min(ds[i][j], ds[i][k]+ds[k][j]);\n      }\n\n  size_t r;\n  scanf(\"%zu\", &r);\n  std::vector<size_t> z(r);\n  for (auto& zi: z) {\n    scanf(\"%zu\", &zi);\n    --zi;\n  }\n\n  std::vector<std::vector<intmax_t>> dp(r, std::vector<intmax_t>(n, inf));\n  dp[0][z[0]] = 0;\n  for (size_t i = 0; i+1 < r; ++i) {\n    for (size_t j = 0; j < n; ++j) {\n      for (size_t k = 0; k < n; ++k) {\n        intmax_t dist = dp[i][j];\n        if (j != k) {\n          dist += dl[z[i]][j]+ds[j][k]+dl[k][z[i+1]];\n        } else {\n          dist += std::min(dl[z[i]][j]+ds[j][k]+dl[k][z[i+1]], dl[z[i]][z[i+1]]);\n        }\n        dp[i+1][k] = std::min(dp[i+1][k], dist);\n      }\n    }\n  }\n\n  printf(\"%jd\\n\", *std::min_element(dp[r-1].begin(), dp[r-1].end()));\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<sstream>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pa;\nconst int inf=1e8;\nint mml[205][205],mms[205][205],dp[1005][205],num[1005];\nint main(){\n    int n,m,a,b,c,r;\n    char str[5];\n    while(scanf(\"%d%d\",&n,&m)&&n){\n        for(int i=0;i<n;i++){\n            mml[i][i]=mms[i][i]=0;\n            for(int j=i+1;j<n;j++){\n                mml[i][j]=mml[j][i]=inf;\n                mms[i][j]=mms[j][i]=inf;\n            }\n        }\n        for(int i=0;i<m;i++){\n            scanf(\"%d%d%d%s\",&a,&b,&c,str);\n            a--,b--;\n            if(str[0]=='L'){\n                mml[a][b]=mml[b][a]=min(mml[a][b],c);\n            }else{\n                mms[a][b]=mms[b][a]=min(mms[a][b],c);\n            }\n        }\n        scanf(\"%d\",&r);\n        for(int i=0;i<r;i++){\n            scanf(\"%d\",&num[i]);\n            num[i]--;\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    mml[i][j]=min(mml[i][j],mml[i][k]+mml[k][j]);\n                    mms[i][j]=min(mms[i][j],mms[i][k]+mms[k][j]);\n                }\n            }\n        }\n        for(int i=0;i<r;i++){\n            for(int j=0;j<n;j++){\n                dp[i][j]=inf;\n            }\n        }\n        for(int i=0;i<n;i++){\n            dp[0][i]=mms[num[0]][i]+mml[i][num[0]];\n        }\n        int ans=inf;\n        for(int i=1;i<r;i++){\n            for(int j=0;j<n;j++){\n                for(int k=0;k<n;k++){\n                    if(j!=k)\n                        dp[i][k]=min(dp[i][k],dp[i-1][j]+mml[num[i-1]][j]+mms[j][k]+mml[k][num[i]]);\n                    else dp[i][j]=min(dp[i][j],dp[i-1][j]+mml[num[i-1]][num[i]]);\n                }\n            }\n        }\n        for(int i=0;i<n;i++){\n            ans=min(ans,dp[r-1][i]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dp[200][200];\nint ldist[200][200];\nint sdist[200][200];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n) {\n\t\t\tsdist[i][j] = ldist[i][j] = (i == j ? 0 : inf);\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\n\t\t\tscanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L')\tldist[x][y] = ldist[y][x] = min(ldist[y][x], t);\n\t\t\telse if (sl == 'S')\tsdist[x][y] = sdist[y][x] = min(sdist[y][x], t);\n\t\t}\n\t\trep(k, n)\trep(j, n)\trep(i, n) {\n\t\t\tsdist[i][j] = min(sdist[i][k] + sdist[k][j], sdist[i][j]);\n\t\t\tldist[i][j] = min(ldist[i][k] + ldist[k][j], ldist[i][j]);\n\t\t}\n\t\tint r;\tscanf(\"%d\", &r);\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tscanf(\"%d\", &z[i]);\tz[i]--;\n\t\t}\n\t\trep(i, n)\trep(j, n)\tdp[i][j] = inf;\n\t\trep(i, n)\tdp[i][i] = 0;\n\t\trep(i, n)\trep(j, n)\tdp[j][i] = min(dp[j][i], dp[i][i] + ldist[i][j]);\n\t\trep(i, n) {\n\t\t\tif (i != z[0])\trep(j, n)\tdp[i][j] = inf;\n\t\t}\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n)\tdp[k][j] = min(dp[k][j], dp[z[i - 1]][j] + ldist[z[i - 1]][k]);\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n)\tdp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k]);\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n)\tdp[k][j] = min(dp[k][j], dp[j][j] + ldist[j][k]);\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tif (j != z[i]) {\n\t\t\t\t\trep(k, n)\tdp[j][k] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[z[r - 1]][i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n\n    typedef tuple<int,int,int> tpl;\n    int dist[128][128];\n    fill_n((int*)dist,128*128,inf);\n    dist[z[0]][z[0]]=0;\n    rep(i,1,r){\n        priority_queue<tpl,vector<tpl>,greater<tpl>> que;\n        rep(j,0,n){\n            rep(k,0,n){\n                if(dist[j][k]==inf) continue;\n                if(j==z[i-1]) que.push(make_tuple(dist[j][k],j,k));\n                else dist[j][k]=inf;\n            }\n        }\n        while(!que.empty()){\n            auto t=que.top();\n            que.pop();\n            int d=get<0>(t),p1=get<1>(t),p2=get<2>(t);\n            if(d>dist[p1][p2]) continue;\n            for(auto &e:graph[p1][0]){\n                int d_=d+e.second,p_=e.first;\n                if(d_>=dist[p_][p2]) continue;\n                dist[p_][p2]=d_;\n                que.push(make_tuple(d_,p_,p2));\n            }\n            if(p1!=p2) continue;\n            for(auto &e:graph[p1][1]){\n                int d_=d+e.second,p_=e.first;\n                if(d_>=dist[p_][p_]) continue;\n                dist[p_][p_]=d_;\n                que.push(make_tuple(d_,p_,p_));\n            }\n        }\n    }\n    int ans=inf;\n    rep(i,0,n) ans=min(ans,dist[z.back()][i]);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct edge{\n    int to,cost;\n    bool S;\n    edge(int a,int b,bool c):to(a),cost(b),S(c){}\n};\n\nstruct data{\n    int pos,cost,ship,t;\n    data(int a,int b,int c,int d):pos(a),cost(b),ship(c),t(d){}\n    bool operator<(const data &d)const{\n        return cost>d.cost;\n    }\n};\n\nint N,M,T;\nvector<edge>G[200];\nvector<int>task;\nint dist[200][200][1001];\nconst int INF=1001001001;\nvoid solve(){\n    fill_n(**dist,200*200*1001,INF);\n    priority_queue<data>Q;\n    Q.push(data(task[0],0,task[0],0));\n    dist[task[0]][task[0]][0]=0;\n\n    while(Q.size()){\n        data d=Q.top();Q.pop();\n        if(d.t==T){\n            cout<<d.cost<<endl;\n            return;\n        }\n\n        if(dist[d.pos][d.ship][d.t]<d.cost)continue;\n\n        if(task[d.t]==d.pos){\n            if(dist[d.pos][d.ship][d.t+1]<=d.cost)continue;\n            dist[d.pos][d.ship][d.t+1]=d.cost;\n            Q.push(data(d.pos,d.cost,d.ship,d.t+1));\n            continue;\n        }\n\n        for(int i=0;i<G[d.pos].size();i++){\n            edge &e=G[d.pos][i];\n            if(e.S){\n                if(d.pos!=d.ship)continue;\n                if(dist[e.to][e.to][d.t]<=d.cost+e.cost)continue;\n                dist[e.to][e.to][d.t]=d.cost+e.cost;\n                Q.push(data(e.to,d.cost+e.cost,e.to,d.t));\n            }\n            else{\n                if(dist[e.to][d.ship][d.t]<=d.cost+e.cost)continue;\n                dist[e.to][d.ship][d.t]=d.cost+e.cost;\n                Q.push(data(e.to,d.cost+e.cost,d.ship,d.t));\n            }\n        }\n    }\n}\n\nint main(){\n\n    while(cin>>N>>M,N||M){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].push_back(edge(b,c,(d=='S')));\n            G[b].push_back(edge(a,c,(d=='S')));\n        }\n        cin>>T;\n        task.resize(T);\n        for(int i=0;i<T;i++)cin>>task[i],task[i]--;\n\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        d[i][j] = min(d[i][j], c);\n        d[j][i] = min(d[j][i], c);\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n    void disp() {\n        printVV(d);\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<WarshallFloyd> wf(2, WarshallFloyd(n));\n        rep(i, m) {\n            int a, b, c;\n            char t;\n            cin >> a >> b >> c >> t;\n            a--, b--;\n            wf[t == 'S'].setDist(a, b, c);\n        }\n\n        rep(k, 2) wf[k].calc();\n\n        int q;\n        cin >> q;\n        int s;\n        vi a(n, inf);\n        rep(i, q) {\n            int t;\n            cin >> t;\n            t--;\n            if (i == 0) {\n                a[t] = 0;\n            }\n            else {\n                vi b(n, inf);\n                rep(j, n) {\n                    chmin(b[j], a[j] + wf[0].getDist(s, t));\n                    rep(k, n) {\n                        if (j == k) continue;\n                        chmin(b[k], a[j] + wf[0].getDist(s, j) + wf[1].getDist(j, k) + wf[0].getDist(k, t));\n                    }\n                }\n                a = b;\n            }\n            s = t;\n        }\n\n        cout << *min_element(all(a)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n\n    //陸路と海路を別々に全点対最短路を求める\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    //dp[i][j]をjに船をおいてz[i]まで進んだ時にかかる最短の時間\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n          if(k==j) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cstring>\n#include <map>\n#include <string>\n#include <sstream>\n#include <set>\n#include <bitset>\n#include <cmath>\nusing namespace std;\n\nconst int maxn = 200 + 5, INF = 1e8, maxr = 1000 + 5;\n\nint n, m, r, d[2][maxn][maxn], z[maxr], dp[maxr][maxn];\n\nint main() {\n    while (cin >> n >> m && n) {\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                d[0][i][j] = d[1][i][j] = (i == j ? 0 : INF);\n        for (int i = 1; i <= m; ++i) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            if (sl == 'L') d[0][x][y] = d[0][y][x] = min(d[0][x][y], t);\n            else d[1][x][y] = d[1][y][x] = min(d[1][x][y], t);\n        }\n        for (int k = 1; k <= n; ++k)\n            for (int i = 1; i <= n; ++i)\n                for (int j = 1; j <= n; ++j) {\n                    d[0][i][j] = min(d[0][i][j], d[0][i][k] + d[0][k][j]);\n                    d[1][i][j] = min(d[1][i][j], d[1][i][k] + d[1][k][j]);\n                }\n        cin >> r;\n        for (int i = 1; i <= r; ++i) cin >> z[i];\n        for (int i = 2; i <= r; ++i)\n            for (int j = 1; j <= n; ++j)\n                dp[i][j] = INF;\n        for (int i = 1; i <= n; ++i)\n            dp[1][i] = d[1][z[1]][i] + d[0][i][z[1]];\n        for (int i = 2; i <= r; ++i)\n            for (int j = 1; j <= n; ++j)\n                for (int k = 1; k <= n; ++k)\n                    if (j != k) dp[i][j] = min(dp[i][j], dp[i - 1][k] + d[0][z[i - 1]][k] + d[1][k][j] + d[0][j][z[i]]);\n                    else dp[i][j] = min(dp[i][j], dp[i - 1][k] + d[0][k][z[i]]);\n        int ans = INF;\n        for (int i = 1; i <= n; ++i) ans = min(ans, dp[r][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nlong long dis1[210][210];\nlong long dis2[210][210];\nlong long dp[2][210];\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    rep (i, n) rep (j, n) dis1[i][j] = 1e18;\n    rep (i, n) rep (j, n) dis2[i][j] = 1e18;\n    rep (i, n) dis1[i][i] = 0;\n    rep (i, n) dis2[i][i] = 0;\n    rep (i, m) {\n      long long x, y, t;\n      string sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if (sl == \"L\") dis1[x][y] = dis1[y][x] = min(dis1[y][x], t);\n      else dis2[x][y] = dis2[y][x] = min(dis2[y][x], t);\n    }\n    rep (i, n) rep (j, n) rep (k, n) dis1[i][j] = min(dis1[i][j], dis1[i][k] + dis1[k][j]);\n    rep (i, n) rep (j, n) rep (k, n) dis2[i][j] = min(dis2[i][j], dis2[i][k] + dis2[k][j]);\n    int r, p;\n    cin >> r >> p;\n    --p;\n    rep (i, 2) rep (j, n) dp[i][j] = 1e18;\n    dp[p][p] = 0;\n    rep (_, r - 1) {\n      int q;\n      cin >> q;\n      --q;\n      rep (i, n) rep (j, n) dp[1][j] = min(dp[1][j], dp[0][i] + dis1[p][i] + dis2[i][j] + dis1[j][q]);\n      rep (i, n) dp[0][i] = dp[1][i];\n      rep (i, n) dp[1][i] = 1e18;\n      p = q;\n    }\n    long long res = 1e18;\n    rep (i, n) res = min(res, dp[0][i]);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\nconst int INF = 1 << 22;\nint N, M, R;\nvoid wf(VVI &adj){\n  for(int k = 0; k < N; ++k){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n      }\n    }\n  }\n}\nvoid print_adj(VVI adj){\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      if(adj[i][j] >= INF){\n\tcout << \"INF\" << \" \";\n      }\n      else{\n\tcout << adj[i][j] << \" \";\n      }\n    }\n    cout << endl;\n  }\n}\nvoid db_print(int line[]){\n  for(int i = 0; i < N; ++i){\n    if(line[i] >= INF){\n      cout << \"INF\" << \" \";\n    }\n    else{\n      cout << line[i] << \" \";\n    }\n  }\n  cout << endl;\n}\nint solve(VVI sea, VVI land, VI que){  \n  int table[R][N];\n  fill_n((int *) table, (R+1)*N, INF);\n  table[0][que[0]] = 0;\n  for(int r = 1; r < R; ++r){\n    //db_print(table[r-1]);\n    for(int from = 0; from < N; ++from){\n      for(int to = 0; to < N; ++to){\n\tif(from == to){\n\t  int cost = table[r-1][from];\n\t  cost += land[que[r-1]][que[r]];\n\t  table[r][to] = min(table[r][to], cost);\n\t}\n\telse{\n\t  int cost = table[r-1][from];\n\t  cost += land[que[r-1]][from];\n\t  cost += sea[from][to];\n\t  cost += land[to][que[r]];\n\t  table[r][to] = min(table[r][to], cost);\n\t}\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      if(table[r][i] > INF){\n\ttable[r][i] = INF;\n      }\n    }\n  }\n  int res = INF;\n  //db_print(table[R-1]);\n  for(int i = 0; i < N; ++i){\n    res = min(res, table[R-1][i]);\n  }\n  return res;\n}\nint main(){\n  while(true){\n    cin >> N >> M;\n    if((N|M) == 0){\n      break;\n    }\n    VVI sea(N, vector<int>(N, INF));\n    VVI land(N, vector<int>(N, INF));\n    for(int i = 0; i < N; ++i){\n      sea[i][i] = 0;\n      land[i][i] = 0;\n    }\n    for(int i = 0; i < M; ++i){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      if(sl == 'S'){\n\tsea[x][y] = sea[y][x] = min(sea[y][x], t);\n      }\n      else{\n\tland[x][y] = land[y][x] = min(land[y][x], t);\n      }\n    }\n    wf(sea); wf(land);    \n    //print_adj(sea);\n    //print_adj(land);\n    cin >> R;\n    vector<int> que(R);\n    for(int i = 0; i < R; ++i){\n      cin >> que[i];\n      --que[i];\n    }    \n    cout << solve(sea, land, que) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nconst int INF = 1e9;\n\ntypedef long long ll;\n\nll land[210][210];\nll sea[210][210];\nint N, M;\nint R;\nvector<int> z;\n\n// even/odd, ship\nll cost[2][210];\n\nint main() {\n\twhile(cin >> N >> M, N || M) {\n\t\t// init\n\t\tfor(int i = 0; i < 210; i++) {\n\t\t\tfor(int j = 0; j < 210; j++) {\n\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\tcost[0][i] = cost[1][i] = INF;\n\t\t}\n\t\tz.clear();\n\n\t\t// input\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tll x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == \"L\")\n\t\t\t\tland[x][y] = land[y][x] = min(land[x][y], t);\n\t\t\telse\n\t\t\t\tsea[x][y] = sea[y][x] = min(sea[x][y], t);\n\t\t}\n\t\tcin >> R;\n\t\tz.resize(R);\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tland[j][k] = min(land[j][k], land[j][i] + land[i][k]);\n\t\t\t\t\tsea[j][k] = min(sea[j][k], sea[j][i] + sea[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\tcout << sea[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tcost[0][z[0]] = 0;\n\t\tfor(int i = 1; i < z.size(); i++) {\n\t\t\tfor(int j = 0; j < 210; j++)\n\t\t\t\tcost[i%2][j] = INF;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tcost[i%2][j] = min(cost[i%2][j],\n\t\t\t\t\t\t\tland[z[i-1]][k] + sea[k][j] + land[j][z[i]] + cost[(i+1)%2][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tres = min(res, cost[(N-1)%2][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 1020\n#define INF 123456789\n\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>Q;\n\nint L[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint LD[MAX_N][MAX_N];\nint SD[MAX_N][MAX_N];\nint DP[MAX_N][MAX_N];\nint T[MAX_N], DIST[MAX_N];\nint A, B, C, N, M, R, res; char D;\n\nvoid dijkstra(int v, int st) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tDIST[i] = INF;\n\t}\n\tDIST[st] = 0;\n\tQ.push(make_pair(0, st));\n\twhile (!Q.empty()) {\n\t\tpair<int, int>p = Q.top(); Q.pop();\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (v == 1) {\n\t\t\t\tif (L[p.second][i] + p.first < DIST[i]) {\n\t\t\t\t\tDIST[i] = L[p.second][i] + p.first;\n\t\t\t\t\tQ.push(make_pair(DIST[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (S[p.second][i] + p.first < DIST[i]) {\n\t\t\t\t\tDIST[i] = S[p.second][i] + p.first;\n\t\t\t\t\tQ.push(make_pair(DIST[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tres = INF;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tL[i][j] = INF; S[i][j] = INF;\n\t\t\t\tLD[i][j] = INF; SD[i][j] = INF;\n\t\t\t\tDP[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A >> B >> C >> D;\n\t\t\tif (D == 'L') {\n\t\t\t\tL[A][B] = C;\n\t\t\t\tL[B][A] = C;\n\t\t\t}\n\t\t\tif (D == 'S') {\n\t\t\t\tS[A][B] = C;\n\t\t\t\tS[B][A] = C;\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> T[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdijkstra(1, i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tLD[i][j] = DIST[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdijkstra(2, i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tSD[i][j] = DIST[j];\n\t\t\t}\n\t\t}\n\t\tDP[0][T[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tint ST = T[i], GO = T[i + 1];\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + LD[ST][GO]);\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + LD[ST][j] + SD[j][k] + LD[k][GO]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    int land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<n;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      int b;cin>>b;b--;\n      a[i]=b;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(sea[i][k]!=inf && sea[k][j]!=inf)sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          if(land[i][k]!=inf && land[k][j]!=inf)land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    int dp[1001][201];\n    for(int i=0;i<r;i++)for(int j=0;j<n;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          if(land[a[i]][j]==inf)continue;\n          if(sea[j][k]==inf)continue;\n          if(land[k][a[i+1]]==inf)continue;\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n          if(j==k)dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][a[i+1]]);\n        }\n      }\n    }\n    for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        cout<<dp[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    int ans=inf;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\nint dp[1001][200];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(dp[0],dp[1001],INF);\n\t   dp[0][now]=0;\n\t    \n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF (1e9)\n#define M 1005\n#define N 205\nusing namespace std;\ntypedef pair<int,char> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,int> P2;\ntypedef pair<P2,P2> P3;\n\nvector<P1> G[N];\nint n,m,r,z[M];\n\nint d[N][N][M];\n\nint dijkstra(){\n  priority_queue<P3> q;\n  \n  d[0][0][0]=0;\n  q.push(P3(P2(0,0),P2(0,0)));\n\n  while(!q.empty()){\n    P3 t=q.top(); q.pop();\n    \n    int cost=t.first.first;\n    int hune=t.first.second;\n    int node=t.second.first;\n    int Z=t.second.second;\n    \n    if(Z==r-1)return cost;\n    if(cost>d[hune][node][Z])continue;\n\n    rep(i,G[node].size()){\n      int ncost=cost+G[node][i].second.first;\n      char sl=G[node][i].second.second;\n      int nnode=G[node][i].first;\n      int nhune=hune;\n      int nZ=Z;      \n      \n      if(sl=='S'&&hune!=node)continue;\n      if(z[Z+1]==nnode)nZ++;\n      if(sl=='S')nhune=nnode;\n\n      if(d[nhune][nnode][nZ]>ncost){\n\td[nhune][nnode][nZ]=ncost;\n\tq.push(P3(P2(ncost,nhune),P2(nnode,nZ)));\n      }\n    }\n    \n  }\n  \n  return INF;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    \n    int x,y,t;\n    char sl;\n    \n    rep(i,m){\n      cin>>x>>y>>t>>sl;\n      G[x-1].push_back(P1(y-1,P(t,sl)));\n      G[y-1].push_back(P1(x-1,P(t,sl)));\n    }\n    \n    cin>>r;\n    rep(i,r)cin>>z[i],z[i]--;\n\n    rep(i,n) rep(j,n) rep(k,M) d[i][j][k]=INF;\n    \n    cout<<dijkstra()<<endl;\n    \n    rep(i,n)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n#define debug(x) cout << #x << \" = \" << x << endl;\n#define sq(x) ((x)*(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nint Lcost[205][205];\nint Scost[205][205];\n\nint dp[1005][205];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tstatic const int INF = 1e8;\n\t\trep(i, n) rep(j, n){\n\t\t\tif(i == j) continue;\n\t\t\tLcost[i][j] = INF;\n\t\t\tScost[i][j] = INF;\n\t\t}\n\t\trep(i, m){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tLcost[x][y] = Lcost[y][x] = t;\n\t\t\t}else{\n\t\t\t\tScost[x][y] = Scost[y][x] = t;\n\t\t\t}\n\t\t}\n\t\trep(i, n) rep(j, n) rep(k, n){\n\t\t\tLcost[j][k] = min(Lcost[j][k], Lcost[j][i] + Lcost[i][k]);\n\t\t\tScost[j][k] = min(Scost[j][k], Scost[j][i] + Scost[i][k]);\n\t\t}\n\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, n){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i, r) rep(j, n) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 1; i < r; i++){\n\t\t\tint pos = z[i-1];\n\t\t\tint next = z[i];\n\t\t\trep(j, n){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j]+Lcost[pos][next]);\n\t\t\t\trep(k, n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+Lcost[pos][j]+Scost[j][k]+Lcost[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, n) ans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX\n#define EPS 1e-14\n\n#define LAND dist[0]\n#define SEA dist[1]\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> Triple;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\nconst int NMAX = 216, RMAX = 1024;\nlli dist[2][NMAX][NMAX]; // land, sea;\nlli dp[RMAX][NMAX][NMAX];\nlli N,M,R;\nvector<int> z_;\n\nint main() {\n  while (cin >> N >> M and N) {\n    REP(sl,2) REP(i,N) REP(j,N) { dist[sl][i][j] = (i == j ? 0:INF); }\n    REP(i,M) {\n      int x,y,t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      x--; y--;\n      dist[(sl == 'L'? 0:1)][x][y] = dist[(sl == 'L'? 0:1)][y][x] = t;\n    }\n    REP(sl,2) REP(k,N) REP(i,N) REP(j,N) {\n      chmin(dist[sl][i][j], dist[sl][i][k] + dist[sl][k][j]);\n    }\n    cin >> R;\n    REP(i,N) REP(j,N) { dp[R][i][j] = 0; }\n    z_.resize(R);\n    REP(i, R) { cin >> z_[i]; z_[i]--; }\n    RREP(r,R) REP(man,N) REP(ship,N) {\n      lli v = z_[r];\n      dp[r][man][ship] = dp[r+1][v][ship] + LAND[man][v];\n      REP(p,N) {\n        chmin(dp[r][man][ship], dp[r+1][v][p] + LAND[man][ship] + SEA[ship][p] + LAND[p][v]);\n      }\n    }\n    cout << dp[0][z_[0]][z_[0]] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\tlong long cnt = 0;\n\twhile (!Q.empty()) {\n\t\tif (cnt == 0) { return; }\n\t\tcnt = 0;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!Q.empty()) { Q.pop(); }\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,i,j,k,r,a[205],ans,map[205][205][2],dp[205][205];//map:0?????????1?°´???,dp[i][j]??¨?????°i??????????????¨j?????¶???????°???±?´?\nint main()\n{\n\twhile(~scanf(\"%d %d\",&n,&m)&&n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tmap[i][j][0]=2147483647;\n\t\t\t\tmap[i][j][1]=2147483647;\n\t\t\t}\n\t\t\tmap[i][i][0]=0;\n\t\t\tmap[i][i][1]=0;\n\t\t}\n\t\tint x,y,t,o;\n\t\tchar s;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%d %d %d %c\",&x,&y,&t,&s);\n\t\t\tif(s=='L')\n\t\t\t\to=0;\n\t\t\tif(s=='S')\n\t\t\t\to=1;\n\t\t\tmap[x][y][o]=min(map[x][y][o],t);\n\t\t\tmap[y][x][o]=map[x][y][o];\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\ta[0]=1;\n\t\tfor(k=1;k<=n;k++)\n\t\t{\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][k][0]<2147483647&&map[k][j][0]<2147483647)\n\t\t\t\t\t\tmap[i][j][0]=min(map[i][j][0],map[i][k][0]+map[k][j][0]);\n\t\t\t\t\tif(map[i][k][1]<2147483647&&map[k][j][1]<2147483647)\n\t\t\t\t\t\tmap[i][j][1]=min(map[i][j][1],map[i][k][1]+map[k][j][1]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=r;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tdp[i][j]=2147483647;\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tdp[0][i]=map[a[0]][i][1]+map[i][a[0]][0];\n\t\tfor(i=1;i<=r;i++)\n\t\t{\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][k]<2147483647&&map[a[i-1]][k][0]<2147483647)\n\t\t\t\t{\n\t\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(map[k][j][1]<2147483647&&map[j][a[i]][0]<2147483647)\n\t\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+map[a[i-1]][k][0]+map[k][j][1]+map[j][a[i]][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=2147483647;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=min(ans,dp[r][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <climits>\n\n#include <cstdio>\n \nusing namespace std;\n\n#define REP(var, count) for(int var=0; var<count; var++)\n\nconst int IPPAI = 214748364;\n\nint umi[210][210];\nint riku[210][210];\n\nint cmpl[1010][210]; //??????????????§?????????????????????\nbool used[1010][210];\n\nbool solve(void) {\n    int N, M;\n   \n    cin >> N >> M;\n    if ( N == 0 ) { return false; }\n   \n    REP(i, 210) REP(j, 210) {\n        int a = (i==j) ? 0 : IPPAI;\n        umi[i][j] = a;\n        riku[i][j] = a;\n    }\n   \n    REP(i, M) {\n        int x, y, l;\n        char ty;\n        cin >> x >> y >> l >> ty;\n       \n        if (ty == 'L') {\n            riku[x][y] = l;\n            riku[y][x] = l;\n        } else {\n            umi[x][y] = l;\n            umi[y][x] = l;\n        }\n    }\n   \n    // ???\n    for(int k=1; k<=N; k++) {\n        for(int i=1; i<=N; i++) {\n            for(int j=1; j<=N; j++) {\n                umi[i][j] = std::min(umi[i][j], umi[i][k] + umi[k][j]);\n                riku[i][j] = std::min(riku[i][j], riku[i][k] + riku[k][j]);\n            }\n        }\n    }\n\n    int R;\n    int list[1010];\n    cin >> R;\n    REP(i, R) { cin >> list[i]; }\n   \n    typedef pair<int, pair<int, int> > P;\n    priority_queue<P, vector<P>, greater<P> > que;\n   \n    REP(i, 210) REP(f, 1010) {\n        cmpl[f][i] = IPPAI;\n        used[f][i] = false;\n    }\n    cmpl[0][ list[0] ] = 0;\n    que.push( make_pair(0, make_pair(0, list[0]) ) );\n   \n    while ( !que.empty() ) {\n        P p = que.top(); que.pop();\n        pair<int, int> pa = p.second;\n       \n        int adv = pa.first;\n        int nowpos  = list[adv];\n        int funepos = pa.second;\n       \n        if ( cmpl[adv][funepos] < p.first ) { continue; }\n        if ( adv+1 >= R ) { continue; }\n       \n        for(int i=1; i<=N; i++) {\n            // 1????????????????????????i???\n           \n            int nextpos = list[adv+1];\n           \n            int cost;\n           \n\t\t   //cout << \"adv=\" << adv << \", funepos=\" << funepos << \", i=\" << i << endl;\n            // ??????????????????\n            if ( funepos == i ) {\n                if ( riku[nowpos][nextpos] == IPPAI ) { continue; }\n                cost = riku[nowpos][nextpos];\n            } else {\n                // ????????\\?????´??????????????°???????????§????????§??????\n                if ( riku[nowpos][funepos] == IPPAI ) { continue; }\n                cost = riku[nowpos][funepos];\n               \n                // ?????§ i ?????§?§??????????\n                if ( umi[funepos][i] == IPPAI ) { continue; }\n                cost += umi[funepos][i];\n           \n                if ( riku[i][nextpos] == IPPAI ) { continue; }\n                cost += riku[i][nextpos];\n\t\t\t\t\n\t\t\t\t//cout << riku[nowpos][funepos] << \" \" << umi[funepos][i] << \" \" << riku[i][nextpos] << endl;\n            }\n\t\t\t//cout << \"cost = \" << cost << endl;\n           \n            if ( cmpl[adv+1][i] > cmpl[adv][funepos] + cost ) {\n                cmpl[adv+1][i] = cmpl[adv][funepos] + cost;\n                que.push( make_pair(cmpl[adv+1][i], make_pair(adv+1, i) ) );\n            }\n        }\n    }\n   \n    int ret = IPPAI;\n    for(int i=1; i<=N; i++) {\n        ret = std::min(ret, cmpl[R-1][i]);\n    }\n\t\n\tcout << ret << endl;\n   \n    return true;\n}\n\nint main(void) {\n    while( solve() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=(k);i++)\n#define INF ((int)1<<29)\n#define mk(i,j) make_pair(i,j)\n\n#define N 200\n#define M 10000\n#define R 1000\nint sdst[N][N];\nint ldst[N][N];\nint dp[R+1][N];\n\nusing namespace std;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n)break;\n\t\trep(i,n)rep(j,n){\n\t\t\tsdst[i][j] = ldst[i][j] = i==j?0:INF;\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin >> x >> y >> t;\n\t\t\tx--;y--;\n\t\t\tcin >> s;\n\t\t\tif(s[0]=='L'){\n\t\t\t\tldst[x][y] = ldst[y][x] = min(ldst[x][y],t);\n\t\t\t}else{\n\t\t\t\tsdst[x][y] = sdst[y][x] = min(sdst[x][y],t);\n\t\t\t}\n\t\t\t//cout << x << \" \" << y << \" \" << t << \" \" << s << endl;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tldst[i][j] = min(ldst[i][j],ldst[i][k] + ldst[k][j]);\n\t\t\tsdst[i][j] = min(sdst[i][j],sdst[i][k] + sdst[k][j]);\n\t\t}\n\t\tint r,zp;\n\t\tcin >> r;\n\t\trep(i,r)rep(j,n)dp[i][j]=INF;\n\t\tcin >> zp;\n\t\tzp--;\n\t\tdp[0][zp]=0;\n\t\trep(i,r-1){\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t\trep(j,n)rep(k,n){\n\t\t\t\tdp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t dp[i][j] + (j==k?ldst[zp][z]:ldst[zp][j] + sdst[j][k] + ldst[k][z]));\n\t\t\t}\n\t\t\tzp = z;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i,n)ans = min(dp[r-1][i],ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\n#define rep(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\ntypedef long long LL;\nconst int INF = 0x3f3f3f3f;\nint n, m, q, x, y, z, d[1010];\nchar c;\nint dl[210][210], ds[210][210], dp[1010][210];\nint main() {\n\twhile (~scanf(\"%d%d\",&n,&m),n+m)\n\t{\n\t\trep(i, n) rep(j, n) ds[i][j] = dl[i][j] = i == j ? 0 : INF;\n\t\trep(i, m) {\n\t\t\tscanf(\"%d%d%d %c\", &x, &y, &z, &c);\n\t\t\tif (c == 'S') ds[x][y] = ds[y][x] = min(ds[x][y], z);\n\t\t\telse dl[x][y] = dl[y][x] = min(dl[x][y], z);\n\t\t}scanf(\"%d\", &q);\n\t\trep(i, q) scanf(\"%d\", d + i);\n\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t}memset(dp, INF, sizeof(dp));\n\t\tdp[1][d[1]] = 0;\n\t\trep(i, q) rep(j, n) {\n\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + dl[d[i - 1]][d[i]]);\n\t\t\trep(k, n) dp[i][k] = min((LL)dp[i][k], (LL)dp[i - 1][j] + dl[d[i - 1]][j] + ds[j][k] + dl[k][d[i]]);\n\t\t}printf(\"%d\\n\", *min_element(dp[q], dp[q] + n + 1));\n\t}return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <bitset>\n#include <set>\n#include <queue>\n\n#define FOR(i, a, b) for(int i = (int)a; i < (int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\nusing ll = long long;\ntemplate <class T, class U> void CHMAX(T & a, const U & b) { if (a < b) a = b; }\ntemplate <class T, class U> void CHMIN(T& a, const U& b) { if (a > b) a = b; }\n\nconstexpr int INF = (1 << 30) - 1;\n\n\n\nsigned main() {\n\tint n, m;\n\twhile (std::cin >> n >> m, n || m) {\n\t\tstd::vector<int> a(m), b(m), c(m);\n\t\tstd::vector<char> s(m);\n\t\tREP(i, m) std::cin >> a[i] >> b[i] >> c[i] >> s[i], --a[i], --b[i];\n\t\tint r;\n\t\tstd::cin >> r;\n\t\tstd::vector<int> z(r);\n\t\tREP(i, r) std::cin >> z[i], --z[i];\n\n\t\tstd::vector<std::vector<ll>> gl(n, std::vector<ll>(n, INF)), gs(n, std::vector<ll>(n, INF));\n\t\tREP(i, n) gl[i][i] = gs[i][i] = 0;\n\n\t\tREP(i, m) {\n\t\t\tif (s[i] == 'L') gl[a[i]][b[i]] = gl[b[i]][a[i]] = c[i];\n\t\t\tif (s[i] == 'S') gs[a[i]][b[i]] = gs[b[i]][a[i]] = c[i];\n\t\t}\n\t\tREP(k, n) REP(i, n) REP(j, n) CHMIN(gl[i][j], gl[i][k] + gl[k][j]);\n\t\tREP(k, n) REP(i, n) REP(j, n) CHMIN(gs[i][j], gs[i][k] + gs[k][j]);\n\n\t\tstd::vector<ll> cur(n, INF), nex(n, INF);\n\t\tcur[z[0]] = 0;\n\t\tREP(k, r - 1) {\n\t\t\tREP(i, n) CHMIN(nex[i], cur[i] + gl[z[k]][z[k + 1]]);\n\t\t\tREP(i, n) REP(j, n) {\n\t\t\t\tCHMIN(nex[j], cur[i] + gl[z[k]][i] + gs[i][j] + gl[j][z[k + 1]]);\n\t\t\t}\n\t\t\tcur.swap(nex);\n\t\t\tREP(i, n) nex[i] = INF;\n\t\t}\n\n\t\tll ans = INF;\n\t\tREP(i, n) CHMIN(ans, cur[i]);\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\nint n,m,R;\nvector<pii> riku[210],umi[210];\nint route[210];\nint lan[210][210],sea[210][210];\ni64 dp[2][210];\n\nvoid solve() {\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                chmin(lan[j][k],lan[j][i]+lan[i][k]);\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                chmin(sea[j][k],sea[j][i]+sea[i][k]);\n            }\n        }\n    }\n    init(dp,inf<int>);\n    int now=0;\n    i64 ans=inf<int>;\n    dp[now][route[0]]=0;\n    for(int r=1; r<R; ++r,now^=1) {\n        init(dp[now^1],inf<int>);\n        for(int i=0; i<n; ++i) {\n            if(dp[now][i]>=inf<int>) continue;\n            for(int j=0; j<n; ++j) {\n                if(i==j) {\n                    chmin(dp[now^1][j],dp[now][i]+lan[route[r]][route[r-1]]);\n                } else {\n                    chmin(dp[now^1][j],dp[now][i]+lan[route[r-1]][i]+sea[i][j]+lan[route[r]][j]);\n                }\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        chmin(ans,dp[now][i]);\n    }\n    writeln(ans);\n}\n\nsigned main() {\n    while(true) {\n        cin>>n>>m;\n        if(!n) break;\n        init(lan,inf<int>);\n        init(sea,inf<int>);\n        for(int i=0; i<n; ++i) lan[i][i]=sea[i][i]=0;\n        for(int i=0; i<n; ++i) {\n            riku[i].clear();\n            umi[i].clear();\n        }\n        for(int _=0; _<m; ++_) {\n            int x,y,t;\n            char sl;\n            cin>>x>>y>>t>>sl;\n            x--,y--;\n            if(sl=='L') {\n                riku[x].emplace_back(y,t);\n                riku[y].emplace_back(x,t);\n                chmin(lan[x][y],t);\n                chmin(lan[y][x],t);\n            } else {\n                umi[x].emplace_back(y,t);\n                umi[y].emplace_back(x,t);\n                chmin(sea[x][y],t);\n                chmin(sea[y][x],t);\n            }\n        }\n        cin>>R;\n        for(int i=0; i<R; ++i) {\n            cin>>route[i];\n            route[i]--;\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst long long INF = 1LL<<60;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N) {\n        vector<vector<long long> > dps(N, vector<long long>(N, INF)), dpl(N, vector<long long>(N, INF));\n        for (int v = 0; v < N; ++v) dps[v][v] = dpl[v][v] = 0;\n        for (int e = 0; e < M; ++e) {\n            int x, y;\n            long long w;\n            char type;\n            cin >> x >> y >> w >> type;\n            --x, --y;\n            if (type == 'L') chmin(dpl[x][y], w), chmin(dpl[y][x], w);\n            else chmin(dps[x][y], w), chmin(dps[y][x], w);\n        }\n        for (int k = 0; k < N; ++k) {\n            for (int i = 0; i < N; ++i) {\n                for (int j = 0; j < N; ++j) {\n                    dpl[i][j] = min(dpl[i][j], dpl[i][k] + dpl[k][j]);\n                    dps[i][j] = min(dps[i][j], dps[i][k] + dps[k][j]);\n                }\n            }\n        }\n        \n        int R; cin >> R;\n        vector<int> v(R);\n        for (int i = 0; i < R; ++i) cin >> v[i], --v[i];\n        \n        vector<vector<long long> > dp(R, vector<long long>(N, INF));\n        dp[0][0] = 0;\n        for (int i = 0; i < R-1; ++i) {\n            for (int j = 0; j < N; ++j) {\n                for (int k = 0; k < N; ++k) {\n                    dp[i+1][k] = min(dp[i+1][k], dp[i][j] + dpl[v[i]][j] + dps[j][k] + dpl[k][v[i+1]]);\n                }\n            }\n        }\n        long long res = INF;\n        for (int i = 0; i <= R-1; ++i) {\n            res = min(res, dp[R-1][i]);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(n,n,INF);\n        auto Sd = vectors(n,n,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        auto v = vectors(r,INF);\n        rep(i,r) cin >> v[i],--v[i];\n        auto dp = vectors(n,n,INF);\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Sd[v[i]][k];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int MAX_N = 210;\nconst int MAX_T = 1005;\nconst int INF = 2*MAX_N*MAX_T;\nint N,M,R;\nint sea[MAX_N][MAX_N];\nint land[MAX_N][MAX_N];\nconst int MAX_R = 1005;\nint O[MAX_R];\nint dp[MAX_R][MAX_N];\nvoid show(char s) {\n    printf(\"\\n\");\n    if (s == 'L') {\n        printf(\"Land\\n\");\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                int n = land[i][j];\n                if (n == INF) printf(\"INF \");\n                else printf(\"%d \", n);\n            }\n            printf(\"\\n\");\n        }\n    } else if (s == 'S') {\n        printf(\"Sea\\n\");\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                int n = sea[i][j];\n                if (n == INF) printf(\"INF \");\n                else printf(\"%d \", n);\n            }\n            printf(\"\\n\");\n        }\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &M);  //町の番号は1~Nにする\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (i == j) {\n                    sea[i][j] = land[i][j] = 0;\n                } else {\n                    sea[i][j] = land[i][j] = INF;\n                }\n            }\n        }\n        for (int i = 0; i < M; i++) {\n            int x,y,t;\n            char s;\n            scanf(\"%d %d %d %c\", &x, &y, &t, &s);\n            if (s == 'L') {\n                land[x][y] = land[y][x] = t;\n            } else if (s == 'S'){\n                sea[x][y] = sea[y][x] = t;\n            }\n        }\n        scanf(\"%d\", &R);\n        \n        for (int i = 0; i < R; i++) {\n            scanf(\"%d\", &O[i]);\n        }\n        \n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n                    sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n                }\n            }\n        }\n        //確認\n        //show('L');\n        //show('S');\n        for (int i = 1; i <= N; i++) dp[0][i] = INF;\n        dp[0][O[0]] = 0;\n        \n        \n        for (int i = 1; i < R; i++) {\n            for (int j = 1; j <= N; j++) {\n                int minD = INF;\n                for (int k = 1; k <= N; k++) {\n                    if (j == k) {\n                        minD = min(minD, dp[i-1][j] + land[O[i-1]][O[i]]);\n                    } else {\n                        minD = min(minD, dp[i-1][k] + land[O[i-1]][k] + sea[k][j] + land[j][O[i]]);\n                    }\n                    //printf(\"minD=%d\\n\",minD);\n                }\n                dp[i][j] = minD;\n            }\n        }\n        int ret = INF;\n        for (int i = 1; i <= N; i++) ret = min(ret, dp[R-1][i]);\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#define IL inline\n#define RG register\n#define db double\n#define pi acos(-1.0)\n#define inf 0x3f3f3f3f\n#define LL long long\n#define N 205\nusing namespace std;\nIL int gi()\n{\n\tRG int res=0,s=1;RG char ch;\n\tfor(ch=getchar(); (ch<'0'||ch>'9')&&ch!='-' ;ch=getchar());\n\tif(ch=='-') s=-1,ch=getchar();\n\tfor(;ch>='0'&&ch<='9';ch=getchar()) res=10*res+ch-48;\n\treturn res*s;\n}\nint dis1[N][N],dis2[N][N],map1[N][N],map2[N][N];\nint n,m,r,pos[1005];LL dp[1005][N];\n//1:land    2:water\nIL void init()\n{\n\tmemset(map1,inf,sizeof(map1));\n\tmemset(map2,inf,sizeof(map2));\n\tfor(RG int i=1;i<=n;++i) map1[i][i]=map2[i][i]=0;\n}\nIL void pre()\n{\n\tfor(RG int i=1;i<=n;++i)\n\t\tfor(RG int j=1;j<=n;++j)\n\t\t\tdis1[i][j]=map1[i][j],\n\t\t\t\tdis2[i][j]=map2[i][j];\n\tfor(RG int k=1;k<=n;++k)\n\t\tfor(RG int i=1;i<=n;++i)\n\t\t\tfor(RG int j=1;j<=n;++j){\n\t\t\t\tdis1[i][j]=min(dis1[i][j],dis1[i][k]+dis1[k][j]),dis1[j][i]=dis1[i][j];\n\t\t\t\tdis2[i][j]=min(dis2[i][j],dis2[i][k]+dis2[k][j]),dis2[j][i]=dis2[i][j];\n\t\t\t}\n}\nIL void work()\n{\n\tfor(RG int i=1;i<=r;++i)\n\t\tfor(RG int j=1;j<=n;++j)\n\t\t\tdp[i][j]=1e15;\n\tdp[1][pos[1]]=0;\n\tfor(RG int p=2;p<=r;++p)\n\t\t{\n\t\t\tfor(RG int u=1;u<=n;++u)\n\t\t\t\t{\n\t\t\t\t\tif(dp[p-1][u]>=1e15||dis1[pos[p-1]][u]>=inf) continue;\n\t\t\t\t\tfor(RG int v=1;v<=n;++v)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdp[p][v]=min(dp[p][v],dp[p-1][u]+(LL)dis1[pos[p-1]][u]+(LL)dis2[u][v]+(LL)dis1[v][pos[p]]);\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\tRG LL ans=1e15;\n\tfor(RG int i=1;i<=n;++i)\n\t\tans=min(ans,dp[r][i]);\n\tprintf(\"%lld\\n\",ans);\n}\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tRG int u,v,len;RG char ch;\n\twhile(true)\n\t\t{\n\t\t\tn=gi(),m=gi(); if(!n&&!m) break; init();\n\t\t\tfor(RG int i=1;i<=m;++i){\n\t\t\t\tu=gi(),v=gi(),len=gi();\n\t\t\t\tfor(ch=getchar();ch!='L'&&ch!='S';ch=getchar());\n\t\t\t\tif(ch=='L') map1[u][v]=min(map1[u][v],len),map1[v][u]=map1[u][v];\n\t\t\t\telse map2[u][v]=min(map2[u][v],len),map2[v][u]=map2[u][v];\n\t\t\t}\n\t\t\tpre(); r=gi();\n\t\t\tfor(RG int i=1;i<=r;++i) pos[i]=gi();\n\t\t\twork();\n\t\t}\n\t//fclose(stdin);fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint const MAX_N = 210;\nint const MAX_R = 1010;\nint const INF = 1<<29;\nll dpl[MAX_N][MAX_N];\nll dps[MAX_N][MAX_N];\nll dp[MAX_R][MAX_N];\nll N, M, R;\nint z[MAX_R];\n\nint main() {\n     \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dpl[i][j] = dpl[j][i] = INF;\n        dps[i][j] = dps[j][i] = INF;\n      }\n      dpl[i][i] = 0;\n      dps[i][i] = 0;\n    }\n     \n    for(int i=0; i<M; i++) {\n      int x, y, c; char ls;\n      cin >> x >> y >> c >> ls; x--, y--;\n      if(ls == 'L') {\n        dpl[x][y] = dpl[y][x] = c;\n      }\n      else {\n        dps[x][y] = dps[y][x] = c;\n      }\n    }\n     \n    cin >> R;\n    for(int i=0; i<R; i++) {\n      cin >> z[i]; z[i] --;\n    }\n     \n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          dpl[i][j] = min(dpl[i][j], dpl[i][k]+dpl[k][j]);\n          dps[i][j] = min(dps[i][j], dps[i][k]+dps[k][j]);\n        }\n      }\n    }\n \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++)\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s] + dpl[z[i-1]][s] + dps[s][t] + dpl[t][z[i]]);\n          dp[i][t] = min(dp[i][t], dp[i-1][t] + dpl[z[i-1]][z[i]]);\n        }\n    }\n          \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\n\nconst ll INF = 1e17;\n\nint main(){\n  ll n,m,r;\n  while(cin >> n >> m){\n    if(n==0)break;\n    vector< vi > sg(n,vi(n,INF)), lg(n,vi(n,INF));\n    rep(i,n)sg[i][i] = lg[i][i] = 0;\n\n    rep(i,m){\n      ll x,y,t;\n      string s;\n      cin >> x >> y >> t >> s; x--; y--;\n      if(s == \"L\")lg[x][y] = lg[y][x] = t;\n      else sg[x][y] = sg[y][x] = t;\n    }\n\n    rep(k,n)rep(i,n)rep(j,n)lg[i][j] = min(lg[i][j], lg[i][k] + lg[k][j]);\n    rep(k,n)rep(i,n)rep(j,n)sg[i][j] = min(sg[i][j], sg[i][k] + sg[k][j]);\n\n    /*\n    rep(i,n){rep(j,n)cout << lg[i][j] << \" \"; cout << endl;}\n    rep(i,n){rep(j,n)cout << sg[i][j] << \" \"; cout << endl;}\n    */\n\n    cin >> r;\n    ll cur; cin >> cur; cur--;\n    vi dis(n,INF); dis[cur] = 0;\n\n    rep(z,r-1){\n      ll nxt; cin >> nxt; nxt--;\n      vi ndis(n,INF);\n\n      rep(i,n){\n\trep(j,n){\n\t  ndis[j] = min(ndis[j], dis[i] + lg[cur][i] + sg[i][j] + lg[j][nxt]);\n\t}\n      }\n\n      dis = ndis;\n      cur = nxt;\n    }\n\n    cout << *min_element(dis.begin(), dis.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=(k);i++)\n#define INF ((int)1<<29)\n#define mk(i,j) make_pair(i,j)\n\n#define N 200\n#define M 10000\n#define R 1000\nint sdst[N][N];\nint ldst[N][N];\nint dp[R+1][N];\n\nusing namespace std;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n)break;\n\t\trep(i,n)rep(j,n){\n\t\t\tsdst[i][j] = ldst[i][j] = i==j?0:INF;\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin >> x >> y >> t;\n\t\t\tx--;y--;\n\t\t\tcin >> s;\n\t\t\tif(s[0]=='L'){\n\t\t\t\tldst[x][y] = ldst[y][x] = min(ldst[x][y],t);\n\t\t\t}else{\n\t\t\t\tsdst[x][y] = sdst[y][x] = min(sdst[x][y],t);\n\t\t\t}\n\t\t\t//cout << x << \" \" << y << \" \" << t << \" \" << s << endl;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tldst[i][j] = min(ldst[i][j],ldst[i][k] + ldst[k][j]);\n\t\t\tsdst[i][j] = min(sdst[i][j],sdst[i][k] + sdst[k][j]);\n\t\t}\n\t\tint r,zp;\n\t\tcin >> r;\n\t\trep(i,r)rep(j,n)dp[i][j]=INF;\n\t\tcin >> zp;\n\t\tzp--;\n\t\tdp[0][zp]=0;\n\t\trep(i,r-1){\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t\trep(j,n)rep(k,n){\n\t\t\t\tdp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t dp[i][j] + (j==k?ldst[zp][z]:ldst[zp][j] + sdst[j][k] + ldst[k][z]));\n\t\t\t}\n\t\t\tzp = z;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i,n)ans = min(dp[r-1][i],ans);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst long long INF = (1LL<<59);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &st) const { return d > st.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<long long> > L(n,vector<long long>(n,INF)), S(n,vector<long long>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b;\n      long long c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n\n    \n    for(int k=0;k<n;k++){\n      L[k][k] = S[k][k] = 0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int l=0;l<2;l++){\n\t    if(l == 0){\n\t      if(L[i][k] >= INF || L[k][j] >= INF) continue;\n\t      L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t    }\n\t    else{\n\t      if(S[i][k] >= INF || S[k][j] >= INF) continue;\n\t      S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<long long> > dp(2,vector<long long>(n,INF));\n    dp[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){\n      for(int j=0;j<n;j++){\n\tif(dp[0][j] >= INF || L[dest[i-1]][j] >= INF) continue;\n\tfor(int k=0;k<n;k++){\n\t  if(S[j][k] >= INF || L[k][dest[i]] >= INF) continue;\n\t  dp[1][k] = min(dp[1][k], dp[0][j] + L[dest[i-1]][j] + S[j][k] + L[k][dest[i]]);\n\t}\n      }\n      dp[0].assign(dp[1].begin(),dp[1].end());\n      dp[1].assign(n,INF);\n    }\n\n    long long ans = INF;\n    for(int i=0;i<n;i++) ans = min(ans,dp[0][i]);\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define int long long\ntypedef pair<int, int> p;\nconst int INF = 1e16;\n\nint dp[1001][201];\n\nint ld[201][201];\nint sd[201][201];\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\trep(i, 201)rep(j, 201) {\n\t\t\tld[i][j] = sd[i][j] = INF;\n\t\t}\n\t\trep(i, 1001)rep(j, 201) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--; y--;\n\t\t\tif (s == 'S') {\n\t\t\t\tsd[y][x] = sd[x][y] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld[y][x] = ld[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tdp[0][z[0]] = 0;\n\t\trep(i, r-1) {\n\t\t\trep(s, n) {\n\t\t\t\t//z[i]テ」ツ?凝」ツつ越[i+1]テ」ツ?ク\n\t\t\t\t//ティツ按ケテ」ツ?ョテ、ツスツ催ァツスツョテ」ツ?茎\n\t\t\t\ttypedef tuple<int, int, int> p;\n\t\t\t\tint me[201][201];\n\t\t\t\trep(i, 201)rep(j, 201) {\n\t\t\t\t\tme[i][j] = INF;\n\t\t\t\t}\n\t\t\t\tpriority_queue<p,vector<p>,greater<p>> q;\n\t\t\t\tq.push(p(dp[i][s], z[i], s));\n\t\t\t\tme[z[i]][s] = dp[i][s];\n\t\t\t\twhile (q.size()) {\n\t\t\t\t\tint cost = get<0>(q.top());\n\t\t\t\t\tint nw = get<1>(q.top());\n\t\t\t\t\tint sh = get<2>(q.top());\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif (me[nw][sh] < cost)continue;\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tif (me[j][sh] > ld[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\tme[j][sh] = ld[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\tq.push(p(me[j][sh], j, sh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sh == nw) {\n\t\t\t\t\t\t\tif (me[j][j] > sd[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\t\tme[j][j] = sd[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\t\tq.push(p(me[j][j], j, j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(sh, n) {\n\t\t\t\t\tdp[i + 1][sh] = min(dp[i + 1][sh], me[z[i + 1]][sh]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(s, n) {\n\t\t\tans = min(ans, dp[r - 1][s]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<int,int,int> tpl;\n    static int dist[100][100][1001];\n    fill_n((int*)dist,100*100*1001,inf);\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    dist[z[0]][z[0]][1]=true;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        if(d>dist[p1][p2][num]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p2][num_]) continue;\n            dist[p_][p2][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p2,num_)));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p_][num_]) continue;\n            dist[p_][p_][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p_,num_)));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef TIII state;\nint INF;\nint distS[222][222];\nint distL[222][222];\nint z[1111];\nint DP[2][222];\n\nint main(){\n\tINF = 500000000;\n\twhile(1){\n\t\tint n,m,r;\n\t\tcin>>n>>m;\n\t\tif(n==0)return 0;\n\t\tREP(i,222)REP(j,222)distS[i][j] = INF;\n\t\tREP(i,222)REP(j,222)distL[i][j] = INF;\n\t\tREP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--, y--;\n\t\t\tif(sl=='L')distL[y][x] = distL[x][y] = min(distL[x][y], t);\n\t\t\telse distS[y][x] = distS[x][y] = min(distS[x][y], t);\n\t\t}\n\t\tREP(i,n)distL[i][i] = 0;\n\t\tREP(i,n)distS[i][i] = 0;\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,i){\n\t\t\t\t\tdistL[i][j] = distL[j][i] = min(distL[i][j], distL[i][k] + distL[k][j]);\n\t\t\t\t\tdistS[i][j] = distS[j][i] = min(distS[i][j], distS[i][k] + distS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>r;\n\t\tREP(i,r){\n\t\t\tscanf(\"%d\", &z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\tREP(i,222)DP[0][i] = INF;\n\t\tDP[0][z[0]]=0;\n\t\tFOR(i,1,r){\n\t\t\tREP(j,222)DP[i%2][j]=INF;\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,n){\n\t\t\t\t\tif(j==k)DP[i%2][k] = min(DP[i%2][k], DP[(i+1)%2][j]+distL[z[i-1]][z[i]]);\n\t\t\t\t\telse DP[i%2][k] = min(DP[i%2][k], DP[(i+1)%2][j]+distL[z[i-1]][j]+distS[j][k]+distL[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tREP(i,n)ret = min(ret, DP[(r+1)%2][i]);\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N, M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = t;\n      }else{\n        G2[x][y] = G2[y][x] = t;\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n    \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int j = 0 ; j < N ; j++){\n        for(int i = 0 ; i < N ; i++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        dp[r][j]=min(dp[r][j], dp[r-1][j] + G1[now][next]);\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8;\nconst int MAX_V = 205;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tint riku[MAX_V][MAX_V];\n\t\tint umi[MAX_V][MAX_V];\n\t\tinit(riku);\n\t\tinit(umi);\n\t\trep(i,m){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl[0] == 'L') riku[x][y] = riku[y][x] = t;\n\t\t\telse umi[x][y] = umi[y][x] = t;\n\t\t}\n\t\twarshallFloyd(riku, n);\n\t\twarshallFloyd(umi, n);\n\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i,r) cin >> z[i];\n\t\tfor(auto& i : z) i--;\n\n\t\tvector<vector<int>> dp(n, vector<int>(n, INF));\n\t\tdp[0][z[0]] = 0;\n\t\trep(i,r - 1){\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tint cur = z[i];\n\t\t\t\t\tint nxt = z[i + 1];\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + riku[cur][j] +\n\t\t\t\t\t\t\tumi[j][k] + riku[k][nxt]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,n) cout << dp.back()\n\n\t\tcout << *min_element(all(dp.back())) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n  \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n  \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n  \nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n  \nint main(){\n    while(1){\n        int n,m;\n        static int ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static int sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)return 0;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static int dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tint ret=1000000000;\n    \trep1(i,n){\n    \t\tret=min(ret,dp[r-1][i]);\n    \t}\n          \n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n\n\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint N, M, R;\n\nstruct Node {\n\tint id;\n\tint d;\n};\n\nvector<Node> gl[201];\nvector<Node> gs[201];\n\nint dist_l[201][201];\nint dist_s[201][201];\n\nint dest[1001];\n\nint dp[201][201];\n\nvoid flood()\n{\n\tint i, j, k;\n\n\tfor (i=1; i<=N; i++) {\n\t\tdist_l[i][i] = 0;\n\t\tfor (j=i+1; j<=N; j++) {\n\t\t\tdist_l[i][j] = dist_l[j][i] = INT_MAX;\n\t\t}\n\t}\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=0; j<gl[i].size(); j++) {\n\t\t\tint t = gl[i][j].id;\n\t\t\tint d = gl[i][j].d;\n\t\t\tif (dist_l[i][t] > d)\n\t\t\t\tdist_l[i][t] = dist_l[t][i] = d;\n\t\t}\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (i=1; i<=N; i++) {\n\t\tdist_s[i][i]=0;\n\t\tfor (j=i+1; j<=N; j++) {\n\t\t\tdist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t}\n\t}\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=0; j<gs[i].size(); j++) {\n\t\t\tint id = gs[i][j].id;\n\t\t\tint d = gs[i][j].d;\n\t\t\tif (dist_s[i][id] > d) \n\t\t\t\tdist_s[i][id] = dist_s[id][i] = d;\n\t\t}\n\t}\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t/*\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=i; j<=N; j++) {\n\t\t\tprintf(\"dist_l[%d][%d]=%d\\n\", i, j, dist_l[i][j]);\n\t\t}\n\t}\n\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=i; j<=N; j++) {\n\t\t\tprintf(\"dist_s[%d][%d]=%d\\n\", i, j, dist_s[i][j]);\n\t\t}\n\t}\n\t*/\n}\n\n\n\nvoid solve()\n{\n\tflood();\n\n\tint s_start[201];\n\tint s_end[201];\n\n\tint i, j;\n\n\tfor (i=1; i<=N; i++)\n\t\ts_start[i] = INT_MAX;\n\ts_start[1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_end[j] = INT_MAX;\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (s_start[j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (s_end[j] > s_start[j]+total_land_cost)\n\t\t\t\t\t\ts_end[j] = s_start[j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (s_end[k] > c1+c2+c3+s_start[j]) {\n\t\t\t\t\t\ts_end[k] = c1+c2+c3+s_start[j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_start[j] = s_end[j];\n/*\n\t\tprintf(\"start=%d, end=%d\\n\", start, end);\n\t\tprintf(\"s_end[]= \");\n\t\tfor (j=1; j<=N; j++)\n\t\t\tprintf(\"%d \", s_end[j]);\n\t\tprintf(\"\\n\");\n*/\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > s_start[i])\n\t\t\tmin = s_start[i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tNode node;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tgl[i].clear();\n\t\t\tgs[i].clear();\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tnode.d = t; node.id = y;\n\t\t\t\tgs[x].push_back(node);\n\t\t\t\tnode.id = x;\n\t\t\t\tgs[y].push_back(node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode.d = t; node.id = y;\n\t\t\t\tgl[x].push_back(node);\n\t\t\t\tnode.id = x;\n\t\t\t\tgl[y].push_back(node);\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvll land;\n\t\tvvll sea;\n\t\tinitvv(land,n,n,INFL);\n\t\tinitvv(sea,n,n,INFL);\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L') land[a][b]=mins(land[b][a],c);\n\t\t\telse sea[a][b]=mins(sea[b][a],c);\n\t\t}\n\t\trep(i,2) rep(j,n) land[j][j]=sea[j][j]=0;\n\t\trep(k,n) rep(i,n) rep(j,n) mins(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n) rep(i,n) rep(j,n) mins(sea[i][j],sea[i][k]+sea[k][j]);\n\t\tint r;\n\t\tcin>>r;\n\t\tvint v(r);\n\t\trep(i,r){\n\t\t\tcin>>v[i],v[i]--;\n\t\t}\n\t\tvll pre(n,INFL);\n\t\tpre[v[0]]=0;\n\t\trep(i,r-1){\n\t\t\tvll dp(n,INFL);\n\t\t\trep(k,n){\n\t\t\t\trep(l,n){\n\t\t\t\t\tmins(dp[l],pre[k]+land[v[i]][k]+sea[k][l]+land[l][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp,pre);\n\t\t}\n\t\tcout<< *min_element(ALL(pre))<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 28;\n\nvoid Floyd_Warshall(vector< vector< int > >& graph){\n  for(int k = 0; k < graph.size(); k++){\n    for(int i = 0; i < graph.size(); i++){\n      for(int j = 0; j < graph.size(); j++){\n        graph[i][j] = min( graph[i][j], graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n  return ;\n}\n\nint main(){\n  int N, M, R, z[1001];\n  vector< vector< int > > Road_graph, Sea_graph;\n  int dp[1001][200];\n\n  while(cin >> N >> M, N){\n    \n    Road_graph = vector< vector< int > >( N, vector< int >( N, INF));\n    Sea_graph  = vector< vector< int > >( N, vector< int >( N, INF));\n    for(int i = 0; i < N; i++){\n      Road_graph[i][i] = Sea_graph[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if(sl == 'L') Road_graph[x][y] = Road_graph[y][x] = t;\n      else          Sea_graph [x][y] = Sea_graph [y][x] = t;\n    }\n    cin >> R;\n    z[0] = 0;\n    for(int i = 1; i <= R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    Floyd_Warshall(Road_graph);\n    Floyd_Warshall( Sea_graph);\n\n    //dp[idx][船の場所]\n    fill_n( *dp, 1001 * 200, INF);\n    dp[z[0]][0] = 0;\n    for(int i = 0; i < R; i++){\n      for(int j = 0; j < N; j++){ //船の場所\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < N; k++){\n          int Cost = Road_graph[z[i]][j] + Sea_graph[j][k] + Road_graph[k][z[i + 1]];\n          if(Cost > INF) continue;\n          dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + Cost);\n        }\n      }\n    }\n    int ret = INF;\n    for(int i = 0; i < N; i++){\n      ret = min( ret, dp[R][i]);\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst int INF = 1 << 27;\n\nint main(){\n    while(true){\n        int N,M;\n        cin >> N >> M;\n        if(N == 0 and M == 0) break;\n        vector<vector<vector<int> > > dist(2,vector<vector<int> >(N,vector<int>(N,INF)));\n        for(int i=0;i<M;i++){\n            int x,y,t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;y--;\n            int isl = (sl=='L')?0:1;\n            dist[isl][x][y] = min(dist[isl][x][y],t);\n            dist[isl][y][x] = min(dist[isl][y][x],t);\n        }\n        for(int i=0;i<N;i++){\n            dist[0][i][i] = dist[1][i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[0][i][j] = min(dist[0][i][j],dist[0][i][k]+dist[0][k][j]);\n                    dist[1][i][j] = min(dist[1][i][j],dist[1][i][k]+dist[1][k][j]);\n                }\n            }\n        }\n        int R;\n        cin >> R;\n        vector<int> togo(R);\n        for(int i=0;i<R;i++){\n            cin >> togo[i];\n            togo[i]--;\n        }\n        vector<vector<int> > dp(R,vector<int>(N,INF));\n        dp[0][togo[0]] = 0;\n        for(int i=0;i<R-1;i++){\n            for(int j=0;j<N;j++){\n                if(dp[i][j] == INF) continue;\n                for(int k=0;k<N;k++){\n                    dp[i+1][k] = min(dp[i+1][k],dp[i][j] + \n                            dist[0][togo[i]][j] +\n                            dist[1][j][k] +\n                            dist[0][k][togo[i+1]]);\n                }\n                dp[i+1][j] = min(dp[i+1][j],\n                        dp[i][j]+dist[0][togo[i]][togo[i+1]]);\n            }\n        }\n        int ret = INF;\n        for(int i=0;i<N;i++){\n            ret = min(ret,dp[R-1][i]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int INF=100000000;\nconst int MAX_V = 201;\nconst int MAX_R = 1001;\nint n,m,r;\nint land[MAX_V][MAX_V];\nint sea[MAX_V][MAX_V];\nint citys[MAX_R];\nvoid calcLandMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n}\nvoid calcSeaMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n}\nint dp[MAX_R][MAX_V];\n// WzæªidxÌÔÚÌÆ±ëÅA{[gªboatÌm[hÉ éÆ«ÌÅ¬zBÔ\nint rec(int idx,int boat){\n    if(idx==r)\n        return 0;\n    if(dp[idx][boat]!=INF)\n        return dp[idx][boat];\n    int minTime=INF;\n    // ¤ÌÝðgÁÄB·éê\n    minTime=min(minTime,rec(idx+1,boat)+land[citys[idx-1]][citys[idx]]);\n    // CàgÁÄB·éê\n    // »ÝÌboatÌÊu©çBÅ«é`¬·×ÄÉÂ¢Ä·\n    for(int i = 0; i < n; i++){\n        minTime=min(minTime,rec(idx+1,i)+land[citys[idx-1]][boat]\n        + sea[boat][i] + land[i][citys[idx]]);\n    }\n    return dp[idx][boat]=minTime;\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i==j)\n                    land[i][j]=sea[i][j]=0;\n                else\n                    land[i][j]=sea[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char kind;\n            cin>>from>>to>>cost>>kind;\n            from--;to--;\n            if(kind=='L'){\n                land[from][to]=min(land[from][to],cost);\n                land[to][from]=min(land[to][from],cost);\n            }\n            else{\n                sea[from][to]=min(sea[from][to],cost);\n                sea[to][from]=min(sea[to][from],cost);\n            }\n        }\n        cin>>r;\n        for(int i = 0; i < r; i++){\n            cin>>citys[i];\n            citys[i]--;\n        }\n        calcLandMinDist();\n        calcSeaMinDist();\n        // dpÅÅZ£ðßé\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)dp[i][j]=INF;\n        dp[0][citys[0]]=0;\n        // Wzæ\n        for(int i = 1; i < r; i++){\n            // ¡Ì{[gÌê\n            for(int j = 0; j < n; j++){\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+land[citys[i-1]][citys[i]]);\n                // Ì{[gÌê\n                for(int k = 0; k < n; k++){\n                    dp[i][k]=min(dp[i][k],dp[i-1][j]+land[citys[i-1]][j]\n                    +sea[j][k]+land[k][citys[i]]);\n                }\n            }\n        }\n        //int res=rec(1,citys[0]);\n        int res=INF;\n        for(int i = 0; i < n; i++)\n            res=min(res,dp[r-1][i]);\n        cout<<res<<endl;\n    }\n    return 0;\n}\n/*\nÈº¦ÍÅ«P[XÅªöxÅoÍ³êéªAAOJÅÍà¿ëñTLE·éR[h\n_CNXg@ðgpµÄð¼Éð¢Ä¢é\n*/\n//struct edge{\n//\tint to;\n//\tint cost;\n//    char kind;\n//};\n//\n//class Situation{\n//public:\n//\tint cost;\n//\tint node;\n//    int boat;\n//    int obj;\n//\n//\tSituation(int cost_,int node_,int boat_,int obj_){\n//\t\tcost=cost_;\n//        node=node_;\n//        boat=boat_;\n//        obj=obj_;\n//\t}\n//\tSituation();\n//\n//\tbool operator<(const Situation &s)const{\n//\t\treturn s.cost < this->cost;\n//\t}\n//};\n//\n//int V;\n//int n,m;\n//\n//vector<int> objLands;\n//\n//const int MAX_V = 205;\n//const int MAX_M = 1001;\n//vector<edge> G[MAX_V];\n//int d[MAX_V][MAX_M][MAX_V];\n//const int INF = 1000000000;\n//\n//void dijkstra(int s){\n//\tpriority_queue<Situation> que;\n//    for(int i = 0; i < MAX_V; i++)\n//        for(int j = 0; j < MAX_M; j++)\n//            for(int k = 0; k < MAX_V; k++)\n//                d[i][j][k]=INF;\n//    d[s][0][s] = 0;\n//    que.push(Situation(0,s,s,0));\n//\twhile(!que.empty()){\n//\t\tSituation p = que.top();\n//\t\tque.pop();\n//        int node=p.node;\n//        int boat=p.boat;\n//        int cost=p.cost;\n//        int obj=p.obj;\n//        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n//\t\tif(d[node][obj][boat] < cost)\n//            continue;\n//\t\tfor(int i = 0; i < G[node].size(); i++){\n//\t\t\tedge &e = G[node][i];\n//            int toObj=obj;\n//            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n//            if(objLands[obj]==e.to)\n//                toObj++;\n//            // ¤ÌêÆCÌêÅêí¯\n//            if(e.kind=='L'){\n//                // ÅZ£\n//                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n//                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n//                    if(toObj!=objLands.size())\n//                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n//                }\n//            }\n//            else{\n//                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n//                if(boat==node){\n//                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n//                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n//                        if(toObj!=objLands.size())\n//                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n//                    }\n//                }\n//            }\n//\t\t}\n//\t}\n//}\n//\n//int main(){\n//\n//    while(cin>>n>>m&&!(n==0&&m==0)){\n//        objLands.clear();\n//        for(int i = 0; i < MAX_V; i++)\n//            G[i].clear();\n//        for(int i = 0; i < m; i++){\n//            int from,to,cost;\n//            char c;\n//            cin>>from>>to>>cost>>c;\n//            from--;to--;\n//            edge e;\n//            e.cost=cost;e.kind=c;e.to=to;\n//            G[from].push_back(e);\n//            e.to=from;\n//            G[to].push_back(e);\n//        }\n//        int t;\n//        cin>>t;\n//        int s;\n//        for(int i = 0; i < t; i++){\n//            if(i==0){\n//                cin>>s;\n//                s--;\n//            }\n//            else{\n//                int b;\n//                cin>>b;\n//                b--;\n//                objLands.push_back(b);\n//            }\n//        }\n//        dijkstra(s);\n//        int minCost=INF;\n//        for(int i = 0; i < n; i++){\n//            for(int j = 0; j < n; j++)\n//                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n//        }\n//        cout<<minCost<<endl;\n//    }\n//    return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define chmin(x,y)x=min(x,y)\nusing namespace std;\nlong long L[222][222],S[222][222];\nlong long dp[1111][222];\nint r;\nint z[1111];\nvoid solve(int n,int m)\n{\n\tfor(int i=0;i++<n;)for(int j=0;j++<n;)\n\t\tif(i!=j)L[i][j]=L[j][i]=S[i][j]=S[j][i]=1e13;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint x,y,t;char c;\n\t\tcin>>x>>y>>t>>c;\n\t\tif(c=='L')L[x][y]=L[y][x]=t;\n\t\telse S[x][y]=S[y][x]=t;\n\t}\n\tfor(int k=0;k++<n;)for(int i=0;i++<n;)for(int j=0;j++<n;)\n\t{\n\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t}\n\tcin>>r;\n\tfor(int i=0;i<r;i++)cin>>z[i];\n\tfor(int i=0;i<=r;i++)for(int j=0;j++<n;)dp[i][j]=1e13;\n\tdp[0][z[0]]=0;\n\tfor(int i=0;i<r-1;i++)\n\t{\n\t\tfor(int j=0;j++<n;)\n\t\t{\n\t\t\tchmin(dp[i+1][j],dp[i][j]+L[z[i]][z[i+1]]);\n\t\t\tfor(int k=0;k++<n;)\n\t\t\t{\n\t\t\t\tchmin(dp[i+1][k],dp[i][j]+L[z[i]][j]+S[j][k]+L[k][z[i+1]]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long ans=1e13;\n\tfor(int i=0;i++<n;)chmin(ans,dp[r-1][i]);\n\tcout<<ans<<endl;\n}\nmain()\n{\n\tint n,m;\n\twhile(cin>>n>>m,n)\n\t{\n\t\tsolve(n,m);\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\nll ord[1111];\nll dl[222][222],ds[222][222],dp[1111][222];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    ll n,m,r;\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,n)rep(j,n){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n    }\n    rep(i,m){\n      ll x,y,t;\n      char c;\n      cin>>x>>y>>t>>c;\n      x--; y--;\n      if(c=='L'){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    //rep(i,n)rep(j,n)dbg(ds[i][j]);\n    cin>>r;\n    rep(i,r){\n      cin>>ord[i];\n      ord[i]--;\n    }\n    rep(i,r+1)rep(j,n)dp[i][j]=INF;\n    dp[0][ord[0]]=0;\n    rep(i,r-1){\n      int crt=ord[i],nxt=ord[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        rep(k,n){\n          minch(dp[i+1][k],dp[i][j]+dl[crt][j]+ds[j][k]+dl[k][nxt]);\n        }\n        if(j==crt){\n          rep(k,n){\n            minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n          }\n        }\n      }\n    }\n    ll res=INF;\n    rep(i,n)minch(res,dp[r-1][i]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 214748360012345\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to;\n  long cost;\n  char type;\n};\n\ntypedef pair<long, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(d=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<long> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        if(pos == route[i+1]) continue;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(e.type=='L' && !(uf.same(nxtp, route[i+1]) || uf.same(nxtp, route[i]))) continue;\n          long nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    long res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct st{\n  int d,v,b,c;\n  st(){}\n  st(int d,int v,int b,int c):d(d),v(v),b(b),c(c){}\n};\nstruct edge{\n  int to,cost,s;\n  edge(){}\n  edge(int to,int cost,int s):to(to),cost(cost),s(s){}\n};\nint dp[2][222][222];\nvector<edge> G[222];\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    for(int i=0;i<222;i++) G[i].clear();\n    int x[m],y[m],t[m];\n    char sl[m];\n    for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i]>>sl[i];\n    int r;\n    cin>>r;\n    int z[r];\n    for(int i=0;i<r;i++) cin>>z[i];\n    for(int i=0;i<m;i++){\n      x[i]--;y[i]--;\n      G[x[i]].emplace_back(y[i],t[i],sl[i]=='S');\n      G[y[i]].emplace_back(x[i],t[i],sl[i]=='S');\n    }\n    for(int i=0;i<r;i++) z[i]--;\n    memset(dp,-1,sizeof(dp));\n    deque<st> q;\n    q.emplace_back(1,z[0],z[0],0);\n    dp[1][z[0]][z[0]]=0;\n    int pre=1;\n    int ans=1LL<<55LL;\n    while(!q.empty()){\n      st p=q.front();q.pop_front();\n      int d=p.d,v=p.v,b=p.b,c=p.c;\n      if(dp[d%2][v][b]<c) continue;\n      if(d==r){\n\tans=min(ans,dp[d%2][v][b]);\n\tcontinue;\n      }\n      //cout<<d<<\" \"<<v<<\" \"<<b<<\":\"<<dp[d%2][v][b]<<endl;\n      if(pre!=p.d)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    dp[!(d%2)][i][j]=-1;\n      pre=d;\n      for(edge& e:G[v]){\n\tint nv=e.to,nb=b,nd=d;\n\tif(e.s){\n\t  if(v==b) nb=nv;\n\t  else continue;\n\t}\n\tif(nv==z[d]){\n\t  nd++;\n\t  if(dp[nd%2][nv][nb]<0||dp[nd%2][nv][nb]>dp[d%2][v][b]+e.cost){\n\t    //cout<<e.s<<\":\"<<nd<<\" \"<<nv<<\" \"<<nb<<endl;\n\t    dp[nd%2][nv][nb]=dp[d%2][v][b]+e.cost;\n\t    q.emplace_back(nd,nv,nb,dp[nd%2][nv][nb]);\n\t  }\n\t}else{\n\t  if(dp[nd%2][nv][nb]<0||dp[nd%2][nv][nb]>dp[d%2][v][b]+e.cost){\n\t    dp[nd%2][nv][nb]=dp[d%2][v][b]+e.cost;\n\t    q.emplace_front(nd,nv,nb,dp[nd%2][nv][nb]);\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint result[101][101][10001];\n\nint dijk(vector<vector<pair<int, pair<int, bool> > > >& adjlist, vector<int>& z){\n  int n = adjlist.size();\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < z.size(); k++){\n        result[i][j][k] = INF;\n      }\n    }\n  }\n\n  \n  //vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<int, pair<int, int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    int x, y, t;\n    string sl;\n    vector<vector<pair<int, pair<int, bool> > > > adjlist(n + 1);\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(adjlist, z);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL INF = 1e14;\n\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, R;\n  while(cin >> N >> M, N){\n\tfill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n\tfill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n\n\tREP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n\tREP(i,M){\n\t  LL x, y, t; char c;\n\t  cin >> x >> y >> t >> c;\n\t  --x, --y;\n\t  if(c == 'L')\n\t\tdist_L[x][y] = dist_L[y][x] = min(dist_L[x][y], t);\n\t  else\n\t\tdist_S[x][y] = dist_S[y][x] = min(dist_S[x][y], t);\n\t}\n\t\n\tREP(k,N) REP(i,N) REP(j,N){\n\t  dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n\t  dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n\t}\n\n\tcin >> R;\n\tVI RS(R);\n\tREP(i,R){\n\t  cin >> RS[i];\n\t  --RS[i];\n\t}\n\n\t// dp[i][j] :<=> i???????????§?¨???????????????£??????????????????j?????¨??????????°??????????\n\tfill((LL*)dp, (LL*)dp+1001*201, INF);\n\tdp[0][RS[0]] = 0;\n\tREP(i,R-1){\n\t  REP(u,N){\n\t\tREP(v,N){\n\t\t  dp[i+1][v] = min(dp[i+1][v],\n\t\t\t\t\t\t   // Rs[i] -> u????????§???u -> v????????§???v->RS[i+1]????????§?§????\n\t\t\t\t\t\t   dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n\t\t\t\t\t\t   );\n\t\t}\n\t\t//?????????\n\t\tdp[i+1][u] = min(dp[i+1][u], dp[i][u]+dist_L[RS[i]][RS[i+1]]);\n\t  }\n\t}\n\n\tLL ans = INF;\n\tREP(u,N) ans = min(ans, dp[R-1][u]);\n\tcout << ans << endl;\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        dp[0][r[0]]=0;\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nll dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  vector<vector<int> > used(n,vector<int>(r,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    if(pos==ship)\n      for(int i=0;i<n;i++){\n\tncost=cost+G[pos][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n      }\n  }\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                //if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                //    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                //}\n                assert(z[i]<N);\n                if (dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nint N, M, R;\n\nstruct Node {\n\tint id;\n\tint d;\n};\n\nvector<Node> gl[201];\nvector<Node> gs[201];\n\nint dist_l[201][201];\nint dist_s[201][201];\n\nint dest[1001];\n\nint dp[201][201];\n\nvoid flood()\n{\n\tint i, j, k;\n\n\tfor (i=1; i<=N; i++) {\n\t\tdist_l[i][i] = 0;\n\t\tfor (j=i+1; j<=N; j++) {\n\t\t\tdist_l[i][j] = dist_l[j][i] = INT_MAX;\n\t\t}\n\t}\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=0; j<gl[i].size(); j++) {\n\t\t\tint t = gl[i][j].id;\n\t\t\tint d = gl[i][j].d;\n\t\t\tif (dist_l[i][t] > d)\n\t\t\t\tdist_l[i][t] = dist_l[t][i] = d;\n\t\t}\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (i=1; i<=N; i++) {\n\t\tdist_s[i][i]=0;\n\t\tfor (j=i+1; j<=N; j++) {\n\t\t\tdist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t}\n\t}\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=0; j<gs[i].size(); j++) {\n\t\t\tint id = gs[i][j].id;\n\t\t\tint d = gs[i][j].d;\n\t\t\tif (dist_s[i][id] > d) \n\t\t\t\tdist_s[i][id] = dist_s[id][i] = d;\n\t\t}\n\t}\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\t/*\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=i; j<=N; j++) {\n\t\t\tprintf(\"dist_l[%d][%d]=%d\\n\", i, j, dist_l[i][j]);\n\t\t}\n\t}\n\n\tfor (i=1; i<=N; i++) {\n\t\tfor (j=i; j<=N; j++) {\n\t\t\tprintf(\"dist_s[%d][%d]=%d\\n\", i, j, dist_s[i][j]);\n\t\t}\n\t}\n\t*/\n}\n\n\n\nvoid solve()\n{\n\tflood();\n\n\tint s_start[201];\n\tint s_end[201];\n\n\tint i, j;\n\n\tfor (i=1; i<=N; i++)\n\t\ts_start[i] = INT_MAX;\n\ts_start[1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_end[j] = INT_MAX;\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (s_start[j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (s_end[j] > s_start[j]+total_land_cost)\n\t\t\t\t\t\ts_end[j] = s_start[j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (s_end[k] > c1+c2+c3+s_start[j]) {\n\t\t\t\t\t\ts_end[k] = c1+c2+c3+s_start[j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (j=1; j<=N; j++)\n\t\t\ts_start[j] = s_end[j];\n/*\n\t\tprintf(\"start=%d, end=%d\\n\", start, end);\n\t\tprintf(\"s_end[]= \");\n\t\tfor (j=1; j<=N; j++)\n\t\t\tprintf(\"%d \", s_end[j]);\n\t\tprintf(\"\\n\");\n*/\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > s_start[i])\n\t\t\tmin = s_start[i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tNode node;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tgl[i].clear();\n\t\t\tgs[i].clear();\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tnode.d = t; node.id = y;\n\t\t\t\tgs[x].push_back(node);\n\t\t\t\tnode.id = x;\n\t\t\t\tgs[y].push_back(node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnode.d = t; node.id = y;\n\t\t\t\tgl[x].push_back(node);\n\t\t\t\tnode.id = x;\n\t\t\t\tgl[y].push_back(node);\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  dp[テ」ツ?ゥテ」ツ?禿」ツ?セテ」ツ?ァテゥツ崢?ゥツ?催」ツ?療」ツ?淌」ツ?犠[ティツ按ケテ」ツ?ョテ・ツ?エテヲツ可?テ」ツ?ァDPテ」ツ??\n  z[i] -> z[i+1]テ」ツ?ョテァツァツサテ・ツ仰陛」ツ?ョテゥツ堋崚」ツ?ォティツ按ケテ」ツ?ッテ・ツ、ツ堙」ツ?湘」ツ?ヲテ」ツつ?テ・ツ崢榲」ツ?療」ツ?凝、ツケツ療」ツつ嘉」ツ?ェテ」ツ??」ツ?ョテ」ツ?古」ツδ敕」ツつ、テ」ツδウテ」ツδ暗」ツ??」ツ?ィテヲツ?敕」ツ??」ツ??\n */\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 202;\nconst int MAXR = 1002;\nconst int INF = 1<<28;\n\nint N, M;\nint land[MAXN][MAXN], sea[MAXN][MAXN];\nint R;\nint Z[MAXR];\n\nint dp[MAXR][MAXN];\n\nvoid warshallFloyd(int n, int g[MAXN][MAXN]) {\n  for(int k = 0; k < n; ++k) {\n    for(int i = 0; i < n; ++i) {\n      for(int j = 0; j < n; ++j) {\n        g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M && (N|M)) {\n    for(int i = 0; i < MAXN; ++i) {\n      for(int j = 0; j < MAXN; ++j) {\n        land[i][j] = sea[i][j] = (i == j) ? 0 : INF;\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      if(sl == 'L') {\n        land[x][y] = land[y][x] = min(land[x][y], t);\n      } else {\n        sea[x][y] = sea[y][x] = min(sea[x][y], t);\n      }\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      cin >> Z[i];\n      --Z[i];\n    }\n\n    warshallFloyd(N, land);\n    warshallFloyd(N, sea);\n\n    fill(dp[0], dp[MAXR], INF);\n    dp[0][Z[0]] = 0;\n    for(int i = 0; i+1 < R; ++i) {\n      for(int j = 0; j < N; ++j) {\n        if(dp[i][j] == INF) continue;\n        int a = Z[i];\n        int b = Z[i+1];\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j] + land[a][b]);\n        for(int k = 0; k < N; ++k) {\n          dp[i+1][k] = min(dp[i+1][k],\n                           dp[i][j] + land[a][j] + sea[j][k] + land[k][b]);\n        }\n      }\n    }\n\n    int res = INF;\n    for(int j = 0; j < N; ++j) {\n      res = min(res, dp[R-1][j]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint const MAX_N = 210;\nint const MAX_R = 1010;\nint const INF = 1<<29;\nll dpl[MAX_N][MAX_N];\nll dps[MAX_N][MAX_N];\nll dpall[MAX_R][MAX_N];\nll N, M;\nint z[MAX_R];\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      dpl[i][i] = dps[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n        dpl[i][j] = dpl[j][i] = INF;\n        dps[i][j] = dps[j][i] = INF;\n      }\n    }\n    \n    for(int i=0; i<M; i++) {\n      int x, y, c; char ls;\n      cin >> x >> y >> c >> ls; x--, y--;\n      if(ls == 'L') {\n        dpl[x][y] = dpl[y][x] = c;\n      }\n      else {\n        dps[x][y] = dps[y][x] = c;\n      }\n    }\n    \n    int r; cin >> r;\n    for(int i=0; i<r; i++) {\n      cin >> z[i]; z[i] --;\n    }\n    \n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          dpl[i][j] = min(dpl[i][j], dpl[i][k]+dpl[k][j]);\n          dps[i][j] = min(dps[i][j], dps[i][k]+dps[k][j]);\n        }\n      }\n    }\n\n    fill(dp[0], dp[0]+MAX_R*MAX_N, 0);\n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++)\n        for(int t=0; t<N; t++) {\n          dpall[i][t] = min(dpall[i][t], dpall[i-1][s] + dpl[z[i-1]][s] + dps[s][t] + dpl[t][z[i]]);\n          dpall[i][t] = min(dpall[i][t], dp[i-1][t] + dpl[z[i-1]][z[i]]);\n        }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship, cost, job;\n\tP(int now, int ship, int cost,int job ) :now(now), ship(ship), cost(cost),job(job) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tint N, M;\n\t\tint SeaRoutes[201][201];\n\t\tint LandRoutes[201][201];\n\t\tint R;\n\t\tvi Destinations;\n\t\tcin >> N >> M;\n\t\tif ( N == 0 && M == 0 )break;\n\t\tFOR(i, 201)FOR(j, 201)SeaRoutes[i][j] = LandRoutes[i][j] = INF;\n\t\tFOR(i, 201)SeaRoutes[i][i] = LandRoutes[i][i] = 0;\n\t\tFOR(i, M)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif ( sl == 'S' )\n\t\t\t{\n\t\t\t\tSeaRoutes[x][y] = min(SeaRoutes[x][y], t);\n\t\t\t\tSeaRoutes[y][x] = min(SeaRoutes[y][x], t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLandRoutes[x][y] = min(LandRoutes[x][y], t);\n\t\t\t\tLandRoutes[y][x] = min(LandRoutes[y][x], t);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tFOR(i, R)\n\t\t{\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tDestinations.push_back(z);\n\t\t}\n\t\tFOR(k, N+1)FOR(i, N+1)FOR(j, N+1)\n\t\t{\n\t\t\tSeaRoutes[i][j] = min(SeaRoutes[i][j], SeaRoutes[i][k] + SeaRoutes[k][j]);\n\t\t\tLandRoutes[i][j] = min(LandRoutes[i][j], LandRoutes[i][k] + LandRoutes[k][j]);\n\t\t}\n\t\tbool Flag[201][1001] = {};\n\t\tpriority_queue< P, vector<P>, greater<P> >Queue;\n\t\tQueue.push(P(Destinations[0], Destinations[0], 0, 1));\n\t\tint p = 0;\n\t\twhile ( !Queue.empty() )\n\t\t{\n\t\t\tP Current = Queue.top(); Queue.pop();\n\t\t\tif ( Current.job == R )\n\t\t\t{\n\t\t\t\tcout << Current.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint Destination = Destinations[Current.job];\n\t\t\t\n\t\t\tif ( Flag[Current.ship][Current.job] )continue;\n\t\t\tFlag[Current.ship][Current.job] = true;\n\n\t\t\tP A = Current;\n\t\t\tA.cost += LandRoutes[A.now][Destination];\n\t\t\tA.now = Destination;\n\t\t\tA.job++;\n\t\t\tQueue.push(A);\n\n\t\t\t\n\t\t\tFOR(i, N+1)\n\t\t\t{\n\t\t\t\tP B = Current;\n\t\t\t\tB.cost += LandRoutes[B.now][B.ship];\n\t\t\t\tB.job++;\n\t\t\t\tif ( SeaRoutes[B.ship][i] < INF &&LandRoutes[i][Destination]<INF)\n\t\t\t\t{\n\t\t\t\t\tB.cost += SeaRoutes[B.ship][i]+ LandRoutes[i][Destination];\n\t\t\t\t\tB.now = Destination;\n\t\t\t\t\tB.ship = i;\n\t\t\t\t\tQueue.push(B);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 26)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nint Shortest(int start, int goal, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[goal];\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tint Land_Only = Shortest(Z[i - 1], Z[i], \"Land\");\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tdp[i][k] = min(dp[i - 1][k] + Land_Only, dp[i][k]);\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Shortest(Z[i - 1], j, \"Land\");\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Shortest(j, k, \"Sea\");\n\n\t\t\t\t\t\tint Land_2 = Shortest(k, Z[i], \"Land\");\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\n\n\t\t// ------ Variable Value ------ //\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINT_MAX)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<LL>> warshall_floyd(std::vector<std::vector<LL>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INT_MAX and matrix.at(m).at(e) != INT_MAX) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        vector<vector<LL>> matrix1(N, vector<LL>(N, INT_MAX)), matrix2(N, vector<LL>(N, INT_MAX));\n        FOR(i, 0, M) {\n            LL X, Y, T;\n            char S;\n            cin >> X >> Y >> T >> S;\n            X--; Y--;\n            if (S == 'L') {\n                matrix1[X][Y] = min(matrix1[X][Y], T);\n                matrix1[Y][X] = min(matrix1[Y][X], T);\n            }\n            else if (S == 'S') {\n                matrix2[X][Y] = min(matrix2[X][Y], T);\n                matrix2[Y][X] = min(matrix2[Y][X], T);\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> route(R);\n        FOR(i, 0, R) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        matrix1 = warshall_floyd(matrix1);\n        matrix2 = warshall_floyd(matrix2);\n\n        vector<vector<LL>> dp(R, vector<LL>(N, INF));\n        dp[0][route[0]] = 0;\n\n        FOR(i, 0, R - 1) {\n            int now = route[i];\n            int next = route[i + 1];\n\n            FOR(j, 0, N) {\n                if (dp[i][j] == INF) {\n                    continue;\n                }\n\n                FOR(k, 0, N) {\n                    // 船がjにあるとき、町nowから町jに陸路、町jから町kに海路、町kから町nextに陸路でいく\n                    LL dist = dp[i][j] + matrix1[now][j] + matrix2[j][k] + matrix1[k][next];\n                    dp[i + 1][k] = min(dp[i + 1][k], dist);\n\n                    if (j == k) {\n                        LL d = dp[i][j] + matrix1[now][next];\n                        dp[i + 1][j] = min(dp[i + 1][j], d);\n                    }\n\n                }\n            }\n        }\n\n        LL ans = INF;\n        FOR(i, 0, N) {\n            ans = min(ans, dp[R - 1][i]);\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct edge{\n    int to,cost;\n    bool S;\n    edge(int a,int b,bool c):to(a),cost(b),S(c){}\n};\n\nstruct data{\n    int pos,cost,ship;\n    data(int a,int b,int c):pos(a),cost(b),ship(c){}\n    bool operator<(const data &d)const{\n        return cost>d.cost;\n    }\n};\n\nint N,M,T;\nvector<edge>G[200];\nvector<int>task;\nint dist[200][200];\nconst int INF=1001001001001001001;\nvoid solve(){\n    priority_queue<data>Q;\n\n    for(int i=0;i<T-1;i++){\n        if(i==0){\n            for(int j=0;j<N;j++)fill_n(dist[j],N,INF);\n            dist[task[0]][task[0]]=0;\n            Q.push(data(task[0],0,task[0]));\n        }\n        else{\n            for(int j=0;j<N;j++)if(task[i]!=j)fill_n(dist[j],N,INF);\n            for(int j=0;j<N;j++){\n                Q.push(data(task[i],dist[task[i]][j],j));\n            }\n        }\n\n        while(Q.size()){\n            data d=Q.top();Q.pop();\n\n            if(dist[d.pos][d.ship]<d.cost)continue;\n\n            for(int j=0;j<G[d.pos].size();j++){\n                edge &e=G[d.pos][j];\n                if(e.S){\n                    if(d.pos!=d.ship)continue;\n                    if(dist[e.to][e.to]<=d.cost+e.cost)continue;\n                    dist[e.to][e.to]=d.cost+e.cost;\n                    Q.push(data(e.to,d.cost+e.cost,e.to));\n                }\n                else{\n                    if(dist[e.to][d.ship]<=d.cost+e.cost)continue;\n                    dist[e.to][d.ship]=d.cost+e.cost;\n                    Q.push(data(e.to,d.cost+e.cost,d.ship));\n                }\n            }\n        }\n    }\n\n    int ans=INF;\n    for(int i=0;i<N;i++)ans=min(ans,dist[task[T-1]][i]);\n    printf(\"%lld\\n\",ans);\n}\n\nsigned main(){\n    while(scanf(\"%lld%lld\",&N,&M),N||M){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            scanf(\"%lld%lld%lld %c\",&a,&b,&c,&d);\n            a--;b--;\n            G[a].push_back(edge(b,c,(d=='S')));\n            G[b].push_back(edge(a,c,(d=='S')));\n        }\n        scanf(\"%d\",&T);\n        task.resize(T);\n        for(int i=0;i<T;i++)scanf(\"%d\",&task[i]),task[i]--;\n\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL INF = 1e9;\n\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, R;\n  while(cin >> N >> M, N){\n\tfill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n\tfill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n\n\tREP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n\tREP(i,M){\n\t  LL x, y, t; char c;\n\t  cin >> x >> y >> t >> c;\n\t  --x, --y;\n\t  if(c == 'L')\n\t\tdist_L[x][y]=  dist_L[y][x] = min(dist_L[x][y], t);\n\t  else\n\t\tdist_S[x][y]=  dist_S[y][x] = min(dist_S[x][y], t);\n\t}\n\t\n\tREP(k,N) REP(i,N) REP(j,N){\n\t  dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n\t  dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n\t}\n\n\tcin >> R;\n\tVI RS(R);\n\tREP(i,R){\n\t  cin >> RS[i];\n\t  --RS[i];\n\t}\n\n\t// dp[i][j] :<=> i???????????§?¨???????????????£??????????????????j?????¨??????????°??????????\n\tfill((LL*)dp, (LL*)dp+1001*201, INF);\n\tdp[RS[0]][RS[0]] = 0;\n\tREP(i,R-1){\n\t  REP(u,N){\n\t\tREP(v,N){\n\t\t  dp[i+1][v] = min(dp[i+1][v],\n\t\t\t\t\t\t   // Rs[i] -> u????????§???u->????????§???v->RS[i+1]????????§?§????\n\t\t\t\t\t\t   dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n\t\t\t\t\t\t   );\n\t\t}\n\t\t// ????????????\n\t\t//\t\tdp[i+1][u] = min(dp[i+1][u], dp[i][u]+dist_L[RS[i]][RS[i+1]]);\n\t  }\n\t}\n\n\tLL ans = INF;\n\tREP(u,N) ans = min(ans, dp[R-1][u]);\n\tcout << ans << endl;\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[50][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int j=0;j<200;j++){\n\t\tfor(int k=0;k<200;k++){\n\t\t\tcost[0][j][k]=INF;\n\t\t}\n\t}\n\tmemset(reset,false,sizeof(reset));\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(0,0))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\tres=min(res,nc);\n\t\t\tcontinue;\n\t\t}\n\t\tif(now==rt[np]){\n\t\t\tnp++;\n\t\t\tif(reset[np]==false){\n\t\t\t\tfor(int i=0;i<200;i++){\n\t\t\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\t\t\tcost[np%20][i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset[np]=true;\n\t\t\t}\n\t\t}\n\t\tif(cost[np%20][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np%20][e.t][ns]){\n\t\t\t\tcost[np%20][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np%20][e.t][e.t]){\n\t\t\t\t\tcost[np%20][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[201],INF);\n   fill(dS[0],dS[201],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=min(dL[s][t],v);  \n     dL[t][s]=min(dL[t][s],v);  \n     }else{\n     dS[s][t]=min(dS[s][t],v);  \n     dS[t][s]=min(dS[t][s],v); \n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){ \n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n        }\n       }\n      } \n\n   fill(dp[0],dp[1001],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           /*else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);*/\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll l[201][201];\nll s[201][201];\nll dp[1001][201];\n\n\nint main(){\n\tint n,m,r;\n\twhile(cin >> n >> m && n!=0){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tl[i][j] = inf;\n\t\t\t\ts[i][j] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tl[i][j] = 0;\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tll x,y;\n\t\t\tll t;\n\t\t\tchar c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(c=='L'){\n\t\t\t\tl[x][y] = min(l[x][y],t);\n\t\t\t\tl[y][x] = min(l[x][y],t);\n\t\t\t}else{\n\t\t\t\ts[x][y] = min(s[x][y],t);\n\t\t\t\ts[y][x] = min(s[x][y],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tl[i][j] = min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j] = min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\n\nconst int N   = 200;\nconst ll inf =(1LL<<58);\n\nll land[N][N];\nll sea[N][N];\n\nvoid wf(int n,ll mat[N][N]){\n  rep(k,n)rep(i,n)rep(j,n)mat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);\n}\n\n\nll dp[1000][N];\nll solve(int n,vector<int> &in,int s){\n  wf(n,land);\n  wf(n,sea);\n  rep(i,in.size())rep(j,n)dp[i][j]=inf;\n//   rep(i,n){\n//     rep(j,n){\n//       dp[0][j]=min(dp[0][j],land[s][i]+sea[i][j]+land[j][in[0]]);\n//       cout << dp[0][j] << endl;\n//     }\n//   }\n\n  dp[0][s]=0;\n\n  REP(i,1,in.size()){\n    rep(j,n){\n      rep(k,n){\n\tdp[i][k]=min(dp[i][k],\n\t\t     dp[i-1][j]+land[in[i-1]][j]+sea[j][k]+land[k][in[i]]);\n      }\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+land[in[i-1]][in[i]]);\n    }\n  }\n\n  ll ret = inf;\n  rep(i,n)ret=min(ret,dp[in.size()-1][i]);\n  return ret;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n){\n      rep(j,n)sea[i][j]=land[i][j]=inf;\n      sea[i][i]=0;land[i][i]=0;\n    }\n    rep(i,m){\n      int f,t;ll c;char tmp;\n      cin>>f>>t>>c>>tmp;\n      f--;t--;\n      if (tmp == 'L')land[f][t]=land[t][f]=min(land[t][f],c);\n      if (tmp == 'S')sea[f][t] =sea[t][f] =min( sea[t][f],c);\n    }\n\n\n    int q;\n    cin>>q;\n    vector<int> in(q);\n    rep(i,q)cin>>in[i],in[i]--;\n    cout << solve(n,in,in[0]) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n\nusing namespace std;\n\nconst int INF = 0xfffffff;\n\nint N, M, R;\nvector<int> z;\n\nint dl[256][256], ds[256][256], dp[1024][256];\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M, N|M){\n\t\trep(i, 256) rep(j, 256) dl[i][j] = ds[i][j] = INF;\n\t\trep(i, 1024) rep(j, 256) dp[i][j] = INF;\n\t\tz.clear();\n\t\trep(i, M) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tdl[x][y] = min(dl[x][y], t);\n\t\t\t\tdl[y][x] = min(dl[y][x], t);\n\t\t\t} else {\n\t\t\t\tds[x][y] = min(ds[x][y], t);\n\t\t\t\tds[y][x] = min(ds[y][x], t);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i, R) {\n\t\t\tint tmp;\n\t\t\tcin >> tmp;\n\t\t\ttmp--;\n\t\t\tz.push_back(tmp);\n\t\t}\n\t\t//cout << \"kita\" << endl;\n\t\t//rep(i, z.size()) cout << z[i] << endl;\n\t\t//cout << \"kita\" << endl;\n\t\trep(k, N) {\n\t\t\trep(i, N) {\n\t\t\t\trep(j, N) {\n\t\t\t\t\tif(i == j) {\n\t\t\t\t\t\tdl[i][j] = ds[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i, N) {\n\t\t\tdp[0][i] = ds[z[0]][i] + dl[i][z[0]];\t\n\t\t}\n\t\tfor(int i = 1; i < R; i++) {\n\t\t\trep(j, N) {\n\t\t\t\trep(k, N) {\n\t\t\t\t\tif(j != k) {\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + dl[z[i-1]][j] + ds[j][k] + dl[k][z[i]]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + dl[z[i-1]][z[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, N) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t\t//cout << dp[R-1][i] << endl;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\nint N, M, R;\nint ds[200][200],dl[200][200];//ship walk\nint list[1000];\nint dp[1000][200];\n\nint main() {\n\twhile (cin >> N >> M, N + M) {\n\t\tfor (int i = 0; i < N; i++)for (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i == j)dl[i][j] = ds[i][j] = 0;\n\t\t\telse dl[i][j] = ds[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, cost;\n\t\t\tchar c;\n\t\t\tcin >> a >> b >> cost >> c;\n\t\t\ta--, b--;\n\t\t\tif (c == 'L') dl[a][b] = min(cost, dl[a][b]), dl[b][a] = dl[a][b];\n\t\t\telse ds[a][b] = min(cost, ds[a][b]), ds[b][a] = ds[a][b];\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++)cin >> list[i],list[i]--;\n\t\t//???????????£??????????????????\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; i++)for (int j = 0; j < N; j++)dp[i][j] = INF;\n\t\t//dp[i][j] := i???????????????????????°??§???j?????????????????¨??????????????¨?????????????????????????????????\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdp[0][i] = ds[list[0]][i] + dl[i][list[0]];\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k)dp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[list[i]][list[i - 1]]);\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[list[i - 1]][j] + ds[k][j] + dl[k][list[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; i++)ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n#define debug(x) cout << #x << \" = \" << x << endl;\n#define sq(x) ((x)*(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nint Lcost[205][205];\nint Scost[205][205];\n\nint dp[1005][205];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tstatic const int INF = 1e8;\n\t\trep(i, n) rep(j, n){\n\t\t\tif(i == j) continue;\n\t\t\tLcost[i][j] = INF;\n\t\t\tScost[i][j] = INF;\n\t\t}\n\t\trep(i, n){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tLcost[x][y] = Lcost[y][x] = t;\n\t\t\t}else{\n\t\t\t\tScost[x][y] = Scost[y][x] = t;\n\t\t\t}\n\t\t}\n\t\trep(i, n) rep(j, n) rep(k, n){\n\t\t\tLcost[j][k] = min(Lcost[j][k], Lcost[j][i] + Lcost[i][k]);\n\t\t\tScost[j][k] = min(Scost[j][k], Scost[j][i] + Scost[i][k]);\n\t\t}\n\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, n){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i, r) rep(j, n) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 1; i < r; i++){\n\t\t\tint pos = z[i-1];\n\t\t\tint next = z[i];\n\t\t\trep(j, n){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j]+Lcost[pos][next]);\n\t\t\t\trep(k, n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+Lcost[pos][j]+Scost[j][k]+Lcost[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, n) ans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\nint n,m,R;\nvector<pii> riku[210],umi[210];\nint route[1010];\ni64 lan[210][210],sea[210][210];\ni64 dp[2][210];\n\nvoid solve() {\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                chmin(lan[j][k],lan[j][i]+lan[i][k]);\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                chmin(sea[j][k],sea[j][i]+sea[i][k]);\n            }\n        }\n    }\n    init(dp,inf<int>);\n    int now=0;\n    i64 ans=inf<int>;\n    dp[now][route[0]]=0;\n    for(int r=1; r<R; ++r,now^=1) {\n        init(dp[now^1],inf<int>);\n        for(int i=0; i<n; ++i) {\n            if(dp[now][i]>=inf<int>) continue;\n            for(int j=0; j<n; ++j) {\n                if(i==j) {\n                    chmin(dp[now^1][j],dp[now][i]+lan[route[r]][route[r-1]]);\n                } else {\n                    chmin(dp[now^1][j],dp[now][i]+lan[route[r-1]][i]+sea[i][j]+lan[route[r]][j]);\n                }\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        chmin(ans,dp[now][i]);\n    }\n    writeln(ans);\n}\n\nsigned main() {\n    while(true) {\n        cin>>n>>m;\n        if(!n) break;\n        init(lan,inf<int>);\n        init(sea,inf<int>);\n        for(int i=0; i<n; ++i) lan[i][i]=sea[i][i]=0;\n        for(int i=0; i<n; ++i) {\n            riku[i].clear();\n            umi[i].clear();\n        }\n        for(int _=0; _<m; ++_) {\n            i64 x,y,t;\n            char sl;\n            cin>>x>>y>>t>>sl;\n            x--,y--;\n            if(sl=='L') {\n                riku[x].emplace_back(y,t);\n                riku[y].emplace_back(x,t);\n                chmin(lan[x][y],t);\n                chmin(lan[y][x],t);\n            } else {\n                umi[x].emplace_back(y,t);\n                umi[y].emplace_back(x,t);\n                chmin(sea[x][y],t);\n                chmin(sea[y][x],t);\n            }\n        }\n        cin>>R;\n        for(int i=0; i<R; ++i) {\n            cin>>route[i];\n            route[i]--;\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n#include<queue>\n#include<cstring>\n#include<vector>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 1010;\nconst ll INF = 0x1f1f1f1f1f1f1f1f;\nll odr[maxn],cost[maxn][maxn],sea[maxn][maxn],land[maxn][maxn];\nint n,m,w;\n\nvoid init() {\n    memset(cost,INF, sizeof(cost));\n    memset(sea,INF, sizeof(sea));\n    memset(land,INF, sizeof(land));\n    char s[5];\n    for(int i=0;i<m;i++) {\n        ll a,b,c;\n        scanf(\"%lld%lld%lld%s\",&a,&b,&c,s);\n        if(s[0] == 'S')\n            sea[a][b] = sea[b][a] = min(sea[a][b],c);\n        else\n            land[a][b] = land[b][a] = min(land[a][b],c);\n    }\n    scanf(\"%lld\",&w);\n    for(int i=1;i<=w;i++)\n        scanf(\"%lld\",&odr[i]);\n}\nvoid Floyd() {\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++) {\n                sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n                land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n            }\n}\nvoid get() {\n    for(int i=1;i<=n;i++)\n        sea[i][i] = land[i][i] = 0;\n    cost[1][odr[1]] = 0;\n    for(int i=1;i<=w;i++) {\n        for(int j=1;j<=n;j++) {\n            cost[i][j] = min(cost[i][j],cost[i-1][j]+land[odr[i-1]][odr[i]]);\n            for(int k=1;k<=n;k++) {\n                cost[i][k] = min(cost[i][k],cost[i-1][j]+land[odr[i-1]][j]+sea[j][k]+land[k][odr[i]]);\n            }\n        }\n    }\n    ll minn = 1e12;\n    for(int i=1;i<=n;i++)\n        minn = min(cost[w][i],minn);\n    printf(\"%lld\\n\",minn);\n}\nint main() {\n    while(scanf(\"%lld%lld\",&n,&m)) {\n    \tif(n==0&&m==0) break;\n        init();\n        Floyd();\n        get();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nconst lnt INF = 0xffffffffffff;\nlnt n,m,x,y,z,s;\nlnt dl[200][200];\nlnt ds[200][200];\nlnt vis[1000];\nlnt ans[200][1000];\nchar str[10];\nint main()\n{while(1){\n\tcin>>n>>m;\n\tif(!n&&!m) return 0;\n\t//for(int i=0;i<200;i++) {\n\t//\tfor(int j=0;j<1000;j++) {\n\t//\t\tif(j<200){\n\t//\t\t\tdl[i][j]=INF;\n\t//\t\t\tds[i][j]=INF;\n\t//\t\t}\n\t//\t\tans[i][j]=INF;\n\t//\t}\n\t//}\n\tfill(dl[0],dl[200],INF);\n\tfill(ds[0],ds[200],INF);\n\tfill(ans[0],ans[200],INF);\n\tfor(int i=0;i<n;i++) dl[i][i]=ds[i][i]=0;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%lld%lld%lld%s\",&x,&y,&z,str);\n\t\tx--; y--;\n\t\tif(*str=='L') dl[x][y]=dl[y][x]=z;\n\t\telse ds[x][y]=ds[y][x]=z;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n\t\t\t\tds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcin>>s;\n\tfor(lnt i=0;i<s;i++){\n\t\tcin>>vis[i];\n\t\tvis[i]--;\n\t}\n\tans[vis[0]][0]=0;\n\tfor(int i=1;i<s;i++){\n\t\tif(i==1){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tans[j][1]=ds[vis[0]][j]+dl[j][vis[1]];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<n;j++){//vis[i-1]????????????j????????????k ?????? vis[i]\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(j==k) ans[k][i]=min(ans[k][i],ans[j][i-1]+dl[vis[i-1]][vis[i]]);\n\t\t\t\t\telse ans[k][i]=min(ans[k][i],ans[j][i-1]+dl[vis[i-1]][j]+ds[j][k]+dl[k][vis[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlnt res=INF;\n\tfor(int i=0;i<n;i++) res=min(res,ans[i][s-1]);\n\tcout<<res<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF 1LL<<60\ntypedef long long ll;\n\nint N, M;\n\nll d1[200][200]; // Land\nll d2[200][200]; // Sea\n\nll dp[1010][200];\n\nint R;\nint Z[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> M)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) rep(j, 0, N) d1[i][j] = d2[i][j] = INF;\n\t\trep(i, 0, N) d1[i][i] = d2[i][i] = 0;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tint x, y, t; char sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\n\t\t\tif (sl == 'L')\n\t\t\t\td1[x][y] = d1[y][x] = t;\n\t\t\telse\n\t\t\t\td2[x][y] = d2[y][x] = t;\n\t\t}\n\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n\n\t\tcin >> R;\n\t\trep(i, 0, R) cin >> Z[i];\n\t\trep(i, 0, R) Z[i]--;\n\n\t\trep(i, 0, R) rep(j, 0, N) dp[i][j] = INF;\n\t\tdp[0][Z[0]] = 0;\n\n\t\trep(i, 0, R - 1) rep(j, 0, N) if (dp[i][j] != INF)\n\t\t{\n\t\t\tll dd = dp[i][j] + d1[Z[i]][Z[i + 1]];\n\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dd);\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tdd = dp[i][j] + d1[Z[i]][j] + d2[j][k] + d1[k][Z[i + 1]];\n\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dd);\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\trep(i, 0, N) ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 214748360012345\n\nlong l[200][200];\nlong s[200][200];\n\nlong dp[2][200];\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    fill(l[0], l[n], INF);\n    fill(s[0], s[n], INF);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      if(d=='L'){\n        l[a][b]=c;\n        l[b][a]=c;\n      } else {\n        s[a][b]=c;\n        s[b][a]=c;\n      }\n    }\n\n    rep(i,n) l[i][i] = s[i][i] = 0;\n    rep(k,n) rep(i,n) rep(j,n) l[i][j] = min(l[i][j], l[i][k]+l[k][j]);\n    rep(k,n) rep(i,n) rep(j,n) s[i][j] = min(s[i][j], s[i][k]+s[k][j]);\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    long * prev = dp[0];\n    long * crnt = dp[1];\n\n    fill(prev, prev+n, INF);\n    prev[route[0]] = 0;\n    rep(i,r-1){\n      // route[i] -> route[i+1]\n      fill(crnt, crnt+n, INF);\n      rep(j,n) if(prev[j]!=INF){\n        // ??????j??????????????¨?????????????§?\n        rep(k,n) crnt[k] = min(crnt[k], prev[j] + l[route[i]][j] + s[j][k] + l[k][route[i+1]]);\n        crnt[j] = min(crnt[j], prev[j] + l[route[i]][route[i+1]]);\n      }\n      swap(crnt, prev);\n    }\n\n    cout << *min_element(prev, prev+n) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\n\n\t\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m && n){\n\t\tint land[200][200] , ship[200][200] ;\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tint a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse      ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tint r; cin >> r;\n\t\tint R[1000];\t\n\t\trep(i,r)cin >> R[i] , R[i]--;\n\t\t\n\t\tint dp[2][200];\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tint newCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[(bit+1)%2][cur] = min(dp[(bit+1)%2][cur],dp[bit%2][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,200)dp[bit%2][j] = INF;\n\t\t}\n\t\tint ret = INF;\n\t\trep(i,n){\n\t\t\tret = min(dp[(r-1)%2][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(int (i) = (s);(i) <= (e);(i)++)\n#define all(x) x.begin(),x.end()\n\nint N,M;\nint X[10101];\nint Y[10101];\ni64 T[10101];\nchar L[10101];\nint R;\nint Z[1010];\n\ni64 land[202][202];\ni64 sea[202][202];\n\nint solve(){\n  rep(i,0,N - 1) rep(j,0,N - 1) land[i][j] = sea[i][j] = 1e9;\n  rep(i,0,N - 1) land[i][i] = sea[i][i] = 0;\n  rep(i,0,M - 1){\n    cin >> X[i] >> Y[i] >> T[i] >> L[i];\n    X[i]--;\n    Y[i]--;\n    if(L[i] == 'L'){\n      land[X[i]][Y[i]] = min(land[X[i]][Y[i]],T[i]);\n      land[Y[i]][X[i]] = min(land[Y[i]][X[i]],T[i]);\n    }\n    else{\n      sea[X[i]][Y[i]] = min(sea[X[i]][Y[i]],T[i]);\n      sea[Y[i]][X[i]] = min(sea[Y[i]][X[i]],T[i]);\n    }\n  }\n  cin >> R;\n  rep(i,0,R - 1){\n    cin >> Z[i];\n    Z[i]--;\n  }\n  rep(k,0,N - 1) rep(i,0,N - 1) rep(j,0,N - 1)\n    land[i][j] = min(land[i][j] , land[i][k] + land[k][j]);\n  rep(k,0,N - 1) rep(i,0,N - 1) rep(j,0,N - 1)\n    sea[i][j] = min(sea[i][j] , sea[i][k] + sea[k][j]);\n  vector<vector<i64>> dp(R,vector<i64>(N,1e18));\n  dp[0][Z[0]] = 0;\n\n  rep(i,1,R - 1){\n    rep(j,0,N - 1){\n      rep(k,0,N - 1){\n        dp[i][j] = min(dp[i][j],dp[i - 1][k] + land[Z[i - 1]][k] + sea[k][j] + land[j][Z[i]]);\n        dp[i][k] = min(dp[i][k],dp[i - 1][k] + land[Z[i - 1]][Z[i]]);\n      }\n    }\n  }\n  i64 ans = 1e18;\n  rep(i,0,N - 1){\n    ans = min(ans , dp[R - 1][i]);\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> N >> M,N && M) solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nconst int INF = 10000000;\nconst int MAX_N = 200;\nconst int MAX_R = 1000;\n//struct edge {int };\n\nint main() {\n  // ifstream cin(\"../test.txt\");\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (!(N | M)) break;\n    // dl, dsの初期化\n    int dl[MAX_N][MAX_N]; // 陸路の最短距離\n    int ds[MAX_N][MAX_N]; // 海路の最短距離\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        if (i == j) {\n          dl[i][i] = 0;\n          ds[i][i] = 0;\n        } else {\n          dl[i][j] = INF;\n          ds[i][j] = INF;\n        }\n      }\n    }\n    int x, y, t;\n    char sl;\n    while (M--) {\n      cin >> x >> y >> t >> sl;\n      x--; y--;\n      if (sl == 'L') {\n        dl[x][y] = t;\n        dl[y][x] = t;\n      } else if (sl == 'S') {\n        ds[x][y] = t;\n        ds[y][x] = t;\n      }\n    }\n    // ワーシャルフロイド\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n        }\n      }\n    }\n    // 表示\n  //   cout << \"dl----------\" << endl;\n  //   for (int k = 0 ; k < N; k++) {\n  //    for (int i = 0; i < N; i++) {\n  //      cout << k+1 << \" \" << i+1 << \" \";\n  //      cout << dl[k][i] << endl;\n  //    }\n  //  }\n  //  cout << \"ds----------\" << endl;\n  //  for (int k = 0 ; k < N; k++) {\n  //   for (int i = 0; i < N; i++) {\n  //     cout << k+1 << \" \" << i+1 << \" \";\n  //     cout << ds[k][i] << endl;\n  //   }\n  // }\n  // cout << \"------------\" <<endl;\n    // dp 初期化\n    int dp[MAX_R][MAX_N];\n    int z[MAX_R];\n    int R;\n    cin >> R;\n    for (int i = 0; i < R; i++) {\n      cin >> z[i];\n      z[i]--;\n    }\n    for (int i = 0; i < R; i++) {\n      for (int j = 0; j < N; j++) {\n        dp[i][j] = INF;\n      }\n    }\n    dp[0][z[0]] = 0;\n    for (int j = 0; j < N; j++) {\n      dp[0][j] = ds[z[0]][j];\n    }\n    // dp 計算\n    int s, g;\n    for (int i = 1; i < R; i++) {\n      for (int j = 0; j < N; j++) {\n        s = z[i-1];\n        g = z[i];\n        // dp[i-1][k] + dl[s][k] + ds[k][j] + dl[j][g] の最小値\n        int min_s = INF;\n        for (int k = 0; k < N; k++) {\n          if (INF > dp[i-1][k] + dl[s][k] + ds[k][j])\n            min_s = min(min_s, dp[i-1][k] + dl[s][k] + ds[k][j]);\n        }\n        min_s += dl[j][g];\n        dp[i][j] = min(dp[i-1][j] + dl[s][g], min_s);\n      }\n    }\n    // 出力\n    int ans = INF;\n    for (int i = 0; i < N; i++) {\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct E{\n  int d,t;\n  bool s;\n};\n\nstruct S{\n  int t,x,p,b;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    vector<E> e[201];\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      E a={y,t,sl=='S'};\n      e[x].push_back(a);\n      E b={x,t,sl=='S'};\n      e[y].push_back(b);\n    }\n    int r;\n    cin>>r;\n    int z[1000];\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n    }\n    priority_queue<S> que;\n    S is={0,0,z[0],z[0]};\n    que.push(is);\n    int p[201][201]={{}};\n    fill(p[0],p[201],false);\n    for(;;){\n      S c=que.top();\n      if(c.x==r-1)break;\n      que.pop();\n      if(p[c.p][c.b]>c.x)continue;\n      p[c.p][c.b]=c.x;\n      for(int i=0;i<e[c.p].size();i++){\n\tE ce=e[c.p][i];\n\tif(!ce.s||c.b==c.p){\n\t  S n={c.t+ce.t,c.x+(ce.d==z[c.x+1]),ce.d,ce.s?ce.d:c.b};\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define inf 100000000\n\nlong long N,M;\nlong long disL[200][200];//隣接行列の重みバージョン陸\nlong long disS[200][200];//海\nlong long r ;\nlong long z[1000];\nlong long disP[1000][100]={};\n\n/*町番号は0からN-1とする（入力は1からN）*/\n\n/*町Z(num)からZr（終点）への最短時間（船が町shipにある状況で）を返す\nz  宅配順列の何番目か0->(r-1)\nship 船のある町番号0->N-1\n*/\nlong long recur(long long num,long long ship){\n  long long land,sea=inf,sm=ship,sp,i;\n\n  if(disP[num][ship]!=0)return disP[num][ship];\n  if(num>=r-1)return 0;\n  land=disL[z[num]][z[num+1]]+recur(num+1,ship);\n  \n  for(i=0;i<N;i++){\n    sp=disL[ z[num] ][ship] + disS[ship][i] + disL[i][ z[num+1] ] + recur(num+1,i);\n    if(sea>sp){\n      sea=sp;\n    }\n  }\n  disP[num][ship]=min(land,sea);\n  return disP[num][ship];\n}\n\n\nint main(){\n  long long i,j,k,x,y,t;\n  char ch;\n  while(true){\n\n    for(i=0;i<1000;i++)\n      for(j=0;j<100;j++)\n\tdisP[i][j]=0;\n\n    /*入力処理*/\n    cin >>N>>M;\n    if(N==0 && M==0)break;\n    for(i=0;i<M;i++){\n      for(j=0;j<M;j++){\n\tif(i!=j){\n\t  disL[i][j]=inf;\n\t  disS[i][j]=inf;\n\t}\n\telse {\n\t  disL[i][i]=0;\n\t  disS[i][i]=0;\n\t}\n      }\n    }\n    \n\n    /*陸路海路それぞれの最小値をセット*/\n    for(i=0;i<M;i++){\n      cin >>x>>y>>t>>ch;\n      if(ch=='L'){\n\tdisL[x-1][y-1]=min(disL[x-1][y-1],t);\n\tdisL[y-1][x-1]=min(disL[y-1][x-1],t);\n      }\n      else if(ch=='S'){\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n      }\n    }\n\n    priority_queue<long long> p_que;\n    /*陸、海それぞれで各町同士の最短経路を出す*/  \n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tfor(k=0;k<N;k++){\n\t  disL[j][k]=min(disL[j][k],disL[j][i]+disL[i][k]);\n\t  disS[j][k]=min(disS[j][k],disS[j][i]+disS[i][k]);\n\t}\n      }\n    }\n    cin >> r;\n    for(i=0;i<r;i++){\n      cin >> j;\n      z[i]=j-1;//町番号は0からN-1にする\n    }\n    cout << recur(0,z[0]) <<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\nint dijkstra(){\n  vector<vector<int> > D(n+1,vector<int>(r+1,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(D[ship][idx]<cost) continue;\n    \n    int npos=z[idx+1];\n    int ncost=cost+G[pos][npos][0];\n    if(pos!=ship&&D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    \n    for(int i=0;i<n&&ship==pos;i++){\n      ncost=cost+G[pos][i][1]+G[i][npos][0];\n      if(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n    }\n  }\n  return -1;  \n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\nint N,M;\nconst LL up=1000LL*1000LL*1000LL+1;\nLL l[200][200];\nLL s[200][200];\nvoid relax(LL mat[200][200])\n{\n\tfor(int k=0;k<N;k++){\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tmat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nLL buf[2][200];\ninline void clear(LL *b)\n{\n\tfor(int i=0;i<N;i++){\n\t\tb[i]=up;\n\t}\n}\nvoid exec()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tif(N==0&&M==0){\n\t\texit(0);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=0;j<N;j++){\n\t\t\tl[i][j]=s[i][j]=up;\n\t\t}\n\t\tl[i][i]=s[i][i]=0;\n\t}\n\n\tfor(int i=0;i<M;i++){\n\t\tint x,y,t;\n\t\tchar sl[2];\n\t\tscanf(\"%d%d%d%1s\",&x,&y,&t,sl);\n\t\tx--;\n\t\ty--;\n\t\tif(sl[0]=='L'){\n\t\t\tif(l[x][y]>t){\n\t\t\t\tl[x][y]=l[y][x]=t;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(s[x][y]>t){\n\t\t\t\ts[x][y]=s[y][x]=t;\n\t\t\t}\n\t\t}\n\t}\n\n\trelax(l);\n\trelax(s);\n\n\n\t/*\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i;j<N;j++){\n\t\t\tif(l[i][j]!=up)\n\t\t\t\t//cout << i+1 << \", \" << j+1 << \": \" << l[i][j] << endl;\n\t\t}\n\n\t}\n\t//cout << endl;\n\tfor(int i=0;i<N;i++){\n\t\tfor(int j=i;j<N;j++){\n\t\t\tif(s[i][j]!=up)\n\t\t\t\t//cout << i+1 << \", \" << j+1 << \": \" << s[i][j] << endl;\n\t\t}\n\t}\n\t//cout << endl;\n*/\n\tint R;\n\tscanf(\"%d\",&R);\n\tint z;\n\tint zz;\n\tscanf(\"%d\",&z);\n\tz--;\n\tLL *cur=buf[0];\n\tLL *nex=buf[1];\n\tclear(cur);\n\tcur[z]=0;\n\tzz=z;\n\tfor(int i=1;i<R;i++){\n\t\tclear(nex);\n\t\tscanf(\"%d\",&z);\n\t\tz--;\n\t\tfor(int b=0;b<N;b++){\n\t\t\tif(l[zz][b]==up){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int e=0;e<N;e++){\n\t\t\t\tif(l[e][z]==up||s[b][e]==up){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(b==e){\n\t\t\t\t\tnex[e]=min(nex[e],cur[b]+l[zz][z]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnex[e]=min(nex[e],cur[b]+l[zz][b]+s[b][e]+l[e][z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\t//cout << z+1 << endl;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif (nex[i]!=up)\n\t\t\t\t//cout << i+1 << \": \" << nex[i] << endl;\n\t\t}\n\t\t//cout << endl;\n\t\t*/\n\t\tzz=z;\n\t\tswap(nex,cur);\n\t}\n\tLL ret=up;\n\tfor(int i=0;i<N;i++){\n\t\tret=min(cur[i],ret);\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\nint main()\n{\n\twhile(true){\n\t\texec();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\nTASK: A2200 - Mr. Rito Post Office\nLANG: C++\nNAME: untitled.cpp\n*/\n#include <cstdio>\n#include <algorithm>\n\n#define NMAX 200\n#define RMAX 1000\nconst int INTMAX=0x0fffffff;\n\nusing namespace std;\n\nint n,m,swim[NMAX][NMAX],walk[NMAX][NMAX],route[RMAX],memo[RMAX][NMAX];\nbool bay[NMAX];\n\nint func(int pos,int ship)\n{\n\tif(-1!=memo[pos][ship]){\n\t\treturn memo[pos][ship];\n\t}\n\tif(0==pos){\n\t\tint ret=INTMAX;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(bay[i]){\n\t\t\t\tret = min(ret,swim[0][ship]+walk[ship][route[pos]]);\n\t\t\t}\n\t\t}\n\t\tif(0==ship) ret = min(ret,walk[0][route[pos]]);\n\t\treturn memo[pos][ship]=ret;\n\t}\n\n\tint ret=INTMAX;\n\tfor(int i=0;i<n;i++){\n\t\tif(bay[i]){\n\t\t\tret = min(ret,func(pos-1,i)+walk[route[pos-1]][i]+swim[i][ship]+walk[ship][route[pos]]);\n\t\t}\n\t}\n\tret = min(ret,func(pos-1,ship)+walk[route[pos-1]][route[pos]]);\n\n\treturn memo[pos][ship]=ret;\n}\n\nvoid solve()\n{\n\tfill(bay,bay+n,false);\n\tfor(int i=0;i<n;i++){\n\t\tfill(swim[i],swim[i]+n,INTMAX);\n\t\tfill(walk[i],walk[i]+n,INTMAX);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tswim[i][i] = 0; walk[i][i] = 0;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,t; char sl; scanf(\"%d%d%d\\n%c\",&x,&y,&t,&sl); x--; y--;\n\t\tif('L'==sl){\n\t\t\twalk[x][y] = walk[y][x] = min(walk[x][y],t);\n\t\t}else if('S'==sl){\n\t\t\tswim[x][y] = swim[y][x] = min(swim[x][y],t);\n\t\t\tbay[x] = bay[y] = true;\n\t\t}\n\t}\n\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\twalk[i][j] = walk[j][i] = min(walk[i][j],walk[i][k]+walk[k][j]);\n\t\t\t\tswim[i][j] = swim[j][i] = min(swim[i][j],swim[i][k]+swim[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint r; scanf(\"%d\",&r);\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d\",route+i); route[i]--;\n\t}\n\n\tint ret=INTMAX;\n\tfor(int i=0;i<r;i++){\n\t\tfill(memo[i],memo[i]+n,-1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(bay[i]){\n\t\t\tret = min(ret,func(r-1,i));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\n\treturn;\n}\n\nint main()\n{\n\t/*FILE *fin=NULL,*fout=NULL;\n\tfin = freopen(\"input.txt\",\"r\",stdin);\n\tfout = freopen(\"output.txt\",\"w\",stdout);*/\n\n\t//DP+Warshall-Floyd\n\t//func(i,j):i番目の集配先まで、j番目の町に船を置いて到着する最短時間。\n\n\twhile(scanf(\"%d%d\",&n,&m),0!=n){\n\t\tsolve();\n\t}\n\n\t//finalize\n\t/*if(NULL!=fin) fclose(fin);\n\tif(NULL!=fout) fclose(fout);*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL INF = 1e14;\n\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, R;\n  while(cin >> N >> M, N){\n\tfill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n\tfill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n\n\tREP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n\tREP(i,M){\n\t  LL x, y, t; char c;\n\t  cin >> x >> y >> t >> c;\n\t  --x, --y;\n\t  if(c == 'L')\n\t\tdist_L[x][y] = dist_L[y][x] = min(dist_L[x][y], t);\n\t  else\n\t\tdist_S[x][y] = dist_S[y][x] = min(dist_S[x][y], t);\n\t}\n\t\n\tREP(k,N) REP(i,N) REP(j,N){\n\t  dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n\t  dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n\t}\n\n\tcin >> R;\n\tVI RS(R);\n\tREP(i,R){\n\t  cin >> RS[i];\n\t  --RS[i];\n\t}\n\n\t// dp[i][j] :<=> i???????????§?¨???????????????£??????????????????j?????¨??????????°??????????\n\tfill((LL*)dp, (LL*)dp+1001*201, INF);\n\tdp[RS[0]][RS[0]] = 0;\n\tREP(i,R-1){\n\t  REP(u,N){\n\t\tREP(v,N){\n\t\t  dp[i+1][v] = min(dp[i+1][v],\n\t\t\t\t\t\t   // Rs[i] -> u????????§???u -> v????????§???v->RS[i+1]????????§?§????\n\t\t\t\t\t\t   dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n\t\t\t\t\t\t   );\n\t\t}\n\t  }\n\t}\n\n\tLL ans = INF;\n\tREP(u,N) ans = min(ans, dp[R-1][u]);\n\tcout << ans << endl;\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nint l[200][200],s[200][200];\n\nsigned main(void) {\n    int n,m;\n    while(cin >> n >> m, n){\n        rep(i,n)rep(j,n){\n            if(i != j)l[i][j] = s[i][j] = INF;\n            else l[i][j] = s[i][j] = 0;\n        }\n        rep(i,m){\n            int a,b,c;\n            string str;\n            cin >> a >> b >> c >> str;\n            a--,b--;\n            if(str == \"L\"){\n                int t = min(l[a][b], c);\n                l[a][b] = l[b][a] = t;\n            }else{\n                int t = min(s[a][b], c);\n                s[a][b] = s[b][a] = t;\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            l[i][j] = min(l[i][j],l[i][k]+l[k][j]);\n            s[i][j] = min(s[i][j],s[i][k]+s[k][j]);\n        }\n        /*\n        cout << \"land\\n\";\n        rep(i,n){rep(j,n)cout << \" \" << l[i][j];cout << endl;}\n        cout << \"sea\\n\";\n        rep(i,n){rep(j,n)cout << \" \" << s[i][j];cout << endl;}\n        */\n        int r;\n        cin >> r;\n        vi in(r);\n        rep(i,r)cin >> in[i],in[i]--;\n        vector<vi> dp(r,vi(n,INF));\n        //dp[i][j]:= i番目まで集配が終わり船がjにあるときの最小コスト\n        dp[0][in[0]] = 0;\n        rep(i,r-1){\n            //in[i]からin[i+1]に移動\n            rep(x,n)rep(y,n){//船がxからyに移動\n                int cost;\n                if(x != y)cost = l[in[i]][x] + s[x][y] + l[y][in[i+1]];\n                //in[i]からxに移動して、xからyまで船に乗り、yからin[i+1]に移動\n                else cost = l[in[i]][in[i+1]];\n                //船が移動しない場合は直接in[i+1]に向かう\n                dp[i+1][y] = min(dp[i+1][y], dp[i][x]+cost);\n            }\n        }\n        int ans = LINF;\n        rep(i,n)ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < r; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[r-1], dp[r-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <string.h>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mclr(n) memset(n, -1, sizeof(n))\n\n#define int long long\ntypedef pair<int, int> p;\nconst int INF = 1e16;\n\nint dp[1001][201];\n\nint ld[201][201];\nint sd[201][201];\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\trep(i, 201)rep(j, 201) {\n\t\t\tld[i][j] = sd[i][j] = INF;\n\t\t}\n\t\trep(i, 1001)rep(j, 201) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--; y--;\n\t\t\tif (s == 'S') {\n\t\t\t\tsd[y][x] = sd[x][y] = min(sd[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld[y][x] = ld[x][y] = min(ld[x][y], t);\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tdp[0][z[0]] = 0;\n\t\trep(i, r-1) {\n\t\t\trep(s, n) {\n\t\t\t\t//z[i]テ」ツ?凝」ツつ越[i+1]テ」ツ?ク\n\t\t\t\t//ティツ按ケテ」ツ?ョテ、ツスツ催ァツスツョテ」ツ?茎\n\t\t\t\ttypedef tuple<int, int, int> p;\n\t\t\t\tstatic int me[201][201];\n\t\t\t\tmclr(me);\n\t\t\t\tpriority_queue<p, vector<p>,greater<p>> q;\n\t\t\t\tq.push(p(dp[i][s], z[i], s));\n\t\t\t\tme[z[i]][s] = dp[i][s];\n\t\t\t\twhile (q.size()) {\n\t\t\t\t\tint cost = get<0>(q.top());\n\t\t\t\t\tint nw = get<1>(q.top());\n\t\t\t\t\tint sh = get<2>(q.top());\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif (me[nw][sh] < cost)continue;\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tif (me[j][sh] == -1 || me[j][sh] > ld[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\tme[j][sh] = ld[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\tq.push(p(me[j][sh], j, sh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sh == nw) {\n\t\t\t\t\t\t\tif (me[j][j] == -1 || me[j][j] > sd[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\t\tme[j][j] = sd[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\t\tq.push(p(me[j][j], j, j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(sh, n) {\n\t\t\t\t\tdp[i + 1][sh] = min(dp[i + 1][sh], me[z[i + 1]][sh]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(s, n) {\n\t\t\tans = min(ans, dp[r - 1][s]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define MAX 200\n#define INFTY (1<<21)\n\nint N, M, R, L[MAX][MAX], S[MAX][MAX];\nvector<int> O;\n\nvoid floyd(int D[MAX][MAX], int n){\n    rep(k, n) rep(i, n){\n\tif ( D[i][k] == INFTY ) continue;\n\trep(j, n){\n\t    if ( D[k][j] == INFTY ) continue;\n\t    D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t}\n    }\n}\n\nint compute(){\n    floyd(L, N);\n    floyd(S, N);\n    int T[1000][MAX];\n    rep(i, O.size()) rep(j, N) T[i][j] = INFTY;\n    \n    T[0][O[0]] = 0;\n\n    for ( int i = 1; i < R; i++ ){\n\tfor ( int j = 0; j < N; j++ ){\n\t    T[i][j] = min(T[i][j], T[i-1][j] + L[O[i-1]][O[i]]);\n\t    for ( int k = 0; k < N; k++ ){\n\t\tT[i][k] = min(T[i][k], T[i-1][j] + L[O[i-1]][j] + S[j][k] + L[k][O[i]]);\n\t    }\n\n\t}\n    }\n\n    int minv = INFTY;\n    rep(i, N) minv = min(minv, T[O.size()-1][i]);\n    return minv;\n\n}\n\nmain(){\n    int s, t, c;\n    char ch;\n    while(cin >> N >> M && N ){\n\tO.clear();\n\trep(i, N) rep(j, N) L[i][j] = S[i][j] = INFTY;\n\trep(i, N) L[i][i] = S[i][i] = 0;\n\trep(i, M){\n\t    scanf(\"%d %d %d\", &s, &t, &c); cin >> ch;\n\t    s--; t--;\n\t    if ( ch == 'L' ) L[s][t] = L[t][s] = min(L[s][t], c);\n\t    else S[s][t] = S[t][s] = min(S[s][t], c);\n\t}\n\tcin >> R;\n\trep(i, R){\n\t    cin >> s; s--;\n\t    O.push_back(s);\n\t}\n\tcout << compute() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + land[A][B]);\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINT_MAX)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<LL>> warshall_floyd(std::vector<std::vector<LL>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INT_MAX and matrix.at(m).at(e) != INT_MAX) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        vector<vector<LL>> matrix1(N, vector<LL>(N, INT_MAX)), matrix2(N, vector<LL>(N, INT_MAX));\n        FOR(i, 0, M) {\n            LL X, Y, T;\n            char S;\n            cin >> X >> Y >> T >> S;\n            X--; Y--;\n            if (S == 'L') {\n                matrix1[X][Y] = min(matrix1[X][Y], T);\n                matrix1[Y][X] = min(matrix1[Y][X], T);\n            }\n            else if (S == 'S') {\n                matrix2[X][Y] = min(matrix2[X][Y], T);\n                matrix2[Y][X] = min(matrix2[Y][X], T);\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> route(R);\n        FOR(i, 0, R) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        matrix1 = warshall_floyd(matrix1);\n        matrix2 = warshall_floyd(matrix2);\n\n        vector<vector<LL>> dp(R, vector<LL>(N, INF));\n        dp[0][route[0]] = 0;\n\n        FOR(i, 0, R - 1) {\n            int now = route[i];\n            int next = route[i + 1];\n\n            FOR(j, 0, N) {\n                if (dp[i][j] == INF) {\n                    continue;\n                }\n\n                FOR(k, 0, N) {\n                    // 船がjにあるとき、町nowから町jに陸路、町jから町kに海路、町kから町nextに陸路でいく\n                    LL dist = dp[i][j] + matrix1[now][j] + matrix2[j][k] + matrix1[k][next];\n                    dp[i + 1][k] = min(dp[i + 1][k], dist);\n                }\n            }\n        }\n\n        LL ans = INF;\n        FOR(i, 0, N) {\n            ans = min(ans, dp[R - 1][i]);\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long \n#define inf 0x3f3f3f3f\nLL e1[220][220],e2[220][220];\nLL f[1100][220],Iinf;\nint a[220];\nvoid init(int N){\n\tmemset(e1,inf,sizeof(e1));\n\tmemset(e2,inf,sizeof(e2));\n\tmemset(f,inf,sizeof(f));\n\tIinf=f[1][1];\n\tfor(int i=1;i<=N;++i) e1[i][i]=e2[i][i]=0;\n}\nint main(){\n\tint N,M,i,j,k,u,v,R;\n\tLL w;\n\tchar str[10];\n\twhile(scanf(\"%d%d\",&N,&M)==2){\n\t\tif(N==0&&M==0) break;\n\t\tinit(N);\n\t\twhile(M--){\n\t\t\tscanf(\"%d%d%lld\",&u,&v,&w);\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(!strcmp(str,\"L\")){\n\t\t\t\tif(w<e1[u][v]){\n\t\t\t\t\te1[u][v]=e1[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(w<e2[u][v]){\n\t\t\t\t\te2[u][v]=e2[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//floyd(e1,N);\n\t\t//floyd(e2,N);\n\t\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e1[i][j]==Iinf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te1[i][k]=min(e1[i][k],e1[i][j]+e1[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e2[i][j]==Iinf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te2[i][k]=min(e2[i][k],e2[i][j]+e2[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=1;i<=R;++i) scanf(\"%d\",a+i);\n\t\tfor(i=1;i<=N;++i) \n\t\tf[1][i]=min(f[1][i],e1[i][a[1]]+e2[i][a[1]]);\n\t\tfor(i=1;i<R;++i){\n\t\t\tfor(j=1;j<=N;++j){\n\t\t\t\tif(f[i][j]!=Iinf){\n\t\t\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\t\t\tif(e2[j][k]!=Iinf&&e1[a[i]][j]!=Iinf&&e1[a[i+1]][k]!=Iinf)\n\t\t\t\t\t\tf[i+1][k]=min(\n\t\t\t\t\t\tf[i+1][k],f[i][j]+e1[a[i]][j]+e1[a[i+1]][k]+e2[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf[i+1][j]=min(f[i+1][j],f[i][j]+e1[a[i]][a[i+1]]);\n\t\t\t}\n\t\t}\n\t\tLL ans=Iinf;\n\t\tfor(i=1;i<=N;++i) ans=min(ans,f[R][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e16;\nlong long int MOD = 1000000007;\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tlong long int CL[300][300], CS[300][300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tCL[i][j] = INF;\n\t\t\t\tCS[i][j] = INF;\n\t\t\t}\n\t\t\tCL[i][i] = 0;\n\t\t\tCS[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tlong long int u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(str == \"L\"){\n\t\t\t\tcost = min(cost, CL[u][v]);\n\t\t\t\tCL[u][v] = cost;\n\t\t\t\tCL[v][u] = cost;\n\t\t\t}else{\n\t\t\t\tcost = min(cost, CS[u][v]);\n\t\t\t\tCS[u][v] = cost;\n\t\t\t\tCS[v][u] = cost;\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++)\n\t\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tCL[i][j] = min(CL[i][j], CL[i][k] + CL[k][j]);\n\t\t\tCS[i][j] = min(CS[i][j], CS[i][k] + CS[k][j]);\n\t\t}\n\t\t\n\t\tint R, pre, num;\n\t\tcin >> R;\n\t\tcin >> pre;\n\t\tpre--;\n\t\t\n\t\tlong long int ans = INF, DP1[300], DP2[300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tDP1[i] = INF;\n\t\t}\n\t\tDP1[pre] = 0;\n\t\tfor(int i = 1; i < R; i++){\n\t\t\tcin >> num;\n\t\t\tnum--;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tDP2[j] = DP1[j] + CL[pre][num];\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tDP2[j] = min(DP2[j], CL[pre][k] + DP1[k] + CS[k][j] + CL[j][num]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(DP1, DP2);\n\t\t\tpre = num;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans = min(ans, DP1[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf = 1e12;\n\n\nint main(){\n    while(1){\n\tint n,m;\n\tcin>>n>>m;\n\tif(n==0)break;\n\t//ll gs[n][n]={inf},gl[n][n]={inf};\n\tvector<vector<ll> > gs(n,vector<ll>(n,inf) ),gl;\n\tgl = gs;\n\tll x[m],y[m],t[m];\n\tchar state[m];\n\tfor(int i=0;i<n;i++) gs[i][i] = gl[i][i] = 0;\n\tfor(int i=0;i<m;i++){\n\t    cin>>x[i]>>y[i]>>t[i]>>state[i];\n\t    x[i]--,y[i]--;\n\t    if(state[i]=='S'){\n\t\tgs[x[i]][y[i]] = min(gs[x[i]][y[i]],t[i]);\n\t\tgs[y[i]][x[i]] = min(gs[y[i]][x[i]],t[i]);\n\t    }else{\n\t\tgl[x[i]][y[i]] = min(gl[x[i]][y[i]],t[i]);\n\t\tgl[y[i]][x[i]] = min(gl[y[i]][x[i]],t[i]);\n\t    }\n\t}\n\n\tfor(int k=0;k<n;k++){\n\t    for(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t    gs[i][j] = min(gs[i][j],gs[i][k] + gs[k][j]);\n\t\t    gl[i][j] = min(gl[i][j],gl[i][k] + gl[k][j]);\n\t\t}\n\t    }\n\t}\n\tint r;\n\tcin>>r;\n\tll z[r];\n\tfor(int i=0;i<r;i++) cin>>z[i],z[i]--;\n\t//ll dp[r][n] = { inf };\n\tvector<vector<ll> > dp(r,vector<ll>(n,inf) );\n\tdp[0][z[0]] = 0;\n\tfor(int i=0;i<r-1;i++){\n\t    for(int j=0;j< n;j++){\n\t\tdp[i+1][j] = min(dp[i+1][j],dp[i][j] + gl[ z[i] ][ z[i+1] ] );\n\t\tfor(int k=0;k<n;k++){\n\t\t    dp[i+1][j] = min(dp[i+1][j],dp[i][k] + gl[z[i]][k] + gs[k][j] + gl[j][z[i+1]] ); \n\t\t}\n\t    }\n\t}\n\t/*for(int i=0;i<r;i++){\n\t    for(int j = 0;j<n;j++) cout<<dp[i][j]<<' ';\n\t    cout<<endl;\n\t}*/\n\n\tll res = inf;\n\tfor(int i=0;i<n;i++) res = min(res,dp[r-1][i] );\n\tcout<<res<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << \"0\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tif(R == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[z[0]][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + land[A][B]);\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*#include <cstdio>\n#include <algorithm>\n#include <limits>\n#include <queue>\n#include <vector>\n#include <utility>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconstexpr int MAX_N = 200, MAX_R = 1000, INF = std::numeric_limits<int>::max()>>2;\n\nstruct edge\n{\n  int to, cost;\n  bool ship;\n\n  edge( int to, int cost, bool ship )\n  : to(to), cost(cost), ship(ship)\n  {}\n};\n\nstruct State\n{\n  int dist, v, ord, shipP;\n\n  State( int dist, int v, int ord, int shipP )\n  : dist(dist), v(v), ord(ord), shipP(shipP)\n  {}\n\n  bool operator< ( const State &s ) const\n  { return this->dist > s.dist; }\n};\n\nint N, M;\nstd::vector<edge> G[MAX_N];\nint R;\nint z[MAX_R];\nshort dp[MAX_N][MAX_R][MAX_N];\n\nint main()\n{\n  while( scanf( \"%d%d\", &N, &M ), N|M )\n  {\n    rep( i, N )\n      G[i].clear();\n\n    rep( i, M )\n    {\n      int x, y, t;\n      char sl;\n      scanf( \"%d%d%d %c\", &x, &y, &t, &sl );\n      --x; --y;\n      //putchar(sl);\n      G[x].push_back( edge( y, t, sl=='S' ) );\n      G[y].push_back( edge( x, t, sl=='S' ) );\n    }\n\n    scanf( \"%d\", &R );\n    rep( i, R )\n      scanf( \"%d\", z+i ), --z[i];\n\n    std::priority_queue<State> pque;\n    pque.push( State( 0, z[0], 0, 0 ) );\n    std::fill( (int*)dp, (int*)(dp+N), INF );\n    dp[z[0]][0][0] = 0;\n\n    while( !pque.empty() )\n    {\n      State st = pque.top(); pque.pop();\n\n      if( st.dist > dp[st.v][st.ord][st.shipP] || st.ord == R-1 )\n        continue;\n\n      //printf( \"[%d %d %d %d]\\n\", st.dist, st.v, st.ord, st.shipP );\n\n      for( auto e : G[st.v] )\n      {\n        int nord = e.to == z[st.ord+1] ? st.ord+1 : st.ord;\n        \n        if( st.shipP == st.v && e.ship && dp[e.to][nord][e.to] > dp[st.v][st.ord][st.shipP]+e.cost )\n        {\n          dp[e.to][nord][e.to] = dp[st.v][st.ord][st.shipP]+e.cost;\n          pque.push( State( dp[e.to][nord][e.to], e.to, nord, e.to ) );\n        }\n\n        if( !e.ship && dp[e.to][nord][st.shipP] > dp[st.v][st.ord][st.shipP]+e.cost )\n        {\n          dp[e.to][nord][st.shipP] = dp[st.v][st.ord][st.shipP]+e.cost;\n          pque.push( State( dp[e.to][nord][st.shipP], e.to, nord, st.shipP ) );\n        }\n      }\n    }\n\n    short ans = INF;\n    rep( i, N )\n      ans = std::min( ans, dp[z[R-1]][R-1][i] );\n\n    printf( \"%d\\n\", ans );\n  }\n\n  return 0;\n}*/\n\n#include <cstdio>\n#include <algorithm>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconstexpr int MAX_N = 200, MAX_R = 1000, INF = std::numeric_limits<int>::max()>>2;\n\nint N, M;\nint sea[MAX_N][MAX_N], land[MAX_N][MAX_N];\nint R;\nint z[MAX_R];\nint dp[MAX_R+1][MAX_N];\n\nint main()\n{\n  while( scanf( \"%d%d\", &N, &M ), N|M )\n  {\n    std::fill( (int*)sea, (int*)(sea+N), INF );\n    std::fill( (int*)land, (int*)(land+N), INF );\n\n    rep( i, N )\n      sea[i][i] = land[i][i] = 0;\n\n    rep( i, M )\n    {\n      int x, y, t;\n      char sl;\n      scanf( \"%d%d%d %c\", &x, &y, &t, &sl );\n      --x; --y;\n\n      if( sl == 'S' )\n      {\n        sea[x][y] = std::min( sea[x][y], t );\n        sea[y][x] = std::min( sea[y][x], t );\n      }\n      else\n      {\n        land[x][y] = std::min( land[x][y], t );\n        land[y][x] = std::min( land[y][x], t );\n      }\n    }\n\n    scanf( \"%d\", &R );\n\n    rep( i, R )\n      scanf( \"%d\", z+i ), --z[i];\n\n    rep( k, N ) rep( i, N ) rep( j, N )\n    {\n      sea[i][j] = std::min( sea[i][j], sea[i][k]+sea[k][j] );\n      land[i][j] = std::min( land[i][j], land[i][k]+land[k][j] );\n    }\n\n    std::fill( (int*)dp, (int*)(dp+R), INF );\n    dp[0][z[0]] = 0;\n\n    rep( i, R-1 ) rep( j, N )\n    {\n      dp[i+1][j] = std::min( dp[i+1][j], dp[i][j]+land[z[i+1]][z[i]] );\n\n      rep( k, N )\n        dp[i+1][k] = std::min( dp[i+1][k], dp[i][j]+land[z[i]][j]+sea[j][k]+land[z[i+1]][k] );\n    }\n\n    printf( \"%d\\n\", *std::min_element( dp[R-1], dp[R-1]+N ) );\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\nusing namespace std;\n\nint N, M, R;\n\nstruct Edge {\n  int x, y, t;\n  char type;  // S or L\n} edges[10000];\n\nint visitOrder[1000];\n\n// dpWater[i][j] is the min time to move from i to j by water.\nint dpWater[200][200];\n\n// dpLand[i][j] is the min time to move from i to j by land.\nint dpLand[200][200];\n\nvoid calculateDp() {\n  memset(dpWater, -1, sizeof(dpWater));\n  for (int i = 0; i < N; ++i) {\n    dpWater[i][i] = 0;\n  }\n  memset(dpLand, -1, sizeof(dpLand));\n  for (int i = 0; i < N; ++i) {\n    dpLand[i][i] = 0;\n  }\n  for (int i = 0; i < M; ++i) {\n    int a = edges[i].x;\n    int b = edges[i].y;\n    if (edges[i].type == 'L') {\n      if (dpLand[a][b] == -1 || dpLand[a][b] > edges[i].t) {\n        dpLand[a][b] = dpLand[b][a] = edges[i].t;\n        //printf(\"dpLand[%d][%d] = %d\\n\", a, b, dpLand[a][b]);\n      }\n    } else {\n      if (dpWater[a][b] == -1 || dpWater[a][b] > edges[i].t) {\n        dpWater[a][b] = dpWater[b][a] = edges[i].t;\n        //printf(\"dpWater[%d][%d] = %d\\n\", a, b, dpWater[a][b]);\n      }\n    }\n  }\n  // Flood.\n  for (int k = 0; k < N; ++k) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i + 1; j < N; ++j) {\n        if (k == i || k == j) {\n          continue;\n        }\n        if (dpLand[i][k] != -1 && dpLand[k][j] != -1) {\n          int t = dpLand[i][k] + dpLand[k][j];\n          if (dpLand[i][j] == -1 || dpLand[i][j] > t) {\n            dpLand[i][j] = dpLand[j][i] = t;\n          }\n        }\n        if (dpWater[i][k] != -1 && dpWater[k][j] != -1) {\n          int t = dpWater[i][k] + dpWater[k][j];\n          if (dpWater[i][j] == -1 || dpWater[i][j] > t) {\n            dpWater[i][j] = dpWater[j][i] = t;\n          }\n        }\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < N; ++i) {\n    for (int j = i; j < N; ++j) {\n      printf(\"dpLand[%d][%d] = %d\\n\", i, j, dpLand[i][j]);\n    }\n  }\n  for (int i = 0; i < N; ++i) {\n    for (int j = i; j < N; ++j) {\n      printf(\"dpWater[%d][%d] = %d\\n\", i, j, dpWater[i][j]);\n    }\n  }\n  */\n}\n\nint getMinTime() {\n  calculateDp();\n  int dp[2][200];\n  memset(dp, -1, sizeof(dp));\n  dp[0][visitOrder[0]] = 0;\n  int *prev = dp[0];\n  int *cur = dp[1];\n  int source = visitOrder[0];\n  for (int i = 1; i < R; ++i) {\n    //printf(\"i = %d\\n\", i);\n    int target = visitOrder[i];\n    if (source == target) {\n      continue;\n    }\n    memset(cur, -1, sizeof(dp[0]));\n    for (int targetWater = 0; targetWater < N; ++targetWater) {\n      for (int sourceWater = 0; sourceWater < N; ++sourceWater) {\n        //printf(\"i = %d, source = %d, target = %d, sourceWater = %d, targetWater = %d\\n\",\n        //        i, source, target, sourceWater, targetWater);\n        if (prev[sourceWater] == -1) {\n          continue;\n        }\n        int t = -1;\n        if (sourceWater != targetWater) {\n          if (prev[sourceWater] == -1 || dpLand[source][sourceWater] == -1 ||\n              dpWater[sourceWater][targetWater] == -1 || dpLand[targetWater][target] == -1) {\n            continue;\n          }\n          t = prev[sourceWater] + dpLand[source][sourceWater] +\n                  dpWater[sourceWater][targetWater] + dpLand[targetWater][target];\n        } else {\n          if (prev[sourceWater] == -1 || dpLand[source][target] == -1) {\n            continue;\n          }\n          t = prev[sourceWater] + dpLand[source][target];\n        }\n        if (cur[targetWater] == -1 || cur[targetWater] > t) {\n          cur[targetWater] = t;\n          //printf(\"cur[%d] = %d\\n\", targetWater, t);\n        }\n      }\n    }\n    swap(prev, cur);\n    source = target;\n  }\n  int result = -1;\n  for (int i = 0; i < N; ++i) {\n    if (prev[i] != -1 && (result == -1 || result > prev[i])) {\n      result = prev[i];\n    }\n  }\n  return result;\n}\n\nint main() {\n  //freopen(\"MrRitoPostOffice.in\", \"r\", stdin);\n  //freopen(\"2200-input.txt\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &M) == 2 && !(N == 0 && M == 0)) {\n    for (int i = 0; i < M; ++i) {\n      char buf[10];\n      scanf(\"%d%d%d%s\", &edges[i].x, &edges[i].y, &edges[i].t, buf);\n      edges[i].x--;\n      edges[i].y--;\n      edges[i].type = buf[0];\n      //printf(\"edge %d, x %d, y %d, t %d, type %c\\n\", i, edges[i].x, edges[i].y, edges[i].t, edges[i].type);\n    }\n    scanf(\"%d\", &R);\n    for (int i = 0; i < R; ++i) {\n      scanf(\"%d\", &visitOrder[i]);\n      visitOrder[i]--;\n    }\n    int result = getMinTime();\n    printf(\"%d\\n\", result);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int M = 1000000007;\nconst int LM = 500000007;\n\nvoid warshallfloyd(vector<vector<int>>& d)\n{\n    int n = d.size();\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            for (int k = 0; k < n; ++k)\n                d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n}\n\n\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n\n        vector<vector<int>> led(n, vector<int>(n, LM));\n        vector<vector<int>> sed(n, vector<int>(n, LM));\n        for (int i = 0; i < n; ++i) {\n            led[i][i] = 0;\n            sed[i][i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x;\n            --y;\n            if (sl == 'L') {\n                led[x][y] = min(led[x][y], t);\n                led[y][x] = min(led[y][x], t);\n            }\n            else {\n                sed[x][y] = min(sed[x][y], t);\n                sed[y][x] = min(sed[y][x], t);\n            }\n        }\n        warshallfloyd(sed);\n        warshallfloyd(led);\n        int r;\n        cin >> r;\n        vector<int> dp(n, LM);\n        int prev;\n        cin >> prev;\n        --prev;\n        dp[prev] = 0;\n        for (int i = 0; i < r - 1; ++i) {\n            int z;\n            cin >> z;\n            --z;\n            vector<int> next(n, LM);\n            for (int j = 0; j < n; ++j) {\n                next[j] = min(next[j], dp[j] + led[prev][z]);\n                for (int k = 0; k < n; ++k) {\n                    next[j] = min(next[j], dp[k] + led[prev][k] + sed[k][j] + led[j][z]);\n                }\n            }\n            prev = z;\n            dp = next;\n        }\n        int ans = LM;\n        for (int i : dp) {\n            ans = min(ans, i);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\nconst int N = 210;\nconst int R = 1010;\nll ds[N][N], dl[N][N];\n\nll dp[R][N];\n\nll inf = 1e16;\nconst int DEBUG = 0;\n\nint main(void){\n  int n, m;\n  while (cin >> n >> m && n) {\n    REP(i, 0, n) {\n      REP(j, 0, n) {\n\tds[i][j] = dl[i][j] = i == j ? 0 : inf;\n      }\n    }\n    REP(loop_cnt, 0, m) {\n      int i, j;\n      ll t;\n      char sl;\n      cin >> i >> j >> t >> sl;\n      i--, j--;\n      if (sl == 'S') {\n\tds[i][j] = min(ds[i][j], t);\n\tds[j][i] = min(ds[j][i], t);\n      } else {\n\tdl[i][j] = min(dl[i][j], t);\n\tdl[j][i] = min(dl[j][i], t);\n      }\n    }\n    REP(k, 0, n) {\n      REP(i, 0, n) {\n\tREP(j, 0, n) {\n\t  ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t  dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t}\n      }\n    }\n    int r;\n    cin >> r;\n    VI z(r);\n    REP(i, 0, r) {\n      cin >> z[i];\n      z[i]--;\n    }\n    REP(i, 0, R) {\n      REP(j, 0, N) {\n\tdp[i][j] = inf;\n      }\n    }\n    dp[0][z[0]] = 0;\n    REP(i, 1, r) {\n      REP(j, 0, n) {\n\tREP(k, 0, n) {\n\t  ll sdist = dl[z[i - 1]][j] + ds[j][k] + dl[k][z[i]];\n\t  dp[i][k] = min(dp[i][k], dp[i - 1][j] + sdist);\n\t  if (j == k) {\n\t    ll ldist = dl[z[i - 1]][z[i]];\n\t    dp[i][j] = min(dp[i][j], dp[i - 1][j] + ldist);\n\t  }\n\t  if (DEBUG) {\n\t    cerr << \"dp[\" << i << \",\" << k << \"]=\" << dp[i][k] << endl;\n\t  }\n\t}\n      }\n    }\n    ll mi = inf;\n    REP(i, 0, n) {\n      mi = min(mi, dp[r - 1][i]);\n    }\n    cout << mi << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, m; \n    while (cin >> n >> m && n && m) {\n        vvll dl(n, vll(n, INF)), ds(n, vll(n, INF));\n        rep(i, n) dl[i][i] = ds[i][i] = 0;\n\n        rep(i, m) {\n            ll x, y, t; char sl; cin >> x >> y >> t >> sl; x--; y--;\n            (sl == 'L' ? dl : ds)[x][y] = (sl == 'L' ? dl : ds)[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n) \n            chmin(dl[i][j], dl[i][k]+dl[k][j]), chmin(ds[i][j], ds[i][k]+ds[k][j]);\n        /*\n        cout << \"dl\" << endl;\n        cout << dl << endl;\n        cout << \"ds\" << endl;\n        cout << ds << endl;\n        */\n\n        ll r; cin >> r;\n        vll z(r); rep(i, r) { cin >> z[i]; z[i]--; } \n\n        // ??????j???????????????i?????????????????????????????????????????????\n        vvll dp(r+1, vll(n, INF));\n        dp[0][z[0]] = 0;\n        rep(i, r) { \n            rep(j, n) { // j?????????\n                if (dp[i][j] == INF) continue;\n                rep(k, n) { // k???j?????????????????????, k????????????z[i]?????????\n                    if (ds[j][k] == INF) continue;\n                    chmin(dp[i+1][k], \n                            dp[i][j]/*????????§????????£????????????*/ + \n                            ds[i?z[i-1]:z[0]][j]/*j?????????????????????*/ +\n                            ds[j][k]/*j??????k????§????*/ + \n                            dl[k][z[i]]/*k??????????????´???????§????*/);\n\n                }\n                if (dl[i?z[i-1]:z[0]][z[i]] != INF)\n                    chmin(dp[i+1][j], \n                            dp[i][j]/*????????§????????£????????????*/ + \n                            dl[i?z[i-1]:z[0]][z[i]]/*????????´???????§????*/);\n            } \n            /*\n            rep(j, n) if (dp[i+1][j] != INF) \n                cout << i+1 << \" \" << j << \" : \" << dp[i+1][j] << endl;\n                */\n        }\n\n        ll ret = INF;\n        rep(j, n) {\n            chmin(ret, dp[n][j]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\nconst int INF=10000000;\n\nint n,m;\nint ldist[203][203];\nint sdist[203][203];\nint z[1003];\nint dp[1003][203];\n\nvoid solve() {\n    rep(i,203) rep(j,203) ldist[i][j]=sdist[i][j]=INF;\n    rep(i,203) ldist[i][i]=sdist[i][i]=0;\n    rep(i,m) {\n        int s,t,cost;\n        char c;\n        cin>>s>>t>>cost>>c;\n        if(c=='L') ldist[s][t]=ldist[t][s]=min(ldist[s][t],cost);\n        if(c=='S') sdist[s][t]=sdist[t][s]=min(sdist[s][t],cost);\n    }\n    rep(k,n+1) rep(i,n+1) rep(j,n+1) { \n        ldist[i][j]=min(ldist[i][j],ldist[i][k]+ldist[k][j]);\n        sdist[i][j]=min(sdist[i][j],sdist[i][k]+sdist[k][j]);\n    }\n\n    int R;\n    cin>>R;\n    rep(i,R) cin>>z[i];\n    //集配順,船の位置のDP\n\n    rep(i,1003) rep(j,203) dp[i][j]=INF;\n    dp[0][z[0]]=0;\n\n    for(int i=1;i<R;i++) rep(j,n+1) {\n        dp[i][j]=min(dp[i][j],dp[i-1][j]+ldist[z[i-1]][z[i]]);\n        rep(k,n+1) {\n            dp[i][k]=min(dp[i][k],dp[i-1][j]+ldist[z[i-1]][j]+\n                    sdist[j][k]+ldist[k][z[i]]);\n        }\n    }\n    int ans=INF;\n    rep(i,n+1) ans=min(ans,dp[R-1][i]);\n    cout<<ans<<endl;\n\n\n    \n}\nint main() {\n    while(cin>>n>>m) {\n        if(n+m==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef int gitype;\ntypedef long long LL;\ngitype gi () {\n    gitype ret=0; char ch=getchar();\n    while((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n    char c=ch=='-'?getchar():ch;\n    while(c>='0' && c<='9') ret=ret*10+c-'0',c=getchar();\n    return ch=='-'?-ret:ret;\n}\nconst int N = 500;\nconst int R = 2000;\nint n,m,tot;\nLL f[R][N],w1[N][N],w2[N][N];\nint main () {\n    while(scanf(\"%d%d\",&n,&m) && (n||m)) {\n        int u,v; LL t; char ops[10];\n        memset(w1,3,sizeof(w1));\n        memset(w2,3,sizeof(w2));\n        memset(f,3,sizeof(f));\n        for(int i=1;i<=m;i+=1) {\n            u=gi(); v=gi(); t=gi(); scanf(\"%s\",ops);\n            if(ops[0]=='L') w1[v][u] = w1[u][v] = min(w1[u][v],t);\n            else w2[v][u] = w2[u][v] = min(w2[u][v],t);\n        }\n        for(int i=1;i<=n;i+=1) w1[i][i]=w2[i][i]=0;\n        for(int k=1;k<=n;k+=1) {\n            for(int i=1;i<=n;i+=1) {\n                for(int j=1;j<=n;j+=1) {\n                    w1[i][j] = min(w1[i][j], w1[i][k] + w1[k][j]);\n                    w2[i][j] = min(w2[i][j], w2[i][k] + w2[k][j]);\n                    \n                }\n            }\n        }\n        int b,r=gi(); int p=gi(); LL ans=(1ll<<60);\n        f[1][p]=0;\n        for(int i=2;i<=r;i+=1) {\n            swap(b,p); p=gi();\n            for(int j=1;j<=n;j+=1) {\n                for(int k=1;k<=n;k+=1) {\n                    f[i][j] = min(f[i][j], f[i-1][k] + w1[b][k] + w2[k][j] + w1[j][p]);\n                }\n                f[i][j] = min(f[i][j], f[i-1][j] + w1[b][p]);\n                if(i==r) ans=min(ans,f[i][j]);\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\n// enum { kN = 202, kR = 1002, kInf = 1 << 28 };\nconst int kN = 202, kR = 1002, kInf = 1 << 28;\n\nint N, M, R, rs[kR];\nint dl[kN][kN], ds[kN][kN], dp[kR][kN];\n\nint solve() {\n  rep(i,N) ds[i][i] = dl[i][i] = 0;\n  for (int k = 0; k < N; ++k) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = 0; j < N; ++j) {\n        ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n        dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n      }\n    }\n  }\n  \n  dp[0][ rs[0] ] = 0;\n  \n  for (int i = 1; i < R; ++i) {\n    int from = rs[i-1], to = rs[i];\n    for (int j = 0; j < N; ++j) {\n      for (int k = 0; k < N; ++k) {\n        // 海路がひとつ存在する\n        dp[i][k] = min(dp[i][k],\n                       dp[i-1][j] + dl[from][j] + ds[j][k] + dl[k][to]);\n      }\n      // 陸路のみ\n      dp[i][j] = min(dp[i][j],\n                     dp[i-1][j] + dl[from][to]);\n    }\n\n    // for (int ii = 0; ii < R; ++ii) {\n    //   for (int jj = 0; jj < N; ++jj) {\n    //     printf(\" %d\", dp[ii][jj]);\n    //   }\n    //   puts(\"\");\n    // }\n    // puts(\"\");\n  }\n  \n  return *min_element(dp[R-1], dp[R-1] + kN);\n}\n\nint main() {\n  while (scanf(\"%d%d\", &N, &M) != -1, N | M) {\n    rep(i,kR) fill(dp[i], dp[i] + kN, kInf);\n    rep(i,kN) {\n      fill(dl[i], dl[i] + kN, kInf);\n      fill(ds[i], ds[i] + kN, kInf);\n    }\n    \n    int x, y, t; char sl;\n    rep(i,M) {\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      --x; --y;\n      assert(x >= 0);\n\n      if (sl == 'L')\n        dl[y][x] = dl[x][y] = t;\n      else\n        ds[y][x] = ds[x][y] = t;\n    }\n\n    scanf(\"%d\", &R);\n    rep(i,R) {\n      scanf(\"%d\", &x);\n      --x;\n      rs[i] = x;\n    }\n    printf(\"%d\\n\", solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N, M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n    \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int j = 0 ; j < N ; j++){\n        for(int i = 0 ; i < N ; i++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF ( 1<<29 )\n\nint N,M;\n\nint dp[1111][211];\nint WS[211][211];\nint WL[211][211];\n\nvoid warshall(int (*W)[211]){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n\tW[j][k] = min(W[j][k],W[j][i]+W[i][k]);\n}\n\nint main(){\n  while(  cin >> N >> M && ( N||M ) ){\n    fill(WS[0],WS[N],INF);\n    fill(WL[0],WL[N],INF);\n    fill(dp[0],dp[1001],INF);\n    for(int i=0;i<N;i++) WS[i][i] = WL[i][i] = 0;\n    for(int i=0;i<M;i++){\n      int x,y,t;\n      char s;\n      cin >> x >> y >> t >> s;\n      --x; --y;\n      if( s == 'L' ) WL[x][y] = WL[y][x] = t;\n      else WS[x][y] = WS[y][x] = t;\n    }\n    warshall(WL);\n    warshall(WS);\n    int R;\n    cin >> R;\n    int d; cin >> d;\n    --d;\n    dp[0][d] = 0;\n    for(int i=1;i<R;i++){\n      int nd; \n      cin >> nd; --nd;\n      for(int j=0;j<N;j++){\n\tif(dp[i-1][j] != INF ) {\n\t  dp[i][j] = min(dp[i][j],dp[i-1][j] + WL[d][nd]);\n\t  for(int k=0;k<N;k++){\n\t    dp[i][k] = min( dp[i][k],\n\t\t\t    dp[i-1][j] + WL[d][j] + WS[j][k] + WL[k][nd] );\n\t  }\n\t}\n      }\n      d = nd;\n    }\n    int res = INF;\n    for(int i=0;i<N;i++) res = min( res, dp[R-1][i] );\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAOJ 2200 Mr. Rito Post Office\n\n????????°???????????????????????????ACM-ICPC Japan??????????????????????¨?????????????????????????\n?????????????\\?????????????????????°??????????????¨?????????????????????????°´????????±??????????????°?°´\n??????????????¨????????¨X????????????????°±?????¨X????????????????????????????????????????¬??????°?°´???\n??????????????°X?????????????????????????????´?????????????????\\???????°´????????±?????????????????????\n?????§???????????????????????????????????????????????????????????¶?????????????????????????????????????¬?\n??§???????????????ABCB??????B????????????????????°????¬?????????????\n\n????????°???????????????\nN M\nx1 y1 t1 sl1\nx2 y2 t2 sl2\n???\nxM yM tM slM\nR\nz1 z2 ??? zR\n\nN (2 ??? N ??? 200) ??????????????°??????M (1 ??? M ??? 10000) ?????±???????°´????????????\n??°??????????¬¬2?????°?¬¬M + 1????????????????????°??????????????\\xi yi?????°???????????±?´? ti\n(1 ??? ti ??? 1000)??¶??´???sli ???L??¶??¨????????±??????S??¶??¨???????°´?????????????????????\n?????\\??????????????\\?????????????????¶???????????????????????????\n\nM + 2??????R????????????????????????????????°??????M + 3???????????????????????????????????????\n\n????§???¶????????????????????¨?¬¬??????????????????????????????????????°?????????????????????\n\n????????°??????0 0?????¶?????¨????????¢???\n\n */\n#include <assert.h>\n#include <ctype.h>\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/types.h>\n\n#include <algorithm>\n#include <complex>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define SZ(a) (int)(a).size()\n#define FOR(i,a,b) for (int i=(a); i<=(b); ++i)\n#define REP(i,n) for (int i=0; i<(n); ++i)\n#define ALL(c) c.begin(), c.end()\n#define CLR(c,n) memset(c, n, sizeof(c))\n#define TR(it, c) for(typeof(c.begin()) it = c.begin();it != c.end(); ++it)\n#define CONTAIN(it, c) (c.find(it) != c.end())\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntemplate <class T> void checkmin(T &a, T b) { if (b<a) a=b; }\ntemplate <class T> void checkmax(T &a, T b) { if (b>a) a=b; }\nconst int INF=0x1F1F1F1F;\n\nconst int N = 200;\n\nint distL[N][N], distS[N][N];\nint dp[2][N];\nint n, m;\n\nint main(int argc, char *argv[]) {\n  int x, y, t;\n  char sl;\n  while (scanf(\"%d %d\", &n, &m) == 2 && n + m > 0) {\n    CLR(distL, INF);\n    CLR(distS, INF);\n    REP(i, n) distL[i][i] = distS[i][i] = 0;\n    while (m--) {\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      --x;\n      --y;\n      switch (sl) {\n        case 'L':\n          checkmin(distL[x][y], t);\n          checkmin(distL[y][x], t);\n          break;\n        case 'S':\n          checkmin(distS[x][y], t);\n          checkmin(distS[y][x], t);\n          break;\n      }\n    }\n    REP(k, n) REP(i, n) REP(j, n) {\n      checkmin(distL[i][j], distL[i][k] + distL[k][j]);\n      checkmin(distS[i][j], distS[i][k] + distS[k][j]);\n    }\n    int current = 0, prev = 1, src=0, dst=0;\n    CLR(dp, INF);\n    dp[current][0] = 0;\n    for (scanf(\"%d\", &m); m; --m) {\n      src = dst;\n      scanf(\"%d\", &dst);\n      --dst;\n      swap(current, prev);\n      CLR(dp[current], INF);\n      REP(i, n) {\n\tif (dp[prev][i] == INF) continue;\n\tcheckmin(dp[current][i], dp[prev][i] + distL[src][dst]);\n\tif (distL[src][i] == INF) continue;\n\tREP(j, n) checkmin(dp[current][j], dp[prev][i] + distL[src][i] + distS[i][j] + distL[j][dst]);\n      }\n    }\n    printf(\"%d\\n\", *min_element(dp[current], dp[current] + n));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                //if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                //    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                //}\n                if (dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n\n    typedef tuple<int,int,int> tpl;\n    int dist[200][200];\n    fill_n((int*)dist,200*200,inf);\n    dist[z[0]][z[0]]=0;\n    rep(i,1,r){\n        priority_queue<tpl,vector<tpl>,greater<tpl>> que;\n        rep(j,0,n){\n            rep(k,0,n){\n                if(dist[j][k]==inf) continue;\n                if(j==z[i-1]) que.push(make_tuple(dist[j][k],j,k));\n                else dist[j][k]=inf;\n            }\n        }\n        while(!que.empty()){\n            auto t=que.top();\n            que.pop();\n            int d=get<0>(t),p1=get<1>(t),p2=get<2>(t);\n            if(d>dist[p1][p2]) continue;\n            for(auto &e:graph[p1][0]){\n                int d_=d+e.second,p_=e.first;\n                if(d_>=dist[p_][p2]) continue;\n                dist[p_][p2]=d_;\n                que.push(make_tuple(d_,p_,p2));\n            }\n            if(p1!=p2) continue;\n            for(auto &e:graph[p1][1]){\n                int d_=d+e.second,p_=e.first;\n                if(d_>=dist[p_][p_]) continue;\n                dist[p_][p_]=d_;\n                que.push(make_tuple(d_,p_,p_));\n            }\n        }\n    }\n    int ans=inf;\n    rep(i,0,n) ans=min(ans,dist[z.back()][i]);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\t<cstdio>\n#include\t<cstring>\n#include\t<iostream>\n#include\t<algorithm>\n\nusing\tnamespace\tstd;\nconst\tint INF = 100000000;\nconst\tint N = 210, M = 1010;\n\nint n, m;\nint z[M], d[M][N];\nint dl[N][N], ds[N][N];\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &n, &m ) == 2 && n )\n\t{\n\t\tfor( int i = 0; i < n; i ++ )\n\t\t{\n\t\t\tfor( int j = 0; j < n; j ++ )\n\t\t\t{\n\t\t\t\tif( i == j )\n\t\t\t\t\tdl[i][j] = ds[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tdl[i][j] = ds[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0; i < m; i ++ )\n\t\t{\n\t\t\tchar s[2];\n\t\t\tint u, v, t;\n\t\t\tscanf( \"%d%d%d%s\", &u, &v, &t, s );\n\t\t\tu --, v --;\n\t\t\tif( s[0] == 'L' )\n\t\t\t{\n\t\t\t\tdl[u][v] = min( dl[u][v], t );\n\t\t\t\tdl[v][u] = dl[u][v];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds[u][v] = min( ds[u][v], t );\n\t\t\t\tds[v][u] = ds[u][v];\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tscanf( \"%d\", &r );\n\t\tfor( int i = 0; i < r; i ++ )\n\t\t{\n\t\t\tscanf( \"%d\", &z[i] );\n\t\t\tz[i] --;\n\t\t}\n\t\tfor( int k = 0; k < n; k ++ )\n\t\t{\n\t\t\tfor( int i = 0; i < n; i ++ )\n\t\t\t{\n\t\t\t\tfor( int j = 0; j < n; j ++ )\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = min( dl[i][j], dl[i][k] + dl[k][j] );\n\t\t\t\t\tds[i][j] = min( ds[i][j], ds[i][k] + ds[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor( int i = 0; i < r; i ++ )\n\t\t\tfor( int j = 0; j < N; j ++ )\n\t\t\t\td[i][j] = INF;\n\t\tfor( int i = 0; i < n; i ++ )\n\t\t\td[0][i] = ds[z[0]][i] + dl[i][z[0]];\n\t\tfor( int i = 1; i < r; i ++ )\n\t\t{\n\t\t\tfor( int j = 0; j < n; j ++ )\n\t\t\t{\n\t\t\t\tfor( int k = 0; k < n; k ++ )\n\t\t\t\t{\n\t\t\t\t\tif( j != k )\n\t\t\t\t\t\td[i][j] = min( d[i][j], d[i-1][k] + dl[z[i-1]][k] + ds[k][j] + dl[j][z[i]] );\n\t\t\t\t\telse\n\t\t\t\t\t\td[i][j] = min( d[i][j], d[i-1][j] + dl[z[i-1]][z[i]] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor( int i = 0; i < n; i ++ )\n\t\t\tans = min( ans, d[r-1][i] );\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n#define FOR(i, a, b) for (int i = a; i < b; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for (int i = b - 1; i >= a; i--)\n#define RREP(i, n) RFOR(i, 0, n)\n#define rep(i, a, b) for (auto i = a; i < b; i++)\n#define rrep(i, a, b) for (auto i = a; i > b; i--)\n#define range(i, a, b) (a <= i && i < b)\n#define ll long long\n#define fi first\n#define fs sirst\n#define se second\n#define sc second\n//#define int long long\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\ntypedef pair<int, int> P;\n\nint n,m;\nint riku[1111][1111], umi[1111][1111];\nvec dp;\n\nvoid solve() {\n\tREP(i, n) REP(j, n) riku[i][j] = umi[i][j] = 1 << 28;\n\tREP(i, n) riku[i][i] = umi[i][i] = 0;\n\n\tREP(_, m) {\n\t\tint x, y, c; char s;\n\t\tcin >> x >> y >> c >> s;\n\t\tx--; y--;\n\t\tif (s == 'L') riku[x][y] = min(riku[x][y], c), riku[y][x] = min(riku[y][x], c);\n\t\telse umi[x][y] = min(umi[x][y], c), umi[y][x] = min(umi[y][x], c);\n\t}\n\n\tint r;\n\tcin >> r;\n\tvec a(r,0);\n\tREP(i, r) cin >> a[i], a[i]--;\n\t\n\tREP(k, n) {\n\t\tREP(i, n) {\n\t\t\tREP(j, n) {\n\t\t\t\triku[i][j] = min(riku[i][j],riku[i][k] + riku[k][j]);\n\t\t\t\tumi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tdp.assign(n, 1 << 28);\n\tdp[a[0]] = 0;\n\n\tREP(i, r-1) {\n\t\tvec tmp(n, 1 << 28);\n\t\tREP(j, n) {\n\t\t\ttmp[j] = min(tmp[j], dp[j] + riku[a[i]][a[i + 1]]);\n\n\t\t\tint base = riku[a[i]][j];\n\t\t\tREP(k, n) {\n\t\t\t\ttmp[k] = min(tmp[k], dp[j] + base + umi[j][k] + riku[k][a[i + 1]]);\n\t\t\t}\n\t\t}\n\t\tdp = tmp;\n\t}\n\tint ans = 1 << 30;\n\tREP(i, n) ans = min(ans, dp[i]);\n\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n >> m, n) solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\n\n#define ll long long int\n\nusing namespace std;\n\nconst int INF = (1<<25) - 1;\n\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    \n    int N, M;\n    while (cin>>N>>M, N|M) {\n        vector<vector<int>> dl(N, vector<int>(N, INF));\n        vector<vector<int>> ds(N, vector<int>(N, INF));\n        for(int i=0; i<N; i++)\n            dl[i][i] = ds[i][i] = 0;\n        \n        for(int i=0; i<M; i++){\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'L'){\n                dl[x][y] = min(dl[x][y], t);\n                dl[y][x] = min(dl[y][x], t);\n            }else{\n                ds[x][y] = min(ds[x][y], t);\n                ds[y][x] = min(ds[y][x], t);\n            }\n        }\n        int R; cin >> R;\n        vector<int> z(R);\n        for(auto &r: z){\n            cin >> r; r--;\n        }\n        for(int k=0; k<N; k++){\n            for(int i=0; i<N; i++){\n                for(int j=0; j<N; j++){\n                    ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n                    dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n                }\n            }\n        }\n        \n        // dp[i][j] := j?????????????????¶?????§z[i]?????§??\\?????????????°??????????\n        vector<vector<int>> dp(R, vector<int>(N, INF));\n        for(int i=0; i<N; i++)\n            dp[0][i] = ds[z[0]][i] + dl[i][z[0]];\n        \n        for(int i=1; i<R; i++){\n            for(int j=0; j<N; j++){\n                for(int k=0; k<N; k++){\n                    if(j == k)\n                        dp[i][j] = min(dp[i][j], dp[i-1][j] + dl[z[i-1]][z[i]]);\n                    else\n                        dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[z[i-1]][k] + ds[k][j] + dl[j][z[i]]);\n                }\n            }\n        }\n        \n        int ans = INF;\n        for(int i=0; i<N; i++)\n            ans = min(ans, dp[R-1][i]);\n        cout << ans << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],sea[z[0]][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < r; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[r-1], dp[r-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n#include <queue>\n#include <vector>\n#include <string.h>\nusing namespace std;\nlong long n, m;\nlong long l[210][210];\nlong long s[210][210];\nlong long dp[1010][210];// 到?第i个?子，船在j?\nlong long t[1010];\nint main()\n{\n    while(scanf(\"%lld%lld\", &n, &m), n || m )\n    {\n        memset(l, 1, sizeof(l));\n        memset(s, 1, sizeof(s));\n        memset(dp, 1, sizeof(dp));\n        for(long long i = 0; i < m; i++)\n        {\n            long long a, b, c;\n            char x;\n            scanf(\"%lld%lld%lld %c\", &a, &b, &c, &x);\n            if(x == 'L')\n                l[a][b] = l[b][a] = min(l[a][b], c);\n            else\n                s[a][b] = s[b][a] = min(s[a][b], c);\n        }\n        for(long long i = 1; i <= n; i++)\n            l[i][i] = s[i][i] = 0;\n        for(long long k = 1; k <= n; k++)\n            for(long long i = 1; i <= n; i++)\n                for(long long j = 1; j <= n; j++)\n                {\n                    l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                    s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n                }\n        long long r;\n        scanf(\"%lld\", &r);\n        for(long long i = 0; i < r; i++)\n            scanf(\"%lld\", &t[i]);\n        dp[0][1] = 0;\n        for(long long i = 1; i < r; i++)\n        {\n            for(long long j = 1; j <= n; j++) // 枚?第 i - 1 个?子的船的位置\n            {\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + l[ t[i - 1] ][ t[i] ]); // 走?路\n                for(long long k = 1; k <= n; k++) // 枚?第 i 个?子的船的位置\n                {\n                    dp[i][k] = min(dp[i][k], dp[i - 1][j] + l[ t[i - 1] ][ j ] + s[ j ][ k ] + l[ k ][ t[i] ]); // 走水路\n                }\n            }\n        }\n        long long ans;\n        for(long long i = 1; i <= n; i++)\n        {\n            if(i == 1)\n                ans = dp[r - 1][i];\n            else\n                ans = min(ans, dp[r - 1][i]);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n,m;\nint dl[200][200], ds[200][200],dp[1001][200];\nconst int inf = 500000000;\n\nint main() {\n while(cin >> n >> m, n) {\n  for (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dl[i][j] = ds[i][j] = inf;\n  for (int i = 0; i < n; i++)dl[i][i] = ds[i][i] = 0;\n  for (int i = 0; i < m; i++) {\n   int x,y,t;\n   char c;\n   cin >> x >> y >> t >> c;\n   x--, y--;\n   if (c == 'L') {\n    dl[x][y] = min(dl[x][y],t);\n    dl[y][x] = min(dl[y][x], t);\n   } else {\n    ds[x][y] = min(ds[x][y],t);\n    ds[y][x] = min(ds[y][x], t);\n   }\n  }\n  for (int k = 0; k < n; k++) {\n   for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n     dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n     ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n    }\n   }\n  }\n  int r, initz, pos;\n  cin >> r >> initz;\n  initz--;\n  for (int i = 0; i < r; i++)for (int j = 0; j < n; j++)dp[i][j] = inf;\n  dp[0][initz] = 0;\n  pos = initz;\n  for (int i = 1; i < r; i++) {\n   int z;\n   cin >> z;\n   z--;\n   for (int j = 0; j < n; j++) {\n    dp[i][j] = min(dp[i][j], dp[i-1][j] + dl[pos][z]);\n    for (int k = 0; k < n; k++) {\n     dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[pos][k] + ds[k][j] + dl[j][z]);\n    }\n   }\n   pos = z;\n  }\n  int ans = inf;\n  for (int i = 0; i < n; i++) {\n   ans = min(ans, dp[r-1][i]);\n  }\n  cout << ans << endl;\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2200&lang=jp\ntypedef long long ll;\n#define INF 1<<30\n#define LINF 1LL<<60\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tll N, M; \n\twhile (cin >> N >> M, N | M) {\n\t\tvector<vector<ll>> L(N + 1, vector<ll>(N + 1, INF)), S(N + 1, vector<ll>(N + 1, INF));\n\n\t\tfor (int i = 0; i < N + 1;i++) L[i][i] = S[i][i] = 0;\n\n\t\tfor (int i = 0; i < M;i++) {\n\t\t\tll x, y, t; char sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') { L[x][y] = L[y][x] = min(L[x][y],t); }\n\t\t\telse { S[x][y] = S[y][x] = min(S[x][y], t); }\n\t\t}\n\n\t\tfor (int i = 0; i < N+1;i++)\n\t\t\tfor (int j = 0; j < N+1;j++)\n\t\t\t\tfor (int k = 0; k < N + 1;k++) {\n\t\t\t\t\tS[j][k] = min(S[j][k], S[j][i] + S[i][k]);\n\t\t\t\t\tL[j][k] = min(L[j][k], L[j][i] + L[i][k]);\n\t\t\t\t}\n\n\t\tll R; cin >> R;\n\t\tvector<ll> z(R);\n\t\tfor (int i = 0; i < R; i++) cin >> z[i];\n\n\t\t/* dp[i][j] := collection and delivery to z[i] / ship is in j */\n\t\tvector<vector<ll>> dp(R, vector<ll>(N+1, INF));\n\t\tdp[0][z[0]] = 0;\n\t\tfor (int i = 1; i < R;i++) {\n\t\t\tfor (int j = 1; j < N + 1;j++) {\n\t\t\t\tif (dp[i - 1][j] == INF)continue;\n\t\t\t\t/* Overland route : z[i-1] -> z[i]  / ship is in j */\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + L[z[i - 1]][z[i]]);\n\t\t\t\t/* Overland and sea route: z[i-1] (Sea)-> k (Land)-> z[i] / ship move to k from j */\n\t\t\t\tfor (int k = 1; k < N + 1;k++) {\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + L[z[i - 1]][j] + S[j][k] + L[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tfor (int i = 1; i < N + 1;i++) ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\nll dp[210][210];\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tVV(pii) land(n);\n\t\tVV(pii) sea(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L'){\n\t\t\t\tland[a].PB(pii(b,c));\n\t\t\t\tland[b].PB(pii(a,c));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsea[a].PB(pii(b,c));\n\t\t\t\tsea[b].PB(pii(a,c));\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin>>r;\n\t\tvint dest(r);\n\t\trep(i,r) cin>>dest[i],dest[i]--;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tdp[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\tdp[dest[0]][dest[0]]=0;\n\t\treep(o,1,r){\n\t\t\ttypedef pair<ll,pii> P;\n\t\t\tpriority_queue<P> pq;\n\t\t\trep(i,n){\n\t\t\t\tif(dp[dest[o-1]][i]>=0){\n\t\t\t\t\tpq.push(mkp(-dp[dest[o-1]][i],pii(dest[o-1],i)));\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()){\n\t\t\t\tP top=pq.top();\n\t\t\t\tpq.pop();\n\t\t\t\tif(dp[top.S.F][top.S.S]>=0) continue;\n\t\t\t\tdp[top.S.F][top.S.S]=-top.F;\n\t\t\t\t// cout<<-top.F.F<<\" \"<<top.F.S<<\" \"<<top.S.F<<\" \"<<top.S.S<<endl;\n\t\t\t\tfor(pii x:land[top.S.F]){\n\t\t\t\t\tif(dp[x.F][top.S.S]==-1){\n\t\t\t\t\t\tpq.push(mkp(top.F-x.S,pll(x.F,top.S.S)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(top.S.F==top.S.S) for(pii x:sea[top.S.F]){\n\t\t\t\t\tif(dp[x.F][x.F]==-1){\n\t\t\t\t\t\tpq.push(mkp(top.F-x.S,pll(x.F,x.F)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=INFL;\n\t\t// dp[r-1][dest[r-1]]\n\t\t// cout<<r-1<<\" \"<<dest[r-1]<<endl;\n\t\trep(i,n){\n\t\t\tif(dp[dest[r-1]][i]==-1) continue;\n\t\t\tmins(ans,dp[dest[r-1]][i]);\n\t\t\t// cout<<dp[r-1][dest[r-1]][i]<<endl;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nvi p;\nusing t = vector<pair<int, void*>>;\nvpii ki;\nt* c(int i) {\n\tif (ki.size() == i)return nullptr;\n\tt* a=new t(ki[i].second + 1);\n\trep(j, ki[i].second + 1) {\n\t\t(*a)[j].second = c(i + 1);\n\t}\n\treturn a;\n}\nvoid add(int k, int i, t* a) {\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second+0);\n\t(*a)[s].first++;\n\tif (i == ki.size() - 1) {\n\t\treturn;\n\t}\n\tadd(k, i + 1, (t*)((*a)[s].second));\n}\nll cnt(int k, int i, t*a) {\n\tll c = 0;\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second + 0);\n\tif (i == ki.size() - 1) {\n\t\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += (*a)[j].first;\n\t\treturn c;\n\t}\n\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += cnt(k, i + 1, (t*)((*a)[j].second));\n\treturn c;\n}\nint lw[200][200], sw[200][200];\nint dp[2][200];\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tfill(lw[0], lw[200], numeric_limits<int>::max() / 8);\n\t\tfill(sw[0], sw[200], numeric_limits<int>::max() / 8);\n\t\trep(i, n)lw[i][i] = 0;\n\t\trep(i, n)sw[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tcmin(lw[x - 1][y - 1], t);\n\t\t\t\tcmin(lw[y - 1][x - 1], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmin(sw[x - 1][y - 1], t);\n\t\t\t\tcmin(sw[y - 1][x - 1], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(lw[i][j], lw[i][k] + lw[k][j]);\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(sw[i][j], sw[i][k] + sw[k][j]);\n\t\t}\n\t\tfill(dp[0], dp[1], numeric_limits<int>::max() / 8);\n\t\tint r;\n\t\tcin >> r;\n\t\tvi z(r);\n\t\trep(i, r)cin >> z[i];\n\t\tint prev = z[0] - 1;\n\t\tdp[0][z[0] - 1] = 0;\n\t\trep(i, m) {\n\t\t\tfill(dp[~i & 1], dp[(~i&1) + 1], numeric_limits<int>::max() / 8);\n\t\t\trep(j, n)rep(k, n) {\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][j] + sw[j][k] + lw[k][z[i] - 1]);\n\t\t\t}\n\t\t\tprev = z[i] - 1;\n\t\t}\n\t\tint ans = numeric_limits<int>::max() / 8;\n\t\trep(i, n)cmin(ans, dp[r & 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\nusing ll = long long;\n\nconst int MN = 220;\nconst int MR = 1100;\nconst ll INF = 1e9;\n\nll dp[MR][MN];\nll dist[MN][MN];\nll distS[MN][MN];\n\nbool solve() {\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            dist[i][j] = INF;\n            distS[i][j] = INF;\n            if (i == j) {\n                dist[i][j] = 0;\n                distS[i][j] = 0;\n            }\n        }\n    }\n    int n, m;\n    cin >> n >> m;\n    if (!n) return false;\n    for (int i = 0; i < m; i++) {\n        int x, y; ll t; char s;\n        cin >> x >> y >> t >> s; x--; y--;\n        if (s == 'L') {\n            dist[x][y] = dist[y][x] = min(dist[x][y], t);\n        } else {\n            distS[x][y] = distS[y][x] = min(distS[x][y], t);\n        }\n    }\n    for (int k = 0; k < n; k++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n            }\n        }\n    }\n    int r;\n    cin >> r;\n    int z0; cin >> z0; z0--;\n    fill_n(dp[0], n, INF);\n    dp[0][z0] = 0;\n    int b = z0;\n    r--;\n    for (int i = 0; i < r; i++) {\n        int p;\n        cin >> p; p--;\n        for (int j = 0; j < n; j++) {\n            dp[i+1][j] = dp[i][j] + dist[b][p];\n            for (int k = 0; k < n; k++) {\n                dp[i+1][j] = min(dp[i+1][j], dp[i][k]+dist[b][k]+distS[k][j]+dist[j][p]);\n            }\n        }\n        b = p;\n    }\n    ll ans = INF;\n    for (int i = 0; i < n; i++) {\n        ans = min(ans, dp[r][i]);\n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<unsigned char,unsigned char,short> tpl;\n    static int dist[200][200][1001];\n    fill_n((int*)dist,200*200*1001,inf);\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    dist[z[0]][z[0]][1]=true;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        if(d>dist[p1][p2][num]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p2][num_]) continue;\n            dist[p_][p2][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p2,num_)));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p_][num_]) continue;\n            dist[p_][p_][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p_,num_)));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <tuple>\n#include <string.h>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mclr(n) memset(n, -1, sizeof(n))\n\n#define int long long\ntypedef pair<int, int> p;\nconst int INF = 1e16;\n\nint dp[1001][201];\n\nint ld[201][201];\nint sd[201][201];\n\nsigned main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\trep(i, 201)rep(j, 201) {\n\t\t\tld[i][j] = sd[i][j] = INF;\n\t\t}\n\t\trep(i, 1001)rep(j, 201) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--; y--;\n\t\t\tif (s == 'S') {\n\t\t\t\tsd[y][x] = sd[x][y] = min(sd[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld[y][x] = ld[x][y] = min(ld[x][y], t);\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tdp[0][z[0]] = 0;\n\t\trep(i, r-1) {\n\t\t\trep(s, n) {\n\t\t\t\t//z[i]テ」ツ?凝」ツつ越[i+1]テ」ツ?ク\n\t\t\t\t//ティツ按ケテ」ツ?ョテ、ツスツ催ァツスツョテ」ツ?茎\n\t\t\t\ttypedef tuple<int, int, int> p;\n\t\t\t\tstatic int me[201][201];\n\t\t\t\tmclr(me);\n\t\t\t\tpriority_queue<p, vector<p>,greater<p>> q;\n\t\t\t\tq.push(p(dp[i][s], z[i], s));\n\t\t\t\tme[z[i]][s] = dp[i][s];\n\t\t\t\twhile (q.size()) {\n\t\t\t\t\tint cost = get<0>(q.top());\n\t\t\t\t\tint nw = get<1>(q.top());\n\t\t\t\t\tint sh = get<2>(q.top());\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif (me[nw][sh] < cost)continue;\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tif (me[j][sh] == -1 || me[j][sh] > ld[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\tme[j][sh] = ld[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\tq.push(p(me[j][sh], j, sh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sh == nw) {\n\t\t\t\t\t\t\tif (me[j][j] == -1 || me[j][j] > sd[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\t\tme[j][j] = sd[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\t\tq.push(p(me[j][j], j, j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(sh, n) {\n\t\t\t\t\tdp[i + 1][sh] = min(dp[i + 1][sh], me[z[i + 1]][sh]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(s, n) {\n\t\t\tans = min(ans, dp[r - 1][s]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\ntypedef pair<int,int> pi;\nconst int inf= 1<<28;\n\nint n,m,r,z[1000];\nint DL[200][200],DS[200][200];\n\nint dp[1000][200];\n\nint main(){\n\twhile(cin>>n>>m,n)\n\t{\n\t\trep(i,n)rep(j,n)DL[i][j]=DS[i][j]=inf;\n\t\t\n\t\trep(i,m)\n\t\t{\n\t\t\tint x,y,t; char c;\n\t\t\tcin>>x>>y>>t>>c; x--,y--;\n\t\t\tif(c=='L')DL[x][y]=DL[y][x]=min(DL[x][y],t);\n\t\t\tif(c=='S')DS[x][y]=DS[y][x]=min(DS[x][y],t);\n\t\t}\n\t\trep(i,n)DL[i][i]=DS[i][i]=0;\n\t\t\n\t\tcin>>r;\n\t\trep(i,r)cin>>z[i],z[i]--;\n\t\trep(i,r)rep(j,n)dp[i][j]=inf;\n\t\t\n\t\trep(k,n)rep(i,n)rep(j,n)\n\t\t{\n\t\t\tDL[i][j]=min(DL[i][j],DL[i][k]+DL[k][j]);\n\t\t\tDS[i][j]=min(DS[i][j],DS[i][k]+DS[k][j]);\n\t\t}\n\t\t\n\t\tdp[0][z[0]]=0;\n\t\tpriority_queue<pair<int,pi> > Q; Q.push(mp(0,mp(0,z[0])));\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint cc=Q.top().first;\n\t\t\tint cur=Q.top().second.first,ship=Q.top().second.second; Q.pop();\n\t\t\t\n\t\t\tif(dp[cur][ship]>-cc)continue;\n\t\t\tif(cur==r-1)\n\t\t\t{\n\t\t\t\tcout<<-cc<<endl; break;\n\t\t\t}\n\t\t\t\n\t\t\t//land\n\t\t\tint nc=cc-DL[z[cur]][z[cur+1]];\n\t\t\tif(DL[z[cur]][z[cur+1]]!=inf&&dp[cur+1][ship]>-nc)\n\t\t\t\tdp[cur+1][ship]=-nc,Q.push(mp(nc,mp(cur+1,ship)));\n\t\t\t\n\t\t\t//sea\n\t\t\trep(i,n)if(DL[z[cur]][ship]!=inf&&DS[ship][i]!=inf&&DL[i][z[cur+1]]!=inf)\n\t\t\t{\n\t\t\t\tnc=cc-DL[z[cur]][ship]-DS[ship][i]-DL[i][z[cur+1]];\n\t\t\t\tif(dp[cur+1][i]>-nc)\n\t\t\t\t\tdp[cur+1][i]=-nc,Q.push(mp(nc,mp(cur+1,i)));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) ((c).begin()), ((c).end())\n#define dump(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define REP(i, a, b) for (int i = a; i < (int)(b); i++)\n#define rep(i, n) REP(i, 0, n)\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\ndouble zero(double d) {\n    return d < EPS ? 0.0 : d;\n}\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    return os << '(' << p.first << ',' << p.second << ')';\n}\n\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &a) {\n    os << '[';\n    rep(i, a.size()) os << (i ? \" \" : \"\") << a[i];\n    return os << ']';\n}\n\n// to avoid error on mingw\nstring toString(int i) {\n    stringstream ss;\n    ss << i;\n    return ss.str();\n}\n\nconst int MOD = 1000000007;\n// a^k\nll fpow(ll a, ll k, int M) {\n    ll res = 1ll;\n    ll x = a;\n    while (k != 0) {\n        if ((k & 1) == 1)\n            res = (res * x) % M;\n        x = (x * x) % M;\n        k >>= 1;\n    }\n    return res;\n}\n\nint main() {\n    cout.setf(ios::fixed, ios::floatfield);\n    cout.precision(8);\n    ios_base::sync_with_stdio(false);\n\n    int N, M;\n    while(cin >> N >> M, (N|M)) {\n        vector< vi > dl(N, vi(N, INF));\n        vector< vi > ds(N, vi(N, INF));\n        rep(i, N) {\n            dl[i][i] = ds[i][i] = 0;\n        }\n\n        rep(i, M) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if(sl == 'L')\n                dl[x][y] = dl[y][x] = t;\n            else\n                ds[x][y] = ds[y][x] = t;\n        }\n\n        // WF\n        rep(k, N) {\n            rep(i, N) {\n                rep(j, N) {\n                    dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        int R;\n        cin >> R;\n        vi z(R);\n        rep(i, R) {\n            int tz;\n            cin >> tz;\n            z[i] = (--tz);\n        }\n\n        // dp[i][j] := z[i]まで移動し、船がjにある時の最小累計距離\n        vector<vi> dp(R, vi(N,INF));\n        dp[0][z[0]] = 0;\n\n        REP(i, 1, R) {\n            rep(j, N) {\n                // 陸路のみ\n                // もともと船がjにある場合のみ\n                if(dp[i-1][j] != INF) {\n                    dp[i][j] = min(dp[i][j],\n                                   dp[i - 1][j] + dl[z[i - 1]][z[i]]);\n                }\n                // 陸路 -> 海路 -> 陸路\n                // 海路でjに来る場合\n                rep(k, N) {\n                    if(dp[i-1][k] != INF) {\n                        dp[i][j] = min(dp[i][j],\n                                       dp[i - 1][k] + dl[z[i - 1]][k] + ds[k][j] + dl[j][z[i]]\n                        );\n                    }\n                }\n            }\n        }\n\n        cout << *min_element(all(dp[R-1])) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // {{{\n\n#define GET_MACRO(a, b, c, d, NAME, ...) NAME\n#define REP(...) GET_MACRO(__VA_ARGS__, REP4, REP3, REP2)(__VA_ARGS__)\n#define REP2(i, a) REP3(i, 0, a)\n#define REP3(i, a, b) REP4(i, a, b, 1)\n#define REP4(i, a, b, s) for (int i = (a); i < (int)(b); i += (s))\n#define REPR(...) GET_MACRO(__VA_ARGS__, REPR4, REPR3, REPR2)(__VA_ARGS__)\n#define REPR2(i, a) REPR3(i, 0, a)\n#define REPR3(i, a, b) REPR4(i, a, b, 1)\n#define REPR4(i, a, b, s) for (int i = (b)-1; i >= (int)(a); i -= (s))\n#define ALL(c) (c).begin(), (c).end()\n#define DUMP(x) (std::cerr << #x << ':' << ' ' << x << '\\n')\n#define TMPL_T template <typename T>\n#define TMPL_TU template <typename T, typename U>\n#define mut auto\n#define let const auto\n\nusing Int = long long;\n// clang-format off\nnamespace extio {\nstd::string delimiter=\" \",pdelimiter=\" \";\nstd::string bracket_b=\"\",bracket_e=\"\";\nvoid chdelim(const std::string&s){delimiter=s;}\nvoid chpdelim(const std::string&s){pdelimiter=s;}\nvoid chbracket(const std::string&b,const std::string&e){bracket_b=b,bracket_e=e;}\nTMPL_T  void pcont(std::ostream&os,const T&x){int c=0;for(const auto&a:x){if(c++)os<<delimiter;os<<a;}}\nTMPL_TU void ppair(std::ostream&os,const std::pair<T,U>&p){os<<bracket_b<<p.first<<pdelimiter<<p.second<<bracket_e;}\n}\nnamespace std {\nTMPL_T ostream& operator<<(ostream&os,const vector<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const set<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const multiset<T>&x){extio::pcont(os,x);return os;}\nTMPL_T ostream& operator<<(ostream&os,const deque<T>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const map<T,U>&x){extio::pcont(os,x);return os;}\nTMPL_TU ostream& operator<<(ostream&os,const pair<T,U>&x){extio::ppair(os,x);return os;}\nTMPL_T istream& operator>>(istream&is,tuple<int&,vector<T>&>x)\n{int N=get<0>(x);vector<T>&v=get<1>(x);v.clear();v.reserve(N);REP(i,N){T a;is>>a;v.emplace_back(a);}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<vector<T>&,int&>x){return is>>tie(get<1>(x),get<0>(x));}\nTMPL_T istream& operator>>(istream&is,tuple<int&,T*>x){int N=get<0>(x);T*v=get<1>(x);REP(i,N){is>>v[i];}return is;}\nTMPL_T istream& operator>>(istream&is,tuple<T*,int&>x){return is>>tie(get<1>(x),get<0>(x));}\n}\nTMPL_TU inline bool chmax(T&x,U a){return x<a&&(x=a,1);}\nTMPL_TU inline bool chmin(T&x,U a){return a<x&&(x=a,1);}\n\ninline int in(){int x;std::cin>>x;return x;}\n\nstruct Initializer_ {\n  Initializer_(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(0);\n    std::cout << std::setprecision(10);\n    std::cerr << std::setprecision(10);\n  }\n} precalc;\n// clang-format on\n// }}}\n\nusing namespace std;\n\nsigned main() {\n  int N, M;\n  while (N = in(), M = in(), N || M) {\n    int min_cost[2][222][222];\n    memset(min_cost, 0x1f, sizeof(min_cost));\n    REP(i, N) { min_cost[0][i][i] = min_cost[1][i][i] = 0; }\n    REP(i, M) {\n      int x, y, t;\n      string sl;\n      cin >> x >> y >> t >> sl;\n      x--, y--;\n      int k = \"L\" == sl;\n      chmin(min_cost[k][x][y], t);\n      chmin(min_cost[k][y][x], t);\n    }\n    int R = in();\n    vector<int> Z;\n    cin >> tie(R, Z);\n    for (auto&& z : Z) {\n      z--;\n    }\n    REP(k, N) REP(i, N) REP(j, N) {\n      chmin(min_cost[0][i][j], min_cost[0][i][k] + min_cost[0][k][j]);\n      chmin(min_cost[1][i][j], min_cost[1][i][k] + min_cost[1][k][j]);\n    }\n    int dp[1010][222];\n    memset(dp, 0x1f, sizeof(dp));\n    dp[0][Z[0]] = 0;\n    REP(i, R - 1) {\n      int cur = Z[i], nxt = Z[i + 1];\n      REP(j, N) {\n        chmin(dp[i + 1][j], dp[i][j] + min_cost[1][cur][nxt]);\n        REP(k, N) {\n          chmin(dp[i + 1][k],\n                dp[i][j] + min_cost[1][cur][j] + min_cost[0][j][k] + min_cost[1][k][nxt]);\n        }\n      }\n    }\n    cout << *min_element(dp[R - 1], dp[R]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := 集配先\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      if(dp[i][j] != inf)\n\t\t{\n\t\t  //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t\t  dp[i+1][j] = min(dp[i+1][j],\n\t\t\t\t   dp[i][j]+LG[v[i]][v[i+1]]);\n\t\t  //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl;\n\t\t} \n\t      rep(k,N)\n\t\t{\n\t\t  if(SG[v[i]][k] != inf)\n\t\t    {\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t       dp[i][v[i]] + SG[v[i]][k] + LG[k][v[i+1]]);\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst long long inf = 1LL<<55;\nconst int NODE = 210;\nint main()\n{\n  int n,m;\n  while(cin>>n>>m&&n&&m){\n    long long sea[n][n];\n    long long land[n][n];\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if( i!=j ){\n          sea[i][j]=land[i][j]=inf;\n        }else{\n          sea[i][j]=land[i][j]=0;\n        }\n      }\n    }\n    for(int i = 0; i < m; ++i){\n      int x,y;\n      long long t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x;\n      --y;\n      if( sl == 'S' ){\n        sea[x][y]=min(sea[x][y],t);\n        sea[y][x]=min(sea[y][x],t);\n      }else{\n        land[x][y]=min(land[x][y],t);\n        land[y][x]=min(land[y][x],t);\n      }\n    }\n    for(int k=0;k<n;++k){\n      for(int i=0;i<n;++i){\n        for(int j=0;j<n;++j){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    int R;\n    int cur,ship;\n    int prez,z;\n    long long preA[n][n];\n    long long A[n][n];\n    \n    cin >> R;\n    cin >> z;\n    --z;\n    cur = ship = z;\n    for(int j = 0; j < n; ++j){\n      for(int k = 0; k < n; ++k){\n        preA[j][k] = A[j][k] = inf;\n      }\n    }\n    A[cur][ship] = 0;\n    for(int i = 1; i < R; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          preA[j][k] = A[j][k];\n          A[j][k] = inf;\n        }\n      }\n      prez = z;\n      cin >> z;\n      --z;\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          A[z][k] = min( A[z][k], preA[prez][j] + land[prez][j] + sea[j][k] + land[k][z] );\n          //cout << z << ' ' << k << ' ' << A[z][k] << endl;\n        }\n      }\n    }\n    long long res = inf;\n    for(int i = 0; i < n; ++i){\n      res = min( res, A[z][i] );\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF (1e9)\n#define M 1005\n#define N 205\nusing namespace std;\ntypedef long long ll;\n\nll n,m,r,z[M],sld[2][N][N];\n\nvoid init(){\n  rep(i,2)\n    rep(j,n)\n      rep(k,n)\n        sld[i][j][k]=INF;  \n}\n\nvoid add_edge(ll sl,ll x,ll y,ll t){\n  sld[sl][x][y]=sld[sl][y][x]=min(sld[sl][x][y],t);\n}\n\nvoid warshall_floyd(){\n  rep(sl,2) rep(k,n) rep(i,n) rep(j,n)\n    sld[sl][i][j]=min(sld[sl][i][j],sld[sl][i][k]+sld[sl][k][j]);\n  rep(sl,2)\n    rep(i,n)sld[sl][i][i]=0;\n}\n\nll dp[M][N];\n\nvoid solve(){\n  rep(i,r)\n    rep(j,n)dp[i][j]=INF;\n  dp[0][z[0]]=0;\n  \n  rep(i,r-1)\n    rep(j,n){\n      if(dp[i][j]==INF)continue;\n      ll cost=dp[i][j]+sld[0][z[i]][z[i+1]];\n      dp[i+1][j]=min(dp[i+1][j],cost);\n      rep(k,n){\n\tll cost2=dp[i][j]+sld[0][z[i]][j];\n\tcost2+=sld[1][j][k]+sld[0][k][z[i+1]];\n\tdp[i+1][k]=min(dp[i+1][k],cost2);\n      }\n    }\n  ll ans=INF;\n  rep(i,n)ans=min(ans,dp[r-1][i]);\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    ll x,y,t;\n    char sl;\n    \n    init();\n    \n    rep(i,m){\n      cin>>x>>y>>t>>sl;\n      x--,y--;\n      if(sl=='L')add_edge(0,x,y,t);\n      else add_edge(1,x,y,t);\n    }\n    \n    warshall_floyd();\n \n    cin>>r;\n    rep(i,r)cin>>z[i],z[i]--;\n    \n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n\nconst int INF = 1e8;\n\nint main(){\n  int n,m,r;\n  while(cin >> n >> m){\n    if(n==0)break;\n    vector< vi > sg(n,vi(n,INF)),lg(n,vi(n,INF));\n    rep(i,n)sg[i][i] = lg[i][i] = 0;\n\n    rep(i,m){\n      int x,y,t;\n      char s;\n      cin >> x >> y >> t >> s; x--; y--;\n      if(s == 'L')lg[x][y] = lg[y][x] = t;\n      else sg[x][y] = sg[y][x] = t;\n    }\n\n    rep(k,n)rep(i,n)rep(j,n)lg[i][j] = min(lg[i][j], lg[i][k] + lg[k][j]);\n    rep(k,n)rep(i,n)rep(j,n)sg[i][j] = min(sg[i][j], sg[i][k] + sg[k][j]);\n\n    /*\n    rep(i,n){rep(j,n)cout << lg[i][j] << \" \"; cout << endl;}\n    rep(i,n){rep(j,n)cout << sg[i][j] << \" \"; cout << endl;}\n    */\n\n    cin >> r;\n    int cur; cin >> cur; cur--;\n    vi dis(n,INF); dis[cur] = 0;\n\n    rep(z,r-1){\n      int nxt; cin >> nxt; nxt--;\n      vi ndis(n,INF);\n\n      rep(i,n){\n\trep(j,n){\n\t  ndis[j] = min(ndis[j], dis[i] + lg[cur][i] + sg[i][j] + lg[j][nxt]);\n\t}\n      }\n\n      swap(dis,ndis);\n      cur = nxt;\n    }\n\n    cout << *min_element(dis.begin(), dis.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 111111111;\n\n\nstruct edge{\n    int f,t,c,id;\n    edge(){};\n    edge(int f_,int t_,int c_,int id_):f(f_),t(t_),c(c_),id(id_){};\n    bool operator< (const edge &e){\n        return c < e.c;\n    }\n};\n\nstruct graph{\n    vector<vector<edge> > E;\n    int V;\n    graph(int V_):E(V_),V(V_){};\n};\n\nvector< vector<int> > WF_L(graph &G){\n    vector< vector<int> > res(G.V,vector<int>(G.V,INF));\n    for(int i=0;i<G.V;i++)res[i][i] = 0;\n    for(auto&& V:G.E){\n        for(auto&& e:V){\n            if(e.id==0)continue;\n            res[e.f][e.t] = min(res[e.f][e.t],e.c);\n        }\n    }\n    for(int k=0;k<G.V;k++){\n        for(int i=0;i<G.V;i++){\n            for(int j=0;j<G.V;j++){\n                if(res[i][k]<INF && res[k][j]<INF)res[i][j] = min(res[i][j],res[i][k] + res[k][j]);\n            }\n        }\n    }\n    return res;\n}\n\nvector< vector<int> > WF_S(graph &G){\n    vector< vector<int> > res(G.V,vector<int>(G.V,numeric_limits<int>::max()/4));\n    for(int i=0;i<G.V;i++)res[i][i] = 0;\n    for(auto&& V:G.E){\n        for(auto&& e:V){\n            if(e.id==1)continue;\n            res[e.f][e.t] = min(res[e.f][e.t],e.c);\n        }\n    }\n    for(int k=0;k<G.V;k++){\n        for(int i=0;i<G.V;i++){\n            for(int j=0;j<G.V;j++){\n                if(res[i][k]<INF && res[k][j]<INF)res[i][j] = min(res[i][j],res[i][k] + res[k][j]);\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n,m;\n    while(true){\n        cin >> n >> m;\n        if(!n && !m)break;\n        graph G(n);\n        for(int i=0;i<m;i++){\n            int x,y,t;char s;\n            cin >> x >> y >> t >> s;\n            x--;y--;\n            G.E[x].emplace_back(x,y,t,(int)s=='L');\n            G.E[y].emplace_back(y,x,t,(int)s=='L');\n        }\n        int r;\n        cin >> r;\n        vector<int> R(r);\n        for(int i=0;i<r;i++){\n            cin >> R[i];R[i]--;\n        }\n        vector<vector<int> > L = WF_L(G);\n        vector<vector<int> > S = WF_S(G);\n        vector<vector<int> > dp(r,vector<int>(n,INF));\n        // cerr << L.size() << \" \" << L[0].size() << endl;\n        // cerr << dp.size() << \" \" << dp[0].size() << endl;\n        dp[0][R[0]] = 0;\n        //todo\n        //dp[wentRs][ship]\n        //land -> ship -> land\n        for(int i=0;i<r-1;i++){\n            // cerr << i << endl;\n            for(int j=0;j<n;j++){\n                // cerr << i << \" \" << j << endl;\n                if(L[R[i]][R[i+1]]<INF)dp[i+1][j] = min(dp[i+1][j],dp[i][j] + L[R[i]][R[i+1]]);\n                for(int k=0;k<n;k++){\n                    if(L[R[i]][k] < INF && S[k][j] < INF && L[j][R[i+1]] < INF)\n                        dp[i+1][j] = min(dp[i+1][j],dp[i][k] + L[R[i]][k] + S[k][j] + L[j][R[i+1]] );\n                }\n            }\n        }\n        int res = INF;\n        for(int i=0;i<n;i++){\n            res = min(dp[r-1][i],res);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e8;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint ldist[210][210];\nint sdist[210][210];\nint dp[210], dp2[210];\n\nint main() {\n\tifstream ifs(\"input.txt\");\n\twhile (true) {\n\t\tint n, m;\tifs >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n)\tldist[i][j] = sdist[i][j] = (i == j ? 0 : inf);\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tifs >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)\trep(i, n)\trep(j, n) {\n\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t}\n\t\tint r;\tifs >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tifs\t>> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, n)\tdp[i] = ldist[i][z[0]];\n\t\trep(i, n)\tdp2[i] = inf;\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n)\tdp2[j] = dp[j] + ldist[z[i - 1]][z[i]];\n\t\t\trep(j, n)\trep(k, n) {\n\t\t\t\tdp2[j] = min(dp2[j], dp[k] + ldist[z[i - 1]][k] + sdist[k][j] + ldist[j][z[i]]);\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tdp[j] = dp2[j];\n\t\t\t\tdp2[j] = inf;\n\t\t\t}\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = 10000000;\nint land[200][200];\nint sea[200][200];\nint dp[1000][200];\n\nint main() {\n    int N,M,R,x,y,i,j,k,t;\n  string s;\n  while(cin>>N>>M, N|M) {\n\n    rep(i,200) {\n      rep(j,200) land[i][j] = sea[i][j] = inf;\n      land[i][i] = sea[i][i] = 0;\n    }\n\n    rep(i,M) {\n      cin>>x>>y>>t>>s;\n      x--,y--;\n      if(s == \"S\") {\n\tsea[x][y] = min(t, sea[x][y]);\n\tsea[y][x] = sea[x][y];\n      }else{\n\tland[x][y] = min(t, land[x][y]);\n\tland[y][x] = land[x][y];\n      }\n    }\n\n    rep(k,N) {\n      rep(i,N) {\n\trep(j,N) {\n\t  sea[i][j] = min(sea[i][k]+sea[k][j], sea[i][j]);\n\t  land[i][j] = min(land[i][k]+land[k][j], land[i][j]);\n\t}\n      }\n    }\n\n    cin>>R;\n    vector<int> path;\n    rep(i,1000) rep(j,200) dp[i][j] = inf;\n    rep(i, R) {\n      int kt;\n      cin>>kt;\n      kt--;\n      path.push_back(kt);\n    }\n\n    dp[0][path[0]] = 0;\n    for(i=1; i<R; ++i) {\n      for(j=0; j<N; ++j) {\n\tdp[i][j] = min(dp[i-1][j]+land[path[i-1]][path[i]],dp[i][j]);\n\n\tfor(k=0; k<N; ++k) {\n\t  int t = dp[i-1][j]+land[path[i-1]][j]+sea[j][k]+land[k][path[i]];\n\t  dp[i][k] = min(dp[i][k], t);\n\t}\n\t//cout<<i<<\": \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n\n    int ans = inf;\n    rep(i,N) {\n      ans = min(ans, dp[R-1][i]);\n      //cout<<i<<\" : \"<<dp[R-1][i]<<endl;\n    }\n\n    cout<<ans<<endl;\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nconst long long INF = LLONG_MAX / 5;\n\nclass Edge\n{\npublic:\n    int to;\n    long long cost;\n    Edge(){};\n    Edge(int to0, long long cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<long long>& dist)\n{\n    dist.assign(edges.size(), INF);\n    dist[start] = 0;\n    priority_queue<pair<long long,int> ,vector<pair<long long,int> >, greater<pair<long long,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<long long, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n}\n\nvoid shortestPath(const vector<vector<Edge> >& edges, vector<vector<long long> >& dist)\n{\n    dist.resize(edges.size());\n    for(unsigned i=0; i<edges.size(); ++i)\n        shortestPath(edges, i, dist[i]);\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edgesLand(n), edgesSea(n);\n        for(int i=0; i<m; ++i){\n            int x, y, t;\n            char c;\n            cin >> x >> y >> t >> c;\n            -- x;\n            -- y;\n            if(c == 'L'){\n                edgesLand[x].push_back(Edge(y, t));\n                edgesLand[y].push_back(Edge(x, t));\n            }else{\n                edgesSea[x].push_back(Edge(y, t));\n                edgesSea[y].push_back(Edge(x, t));\n            }\n        }\n\n        vector<vector<long long> > costLand, costSea;\n        shortestPath(edgesLand, costLand);\n        shortestPath(edgesSea, costSea);\n\n        int r;\n        cin >> r;\n        vector<int> z(r+1, 0);\n        for(int i=1; i<=r; ++i){\n            cin >> z[i];\n            -- z[i];\n        }\n\n        vector<long long> dp(n, INF);\n        dp[0] = 0;\n        for(int i=1; i<=r; ++i){\n            vector<long long> next(n, INF);\n            for(int j=0; j<n; ++j)\n                next[j] = min(next[j], dp[j] + costLand[z[i-1]][z[i]]);\n\n            for(int j=0; j<n; ++j){\n                for(int k=0; k<n; ++k){\n                    long long cost = costLand[z[i-1]][j] + costSea[j][k] + costLand[k][z[i]];\n                    next[k] = min(next[k], dp[j] + cost);\n                }\n            }\n\n            dp.swap(next);\n        }\n\n        cout << *min_element(dp.begin(), dp.end()) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//{Headers\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<list>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n\nusing namespace std;\ntypedef vector< int > vi;\ntypedef vector< vi > vvi;\ntypedef pair< int,int > pii;\n#define mp(x,y) make_pair(x,y)\ntypedef long long ll;\n//}\n\nconst int MAXN=200,MAXR=1000;\nconst ll INF64=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nint N,R,z[MAXR+1];\nll s[MAXN+1][MAXN+1],l[MAXN+1][MAXN+1],dp[2][MAXN+1];\n\nvoid init(){\n    memset(s,INF,sizeof s);\n    memset(l,INF,sizeof l);\n    for(int i=1;i<=N;i++) s[i][i]=l[i][i]=0;\n}\n\nvoid Floyd(ll g[MAXN+1][MAXN+1]){\n    for(int k=1;k<=N;k++) for(int i=1;i<=N;i++) for(int j=1;j<=N;j++)\n        if(g[i][j]>g[i][k]+g[k][j])\n            g[i][j]=g[i][k]+g[k][j];\n}\n\nvoid solve(){\n    Floyd(s);\n    Floyd(l);\n    memset(dp,INF,sizeof dp);\n//    for(int i=1;i<=N;i++)\n//        dp[0][i]=min(INF64,s[z[1]][i]+l[z[1]][i]);\n    z[0]=z[1];\n    dp[0][z[1]]=0;\n#define last ((i+1)%2)\n#define curr (i%2)\n    /*\n     *              | Location | Boat |\n     * -------------+----------+------|\n     * dp[last][lb] |  Z[i-1]  |  lb  |\n     * dp[curr][cb] |   Z[i]   |  cb  |\n     *\n     *                       L       S       L\n     *   Move order: Z[i-1] ---> lb ---> cb ---> Z[i]\n     *                      L       S       L\n     * Search order: Z[i] <--- cb <--- lb <--- Z[i-1]\n     */\n/* First cb, second lb */\n    for(int i=1;i<=R;i++) for(int cb=1;cb<=N;cb++){\n        dp[curr][cb]=min(dp[last][cb]+l[z[i-1]][z[i]],INF64);\n        if(l[z[i]][cb]==INF64) continue;\n        for(int lb=1;lb<=N;lb++){\n            if(s[lb][cb]==INF64 || l[z[i-1]][lb]==INF64 || dp[last][lb]==INF64)\n                continue;\n            int dt=dp[last][lb]+l[z[i-1]][lb]+s[lb][cb]+l[cb][z[i]];\n            if(dp[curr][cb]>dt)\n                dp[curr][cb]=dt;\n        }\n    }\n/* First lb, second cb */\n//    for(int i=1;i<=R;i++){\n//        for(int j=1;j<=N;j++) dp[curr][j]=INF64;\n//        for(int lb=1;lb<=N;lb++) if(dp[last][lb]!=INF64){\n//            dp[curr][lb]=min(dp[last][lb]+l[z[i-1]][z[i]],dp[curr][lb]);\n//            if(l[z[i-1]][lb]==INF64) continue;\n//            for(int cb=1;cb<=N;cb++){\n//                if(s[lb][cb]==INF64 || l[z[i]][cb]==INF64 || dp[last][lb]==INF64)\n//                    continue;\n//                int dt=dp[last][lb]+l[z[i-1]][lb]+s[lb][cb]+l[cb][z[i]];\n//                if(dp[curr][cb]>dt)\n//                    dp[curr][cb]=dt;\n//            }\n//        }\n//    }\n#undef last\n#undef curr\n    ll ans=INF64;\n    for(int i=1;i<=N;i++) if(dp[R%2][i]<ans)\n        ans=dp[R%2][i];\n    printf(\"%lld\\n\",ans);\n}\n\nint main(void){\n//    freopen(\"in.txt\",\"r\",stdin);\n    int x,y,M;\n    ll t;\n    char sl;\n    while(~scanf(\"%d%d\",&N,&M) && N!=0){\n        init();\n        for(int i=0;i<M;i++){\n            scanf(\"%d%d%lld %c \",&x,&y,&t,&sl);\n            if(sl=='S') s[x][y]=s[y][x]=min(s[x][y],t);\n            else l[x][y]=l[y][x]=min(l[x][y],t);\n        }\n        scanf(\"%d\",&R);\n        for(int i=1;i<=R;i++) scanf(\"%d\",&z[i]);\n        solve();\n    }\n    return 0;\n}\n\n/*\nSample Input\n3 3\n1 2 5 L\n1 2 7 S\n2 3 11 S\n3\n1 2 3\n5 5\n1 2 15 L\n2 3 10 L\n4 5 7 L\n1 3 30 S\n3 4 100 S\n5\n1 3 5 4 1\n0 0\nOutput for the Sample Input\n18\n269\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[1010],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    int dis1=L[z[i-1]][k];\n                    int dis2=W[k][j];\n                    int dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tpublic:\n\tvvl d;\n\tGraph(int v){\n\t\tV=v;\n\t\td=vvl(v,vl(v,INF));\n\t\tfor(int i=0;i<v;i++) d[i][i]=0;\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\td[s][t]=c;\n\t\td[t][s]=c;\n\t}\n\tvoid solve(){\n\t\tfor(int k=0;k<V;k++) for(int i=0;i<V;i++) for(int j=0;j<V;j++) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t}\n};\n\nint n,m,r;\n\nint main(){\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(!n) break;\n\t\tGraph g(n),G(n);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint s,t,cost;\n\t\t\tchar c;\n\t\t\tcin>>s>>t>>cost>>c;\n\t\t\ts--;t--;\n\t\t\tif(c=='L') g.add_edge(s,t,cost);\n\t\t\telse G.add_edge(s,t,cost);\n\t\t}\n\t\tg.solve();\n\t\tG.solve();\n\t\tvl dp(n,INF);\n\t\tint v,u;\n\t\tcin>>r>>v;\n\t\tv--;\n\t\tdp[v]=0;\n\t\tu=v;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tcin>>v;\n\t\t\tv--;\n\t\t\tvl DP(n,INF);\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tDP[j]=dp[j]+g.d[u][v];\n\t\t\t\tfor(int k=0;k<n;k++) DP[j]=min(DP[j],dp[k]+g.d[u][k]+G.d[k][j]+g.d[j][v]);\n\t\t\t}\n\t\t\tdp=DP;\n\t\t\tu=v;\n\t\t}\n\t\tll res=INF;\n\t\tfor(int i=0;i<n;i++) res=min(res,dp[i]);\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n//mplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntypedef int Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  //cout<<from<<\",\"<<to<<\":\"<<cost<<endl;\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,cap,(int)g[from].size()-1,cost});\n}\nCost INF=5e8;\n//dij\nint n,m,r; \nint dij(Graph &g,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    //cout<<p;\n    if(v/n/n==r)return p.X;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n  return -1;\n}\nint fun(int p,int b,int r_){\n  return p+b*n+r_*n*n;\n}\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  while(cin>>n>>m,n){\n    vector<int> a(m),b(m),c(m);\n    vector<char> ch(m);\n    rep(i,m){\n      cin>>a[i]>>b[i]>>c[i]>>ch[i];\n      --a[i]; --b[i];\n    }\n    cin>>r;\n    vector<int> pos(r);\n    rep(i,r){\n      cin>>pos[i]; --pos[i];\n    }\n    //cout<<pos;\n    Graph g(n*n*(r+1));\n    rep(j,n)rep(k,r)\n      add_edge(g,fun(pos[k],j,k),fun(pos[k],j,k+1),1,0);\n    rep(i,m){\n      if(ch[i]=='L'){\n\trep(j,n)rep(k,r)\n\t  add_edge(g,fun(a[i],j,k),fun(b[i],j,k),1,c[i]);\n      }else{\n\trep(k,r)\n\t  add_edge(g,fun(a[i],a[i],k),fun(b[i],b[i],k),1,c[i]);\n      }\n    }\n    vector<Cost> dist(n*n*(r+1));\n    //cout<<\"g.size()\"<<g.size()<<endl;\n    cout<<dij(g,fun(pos[0],pos[0],0),dist)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        const int inf = ten(8);\n        int l[256][256], s[256][256];\n        rep(i, n) rep(j, n)\n            l[i][j] = s[i][j] = i == j ? 0 : inf;\n\n        while (m--)\n        {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if (sl == 'L')\n                l[x][y] = l[y][x] = t;\n            else\n                s[x][y] = s[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(l[i][j], l[i][k] + l[k][j]);\n            chmin(s[i][j], s[i][k] + s[k][j]);\n        }\n\n        int r, z[1024];\n        cin >> r;\n        input(z, r);\n        rep(i, r)\n            --z[i];\n        int dp[1024][256];\n        rep(i, r) rep(j, n)\n            dp[i][j] = inf;\n        dp[0][z[0]] = 0;\n        rep(i, r - 1) rep(j, n) rep(k, n)\n            chmin(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n        cout << *min_element(dp[r - 1], dp[r - 1] + n) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<cstring>\n#include<string>\nusing namespace std;\nint land[205][205],sea[205][205],tar[1005],dp[1005][205];\nint main()\n{\n    int n,m,i,j,k,r;\n    while(cin>>n>>m&&(n+m)){\n        memset(land,0x3f,sizeof(land));memset(sea,0x3f,sizeof(sea));memset(dp,0x3f,sizeof(dp));\n        for(i=1;i<=m;i++){\n            int a,b,c;string str;\n            cin>>a>>b>>c>>str;\n            if(str==\"S\")\n                sea[a][b]=sea[b][a]=c;\n            else\n                land[a][b]=land[b][a]=c;\n        }\n        for(i=1;i<=n;i++)land[i][i]=sea[i][i]=0;//不要忘了这个..\n        cin>>r;for(i=1;i<=r;i++)cin>>tar[i];\n        for(k=1;k<=n;k++)//floyd初始化,至于那些不可能的,初始化完了肯定还是无穷大不可能\n            for(i=1;i<=n;i++)\n                for(j=1;j<=n;j++){\n                    land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n                    sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n                }\n        dp[1][tar[1]]=0;//初始化\n        for(i=1;i<=r;i++)//从2开始也没问题\n            for(j=1;j<=n;j++){\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+land[tar[i-1]][tar[i]]);//单纯走陆路的情况,从tar[i-1]到tar[i]\n                for(k=1;k<=n;k++){//回到船停的j镇,水路从j到k,陆路k到tar[i],枚举k\n                    dp[i][k]=min((long long)dp[i][k],(long long)dp[i-1][j]+land[tar[i-1]][j]+sea[j][k]+land[k][tar[i]]);\n                 \n                }\n            }\n        int ans=0x7f7f7f7f;\n        for(i=1;i<=n;i++)\n            ans=min(ans,dp[r][i]);\n        cout<<ans<<endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\n\nconst int INF = 1 << 28;\nint N, M, R;\n\nvoid solve() {\n    mat dps(N, vec(N, INF));\n    mat dpl(N, vec(N, INF));\n    for (int i = 0; i < M; i++) {\n        int x, y, t;\n        char c;\n        cin >> x >> y >> t >> c;\n        x--, y--;\n        if (c == 'L') dpl[x][y] = dpl[y][x] = min(dpl[x][y], t);\n        if (c == 'S') dps[x][y] = dps[y][x] = min(dps[x][y], t);\n    }\n\n    for (int i = 0; i < N; i++) dpl[i][i] = dps[i][i] = 0;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            for (int k = 0; k < N; k++) {\n                dpl[j][k] = min(dpl[j][k], dpl[j][i] + dpl[i][k]);\n                dps[j][k] = min(dps[j][k], dps[j][i] + dps[i][k]);\n            }\n        }\n    }\n\n    cin >> R;\n    vec z(R);\n    for (auto& i : z) cin >> i, i--;\n\n    mat dp(R, vec(N, INF));\n    dp[0][z[0]] = 0;\n    for (int i = 0; i < R-1; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i+1][j] = min(dp[i+1][j], dp[i][j]+dpl[z[i]][z[i+1]]);\n            for (int k = 0; k < N; k++) {\n                dp[i+1][k] = min(dp[i+1][k],\n                                 dp[i][j]+dpl[z[i]][j]+dps[j][k]+dpl[k][z[i+1]]);\n            }\n        }\n    }\n\n    int ans = INF;\n    for (int i = 0; i < N; i++) {\n        ans = min(ans, dp[R-1][i]);\n    }\n\n    cout << ans << endl;\n}\n\nint main() {\n    while (cin >> N >> M, N || M) solve();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dp[200][200];\nvector<pii> edgel[200], edges[200];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n) {\n\t\t\tedgel[i].clear();\n\t\t\tedges[i].clear();\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\n\t\t\tscanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tedgel[x].push_back(mp(y, t));\n\t\t\t\tedgel[y].push_back(mp(x, t));\n\t\t\t}\n\t\t\telse if (sl == 'S') {\n\t\t\t\tedges[x].push_back(mp(y, t));\n\t\t\t\tedges[y].push_back(mp(x, t));\n\t\t\t}\n\t\t}\n\t\tint r;\tscanf(\"%d\", &r);\n\t\tvint z(r);\n\t\trep(i, r)\tscanf(\"%d\", &z[i]);\n\t\trep(i, n)\trep(j, n)\tdp[i][j] = inf;\n\t\tpriority_queue<pii> pq;\n\t\trep(i, n)\tdp[i][i] = 0;\n\t\trep(i, r) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n)\tif (dp[k][j] != inf)\tpq.push(mp(-dp[k][j], k));\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\t\t\tint dist = -it.fst, pos = it.scn;\n\t\t\t\t\tif (dist > dp[pos][j])\tcontinue;\n\t\t\t\t\trep(k, edgel[pos].size()) {\n\t\t\t\t\t\tint to = edgel[pos][k].fst, add = dist + edgel[pos][k].scn;\n\t\t\t\t\t\tif (dp[to][j] > add) {\n\t\t\t\t\t\t\tdp[to][j] = add;\n\t\t\t\t\t\t\tpq.push(mp(-add, to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) if (dp[j][j] != inf)\tpq.push(mp(-dp[j][j], j));\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\t\tint dist = -it.fst, pos = it.scn;\n\t\t\t\tif (dist > dp[pos][pos])\tcontinue;\n\t\t\t\trep(j, edges[pos].size()) {\n\t\t\t\t\tint to = edges[pos][j].fst, add = dist + edges[pos][j].scn;\n\t\t\t\t\tif (dp[to][to] > add) {\n\t\t\t\t\t\tdp[to][to] = add;\n\t\t\t\t\t\tpq.push(mp(-add, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tif (dp[j][j] != inf)\tpq.push(mp(-dp[j][j], j));\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\t\t\tint dist = -it.fst, pos = it.scn;\n\t\t\t\t\tif (dist > dp[pos][j])\tcontinue;\n\t\t\t\t\trep(k, edgel[pos].size()) {\n\t\t\t\t\t\tint to = edgel[pos][k].fst, add = dist + edgel[pos][k].scn;\n\t\t\t\t\t\tif (dp[to][j] > add) {\n\t\t\t\t\t\t\tdp[to][j] = add;\n\t\t\t\t\t\t\tpq.push(mp(-add, to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tif (j != z[i]) {\n\t\t\t\t\trep(k, n)\tdp[j][k] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[z[r - 1]][i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N, M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n    \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        if(i != next){\n          dp[r][i] = min(dp[r][i], dp[r-1][i] + G1[i][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<ll,P> State;\n\nconst ll INF = 1001001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Edge{\n    int to, cost;\n};\n\nll dl[200][200], ds[200][200], dp[1000][200];\nint N, M, R;\nint Z[1000];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        \n        REP(i, 200){\n            REP(j, 200){\n                if(i == j){\n                    dl[i][j] = 0;\n                    ds[i][j] = 0;\n                }else{\n                    dl[i][j] = INF;\n                    ds[i][j] = INF;\n                }\n            }\n        }\n\n        REP(i, M){\n            int from, to, cost;\n            char c;\n            std::cin >> from >> to >> cost >> c;\n            from--; to--;\n\n            if(c == 'L'){\n                dl[from][to] = std::min(dl[from][to], static_cast<ll>(cost));\n                dl[to][from] = std::min(dl[to][from], static_cast<ll>(cost));\n            }else if(c == 'S'){\n                ds[from][to] = std::min(ds[from][to], static_cast<ll>(cost));\n                ds[to][from] = std::min(ds[to][from], static_cast<ll>(cost));\n            }\n        }\n\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    dl[i][j] = std::min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = std::min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        std::cin >> R;\n        REP(i, R){\n            std::cin >> Z[i];\n            Z[i]--;\n        }\n\n        REP(i, 1000){\n            REP(j, 200){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][Z[0]] = 0;\n        \n        REP(i, R-1){\n            REP(j, N){\n                // A->陸->C->海->D->陸->B\n                REP(k, N){\n                    dp[i+1][j] = std::min(dp[i+1][j], dp[i][k] + dl[Z[i]][k] + ds[k][j] + dl[j][Z[i+1]]);\n                }\n                // A->陸->B\n                dp[i+1][j] = std::min(dp[i+1][j], dp[i][j] + dl[Z[i]][Z[i+1]]);\n            }\n        }\n\n        ll res = INF;\n        REP(i, N){\n            res = std::min(res, dp[R-1][i]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tif(R == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + land[A][B]);\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tassert(ans < INF);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 100000000\n#define MOD 1000000007\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\ntypedef int COST;\nstruct Path\n{\n\tint from;\n\tint to;\n\tCOST cost;\n\tCOST capacity;\n\tPath(int from = 0, int to = 0, COST cost = 0, COST capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, k) REP(j, k) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n, m);\n\t\tif (!(n | m)){ break; }\n\n\t\t// read\n\t\tvevector<int> landMap(n, n, INF), seaMap(n, n, INF);\n\n\t\tREP(_, n) { landMap[_][_] = seaMap[_][_] = 0; }\n\t\tREP(_, m)\n\t\t{\n\t\t\tREAD(int, x, y, t); READ(char, sl); x--; y--;\n\t\t\tif (sl == 'S') { seaMap[x][y] = seaMap[y][x] = min(seaMap[x][y], t); }\n\t\t\telse { landMap[x][y] = landMap[y][x] = min(landMap[x][y], t); }\n\t\t}\n\n\t\twarshall_floyd(landMap); // 陸路のみマップ\n\t\twarshall_floyd(seaMap); // 海路のみマップ\n\n\t\tREAD(int, R);\n\t\tvector<int> r = read<int>(R);\n\n\t\t\n\t\tvevector<int> dp(R, n, INF); // dp[i][j] 船をjにおいてi番目の町にいるよ。\n\t\tdp[0][r[0] - 1] = 0;\n\n\t\tFOR(i, 1, R) // 最後の町まで行く\n\t\t{\n\t\t\tint cur = r[i - 1] - 1, next = r[i] - 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\t// 船をjにおいたまま。\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + landMap[cur][next]); // 陸路のみ\n\n\t\t\t\t// 船をkに移動してから行く。\n\t\t\t\tREP(k, n)\n\t\t\t\t{\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + landMap[cur][j] + seaMap[j][k] + landMap[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = *min_element(allof(dp[R - 1]));\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nconst ll  INF  = 1LL << 50;\nconst int MAXN = 210;\nconst int MAXR = 1010;\n\nll l_dist[MAXN][MAXN];\nll s_dist[MAXN][MAXN];\nll dp[MAXR][MAXN];\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, R;\n\n  while (cin >> N >> M && N + M){\n    fill(&l_dist[0][0], &l_dist[0][0] + MAXN * MAXN, INF);\n    fill(&s_dist[0][0], &s_dist[0][0] + MAXN * MAXN, INF);\n    fill(&dp[0][0], &dp[0][0] + MAXN * MAXN, INF);\n\n    REP(i, N){\n      l_dist[i][i] = 0;\n      s_dist[i][i] = 0;\n    }\n\n    REP(i, M){\n      int x, y, t;\n      string sl;\n      \n      cin >> x >> y >> t >> sl; x--, y--;\n      if (sl == \"L\"){\n        l_dist[x][y] = l_dist[y][x] = min(l_dist[x][y], (ll)t);\n      } else {\n        s_dist[x][y] = s_dist[y][x] = min(s_dist[x][y], (ll)t);\n      }\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      l_dist[i][j] = min(l_dist[i][j], l_dist[i][k] + l_dist[k][j]);\n      s_dist[i][j] = min(s_dist[i][j], s_dist[i][k] + s_dist[k][j]);\n    }\n\n    cin >> R;\n    vector<int> zs(R);\n    REP(i, R){\n      cin >> zs[i]; zs[i]--;\n    }\n\n    dp[0][zs[0]] = 0;\n    \n    REP2(i, 1, R) REP(u, N) if (dp[i - 1][u] < INF){\n      // cout << i - 1 << \" \" << u << endl;\n      int cz = zs[i - 1];\n      int nz = zs[i];\n\n      dp[i][u] = min(dp[i][u], dp[i - 1][u] + l_dist[cz][nz]);\n      \n      REP(v, N){\n        dp[i][v] = min(dp[i][v], dp[i - 1][u] + l_dist[cz][u] + s_dist[u][v] + l_dist[v][nz]);\n      }\n    }\n    \n    ll res = INF;\n    REP(i, N){\n      res = min(res, dp[R - 1][i]);\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int INF=100000000;\nconst int MAX_V = 201;\nint n,m,r;\nint land[MAX_V][MAX_V];\nint sea[MAX_V][MAX_V];\nint citys[1001];\nvoid calcLandMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n}\nvoid calcSeaMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n}\nint dp[1001][201];\n// WzæªidxÌÔÚÌÆ±ëÅA{[gªboatÌm[hÉ éÆ«ÌÅ¬zBÔ\nint rec(int idx,int boat){\n    if(idx==r)\n        return 0;\n    if(dp[idx][boat]!=INF)\n        return dp[idx][boat];\n    int minTime=INF;\n    // ¤ÌÝðgÁÄB·éê\n    minTime=min(minTime,rec(idx+1,boat)+land[citys[idx-1]][citys[idx]]);\n    // CàgÁÄB·éê\n    // »ÝÌboatÌÊu©çBÅ«é`¬·×ÄÉÂ¢Ä·\n    for(int i = 0; i < n; i++){\n        minTime=min(minTime,rec(idx+1,i)+land[citys[idx-1]][boat]\n        + sea[boat][i] + land[i][citys[idx]]);\n    }\n    return dp[idx][boat]=minTime;\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(i==j)\n                    land[i][j]=sea[i][j]=0;\n                else\n                    land[i][j]=sea[i][j]=INF;\n            }\n        }\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char kind;\n            cin>>from>>to>>cost>>kind;\n            from--;to--;\n            if(kind=='L')\n                land[from][to]=land[to][from]=cost;\n            else\n                sea[from][to]=sea[to][from]=cost;\n        }\n        cin>>r;\n        for(int i = 0; i < r; i++){\n            cin>>citys[i];\n            citys[i]--;\n        }\n        calcLandMinDist();calcSeaMinDist();\n        // dpÅÅZ£ðßé\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)dp[i][j]=INF;\n        int res=rec(1,citys[0]);\n        cout<<res<<endl;\n    }\n\n    return 0;\n}\n/*\nÈº¦ÍÅ«P[XÅªöxÅoÍ³êéªAAOJÅÍà¿ëñTLE·éR[h\n_CNXg@ðgpµÄð¼Éð¢Ä¢é\n*/\n//struct edge{\n//\tint to;\n//\tint cost;\n//    char kind;\n//};\n//\n//class Situation{\n//public:\n//\tint cost;\n//\tint node;\n//    int boat;\n//    int obj;\n//\n//\tSituation(int cost_,int node_,int boat_,int obj_){\n//\t\tcost=cost_;\n//        node=node_;\n//        boat=boat_;\n//        obj=obj_;\n//\t}\n//\tSituation();\n//\n//\tbool operator<(const Situation &s)const{\n//\t\treturn s.cost < this->cost;\n//\t}\n//};\n//\n//int V;\n//int n,m;\n//\n//vector<int> objLands;\n//\n//const int MAX_V = 205;\n//const int MAX_M = 1001;\n//vector<edge> G[MAX_V];\n//int d[MAX_V][MAX_M][MAX_V];\n//const int INF = 1000000000;\n//\n//void dijkstra(int s){\n//\tpriority_queue<Situation> que;\n//    for(int i = 0; i < MAX_V; i++)\n//        for(int j = 0; j < MAX_M; j++)\n//            for(int k = 0; k < MAX_V; k++)\n//                d[i][j][k]=INF;\n//    d[s][0][s] = 0;\n//    que.push(Situation(0,s,s,0));\n//\twhile(!que.empty()){\n//\t\tSituation p = que.top();\n//\t\tque.pop();\n//        int node=p.node;\n//        int boat=p.boat;\n//        int cost=p.cost;\n//        int obj=p.obj;\n//        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n//\t\tif(d[node][obj][boat] < cost)\n//            continue;\n//\t\tfor(int i = 0; i < G[node].size(); i++){\n//\t\t\tedge &e = G[node][i];\n//            int toObj=obj;\n//            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n//            if(objLands[obj]==e.to)\n//                toObj++;\n//            // ¤ÌêÆCÌêÅêí¯\n//            if(e.kind=='L'){\n//                // ÅZ£\n//                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n//                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n//                    if(toObj!=objLands.size())\n//                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n//                }\n//            }\n//            else{\n//                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n//                if(boat==node){\n//                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n//                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n//                        if(toObj!=objLands.size())\n//                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n//                    }\n//                }\n//            }\n//\t\t}\n//\t}\n//}\n//\n//int main(){\n//\n//    while(cin>>n>>m&&!(n==0&&m==0)){\n//        objLands.clear();\n//        for(int i = 0; i < MAX_V; i++)\n//            G[i].clear();\n//        for(int i = 0; i < m; i++){\n//            int from,to,cost;\n//            char c;\n//            cin>>from>>to>>cost>>c;\n//            from--;to--;\n//            edge e;\n//            e.cost=cost;e.kind=c;e.to=to;\n//            G[from].push_back(e);\n//            e.to=from;\n//            G[to].push_back(e);\n//        }\n//        int t;\n//        cin>>t;\n//        int s;\n//        for(int i = 0; i < t; i++){\n//            if(i==0){\n//                cin>>s;\n//                s--;\n//            }\n//            else{\n//                int b;\n//                cin>>b;\n//                b--;\n//                objLands.push_back(b);\n//            }\n//        }\n//        dijkstra(s);\n//        int minCost=INF;\n//        for(int i = 0; i < n; i++){\n//            for(int j = 0; j < n; j++)\n//                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n//        }\n//        cout<<minCost<<endl;\n//    }\n//    return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\n\n#define fst first;\n#define snd second;\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) (x).begin(), (x).end()\n#define RANGE(x, y, w, h) (0 <= (x) && 0 <= (y) && (x) < (w) && (y) < (h))\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = (init); i < (n); i++)\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[] = {1,0,-1,0}, DY[] = {0,-1,0,1};\n\nint N, M;\n\nstruct Edge {\n    Edge(){};\n    Edge(int t, int c, bool s):\n        to(t), cost(c), is_sea(s){};\n    int to, cost;\n    bool is_sea;\n};\n\nvector<vector<Edge>> es;\n\nint R;\nVI rs;\n\nstruct State {\n    int v, where, ri, cost;\n    bool operator > (const State &s) const { return cost < s.cost; }\n};\n\nint solve() {\n    // costs[v][where][ri] = min_cost\n    vector<VVI> costs(N, VVI(N, VI(R + 1, INF)));\n\n    priority_queue<State, vector<State>, greater<State>> q;\n    {\n        State s;\n        s.v = rs[0];\n        s.cost = 0;\n        s.where = rs[0];\n        s.ri = 1;\n        q.push(s);\n        costs[s.v][s.where][s.ri] = 0;\n    }\n\n    while (q.size()) {\n        State cur = q.top();\n        q.pop();\n\n        if (cur.ri == R) continue;\n        if (cur.cost > costs[cur.v][cur.where][cur.ri]) continue;\n\n        for (auto &e : es[cur.v]) {\n            State n;\n            n.cost = cur.cost + e.cost;\n            n.ri = cur.ri + (rs[cur.ri] == e.to);\n            n.v = e.to;\n\n            if (e.is_sea) {\n                if (cur.where == cur.v) {\n                    n.where = n.v;\n                } else {\n                    continue;\n                }\n            } else {\n                n.where = cur.where;\n            }\n\n            if (costs[n.v][n.where][n.ri] > n.cost) {\n                costs[n.v][n.where][n.ri] = n.cost;\n                q.push(n);\n            }\n        }\n    }\n\n    // costs[rs[R - 1]][*][R]\n    int ans = INF;\n    rep (v, N) {\n        ans = min(ans, costs[rs[R - 1]][v][R]);\n    }\n\n    return ans;\n}\n\nint main(void) {\n    while (cin >> N >> M, N) {\n        es.clear();\n        es.resize(N);\n\n        rep(i, M) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n            es[x].EB(y, t, sl == 'S');\n            es[y].EB(x, t, sl == 'S');\n        }\n\n        cin >> R;\n        rs = VI(R);\n        for (auto &r : rs) {\n            cin >> r;\n            --r;\n        }\n\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x1f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvll land;\n\t\tvvll sea;\n\t\tinitvv(land,n,n,INFL);\n\t\tinitvv(sea,n,n,INFL);\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tll c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L') land[a][b]=mins(land[b][a],c);\n\t\t\telse sea[a][b]=mins(sea[b][a],c);\n\t\t}\n\t\trep(j,n) land[j][j]=sea[j][j]=0;\n\t\trep(k,n) rep(i,n) rep(j,n) mins(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n) rep(i,n) rep(j,n) mins(sea[i][j],sea[i][k]+sea[k][j]);\n\t\tint r;\n\t\tcin>>r;\n\t\tvint v(r);\n\t\trep(i,r){\n\t\t\tcin>>v[i],v[i]--;\n\t\t}\n\t\tvll pre(n,INFL);\n\t\tpre[v[0]]=0;\n\t\trep(i,r-1){\n\t\t\tvll dp(n,INFL);\n\t\t\trep(k,n){\n\t\t\t\trep(l,n){\n\t\t\t\t\tmins(dp[l],pre[k]+land[v[i]][k]+sea[k][l]+land[l][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp,pre);\n\t\t}\n\t\tcout<< *min_element(ALL(pre))<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dp[200][200];\nint ldist[200][200];\nint sdist[200][200];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n)\trep(j, n)\tldist[i][j] = sdist[i][j] = (i == j ? 0 : inf);\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)\trep(i, n)\trep(j, n) {\n\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t}\n\t\trep(i, n)\trep(j, n)\tdp[i][j] = (i == j ? 0 : inf);\n\t\trep(i, n)\trep(j, n) {\n\t\t\tif (i == j)\tcontinue;\n\t\t\tdp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i]);\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, n) {\n\t\t\tcin >> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, n)\tif (i != z[0])\trep(j, n)\tdp[i][j] = inf;\n\t\tsrep(i, 1, r) {\n\t\t\trep(j, n)\tif (j != z[i - 1])\trep(k, n) {\n\t\t\t\tdp[j][k] = min(dp[j][k], dp[z[i - 1]][k] + ldist[z[i - 1]][j]);\n\t\t\t}\n\t\t\trep(j, n)\trep(k, n)\tdp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k]);\n\t\t\trep(j, n)\trep(k, n)\tif (j != k) {\n\t\t\t\tdp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j]);\n\t\t\t}\n\t\t\trep(j, n)\tif (j != z[i])\trep(k, n)\tdp[j][k] = inf;\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[z[r - 1]][i]);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint main(){\n    std::ios::sync_with_stdio(0); cin.tie(0);\n    int n, m, x, y, t, r;\n    char sl;\n    while(scanf(\"%d%d\", &n, &m) &&  n!=0){\n        vector< vector<ll> > st(n, vector<ll>(n, LLONG_MAX)), lt(n, vector<ll>(n, LLONG_MAX));\n        rep(n){\n            st[i][i] = 0LL;\n            lt[i][i] = 0LL;\n        }\n        rep(m){\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'S'){\n                st[x][y] = t;\n                st[y][x] = t;\n            }else{\n                lt[x][y] = t;\n                lt[y][x] = t;\n            }\n        }\n\n        repp(k, n){\n            repp(i, n){\n                repp(j, n){\n                    if(st[i][k] != LLONG_MAX && st[k][j] != LLONG_MAX)\n                        st[i][j] = min(st[i][j], st[i][k] + st[k][j]);\n                    if(lt[i][k] != LLONG_MAX && lt[k][j] != LLONG_MAX)\n                        lt[i][j] = min(lt[i][j], lt[i][k] + lt[k][j]);\n                }\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(r){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // dp[i][j]: z[i]にいる，お船はjにあるときの最短時間\n        ll dp[r][n];\n        fill(dp[0], dp[r], LLONG_MAX);\n        dp[0][0] = 0LL;\n        repp(zi, r-1){\n            repp(j, n){\n                if(dp[zi][j] == LLONG_MAX) continue;\n                // 今の街に船があるなら，目的の街までor途中まで船で行ける\n                if(z[zi] == j){\n                    // z[zi]からkまで船で，kからz[zi+1]まで陸路で\n                    repp(k, n){\n                        if(st[z[zi]][k] != LLONG_MAX && lt[k][z[zi+1]] != LLONG_MAX){\n                            dp[zi+1][k] = min(dp[zi+1][k], dp[zi][j]+st[z[zi]][k]+lt[k][z[zi+1]]);\n                        }\n                    }\n                }\n                if(lt[z[zi]][z[zi+1]] != LLONG_MAX){\n                    dp[zi+1][j] = min(dp[zi+1][j], dp[zi][j] + lt[z[zi]][z[zi+1]]);\n                }\n            }\n        }\n\n        // rep(r){\n        //     repp(j, n){\n        //         printf(\"%5lld\", (dp[i][j] == LLONG_MAX?-1:dp[i][j]));\n        //     }\n        //     printf(\"\\n\");\n        // }\n\n        ll ans = LLONG_MAX;\n        repp(j, n){\n            ans = min(ans, dp[r-1][j]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<ll,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Edge{\n    int to, cost;\n};\n\nint dl[200][200], ds[200][200];\nll dp[1000][200];\nint N, M, R;\nint Z[1000];\n\nint main(){\n    while(std::cin >> N >> M, N){\n        \n        REP(i, 200){\n            REP(j, 200){\n                if(i == j){\n                    dl[i][j] = 0;\n                    ds[i][j] = 0;\n                }else{\n                    dl[i][j] = INF;\n                    ds[i][j] = INF;\n                }\n            }\n        }\n\n        REP(i, M){\n            int from, to, cost;\n            char c;\n            std::cin >> from >> to >> cost >> c;\n            from--; to--;\n\n            if(c == 'L'){\n                dl[from][to] = std::min(dl[from][to], cost);\n                dl[to][from] = std::min(dl[to][from], cost);\n            }else if(c == 'S'){\n                ds[from][to] = std::min(ds[from][to], cost);\n                ds[to][from] = std::min(ds[to][from], cost);\n            }\n        }\n\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    dl[i][j] = std::min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = std::min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        std::cin >> R;\n        REP(i, R){\n            std::cin >> Z[i];\n            Z[i]--;\n        }\n\n        REP(i, 1000){\n            REP(j, 200){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][Z[0]] = 0;\n        \n        REP(i, R-1){\n            REP(j, N){\n                REP(k, N){\n                    dp[i+1][j] = std::min(dp[i+1][j], dp[i][k] + dl[Z[i]][k] + ds[k][j] + dl[j][Z[i+1]]);\n                }\n            }\n        }\n\n        ll res = INF;\n        REP(i, N){\n            res = std::min(res, dp[R-1][i]);\n        }\n\n        std::cout << res << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define R cin>>\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    ll l[n][n],s[n][n];\n    rep(i,n)rep(j,n)l[i][j]=s[i][j]=MAX;\n    rep(i,m) {\n      ll x,y,z;\n      char c;\n      cin >> x >> y >> z >> c;\n      x--,y--;\n      if(c=='L') l[x][y]=l[y][x]=min(l[x][y],z);\n      else s[x][y]=s[y][x]=min(s[x][y],z);\n    }\n    rep(k,n)rep(i,n)rep(j,n) {\n      if(l[i][k]!=MAX && l[k][j]!=MAX) l[i][j]=min(l[i][j],l[i][k]+l[k][j]);\n      if(s[i][k]!=MAX && s[k][j]!=MAX) s[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n    }\n    int k;\n    R k;\n    vector<int> a(k);\n    rep(i,k) {\n      R a[i];\n      a[i]--;\n    }\n    ll d[k][n];\n    rep(i,k)rep(j,n) d[i][j]=MAX;\n    d[0][a[0]]=0;\n    REP(i,1,k) {\n      rep(j,n) {\n\trep(t,n) {\n\t  int d1=l[a[i]][t],d2=l[j][a[i-1]];\n\t  if(t==a[i]) d1=0;\n\t  if(j==a[i-1]) d2=0;\n\t  d[i][t]=min(d[i][t],d[i-1][j]+d1+s[t][j]+d2);\n\t}\n\td[i][j]=min(d[i][j],d[i-1][j]+l[a[i]][a[i-1]]);\n      }\n    }\n    ll ans=MAX;\n    rep(i,n) ans=min(ans,d[k-1][i]);\n    pr(ans);\n  }  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &st) const { return d > st.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n\n    \n    for(int k=0;k<n;k++){\n      L[k][k] = S[k][k] = 0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int l=0;l<2;l++){\n\t    if(l == 0){\n\t      if(L[i][k] >= INF || L[k][j] >= INF) continue;\n\t      L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t    }\n\t    else{\n\t      if(S[i][k] >= INF || S[k][j] >= INF) continue;\n\t      S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > dp(n2,vector<int>(n,INF));\n    dp[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  dp[i][j] = min(dp[i][j], dp[i-1][k] + L[dest[i-1]][k] + S[k][j] + L[j][dest[i]]);\n\t}\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;i++) ans = min(ans,dp[n2-1][i]);\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum\n{\n    MAX_V = 300 + 10, MAX_Z = 2000 + 50\n};\n\nconst long long INF = 1000000000000;\nlong long dp[MAX_Z][MAX_V];\nlong long SG[MAX_V][MAX_V], LG[MAX_V][MAX_V];\nint rt[MAX_Z], rtl;\nint n, m;\n\nvoid floyd()\n{\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = min(SG[i][j], SG[i][k] + SG[k][j]);\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                LG[i][j] = min(LG[i][j], LG[i][k] + LG[k][j]);\n    for(int i = 1; i <= n; i++)\n        LG[i][i] = SG[i][i] = 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n+m)\n    {\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = LG[i][j] = INF;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y;\n            long long cs;\n            char tp;\n            scanf(\"%d %d %lld %c\", &x, &y, &cs, &tp);\n            if(tp == 'S')\n            {\n                SG[x][y] = min(SG[x][y], cs);\n                SG[y][x] = min(SG[y][x], cs);\n            }\n            else\n            {\n                LG[x][y] = min(LG[x][y], cs);\n                LG[y][x] = min(LG[y][x], cs);\n            }\n        }\n        scanf(\"%d\", &rtl);\n        for(int i = 1; i <= rtl; i++)\n            scanf(\"%d\", &rt[i]);\n\n        floyd();\n        for(int i = 1; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                dp[i][j] = INF;\n\n        dp[1][rt[1]] = 0;\n        for(int i = 2; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                for(int k = 1; k <= n; k++)\n                {\n                    if(j != k)\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[k][rt[i - 1]] + SG[k][j] + LG[j][rt[i]]);\n                    else\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[rt[i-1]][rt[i]]);\n                }\n\n        long long ans = *min_element(dp[rtl] + 1, dp[rtl] + n + 1);\n        if(ans == INF);\n        else printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINT_MAX)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<LL>> warshall_floyd(std::vector<std::vector<LL>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INT_MAX and matrix.at(m).at(e) != INT_MAX) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        vector<vector<LL>> matrix1(N, vector<LL>(N, INT_MAX)), matrix2(N, vector<LL>(N, INT_MAX));\n        FOR(i, 0, M) {\n            int X, Y, T;\n            char S;\n            cin >> X >> Y >> T >> S;\n            X--; Y--;\n            if (S == 'L') {\n                matrix1[X][Y] = T;\n                matrix1[Y][X] = T;\n            }\n            else if (S == 'S') {\n                matrix2[X][Y] = T;\n                matrix2[Y][X] = T;\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> route(R);\n        FOR(i, 0, R) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        matrix1 = warshall_floyd(matrix1);\n        matrix2 = warshall_floyd(matrix2);\n\n        vector<vector<LL>> dp(R, vector<LL>(N, INF));\n        dp[0][0] = 0;\n\n        FOR(i, 0, R - 1) {\n            int now = route[i];\n            int next = route[i + 1];\n\n            FOR(j, 0, N) {\n                FOR(k, 0, N) {\n                    // 船がjにあるとき、町nowから町jに陸路、町jから町kに海路、町kから町nextに陸路でいく\n                    LL dist = dp[i][j] + matrix1[now][j] + matrix2[j][k] + matrix1[k][next];\n                    dp[i + 1][k] = min(dp[i + 1][k], dist);\n                }\n            }\n        }\n\n        LL ans = INF;\n        FOR(i, 0, N) {\n            ans = min(ans, dp[R - 1][i]);\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef _WIN32\n#define scanfll(x) scanf(\"%I64d\", x)\n#define printfll(x) printf(\"%I64d\", x)\n#else\n#define scanfll(x) scanf(\"%lld\", x)\n#define printfll(x) printf(\"%lld\", x)\n#endif\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using ld = long double; using vll = vector<ll>; using vvll = vector<vll>; using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>;\nvll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing P = pair<ll, ll>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; cout << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const unordered_map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvoid printbits(ll mask, ll n) { rep(i, n) { cout << !!(mask & (1ll << i)); } cout << endl; }\n#define ldout fixed << setprecision(40) \n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n\nint main(void) {\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, m; \n    while (cin >> n >> m && n && m) {\n        vvll dl(n, vll(n, INF)), ds(n, vll(n, INF));\n        rep(i, n) dl[i][i] = ds[i][i] = 0;\n\n        rep(i, m) {\n            ll x, y, t; char sl; cin >> x >> y >> t >> sl; x--; y--;\n            (sl == 'L' ? dl : ds)[x][y] = (sl == 'L' ? dl : ds)[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n) \n            chmin(dl[i][j], dl[i][k]+dl[k][j]), chmin(ds[i][j], ds[i][k]+ds[k][j]);\n        /*\n        cout << \"dl\" << endl;\n        cout << dl << endl;\n        cout << \"ds\" << endl;\n        cout << ds << endl;\n        */\n\n        ll r; cin >> r;\n        vll z(r); rep(i, r) { cin >> z[i]; z[i]--; } \n\n        // ??????j???????????????i?????????????????????????????????????????????\n        vvll dp(r+1, vll(n, INF));\n        dp[0][z[0]] = 0;\n        rep(i, r) { \n//            cout << i << \"#####\"<< endl;\n            rep(j, n) { // j?????????\n                if (dp[i][j] == INF) continue;\n//                cout << i << \" \" << j << \"#valid\" << endl;\n                rep(k, n) { // k???j?????????????????????, k????????????z[i]?????????\n                    if (ds[j][k] == INF) continue;\n                       ll tmp = (dp[i][j]/*????????§????????£????????????*/ + \n                            dl[i?z[i-1]:z[0]][j]/*j?????????????????????*/ +\n                            ds[j][k]/*j??????k????§????*/ + \n                            dl[k][z[i]]/*k??????????????´???????§????*/);\n                    chmin(dp[i+1][k], tmp);\n//                    cout << dp[i+1][k] << \" \" << tmp << \"#org\" << endl;\n#if 0\n                    chmin(dp[i+1][k], \n                            dp[i][j]/*????????§????????£????????????*/ + \n                            ds[i?z[i-1]:z[0]][j]/*j?????????????????????*/ +\n                            ds[j][k]/*j??????k????§????*/ + \n                            dl[k][z[i]]/*k??????????????´???????§????*/);\n                    cout << dp[i+1][k] << \"#aft\" << endl;\n                    cout << k << \" \"  <<\n                            dp[i][j]/*????????§????????£????????????*/ << \" \"  <<\n                            dl[i?z[i-1]:z[0]][j]/*j?????????????????????*/  << \" \" <<\n                            ds[j][k]/*j??????k????§????*/ << \" \"  <<\n                            dl[k][z[i]]/*k??????????????´???????§????*/ << endl;\n//                    cout << (i?z[i-1]:z[0]) << \" \" << j << \"prev pos\" << endl;\n                    if (dp[i+1][k] != INF) cout << i+1 << \" \" << k << \" \" << dp[i+1][k] << \"###OK\"<< endl;\n#endif\n\n                }\n                if (dl[i?z[i-1]:z[0]][z[i]] != INF)\n                    chmin(dp[i+1][j], \n                            dp[i][j]/*????????§????????£????????????*/ + \n                            dl[i?z[i-1]:z[0]][z[i]]/*????????´???????§????*/);\n            } \n            /*\n            rep(j, n) if (dp[i+1][j] != INF) \n                cout << i+1 << \" \" << j << \" : \" << dp[i+1][j] << endl;\n                */\n        }\n\n        ll ret = INF;\n        rep(j, n) {\n            chmin(ret, dp[r][j]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<27;\n\ntypedef vector<int> Array;\ntypedef vector<Array> Matrix;\n\nvoid shortestPath(const Matrix &g, Matrix &dist) {\n  int n = g.size();\n  dist = g;\n  REP(k, n) REP(i, n) REP(j, n)\n    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n}\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n) {\n    Matrix gl(n,Array(n,INF));\n    Matrix gs(n,Array(n,INF));\n    REP(i,n) {\n      gl[i][i] = 0;\n      gs[i][i] = 0;\n    }\n    REP(i,m) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      a--;b--;\n      char ch;\n      cin >> ch;\n      if (ch=='L') {\n        gl[a][b] = c;\n        gl[b][a] = c;\n      }else {\n        gs[a][b] = c;\n        gs[b][a] = c;\n      }\n    }\n    int t;\n    cin >> t;\n    int z[t];\n    REP(i,t) {\n      cin >> z[i];\n      z[i]--;\n    }\n    Matrix distl, dists;\n    shortestPath(gl, distl);\n    shortestPath(gs, dists);\n\n    int dp[t][n];\n    REP(i,t)REP(j,n)dp[i][j] = INF;\n    dp[0][z[0]] = 0;\n    int cnt = 0;\n    REP(i,t-1) {\n      REP(j, n) {\n        REP(k, n) {\n          int tmp;\n          if (j==k) tmp = distl[z[i]][z[i+1]];\n          else tmp = distl[z[i]][j] + dists[j][k] + distl[k][z[i+1]];\n          dp[i+1][k] = min(dp[i+1][k], dp[i][j] + tmp);\n        }\n      }\n    }\n    cout << *min_element(dp[t-1], dp[t-1]+n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<24;\n\nconst int MAX_N=210;\nconst int MAX_M=10010;\nconst int MAX_R=1010;\nint n,m,r;\nint x[MAX_M];\nint y[MAX_M];\nint t[MAX_M];\nchar sl[MAX_M];\nint z[MAX_R];\nint dp[MAX_R][MAX_N];\nint dl[MAX_N][MAX_N];\nint ds[MAX_N][MAX_N];\n/*\n  繧ｳ繧ｹ繝・dp[縺ｩ縺薙∪縺ｧ驕疲・縺励※縺・ｋ縺犠[闊ｹ縺ｮ菴咲ｽｮ]\n  dp[i][j]=min(dp[i-1][j]+dl[from][to], dp[i-1][k]+dl[from][k]+ds[k][l]+dl[l][to] for k in {0..n-1} for l in {0..n-1})\n */\nvoid solve(){\n  REP(i,n) fill_n(dl[i],n,INF);\n  REP(i,n) fill_n(ds[i],n,INF);\n  REP(i,n) dl[i][i]=ds[i][i]=0;\n  REP(i,m){\n    if(sl[i]=='L')\n      dl[x[i]][y[i]]=dl[y[i]][x[i]]=t[i];\n    else\n      ds[x[i]][y[i]]=ds[y[i]][x[i]]=t[i];\n  }\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tdl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n\tds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n      }\n    }\n  }\n  REP(i,r)REP(j,n)dp[i][j]=INF;\n\n  dp[0][z[0]]=0;\n  for(int i=1;i<r;i++){\n    REP(shipFrom,n){\n      REP(shipTo,n){\n        if(shipFrom==shipTo){\n          dp[i][shipTo]=min(dp[i][shipTo],dp[i-1][shipFrom]+dl[z[i-1]][z[i]]);\n        }else{\n          dp[i][shipTo]=min(dp[i][shipTo],dp[i-1][shipFrom]+dl[z[i-1]][shipFrom]+ds[shipFrom][shipTo]+dl[shipTo][z[i]]);\n        }\n      }\n    }\n  }\n  int result=INF;\n  REP(i,n)result=min(result,dp[r-1][i]);\n  cout<<result<<endl;\n}\n\nint main(){ _;\n  while(cin>>n>>m,(n|m)!=0){\n    REP(i,m){\n      cin>>x[i]>>y[i]>>t[i]>>sl[i];\n      x[i]--;y[i]--;\n    }\n    cin>>r;\n    REP(i,r){\n      cin>>z[i];\n      z[i]--;\n    }\n    solve();\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[201],INF);\n   fill(dS[0],dS[201],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=min(dL[s][t],v);  \n     dL[t][s]=min(dL[t][s],v);  \n     }else{\n     dS[s][t]=min(dS[s][t],v);  \n     dS[t][s]=min(dS[t][s],v); \n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){ \n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n        }\n       }\n      } \n\n   fill(dp[0],dp[201],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           if(j!=k) dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<vector<int> > > dp;\nstruct State{\n\tint pos;\n\tint hune;\n\tint r;\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tvector<vector<int> > g(N);\n\t\tvector<vector<int> > ti(N);\n\t\tvector<vector<char> > sl(N);\n\t\t\n\t\tint res = 0;\n\t\tint a, b, c;\n\t\tchar d;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t\tti[a].push_back(c);\n\t\t\tti[b].push_back(c);\n\t\t\tsl[a].push_back(d);\n\t\t\tsl[b].push_back(d);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> A(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> A[i];\n\t\t\tA[i]--;\n\t\t}\n\t\tdp.clear();\n\t\tdp.resize(N, vector < vector<int> >(N, vector<int>(R + 1, (int)1 << 60)));\n\t\tdp[A[0]][A[0]][1] = 0;\n\t\tqueue<State> qu;\n\t\tqu.push(State{ A[0], A[0],1 });\n\t\tState t;\n\t\twhile ((int)qu.size() > 0) {\n\t\t\tState st = qu.front(); qu.pop();\n\t\t\t//cerr << st.pos << \" \" << st.hune << \" \" << st.r << endl;\n\t\t\tif (st.r == R)continue;\n\t\t\tfor (int i = 0; i < g[st.pos].size(); i++) {\n\t\t\t\tif (st.pos == st.hune || sl[st.pos][i] == 'L') {\n\t\t\t\t\tt.pos = g[st.pos][i];\n\t\t\t\t\tif (sl[st.pos][i] == 'S') {\n\t\t\t\t\t\tt.hune = g[st.pos][i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tt.hune = st.hune;\n\t\t\t\t\t}\n\t\t\t\t\tt.r = st.r;\n\t\t\t\t\tif (A[st.r] == g[st.pos][i]) {\n\t\t\t\t\t\tt.r++;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[t.pos][t.hune][t.r] > dp[st.pos][st.hune][st.r] + ti[st.pos][i]) {\n\t\t\t\t\t\tdp[t.pos][t.hune][t.r] = dp[st.pos][st.hune][st.r] + ti[st.pos][i];\n\t\t\t\t\t\tqu.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = (int)1 << 60;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, dp[A[R - 1]][i][R]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    ll land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<201;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;ll t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>a[i];a[i]--;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    ll dp[1001][201];\n    for(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n        }\n      }\n    }\n    /*for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        cout<<dp[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;*/\n    ll ans=inf;\n    for(int i=0;i<201;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define inf 100000\n\nint N,M;\nint disL[200][200];//隣接行列の重みバージョン陸\nint disS[200][200];//海\nint r ;\nint z[1000];\nint disP[1000][100]={};\n\n/*町番号は0からN-1とする（入力は1からN）*/\n\n/*町Z(num)からZr（終点）への最短時間（船が町shipにある状況で）を返す\nz  宅配順列の何番目か0->(r-1)\nship 船のある町番号0->N-1\n*/\nint recur(int num,int ship){\n  int land,sea=inf,sm=ship,sp,i;\n\n  if(disP[num][ship]!=0)return disP[num][ship];\n  if(num>=r-1)return 0;\n  land=disL[z[num]][z[num+1]]+recur(num+1,ship);\n  \n  for(i=0;i<N;i++){\n    sp=disL[ z[num] ][ship] + disS[ship][i] + disL[i][ z[num+1] ] + recur(num+1,i);\n    if(sea>sp){\n      sea=sp;\n    }\n  }\n  disP[num][ship]=min(land,sea);\n  return disP[num][ship];\n}\n\n\nint main(){\n  int i,j,k,x,y,t;\n  char ch;\n  while(true){\n\n    for(i=0;i<1000;i++)\n      for(j=0;j<100;j++)\n\tdisP[i][j]=0;\n\n    /*入力処理*/\n    cin >>N>>M;\n    if(N==0 && M==0)break;\n    for(i=0;i<M;i++){\n      for(j=0;j<M;j++){\n\tif(i!=j){\n\t  disL[i][j]=inf;\n\t  disS[i][j]=inf;\n\t}\n\telse {\n\t  disL[i][i]=0;\n\t  disS[i][i]=0;\n\t}\n      }\n    }\n    \n\n    /*陸路海路それぞれの最小値をセット*/\n    for(i=0;i<M;i++){\n      cin >>x>>y>>t>>ch;\n      if(ch=='L'){\n\tdisL[x-1][y-1]=min(disL[x-1][y-1],t);\n\tdisL[y-1][x-1]=min(disL[y-1][x-1],t);\n      }\n      else if(ch=='S'){\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n      }\n    }\n\n    priority_queue<int> p_que;\n    /*陸、海それぞれで各町同士の最短経路を出す*/  \n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tfor(k=0;k<N;k++){\n\t  disL[j][k]=min(disL[j][k],disL[j][i]+disL[i][k]);\n\t  disS[j][k]=min(disS[j][k],disS[j][i]+disS[i][k]);\n\t}\n      }\n    }\n    cin >> r;\n    for(i=0;i<r;i++){\n      cin >> j;\n      z[i]=j-1;//町番号は0からN-1にする\n    }\n    cout << recur(0,z[0]) <<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 201\n#define INF 1e6\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    int G1[MAX][MAX], G2[MAX][MAX];\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX], dp[MAX][MAX];\n      for(int i = 0 ; i < MAX ; i++){\n        for(int j = 0 ; j < MAX ; j++){\n          dp[i][j] = INF;\n        }\n      }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        dp[r][now] = min(dp[r][now], dp[r-1][now] + G1[now][next]);\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 222;\nconst int MAXR = 1111;\nconst ll INF = 1ll<<55;\nint N, M, R;\n// d1: land d2: sea\nll d1[MAXN][MAXN], d2[MAXN][MAXN];\nint z[MAXR];\n\nll dp[MAXR][MAXN];\n\nll dfs(int turn, int ship) {\n\tll& ret = dp[turn][ship];\n\tif (ret >= 0) return ret;\n\tif (turn == R-1) return ret = 0;\n\t// ??????\n\tret = d1[z[turn]][z[turn+1]] + dfs(turn+1, ship);\n\t// ???\n\tfor (int v = 0; v < N; v++) {\n\t\tll tmp = d1[z[turn]][ship] + d2[ship][v] + d1[v][z[turn+1]];\n\t\tif (tmp >= INF) continue;\n\t\ttmp += dfs(turn+1, v);\n\t\tret = min(ret, tmp);\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N >> M) {\n    \tif (N==0 && M==0) break;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tfor (int j = 0; j < N; j++) {\n    \t\t\td1[i][j] = d2[i][j] = INF;\n    \t\t}\n    \t\td1[i][i] = d2[i][i] = 0;\n    \t}\n    \tfor (int i = 0; i < M; i++) {\n    \t\tint x, y, t;\n    \t\tchar sl;\n    \t\tcin >> x >> y >> t >> sl;\n    \t\tx--; y--;\n    \t\tif (sl == 'L') {\n    \t\t\td1[x][y] = min<ll>(d1[x][y], t);\n    \t\t\td1[y][x] = d1[x][y];\n    \t\t} else {\n    \t\t\td2[x][y] = min<ll>(d2[x][y], t);\n    \t\t\td2[y][x] = d2[x][y];\n    \t\t}\n    \t}\n    \tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n    \t\td1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n    \t\td2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n    \t}\n    \tcin >> R;\n    \tfor (int i = 0; i < R; i++) {\n    \t\tcin >> z[i];\n    \t\tz[i]--;\n    \t}\n    \tmemset(dp, -1, sizeof(dp));\n    \tcout << dfs(0, z[0]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<utility>\n#include<vector>\n#include<queue>\n#define MAX_N 200\nusing namespace std;\ntypedef pair<int,int>p;\ntypedef struct node\n{\n\tint p,n,b,c;\n\tbool operator <(const node &a)const{ return c>a.c;};\n}node;\nvector<p> Sea[MAX_N],Land[MAX_N];\nint N,M,R,des[1000];\nint d[1005][205][205];\npriority_queue<node>Q;\n\nvoid f(node tmp,vector<p> edge,bool Boat)\n{\n\tnode ins;\n\tins.n=tmp.p==des[tmp.n]?tmp.n+1:tmp.n;\n\tfor(int i=0;i<edge.size();i++)\n\t{\n\t\tins.p=edge[i].first;\n\t\tins.b=Boat?edge[i].first:tmp.b;\n\t\tif(d[ins.n][ins.p][ins.b]>tmp.c+edge[i].second)\n\t\t{\n\t\t\tins.c=d[ins.n][ins.p][ins.b]=tmp.c+edge[i].second;\n\t\t\tQ.push(ins);\n\t\t}\n\t}\n}\n\nint dij()\n{\n\tfor(;!Q.empty();Q.pop());\n\tmemset(d,0x77,sizeof(d));\n\td[0][des[0]][des[0]]=0;\n\tnode tmp={des[0],1,des[0],0};\n\tQ.push(tmp);\n\tfor(;!Q.empty();)\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(d[tmp.n][tmp.p][tmp.b]<tmp.c)continue;\n\t\tif(tmp.n==R-1&&tmp.p==des[tmp.n])return tmp.c;\n\t\tf(tmp,Land[tmp.p],0);\n\t\tif(tmp.b==tmp.p)f(tmp,Sea[tmp.p],1);\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint x,y,s;\n\t\t\tchar t;\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&s,&t);\n\t\t\tif(t=='L')\n\t\t\t{\n\t\t\t\tLand[x].push_back(make_pair(y,s));\n\t\t\t\tLand[y].push_back(make_pair(x,s));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSea[x].push_back(make_pair(y,s));\n\t\t\t\tSea[y].push_back(make_pair(x,s));\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(int i=0;i<R;i++)scanf(\"%d\",&des[i]);\n\t\tprintf(\"%d\\n\",dij());\n\t\tfor(int i=0;i<200;i++){Land[i].clear();Sea[i].clear();}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int INF = 1<<30;\n\nint cost[3][210][210];\n// bool used[210][210][1010];\n\nstruct t_node {\n\tint pos;\n\tint ship;\n\tint time;\n\tint delindex;\n\tt_node(int p, int s, int t, int d) {\n\t\tpos = p;\n\t\tship = s;\n\t\ttime = t;\n\t\tdelindex = d;\n\t}\n};\nbool operator<( const t_node& lhs, const t_node &rhs ) {\n\treturn lhs.time > rhs.time;\n}\n\nint main() {\n\tint n, m;\n\twhile( cin >> n >> m, n||m ) {\n//\t\tmemset( used, 0, sizeof(used) );\n\t\trep(i,2) rep(j,201) rep(k,201) cost[i][j][k] = INF;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tint s = (sl=='L' ? 0 : 1);\n\t\t\tcost[s][x][y] = cost[s][y][x] = t;\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> deliver(r);\n\t\trep(i, r) {\n\t\t\tcin >> deliver[i];\n\t\t}\n\t\tpriority_queue<t_node> que;\n\t\tque.push( t_node(1, 1, 0, 0) );\n\t\twhile( !que.empty() ) {\n\t\t\tt_node tn = que.top();\n\t\t\tque.pop();\n//\t\t\tif( used[tn.pos][tn.ship][tn.delindex] ) {\n//\t\t\t\tcontinue;\n//\t\t\t}\n//\t\t\tused[tn.pos][tn.ship][tn.delindex] = true;\n\t\t\tif( deliver[tn.delindex] == tn.pos ) {\n\t\t\t\ttn.delindex++;\n\t\t\t\tif( tn.delindex == r ) {\n\t\t\t\t\tcout << tn.time << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, (tn.pos==tn.ship ? 2 : 1)) {\n\t\t\t\trep(i, n+1) {\n\t\t\t\t\tif( cost[j][tn.pos][i] < INF ) {\n\t\t\t\t\t\tque.push( t_node( i, (j==1 ? i : tn.ship), tn.time+cost[j][tn.pos][i], tn.delindex ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef int Weight;\n\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nconst int INF = 10000;\nint N, M, R;\nint dS[MAX_N][MAX_N];  // 海路\nint d[MAX_N][MAX_N];  // 全点対最短距離\nint z[MAX_R];\n\nvoid warshall_floyd(int d[MAX_N][MAX_N])\n{\n    for (int k = 0; k < N; k++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main()\n{\n    while (cin >> N >> M, N || M) {\n        // Initial\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++) {\n                if (i == j)\n                    d[i][j] = dS[i][j] = 0;\n                else\n                    d[i][j] = dS[i][j] = INF;\n            }\n\n        // Input\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char c;\n\n            cin >> x >> y >> t >> c;\n            x--, y--;\n\n            if (d[x][y] > t)\n                d[x][y] = d[y][x] = t;\n            if (c == 'S') // 海路\n                dS[x][y] = dS[y][x] = t;\n        }\n\n        cin >> R;\n        for (int i = 0; i < R; i++) {\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // Warshall-Floyd\n        warshall_floyd(d);\n        warshall_floyd(dS);\n\n        int ans = dS[z[0]][z[1]];\n        for (int i = 1; i < R - 1; i++)\n            ans += d[z[i]][z[i + 1]];\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n#include <cassert>\n\n\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n\n#define all(x) begin(x),end(x)\n#define dump(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define debug(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 10;\n\ntemplate<class T>\nbool chmax(T &a, const T &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\nbool chmin(T &a, const T &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n// edit\n\nbool solve() {\n    int N, M;\n    cin >> N >> M;\n    if (N == 0) return false;\n\n    vvll ldist(N, vll(N, LINF)), sdist(N, vll(N, LINF));\n    REP(i, N) {\n        ldist[i][i] = sdist[i][i] = 0;\n    }\n\n    REP(i, M) {\n        int x, y;\n        ll t;\n        char c;\n        cin >> x >> y >> t >> c;\n        x--, y--;\n        if (c == 'L') {\n            chmin(ldist[x][y], t);\n            chmin(ldist[y][x], t);\n        } else if (c == 'S') {\n            chmin(sdist[x][y], t);\n            chmin(sdist[y][x], t);\n        }\n    }\n\n    REP(k, N) {\n        REP(i, N) {\n            REP(j, N) {\n                chmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n                chmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n            }\n        }\n    }\n\n\n    int R;\n    cin >> R;\n    vector<int> z(R);\n    REP(i, R) {\n        cin >> z[i];\n        z[i]--;\n    }\n\n\n    vvll dp(R, vll(N, LINF)); // dp[i][j] := [0, i]まで配達済み、船がjにある、最短時間\n    dp[0][z[0]] = 0;\n    REP(i, R - 1) {\n        REP(j, N) {\n            chmin(dp[i + 1][j], dp[i][j] + ldist[z[i]][z[i + 1]]);\n\n            REP(k, N) {\n                chmin(dp[i + 1][j], dp[i][k] + ldist[z[i]][k] + sdist[k][j] + ldist[j][z[i + 1]]);\n            }\n        }\n    }\n\n    ll ans = LINF;\n\n    REP(i, N) {\n        chmin(ans, dp[R - 1][i]);\n    }\n\n    cout << ans << endl;\n\n    return true;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n//    std::ifstream in(\"input.txt\");\n//    std::cin.rdbuf(in.rdbuf());\n\n    while (solve());\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <queue>\n#define oo 0x3f3f3f3f\nusing namespace std;\nstruct ad\n{\n    int to, next, v, water;\n}edge[22000];\nstruct node\n{\n    int people_pos, ship_pos, cnt;\n};\nint head[330], edge_num, vis[300][1100], k, End[1100], dist[300][1100], n;\nvoid Add(int x, int y, int z, int op)\n{\n    edge[edge_num].to = y;\n    edge[edge_num].v = z;\n    edge[edge_num].next = head[x];\n    edge[edge_num].water = op;\n    head[x] = edge_num++;\n}\nint spfa()\n{\n    queue<node>Q;\n    node now, next;\n    now.people_pos = End[1];\n    now.ship_pos = End[1];\n    now.cnt = 1;\n    vis[End[1]][1] = 1;\n    Q.push(now);\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=k; j++)\n            dist[i][j] = oo;\n    dist[End[1]][1] = 0;\n    while(!Q.empty())\n    {\n        now = Q.front();\n        Q.pop();\n\n        for(int i=head[now.people_pos]; ~i; i=edge[i].next)\n        {\n            int v = edge[i].to;\n            int new_cnt = now.cnt;\n            if(v == End[now.cnt+1])\n                new_cnt++;\n            if(!edge[i].water)\n            {\n                if(!vis[v][new_cnt] && dist[v][new_cnt]>dist[now.people_pos][now.cnt]+edge[i].v)\n                {\n                    dist[v][new_cnt] = dist[now.people_pos][now.cnt]+edge[i].v;\n                    vis[v][new_cnt] = 1;\n                    next.people_pos = v;\n                    next.ship_pos = now.ship_pos;\n                    next.cnt = new_cnt;\n                    Q.push(next);\n                }\n            }\n            else if(now.ship_pos == now.people_pos)\n            {\n                if(!vis[v][new_cnt] && dist[v][new_cnt]>dist[now.people_pos][now.cnt]+edge[i].v)\n                {\n                    dist[v][new_cnt] = dist[now.people_pos][now.cnt]+edge[i].v;\n                    vis[v][new_cnt] = 1;\n                    next.people_pos = v;\n                    next.ship_pos = v;\n                    next.cnt = new_cnt;\n                    Q.push(next);\n                }\n            }\n        }\n        vis[now.people_pos][now.cnt] = 0;\n    }\n\n    return dist[End[k]][k];\n}\nint main()\n{\n    int m;\n    while(scanf(\"%d %d\", &n, &m), n+m)\n    {\n        memset(head, -1, sizeof(head));\n        edge_num = 0;\n        int u, v, w;\n        char way[5];\n        for(int i=1; i<=m; i++)\n        {\n            scanf(\"%d %d %d %s\", &u, &v, &w, way);\n            Add(u, v, w, way[0]=='S');\n            Add(v, u, w, way[0]=='S');\n        }\n\n        memset(vis, 0, sizeof(vis));\n\n        scanf(\"%d\", &k);\n\n        for(int i=1; i<=k; i++)\n            scanf(\"%d\", &End[i]);\n\n        printf(\"%d\\n\", spfa());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\twhile (cin >> n >> m&&(n&&m)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tREP(i, 201)REP(j, r)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tint ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint d1[205][205],d2[205][205];\nint d[205][205];\nint v[1005];\nint M=1061109567;\nint main()\n{\n\tint n,m,p;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(n&&m){\n\tmemset(d1,0x3f,sizeof d1);\n\tmemset(d2,0x3f,sizeof d2);\n\tmemset(d,0x3f,sizeof d);\n\tfor(int i=1;i<=n;i++)\n\t\td1[i][i]=d2[i][i]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b,d;\n\t\tchar c;\n\t\tscanf(\"%d%d%d %c\",&a,&b,&d,&c);\n\t\tif(c=='L'){\n\t\t\td1[a][b]=min(d1[a][b],d);\n\t\t\td1[b][a]=min(d1[b][a],d);\n\t\t}\n\t\telse{\n\t\t\td2[a][b]=min(d2[a][b],d);\n\t\t\td2[b][a]=min(d2[b][a],d);\n\t\t}\n\t}\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(d1[i][k]!=M&&d1[k][j]!=M&&d1[i][k]+d1[k][j]<d1[i][j])\n\t\t\t\t\td1[i][j]=d1[i][k]+d1[k][j];\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(d2[i][k]!=M&&d2[k][j]!=M&&d2[i][k]+d2[k][j]<d2[i][j])\n\t\t\t\t\td2[i][j]=d2[i][k]+d2[k][j];\n\tscanf(\"%d\",&p);\n\tfor(int i=1;i<=p;i++)\n\t\tscanf(\"%d\",&v[i]);\n\tv[0]=1;\n\td[0][1]=0;\n\tfor(int i=1;i<=p;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t//printf(\"%d %d %d %d %d\\n\",d[i-1][j],d1[v[i-1]][j],d2[j][k],d1[k][v[i]],d[i][k]);\n\t\t\t\tif(d[i-1][j]!=M&&d1[v[i-1]][j]!=M&&d2[j][k]!=M&&d1[k][v[i]]!=M&&d[i-1][j]+d1[v[i-1]][j]+d2[j][k]+d1[k][v[i]]<d[i][k])\n\t\t\t\t\td[i][k]=d[i-1][j]+d1[v[i-1]][j]+d2[j][k]+d1[k][v[i]];\n\t\t\t}\n\t}\n\tint ans=M;\n\tfor(int j=1;j<=n;j++)\n\t\tans=min(d[p][j],ans);\n\tprintf(\"%d\\n\",ans);\n\tscanf(\"%d%d\",&n,&m);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int INF = 1 << 29;\n\nint main() {\n\tint n, m;\n\t\n\twhile ( cin >> n >> m, n | m ) {\n\t\tVVI L( n, VI( n, INF ) ),\n\t\t\tS( n, VI( n, INF ) );\n\t\t\n\t\tfor ( int i = 0; i < m; ++i ) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t\n\t\t\tswitch ( s ) {\n\t\t\tcase 'L':\n\t\t\t\tL[x - 1][y - 1] = L[y - 1][x - 1] = min( t, L[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tS[x - 1][y - 1] = S[y - 1][x - 1] = min( t, S[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\t\n\t\tVI Z( r, 0 );\n\t\t\n\t\tfor ( int i = 0; i < r; ++i ) {\n\t\t\tcin >> Z[i];\n\t\t\t--Z[i];\n\t\t}\n\t\t// end of input\n\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tL[i][i] = S[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\t\tL[i][j] = min( L[i][j], L[i][k] + L[k][j] );\n\t\t\t\t\tS[i][j] = min( S[i][j], S[i][k] + S[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVVI d( r, VI( n, INF ) );\n\t\td[0][Z[0]] = 0;\n\t\tfor ( int i = 0; i + 1 < r; ++i ) {\n\t\t\tint from = Z[i], to = Z[i + 1];\n\t\t\td[i + 1][to] = min( d[i + 1][to], d[i][from] + S[from][to] );\n\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\td[i + 1][to] = min( d[i + 1][to], d[i][j] + L[from][j] + S[j][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][j] + L[from][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][from] + S[from][j] + L[j][to] );\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tans = min( ans, d[r - 1][i] );\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint land[200][200];\ntypedef pair<int,int>P;\nvector<P>sea[200];\n\nint R,z[1000];\n\nconst int INF = 0x0f0f0f0f;\n\nint memo[200][1000];\nint Solve(int boat, int index)\n{\n\tif(index >= R)\n\t\treturn 0;\n\tint &ref = memo[boat][index];\n\tif(ref >= 0)\n\t\treturn ref;\n\tint from = z[index-1];\n\tint to = z[index];\n\n\tref = land[from][to] + Solve(boat,index+1);\n\n\tfor(int i=0;i<sea[boat].size();++i)\n\t{\n\t\tP p=sea[boat][i];\n\t\tref = min(ref, land[from][boat]+p.second+land[p.first][to] + Solve(p.first,index+1));\n\t}\n\treturn ref;\n}\n\nint main()\n{\n\tint n,m,i,j,k;\n\tint x,y,t;\n\tchar c;\n\tint seaTemp[200][200];\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tfor(i=0;i<n;++i)\n\t\t\tsea[i].clear();\n\t\tmemset(land,INF,sizeof(land));\n\t\tmemset(seaTemp,INF,sizeof(seaTemp));\n\t\tfor(i=0;i<n;++i)\n\t\t\tland[i][i]=0;\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&t,&c);\n\t\t\t--x,--y;\n\t\t\tif(c=='L')\n\t\t\t\tland[y][x]=land[x][y] = min(land[y][x],t);\n\t\t\telse\n\t\t\t\tseaTemp[y][x]=seaTemp[x][y]=min(seaTemp[y][x],t);\n\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=0; i<R; ++i)\n\t\t{\n\t\t\tscanf(\"%d\",z+i);\n\t\t\t--z[i];\n\t\t}\n\n\t\tfor(k=0;k<n;++k)\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tfor(j=0;j<n;++j)\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\n\t\tfor(i=0;i<n;++i)\n\t\t\tfor(j=i+1;j<n;++j)\n\t\t\t{\n\t\t\t\tif(seaTemp[i][j]==INF)continue;\n\t\t\t\tsea[i].push_back(P(j,seaTemp[i][j]));\n\t\t\t\tsea[j].push_back(P(i,seaTemp[i][j]));\n\t\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tprintf(\"%d\\n\",Solve(z[0],1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 500000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,M,R,z[1010],dL[210][210],dS[210][210],dp[1010][210];\n\nint main(){\n\twhile(cin>>N>>M && N){\n\t\t\n\t\trep(i,N)rep(j,N) dL[i][j] = dS[i][j] = (i==j ? 0:INF);\n\t\t\n\t\trep(i,M){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--; y--;\n\t\t\tif(sl=='L') dL[x][y] = dL[y][x] = min(dL[x][y], t);\n\t\t\telse dS[x][y] = dS[y][x] = min(dS[x][y], t);\n\t\t}\n\t\t\n\t\tcin>>R;\n\t\trep(i,R)cin>>z[i], z[i]--;\n\t\t\n\t\trep(k,N)rep(i,N)rep(j,N){\n\t\t\tdL[i][j] = min(dL[i][j], dL[i][k]+dL[k][j]);\n\t\t\tdS[i][j] = min(dS[i][j], dS[i][k]+dS[k][j]);\n\t\t}\n\t\t\n\t\trep(i,R)rep(j,N) dp[i][j]=INF;\n\t\tdp[0][z[0]]=0;\n\t\t\n\t\trep2(i,1,R)rep(j,N)rep(k,N){\n\t\t\tif(j==k) dp[i][k] = min(dp[i][k], dp[i-1][j] + dL[z[i-1]][z[i]]);\n\t\t\telse dp[i][k] = min(dp[i][k], dp[i-1][j] + dL[z[i-1]][j] + dS[j][k] + dL[k][z[i]]);\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\trep(i,N) ans=min(ans,dp[R-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define size_of(a) (int)(a).size()\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nint N, M, R, z[1010];\n\nlint cstL[222][222], cstS[222][222];\nlint dp[1010][222];\n\nvoid minUpdate(lint& a, lint b) {\n\ta = min(a, b);\n}\n\nvoid solve() {\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tminUpdate(cstL[i][j], cstL[i][k] + cstL[k][j]);\n\t\tminUpdate(cstS[i][j], cstS[i][k] + cstS[k][j]);\n\t}\n\t\n\tfor_(i,0,1010) for_(j,0,222) dp[i][j] = 1LL << 60;\n\tdp[0][z[0]] = 0;\n\t\n\tfor_(i,0,R-1) for_(j,0,N) {\n\t\tfor_(v,0,N) {\n\t\t\tlint c1 = cstL[z[i]][j];\n\t\t\tlint c2 = cstS[j][v];\n\t\t\tlint c3 = cstL[v][z[i + 1]];\n\t\t\t\n\t\t\tlint cc = c1 + c2 + c3;\n\t\t\tif (cc < 1LL << 60) {\n\t\t\t\tminUpdate(dp[i+1][v], dp[i][j] + cc);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlint ans = 1LL << 60;\n\tfor_(i,0,N) minUpdate(ans, dp[R-1][i]);\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\t\t\n\t\tfor_(i,0,N) for_(j,0,N) cstL[i][j] = cstS[i][j] = 1LL << 60;\n\t\tfor_(i,0,N) cstS[i][i] = cstL[i][i] = 0;\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t--x; --y;\n\t\t\tif (s == 'L') cstL[x][y] = cstL[y][x] = t;\n\t\t\telse cstS[x][y] = cstS[y][x] = t;\n\t\t}\n\t\t\n\t\tcin >> R;\n\t\t\n\t\tfor_(i,0,R) {\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m,r;\nint dl[222][222];\nint ds[222][222];\nint dp[1111][222];\nint rs[1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,222)rep(j,222){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n      dist[i][j]=INF;\n    }\n    rep(i,m){\n      int x,y,t; string sl;\n      cin>>x>>y>>t>>sl; x--; y--;\n      if(sl==\"L\"){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    cin>>r;\n    rep(i,r){\n      cin>>rs[i];\n      rs[i]--;\n    }\n    dp[0][rs[0]]=0;\n    rep(i,r-1){\n      int crt=rs[i],nxt=rs[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        if(crt==j){\n          rep(k,n)minch(dp[i+1][k],dp[i][j]+dl[crt][j]+ds[j][k]+dl[k][nxt]);\n        }\n        rep(k,n)minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n      }\n    }\n    int res=INF;\n    rep(j,n)minch(res,dp[r-1][j]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct E{\n  int d,t;\n  bool s;\n};\n\nstruct S{\n  int t,x,p,b;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    vector<E> e[201];\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      E a={y,t,sl=='S'};\n      e[x].push_back(a);\n      E b={x,t,sl=='S'};\n      e[y].push_back(b);\n    }\n    int r;\n    cin>>r;\n    int z[1000];\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n    }\n    priority_queue<S> que;\n    S is={0,0,z[0],z[0]};\n    que.push(is);\n    static bool p[1000][201][201]={{{}}};\n    fill(p[0][0],p[1000][0],false);\n    for(;;){\n      S c=que.top();\n      if(c.x==r-1)break;\n      que.pop();\n      if(p[c.x][c.p][c.b]++)continue;\n      for(int i=0;i<e[c.p].size();i++){\n\tE ce=e[c.p][i];\n\tif(!ce.s||c.b==c.p){\n\t  S n={c.t+ce.t,c.x+(ce.d==z[c.x+1]),ce.d,ce.s?ce.d:c.b};\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint a[200][200],b[200][200],c[1000],d[1000][200],n,m,l;\nint fn(int p,int q){\n  int i;\n  if(p+1==l)\n    return 0;\n  if(d[p][q])\n    return d[p][q];\n  int mn=a[c[p]][c[p+1]]+fn(p+1,q);\n  for(i=0;i<n;++i){\n    if(i!=q&&b[q][i]!=(1<<29))\n      mn=min(mn,a[c[p]][q]+b[q][i]+a[i][c[p+1]]+fn(p+1,i));\n  }\n  return d[p][q]=mn;\n}\nint main(){\n  int i,j,k;\n  while(scanf(\"%d%d\",&n,&m),n||m){\n    fill(a[0],a[0]+200*200,1<<29);\n    fill(b[0],b[0]+200*200,1<<29);\n    for(i=0;i<n;++i)\n      a[i][i]=b[i][i]=0;\n    for(i=0;i<m;++i){\n      int p,q,r;\n      char s;\n      scanf(\"%d%d%d %c\",&p,&q,&r,&s);\n      --p;\n      --q;\n      if(s=='L'){\n\tif(a[p][q]>r)\n\t  a[p][q]=a[q][p]=r;\n      }else{\n\tif(b[p][q]>r)\n\t  b[p][q]=b[q][p]=r;\n      }\n    }\n    for(k=0;k<n;++k){\n      for(i=0;i<n;++i){\n\tfor(j=0;j<n;++j){\n\t  a[i][j]=min(a[i][j],a[i][k]+a[k][j]);\n\t  b[i][j]=min(b[i][j],b[i][k]+b[k][j]);\n\t}\n      }\n    }\n    scanf(\"%d\",&l);\n    for(i=0;i<l;++i){\n      scanf(\"%d\",c+i);\n      --c[i];\n    }\n    memset(d,0,sizeof(d));\n    printf(\"%d\\n\",fn(0,c[0]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF (1e9)\n#define M 1005\n#define N 205\nusing namespace std;\ntypedef long long ll;\n\nll n,m,r,z[M],sld[2][N][N];\n\nvoid init(){\n  rep(i,2)\n    rep(j,n)\n      rep(k,n)\n        sld[i][j][k]=INF;  \n}\n\nvoid add_edge(ll sl,ll x,ll y,ll t){\n  sld[sl][x][y]=sld[sl][y][x]=min(sld[sl][x][y],t);\n}\n\nvoid warshall_floyd(){\n  rep(sl,2) rep(k,n) rep(i,n) rep(j,n)\n    sld[sl][i][j]=min(sld[sl][i][j],sld[sl][i][k]+sld[sl][k][j]);\n  rep(sl,2)\n    rep(i,n)sld[sl][i][i]=0;\n}\n\nll dp[M][N];\n\nvoid solve(){\n  rep(i,r)\n    rep(j,n)dp[i][j]=INF;\n  dp[0][0]=0;\n  \n  rep(i,r-1)\n    rep(j,n){\n      if(dp[i][j]==INF)continue;\n      ll cost=dp[i][j]+sld[0][z[i]][z[i+1]];\n      dp[i+1][j]=min(dp[i+1][j],cost);\n      rep(k,n){\n\tll cost2=dp[i][j]+sld[0][z[i]][j];\n\tcost2+=sld[1][j][k]+sld[0][k][z[i+1]];\n\tdp[i+1][k]=min(dp[i+1][k],cost2);\n      }\n    }\n  ll ans=INF;\n  rep(i,n)ans=min(ans,dp[r-1][i]);\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    ll x,y,t;\n    char sl;\n    \n    init();\n    \n    rep(i,m){\n      cin>>x>>y>>t>>sl;\n      x--,y--;\n      if(sl=='L')add_edge(0,x,y,t);\n      else add_edge(1,x,y,t);\n    }\n    \n    warshall_floyd();\n \n    cin>>r;\n    rep(i,r)cin>>z[i],z[i]--;\n    \n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct edge{\n    int to,cost;\n    bool S;\n    edge(int a,int b,bool c):to(a),cost(b),S(c){}\n};\n\nstruct data{\n    int pos,cost,ship,t;\n    data(int a,int b,int c,int d):pos(a),cost(b),ship(c),t(d){}\n    bool operator<(const data &d)const{\n        return cost>d.cost;\n    }\n};\n\nint N,M,T;\nvector<edge>G[100];\nvector<int>task;\nint dist[100][100][1001];\nconst int INF=1001001001;\nvoid solve(){\n    fill_n(**dist,100*100*1001,INF);\n    priority_queue<data>Q;\n    Q.push(data(task[0],0,task[0],0));\n    dist[task[0]][task[0]][0]=0;\n\n    while(Q.size()){\n        data d=Q.top();Q.pop();\n        if(d.t==T){\n            cout<<d.cost<<endl;\n            return;\n        }\n\n        if(dist[d.pos][d.ship][d.t]<d.cost)continue;\n\n        if(task[d.t]==d.pos){\n            if(dist[d.pos][d.ship][d.t+1]<=d.cost)continue;\n            dist[d.pos][d.ship][d.t+1]=d.cost;\n            Q.push(data(d.pos,d.cost,d.ship,d.t+1));\n            continue;\n        }\n\n        for(int i=0;i<G[d.pos].size();i++){\n            edge &e=G[d.pos][i];\n            if(e.S){\n                if(d.pos!=d.ship)continue;\n                if(dist[e.to][e.to][d.t]<=d.cost+e.cost)continue;\n                dist[e.to][e.to][d.t]=d.cost+e.cost;\n                Q.push(data(e.to,d.cost+e.cost,e.to,d.t));\n            }\n            else{\n                if(dist[e.to][d.ship][d.t]<=d.cost+e.cost)continue;\n                dist[e.to][d.ship][d.t]=d.cost+e.cost;\n                Q.push(data(e.to,d.cost+e.cost,d.ship,d.t));\n            }\n        }\n    }\n}\n\nint main(){\n\n    while(cin>>N>>M,N||M){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].push_back(edge(b,c,(d=='S')));\n            G[b].push_back(edge(a,c,(d=='S')));\n        }\n        cin>>T;\n        task.resize(T);\n        for(int i=0;i<T;i++)cin>>task[i],task[i]--;\n\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef long long ll;\n\nconst int INF=500000000;\nconst int MAX_V = 210;\nconst int MAX_R = 1010;\nint n,m,r;\nint land[MAX_V][MAX_V];\nint sea[MAX_V][MAX_V];\nint citys[MAX_R];\nvoid calcLandMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n}\nvoid calcSeaMinDist(){\n    for(int i = 0; i < n; i++)\n        for(int j = 0; j < n; j++)\n            for(int k = 0; k < n; k++)\n                sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n}\nint dp[MAX_R][MAX_V];\n// WzæªidxÌÔÚÌÆ±ëÅA{[gªboatÌm[hÉ éÆ«ÌÅ¬zBÔ\nint rec(int idx,int boat){\n    if(idx==r)\n        return 0;\n    if(dp[idx][boat]!=INF)\n        return dp[idx][boat];\n    int minTime=INF;\n    // ¤ÌÝðgÁÄB·éê\n    minTime=min(minTime,rec(idx+1,boat)+land[citys[idx-1]][citys[idx]]);\n    // CàgÁÄB·éê\n    // »ÝÌboatÌÊu©çBÅ«é`¬·×ÄÉÂ¢Ä·\n    for(int i = 0; i < n; i++){\n        minTime=min(minTime,rec(idx+1,i)+land[citys[idx-1]][boat]\n        + sea[boat][i] + land[i][citys[idx]]);\n    }\n    return dp[idx][boat]=minTime;\n}\n\nint main(){\n    while(cin>>n>>m&&!(n==0&&m==0)){\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)\n                if(i==j)\n                    land[i][j]=sea[i][j]=0;\n                else\n                    land[i][j]=sea[i][j]=INF;\n        for(int i = 0; i < m; i++){\n            int from,to,cost;\n            char kind;\n            cin>>from>>to>>cost>>kind;\n            from--;to--;\n            if(kind=='L'){\n                land[from][to]=min(land[from][to],cost);\n                land[to][from]=min(land[to][from],cost);\n            }\n            else{\n                sea[from][to]=min(sea[from][to],cost);\n                sea[to][from]=min(sea[to][from],cost);\n            }\n        }\n        cin>>r;\n        for(int i = 0; i < r; i++){\n            cin>>citys[i];\n            citys[i]--;\n        }\n        calcLandMinDist();\n        calcSeaMinDist();\n        // dpÅÅZ£ðßé\n        for(int i = 0; i < r; i++)\n            for(int j = 0; j < n; j++)dp[i][j]=INF;\n        dp[0][citys[0]]=0;\n        // Wzæ\n        for(int i = 1; i < r; i++){\n            // ¡Ì{[gÌê\n            for(int j = 0; j < n; j++){\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+land[citys[i-1]][citys[i]]);\n                // Ì{[gÌê\n                for(int k = 0; k < n; k++){\n                    dp[i][k]=min(dp[i][k],dp[i-1][j]+land[citys[i-1]][j]\n                    +sea[j][k]+land[k][citys[i]]);\n                }\n            }\n        }\n        //int res=rec(1,citys[0]);\n        int res=INF;\n        for(int i = 0; i < n; i++)\n            res=min(res,dp[r-1][i]);\n        cout<<res<<endl;\n    }\n    return 0;\n}\n/*\nÈº¦ÍÅ«P[XÅªöxÅoÍ³êéªAAOJÅÍà¿ëñTLE·éR[h\n_CNXg@ðgpµÄð¼Éð¢Ä¢é\n*/\n//struct edge{\n//\tint to;\n//\tint cost;\n//    char kind;\n//};\n//\n//class Situation{\n//public:\n//\tint cost;\n//\tint node;\n//    int boat;\n//    int obj;\n//\n//\tSituation(int cost_,int node_,int boat_,int obj_){\n//\t\tcost=cost_;\n//        node=node_;\n//        boat=boat_;\n//        obj=obj_;\n//\t}\n//\tSituation();\n//\n//\tbool operator<(const Situation &s)const{\n//\t\treturn s.cost < this->cost;\n//\t}\n//};\n//\n//int V;\n//int n,m;\n//\n//vector<int> objLands;\n//\n//const int MAX_V = 205;\n//const int MAX_M = 1001;\n//vector<edge> G[MAX_V];\n//int d[MAX_V][MAX_M][MAX_V];\n//const int INF = 1000000000;\n//\n//void dijkstra(int s){\n//\tpriority_queue<Situation> que;\n//    for(int i = 0; i < MAX_V; i++)\n//        for(int j = 0; j < MAX_M; j++)\n//            for(int k = 0; k < MAX_V; k++)\n//                d[i][j][k]=INF;\n//    d[s][0][s] = 0;\n//    que.push(Situation(0,s,s,0));\n//\twhile(!que.empty()){\n//\t\tSituation p = que.top();\n//\t\tque.pop();\n//        int node=p.node;\n//        int boat=p.boat;\n//        int cost=p.cost;\n//        int obj=p.obj;\n//        // ¡ñÈOÉß½»ÝÌÊuÌRXgÌûª¬³¢\n//\t\tif(d[node][obj][boat] < cost)\n//            continue;\n//\t\tfor(int i = 0; i < G[node].size(); i++){\n//\t\t\tedge &e = G[node][i];\n//            int toObj=obj;\n//            // Ú®n_Ìm[hªÚInÅ éêAÚInð©ßé\n//            if(objLands[obj]==e.to)\n//                toObj++;\n//            // ¤ÌêÆCÌêÅêí¯\n//            if(e.kind=='L'){\n//                // ÅZ£\n//                if(d[e.to][toObj][boat]>d[node][obj][boat]+e.cost){\n//                    d[e.to][toObj][boat]=d[node][obj][boat]+e.cost;\n//                    if(toObj!=objLands.size())\n//                        que.push(Situation(d[e.to][toObj][boat],e.to,boat,toObj));\n//                }\n//            }\n//            else{\n//                // CoRÅÚ®·é½ßÉÍA»ÝÌêÉDª é±ÆªKv\n//                if(boat==node){\n//                    if(d[e.to][toObj][e.to]>d[node][obj][boat]+e.cost){\n//                        d[e.to][toObj][e.to]=d[node][obj][boat]+e.cost;\n//                        if(toObj!=objLands.size())\n//                            que.push(Situation(d[e.to][toObj][e.to],e.to,e.to,toObj));\n//                    }\n//                }\n//            }\n//\t\t}\n//\t}\n//}\n//\n//int main(){\n//\n//    while(cin>>n>>m&&!(n==0&&m==0)){\n//        objLands.clear();\n//        for(int i = 0; i < MAX_V; i++)\n//            G[i].clear();\n//        for(int i = 0; i < m; i++){\n//            int from,to,cost;\n//            char c;\n//            cin>>from>>to>>cost>>c;\n//            from--;to--;\n//            edge e;\n//            e.cost=cost;e.kind=c;e.to=to;\n//            G[from].push_back(e);\n//            e.to=from;\n//            G[to].push_back(e);\n//        }\n//        int t;\n//        cin>>t;\n//        int s;\n//        for(int i = 0; i < t; i++){\n//            if(i==0){\n//                cin>>s;\n//                s--;\n//            }\n//            else{\n//                int b;\n//                cin>>b;\n//                b--;\n//                objLands.push_back(b);\n//            }\n//        }\n//        dijkstra(s);\n//        int minCost=INF;\n//        for(int i = 0; i < n; i++){\n//            for(int j = 0; j < n; j++)\n//                minCost=min(minCost,d[objLands[objLands.size()-1]][objLands.size()][j]);\n//        }\n//        cout<<minCost<<endl;\n//    }\n//    return 0;\n//}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nstruct edge{\n    int to,cost;\n    bool S;\n    edge(int a,int b,bool c):to(a),cost(b),S(c){}\n};\n\nstruct data{\n    int pos,cost,ship;\n    data(int a,int b,int c):pos(a),cost(b),ship(c){}\n    bool operator<(const data &d)const{\n        return cost>d.cost;\n    }\n};\n\nint N,M,T;\nvector<edge>G[200];\nvector<int>task;\nint dist[200][200];\nconst int INF=1001001001;\nvoid solve(){\n    priority_queue<data>Q;\n\n    for(int i=0;i<T-1;i++){\n        if(i==0){\n            for(int j=0;j<N;j++)fill_n(dist[j],N,INF);\n            dist[task[0]][task[0]]=0;\n            Q.push(data(task[0],0,task[0]));\n        }\n        else{\n            for(int j=0;j<N;j++)if(task[i]!=j)fill_n(dist[j],N,INF);\n            for(int j=0;j<N;j++){\n                Q.push(data(task[i],dist[task[i]][j],j));\n            }\n        }\n\n        while(Q.size()){\n            data d=Q.top();Q.pop();\n\n            if(dist[d.pos][d.ship]<d.cost)continue;\n\n            for(int j=0;j<G[d.pos].size();j++){\n                edge &e=G[d.pos][j];\n                if(e.S){\n                    if(d.pos!=d.ship)continue;\n                    if(dist[e.to][e.to]<=d.cost+e.cost)continue;\n                    dist[e.to][e.to]=d.cost+e.cost;\n                    Q.push(data(e.to,d.cost+e.cost,e.to));\n                }\n                else{\n                    if(dist[e.to][d.ship]<=d.cost+e.cost)continue;\n                    dist[e.to][d.ship]=d.cost+e.cost;\n                    Q.push(data(e.to,d.cost+e.cost,d.ship));\n                }\n            }\n        }\n    }\n\n    int ans=INF;\n    for(int i=0;i<N;i++)ans=min(ans,dist[task[T-1]][i]);\n    cout<<ans<<endl;\n}\n\nint main(){\n\n    while(cin>>N>>M,N||M){\n        for(int i=0;i<N;i++)G[i].clear();\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            G[a].push_back(edge(b,c,(d=='S')));\n            G[b].push_back(edge(a,c,(d=='S')));\n        }\n        cin>>T;\n        task.resize(T);\n        for(int i=0;i<T;i++)cin>>task[i],task[i]--;\n\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e8;\nconst int maxq = 1024;\nconst int maxn = 255;\n\nint dp[maxq][maxn], l[maxn][maxn], s[maxn][maxn];\nint a[maxq];\nint n, m, q;\n\nvoid init() {\n    for(int k = 0; k < n; k ++) {\n        for(int i = 0; i < n; i ++) {\n            for(int j = 0; j < n; j ++) {\n                l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for(int i = 0; i < q; i ++)\n        for(int j = 0; j < n; j ++)\n            dp[i][j] = INF;\n    for(int i = 0; i < n; i ++) \n        dp[0][i] = min(dp[0][i], s[a[0]][i] + l[i][a[0]]);\n    for(int i = 1; i < q; i ++) {\n        for(int j = 0; j < n; j ++) {\n            for(int k = 0; k < n; k ++) {\n                if(j != k)\n                dp[i][k] = min(dp[i][k], dp[i-1][j] + l[a[i-1]][j] + s[j][k] + l[k][a[i]]);\n                else \n                dp[i][j] = min(dp[i][j], dp[i-1][j] + l[a[i-1]][a[i]]);\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 0; i < n; i ++)\n        ans = min(ans, dp[q-1][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        if(n==0 && m==0) break;\n        for(int i = 0; i < n; i ++) \n            for(int j = 0; j < n; j ++) \n                l[i][j] = s[i][j] = (i==j)?0:INF;\n        while(m --) {\n            int u, v, w; char o[2];\n            scanf(\"%d%d%d%s\", &u, &v, &w, o); u--, v--;\n            if(o[0] == 'L') l[u][v] = l[v][u] = min(l[u][v], w);\n            else s[u][v] = s[v][u] = min(s[u][v], w);\n        }   scanf(\"%d\", &q);\n        for(int i = 0; i < q; i ++) {\n            scanf(\"%d\" ,a+i);\n            a[i] --;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[1111][222];\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    int x[m],y[m],t[m];\n    char sl[m];\n    for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i]>>sl[i];\n    int r;\n    cin>>r;\n    int z[r];\n    for(int i=0;i<r;i++) cin>>z[i];\n    int INF=1LL<<55LL;\n    int s[n][n],l[n][n];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\ts[i][j]=l[i][j]=INF*(i!=j);\n    for(int i=0;i<m;i++){\n      x[i]--;y[i]--;\n      if(sl[i]=='S') s[x[i]][y[i]]=s[y[i]][x[i]]=min(s[x[i]][y[i]],t[i]);\n      else l[x[i]][y[i]]=l[y[i]][x[i]]=min(l[x[i]][y[i]],t[i]);\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  s[i][j]=min(s[i][j],s[i][k]+s[k][j]),\n\t    l[i][j]=min(l[i][j],l[i][k]+l[k][j]);\n    for(int i=0;i<r;i++) z[i]--;\n    for(int i=0;i<r;i++)\n      for(int j=0;j<n;j++)\n\tdp[i][j]=INF;\n    dp[0][z[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+l[z[i]][z[i+1]]);\n\tfor(int k=0;k<n;k++)\n\t  dp[i+1][k]=min(dp[i+1][k],dp[i][j]+l[z[i]][j]+s[j][k]+l[k][z[i+1]]);\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int inf = 1e9;\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) {\n        vector<vector<int>> land(n, vector<int>(n, inf)), sea(n, vector<int>(n, inf));\n        for(int i = 0; i < n; ++i) {\n            land[i][i] = sea[i][i] = 0;\n        }\n        for(int i = 0; i < m; ++i) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            auto& d = (sl == 'L' ? land : sea);\n            d[x - 1][y - 1] = d[y - 1][x - 1] = min(t, d[y - 1][x - 1]);\n        }\n        for(int k = 0; k < n; ++k) {\n            for(int i = 0; i < n; ++i) {\n                for(int j = 0; j < n; ++j) {\n                    land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n                    sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n                }\n            }\n        }\n\n        int r; cin >> r;\n        vector<int> z(r);\n        for(int i = 0; i < r; ++i) {\n            cin >> z[i]; z[i]--;\n        }\n\n        vector<int> dp(n, inf);\n        dp[z[0]] = 0;\n        for(int i = 1; i < r; ++i) {\n            vector<int> nxt(n, inf);\n            for(int from = 0; from < n; ++from) { // ship from\n                if(dp[from] == inf) continue;\n                nxt[from] = min(nxt[from], dp[from] + land[z[i - 1]][z[i]]); // not use\n                for(int to = 0; to < n; ++to) { // ship to\n                    nxt[to] = min(nxt[to], dp[from] + land[z[i - 1]][from] + sea[from][to] + land[to][z[i]]);\n                }\n            }\n            dp = move(nxt);\n        }\n\n        cout << *min_element(begin(dp), end(dp)) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=205;\nconst int MAX_M=10000;\nconst int MAX_R=1005;\nconst int INF=0x3f3f3f3f;\n\nint land[MAX_N][MAX_N];\nint water[MAX_N][MAX_N];\nint N, M, R;\nint dp[MAX_R][MAX_N];\nint dest[MAX_R];\n\nvoid floyd(int d[MAX_N][MAX_N]){\n    for(int i=0; i<N; i++){\n        for(int j=0; j<N; j++){\n            for(int k=0; k<N; k++){\n                d[j][k]=min(d[j][k], d[j][i]+d[i][k]);\n            }\n        }\n    }\n}\n\nint main(){\n    while((cin>>N>>M) && N>0){\n        memset(land, 0x3f, sizeof(land));\n        memset(water, 0x3f, sizeof(water));\n        int x, y, t; char sl;\n        for(int i=0; i<M; i++){\n            scanf(\"%d %d %d %c \", &x, &y, &t, &sl);\n            --x; --y;\n            if(sl=='L'){ land[x][y]=land[y][x]=t;}\n            else {water[x][y]=water[y][x]=t;}\n        }\n        for(int i=0; i<N; i++) water[i][i]=land[i][i]=0;\n        floyd(land); floyd(water);\n        cin>>R;\n        for(int i=0; i<R; i++) cin>>dest[i];\n        for(int i=0; i<N; i++) dp[0][i]=water[0][i];\n        int pre=0, z;\n        for(int i=0; i<R; i++){\n            z=dest[i]; z--;\n            for(int j=0; j<N; j++){\n                int mincost=INF;\n                for(int k=0; k<N; k++){\n                    if(dp[i][k]!=INF && water[j][k]!=INF \n                    && land[pre][k]!=INF && land[z][j]!=INF){\n                        int t=dp[i][k]+water[k][j]+land[pre][k]+land[j][z];\n                        mincost=min(mincost, t);\n                    }\n                }\n                dp[i+1][j]=mincost;\n            }\n            pre=z;\n        }\n        int mincost=INF;\n        for(int i=0; i<N; i++) mincost=min(mincost, dp[R][i]);\n        cout<<mincost<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<int,int,int> tpl;\n    static int dist[128][128][1024];\n    fill_n((int*)dist,128*128*1024,inf);\n    priority_queue<pair<int,tpl>,vector<pair<int,tpl>>,greater<pair<int,tpl>>> que;\n    dist[z[0]][z[0]][1]=true;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        int d=t.first,p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        if(d>dist[p1][p2][num]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p2][num_]) continue;\n            dist[p_][p2][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p2,num_)));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first,d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p_][num_]) continue;\n            dist[p_][p_][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p_,num_)));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint sea[200][200], land[200][200], z[1000];\nll dp[1000][200];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M, R, x, y, t;\n    char _c;\n    while(cin >> N >> M && N){\n        rep(i, N) rep(j, N)\n          sea[i][j] = land[i][j] = i == j ? 0: INF;\n        rep(i, M){\n            cin >> x >> y >> t >> _c; --x; --y;\n            if(_c == 'L')\n              land[x][y] = land[y][x] = min(land[x][y], t);\n            else\n              sea[x][y] = sea[y][x] = min(sea[x][y], t);\n        }\n        cin >> R;\n        rep(i, R){\n            cin >> z[i];\n            --z[i];\n        }\n        \n        rep(k, N) rep(i, N) rep(j, N){\n            sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n        }\n        \n        rep(i, 1000) rep(j, 200) dp[i][j] = INF;\n        dp[0][z[0]] = 0;\n        REP(i, 1, R) rep(j, N){\n            dp[i][j] = min(dp[i][j], dp[i - 1][j] + (ll)land[z[i - 1]][z[i]]);\n            rep(k, N)\n              dp[i][j] = min(dp[i][j], dp[i - 1][k] + (ll)land[z[i - 1]][k] + (ll)sea[k][j] + (ll)land[j][z[i]]);\n        }\n        \n        ll ans = INF;\n        rep(i, N) ans = min(ans, dp[R - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL INF = 1e14;\n\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M, R;\n  while(cin >> N >> M, N){\n\tfill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n\tfill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n\n\tREP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n\tREP(i,M){\n\t  LL x, y, t; char c;\n\t  cin >> x >> y >> t >> c;\n\t  --x, --y;\n\t  if(c == 'L')\n\t\tdist_L[x][y] = dist_L[y][x] = min(dist_L[x][y], t);\n\t  else\n\t\tdist_S[x][y] = dist_S[y][x] = min(dist_S[x][y], t);\n\t}\n\t\n\tREP(k,N) REP(i,N) REP(j,N){\n\t  dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n\t  dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n\t}\n\n\tcin >> R;\n\tVI RS(R);\n\tREP(i,R){\n\t  cin >> RS[i];\n\t  --RS[i];\n\t}\n\n\t// dp[i][j] :<=> i???????????§?¨???????????????£??????????????????j?????¨??????????°??????????\n\tfill((LL*)dp, (LL*)dp+1001*201, INF);\n\tdp[RS[0]][RS[0]] = 0;\n\tREP(i,R-1){\n\t  REP(u,N){\n\t\tif(dp[i][u] >= INF) continue;\n\t\tREP(v,N){\n\t\t  dp[i+1][v] = min(dp[i+1][v],\n\t\t\t\t\t\t   // Rs[i] -> u????????§???u -> v????????§???v->RS[i+1]????????§?§????\n\t\t\t\t\t\t   dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n\t\t\t\t\t\t   );\n\t\t}\n\t  }\n\t}\n\n\tLL ans = INF;\n\tREP(u,N) ans = min(ans, dp[R-1][u]);\n\tcout << ans << endl;\n  }  \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=min(dL[s][t],v);  \n     dL[t][s]=min(dL[t][s],v);  \n     }else{\n     dS[s][t]=min(dS[s][t],v);  \n     dS[t][s]=min(dS[t][s],v); \n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           if(j!=k) dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nLL dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint main() {\n\tint x, y, t, r, z, rz;\n\tchar s;\n\twhile (cin >> n >> m && n>=1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HLINF;\n\t\t\t\tdsea[i][j] = HLINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tfor (int i = 1; i <= 200; i++)for (int j = 0; j < r; j++)dp[j][i] = HLINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tLL ans = HLINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nint dijkstra(){\n  vector<vector<int> > D(n+1,vector<int>(r+1,INF));\n  vector<vector<int> > used(n+1,vector<int>(r+1,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(cost<0)assert(0);\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n\n    \n    int npos=z[idx+1];\n    int ncost=cost+G[pos][npos][0];\n    if(pos!=ship&&D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    if(pos==ship)\n      for(int i=0;i<n;i++){\n\tncost=cost+G[pos][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n      }\n  }\n  return -1;  \n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define int long long\ntypedef pair<int, int> p;\nconst int INF = 1e16;\n\nint dp[1001][201];\n\nint ld[201][201];\nint sd[201][201];\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\trep(i, 201)rep(j, 201) {\n\t\t\tld[i][j] = sd[i][j] = INF;\n\t\t}\n\t\trep(i, 201) {\n\t\t\tld[i][i] = 0;\n\t\t\tsd[i][i] = 0;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--; y--;\n\t\t\tif (s == 'S') {\n\t\t\t\tsd[y][x] = sd[x][y] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld[y][x] = ld[x][y] = t;\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tsd[i][j] = min(sd[i][j], sd[i][k] + sd[k][j]);\n\t\t\tld[i][j] = min(ld[i][j], ld[i][k] + ld[k][j]);\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i, 1001)rep(j, 201) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\n\t\tdp[0][z[0]] = 0;\n\t\trep(i, r - 1) {\n\t\t\trep(s, n) {\n\t\t\t\t//z[i] to z[i+1]\n\t\t\t\tdp[i + 1][s] = min(dp[i + 1][s], dp[i][s] + ld[z[i]][z[i + 1]]);\n\t\t\t\trep(j, n) {\n\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][s] + ld[z[i]][s] + sd[s][j] + ld[j][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(s, n) {\n\t\t\tans = min(ans, dp[r - 1][s]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<28\nusing namespace std;\n\nint n,m,r;\nint s[201][201],t[201][201],z[1001],dp[1001][201];\n\nvoid init(){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)s[i][j]=0;\n      else s[i][j]=inf;\n      if(i==j)t[i][j]=0;\n      else t[i][j]=inf;\n    }\n    for(int j=0;j<1001;j++)dp[i][j]=inf;\n  }\n}\n\nvoid wf(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n\tt[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int a,b,d;\n  char c;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>c;\n      a--;b--;\n      //  cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl;\n      if(c=='L'){\n\tt[a][b]=d;\n\tt[b][a]=d;\n      }\n      else {\n\ts[a][b]=d;\n\ts[b][a]=d;\n      }\n    }\n    cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n      z[i]--;\n    }\n\n    wf();\n    int ans=inf;\n    dp[0][z[0]]=0;\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]+t[z[i-1]][k]+s[k][j]+t[z[i]][j]);\n\t  if(i==r-1)ans=min(ans,dp[i][j]);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 201;\nconst int MAX_R = 1002;\nconst int INF = 10000;\nint N, M, R;\nint dS[MAX_N][MAX_N];  // 海路\nint dL[MAX_N][MAX_N];  // 陸路\n// dp[i][j] := 船がjの場所にあって，z[0], z[1], ..., z[i]までの経過時間\nint dp[MAX_R][MAX_N];\nint z[MAX_R];\n\nvoid warshall_floyd(int d[MAX_N][MAX_N])\n{\n    for (int k = 0; k < N; k++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main()\n{\n    while (cin >> N >> M, N || M) {\n        // dL,dSの初期化\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++) {\n                dp[i][j] = INF;\n                if (i == j)\n                    dL[i][j] = dS[i][j] = 0;\n                else\n                    dL[i][j] = dS[i][j] = INF;\n            }\n\n        // Input\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char c;\n\n            cin >> x >> y >> t >> c;\n            x--, y--;\n\n            if (c == 'S' && dS[x][y] > t) // 海路\n                dS[x][y] = dS[y][x] = t;\n            else if (c == 'L' && dL[x][y] > t) // 陸路\n                dL[x][y] = dL[y][x] = t;\n        }\n\n        cin >> R;\n        for (int i = 0; i < R; i++) {\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // Warshall-Floyd\n        warshall_floyd(dL);\n        warshall_floyd(dS);\n\n        // dpの初期化\n        for (int i = 0; i < R; i++)\n            for (int j = 0; j < N; j++)\n                dp[i][j] = INF;\n\n        dp[0][z[0]] = 0;\n        for (int i = 0; i < R - 1; i++) {\n            for (int j = 0; j < N; j++) {\n                int from = z[i], to = z[i + 1];\n\n                // とりえない状態\n                if (dp[i][j] == INF)\n                    continue;\n\n                // 陸路のみを使う場合\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dL[from][to]);\n\n                // 陸路+海路を使う場合\n                for (int k = 0; k < N; k++)\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dL[from][j] +\n                                       dS[j][k] + dL[k][to]);\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < N; i++)\n            ans = min(ans, dp[R - 1][i]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n \nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nLL ld[202][202]; \nLL sd[202][202]; \nLL dp[1002][202];\nLL ret;\nint n,m,x,y,t,r,z;\nchar sl;\n\n \nint main(){\n    while(1){\n        rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n         \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)break;\n        rep(i,m){\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n         \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n         \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n        \n        rep(i,1002)rep(j,202)dp[i][j]=INF;\n         \n        scanf(\"%d\",&r);\n        scanf(\"%d\",&z);\n        dp[0][z]=0;\n         \n        ret=INF;\n        rep1(i,r-1){\n            scanf(\"%d\",&z);\n            rep1(j,n){\n                if(ld[j][z]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+sd[k][j]);\n                    }\n                    if(i!=r-1){\n                        if(dp[i][j]!=INF)dp[i][j]+=2*ld[j][z];\n                    }\n                    else{\n                        dp[i][j]+=ld[j][z];\n                        ret=min(ret,dp[i][j]);\n                    }\n                }\n            }\n        }\n         \n        printf(\"%I64d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct edge { int to; int cost; char type; };\nstruct Postman { int pos; int ship; int cost; };\nint V, E, R;\nstd::vector<edge> G[MAX_V];\nint D[MAX_V][MAX_V], PATH[MAX_R];\n\nbool cmp(const Postman &p1, const Postman &p2) {\n  return p1.cost > p2.cost;\n}\n\nvoid solve() {\n  for (size_t v = 0; v < V; v++) fill(D[v], D[v] + V, INF);\n  D[PATH[0]][PATH[0]] = 0;\n\n  for (size_t i = 0; i < R - 1; i++) {\n    std::priority_queue<Postman, vector<Postman>, std::function<bool(const Postman &, const Postman &)> > pque(&cmp);\n    int v0 = PATH[i], vf = PATH[i + 1];\n    // printf(\"%d -> %d\\n\", v0, vf);\n    for (int s = 0; s < V; s++) {\n      Postman p = {v0, s, D[v0][s]};\n      if (D[v0][s] < INF) pque.push(p);\n    }\n    while (!pque.empty()) {\n      Postman p = pque.top(); pque.pop();\n      int v = p.pos, s = p.ship;\n      if(D[v][s] < p.cost) continue;\n      // printf(\"v=%d,s=%d,c=%d\\n\", v, s, p.cost);\n      for (size_t j = 0; j < G[v].size(); j++) {\n        edge e = G[v][j];\n        int u = e.to, cost = e.cost;\n        if (e.type == 'L') {\n          if (D[v][s] + cost < D[u][s]) {\n            D[u][s] = D[v][s] + cost;\n            pque.push((Postman) {u, s, D[u][s]});\n//            printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, s, D[u][s], e.type);\n          }\n        } else if (v == s) {\n          if (D[v][s] + cost < D[u][u]) {\n            D[u][u] = D[v][s] + cost;\n            pque.push((Postman) {u, u, D[u][u]});\n            // printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, u, D[u][u], e.type);\n          }\n        }\n      }\n    }\n    for (size_t v = 0; v < V; v++) {\n      if (v != vf) fill(D[v], D[v] + V, INF);\n    }\n  }\n\n  int vF = PATH[R - 1];\n  int ans = INF;\n  for (size_t s = 0; s < V; s++) {\n    ans = min(ans, D[vF][s]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost;\n      char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      G[v].push_back((edge) {u, cost, c});\n      G[u].push_back((edge) {v, cost, c});\n    }\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n\n    for (size_t v = 0; v < V; v++) G[v].clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<limits.h>\n#include<algorithm>\n#include<cstring>\n#include<math.h>\n#include<set>\n#include<vector>\n#include<queue>\n#include<set>\n#include<stdlib.h>\n#include<time.h>\nusing namespace std;\ntypedef long long ll;\n#define inf\t0x3f3f3f3f\ntypedef pair<int,int>\tP;\nint n,m;\nint r;\nint def[1001];\n/*struct Road{\n\tint ldis;\n\tint sdis;\n};\nvector<Road> roads[300][300];\n*/\nint l[300][300];\nint s[300][300];\nll dp[1010][300];\nvoid init() {\n\t//memset(,inf,sizeof(road));\n\tmemset(l,inf,sizeof(l));\n\tmemset(s,inf,sizeof(s));\n\tmemset(dp,inf,sizeof(dp));\n\tfor(int i=1; i<=n; i++) {\n\t\tl[i][i]=0;\n\t\ts[i][i]=0;\n\t}\n}\n\nvoid floyd() {\n\tfor(int k=1; k<=n; k++) {\n\t\tfor(int i=1; i<=n; i++) {\n\t\t\tfor(int j=1; j<=n; j++) {\n\t\t\t\tif(l[i][j]>l[i][k]+l[k][j]) {\n\t\t\t\t\tl[i][j]=l[i][k]+l[k][j];\n\t\t\t\t}\n\t\t\t\tif(s[i][j]>s[i][k]+s[k][j]) {\n\t\t\t\t\ts[i][j]=s[i][k]+s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nll solve() {\n\tfloyd();\n\tfor(int i=1; i<=n; i++) {\n\t\tdp[1][i]=s[def[1]][i]+l[i][def[1]];\n\t}\n\tfor(int i=2; i<=r; i++) {\n\t\tfor(int j=1; j<=n; j++) {\t//上次停船地方\n\t\t\t//分析旱路\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+l[def[i-1]][def[i]]);\n\t\t\t//将船停到新地方，为下一次做准备\n\t\t\tfor(int k=1; k<=n; k++) {\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+l[def[i-1]][j]+s[j][k]+l[k][def[i]]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r]+1,dp[r]+1+n);\n}\n\nint main() {\n\tint x,y,t;\n\tchar str[2];\n\t//cout<<(ll)inf<<endl;\n\twhile(scanf(\"%d%d\",&n,&m)!=EOF) {\n\t\tif(n==0&&m==0){\n\t\t\tbreak;\n\t\t}\n\t\tinit();\n\t\twhile(m--) {\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,str);\n\t\t\tif(str[0]=='L') {\n\t\t\t\tl[x][y]=l[y][x]=t;\n\t\t\t} else if(str[0]=='S') {\n\t\t\t\ts[x][y]=s[y][x]=t;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=1; i<=r; i++) {\n\t\t\tscanf(\"%d\",&def[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",solve());\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <sstream>\n#include <utility>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(ll i=a; i<ll(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define each(e,c) for(auto&e:c)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#ifdef DEBUG\n#define dump(...) (cerr<<#__VA_ARGS__<<\" = \"<<(DUMP(),__VA_ARGS__).str()<<\" [\"<<__LINE__<<\"]\"<<endl)\nstruct DUMP:ostringstream{template<class T>DUMP &operator,(const T&t){if(this->tellp())*this<<\", \";*this<<t;return *this;}};\n#else\n#define dump(...)\n#endif\ntemplate<class T> ostream& operator<<(ostream& os, vector<T> const& v){\n    rep(i,v.size()) os << v[i] << (i+1==v.size()?\"\":\" \");\n    return os;\n}\n\nint N,M;\nint ds[222][222], dl[222][222];\nint r[1111];\nint dp[1111][222];\n\nint const inf = 1<<28;\n\nint main(){\n    while(cin>>N>>M && N){\n        rep(i,N)rep(j,N) ds[i][j] = dl[i][j] = inf;\n        rep(i,N) ds[i][i] = dl[i][i] = 0;\n        rep(i,M){\n            int x,y,d; char c;\n            cin >> x >> y >> d >> c;\n            x--; y--;\n            if(c=='L') dl[x][y] = dl[y][x] = min(d,dl[y][x]);\n            if(c=='S') ds[x][y] = ds[y][x] = min(d,ds[y][x]);\n        }\n        int x; cin >> x;\n        rep(i,x){\n            cin >> r[i];\n            r[i]--;\n        }\n        rep(k,N)rep(i,N)rep(j,N){\n            dl[i][j] = min(dl[i][j],dl[i][k]+dl[k][j]);\n            ds[i][j] = min(ds[i][j],ds[i][k]+ds[k][j]);\n        }\n        rep(i,x+1)rep(j,N) dp[i][j] = inf;\n        dp[0][r[0]] = 0;\n        loop(i,1,x){\n            rep(j,N){\n                // ティツ按ケテ」ツつ男テ」ツ?ォテァツスツョテ」ツ??」ツ?ヲテヲツュツゥテ」ツ??」ツ?ヲr[i]テ」ツ?クティツ。ツ古」ツ??\n                dp[i][j] = min(dp[i][j], dp[i-1][j]+dl[r[i-1]][r[i]]);\n                rep(k,N){\n                    // ティツ按ケテ」ツつ津・ツ渉姪」ツつ甘」ツ?ォティツ。ツ古」ツ?催」ツ??ィツ按ケテ」ツ?ァkテ」ツ?セテ」ツ?ァテァツァツサテ・ツ仰陛」ツ?療」ツ??ヲツュツゥテ」ツ??」ツ?ヲr[i]テ」ツ?ォティツ。ツ古」ツ??\n                    dp[i][k] = min(dp[i][k], dp[i-1][j]+dl[r[i-1]][j]+ds[j][k]+dl[k][r[i]]);\n                }\n            }\n        }\n        int ans = inf;\n        rep(i,N) ans = min(ans, dp[x-1][i]);\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<vector>\nusing namespace std;\n\n#define MAX_N 1020\n#define INF 123456789\n\npriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>Q;\n\nint L[MAX_N][MAX_N];\nint S[MAX_N][MAX_N];\nint LD[MAX_N][MAX_N];\nint SD[MAX_N][MAX_N];\nint DP[MAX_N][MAX_N];\nint T[MAX_N], DIST[MAX_N];\nint A, B, C, N, M, R, res; char D;\n\nvoid dijkstra(int v, int st) {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tDIST[i] = INF;\n\t}\n\tDIST[st] = 0;\n\tQ.push(make_pair(0, st));\n\twhile (!Q.empty()) {\n\t\tpair<int, int>p = Q.top(); Q.pop();\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tif (v == 1) {\n\t\t\t\tif (L[p.second][i] + p.first < DIST[i]) {\n\t\t\t\t\tDIST[i] = L[p.second][i] + p.first;\n\t\t\t\t\tQ.push(make_pair(DIST[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (S[p.second][i] + p.first < DIST[i]) {\n\t\t\t\t\tDIST[i] = S[p.second][i] + p.first;\n\t\t\t\t\tQ.push(make_pair(DIST[i], i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tres = INF;\n\t\tfor (int i = 0; i < MAX_N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tL[i][j] = INF; S[i][j] = INF;\n\t\t\t\tLD[i][j] = INF; SD[i][j] = INF;\n\t\t\t\tDP[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) { break; }\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A >> B >> C >> D;\n\t\t\tif (D == 'L') {\n\t\t\t\tL[A][B] = C;\n\t\t\t\tL[B][A] = C;\n\t\t\t}\n\t\t\tif (D == 'S') {\n\t\t\t\tS[A][B] = C;\n\t\t\t\tS[B][A] = C;\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> T[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdijkstra(1, i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tLD[i][j] = DIST[j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tdijkstra(2, i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tSD[i][j] = DIST[j];\n\t\t\t}\n\t\t}\n\t\tDP[0][T[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tint ST = T[i], GO = T[i + 1];\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + LD[ST][j] + SD[j][k] + LD[k][GO]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\tif(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",res);\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tif(R == 1) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[z[0]][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + land[A][B]);\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tassert(ans < INF);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[100][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<100;i++){\n\t\tfor(int j=0;j<200;j++){\n\t\t\tfor(int k=0;k<200;k++){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(reset,false,sizeof(reset));\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(0,0))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\tres=min(res,nc);\n\t\t\tcontinue;\n\t\t}\n\t\tif(now==rt[np]){\n\t\t\tnp++;\n\t\t\tif(reset[np]==false){\n\t\t\t\tfor(int i=0;i<200;i++){\n\t\t\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\t\t\tcost[np%10][i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset[np]=true;\n\t\t\t}\n\t\t}\n\t\tif(cost[np%10][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np%10][e.t][ns]){\n\t\t\t\tcost[np%10][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np%10][e.t][e.t]){\n\t\t\t\t\tcost[np%10][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\nconst int N = 222;\nconst int R = 1111;\nconst int INF = 500000000;\nint n,m;\n\nvector<pii> sea[N];\nvector<pii> land[N];\nvector<int> move;\n\nint wsea[N][N];\nint wland[N][N];\n\nvoid init(){\n\trep(i,N)sea[i].clear();\n\trep(i,N)land[i].clear();\n\tmove.clear();\n\t\n\trep(i,N)rep(j,N)wsea[i][j]=wland[i][j]=INF;\n}\n\nbool input(){\n\tcin>>n>>m;\n\tif(n==0)return false;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(d==\"L\"){\n\t\t\tland[a].push_back(pii(b,c));\n\t\t\tland[b].push_back(pii(a,c));\n\t\t}\n\t\tif(d==\"S\"){\n\t\t\tsea[a].push_back(pii(b,c));\n\t\t\tsea[b].push_back(pii(a,c));\n\t\t}\n\t}\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\t\n\treturn true;\n}\n\nvoid solve_wf_edge(int memo[N][N], vector<pii> edge[N]){\n\trep(i,N)rep(j,N)memo[i][j]=INF;\n\treps(i,1,n+1)memo[i][i]=0;\n\trep(i,n+1){\n\t\trep(j,edge[i].size()){\n\t\t\tpii e = edge[i][j];\n\t\t\tmemo[i][e.first] = e.second;\n\t\t\tmemo[e.first][i] = e.second;\n\t\t}\n\t}\n\t\n\treps(k,1,n+1){\n\t\treps(i,1,n+1){\n\t\t\treps(j,1,n+1){\n\t\t\t\tmemo[i][j] = min(memo[i][j], memo[i][k]+memo[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve_wf(){\n\tsolve_wf_edge(wsea, sea);\n\tsolve_wf_edge(wland, land);\n}\n\nint solve_dp(){\n\tint dp[R][N];\n\trep(i,R)rep(j,N)dp[i][j]=INF;\n\t\n\tdp[0][move[0]]=0;\n\t\n\treps(i,1,move.size()){\n\t\tint prev = move[i-1];\n\t\tint now = move[i];\n\t\treps(j,1,n+1){\n\t\t\tdp[i][j]=min(INF,dp[i-1][j]+wland[prev][now]);\n\t\t\treps(k,1,n+1){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k]+wland[prev][k]+wsea[k][j]+wland[j][now]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret = INF;\n\treps(i,1,n+1)ret = min(ret, dp[move.size()-1][i]);\n\tif(ret>=INF)return -1;\n\treturn ret;\n}\n\nint solve(){\n\tsolve_wf();\n\treturn solve_dp();\n}\n\nint main(){\n\twhile(init(),input()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n3 3\n1 2 5 L\n1 2 7 S\n2 3 11 S\n3\n1 2 3\n0 0\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\n\n#define fst first;\n#define snd second;\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) (x).begin(), (x).end()\n#define RANGE(x, y, w, h) (0 <= (x) && 0 <= (y) && (x) < (w) && (y) < (h))\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = (init); i < (n); i++)\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[] = {1,0,-1,0}, DY[] = {0,-1,0,1};\n\nint N, M;\nint R;\nVI rs;\n\nVVI seas;\nVVI loads;\n\nint solve() {\n    // ????????????\n    rep(k, N) {\n        rep(i, N) {\n            rep(j, N) {\n                seas[i][j] = min(seas[i][j], seas[i][k] + seas[k][j]);\n                loads[i][j] = min(loads[i][j], loads[i][k] + loads[k][j]);\n            }\n        }\n    }\n    // 8,000,000\n\n    cout << \"????????????ok!\" << endl;\n\n    // dp[ri][where]\n    VVI dp(R, VI(V));\n    dp[0][R[0]] = 0;\n\n    rep(ri, R - 1) {    // 1000\n        rep(w, V) {     // 200\n            if (dp[ri][w] == INF) continue;\n\n            int s = R[ri];\n            int g = R[ri + 1];\n\n            dp[ri + 1][w] = min(dp[ri + 1][w], dp[ri][w] + loads[s][g]);\n\n            int cost = dp[ri][w] + loads[s][w];\n            rep(w2, V) {    // 200\n                int cost2 = cost;\n                cost2 += seas[w][w2];\n                cost2 += loads[w2][g];\n                dp[ri + 1][w2] = min(dp[ri + 1][w2], cost2);\n            }\n        }\n    }\n    // 40,000,000\n\n\n    return *min_element(ALL(dp[R.back()]));\n}\n\nint main(void) {\n    cin.tie( 0 );\n    ios::sync_with_stdio( false );\n\n    while (cin >> N >> M, N) {\n        es.clear();\n        es.resize(N);\n\n        seas = VVI(N, VI(N, INF));\n        loads = VVI(N, VI(N, INF));\n        rep(i, N) rep(j, N) {\n            seas[i][j] = 0;\n            loads[i][j] = 0;\n        }\n\n        rep(i, M) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n\n            bool is_sea = sl == 'S';\n\n            (is_sea ? seas : loads)[x][y] = t;\n            (is_sea ? seas : loads)[y][x] = t;\n        }\n\n        cin >> R;\n        rs = VI(R);\n        for (auto &r : rs) {\n            cin >> r;\n            --r;\n        }\n\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(301,301,INF);\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,r){\n                rep(k,r){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=205;\nconst int MAX_M=10000;\nconst int MAX_R=1005;\nconst int INF=0x3f3f3f3f;\n\nint land[MAX_N][MAX_N];\nint water[MAX_N][MAX_N];\nint N, M, R;\nint dp[MAX_R][MAX_N];\nint dest[MAX_R];\n\nint main(){\n    while((cin>>N>>M) && N>0){\n        memset(land, 0x3f, sizeof(land));\n        memset(water, 0x3f, sizeof(water));\n        memset(dp, 0x3f, sizeof(dp));\n        int x, y, t; char sl;\n        for(int i=0; i<M; i++){\n            scanf(\"%d %d %d %c \", &x, &y, &t, &sl);\n            --x; --y;\n            if(sl=='L'){\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=land[x][y];\n\t\t\t}\n            else {\n\t\t\t\twater[x][y]=min(water[x][y], t);\n\t\t\t\twater[y][x]=water[x][y];\n\t\t\t}\n        }\n        for(int i=0; i<N; i++) water[i][i]=land[i][i]=0;\n        for(int i=0; i<N; i++){\n        \tfor(int j=0; j<N; j++){\n            \tfor(int k=0; k<N; k++){\n                \tland[j][k]=min(land[j][k], land[j][i]+land[i][k]);\n                \twater[j][k]=min(water[j][k], water[j][i]+water[i][k]);\n            \t}\n        \t}\n   \t    }\n        cin>>R;\n        for(int i=0; i<R; i++) {\n\t\t\tcin>>dest[i]; --dest[i];\n\t\t}\n        for(int i=0; i<N; i++) dp[0][i]=water[dest[0]][i]+land[dest[0]][i];\n        int pre=dest[0], z;\n        for(int i=1; i<R; i++){\n            z=dest[i]; \n            for(int j=0; j<N; j++){\n                int mincost=INF;\n                for(int k=0; k<N; k++){\n                    if(dp[i-1][k]!=INF && water[j][k]!=INF \n                    && land[pre][k]!=INF && land[z][j]!=INF){\n                        if(j==k) t=dp[i-1][k]+land[pre][z];\n                        else t=dp[i-1][k]+water[k][j]+land[pre][k]+land[j][z];\n                        mincost=min(mincost, t);\n                    }\n                }\n                dp[i][j]=mincost;\n            }\n            pre=z;\n        }\n        int mincost=INF;\n        for(int i=0; i<N; i++) mincost=min(mincost, dp[R-1][i]);\n        cout<<mincost<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n\nconst lint INF = 1ll << 30;\ninline void chmin(lint &a, lint b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1001];\n\nlint solve()\n{\n\tstatic lint ldist[200][200];\n\tstatic lint sdist[200][200];\n\tstatic lint dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1001 * 200, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tchmin(dp[i + 1][j], dp[i][j] + ldist[src][dst]);\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tlint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r], dp[r + 1]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl == \"L\") ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N   = 200;\nconst int inf =(1<<28);\n\nint land[N][N];\nint sea[N][N];\n\nvoid wf(int n,int mat[N][N]){\n  rep(k,n)rep(i,n)rep(j,n)mat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);\n}\n\n\nint dp[1000][N];\nint solve(int n,vector<int> &in,int s){\n  wf(n,land);\n  wf(n,sea);\n  rep(i,in.size())rep(j,n)dp[i][j]=inf;\n//   rep(i,n){\n//     rep(j,n){\n//       dp[0][j]=min(dp[0][j],land[s][i]+sea[i][j]+land[j][in[0]]);\n//       cout << dp[0][j] << endl;\n//     }\n//   }\n\n  dp[0][s]=0;\n\n  REP(i,1,in.size()){\n    rep(j,n){\n      rep(k,n){\n\tdp[i][k]=min(dp[i][k],\n\t\t     dp[i-1][j]+land[in[i-1]][j]+sea[j][k]+land[k][in[i]]);\n\tdp[i][k]=min(dp[i][k],dp[i-1][k]+land[in[i-1]][in[i]]);\n      }\n    }\n  }\n\n  int ret = inf;\n  rep(i,n)ret=min(ret,dp[n-1][i]);\n  return ret;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n){\n      rep(j,n)sea[i][j]=land[i][j]=inf;\n      sea[i][i]=0;land[i][i]=0;\n    }\n    rep(i,m){\n      int f,t,c;char tmp;\n      cin>>f>>t>>c>>tmp;\n      f--;t--;\n      if (tmp == 'L')land[f][t]=land[t][f]=min(land[t][f],c);\n      if (tmp == 'S')sea[f][t] =sea[t][f] =min( sea[t][f],c);\n    }\n\n\n    int q;\n    cin>>q;\n    vector<int> in(q);\n    rep(i,q)cin>>in[i],in[i]--;\n    cout << solve(n,in,in[0]) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define ll long long\nusing namespace std;\n\nconst int N = 210;\n\nint n,m,cnt,ans,p[1010],dis[N][N][2],dp[1010][N];\n\nint gi() {\n  int x=0,o=1; char ch=getchar();\n  while(ch!='-' && (ch<'0' || ch>'9')) ch=getchar();\n  if(ch=='-') o=-1,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return o*x;\n}\n\nvoid init() {\n  ans=1<<30;\n  for(int i=0; i<=n; i++)\n    for(int j=0; j<=n; j++)\n      for(int k=0; k<2; k++)\n\tdis[i][j][k]=1e8;\n}\n\nvoid floyed() {\n  for(int t=0; t<2; t++)\n    for(int k=1; k<=n; k++) \n      for(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++)\n\t  dis[i][j][t]=min(dis[i][j][t],dis[i][k][t]+dis[k][j][t]);\n}\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) && n+m) {\n    init();\n    for(int i=1; i<=m; i++) {\n      int x=gi(),y=gi(),z=gi(); char ch;\n      scanf(\"%c\", &ch);\n      if(ch=='L') dis[x][y][0]=dis[y][x][0]=min(dis[x][y][0],z);\n      else dis[x][y][1]=dis[y][x][1]=min(dis[x][y][1],z);\n    } \n    cnt=gi();\n    for(int i=1; i<=cnt; i++) p[i]=gi();\n    for(int i=1; i<=n; i++) dis[i][i][0]=dis[i][i][1]=0;\n    floyed();\n    for(int i=0; i<=cnt; i++)\n      for(int j=0; j<=n; j++)\n\tdp[i][j]=1e8;\n    dp[1][p[1]]=0;\n    for(int i=1; i<=cnt; i++)\n      for(int j=1; j<=n; j++) {\n\tdp[i][j]=min(dp[i][j],dp[i-1][j]+dis[p[i-1]][p[i]][0]);\n\tfor(int k=1; k<=n; k++) {\n\t  dp[i][k]=min(dp[i][k],dp[i-1][j]+dis[p[i-1]][j][0]+dis[j][k][1]+dis[k][p[i]][0]);\n\t}\n      }\n    for(int i=1; i<=n; i++) ans=min(ans,dp[n][i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\nconst int INF=100000000;\n\n\nclass Node{\npublic:\n\tint now_mission,ship,sum;\n\tNode(int now_mission,int ship,int sum):now_mission(now_mission),ship(ship),sum(sum){};\n};\n\nbool operator < (Node a,Node b){\n\treturn a.sum>b.sum;\n}\n\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tvector<vector<int> > dist_ground(N,vector<int>(N,INF));\n\t\tvector<vector<int> > dist_sea(N,vector<int>(N,INF));\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y,t; char c;\n\t\t\tcin>>x>>y>>t>>c;\n\t\t\tx--;y--;\n\t\t\tif(c=='L'){\n\t\t\t\tdist_ground[x][y]=min(dist_ground[x][y],t);\n\t\t\t\tdist_ground[y][x]=min(dist_ground[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdist_sea[x][y]=min(dist_sea[x][y],t);\n\t\t\t\tdist_sea[y][x]=min(dist_sea[y][x],t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdist_sea[i][i]=dist_ground[i][i]=0;\n\t\t}\n\t\tint R;cin>>R;\n\t\tvector<int> mission(R);\n\t\tfor(int i=0;i<R;i++){cin>>mission[i];mission[i]--;}\n\n\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tdist_sea[i][j]=min(dist_sea[i][j],dist_sea[i][k]+dist_sea[k][j]);\n\t\t\t\t\tdist_ground[i][j]=min(dist_ground[i][j],dist_ground[i][k]+dist_ground[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<int> > memo(R,vector<int>(N,INF));\n\t\tmemo[0][mission[0]]=0;\n\t\tfor(int i=1;i<R;i++){\n\t\t\tint area=mission[i-1];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tmemo[i][j]=min(memo[i][j],memo[i-1][j]+dist_ground[area][mission[i]]);\n\n\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tmemo[i][j]=min(memo[i][j],\n\t\t\t\t\t\tmemo[i-1][k]+dist_ground[area][k]+dist_sea[k][j]+dist_ground[j][mission[i]]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=INF;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,memo[R-1][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\n\n/*\t\tpriority_queue<Node> que;\n\t\tque.push(Node(0,mission[0],0));\n\n\n\n\t\twhile(!que.empty()){\n\t\t\tNode info=que.top(); que.pop();\n\t\t\tif(info.sum>=memo[info.now_mission][info.ship]) continue;\n//\t\t\tcout<<\"now \"<<info.now_mission<<\" \"<<info.ship<<\" \"<<info.sum<<endl;\n\t\t\tmemo[info.now_mission][info.ship]=info.sum;\n\n\t\t\tif(info.now_mission==R-1){cout<<info.sum<<endl;break;}\n\t\t\tint target=mission[info.now_mission+1];\n\t\t\t\n\t\t\tint now_area=mission[info.now_mission];\n\t\t\tque.push(Node(info.now_mission+1,info.ship,info.sum+dist_ground[now_area][target]));\n\n\t\t\tfor(int relay=0;relay<N;relay++){\n\t\t\t\tint next_cost=dist_ground[now_area][info.ship]+dist_sea[info.ship][relay]+dist_ground[relay][target];\n\t\t\t\tif(next_cost<INF)\n\t\t\t\t\tque.push(Node(info.now_mission+1,relay,info.sum+next_cost));\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint l[222][222], w[222][222];\nint s[1111];\nconst int inf = 2e8;\nint n, m;\nint dp[1111][222];\n\nvoid floyd(int a[222][222]){\n\tfor(int k = 1; k <= n; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\ta[i][j] = min(a[i][j], a[i][k] + a[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(int argc, char const *argv[])\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"in.txt\", \"r\", stdin);\n#endif\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m && n){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfill(l[i], l[i]+n+1, inf);\n\t\t\tfill(w[i], w[i]+n+1, inf);\n\t\t\tl[i][i] = 0;\n\t\t\tw[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u, v, t;\n\t\t\tchar op[2];\n\t\t\tcin >> u >> v >> t >> op;\n\t\t\t// cout << u << endl;\n\t\t\tif(op[0] == 'L'){\n\t\t\t\tl[u][v] = min(l[u][v], t);\n\t\t\t\tl[v][u] = min(l[v][u], t);\n\t\t\t} else{\n\t\t\t\tw[u][v] = min(w[u][v], t);\n\t\t\t\tw[v][u] = min(w[v][u], t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfloyd(l);\n\t\t/*for(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tcout << l[i][j] << ' ';\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}*/\n\t\tfloyd(w);\n\t\tint len;\n\t\tcin >> len;\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tcin >> s[i];\n\t\t}\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tfill(dp[i], dp[i]+n+1, inf);\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tdp[0][i] = w[1][i];\n\t\t}\n\t\tfor(int i = 1; i <= len; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + l[s[i-1]][k] + w[k][j] + l[j][s[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << *min_element(dp[len]+1, dp[len]+n+1) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &s) const { return d > s.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > ans(2,vector<int>(n,INF));\n    ans[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){    \n      for(int j=0;j<n;j++){\n\tif(ans[0][j] >= INF) continue;\t\n\n\tpriority_queue<State> Q;\n\tState u(ans[0][j],dest[i-1],j), v;\n\tvector<vector<State2> > d(n,vector<State2>(n));\n\td[dest[i-1]][j] = ans[0][j];\n\tQ.push(u);\n\twhile(!Q.empty()){\n\t  u = Q.top();\n\t  Q.pop();\n\n\t  if(d[u.n][u.s].f) continue;\n\t  d[u.n][u.s].f = true;\n\n\t  for(int k=0;k<n;k++){\n\t    if(!d[k][u.s].f && d[u.n][u.s].d + L[u.n][k] < d[k][u.s].d){\n\t      v = u;\n\t      v.d = d[k][u.s].d = d[u.n][u.s].d + L[u.n][k];\n\t      v.n = k;\n\t      Q.push(v);\n\t    }\n\t    if(u.s == u.n){\n\t      for(int l=0;l<n;l++){\n\t\tif(l == u.n) continue;\n\t\tif(!d[k][l].f && d[u.n][u.s].d + S[u.n][k] < d[k][l].d){\n\t\t  v = u;\n\t\t  v.d = d[k][l].d = d[u.n][u.s].d + S[u.n][k];\n\t\t  v.n = k;\n\t\t  v.s = l;\n\t\t  Q.push(v);\n\t\t}\n\t      }\n\t    }\n\t  }\n\t}\n\tfor(int k=0;k<n;k++) ans[1][k] = min(ans[1][k],d[dest[i]][k].d);\n      }\n      ans[0].assign(ans[1].begin(),ans[1].end());\n      //for(int j=0;j<n;j++) if(ans[0][j] != INF) cout << ans[0][j] << \" \";\n      ans[1].assign(n,INF);\n    }\n\n    int ans2 = INF;\n    for(int i=0;i<n;i++) ans2 = min(ans2,ans[0][i]);\n    cout << ans2 << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship, cost, job;\n\tP(int now, int ship, int cost, int job) :now(now), ship(ship), cost(cost), job(job) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tint N, M;\n\t\tint SeaRoutes[201][201];\n\t\tint LandRoutes[201][201];\n\t\tint R;\n\t\tvi Destinations;\n\t\tcin >> N >> M;\n\t\tif ( N == 0 && M == 0 )break;\n\t\tFOR(i, 201)FOR(j, 201)SeaRoutes[i][j] = LandRoutes[i][j] = INF;\n\t\tFOR(i, 201)SeaRoutes[i][i] = LandRoutes[i][i] = 0;\n\t\tFOR(i, M)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif ( sl == 'S' )\n\t\t\t{\n\t\t\t\tSeaRoutes[x][y] = min(SeaRoutes[x][y], t);\n\t\t\t\tSeaRoutes[y][x] = min(SeaRoutes[y][x], t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLandRoutes[x][y] = min(LandRoutes[x][y], t);\n\t\t\t\tLandRoutes[y][x] = min(LandRoutes[y][x], t);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tFOR(i, R)\n\t\t{\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tDestinations.push_back(z);\n\t\t}\n\t\tFOR(k, N + 1)FOR(i, N + 1)FOR(j, N + 1)\n\t\t{\n\t\t\tSeaRoutes[i][j] = min(SeaRoutes[i][j], SeaRoutes[i][k] + SeaRoutes[k][j]);\n\t\t\tLandRoutes[i][j] = min(LandRoutes[i][j], LandRoutes[i][k] + LandRoutes[k][j]);\n\t\t}\n\t\tint Flag[201][1001];\n\t\tFOR(i, 201)FOR(j, 1001)Flag[i][j] = INF;\n\t\tpriority_queue< P, vector<P>, greater<P> >Queue;\n\t\tQueue.push(P(Destinations[0], Destinations[0], 0, 1));\n\t\twhile ( !Queue.empty() )\n\t\t{\n\t\t\tP Current = Queue.top(); Queue.pop();\n\t\t\tif ( Current.job == R )\n\t\t\t{\n\t\t\t\tcout << Current.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tconst int Destination = Destinations[Current.job];\n\t\t\tconst int now = Current.now;\n\t\t\tconst int ship = Current.ship;\n\n\t\t\tif ( LandRoutes[now][Destination] < INF )\n\t\t\t{\n\t\t\t\tP A = Current;\n\t\t\t\tA.cost += LandRoutes[now][Destination];\n\t\t\t\tA.now = Destination;\n\t\t\t\tA.job++;\n\t\t\t\tif ( Flag[A.ship][A.job]>A.cost )\n\t\t\t\t{\n\t\t\t\t\tQueue.push(A);\n\t\t\t\t\tFlag[A.ship][A.job] = A.cost;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tFOR(i, N + 1)\n\t\t\t{\n\t\t\t\tif ( SeaRoutes[ship][i] < INF&&LandRoutes[i][Destination] < INF )\n\t\t\t\t{\n\t\t\t\t\tP A = Current;\n\t\t\t\t\tA.cost += LandRoutes[now][ship] + SeaRoutes[ship][i] + LandRoutes[i][Destination];\n\t\t\t\t\tA.now = Destination;\n\t\t\t\t\tA.ship = i;\n\t\t\t\t\tA.job++;\n\t\t\t\t\tif ( Flag[A.ship][A.job] > A.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\tQueue.push(A);\n\t\t\t\t\t\tFlag[A.ship][A.job] = A.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\nint N, M, R;\nint ds[200][200],dl[200][200];//ship walk\nint list[1000];\nint dp[1000][200];\n\nint main() {\n\twhile (cin >> N >> M, N + M) {\n\t\tfor (int i = 0; i < N; i++)for (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i == j)dl[i][j] = ds[i][j] = 0;\n\t\t\telse dl[i][j] = ds[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, cost;\n\t\t\tchar c;\n\t\t\tcin >> a >> b >> cost >> c;\n\t\t\ta--, b--;\n\t\t\tif (c == 'L') dl[a][b] = min(cost, dl[a][b]), dl[b][a] = dl[a][b];\n\t\t\telse ds[a][b] = min(cost, ds[a][b]), ds[b][a] = ds[a][b];\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++)cin >> list[i],list[i]--;\n\t\t//???????????£???????????????\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; i++)for (int j = 0; j < N; j++)dp[i][j] = INF;\n\t\t//dp[i][j] := i???????????????????????°??§???j?????????????????¨??????????????¨?????????????????????????????????\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdp[0][i] = ds[0][i] + dl[i][list[0]];\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k)dp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[list[i]][list[i - 1]]);\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[list[i - 1]][k] + ds[k][j] + dl[j][list[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; i++)ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define pb push_back\n#define MAX 200\ntypedef pair<int,int> pi;\n#define INF (1145141919/3);\nint N,M,R;\nint G[MAX][MAX], H[MAX][MAX];\nint dp[MAX][2];\nint main()\n{\n  while(true)\n    {\n      cin>>N>>M;\n      if(N==0||M==0)return 0;\n      rep(i,N)\n\t{\n\t  rep(j,N)\n\t    {\n\t      G[i][j]=INF;\n\t      H[i][j]=INF;\n\t      if(i==j)\n\t\t{\n\t\t  G[i][j]=0;\n\t\t  H[i][j]=0;\n\t\t}\n\t    }\n\t}\n      rep(i,M)\n\t{\n\t  int x,y,t; char sl;\n\t  cin>>x>>y>>t>>sl;\n\t  x--; y--;\n\t  if(sl=='L')\n\t    {\n\t      G[x][y]=t;\n\t      G[y][x]=t;\n\t    }\n\t  else\n\t    {\n\t      H[x][y]=t;\n\t      H[y][x]=t;\n\t    }\n\t}\n      rep(k,N)\n\t{\n\t  rep(i,N)\n\t    {\n\t      rep(j,N)\n\t\t{\n\t\t  G[i][j]=min(G[i][j],G[i][k]+G[k][j]);\n\t\t  H[i][j]=min(H[i][j],H[i][k]+H[k][j]);\n\t\t}\n\t    }\n\t}\n\n      rep(i,N)\n\t{\n\t  dp[i][0]=INF;\n\t  dp[i][1]=INF;\n\t}\n      dp[0][1]=0;\n      cin>>R;      \n      int now = 0;\n      //int ship = 0;\n      \n      rep(i,R)\n\t{\n\t  int z;\n\t  cin>>z;\n\t  z--;\n\t  \n\t  rep(j,N)//j ni hune wo oiteiku\n\t    {\n\t      dp[j][i%2]=dp[j][(i+1)%2]+G[now][z];\n\t      rep(k,N)//k ni hune wo toriniiku\n\t\t{\n\t\t  dp[j][i%2]=min(dp[j][i%2],dp[k][(i+1)%2]+G[now][k]+H[k][j]+G[j][z]);\n\t\t}\n\t    }\n\t  /* rep(j,N)\n\t    {\n\t      cout << dp[j][i%2] << \" \";\n\t    }\n\t    cout << endl;*/\n\t  now=z;\n\t}\n      int ans = INF;\n      rep(k,N)\n\t{\n\t  ans=min(ans,dp[k][(R-1)%2]);\n\t}\n      cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<ll,P> State;\n\nconst int INF = 1001001001;\n\n// S N E W(南北東西)\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\nstruct Edge{\n    int to, cost;\n};\n\nint dl[200][200], ds[200][200];\nint N, M, R;\nint Z[1000];\nstd::vector<Edge> Gl[200], Gs[200];\n\nint dijkstra(){\n    int d[1000][200];\n    REP(i, 1000){\n        REP(j, 200){\n            d[i][j] = INF;\n        }\n    }\n    \n    // State: (コスト, (今いるところ, 船を置いたところ))\n    std::priority_queue<State> q;\n    d[0][0] = 0;\n    q.push(mp(0, mp(0, 0)));\n\n    while(!q.empty()){\n        State s = q.top(); q.pop();\n        int cost = s.first;\n        P p = s.second;\n\n        if(p.first == R-1){continue;}\n        if(d[p.first][p.second] < cost){continue;}\n\n        // A->陸->B\n        if(d[p.first+1][p.second] > cost + dl[Z[p.first]][Z[p.first+1]]){\n            d[p.first+1][p.second] = cost + dl[Z[p.first]][Z[p.first+1]];\n            q.push(mp(d[p.first+1][p.second], mp(p.first+1, p.second)));\n        }\n\n        // A->陸->C->海->D->陸->B\n        for(auto &e : Gs[p.second]){\n            if(d[p.first+1][e.to] > cost + dl[Z[p.first]][p.second] + e.cost + dl[e.to][Z[p.first+1]]){\n                d[p.first+1][e.to] = cost + dl[Z[p.first]][p.second] + e.cost + dl[e.to][Z[p.first+1]];\n                q.push(mp(d[p.first+1][e.to], mp(p.first+1, e.to)));\n            }\n        }\n    }\n\n    int res = INF;\n    REP(i, N){\n        res = std::min(res, d[R-1][i]);\n    }\n\n    return res;\n}\n\nint main(){\n    while(std::cin >> N >> M, N){\n        REP(i, 200){\n            REP(j, 200){\n                if(i == j){\n                    dl[i][j] = 0;\n                    ds[i][j] = 0;\n                }else{\n                    dl[i][j] = INF;\n                    ds[i][j] = INF;\n                }\n            }\n        }\n\n        REP(i, 200){\n            Gl[i].clear();\n            Gs[i].clear();\n        }\n\n        REP(i, M){\n            int from, to, cost;\n            char c;\n            std::cin >> from >> to >> cost >> c;\n            from--; to--;\n\n            if(c == 'L'){\n                dl[from][to] = std::min(dl[from][to], cost);\n                dl[to][from] = std::min(dl[to][from], cost);\n            }else if(c == 'S'){\n                ds[from][to] = std::min(ds[from][to], cost);\n                ds[to][from] = std::min(ds[to][from], cost);\n            }\n        }\n\n        std::cin >> R;\n        REP(i, R){\n            std::cin >> Z[i];\n            Z[i]--;\n        }\n\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    dl[i][j] = std::min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = std::min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        REP(i, N){\n            REP(j, N){\n                if(dl[i][j] < INF){\n                    Gl[i].push_back({j, dl[i][j]});\n                    Gl[j].push_back({i, dl[i][j]});\n                }\n                if(ds[i][j] < INF){\n                    Gs[i].push_back({j, ds[i][j]});\n                    Gs[j].push_back({i, ds[i][j]});\n                }\n            }\n        }\n\n        std::cout << dijkstra() << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,i,j,k,r,a[1005],ans,map[256][256][2],dp[10005][256];//map:0?路，1水路,dp[i][j]在送到i个?子船在j??的最少花?\nint main()\n{\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\twhile(~scanf(\"%d %d\",&n,&m)&&n&&m)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tmap[i][j][0]=1000000;\n\t\t\t\tmap[i][j][1]=1000000;\n\t\t\t}\n\t\t\tmap[i][i][0]=0;\n\t\t\tmap[i][i][1]=0;\n\t\t}\n\t\tint x,y,t,o;\n\t\tchar s;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%d %d %d %c\",&x,&y,&t,&s);\n\t\t\tif(s=='L')\n\t\t\t\to=0;\n\t\t\tif(s=='S')\n\t\t\t\to=1;\n\t\t\tmap[x][y][o]=min(map[x][y][o],t);\n\t\t\tmap[y][x][o]=map[x][y][o];\n\t\t}\n\t\tfor(k=1;k<=n;k++)\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\t\tmap[i][j][0]=min(map[i][j][0],map[i][k][0]+map[k][j][0]);\n\t\t\t\t\t\tmap[i][j][1]=min(map[i][j][1],map[i][k][1]+map[k][j][1]);\t\n\t\t\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tdp[i][j]=1000000;\n\t\tdp[1][a[1]]=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tif(map[a[0]][i][1]<2147483647&&map[i][a[0]][0]<2147483647)\n\t\t\tdp[0][i]=map[a[0]][i][1]+map[i][a[0]][0];\n\t\t}\n\t\tfor(i=2;i<=r;i++)\n\t\t{\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][k]+map[a[i-1]][a[i]][0]);\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+map[a[i-1]][k][0]+map[k][j][1]+map[j][a[i]][0]);\n\t\t\t}\n\t\t}\n\t\tans=2147483647;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=min(ans,dp[r][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\nusing namespace std;\n\nint N, M, R;\n\nstruct Edge {\n  int x, y, t;\n  char type;  // S or L\n} edges[10000];\n\nint visitOrder[1000];\n\n// dpWater[i][j] is the min time to move from i to j by water.\nint dpWater[200][200];\n\n// dpLand[i][j] is the min time to move from i to j by land.\nint dpLand[200][200];\n\nvoid calculateDp() {\n  memset(dpWater, -1, sizeof(dpWater));\n  for (int i = 0; i < N; ++i) {\n    dpWater[i][i] = 0;\n  }\n  memset(dpLand, -1, sizeof(dpLand));\n  for (int i = 0; i < N; ++i) {\n    dpLand[i][i] = 0;\n  }\n  for (int i = 0; i < M; ++i) {\n    int a = edges[i].x;\n    int b = edges[i].y;\n    if (edges[i].type == 'L') {\n      if (dpLand[a][b] == -1 || dpLand[a][b] > edges[i].t) {\n        dpLand[a][b] = dpLand[b][a] = edges[i].t;\n        //printf(\"dpLand[%d][%d] = %d\\n\", a, b, dpLand[a][b]);\n      }\n    } else {\n      if (dpWater[a][b] == -1 || dpWater[a][b] > edges[i].t) {\n        dpWater[a][b] = dpWater[b][a] = edges[i].t;\n        //printf(\"dpWater[%d][%d] = %d\\n\", a, b, dpWater[a][b]);\n      }\n    }\n  }\n  // Flood.\n  for (int k = 0; k < N; ++k) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i + 1; j < N; ++j) {\n        if (k == i || k == j) {\n          continue;\n        }\n        if (dpLand[i][k] != -1 && dpLand[k][j] != -1) {\n          int t = dpLand[i][k] + dpLand[k][j];\n          if (dpLand[i][j] == -1 || dpLand[i][j] > t) {\n            dpLand[i][j] = dpLand[j][i] = t;\n          }\n        }\n        if (dpWater[i][k] != -1 && dpWater[k][j] != -1) {\n          int t = dpWater[i][k] + dpWater[k][j];\n          if (dpWater[i][j] == -1 || dpWater[i][j] > t) {\n            dpWater[i][j] = dpWater[j][i] = t;\n          }\n        }\n      }\n    }\n  }\n}\n\nint getMinTime() {\n  calculateDp();\n  int dp[2][200];\n  memset(dp, -1, sizeof(dp));\n  dp[0][0] = 0;\n  int *prev = dp[0];\n  int *cur = dp[1];\n  int source = 0;\n  for (int i = 0; i < R; ++i) {\n    int target = visitOrder[i];\n    if (source == target) {\n      continue;\n    }\n    memset(cur, -1, sizeof(dp[0]));\n    for (int targetWater = 0; targetWater < N; ++targetWater) {\n      for (int sourceWater = 0; sourceWater < N; ++sourceWater) {\n        //printf(\"i = %d, source = %d, target = %d, sourceWater = %d, targetWater = %d\\n\",\n        //        i, source, target, sourceWater, targetWater);\n        if (prev[sourceWater] == -1) {\n          continue;\n        }\n        if (prev[sourceWater] == -1 || dpLand[source][sourceWater] == -1 ||\n            dpWater[sourceWater][targetWater] == -1 || dpLand[targetWater][target] == -1) {\n          continue;\n        }\n        int t = prev[sourceWater] + dpLand[source][sourceWater] +\n                dpWater[sourceWater][targetWater] + dpLand[targetWater][target];\n        if (cur[targetWater] == -1 || cur[targetWater] > t) {\n          cur[targetWater] = t;\n          //printf(\"cur[%d] = %d\\n\", targetWater, t);\n        }\n      }\n    }\n    swap(prev, cur);\n    source = target;\n  }\n  int result = -1;\n  for (int i = 0; i < N; ++i) {\n    if (prev[i] != -1 && (result == -1 || result > prev[i])) {\n      result = prev[i];\n    }\n  }\n  return result;\n}\n\nint main() {\n  //freopen(\"MrRitoPostOffice.in\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &M) == 2 && !(N == 0 && M == 0)) {\n    for (int i = 0; i < M; ++i) {\n      char buf[10];\n      scanf(\"%d%d%d%s\", &edges[i].x, &edges[i].y, &edges[i].t, buf);\n      edges[i].x--;\n      edges[i].y--;\n      edges[i].type = buf[0];\n      //printf(\"edge %d, x %d, y %d, t %d, type %c\\n\", i, edges[i].x, edges[i].y, edges[i].t, edges[i].type);\n    }\n    scanf(\"%d\", &R);\n    for (int i = 0; i < R; ++i) {\n      scanf(\"%d\", &visitOrder[i]);\n      visitOrder[i]--;\n    }\n    int result = getMinTime();\n    printf(\"%d\\n\", result);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n#define int long long\nconst int INF = (1LL << 60);\n\nconst int MAX_V = 205;\nconst int MAX_R = 1005;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\tint N, M;\n\twhile(cin >> N >> M, N||M){\n\t\tint gl[MAX_V][MAX_V], gs[MAX_V][MAX_V];\n\t\tinit(gl);\n\t\tinit(gs);\n\t\trep(i,M){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tgl[x][y] = gl[y][x] = min(t, gl[x][y]);\n\t\t\t}else{\n\t\t\t\tgs[x][y] = gs[y][x] = min(t, gs[x][y]);\n\t\t\t}\n\t\t}\n\t\twarshallFloyd(gl,N);\n\t\twarshallFloyd(gs,N);\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> z(R);\n\t\trep(i,R){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tint dp[MAX_R][MAX_V];\n\t\trep(i,MAX_R) rep(j,MAX_V) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\n\t\trep(i,R - 1){\n\t\t\tint cur = z[i];\n\t\t\tint next = z[i + 1];\n\t\t\t//rep(j,N) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][next]);\n\t\t\trep(j,N){\n\t\t\t\trep(k,N){\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\t\t\t//show(dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,R){\n\t\t//\trep(j,N){\n\t\t//\t\tif(dp[i][j] >= INF) cout << \"_\";\n\t\t//\t\telse cout << dp[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint mini = LONG_MAX;\n\t\trep(i,N){\n\t\t\tmini = min(mini, dp[R - 1][i]);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+2][NMAX+2];\n\tll sdp[NMAX+2][NMAX+2];\n\tll dp[NMAX+2][RMAX+2];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=min(ldp[x][y],t);\n\t\t\t\tldp[y][x]=min(ldp[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=min(sdp[x][y],t);\n\t\t\t\tsdp[y][x]=min(sdp[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=R;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tif(j!=k) dp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t\telse dp[j][i]=min(dp[j][i],dp[k][i-1]+ldp[bzi][zi]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') land[x][y] = land[y][x] = t;\n\t\t\telse sea[x][y] = sea[y][x] = t;\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[z[0]][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n){\n\t\tvector<vector<int>> dl(n,vector<int>(n,1e8));\n\t\tvector<vector<int>> ds(n, vector<int>(n,1e8));\n\t\tREP(i, n){\n\t\t\tdl[i][i] = 0;\n\t\t\tds[i][i] = 0;\n\t\t}\n\t\tREP(i, m){\n\t\t\tint u, v, t;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> t >> c;\n\t\t\tu--; v--;\n\t\t\tif (c == 'L'){\n\t\t\t\tdl[u][v] = t;\n\t\t\t\tdl[v][u] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tds[u][v] = t;\n\t\t\t\tds[v][u] = t;\n\t\t\t}\n\t\t}\n\t\tREP(i,n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n){\n\t\t\tdl[j][k] = min(dl[j][k], dl[j][i] + dl[i][k]);\n\t\t\tds[j][k] = min(ds[j][k], ds[j][i] + ds[i][k]);\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> goal(r);\n\t\tREP(i,r){\n\t\t\tcin >> goal[i];\n\t\t\tgoal[i]--;\n\t\t}\n\t\tvector<vector<int>> dp(r, vector<int>(n, 1e8));\n\t\tdp[0][goal[0]] = 0;\n\t\tFOR(i,1, r){\n\t\t\tREP(j, n){\n\t\t\t\tREP(k, n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k],dp[i - 1][j] + dl[goal[i - 1]][j] + ds[j][k] + dl[k][goal[i]]);\n\t\t\t\t\tif (j == k)dp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[goal[i - 1]][goal[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e8;\n\t\tREP(i, n)\n\t\t\tans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct edge { int to; int cost; char type; };\nstruct Postman { int pos; int ship; int cost; };\nclass Compare {\npublic:\n    bool operator () (const Postman &p1, const Postman &p2) {\n      return p1.cost > p2.cost;\n    }\n};\nint V, E, R;\nstd::vector<edge> G[MAX_V];\nint D[MAX_V][MAX_V], PATH[MAX_R];\n\nvoid solve() {\n  for (size_t v = 0; v < V; v++) fill(D[v], D[v] + V, INF);\n  D[PATH[0]][PATH[0]] = 0;\n\n  for (size_t i = 0; i < R - 1; i++) {\n    std::priority_queue<Postman, vector<Postman>, Compare > pque;\n    // std::priority_queue<Postman, vector<Postman>, std::function<bool(const Postman &, const Postman &)> > pque(&cmp);\n    int v0 = PATH[i], vf = PATH[i + 1];\n    // printf(\"%d -> %d\\n\", v0, vf);\n    for (int s = 0; s < V; s++) {\n      Postman p = {v0, s, D[v0][s]};\n      if (D[v0][s] < INF) pque.push(p);\n    }\n    while (!pque.empty()) {\n      Postman p = pque.top(); pque.pop();\n      int v = p.pos, s = p.ship;\n      if(D[v][s] < p.cost) continue;\n      // printf(\"v=%d,s=%d,c=%d\\n\", v, s, p.cost);\n      for (size_t j = 0; j < G[v].size(); j++) {\n        edge e = G[v][j];\n        int u = e.to, cost = e.cost;\n        if (e.type == 'L') {\n          if (D[v][s] + cost < D[u][s]) {\n            D[u][s] = D[v][s] + cost;\n            pque.push((Postman) {u, s, D[u][s]});\n//            printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, s, D[u][s], e.type);\n          }\n        } else if (v == s) {\n          if (D[v][s] + cost < D[u][u]) {\n            D[u][u] = D[v][s] + cost;\n            pque.push((Postman) {u, u, D[u][u]});\n            // printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, u, D[u][u], e.type);\n          }\n        }\n      }\n    }\n    for (size_t v = 0; v < V; v++) {\n      if (v != vf) fill(D[v], D[v] + V, INF);\n    }\n  }\n\n  int vF = PATH[R - 1];\n  int ans = INF;\n  for (size_t s = 0; s < V; s++) {\n    ans = min(ans, D[vF][s]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost;\n      char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      G[v].push_back((edge) {u, cost, c});\n      G[u].push_back((edge) {v, cost, c});\n    }\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n\n    for (size_t v = 0; v < V; v++) G[v].clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate<class T>inline string toString(T x){\n        ostringstream sout; sout<<x; return sout.str();\n}\nconst ll MOD=1e9+7;\nconst int inf=(ll)1e9;\nconst double PI=acos(-1.0);\n\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n    \tint ldp[201][201];\n    \tint sdp[201][201];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tldp[i][j]=inf;\n    \t\t\tsdp[i][j]=inf;\n    \t\t}\n    \t}\n    \tfor(int i=0;i<n;i++){\n    \t\tldp[i][i]=0;\n    \t\tsdp[i][i]=0;\n    \t}\n    \tfor(int i=0;i<m;i++){\n    \t\tint a,b,c;\n    \t\tchar d;\n    \t\tcin>>a>>b>>c>>d;\n    \t\ta--;b--;\n    \t\tif(d=='L'){\n    \t\t\tldp[a][b]=c;\n    \t\t\tldp[b][a]=c;\n    \t\t}else{\n    \t\t\tsdp[a][b]=c;\n    \t\t\tsdp[b][a]=c;\n    \t\t}\n    \t}\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tldp[i][j]=min(ldp[i][k]+ldp[k][j],ldp[i][j]);\n    \t\t\t\tsdp[i][j]=min(sdp[i][k]+sdp[k][j],sdp[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint r;cin>>r;\n    \tint a[1002];\n    \tfor(int i=0;i<r;i++){\n    \t\tcin>>a[i];\n    \t\ta[i]--;\n    \t}\n    \tint dp[1001][201];\n    \tfor(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n    \tdp[0][a[0]]=0;\n    \tfor(int i=0;i<r-1;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tif(dp[i][j]==inf)continue;\n    \t\t\tfor(int k=0;k<n;k++){\n\t    \t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][j]+sdp[j][k]+ldp[k][a[i+1]]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t/*for(int i=0;i<r;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tcerr<<dp[i][j]<<\" \";\n    \t\t}\n    \t\tcerr<<\"\\n\";\n    \t}*/\n    \tint ans=inf;\n    \tfor(int i=0;i<201;i++){\n    \t\tans=min(ans,dp[r-1][i]);\n    \t}\n    \tcout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1<<25;\nint L[200][200];\nint S[200][200];\nint d[2][200];\nint z[1000];\nint main() {\n    int N,M;\n    while(scanf(\"%d %d\",&N,&M),N) {\n        fill((int*)L,(int*)(L+200),INF);\n        fill((int*)S,(int*)(S+200),INF);\n        for(int i=0;i<N;i++) {\n            L[i][i]=S[i][i]=0;\n        }\n        for(int i=0;i<M;i++) {\n            int x,y,t;\n            char s[2];\n            scanf(\"%d %d %d %s\",&x,&y,&t,s);x--;y--;\n            if(s[0]=='L') {\n                L[x][y]=L[y][x]=min(L[x][y],t);\n            }else {\n                S[x][y]=S[y][x]=min(S[x][y],t);\n            }\n        }\n        int R;\n        scanf(\"%d\",&R);\n        for(int i=0;i<R;i++) {\n            scanf(\"%d\",&z[i]);z[i]--;\n        }\n        for(int k=0;k<N;k++) {\n            for(int i=0;i<N;i++) {\n                for(int j=0;j<N;j++) {\n                    L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n                    S[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n                }\n            }\n        }\n        fill((int*)d,(int*)(d+2),INF);\n        d[0][z[0]]=0;\n        for(int i=0;i+1<R;i++) {\n            for(int j=0;j<N;j++) {\n                d[(i+1)&1][j]=INF;\n            }\n            for(int j=0;j<N;j++) {\n                d[(i+1)&1][j]=min(d[(i+1)&1][j],d[i&1][j]+L[z[i]][z[i+1]]);\n                for(int k=0;k<N;k++) {\n                    d[(i+1)&1][j]=min(d[(i+1)&1][j],d[i&1][k]+L[z[i]][k]+S[k][j]+L[j][z[i+1]]);\n                }\n            }\n        }\n        int ans=INF;\n        for(int i=0;i<N;i++) {\n            ans=min(ans,d[(R-1)&1][i]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nstruct Edge {\n    int from;\n    int to;\n    int cost;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const int cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        Graph load(N);\n        Graph sea(N);\n\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;\n            y--;\n            if (sl == 'L') {\n                load.addEdge(x, y, t);\n            } else {\n                sea.addEdge(x, y, t);\n            }\n        }\n        constexpr int INF = (1 << 28);\n        vector<vector<int>> load_dist(N, vector<int>(N, INF));\n        vector<vector<int>> sea_dist(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) {\n            load_dist[i][i] = 0;\n            sea_dist[i][i] = 0;\n        }\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : load.edge[i]) {\n                load_dist[i][e.to] = min(load_dist[i][e.to], e.cost);\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : sea.edge[i]) {\n                sea_dist[i][e.to] = min(sea_dist[i][e.to], e.cost);\n            }\n        }\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    load_dist[i][j] = min(load_dist[i][j], load_dist[i][k] + load_dist[k][j]);\n                    sea_dist[i][j] = min(sea_dist[i][j], sea_dist[i][k] + sea_dist[k][j]);\n                }\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> pos(R + 1, 0);\n        for (int i = 0; i < R; i++) {\n            cin >> pos[i + 1];\n            pos[i + 1]--;\n        }\n        pos[0] = pos[1];\n        vector<vector<int>> dp(R + 1, vector<int>(N, INF));  // i-th query; Ship @j-th town\n        dp[0][pos[0]] = 0;\n\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    if (dp[i][k] == INF) {\n                        continue;\n                    }\n                    const int toship = load_dist[pos[i]][k];\n                    const int seacost = sea_dist[k][j];\n                    const int totown = load_dist[j][pos[i + 1]];\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][k] + toship + seacost + totown);\n                }\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + load_dist[pos[i]][pos[i + 1]]);\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < N; i++) {\n            mini = min(mini, dp[R][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 1000000000000000000LL //2e18\n#define SIZE 210\n\nll dp[10000][SIZE];\n\nbool solve(){\n  int n, m, r;\n  ll dist[2][SIZE][SIZE];\n  \n  scanf(\"%d%d\", &n, &m);\n\n  if(n == 0) return false;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      dist[0][i][j] = dist[1][i][j] = LLINF;\n    \n  for(int i=0;i<n;i++)\n    dist[0][i][i] = dist[1][i][i] = 0;\n  \n  for(int i=0;i<m;i++){\n    int x, y, t, cn;\n    char c;\n\n    scanf(\"%d%d%d %c\", &x, &y, &t, &c);\n    x--; y--;\n    cn = c == 'S';\n\n    dist[cn][x][y] = dist[cn][y][x] = t;\n  }\n\n  \n  for(int p=0;p<2;p++)\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n        for(int j=0;j<n;j++)\n          dist[p][i][j] = min(dist[p][i][j], dist[p][i][k] + dist[p][k][j]);\n  \n  int prev_z, z;\n  \n  scanf(\"%d%d\", &r, &prev_z);\n  prev_z--;\n  \n  for(int i=0;i<=r;i++)\n    for(int j=0;j<n;j++)\n      dp[i][j] = LLINF;\n\n  dp[0][prev_z] = 0;\n  \n  for(int i=0;i<r-1;i++){\n    scanf(\"%d\", &z);\n    z--;\n    \n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n        dp[i+1][j] = min(dp[i+1][j], dp[i][k] + dist[0][prev_z][k] + dist[1][k][j] + dist[0][j][z]);\n      }\n      dp[i+1][j] = min(dp[i+1][j], dp[i][j] + dist[0][prev_z][z]);\n    }\n    \n    prev_z = z;\n  }\n  \n  ll ans = LLINF;\n  \n  for(int i=0;i<n;i++){\n    ans = min(ans, dp[r-1][i]);\n  }\n  \n  printf(\"%lld\\n\", ans);\n  \n  \n  return true;\n}\n\nint main(){\n  while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\n\nint dl[210][210];\nint ds[210][210];\nlong long int dp[1010][210];   \n//定义 dp[i][j] := 已经去了第i个镇子后，船停在第j个镇子里的状态下的最短路。\nint n,m,r; \nint way[1010];\n\nint main()\n{\n\twhile(cin>>n>>m)\n\t{\n\t\tif(n==0&&m==0)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tmemset(dl,INF,sizeof(dl));\n\t\tmemset(ds,INF,sizeof(ds));\n\t\tmemset(dp,INF,sizeof(dp));\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tdl[i][i] = ds[i][i] = 0;\n\t\t}\n\t\tfor(int i = 1;i <= m;i++)\n\t\t{\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl == 'L')\n\t\t\t{\n\t\t\t\tdl[x][y] = min(dl[x][y],t);\n\t\t\t\tdl[y][x] = dl[x][y];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds[x][y] = min(ds[x][y],t);\n\t\t\t\tds[y][x] = ds[x][y];\n\t\t\t}\n\t\t}\n\t\tcin>>r;\n\t\tfor(int i = 1;i <= r;i++)\n\t\t{\n\t\t\tcin>>way[i];\n\t\t}\n\t\tfor(int k = 1;k <= n;k++)\n\t\t{\n\t\t\tfor(int i = 1;i <= n;i++)\n\t\t\t{\n\t\t\t\tfor(int j = 1;j <= n;j++)\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = min(dl[i][j],dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j],ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//第一次出发可以将船停在任意处再回来 \n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tdp[1][i] = ds[way[1]][i] + dl[way[1]][i];\n\t\t}\n\t\tfor(int i = 2;i <= r;i++)\n\t\t{\n\t\t\tfor(int j = 1;j <= n;j++)\n\t\t\t{   //走旱路 \n\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][j]+dl[way[i-1]][way[i]]);   \n\t\t\t\tfor(int k = 1;k <= n;k++)    //现在停船点 \n\t\t\t\t{//走水路 \n\t\t\t\t\tdp[i][k] = min(dp[i][k],dp[i-1][j]+dl[way[i-1]][j]+ds[j][k]+dl[k][way[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = INF;\n\t\tfor(int i = 1;i <= n;i++)\n\t\t{\n\t\t\tans = min(ans,dp[r][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<24;\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\n\nstruct Edge {\n  int to, cost;\n};\n\nint N, M;\nint G[2][MAX_N][MAX_N];\nint R;\nint Z[MAX_R];\nvector<Edge> E[2][MAX_N];\n\nstruct State {\n  int p, sp, t, c;\n  bool operator < (const State &s) const {\n    if(c != s.c) return c > s.c;\n    if(t != s.t) return t < s.t;\n    if(p != s.p) return p > s.p;\n    if(sp != s.sp) return sp > s.sp;\n  }\n};\nint cost[MAX_N][MAX_N][MAX_R];\n\nint solve() {\n  State s;\n  s.p = s.sp = Z[0];\n  s.c = s.t = 0;\n\n  priority_queue<State> que;\n  que.push(s);\n\n  for(int i = 0; i < N; ++i)\n    for(int j = 0; j < N; ++j)\n      fill(cost[i][j], cost[i][j]+R, INF);\n\n  //  cost[s.p][s.sp][s.t] = s.c;\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(cost[s.p][s.sp][s.t] != INF) continue;\n    cost[s.p][s.sp][s.t] = s.c;\n    if(Z[s.t] == s.p) {\n      ++s.t;\n      if(s.t == R) {\n\treturn s.c;\n      }\n    }\n\n    State t;\n    for(int i = 0; i < E[0][s.p].size(); ++i) {\n      t.p = E[0][s.p][i].to;\n      t.sp = s.sp;\n      t.c = s.c + E[0][s.p][i].cost;\n      t.t = s.t;\n      if(cost[t.p][t.sp][t.t] == INF) {\n\tque.push(t);\n      }\n    }\n    if(s.sp == s.p) {\n      for(int i = 0; i < E[1][s.p].size(); ++i) {\n\tt.p = t.sp = E[1][s.p][i].to;\n\tt.c = s.c + E[1][s.p][i].cost;\n\tt.t = s.t;\n\tif(cost[t.p][t.sp][t.t] == INF) {\n\t  que.push(t);\n\t}\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> N >> M && (N || M)) {\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < 2; ++j) {\n\tfill(G[j][i], G[j][i]+N, INF);\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      int a, b, t, ind;\n      char c;\n      cin >> a >> b >> t >> c;\n      --a; --b;\n      ind = (c == 'L') ? 0 : 1;\n      G[ind][a][b] = min(G[ind][a][b], t);\n      G[ind][b][a] = min(G[ind][b][a], t);\n    }\n\n    for(int i = 0; i < 2; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tE[i][j].clear();\n      }\n    }\n\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tE[k][i].push_back((Edge){i, 0});\n\tfor(int j = 0; j < N; ++j) {\n\t  if(G[k][i][j] != INF)\n\t    E[k][i].push_back((Edge){j, G[k][i][j]});\n\t}\n      }\n    }\n\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      cin >> Z[i];\n      --Z[i];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nlong long int dp[10001][200];\n\nint main() {\n\t/*int N; cin >> N;\n\twhile (N--) {\n\t\tstring ast, bst; cin >> ast >> bst;\n\t\treverse(ast.begin(), ast.end());\n\t\tfor (char c : ast) {\n\t\t\tswitch (c) {\n\t\t\tcase 'A': {\n\t\t\t\treverse(bst.begin(), bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'C': {\n\t\t\t\trotate(bst.begin(), bst.begin() + 1, bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'J':{\n\t\t\t\t\t\t  rotate(bst.begin(), bst.end() - 1, bst.end());\n\t\t\t\t\t  }\n\t\t\t\t\t break;\n\t\t\tcase 'E': {\n\t\t\t\tbst = string(bst.begin() + (bst.size() + 1) / 2, bst.end()) + string(bst.begin() + bst.size() / 2, bst.begin()+(bst.size()+1)/2) + string(bst.begin(), bst.begin() + bst.size() / 2);\n\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'M': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '9')return '0';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c + 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'P': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '0')return '9';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c - 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\t\n\t\t\n\t\tcout << bst << endl;\n\t}*/\n\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < 10001; ++i) {\n\t\t\tfor (int j = 0; j < 200; ++j) {\n\t\t\t\tdp[i][j] = 999999999999;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>stimes(N, vector<long long int>(N, 999999999999)),ltimes(N, vector<long long int>(N,999999999999));\n\n\t\t\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; long long int  t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--; y--;\n\t\t\tif (c == 'L') {\n\t\t\t\tltimes[x][y] = min(ltimes[x][y], t);\n\t\t\t\tltimes[y][x] = min(ltimes[y][x], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstimes[x][y] = min(stimes[x][y], t);\n\t\t\t\tstimes[y][x] = min(stimes[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tltimes[i][i] = 0;\n\t\t\tstimes[i][i] = 0;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tltimes[i][j] = min(ltimes[i][j], ltimes[i][k] + ltimes[k][j]);\n\t\t\t\t\tstimes[i][j] = min(stimes[i][j], stimes[i][k] + stimes[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R; cin >> R;\n\t\tvector<int>vs(R);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tcin >> vs[i];\n\t\t\tvs[i]--;\n\t\t}\n\t\tdp[vs[0]][0] = 0;\n\t\tfor (int time = 0; time< R-1; ++time) {\n\t\t\tfor (int f= 0; f < N; ++f) {\n\t\t\t\tfor (int t = 0; t < N; ++t) {\n\t\t\t\t\tdp[time + 1][t] = min(dp[time + 1][t], dp[time][f] + ltimes[vs[time]][f] + stimes[f][t] + ltimes[t][vs[time + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 999999999999;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\n\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint q[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) {\n  for (int k = 1; k <= n; ++k) {\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while (scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n    memset(q, 0x3f, sizeof(q));\n\n    while (m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if (tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n    b[0] = 1;\n    for (int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (s[i][j] < INF && l[i][j] < INF) {\n          q[i][j] = s[i][j] + l[i][j];\n        }\n      }\n    }\n\n    d[0][1] = 0;\n\n    for (int i = 1; i <= r; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (l[j][b[i]] >= INF) continue;\n        for (int k = 1; k <= n; ++k) {\n          if (d[i - 1][k] >= INF) continue;\n          if (j == k) {\n            if (l[b[i - 1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][b[i]]);\n            }\n          } else {\n            if (l[b[i - 1]][k] < INF && s[k][j] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nstruct state {\n    int v, c, p;\n};\n\nbool operator<(const state &a, const state &b) {\n    return a.c > b.c;\n}\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n, m, r;\n    while(cin >> n >> m, n | m) {\n        int d[n][n][2];\n        rep(i, n)rep(j, n) d[i][j][0] = d[i][j][1] = INF;\n\n        map<int, int> sea;\n        int cnt = 0;\n        rep(i, m) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl; x--, y--;\n            if (t < d[x][y][sl == 'S']) d[x][y][sl == 'S'] = d[y][x][sl == 'S'] = t;\n            if (sl == 'S') {\n                if (!sea.count(x)) sea[x] = cnt++;\n                if (!sea.count(y)) sea[y] = cnt++;\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(i, r) cin >> z[i], z[i]--;\n\n        int dp[n][sea.size()];\n        rep(i, n)rep(j, sea.size()) dp[i][j] = INF;\n        dp[z[0]][sea[z[0]]] = 0;\n\n        bool visited[n][sea.size()];\n        priority_queue<state> q;\n        repl(i, 1, r) {\n            memset(visited, 0, sizeof(visited));\n            rep(j, sea.size()) {\n                if (dp[z[i - 1]][j] < INF) q.push(state{z[i - 1], dp[z[i - 1]][j], j});\n            }\n            rep(i, n)rep(j, sea.size()) dp[i][j] = INF;\n\n            while(!q.empty()) {\n                state s = q.top(); q.pop();\n\n                if (visited[s.v][s.p]) continue;\n                else visited[s.v][s.p] = true;\n\n                dp[s.v][s.p] = s.c;\n                if (s.v == z[i]) continue;\n\n                rep(i, n) {\n                    if (d[s.v][i][0] < INF && !visited[i][s.p]) {\n                        q.push(state{i, s.c + d[s.v][i][0], s.p});\n                    }\n                    if (d[s.v][i][1] < INF && sea[s.v] == s.p && !visited[i][sea[i]]) {\n                        q.push(state{i, s.c + d[s.v][i][1], sea[i]});\n                    }\n                }\n            }\n        }\n\n        int mini = INF;\n        rep(i ,sea.size()) minch(mini, dp[z[r - 1]][i]);\n        cout << mini << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\nconst int INF=100000000;\n\n\nclass Node{\npublic:\n\tint now_mission,ship,sum;\n\tNode(int now_mission,int ship,int sum):now_mission(now_mission),ship(ship),sum(sum){};\n};\n\nbool operator < (Node a,Node b){\n\treturn a.sum>b.sum;\n}\n\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tvector<vector<int> > dist_ground(N,vector<int>(N,INF));\n\t\tvector<vector<int> > dist_sea(N,vector<int>(N,INF));\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y,t; char c;\n\t\t\tcin>>x>>y>>t>>c;\n\t\t\tx--;y--;\n\t\t\tif(c=='L'){\n\t\t\t\tdist_ground[x][y]=min(dist_ground[x][y],t);\n\t\t\t\tdist_ground[y][x]=min(dist_ground[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdist_sea[x][y]=min(dist_sea[x][y],t);\n\t\t\t\tdist_sea[y][x]=min(dist_sea[y][x],t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdist_sea[i][i]=dist_ground[i][i]=0;\n\t\t}\n\t\tint R;cin>>R;\n\t\tvector<int> mission(R);\n\t\tfor(int i=0;i<R;i++){cin>>mission[i];mission[i]--;}\n\n\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tdist_sea[i][j]=min(dist_sea[i][j],dist_sea[i][k]+dist_sea[k][j]);\n\t\t\t\t\tdist_ground[i][j]=min(dist_ground[i][j],dist_ground[i][k]+dist_ground[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<int> > memo(R,vector<int>(N,INF));\n\t\tmemo[0][mission[0]]=0;\n\t\tfor(int i=1;i<R;i++){\n\t\t\tint area=mission[i-1];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\tmemo[i][j]=min(memo[i][j],\n\t\t\t\t\t\tmemo[i-1][k]+dist_ground[area][k]+dist_sea[k][j]+dist_ground[j][mission[i]]\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=INF;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tans=min(ans,memo[R-1][i]);\n\t\t}\n\t\tcout<<ans<<endl;;\n\n\n/*\t\tpriority_queue<Node> que;\n\t\tque.push(Node(0,mission[0],0));\n\n\n\n\t\twhile(!que.empty()){\n\t\t\tNode info=que.top(); que.pop();\n\t\t\tif(info.sum>=memo[info.now_mission][info.ship]) continue;\n//\t\t\tcout<<\"now \"<<info.now_mission<<\" \"<<info.ship<<\" \"<<info.sum<<endl;\n\t\t\tmemo[info.now_mission][info.ship]=info.sum;\n\n\t\t\tif(info.now_mission==R-1){cout<<info.sum<<endl;break;}\n\t\t\tint target=mission[info.now_mission+1];\n\t\t\t\n\t\t\tint now_area=mission[info.now_mission];\n\t\t\tque.push(Node(info.now_mission+1,info.ship,info.sum+dist_ground[now_area][target]));\n\n\t\t\tfor(int relay=0;relay<N;relay++){\n\t\t\t\tint next_cost=dist_ground[now_area][info.ship]+dist_sea[info.ship][relay]+dist_ground[relay][target];\n\t\t\t\tif(next_cost<INF)\n\t\t\t\t\tque.push(Node(info.now_mission+1,relay,info.sum+next_cost));\n\t\t\t}\n\t\t}*/\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int x=0;x<2;x++){\n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[x][i][j]=min(d[x][i][j],d[x][i][k]+d[x][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",*min_element(dp[r-1].begin(),dp[r-1].end()));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define INF (1ll<<58)\n\n\t\nint main(){\n\tlong long n,m;\n\twhile(cin >> n >> m && n){\n\t\tlong long land[200][200] , ship[200][200] ;\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tlong long a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse      ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tlong long r; cin >> r;\n\t\tlong long R[1000];\t\n\t\trep(i,r)cin >> R[i] , R[i]--;\n\t\t\n\t\tlong long dp[2][200];\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tlong long newCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[(bit+1)%2][cur] = min(dp[(bit+1)%2][cur],dp[bit%2][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,200)dp[bit%2][j] = INF;\n\t\t}\n\t\tlong long ret = INF;\n\t\trep(i,n){\n\t\t\tret = min(dp[(r-1)%2][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+2][NMAX+2];\n\tll sdp[NMAX+2][NMAX+2];\n\tll dp[NMAX+2][RMAX+2];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=min(ldp[x][y],t);\n\t\t\t\tldp[y][x]=min(ldp[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=min(sdp[x][y],t);\n\t\t\t\tsdp[y][x]=min(sdp[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tdp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();//the number of cities\n\t\t\tint m=sc.nextInt();//the number of paths\n\t\t\tif(n==0&&m==0)break;\n\t\t\tint INF=Integer.MAX_VALUE/4;\n\t\t\tint[][] ldis=new int[n][n];\n\t\t\tint[][] sdis=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tldis[i][j]=INF;\n\t\t\t\t\tsdis[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"L\")){\n\t\t\t\t\tldis[x][y]=t;\n\t\t\t\t\tldis[y][x]=t;\n\t\t\t\t}else if(str.equals(\"S\")){\n\t\t\t\t\tsdis[x][y]=t;\n\t\t\t\t\tsdis[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tldis[i][j]=Math.min(ldis[i][j],ldis[i][k]+ldis[k][j]);\n\t\t\t\t\t\tsdis[i][j]=Math.min(sdis[i][j],sdis[i][k]+sdis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=sc.nextInt();\n\t\t\tint[] destination=new int[r];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tdestination[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tint[][] dp=new int[r][n];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][destination[0]]=0;//dp[i][j]???i???????????§?¨?????????????j????????????????????´???????????????\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==j){\n\t\t\t\t\t\t\tdp[i][j]=\n\t\t\t\t\t\t\t\t\tMath.min(dp[i][j],\n\t\t\t\t\t\t\t\t\t\t\tldis[destination[i]][destination[i-1]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+dp[i-1][j]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][j]+sdis[j][k]+ldis[k][destination[i-1]]+dp[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min=9999999;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmin=Math.min(dp[r-1][i],min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst long long int INF=1e16;\n\nvector<vector<long long int>> get_dis(vector<map<int,long long int>> &edge){\n  vector<vector<long long int>> d(edge.size(),vector<long long int>(edge.size(),INF));\n  for(int i=0;i<edge.size();i++){\n    for(int j=0;j<edge.size();j++){\n      if(edge[i].count(j)){\n        d[i][j]=edge[i][j];\n      }\n    }\n\n  }\n  for(int k=0;k<edge.size();k++){\n    for(int i=0;i<edge.size();i++){\n      for(int j=0;j<edge.size();j++){\n\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n      }\n    }\n  }\n  return d;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    vector<map<int,long long int>> land_edge(n);\n    vector<map<int,long long int>> sea_edge(n);\n    for(int i=0;i<n;i++){\n      land_edge[i][i]=0;\n      sea_edge[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;\n      long long int t;\n      char sl;\n      cin>>x>>y>>t;\n      x--,y--;\n      cin>>sl;\n      if(sl=='L'){\n\tif(land_edge[x].count(y)){\n\t  land_edge[x][y]=min(land_edge[x][y],t);\n\t  land_edge[y][x]=min(land_edge[y][x],t);\n\t}\n\telse{\n\t  land_edge[x][y]=t;\n\t  land_edge[y][x]=t;\n\t}\n      }\n      else{\n\tif(sea_edge[x].count(y)){\n\t  sea_edge[x][y]=min(sea_edge[x][y],t);\n\t  sea_edge[y][x]=min(sea_edge[y][x],t);\n\t}\n\telse{\n\t  sea_edge[x][y]=t;\n\t  sea_edge[y][x]=t;\n\t}\n      }\n\n    }\n    auto land_d=get_dis(land_edge);\n    auto sea_d=get_dis(sea_edge);\n\n    \n    int r;\n    cin>>r;\n    vector<vector<long long int>> dp(r,vector<long long int>(n,INF));\n    int from,to;\n    cin>>from;\n    from--;\n    dp[0][from]=0;\n    for(int task=0;task<r-1;task++){\n      cin>>to;\n      to--;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  if(i==j) dp[task+1][j]=min(dp[task+1][j],dp[task][i]+land_d[i][to]);\n\t  else dp[task+1][j]=min(dp[task+1][j],dp[task][i]+land_d[from][i]+sea_d[i][j]+land_d[j][to]);\n\t}\n      }\n\n      from=to;\n    }\n    cout<<*min_element(dp[r-1].begin(),dp[r-1].end())<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#define MAXN 1005\n#define INF 100000000\nusing namespace std;\nint land[MAXN][MAXN],water[MAXN][MAXN],dp[MAXN][MAXN],route[MAXN];\nint ans;\nint main()\n{\n    int V,E,x,y,z,n;\n    char c;\n    scanf(\"%d %d\",&V,&E);\n    while(V!=0||E!=0)\n    {\n    for(int i=1;i<=V;i++)\n        for(int j=1;j<=V;j++)\n        {\n            land[i][j]=INF;\n            water[i][j]=INF;\n        }\n    for(int i=1;i<=V;i++)\n    {\n        land[i][i]=0;\n        water[i][i]=0;\n    }\n    for(int i=0;i<E;i++)\n    {\n        cin>>x>>y>>z>>c;\n        if(c=='L')\n        {\n            land[x][y]=min(land[x][y],z);\n            land[y][x]=land[x][y];\n        }\n        if(c=='S')\n        {\n            water[x][y]=min(water[x][y],z);\n            water[y][x]=water[x][y];\n        }\n    }\n    for(int k=1;k<=V;k++)\n      for(int i=1;i<=V;i++)\n        for(int j=1;j<=V;j++)\n    {\n        land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        water[i][j]=min(water[i][j],water[i][k]+water[k][j]);\n    }\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&route[i]);\n    route[0]=1;\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=V;j++)\n        dp[i][j]=INF;\n    for(int i=1;i<=V;i++)\n    {\n        dp[1][i]=water[1][i]+land[i][route[1]];\n    }\n   for(int i=2;i<=n;i++)\n     for(int j=1;j<=V;j++)\n        for(int k=1;k<=V;k++)\n          if(k!=j) dp[i][j]=min(dp[i][j],dp[i-1][k]+land[route[i-1]][k]+water[k][j]+land[j][route[i]]);\n                else dp[i][j]=min(dp[i][j],dp[i-1][k]+land[route[i-1]][route[i]]);\n    ans=INF;\n    for(int i=1;i<=V;i++)\n        ans=min(ans,dp[n][i]);\n    printf(\"%d\\n\",ans);\n    scanf(\"%d %d\",&V,&E);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\n#define inf 10000000\n\nint N,M;\nint disL[200][200];//隣接行列の重みバージョン陸\nint disS[200][200];//海\nint r ;\nint z[1000];\nint disP[1000][100]={};\n\n/*町番号は0からN-1とする（入力は1からN）*/\n\n/*町Z(num)からZr（終点）への最短時間（船が町shipにある状況で）を返す\nz  宅配順列の何番目か0->(r-1)\nship 船のある町番号0->N-1\n*/\nint recur(int num,int ship){\n  int land,sea=inf,sm=ship,sp,i;\n\n  if(disP[num][ship]!=0)return disP[num][ship];\n  if(num>=r-1)return 0;\n  land=disL[z[num]][z[num+1]]+recur(num+1,ship);\n  \n  for(i=0;i<N;i++){\n    sp=disL[ z[num] ][ship] + disS[ship][i] + disL[i][ z[num+1] ] + recur(num+1,i);\n    if(sea>sp){\n      sea=sp;\n    }\n  }\n  disP[num][ship]=min(land,sea);\n  return disP[num][ship];\n}\n\n\nint main(){\n  int i,j,k,x,y,t;\n  char ch;\n  while(true){\n\n    for(i=0;i<1000;i++)\n      for(j=0;j<100;j++)\n\tdisP[i][j]=0;\n\n    /*入力処理*/\n    cin >>N>>M;\n    if(N==0 && M==0)break;\n    for(i=0;i<M;i++){\n      for(j=0;j<M;j++){\n\tif(i!=j){\n\t  disL[i][j]=inf;\n\t  disS[i][j]=inf;\n\t}\n\telse {\n\t  disL[i][i]=0;\n\t  disS[i][i]=0;\n\t}\n      }\n    }\n    \n\n    /*陸路海路それぞれの最小値をセット*/\n    for(i=0;i<M;i++){\n      cin >>x>>y>>t>>ch;\n      if(ch=='L'){\n\tdisL[x-1][y-1]=min(disL[x-1][y-1],t);\n\tdisL[y-1][x-1]=min(disL[y-1][x-1],t);\n      }\n      else if(ch=='S'){\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n      }\n    }\n\n    priority_queue<int> p_que;\n    /*陸、海それぞれで各町同士の最短経路を出す*/  \n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tfor(k=0;k<N;k++){\n\t  disL[j][k]=min(disL[j][k],disL[j][i]+disL[i][k]);\n\t  disS[j][k]=min(disS[j][k],disS[j][i]+disS[i][k]);\n\t}\n      }\n    }\n    cin >> r;\n    for(i=0;i<r;i++){\n      cin >> j;\n      z[i]=j-1;//町番号は0からN-1にする\n    }\n    cout << recur(0,z[0]) <<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define size_of(a) (int)(a).size()\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nstruct Edge {\n\tint to;\n\tlint cst;\n\tchar S;\n\tint f, r;\n\t\n\tEdge(int to_, lint cst_, char S_, int f_ = 0, int r_ = 0)\n\t: to(to_), cst(cst_), S(S_), f(f_), r(r_) {}\n\tbool operator > (const Edge& a) const { return cst > a.cst; } \n};\n\nint N, M, R, z[1010];\nvector< vector< Edge > > edges;\n\nlint cst[222][1010][222];\n\nvoid solve() {\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > que;\n\tque.push(Edge(z[0], 0, ' ', z[0], 0));\n\t\n\tfor_(i,0,N) for_(j,0,R) for_(k,0,N) cst[i][j][k] = 1LL << 60;\n\tcst[z[0]][0][z[0]] = 0;\n\t\n\twhile (!que.empty()) {\n\t\tEdge e = que.top(); que.pop();\n\t\t\n\t\tint v = e.to, f = e.f, r = e.r;\n\t\tlint c = e.cst;\n\t\t\n\t\tif (r == R-1) {\n\t\t\tcout << c << endl;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (cst[v][r][f] < c) continue;\n\t\t\n\t\tint e_size = size_of(edges[v]);\n\t\t\n\t\tfor_(i,0,e_size) {\n\t\t\tEdge ei = edges[v][i];\n\t\t\tbool fs = ei.S == 'S';\n\t\t\t\n\t\t\tif (fs && f != v) continue;\n\t\t\t\n\t\t\tint nv = ei.to;\n\t\t\tint nf = fs ? ei.to : f;\n\t\t\tint nr = (ei.to == z[r + 1]) ? r + 1 : r;\n\t\t\t\n\t\t\tif (cst[nv][nr][nf] > c + ei.cst) {\n\t\t\t\tcst[nv][nr][nf] = c + ei.cst;\n\t\t\t\tque.push(Edge(nv, c + ei.cst, ' ', nf, nr));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\n\t\tedges.assign(N, vector< Edge >());\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t--x; --y;\n\t\t\tedges[x].push_back(Edge(y, t, s));\n\t\t\tedges[y].push_back(Edge(x, t, s));\n\t\t}\n\t\t\n\t\tcin >> R;\n\t\t\n\t\tfor_(i,0,R) {\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n \nusing namespace std;\n \ntypedef long long LINT;\ntypedef vector<int> VI;\ntypedef vector<LINT> VL;\ntypedef vector<VL> VVL;\n \nconst LINT INF = 1LL << 50;\n \nint main() {\n    int n, m;\n     \n    while ( cin >> n >> m, n | m ) {\n        VVL L( n, VL( n, INF ) ),\n            S( n, VL( n, INF ) );\n         \n        for ( int i = 0; i < m; ++i ) {\n            int x, y, t;\n            char s;\n            cin >> x >> y >> t >> s;\n             \n            switch ( s ) {\n            case 'L':\n                L[x - 1][y - 1] = L[y - 1][x - 1] = min<LINT>( t, L[x - 1][y - 1] );\n                break;\n            case 'S':\n                S[x - 1][y - 1] = S[y - 1][x - 1] = min<LINT>( t, S[x - 1][y - 1] );\n                break;\n            }\n        }\n         \n        int r;\n        cin >> r;\n         \n        VI Z( r, 0 );\n         \n        for ( int i = 0; i < r; ++i ) {\n            cin >> Z[i];\n            --Z[i];\n        }\n        // end of input\n \n        for ( int i = 0; i < n; ++i ) {\n            L[i][i] = S[i][i] = 0;\n        }\n         \n        for ( int k = 0; k < n; ++k ) {\n            for ( int i = 0; i < n; ++i ) {\n                for ( int j = 0; j < n; ++j ) {\n                    L[i][j] = min( L[i][j], L[i][k] + L[k][j] );\n                    S[i][j] = min( S[i][j], S[i][k] + S[k][j] );\n                }\n            }\n        }\n \n        VVL d( r, VL( n, INF ) );\n        d[0][Z[0]] = 0;\n        for ( int i = 0; i + 1 < r; ++i ) {\n            int from = Z[i], to = Z[i + 1];\n            d[i + 1][to] = min( d[i + 1][to], d[i][from] + S[from][to] );\n            for ( int j = 0; j < n; ++j ) {\n                d[i + 1][to] = min( d[i + 1][to], d[i][j] + L[from][j] + S[j][to] );\n                d[i + 1][j] = min( d[i + 1][j], d[i][j] + L[from][to] );\n                d[i + 1][j] = min( d[i + 1][j], d[i][from] + S[from][j] + L[j][to] );\n            }\n        }\n \n        LINT ans = INF;\n        for ( int i = 0; i < n; ++i ) {\n            ans = min( ans, d[r - 1][i] );\n        }\n \n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nstatic int N, M, R;\n\n\n\nstatic int dist_l[201][201];\nstatic int dist_s[201][201];\n\nstatic int dest[1001];\n\n\n\nstatic void flood()\n{\n\tint i, j, k;\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n\nstatic int dp[1001][201];\n\nstatic void solve()\n{\n\tflood();\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tdp[0][1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k!=j) {\n\t\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dist_l[start][end]!=INT_MAX && dp[i][k] > dp[i-1][k]+dist_l[start][end])\n\t\t\t\t\t\t\tdp[i][k] = dp[i-1][k]+dist_l[start][end];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nstatic void solve1()\n{\n\tflood();\n\n\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tdp[0][1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (dp[i][j] > dp[i-1][j]+total_land_cost)\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tdist_l[i][i] = dist_s[i][i] = 0;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tif (dist_s[x][y] > t)\n\t\t\t\t\tdist_s[x][y] = dist_s[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_l[x][y] > t)\n\t\t\t\t\tdist_l[x][y] = dist_l[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        const int inf = 3 * ten(8);\n        int l[256][256], s[256][256];\n        rep(i, n) rep(j, n)\n            l[i][j] = s[i][j] = i == j ? 0 : inf;\n        while (m--)\n        {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if (sl == 'L')\n                l[x][y] = l[y][x] = t;\n            else\n                s[x][y] = s[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(l[i][j], l[i][k] + l[k][j]);\n            chmin(s[i][j], s[i][k] + s[k][j]);\n        }\n\n        int r, z[1024];\n        cin >> r;\n        input(z, r);\n        rep(i, r)\n            --z[i];\n\n        int dp[1024][256];\n        rep(i, r) rep(j, n)\n            dp[i][j] = inf;\n        dp[0][z[0]] = 0;\n        rep(i, r - 1) rep(j, n) rep(k, n)\n            chmin(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n        int res = *min_element(dp[r - 1], dp[r - 1] + n);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <climits>\n \n#include <cstdio>\n  \nusing namespace std;\n \n#define REP(var, count) for(int var=0; var<count; var++)\n \nconst int IPPAI = 214748364;\n \nint umi[210][210];\nint riku[210][210];\n \nint cmpl[1010][210]; //[??????????????§??????][????????????]\nbool used[1010][210];\n \nbool solve(void) {\n    int N, M;\n    \n    cin >> N >> M;\n    if ( N == 0 ) { return false; }\n    \n    REP(i, 210) REP(j, 210) {\n        int a = (i==j) ? 0 : IPPAI;\n        umi[i][j] = a;\n        riku[i][j] = a;\n    }\n    \n    REP(i, M) {\n        int x, y, l;\n        char ty;\n        cin >> x >> y >> l >> ty;\n        \n        if (ty == 'L') {\n            riku[x][y] = l;\n            riku[y][x] = l;\n        } else {\n            umi[x][y] = l;\n            umi[y][x] = l;\n        }\n    }\n    \n    // ???\n    for(int k=1; k<=N; k++) {\n        for(int i=1; i<=N; i++) {\n            for(int j=1; j<=N; j++) {\n                umi[i][j] = std::min(umi[i][j], umi[i][k] + umi[k][j]);\n                riku[i][j] = std::min(riku[i][j], riku[i][k] + riku[k][j]);\n            }\n        }\n    }\n \n    int R;\n    int list[1010];\n    cin >> R;\n    REP(i, R) { cin >> list[i]; }\n    \n    for(int i=1; i<=N; i++) {\n    \tcmpl[0][i] = IPPAI;\n    }\n    // ?§???????????????????\n    cmpl[0][ list[0] ] = 0;\n    \n    for(int f=1; f<R; f++) {\n    \tfor(int i=1; i<=N; i++) {\n    \t\n    \t\tint prevpos = list[f-1];\n    \t\tint nextpos = list[f];\n    \t\t\n       \t\t// ??????????????§?§??????????\n    \t\tint rikuro = IPPAI;\n    \t\tif ( cmpl[f-1][i] != IPPAI && riku[prevpos][nextpos] != IPPAI ) {\n    \t\t\trikuro = cmpl[f-1][i] + riku[prevpos][nextpos];\n    \t\t}\n    \t\t\n    \t\t// ???????§?????????????????§??????????\n    \t\tint kairo = IPPAI;\n    \t\t// ?????????????????????\n    \t\tfor(int pf=1; pf<=N; pf++) {\n    \t\t\tif ( cmpl[f-1][pf] == IPPAI ) { continue; }\n    \t\t\t\n    \t\t\tint cost = 0;\n    \t\t\t// ????????§????????§???????????????\n    \t\t\tif ( riku[prevpos][pf] == IPPAI ) { continue; }\n    \t\t\tcost += riku[prevpos][pf];\n    \t\t\t\n    \t\t\t// ????????§?§??????????\n    \t\t\tif ( umi[pf][i] == IPPAI ) { continue; }\n    \t\t\tcost += umi[pf][i];\n    \t\t\t\n    \t\t\t// ?????????????????°?????§????????§?§??????????\n    \t\t\tif ( riku[i][nextpos] == IPPAI ) { continue; }\n    \t\t\tcost += riku[i][nextpos];\n    \t\t\t\n    \t\t\tkairo = std::min(kairo, cmpl[f-1][pf] + cost);\n    \t\t}\n    \t\t\n    \t\tcmpl[f][i] = std::min(rikuro, kairo);\n    \t}\n    }\n    \n    int ret = IPPAI;\n    for(int i=1; i<=N; i++) {\n        ret = std::min(ret, cmpl[R-1][i]);\n    }\n     \n    cout << ret << endl;\n    \n    return true;\n}\n \nint main(void) {\n    while( solve() ) {}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\n\n#define fst first;\n#define snd second;\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back\n#define ALL(x) (x).begin(), (x).end()\n#define RANGE(x, y, w, h) (0 <= (x) && 0 <= (y) && (x) < (w) && (y) < (h))\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = (init); i < (n); i++)\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[] = {1,0,-1,0}, DY[] = {0,-1,0,1};\n\nint N, M;\nint R;\nVI rs;\n\nVVI seas;\nVVI loads;\n\nint solve() {\n    // ????????????\n    rep(k, N) {\n        rep(i, N) {\n            rep(j, N) {\n                if (i == j || i ==k || k == j) continue;\n                seas[i][j] = min(seas[i][j], seas[i][k] + seas[k][j]);\n                loads[i][j] = min(loads[i][j], loads[i][k] + loads[k][j]);\n            }\n        }\n    }\n    // 8,000,000\n\n//    cout << \"????????????ok!\" << endl;\n\n    // dp[ri][where]\n    VVI dp(R, VI(N, INF));\n    dp[0][rs[0]] = 0;\n\n    rep(ri, R - 1) {    // 1000\n        rep(w, N) {     // 200\n            if (dp[ri][w] == INF) continue;\n\n            int s = rs[ri];\n            int g = rs[ri + 1];\n\n            dp[ri + 1][w] = min(dp[ri + 1][w], dp[ri][w] + loads[s][g]);\n\n            int cost = dp[ri][w] + loads[s][w];\n            rep(w2, N) {    // 200\n                int cost2 = cost;\n                cost2 += seas[w][w2];\n                cost2 += loads[w2][g];\n                dp[ri + 1][w2] = min(dp[ri + 1][w2], cost2);\n            }\n        }\n    }\n    // 40,000,000\n\n\n    return *min_element(ALL(dp[R - 1]));\n}\n\nint main(void) {\n    cin.tie( 0 );\n    ios::sync_with_stdio( false );\n\n    while (cin >> N >> M, N) {\n        seas = VVI(N, VI(N, INF));\n        loads = VVI(N, VI(N, INF));\n        rep(i, N) rep(j, N) {\n            if (i != j) continue;\n            seas[i][j] = 0;\n            loads[i][j] = 0;\n        }\n\n        rep(i, M) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n\n            bool is_sea = sl == 'S';\n\n            (is_sea ? seas : loads)[x][y] = t;\n            (is_sea ? seas : loads)[y][x] = t;\n        }\n\n        cin >> R;\n        rs = VI(R);\n        for (auto &r : rs) {\n            cin >> r;\n            --r;\n        }\n\n        cout << solve() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 220\n#define MAX_R 1020\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q2;\nvector<tuple<long long, long long, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N], DIST2[MAX_N];\nlong long COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nint PATH[MAX_N][MAX_N][MAX_N];\nlong long DP[MAX_R][MAX_N];\nlong long cnt;\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n\tcnt = 0;\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = min(PATH[i][j][k], DIST[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tlong long start = travel[i];\n\t\t\t\tlong long goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  int n, m;\n  long long int INF = 1e14;\n  while(cin >> n >> m, n){\n    vector< vector<int> > L(n, vector<int>(n, INF)), S = L;\n    int x, y, t;\n    char s;\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> t >> s;\n      --x;--y;\n      if(s == 'L'){\n        L[x][y] = t;\n        L[y][x] = t;\n      }else{\n        S[x][y] = t;\n        S[y][x] = t;\n      }\n    }\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        L[i][i] = 0;\n        S[i][i] = 0;\n        for(int j = 0; j < n; ++j){\n          L[i][j] = min(L[i][j], L[i][k] + L[k][j]);\n          S[i][j] = min(S[i][j], S[i][k] + S[k][j]);\n        }\n      }\n    }\n    /*\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", L[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", S[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n    int r;\n    cin >> r;\n    vector<int> Z(r);\n    for(int i = 0; i < r; ++i){\n      cin >> Z[i];\n      --Z[i];\n    }\n    vector< vector<long long int> > DP(r, vector<long long int>(n,INF));\n    DP[0][Z[0]] = 0;\n    for(int i = 1; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          DP[i][k] = min(DP[i][k], DP[i-1][j] + L[Z[i-1]][j] + S[j][k] + L[k][Z[i]]);\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", DP[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i) ans = min(ans, DP[r-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll sd[222][222];\nll ld[222][222];\nll dp[1111][222];\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\t\n\t\tREP(i,222){\n\t\t\tREP(j,222){\n\t\t\t\tsd[i][j] = LLINF;\n\t\t\t\tld[i][j] = LLINF;\n\t\t\t}\n\t\t\tREP(j,1111)dp[j][i] = LLINF;\n\t\t}\n\t\t\n\t\tREP(i,222){\n\t\t\tsd[i][i] = 0;\n\t\t\tld[i][i] = 0;\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;b--;\n\t\t\tif(d == 'S'){\n\t\t\t\tsd[a][b] = min(sd[a][b],c);\n\t\t\t\tsd[b][a] = min(sd[b][a],c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld[a][b] = min(ld[a][b],c);\n\t\t\t\tld[b][a] = min(ld[b][a],c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll r;cin >> r;\n\t\tvector<ll> v(r);REP(i,r)cin >> v[i],v[i]--;\n\t\t\n\t\tREP(k,222)REP(i,222)REP(j,222){\n\t\t\tsd[i][j] = min(sd[i][j],sd[i][k]+sd[k][j]);\n\t\t\tld[i][j] = min(ld[i][j],ld[i][k]+ld[k][j]);\n\t\t}\n\t\t\n\t\tdp[0][v[0]] = 0;\n\t\t\n\t\tREP(i,r-1){\n\t\t\tREP(j,n){\n\t\t\t\tif(dp[i][j] != LLINF){\n\t\t\t\t\tdp[i+1][j] = min(dp[i+1][j],dp[i][j]+ld[v[i]][v[i+1]]);\n\t\t\t\t\tREP(k,n){\n\t\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k],dp[i][j]+ld[v[i]][j]+sd[j][k]+ld[k][v[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tDBG(SHOW2d(dp,r,n));\n\t\t\n\t\tll ans = LLINF;\n\t\tREP(i,n)ans = min(ans,dp[r-1][i]);\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long \n#define inf 0x3f3f3f3f\nint e1[220][220],e2[220][220];\nint f[1100][220],a[220];\nvoid init(int N){\n\tmemset(e1,inf,sizeof(e1));\n\tmemset(e2,inf,sizeof(e2));\n\tmemset(f,inf,sizeof(f));\n\tfor(int i=1;i<=N;++i) e1[i][i]=e2[i][i]=0;\n}\nvoid floyd(int e[][210],int N){\n\tint i,j,k;\n\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e[i][j]==inf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te[i][k]=min(e[i][k],e[i][j]+e[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\tint N,M,i,j,k,u,v,w,R;\n\tchar str[10];\n\twhile(scanf(\"%d%d\",&N,&M)==2){\n\t\tif(N==0&&M==0) break;\n\t\tinit(N);\n\t\twhile(M--){\n\t\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(!strcmp(str,\"L\")){\n\t\t\t\tif(w<e1[u][v]){\n\t\t\t\t\te1[u][v]=e1[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(w<e2[u][v]){\n\t\t\t\t\te2[u][v]=e2[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfloyd(e1,N);\n\t\tfloyd(e2,N);\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=1;i<=R;++i) scanf(\"%d\",a+i);\n\t\tf[1][a[1]]=0;\n\t\tfor(i=1;i<=R;++i){\n\t\t\tfor(j=1;j<=N;++j){\n\t\t\t\tif(f[i][j]!=inf){\n\t\t\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\t\t\tif(e2[j][k]!=inf&&e1[a[i]][j]!=inf&&e1[a[i+1]][k]!=inf)\n\t\t\t\t\t\tf[i+1][k]=min(\n\t\t\t\t\t\tf[i+1][k],f[i][j]+e1[a[i]][j]+e1[a[i+1]][k]+e2[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tfor(i=1;i<=N;++i) ans=min(ans,f[R][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nstatic int N, M, R;\n\n\n\nstatic int dist_l[201][201];\nstatic int dist_s[201][201];\n\nstatic int dest[1001];\n\n\n\nstatic void flood()\n{\n\tint i, j, k;\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n\nstatic int dp[1001][201];\n\nstatic void solve()\n{\n\tflood();\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tint z0 = dest[1];\n        if (z0!=1) while (1);\n\t\n\tfor (j=1; j<=N; j++) {\n\t\tif (dist_l[j][z0]!=INT_MAX && dist_s[z0][j]!=INT_MAX) {\n\t\t\tif (dp[1][j] > dist_l[j][z0] + dist_s[z0][j])\n\t\t\t\tdp[1][j] = dist_l[j][z0] + dist_s[z0][j];\n\t\t}\n\t}\n\n\tfor (i=2; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k!=j) {\n\t\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dist_l[start][end]!=INT_MAX && dp[i][k] > dp[i-1][k]+dist_l[start][end])\n\t\t\t\t\t\t\tdp[i][k] = dp[i-1][k]+dist_l[start][end];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nstatic void solve1()\n{\n\tflood();\n\n\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tdp[0][1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (dp[i][j] > dp[i-1][j]+total_land_cost)\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tdist_l[i][i] = dist_s[i][i] = 0;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tif (dist_s[x][y] > t)\n\t\t\t\t\tdist_s[x][y] = dist_s[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_l[x][y] > t)\n\t\t\t\t\tdist_l[x][y] = dist_l[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long \n#define inf 0x7ffffff\nint e1[220][220],e2[220][220];\nint f[1100][220];\nint a[1100];\nvoid init(int N){\n\tmemset(e1,inf,sizeof(e1));\n\tmemset(e2,inf,sizeof(e2));\n\tmemset(f,inf,sizeof(f));\n\tfor(int i=1;i<=N;++i) e1[i][i]=e2[i][i]=0;\n}\nint main(){\n\t//cout<<inf<<endl;\n\tint N,M,i,j,k,u,v,R,w;\n\tchar str[10];\n\twhile(scanf(\"%d%d\",&N,&M)){\n\t\tif(N==0&&M==0) break;\n\t\tinit(N);\n\t\twhile(M--){\n\t\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t\tscanf(\"%s\",str);\n\t\t\tif(!strcmp(str,\"L\")){\n\t\t\t\tif(w<e1[u][v]){\n\t\t\t\t\te1[u][v]=e1[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(w<e2[u][v]){\n\t\t\t\t\te2[u][v]=e2[v][u]=w;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e1[i][j]==inf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te1[i][k]=min(e1[i][k],e1[i][j]+e1[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(i=1;i<=N;++i){\n\t\tfor(j=1;j<=N;++j){\n\t\t\tif(e2[i][j]==inf) continue;\n\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\te2[i][k]=min(e2[i][k],e2[i][j]+e2[j][k]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=1;i<=R;++i) scanf(\"%d\",a+i);\n\t\tfor(i=1;i<=N;++i) \n\t\tf[1][i]=min(f[1][i],e1[i][a[1]]+e2[i][a[1]]);\n\t\tfor(i=1;i<R;++i){\n\t\t\tfor(j=1;j<=N;++j){\n\t\t\t\tif(f[i][j]!=inf){f[i+1][j]=min(f[i+1][j],f[i][j]+e1[a[i]][a[i+1]]);\n\t\t\t\t\tfor(k=1;k<=N;++k){\n\t\t\t\t\t\tif(e2[j][k]!=inf&&e1[a[i]][j]!=inf&&e1[a[i+1]][k]!=inf)\n\t\t\t\t\t\tf[i+1][k]=min(\n\t\t\t\t\t\tf[i+1][k],f[i][j]+e1[a[i]][j]+e1[a[i+1]][k]+e2[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\tfor(i=1;i<=N;++i) ans=min(ans,f[R][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship, cost;\n\tP(int now, int ship, int cost) :now(now), ship(ship), cost(cost) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\n\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tint N, M;\n\t\tvector<pii> SeaRoutes[201];\n\t\tvector<pii> LandRoutes[201];\n\t\tint R;\n\t\tvi Destinations;\n\n\t\tcin >> N >> M;\n\t\tif ( N == 0 && M == 0 )break;\n\n\t\tFOR(i, M)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif ( sl == 'S' )\n\t\t\t{\n\t\t\t\tSeaRoutes[x].emplace_back(t,y);\n\t\t\t\tSeaRoutes[y].emplace_back(t,x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLandRoutes[x].emplace_back(t,y);\n\t\t\t\tLandRoutes[y].emplace_back(t,x);\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tFOR(i, R)\n\t\t{\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tDestinations.push_back(z);\n\t\t}\n\t\t\n\t\tint Flags[201][201];\n\t\tvector<P> StartPoints(1,P(Destinations[0],Destinations[0],0));\n\t\tint Score;\n\t\tFORI(r, 1, R)\n\t\t{\n\t\t\tINIT(Flags);\n\t\t\tpriority_queue< P, vector<P>, greater<P> > Queue(ALL(StartPoints));\n\t\t\tfor ( P StartPoint : StartPoints )\n\t\t\t\tFlags[StartPoint.now][StartPoint.ship] = StartPoint.cost;\n\t\t\tvector<P> Empty;\n\t\t\tswap(StartPoints, Empty);\n\t\t\tScore = INT_MAX;\n\t\t\twhile ( !Queue.empty() )\n\t\t\t{\n\t\t\t\tP CurrentPoint = Queue.top();\n\t\t\t\tQueue.pop();\n\t\t\t\tif ( CurrentPoint.now == Destinations[r] )\n\t\t\t\t{\n\t\t\t\t\tScore = min(Score,CurrentPoint.cost);\n\t\t\t\t\tStartPoints.push_back(CurrentPoint);\n\t\t\t\t}\n\t\t\t\tif ( CurrentPoint.now == CurrentPoint.ship )\n\t\t\t\t{\n\t\t\t\t\tFOR(i, SeaRoutes[CurrentPoint.now].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tP NextPoint = CurrentPoint;\n\t\t\t\t\t\tNextPoint.now = NextPoint.ship = SeaRoutes[CurrentPoint.now][i].second;\n\t\t\t\t\t\tNextPoint.cost += SeaRoutes[CurrentPoint.now][i].first;\n\t\t\t\t\t\tint* Flag=&Flags[NextPoint.now][NextPoint.ship];\n\t\t\t\t\t\tif ( *Flag == -1 || *Flag > NextPoint.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*Flag = NextPoint.cost;\n\t\t\t\t\t\t\tQueue.push(NextPoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFOR(i, LandRoutes[CurrentPoint.now].size())\n\t\t\t\t{\n\t\t\t\t\tP NextPoint = CurrentPoint;\n\t\t\t\t\tNextPoint.now = LandRoutes[CurrentPoint.now][i].second;\n\t\t\t\t\tNextPoint.cost += LandRoutes[CurrentPoint.now][i].first;\n\t\t\t\t\tint* Flag = &Flags[NextPoint.now][NextPoint.ship];\n\t\t\t\t\tif ( *Flag == -1 || *Flag > NextPoint.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\t*Flag = NextPoint.cost;\n\t\t\t\t\t\tQueue.push(NextPoint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\nint N, M, R;\nint ds[200][200],dl[200][200];//ship walk\nint list[1000];\nint dp[1000][200];\n\nint main() {\n\twhile (cin >> N >> M, N + M) {\n\t\tfor (int i = 0; i < N; i++)for (int j = 0; j < N; j++)\n\t\t{\n\t\t\tif (i == j)dl[i][j] = ds[i][j] = 0;\n\t\t\telse dl[i][j] = ds[i][j] = INF;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint a, b, cost;\n\t\t\tchar c;\n\t\t\tcin >> a >> b >> cost >> c;\n\t\t\ta--, b--;\n\t\t\tif (c == 'L') dl[a][b] = min(cost, dl[a][b]), dl[b][a] = dl[a][b];\n\t\t\telse ds[a][b] = min(cost, ds[a][b]), ds[b][a] = ds[a][b];\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++)cin >> list[i],list[i]--;\n\t\t//???????????£???????????????\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < R; i++)for (int j = 0; j < N; j++)dp[i][j] = INF;\n\t\t//dp[i][j] := i???????????????????????°??§???j?????????????????¨??????????????¨?????????????????????????????????\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tdp[0][i] = ds[0][i] + dl[i][list[0]];\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k)dp[i][j] = min(dp[i][j], dp[i - 1][k] + dl[list[i]][list[i - 1]]);\n\t\t\t\t\telse {\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[list[i - 1]][j] + ds[k][j] + dl[k][list[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; i++)ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\nconst ll INF = 1LL << 50;\n\nint main(){\n    int n, m, x, y, r;\n    ll t;\n    char sl;\n    while(scanf(\"%d%d\", &n, &m), n){\n        vector< vector<ll> > st(n, vector<ll>(n, INF)), lt(n, vector<ll>(n, INF));\n        rep(n){\n            st[i][i] = 0LL;\n            lt[i][i] = 0LL;\n        }\n        rep(m){\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'S'){\n                st[x][y] = st[y][x] = min(st[x][y], t);\n            }else{\n                lt[x][y] = lt[y][x] = min(lt[x][y], t);\n            }\n        }\n\n        repp(k, n){\n            repp(i, n){\n                repp(j, n){\n                        st[i][j] = min(st[i][j], st[i][k] + st[k][j]);\n                        lt[i][j] = min(lt[i][j], lt[i][k] + lt[k][j]);\n                }\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(r){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // dp[i][j]: z[i]にいる，お船はjにあるときの最短時間\n        ll dp[r][n];\n        fill(dp[0], dp[r], INF);\n        dp[0][z[0]] = 0LL;\n        rep(r-1){\n            // z[i]からkまで徒歩，kからlまで船，lからz[i+1]まで徒歩\n            repp(k, n){\n                if(dp[i][k] >= INF || lt[z[i]][k] >= INF) continue;\n                repp(l, n){\n                    dp[i+1][l] = min(dp[i+1][l], dp[i][k]+lt[z[i]][k]+st[k][l]+lt[l][z[i+1]]);\n                }\n                if(lt[z[i]][z[i+1]] < INF) dp[i+1][k] = min(dp[i+1][k], dp[i][k] + lt[z[i]][z[i+1]]);\n            }\n        }\n\n        ll ans = INF;\n        rep(n) ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e9;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dp[200][200];\nvector<pii> edgel[200], edges[200];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tscanf(\"%d %d\", &n, &m);\n\t\tif (n == 0)\tbreak;\n\t\trep(i, n) {\n\t\t\tedgel[i].clear();\n\t\t\tedges[i].clear();\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\n\t\t\tscanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n\t\t\tx--;\ty--;\n\t\t\tif (sl == 'L') {\n\t\t\t\tedgel[x].push_back(mp(y, t));\n\t\t\t\tedgel[y].push_back(mp(x, t));\n\t\t\t}\n\t\t\telse if (sl == 'S') {\n\t\t\t\tedges[x].push_back(mp(y, t));\n\t\t\t\tedges[y].push_back(mp(x, t));\n\t\t\t}\n\t\t}\n\t\tint r;\tscanf(\"%d\", &r);\n\t\tvint z(r);\n\t\trep(i, r)\tscanf(\"%d\", &z[i]);\n\t\trep(i, n)\trep(j, n)\tdp[i][j] = inf;\n\t\tpriority_queue<pii> pq;\n\t\trep(i, n)\tdp[i][i] = 0;\n\t\trep(i, r) {\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n)\tif (dp[k][j] != inf)\tpq.push(mp(-dp[k][j], k));\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\t\t\tint dist = -it.fst, pos = it.scn;\n\t\t\t\t\tif (dist > dp[pos][j])\tcontinue;\n\t\t\t\t\trrep(k, edgel[pos].size()) {\n\t\t\t\t\t\tint to = edgel[pos][k].fst, add = dist + edgel[pos][k].scn;\n\t\t\t\t\t\tif (dp[to][j] > add) {\n\t\t\t\t\t\t\tdp[to][j] = add;\n\t\t\t\t\t\t\tpq.push(mp(-add, to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) if (dp[j][j] != inf)\tpq.push(mp(-dp[j][j], j));\n\t\t\twhile (!pq.empty()) {\n\t\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\t\tint dist = -it.fst, pos = it.scn;\n\t\t\t\tif (dist > dp[pos][pos])\tcontinue;\n\t\t\t\trrep(j, edges[pos].size()) {\n\t\t\t\t\tint to = edges[pos][j].fst, add = dist + edges[pos][j].scn;\n\t\t\t\t\tif (dp[to][to] > add) {\n\t\t\t\t\t\tdp[to][to] = add;\n\t\t\t\t\t\tpq.push(mp(-add, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tif (dp[j][j] != inf)\tpq.push(mp(-dp[j][j], j));\n\t\t\t\twhile (!pq.empty()) {\n\t\t\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\t\t\tint dist = -it.fst, pos = it.scn;\n\t\t\t\t\tif (dist > dp[pos][j])\tcontinue;\n\t\t\t\t\trrep(k, edgel[pos].size()) {\n\t\t\t\t\t\tint to = edgel[pos][k].fst, add = dist + edgel[pos][k].scn;\n\t\t\t\t\t\tif (dp[to][j] > add) {\n\t\t\t\t\t\t\tdp[to][j] = add;\n\t\t\t\t\t\t\tpq.push(mp(-add, to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tif (j != z[i]) {\n\t\t\t\t\trep(k, n)\tdp[j][k] = inf;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = inf;\n\t\trep(i, n)\tret = min(ret, dp[z[r - 1]][i]);\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 220\n#define MAX_R 1020\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q2;\nvector<tuple<long long, long long, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N], DIST2[MAX_N];\nlong long COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nint PATH[MAX_N][MAX_N][MAX_N];\nlong long DP[MAX_R][MAX_N];\nlong long cnt;\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n\tcnt = 0;\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = DIST[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tlong long start = travel[i];\n\t\t\t\tlong long goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_N];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << \"0\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <utility>\n#include <complex>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <tuple>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef complex<ld> compd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define RREP(i,n)\tfor(int i=n;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define mt\tmake_tuple\n#define fst\tfirst\n#define scn second\n#define bicnt(x)\t__buildin__popcount(x)\n#define debug(x)\tcout<<\"debug: \"<<x<<endl\n#define DEBUG 0\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-18;\nconst int dx[] = { 0,1,0,-1 };\nconst int dy[] = { 1,0,-1,0 };\n\nint dist[1010][110][110];\nvector<pii> edgel[110],edges[110];\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\tcin >> n >> m;\n\t\tif (n == 0)\tbreak;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\tchar sl;\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\ty--;\n\t\t\t(sl == 'L' ? edgel[x] : edges[x]).push_back(mp(y, t));\n\t\t\t(sl == 'L' ? edgel[y] : edges[y]).push_back(mp(x, t));\n\t\t}\n\t\tint r;\tcin >> r;\n\t\tvint z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\tz[i]--;\n\t\t}\n\t\trep(i, r)\trep(j, n)\trep(k, n)\tdist[i][j][k] = mod;\n\t\tdist[0][z[0]][z[0]] = 0;\n\t\tpriority_queue<tuple<int, int, int, int>> pq;\n\t\tpq.push(mt(0, 0, z[0], z[0]));\n\t\tint ret = mod;\n\t\twhile (!pq.empty()) {\n\t\t\tauto it = pq.top();\tpq.pop();\n\t\t\tint d, pos, fpos, phase;\n\t\t\ttie(d, phase, pos, fpos) = it;\td *= -1;\n\t\t\tif (d > dist[phase][pos][fpos])\tcontinue;\n\t\t\tif(DEBUG)\tcout << d << \" \" << phase << \" \" << pos << \" \" << fpos << endl;\n\t\t\tif (phase == r - 1) {\n\t\t\t\tret = min(ret, d);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(i, edgel[pos].size()) {\n\t\t\t\tint to = edgel[pos][i].fst, add = edgel[pos][i].scn;\n\t\t\t\tint np = phase + (to == z[phase + 1] ? 1 : 0);\n\t\t\t\tif (dist[np][to][fpos] > dist[phase][pos][fpos] + add) {\n\t\t\t\t\tdist[np][to][fpos] = dist[phase][pos][fpos] + add;\n\t\t\t\t\tpq.push(mt(-dist[np][to][fpos], np, to, fpos));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pos == fpos) {\n\t\t\t\trep(i, edges[pos].size()) {\n\t\t\t\t\tint to = edges[pos][i].fst, add = edges[pos][i].scn;\n\t\t\t\t\tint np = phase + (to == z[phase + 1] ? 1 : 0);\n\t\t\t\t\tif (dist[np][to][to] > dist[phase][pos][fpos] + add) {\n\t\t\t\t\t\tdist[np][to][to] = dist[phase][pos][fpos] + add;\n\t\t\t\t\t\tpq.push(mt(-dist[np][to][to], np, to, to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t\trep(i, n) {\n\t\t\tedgel[i].clear();\tedges[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\twhile (cin >> n >> m && (n)) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tfor (int i = 1; i <= 200; i++)for (int j = 0; j < r; j++)dp[j][i] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tint ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst int MAX_V = 10010;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\n\nstruct WarshallFloyd{\n    int n;\n    const int INF = 1e6;\n    vector<vector<int> > d;\n    WarshallFloyd(int _n){\n        n = _n;\n        d.resize(n, vector<int>(n));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n    }\n    void build(){\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n    }\n};\n\nint n, m, r;\nint d[1010][210];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        WarshallFloyd wfl(n), wfs(n);\n        rep(i, 0, m){\n            int x, y, t; char c;\n            cin >> x >> y >> t >> c;\n            x--; y--;\n            if(c == 'L'){\n                wfl.d[x][y] = t;\n                wfl.d[y][x] = t;\n            }else{\n                wfs.d[x][y] = t;\n                wfs.d[y][x] = t;\n            }\n        }\n        cin >> r;\n        vector<int> z(r);\n        rep(i, 0, r){\n            cin >> z[i];\n            z[i]--;\n        }\n        wfl.build();\n        wfs.build();\n        rep(i, 0, r) rep(j, 0, n) d[i][j] = INF;\n        d[0][z[0]] = 0;\n        rep(i, 1, r){\n            rep(j, 0, n){\n                if(d[i - 1][j] == INF) continue;                \n                rep(k, 0, n){\n                    int tmp = wfl.d[z[i - 1]][j] + wfs.d[j][k] + wfl.d[k][z[i]];\n                    // cout << i << ' ' << j << ' ' << k << ' ' << tmp << endl;\n                    d[i][k] = min(d[i][k], d[i - 1][j] + tmp);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n) ans = min(ans, d[r - 1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <queue>\n#define oo 0x3f3f3f3f\nusing namespace std;\nstruct ad\n{\n    int to, next, v, water;\n} edge[33000];\nstruct node\n{\n    int people_pos, ship_pos, cnt, water;\n};\nint head[3300], edge_num, vis[300][1100][2], k, End[1100], dist[300][1100][2], n;\nvoid Add(int x, int y, int z, int op)\n{\n    edge[edge_num].to = y;\n    edge[edge_num].v = z;\n    edge[edge_num].next = head[x];\n    edge[edge_num].water = op;\n    head[x] = edge_num++;\n}\nint spfa()\n{\n    queue<node>Q;\n    node now, next;\n    now.people_pos = End[1];\n    now.ship_pos = End[1];\n    now.cnt = 1;\n    now.water = 0;\n    Q.push(now);\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=k; j++)\n        {\n            dist[i][j][0] = dist[i][j][1] = oo;\n            vis[i][j][0] = vis[i][j][1] = 0;\n        }\n\n    dist[End[1]][1][0] = dist[End[1]][1][1] = 0;\n    vis[End[1]][1][0] = 1;\n    while(!Q.empty())\n    {\n        now = Q.front();\n        Q.pop();\n\n        for(int i=head[now.people_pos]; ~i; i=edge[i].next)\n        {\n            int v = edge[i].to;\n            int new_cnt = now.cnt;\n            if(v == End[now.cnt+1])\n                new_cnt++;\n            if(!edge[i].water)\n            {\n                if(dist[v][new_cnt][edge[i].water]>dist[now.people_pos][now.cnt][now.water]+edge[i].v)\n                {\n                    dist[v][new_cnt][edge[i].water] = dist[now.people_pos][now.cnt][now.water]+edge[i].v;\n                    if(!vis[v][new_cnt][edge[i].water])\n                    {\n                        vis[v][new_cnt][edge[i].water] = 1;\n                        next.people_pos = v;\n                        next.water = 0;\n                        next.ship_pos = now.ship_pos;\n                        next.cnt = new_cnt;\n                        Q.push(next);\n                    }\n\n                }\n            }\n            else if(now.ship_pos == now.people_pos)\n            {\n                if(dist[v][new_cnt][edge[i].water]>dist[now.people_pos][now.cnt][now.water]+edge[i].v)\n                {\n                    dist[v][new_cnt][edge[i].water] = dist[now.people_pos][now.cnt][now.water]+edge[i].v;\n                    if(!vis[v][new_cnt][edge[i].water])\n                    {\n                        vis[v][new_cnt][edge[i].water] = 1;\n                        next.people_pos = v;\n                        next.ship_pos = v;\n                        next.cnt = new_cnt;\n                        next.water = 1;\n                        Q.push(next);\n                    }\n\n                }\n            }\n        }\n        vis[now.people_pos][now.cnt][now.water] = 0;\n    }\n\n    return min(dist[End[k]][k][0], dist[End[k]][k][1]);\n}\nint main()\n{\n    int m;\n    while(scanf(\"%d %d\", &n, &m), n+m)\n    {\n        memset(head, -1, sizeof(head));\n        memset(End, 0, sizeof(End));\n        edge_num = 0;\n        int u, v, w;\n        char way[5];\n        for(int i=1; i<=m; i++)\n        {\n            scanf(\"%d %d %d %s\", &u, &v, &w, way);\n            Add(u, v, w, way[0]=='S');\n            Add(v, u, w, way[0]=='S');\n        }\n\n        scanf(\"%d\", &k);\n\n        for(int i=1; i<=k; i++)\n            scanf(\"%d\", &End[i]);\n\n        printf(\"%d\\n\", spfa());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nvi p;\nusing t = vector<pair<int, void*>>;\nvpii ki;\nt* c(int i) {\n\tif (ki.size() == i)return nullptr;\n\tt* a=new t(ki[i].second + 1);\n\trep(j, ki[i].second + 1) {\n\t\t(*a)[j].second = c(i + 1);\n\t}\n\treturn a;\n}\nvoid add(int k, int i, t* a) {\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second+0);\n\t(*a)[s].first++;\n\tif (i == ki.size() - 1) {\n\t\treturn;\n\t}\n\tadd(k, i + 1, (t*)((*a)[s].second));\n}\nll cnt(int k, int i, t*a) {\n\tll c = 0;\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second + 0);\n\tif (i == ki.size() - 1) {\n\t\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += (*a)[j].first;\n\t\treturn c;\n\t}\n\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += cnt(k, i + 1, (t*)((*a)[j].second));\n\treturn c;\n}\nint lw[200][200], sw[200][200];\nint dp[2][200];\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tfill(lw[0], lw[200], numeric_limits<int>::max() / 8);\n\t\tfill(sw[0], sw[200], numeric_limits<int>::max() / 8);\n\t\trep(i, n)lw[i][i] = 0;\n\t\trep(i, n)sw[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tcmin(lw[x - 1][y - 1], t);\n\t\t\t\tcmin(lw[y - 1][x - 1], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmin(sw[x - 1][y - 1], t);\n\t\t\t\tcmin(sw[y - 1][x - 1], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(lw[i][j], lw[i][k] + lw[k][j]);\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(sw[i][j], sw[i][k] + sw[k][j]);\n\t\t}\n\t\tfill(dp[0], dp[1], numeric_limits<int>::max() / 8);\n\t\tint r;\n\t\tcin >> r;\n\t\tvi z(r);\n\t\trep(i, r)cin >> z[i];\n\t\tint prev = z[0] - 1;\n\t\tdp[0][z[0] - 1] = 0;\n\t\trep(i, r) {\n\t\t\tfill(dp[~i & 1], dp[(~i&1) + 1], numeric_limits<int>::max() / 8);\n\t\t\trep(j, n)rep(k, n) {\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][j] + sw[j][k] + lw[k][z[i] - 1]);\n\t\t\t}\n\t\t\tprev = z[i] - 1;\n\t\t}\n\t\tint ans = numeric_limits<int>::max() / 8;\n\t\trep(i, n)cmin(ans, dp[r & 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][j] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define int long long\n#define FOR(i, m, n) for (int i = (m); i < (n); i++)\n#define all(x) x.begin(), x.end()\n\nusing pii = pair<int, int>;\nint N, M;\n\n// bool used[1010][202][202];\nint t = 1;\nint dps[202][202], dpl[202][202], dp[1010][202];\nbool solve() {\n    cin >> N >> M;\n    // cerr << \"case #\" << t++ << endl;\n    if (N == 0) return false;\n    REP(i, N) REP(j, N) {\n        if (i != j)\n            dps[i][j] = dpl[i][j] = 1e9;\n        else\n            dps[i][j] = dpl[i][j] = 0;\n    }\n\n    REP(i, M) {\n        int x, y, t;\n        char c;\n        cin >> x >> y >> t >> c;\n        bool sea = (c == 'S');\n        x--, y--;\n        if (sea) {\n            dps[x][y] = dps[y][x] = min(dps[x][y], t);\n        } else {\n            dpl[x][y] = dpl[y][x] = min(dpl[x][y], t);\n        }\n        // G[x].push_back({y, t, sea});\n        // G[y].push_back({x, t, sea});\n    }\n    REP(k, N) REP(i, N) REP(j, N) {\n        dps[i][j] = min(dps[i][j], dps[i][k] + dps[k][j]);\n        dpl[i][j] = min(dpl[i][j], dpl[i][k] + dpl[k][j]);\n    }\n\n    int R;\n    cin >> R;\n    vector<int> v(R);\n    REP(i, R + 1) REP(j, N + 1) dp[i][j] = 1e9;\n    REP(i, R) {\n        cin >> v[i];\n        v[i]--;\n    }\n    dp[0][v[0]] = 0;\n\n    REP(i, R - 1) {\n        REP(j, N) {\n            dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dpl[v[i]][v[i + 1]]);\n            REP(k, N) { dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dpl[v[i]][j] + dps[j][k] + dpl[k][v[i + 1]]); }\n        }\n    }\n    int ans = 1e9;\n    REP(i, N) { ans = min(ans, dp[R - 1][i]); }\n    cout << ans << endl;\n    return true;\n}\n\nsigned main() {\n    while (solve())\n        ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct State {\n  unsigned char p, s;\n  int r, cost;\n  State() {}\n  State(int p, int s, int r, int cost)\n    : p(p), s(s), r(r), cost(cost) {}\n  bool operator < (const State &_s) const {\n    if(cost != _s.cost) return cost > _s.cost;\n    if(r != _s.r) return r > _s.r;\n    if(p != _s.p) return p > _s.p;\n    return s > _s.s;\n  }\n};\n\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nconst int INF = 1<<24;\nint N, M, R;\nint G[MAX_N][MAX_N][2];\nvector<int> Z;\nbool vis[MAX_N][MAX_N][MAX_R];\n\nvoid init() {\n  for(int i = 0; i < MAX_N; ++i) {\n    for(int j = 0; j < MAX_N; ++j) {\n      G[i][j][0] = INF;\n      G[i][j][1] = INF;\n    }\n  }\n  Z.clear();\n}\n\nint solve() {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      for(int k = 0; k < R; ++k) {\n\tvis[i][j][k] = false;\n      }\n    }\n  }\n\n  priority_queue<State> que;\n  State s(Z[0], Z[0], 1, 0);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(s.r == R && s.p == Z[R-1]) return s.cost;\n    if(vis[s.p][s.s][s.r]) continue;\n    vis[s.p][s.s][s.r] = true;\n    for(int j = 0; j <= (s.p == s.s); ++j) {\n      for(int i = 0; i < N; ++i) {\n\tif(G[s.p][i][j] == INF) continue;\n\tState t(i, (j ? i : s.s), s.r+(Z[s.r] == i), s.cost+G[s.p][i][j]);\n\tif(vis[t.p][t.s][t.r]) continue;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    init();\n    for(int i = 0; i < M; ++i) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      bool isS = (sl == 'S');\n      G[x][y][isS] = t;\n      G[y][x][isS] = t;\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      int z;\n      cin >> z;\n      Z.push_back(z-1);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint dp[1111][222];\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    int x[m],y[m],t[m];\n    char sl[m];\n    for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i]>>sl[i];\n    int r;\n    cin>>r;\n    int z[r];\n    for(int i=0;i<r;i++) cin>>z[i];\n    int INF=1LL<<55LL;\n    int s[n][n],l[n][n];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\ts[i][j]=l[i][j]=INF*(i!=j);\n    for(int i=0;i<m;i++){\n      x[i]--;y[i]--;\n      if(sl[i]=='S') s[x[i]][y[i]]=s[y[i]][x[i]]=min(s[x[i]][y[i]],t[i]);\n      else l[x[i]][y[i]]=l[y[i]][x[i]]=min(l[x[i]][y[i]],t[i]);\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  s[i][j]=min(s[i][j],s[i][k]+s[k][j]),\n\t    l[i][j]=min(l[i][j],l[i][k]+l[k][j]);\n    for(int i=0;i<r;i++) z[i]--;\n    for(int i=0;i<r;i++)\n      for(int j=0;j<n;j++)\n\tdp[i][j]=INF;\n    dp[0][z[0]]=0;\n    for(int i=0;i<r-1;i++)\n      for(int j=0;j<n;j++)\n\tfor(int k=0;k<n;k++)\n\t  dp[i+1][k]=min(dp[i+1][k],dp[i][j]+l[z[i]][j]+s[j][k]+l[k][z[i+1]]);\n    int ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 10000000000000ll;\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tchar sl;\n\tint N, M, R;\n\twhile (cin >> N >> M, N | M) {\n\t\tvector<vector<ll>> umi(N, vector<ll>(N, INF)), riku(N, vector<ll>(N, INF));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tumi[i][i] = riku[i][i] = 0;\n\t\t}\n\t\tfor (ll i = 0, x, y, t; i < M; i++) {\n\t\t\tcin >> x >> y >> t >> sl; x--; y--;\n\t\t\tif (sl == 'S') {\n\t\t\t\tumi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\triku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tumi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tvector<ll> z(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> z[i]; z[i]--;\n\t\t}\n\t\tvector<vector<ll>> d(R, vector<ll>(N, INF));\n\t\td[0][z[0]] = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (umi[z[0]][i] != INF && riku[i][z[0]] != INF) {\n\t\t\t\td[0][i] = min(d[0][i], umi[z[0]][i] + riku[i][z[0]]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\td[i][k] = min(d[i][k], d[i - 1][j] + riku[z[i - 1]][j] + umi[j][k] + riku[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, d[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 28;\n\nint n,m,r;\n\nint L[210][210];\nint S[210][210];\nint z[1010];\n\nint dp[1010][210];\n\nint main(void){\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,n)rep(j,n) L[i][j]=S[i][j]=(i==j)?0:inf;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar type;\n\t\t\tcin >> a >> b >> c >> type;\n\t\t\ta--,b--;\n\t\t\tif(type=='L')\n\t\t\t\tL[a][b]=L[b][a]=min(L[a][b],c);\n\t\t\telse\n\t\t\t\tS[a][b]=S[b][a]=min(S[a][b],c);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\tcin >> r;\n\t\trep(i,r) cin >> z[i],z[i]--;\n\t\trep(i,r)rep(j,n) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[z[i]][z[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tint cost=L[z[i]][j]+S[j][k]+L[k][z[i+1]];\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+cost);\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\n\nconst int INF=10000000;\nint ans;\nint n,m;\nint r;\nint load[201][201];\nint sea[201][201];\nint dp[1001][201];\nint rt[1001];\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<=200;i++){\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\tload[i][j]=sea[i][j]=INF;\n\t\t\t}\n\t\t\tload[i][i]=sea[i][i]=0;\n\t\t\tfor(int j=0;j<=1000;j++){\n\t\t\t\tdp[j][i]=INF;\n\t\t\t}\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\ta--,b--;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tload[a][b]=min(load[a][b],ti);\n\t\t\t\tload[b][a]=min(load[b][a],ti);\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\tsea[a][b]=min(sea[a][b],ti);\n\t\t\t\tsea[b][a]=min(sea[b][a],ti);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<=200;k++){\n\t\t\tfor(int i=0;i<=200;i++){\n\t\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\t\tload[i][j]=min(load[i][j],load[i][k]+load[k][j]);\n\t\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tdp[0][rt[0]]=0;\n\t\t//配達先\n\t\tfor(int i=0;i<r-1;i++){\n\t\t\t//次の船の位置\n\t\t\tfor(int j=0;j<=200;j++){\n\t\t\t\t//今の船の位置\n\t\t\t\tfor(int k=0;k<=200;k++){\n\t\t\t\t\tif(dp[i][k]!=INF){\n\t\t\t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][k]+load[rt[i]][k]+sea[k][j]+load[j][rt[i+1]]);\n\t\t\t\t\t\tif(j==k)dp[i+1][j]=min(dp[i+1][j],dp[i][k]+load[rt[i]][rt[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res=INF;\n\t\tfor(int i=0;i<=200;i++)res=min(res,dp[r-1][i]);\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n/* ---------------------------------------------------------------------------------------------------- */\n\nint N,M,R;\nint dis[2][210][210];\nint z[1010];\nint dp[1010][210];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while (cin >> N >> M, N) {\n    MINF(dis);\n    REP(i,M) {\n      int x,y,t;\n      char c;\n      cin >> x >> y >> t >> c;\n      x--; y--;\n      CHMIN(dis[c!='L'][x][y],t);\n      CHMIN(dis[c!='L'][y][x],t);\n    }\n    cin >> R;\n    REP(i,R) cin >> z[i], z[i]--;\n    REP(_,2) REP(i,N) dis[_][i][i] = 0;\n    REP(_,2) REP(k,N) REP(i,N) REP(j,N) {\n      CHMIN(dis[_][i][j],dis[_][i][k]+dis[_][k][j]);\n    }\n    MINF(dp);\n    dp[0][z[0]] = 0;\n    using P = tuple<int,int,int>;\n    priority_queue<P,vector<P>,greater<P>> que;\n    que.emplace(0,0,z[0]);\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int dd,id,v;\n      tie(dd,id,v) = p;\n      if (dp[id][v] < dd) continue;\n      if (id+1 < R && CHMIN(dp[id+1][v],dp[id][v]+dis[0][z[id]][z[id+1]])) {\n        que.emplace(dp[id+1][v],id+1,v);\n      }\n      for (int nv = 0; nv < N; nv++) {\n        if (id+1 < R && CHMIN(dp[id+1][nv],dp[id][v]+dis[0][z[id]][v]+dis[1][v][nv]+dis[0][nv][z[id+1]])) {\n          que.emplace(dp[id+1][nv],id+1,nv);\n        }\n      }\n    }\n    cout << *min_element(dp[R-1],dp[R-1]+N) << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\nconst int INF = 1<<28;\n\nint dp[2][202];\n\nint adj_l[202][202];\nint adj_s[202][202];\n\nstruct edge{\n    int to, cost;\n    edge(int to, int cost): to(to), cost(cost){}\n};\n\nvector<int> dijkstra(vector<vector<edge>>& E, int start=0){\n    int N = E.size();\n    vector<int> d(N, INF);\n    priority_queue<P, vector<P>, greater<P>> que;\n    d[start] = 0;\n    que.push(P(0, start));\n    while(que.size()){\n        P p = que.top(); que.pop();\n        if(d[p.second] < p.first) continue;\n        for(edge e: E[p.second]){\n            int nc = p.first + e.cost;\n            if(d[e.to] > nc){\n                d[e.to] = nc;\n                que.push(P(nc, e.to));\n            }\n        }\n    }\n    return d;\n}\n\nint main(){\n    while(true){\n        int N, M;\n        cin >> N >> M;\n        if(N == 0) break;\n\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                adj_l[i][j] = INF;\n                adj_s[i][j] = INF;\n            }\n        }\n        for(int i=0;i<N;i++){\n            adj_l[i][i] = 0;\n            adj_s[i][i] = 0;\n        }\n\n        for(int i=0;i<M;i++){\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'L'){\n                adj_l[x][y] = t;\n                adj_l[y][x] = t;\n            }else{\n                adj_s[x][y] = t;\n                adj_s[y][x] = t;\n            }\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    adj_l[i][j] = min(adj_l[i][j], adj_l[i][k] + adj_l[k][j]);\n                    adj_s[i][j] = min(adj_s[i][j], adj_s[i][k] + adj_s[k][j]);\n                }\n            }\n        }\n\n        int R;\n        cin >> R;\n\n        vector<int> z(R);\n        for(int i=0;i<R;i++){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        int cur = 0;\n        for(int i=0;i<N;i++){\n            dp[0][i] = INF;\n        }\n        dp[0][z[0]] = 0;\n\n        for(int i=1;i<R;i++){\n            int next = cur ^ 1;\n            for(int r_to=0;r_to<N;r_to++){\n                dp[next][r_to] = INF;\n                for(int r_from=0;r_from<N;r_from++){\n                    int cost = adj_l[z[i-1]][r_from] + adj_s[r_from][r_to] + adj_l[r_to][z[i]];\n                    dp[next][r_to] = min(dp[next][r_to], dp[cur][r_from] + cost);\n                }\n                // cout << r_to << \" \" << dp[next][r_to] << endl;\n            }\n            cur = next;\n        }\n\n        int ans = INF;\n        for(int i=0;i<N;i++){\n            ans = min(ans, dp[cur][i]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\n\nusing namespace std;\n\nstruct Edge{int to, cost;};\nstruct State{\n  int pos, comp, ship, t;\n  State(){}\n  State(int p, int c, int s, int t):pos(p),comp(c),ship(s),t(t){}\n  bool operator < (const State& s) const { return t > s.t;}\n};\n\nstruct State2 {\n  int pos, comp, ship, t;\n  State2(int p, int c, int s, int t):pos(p),comp(c),ship(s),t(t){}\n  bool operator < (const State2& a) const {\n    if(pos != a.pos) return pos < a.pos;\n    else if(comp != a.comp) return comp < a.comp;\n    else if(ship != a.ship) return ship < a.ship;\n    return false;\n  }\n};\n\nconst int MAX = 201;\nconst int RM = 1001;\nconst int INF = (1<<25);\n\nvector<Edge> El[MAX];\nvector<Edge> Es[MAX];\nvector<int> R;\n//int T[MAX][RM][MAX];\nint N,M;\n\n\nvoid init(){\n  //fill(T[0][0],T[0][0]+MAX*RM*MAX,INF);\n  for(int i = 0; i < MAX; i++){\n    El[i].clear();\n    Es[i].clear();\n  }\n  R.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < M; i++){\n    int x,y,t;\n    char c;\n    cin >> x >> y >> t >> c;\n    if(c == 'S'){\n      Es[x].push_back((Edge){y,t});\n      Es[y].push_back((Edge){x,t});\n    }else{\n      El[x].push_back((Edge){y,t});\n      El[y].push_back((Edge){x,t});\n    }\n  }\n  int r;\n  cin >> r;\n  R.resize(r);\n\n  for(int i = 0; i < r; i++) cin >> R[i];\n}\n\nvoid solve(){\n  //pos, comp, ship, t\n  priority_queue<State> Q;\n  Q.push(State(R[0],0,R[0],0));\n\n  set<State2> vis;\n//  T[R[0]][0][R[0]] = 0;\n  \n  int ans = INF;\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n    \n    // if(T[now.pos][now.comp][now.ship] < now.t) continue;\n    if(now.comp == R.size()-1) {\n      ans = min(ans,now.t);\n      continue;\n    }\n\n    if(vis.count(State2(now.pos, now.comp, now.ship, now.t))) continue;\n    vis.insert(State2(now.pos, now.comp, now.ship, now.t));\n\n    //use ship\n    if(now.pos == now.ship){\n      for(int i = 0; i < Es[now.pos].size(); i++){\n        Edge& e = Es[now.pos][i];\n        State nex = now;\n        nex.pos = nex.ship = e.to;\n        nex.t += e.cost;\n        \n        if(nex.comp+1 < R.size() && e.to == R[nex.comp+1]) nex.comp++;\n\n        //if(T[nex.pos][nex.comp][nex.ship] > nex.t){\n        //   T[nex.pos][nex.comp][nex.ship] = nex.t;\n          Q.push(nex);\n          //  }\n      }\n    }\n\n    //do not use ship\n    for(int i = 0; i < El[now.pos].size(); i++){\n      Edge& e = El[now.pos][i];\n      State nex = now;\n      nex.pos = e.to;\n      nex.t += e.cost;\n\n      if(nex.comp+1 < R.size() && e.to == R[nex.comp+1]) nex.comp++;\n      //   if(T[nex.pos][nex.comp][nex.ship] > nex.t){\n      //    T[nex.pos][nex.comp][nex.ship] = nex.t;\n        Q.push(nex);\n        //   }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\n#define endl '\\n'\n#define ALL(V) begin(V), end(V)\n#define ALLR(V) rbegin(V), rend(V)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing PLL = std::pair<ll, ll>;\nusing TLL = std::tuple<ll, ll, ll>;\ntemplate <typename T> using V = std::vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n#define mv_rec make_v(init, tail...)\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, size_t s, Tail... tail) { return V<decltype(mv_rec)>(s, mv_rec); }\n#undef mv_rec\nusing namespace std;\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\nconst size_t SIZE = 210;\nconst ll inf = 5e15;\nll dp[2][SIZE];\n\nbool solve() {\n    ll N, M;\n    cin >> N >> M;\n    if (!(N + M)) return false;\n\n    ll dl[SIZE][SIZE], ds[SIZE][SIZE];\n    for (ll i = 0; i < SIZE; i++) {\n        fill(dl[i], dl[i] + SIZE, inf);\n        fill(ds[i], ds[i] + SIZE, inf);\n        dl[i][i] = ds[i][i] = 0;\n    }\n\n    for (ll i = 0; i < M; i++) {\n        ll x, y, t;\n        char c;\n        cin >> x >> y >> t >> c;\n        auto ptr = (c == 'L' ? dl : ds);\n        x--; y--;\n        chmin(ptr[x][y], t);\n        chmin(ptr[y][x], t);\n    }\n\n    for (ll loop = 0; loop < 2; loop++) {\n        auto ptr = (loop ? dl : ds);\n        for (ll k = 0; k < N; k++) for (ll i = 0; i < N; i++) for (ll j = 0; j < N; j++) chmin(ptr[i][j], ptr[i][k] + ptr[k][j]);\n    }\n\n    ll R;\n    cin >> R;\n    V<ll> C(R);\n    for (ll &e : C) {\n        cin >> e;\n        e--;\n    }\n    \n    fill(dp[0], dp[0] + SIZE, inf);\n    ll cur = C[0];\n    dp[0][cur] = 0;\n    for (ll i = 0; i < R; i++) {\n        fill(dp[1], dp[1] + SIZE, inf);\n        ll c = C[i];\n        for (ll i = 0; i < N; i++) for (ll j = 0; j < N; j++) {\n            ll d;\n            if (i != j) d = dp[0][i] + dl[cur][i] + ds[i][j] + dl[j][c];\n            else d = dp[0][i] + dl[cur][c];\n            chmin(dp[1][j], d);\n        }\n        copy(dp[1], dp[1] + SIZE, dp[0]);\n        cur = c;\n    }\n\n    cout << *min_element(ALL(dp[0])) << endl;\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=min(dL[s][t],v);  \n     dL[t][s]=min(dL[t][s],v);  \n     }else{\n     dS[s][t]=min(dS[s][t],v);  \n     dS[t][s]=min(dS[t][s],v); \n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){ \n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       //if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           if(j!=k) dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<set>\n#include<map>\n\n\nusing namespace std;\n\nstruct Edge{int to, cost;};\nstruct State{\n  int pos, comp, ship, t;\n  State(){}\n  State(int p, int c, int s, int t):pos(p),comp(c),ship(s),t(t){}\n  bool operator < (const State& s) const { return t > s.t;}\n};\n\nstruct State2 {\n  int pos, comp, ship;\n  State2(int p, int c, int s):pos(p),comp(c),ship(s){}\n  bool operator < (const State2& a) const {\n    if(pos != a.pos) return pos < a.pos;\n    else if(comp != a.comp) return comp < a.comp;\n    else if(ship != a.ship) return ship < a.ship;\n    return false;\n  }\n};\n\nconst int MAX = 201;\nconst int RM = 1001;\nconst int INF = (1<<25);\n\nvector<Edge> El[MAX];\nvector<Edge> Es[MAX];\nvector<int> R;\nint N,M;\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++){\n    El[i].clear();\n    Es[i].clear();\n  }\n  R.clear();\n}\n\nvoid input(){\n  for(int i = 0; i < M; i++){\n    int x,y,t;\n    char c;\n    cin >> x >> y >> t >> c;\n    if(c == 'S'){\n      Es[x].push_back((Edge){y,t});\n      Es[y].push_back((Edge){x,t});\n    }else{\n      El[x].push_back((Edge){y,t});\n      El[y].push_back((Edge){x,t});\n    }\n  }\n  int r;\n  cin >> r;\n  R.resize(r);\n\n  for(int i = 0; i < r; i++) cin >> R[i];\n}\n\nvoid solve(){\n  //pos, comp, ship, t\n  priority_queue<State> Q;\n  Q.push(State(R[0],0,R[0],0));\n\n  map<State2, int> M;\n  M[State2(R[0],0,R[0])] = 0;\n\n  int ans = INF;\n\n  while(!Q.empty()){\n    State now = Q.top();\n    Q.pop();\n\n    if(M[State2(now.pos,now.comp,now.ship)] < now.t) continue;    \n\n    if(now.comp == R.size()-1) {\n      ans = min(ans,now.t);\n      continue;\n    }\n\n\n    //use ship\n    if(now.pos == now.ship){\n      for(int i = 0; i < Es[now.pos].size(); i++){\n        Edge& e = Es[now.pos][i];\n        State nex = now;\n        nex.pos = nex.ship = e.to;\n        nex.t += e.cost;\n        \n        if(nex.comp+1 < R.size() && e.to == R[nex.comp+1]) nex.comp++;\n\n        if(M[State2(nex.pos,nex.comp,nex.ship)] > nex.t || M[State2(nex.pos,nex.comp,nex.ship)] == 0){\n          M[State2(nex.pos,nex.comp,nex.ship)] = nex.t;\n          Q.push(nex);\n        }\n      }\n    }\n\n    //do not use ship\n    for(int i = 0; i < El[now.pos].size(); i++){\n      Edge& e = El[now.pos][i];\n      State nex = now;\n      nex.pos = e.to;\n      nex.t += e.cost;\n\n      if(nex.comp+1 < R.size() && e.to == R[nex.comp+1]) nex.comp++;\n\n      if(M[State2(nex.pos,nex.comp,nex.ship)] > nex.t || M[State2(nex.pos,nex.comp,nex.ship)] == 0){\n        M[State2(nex.pos,nex.comp,nex.ship)] = nex.t;\n        Q.push(nex);\n      }\n      \n    }\n  }\n\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> N >> M && N+M){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\n#define inf (1<<28)\n#define ll long long\n#define db double\n#define c233 cout<<\"233\"<<endl\n#define mem(s) memset(s,0,sizeof(s))\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\nconst int N=205;\nconst int M=1050;\nusing namespace std;\n\nint l[N][N],s[N][N],dp[M][N],way[M];\nint n,m,r,ans;\n\nvoid fre(){\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n}\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=(x<<1)+(x<<3)+ch-48,ch=getchar();\n  return x*res;\n}\n\nvoid init(){\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      l[i][j]=s[i][j]=inf;\n  for(int i=1;i<=n;i++)\n    l[i][i]=s[i][i]=0;\n  for(int i=1;i<=m;i++){\n    int a,b,c;\n    char d;\n    scanf(\"%d%d%d %c\",&a,&b,&c,&d);\n    if(d=='L')l[a][b]=l[b][a]=min(l[a][b],c);\n    if(d=='S')s[a][b]=s[b][a]=min(s[a][b],c);\n  }\n  r=gi();\n  for(int i=1;i<=r;i++)\n    way[i]=gi();\n}\n\nvoid pre(){\n  for(int k=1;k<=n;k++)\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++){\n\tl[i][j]=min(l[i][j],l[i][k]+l[k][j]);\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n      }\n  for(int i=1;i<=r;i++)\n    for(int j=1;j<=n;j++)\n      dp[i][j]=inf;\n  ans=inf;\n}\n\nvoid work(){\n  dp[1][way[1]]=0;\n  for(int i=2;i<=r;i++)\n    for(int j=1;j<=n;j++){\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+l[way[i-1]][way[i]]);\n      for(int k=1;k<=n;k++)\n\tdp[i][j]=min(dp[i][j],dp[i-1][k]+l[way[i-1]][k]+s[k][j]+l[j][way[i]]);\n    }\n  for(int i=1;i<=n;i++)\n    ans=min(ans,dp[r][i]);\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  //fre();\n  while(1){\n    n=gi();m=gi();\n    if(n==0&&m==0)break;\n    init();\n    pre();\n    work();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\n\nstruct state{\n    ll ship,dist;\n};\n\nint main(){\n    ll N,M,R;\n    ll inf = 1e18;\n    while(cin >> N >> M && N){\n        vector<vector<ll>> L(N+1,vector<ll>(N+1,inf)),S(N+1,vector<ll>(N+1,inf));\n        ll x,y,t;\n        char c;\n        for(int i=0;i<M;i++){\n            cin >> x >> y >> t >> c;\n            if(c=='L'){\n                L[x][y] = min(L[x][y],t);\n                L[y][x] = min(L[y][x],t);\n            }else{\n                S[x][y] = min(S[x][y],t);\n                S[y][x] = min(S[y][x],t);\n            }\n        }\n        for(int i=1;i<=N;i++){\n            L[i][i] = 0;\n            S[i][i] = 0;\n        }\n        for(int k=1;k<=N;k++) for(int i=1;i<=N;i++) for(int j=1;j<=N;j++){\n            L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n            S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n        }\n        cin >> R;\n        vector<ll> Z(R+1,0);\n        for(int i=1;i<=R;i++) cin >> Z[i];\n        queue<state> Q[2];\n        Q[1].push({Z[1],0});\n        for(int t=1;t<=R-1;t++){\n            vector<ll> mi(N+1,inf);\n            while(!Q[t%2].empty()){\n                state now = Q[t%2].front(); Q[t%2].pop();\n                for(int g=1;g<=N;g++){\n                    if(L[g][Z[t+1]]==inf) continue;\n                    if(S[now.ship][g]!=inf){\n                        ll d = now.dist+L[Z[t]][now.ship]+S[now.ship][g]+L[g][Z[t+1]];\n                        mi[g] = min(mi[g],d);\n                    }\n                }\n                if(L[Z[t]][Z[t+1]]!=inf) mi[now.ship] = min(mi[now.ship],now.dist+L[Z[t]][Z[t+1]]);\n            }\n            for(int i=1;i<=N;i++) if(mi[i]!=inf) Q[1-t%2].push({i,mi[i]});\n        }\n        ll ans = inf;\n        while(!Q[R%2].empty()){\n            ans = min(ans,Q[R%2].front().dist);\n            Q[R%2].pop();\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF (1e9)\n#define M 1005\n#define N 205\nusing namespace std;\ntypedef long long ll;\n\nll n,m,r,z[M],sld[2][N][N];\n\nvoid init(){\n  rep(i,2)\n    rep(j,n)\n      rep(k,n)\n        sld[i][j][k]=INF; \n}\n\nvoid add_edge(ll sl,ll x,ll y,ll t){\n  sld[sl][x][y]=sld[sl][y][x]=min(sld[sl][x][y],t);\n}\n\nvoid warshall_floyd(){\n  rep(sl,2) rep(k,n) rep(i,n) rep(j,n)\n    sld[sl][i][j]=min(sld[sl][i][j],sld[sl][i][k]+sld[sl][k][j]);\n  rep(sl,2)\n    rep(i,n)sld[sl][i][i]=0;\n}\n\nll dp[M][N];\n\nvoid solve(){\n  rep(i,r)\n    rep(j,n)dp[i][j]=INF;\n  dp[0][z[0]]=0;\n  \n  rep(i,r-1)\n    rep(j,n){\n      if(dp[i][j]==INF)continue;\n      ll cost=dp[i][j]+sld[0][z[i]][z[i+1]];\n      dp[i+1][j]=min(dp[i+1][j],cost);\n      rep(k,n){\n\tll cost2=dp[i][j]+sld[0][z[i]][j];\n\tcost2+=sld[1][j][k]+sld[0][k][z[i+1]];\n\tdp[i+1][k]=min(dp[i+1][k],cost2);\n      }\n    }\n  \n  ll ans=INF;\n  rep(i,n)ans=min(ans,dp[r-1][i]);\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    ll x,y,t;\n    char sl;\n    \n    init();\n    \n    rep(i,m){\n      cin>>x>>y>>t>>sl;\n      x--,y--;\n      if(sl=='L')add_edge(0,x,y,t);\n      else add_edge(1,x,y,t);\n    }\n    \n    warshall_floyd();\n \n    cin>>r;\n    rep(i,r)cin>>z[i],z[i]--;\n    \n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\n\nconst int N   = 200;\nconst ll inf =(1LL<<58);\n\nll land[N][N];\nll sea[N][N];\n\nvoid wf(int n,ll mat[N][N]){\n  rep(k,n)rep(i,n)rep(j,n)mat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);\n}\n\n\nll dp[1000][N];\nll solve(int n,vector<int> &in,int s){\n  wf(n,land);\n  wf(n,sea);\n  rep(i,in.size())rep(j,n)dp[i][j]=inf;\n//   rep(i,n){\n//     rep(j,n){\n//       dp[0][j]=min(dp[0][j],land[s][i]+sea[i][j]+land[j][in[0]]);\n//       cout << dp[0][j] << endl;\n//     }\n//   }\n\n  dp[0][s]=0;\n\n  REP(i,1,in.size()){\n    rep(j,n){\n      rep(k,n){\n\tdp[i][k]=min(dp[i][k],\n\t\t     dp[i-1][j]+land[in[i-1]][j]+sea[j][k]+land[k][in[i]]);\n\tdp[i][k]=min(dp[i][k],dp[i-1][k]+land[in[i-1]][in[i]]);\n      }\n    }\n  }\n\n  ll ret = inf;\n  rep(i,n)ret=min(ret,dp[n-1][i]);\n  return ret;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n){\n      rep(j,n)sea[i][j]=land[i][j]=inf;\n      sea[i][i]=0;land[i][i]=0;\n    }\n    rep(i,m){\n      int f,t;ll c;char tmp;\n      cin>>f>>t>>c>>tmp;\n      f--;t--;\n      if (tmp == 'L')land[f][t]=land[t][f]=min(land[t][f],c);\n      if (tmp == 'S')sea[f][t] =sea[t][f] =min( sea[t][f],c);\n    }\n\n\n    int q;\n    cin>>q;\n    vector<int> in(q);\n    rep(i,q)cin>>in[i],in[i]--;\n    cout << solve(n,in,in[0]) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF (1e9)\n#define M 1005\n#define N 205\nusing namespace std;\ntypedef pair<int,char> P;\ntypedef pair<int,P> P1;\ntypedef pair<int,int> P2;\ntypedef pair<P2,P2> P3;\n\nvector<P1> G[N];\nint n,m,r,z[M];\n\nint d[N][N][M];\n\nint dijkstra(){\n  priority_queue<P3,vector<P3>,greater<P3> > q;\n  \n  d[0][0][0]=0;\n  q.push(P3(P2(0,0),P2(0,0)));\n\n  while(!q.empty()){\n    P3 t=q.top(); q.pop();\n    \n    int cost=t.first.first;\n    int hune=t.first.second;\n    int node=t.second.first;\n    int Z=t.second.second;\n    \n    if(Z==r-1)return cost;\n    if(cost>d[hune][node][Z])continue;\n\n    rep(i,G[node].size()){\n      int ncost=cost+G[node][i].second.first;\n      char sl=G[node][i].second.second;\n      int nnode=G[node][i].first;\n      int nhune=hune;\n      int nZ=Z;      \n      \n      if(sl=='S'&&hune!=node)continue;\n      if(z[Z+1]==nnode)nZ++;\n      if(sl=='S')nhune=nnode;\n\n      if(d[nhune][nnode][nZ]>ncost){\n\td[nhune][nnode][nZ]=ncost;\n\tq.push(P3(P2(ncost,nhune),P2(nnode,nZ)));\n      }\n    }\n    \n  }\n  \n  return INF;\n}\n\nint main(){\n  \n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    \n    int x,y,t;\n    char sl;\n    \n    rep(i,m){\n      cin>>x>>y>>t>>sl;\n      G[x-1].push_back(P1(y-1,P(t,sl)));\n      G[y-1].push_back(P1(x-1,P(t,sl)));\n    }\n    \n    cin>>r;\n    rep(i,r)cin>>z[i],z[i]--;\n\n    rep(i,n) rep(j,n) rep(k,M) d[i][j][k]=INF;\n    \n    cout<<dijkstra()<<endl;\n    \n    rep(i,n)G[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  Created by Running Photon on 2015-04-09\n//  Copyright (c) 2015 Running Photon. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n#define ll long long\n#define CLR(x) memset(x, 0, sizeof x)\nusing namespace std;\nconst int inf = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int maxn = 4e4 + 10;\n\nint n, m, num, a[1005];\nint dp[1005][205];\nint costl[205][205];\nint costs[205][205];\nint main() {\n#ifdef LOCAL\n\tfreopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n\tios_base::sync_with_stdio(0);\n\n\twhile(scanf(\"%d%d\", &n, &m) != EOF && (n && m)){\n\t\tfor(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){\n\t\t\tcosts[i][j] = costl[i][j] = i == j ? 0 : inf / 3;\n\t\t}\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tint u, v, val; char s[2];\n\t\t\tscanf(\"%d%d%d%s\", &u, &v, &val, s);\n\t\t\tif(s[0] == 'L') costl[u][v] = costl[v][u] = min(val, costl[v][u]);\n\t\t\telse costs[u][v] = costs[v][u] = min(val, costs[v][u]);\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\tfor(int i = 1; i <= num; i++) scanf(\"%d\", &a[i]);\n\t\tfor(int k = 1; k <= n; k++) for(int i = 1; i <= n; i++) for(int j = 1; j <= n; j++){\n\t\t\tcosts[i][j] = min(costs[i][j], costs[i][k] + costs[k][j]);\n\t\t\tcostl[i][j] = min(costl[i][j], costl[i][k] + costl[k][j]);\n\t\t}\n\t\tmemset(dp, 0x3f, sizeof dp);\n\t\tdp[1][a[1]] = 0;\n\t\tfor(int i = 1; i <= num; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + costl[a[i-1]][a[i]]);\n\t\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + costl[a[i-1]][j] + costs[j][k] + costl[k][a[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[num][i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 26)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nint Shortest(int start, int goal, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[goal];\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i <= MAX_R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Shortest(Z[i - 1], j, \"Land\");\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Shortest(j, k, \"Sea\");\n\n\t\t\t\t\t\tint Land_2 = Shortest(k, Z[i], \"Land\");\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 200;\nconst int INF = (1<<28);\n\nint n, m, r, G[2][N][N], z[1000];\n\nvoid floyd(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        for(int l=0;l<2;l++){\n          G[l][i][j] = min(G[l][i][j], G[l][i][k] + G[l][k][j]);\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    fill(G[0][0], G[2][0], INF);\n    for(int i=0;i<n;i++) G[0][i][i] = G[1][i][i] = 0;\n    for(int i=0;i<m;i++){\n      int a, b, c, e;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--; b--;\n      e = (d == 'L' ? 0 : 1);\n      G[e][a][b] = min(G[e][a][b], c);\n      G[e][b][a] = min(G[e][b][a], c);\n    }\n    cin >> r;\n    for(int i=0;i<r;i++) cin >> z[i];\n    for(int i=0;i<r;i++) z[i]--;\n    floyd();\n    int dp[1000][N];\n    fill(dp[0], dp[1000], INF);\n    dp[0][z[0]] = 0;\n    for(int i=0;i+1<r;i++){\n      for(int j=0;j<N;j++){\n        if(dp[i][j] >= INF) continue;\n        dp[i+1][j] = min(dp[i+1][j], dp[i][j] + G[0][z[i]][z[i+1]]);\n        for(int k=0;k<N;k++){\n          int cost = G[0][z[i]][j] + G[1][j][k] + G[0][k][z[i+1]];\n          dp[i+1][k] = min(dp[i+1][k], dp[i][j] + cost);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<N;i++) ans = min(ans, dp[r-1][i]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nint dijkstra(){\n  vector<vector<int> > D(n+1,vector<int>(r+1,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(cost<0)assert(0);\n    if(idx==r-1)return cost;\n    if(D[ship][idx]<cost) continue;\n    \n    int npos=z[idx+1];\n    int ncost=cost+G[pos][npos][0];\n    if(pos!=ship&&D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    \n    for(int i=0;i<n&&ship==pos;i++){\n      ncost=cost+G[pos][i][1]+G[i][npos][0];\n      if(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n    }\n  }\n  return -1;  \n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        if(i != next){\n          dp[r][next] = min(dp[r][next], dp[r-1][i] + G2[i][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return weight<e.weight;}\n\tbool operator>(const Edge& e)const{return weight>e.weight;}\n};\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tvvi gl(n,vi(n,INFTY)),gs(n,vi(n,INFTY)); // 陸路，海路\n\t\trep(i,n) gl[i][i]=gs[i][i]=0;\n\t\trep(i,m){\n\t\t\tint s,d,w; char sl; cin>>s>>d>>w>>sl; s--,d--;\n\t\t\tif(sl=='L' && gl[s][d]>w) gl[s][d]=gl[d][s]=w;\n\t\t\tif(sl=='S' && gs[s][d]>w) gs[s][d]=gs[d][s]=w;\n\t\t}\n\t\tint r; cin>>r;\n\t\tvi route(r);\n\t\trep(i,r) cin>>route[i],route[i]--;\n\t\t\n\t\t// warshall-floyd\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tgl[i][j]=min(gl[i][j],gl[i][k]+gl[k][j]);\n\t\t\tgs[i][j]=min(gs[i][j],gs[i][k]+gs[k][j]);\n\t\t}\n\t\t\n\t\tvvi dp(r,vi(n,INT_MAX/5)); // [集配先][船の位置]\n\t\tdp[0][0]=0;\n\t\trepi(i,1,r){\n\t\t\trep(j,n)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+gl[route[i-1]][route[i]]);\n\t\t\trep(j,n) rep(k,n)\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+gl[route[i-1]][j]+gs[j][k]+gl[k][route[i]]);\n\t\t}\n\t\tcout<<*min_element(all(dp[r-1]))<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nstatic const int MAX_N = 200;\nstatic const int MAX_R = 1000;\nstatic const int INF = 1 << 20;\n\nint N, M;\nint x, y, t; char sl;\nint R;\nint z[MAX_R];\n\nint dist1[MAX_N][MAX_N], dist2[MAX_N][MAX_N];\nint memo[MAX_R][MAX_N];\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d %d\", &N, &M);\n\t\tif(N == 0 && M == 0) break;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == j){\n\t\t\t\t\tdist1[i][j] = 0;\n\t\t\t\t\tdist2[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdist1[i][j] = INF;\n\t\t\t\t\tdist2[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tdist1[x][y] = min(dist1[x][y], t);\n\t\t\t\tdist1[y][x] = min(dist1[y][x], t);\n\t\t\t}else if(sl == 'S'){\n\t\t\t\tdist2[x][y] = min(dist2[x][y], t);\n\t\t\t\tdist2[y][x] = min(dist2[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tif(dist1[i][j] > dist1[i][k] + dist1[k][j]) dist1[i][j] = dist1[i][k] + dist1[k][j];\n\t\t\t\t\tif(dist2[i][j] > dist2[i][k] + dist2[k][j]) dist2[i][j] = dist2[i][k] + dist2[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &R);\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tscanf(\"%d\", &z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\tfill(memo[0], memo[R], INF);\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i == 0){\n\t\t\t\t\tif(j == z[i]) memo[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tmemo[i][j] = min(memo[i][j], min(memo[i - 1][j] + dist1[z[i - 1]][z[i]], INF));\n\t\t\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\t\tmemo[i][k] = min(memo[i][k], min(memo[i - 1][j] + dist1[z[i - 1]][j] + dist2[j][k] + dist1[k][z[i]], INF));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i = 0; i < N; i++) res = min(res, memo[R - 1][i]);\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nconstexpr ll LL_INF = 1e15;\n\nll dist1[200][200], dist2[200][200];\nll dp[1000][200];\n\n/*\n * 2 <= N <= 200\n * 1 <= M <= 10000\n * 1 <= xi, yi <= N\n * 1 <= ti <= 1000\n * 1 <= R <= 1000\n * 1 <= zi <= N\n */\n\nint main(void) {\n    while (true) {\n        int i, j, k, n, m;\n        scanf(\"%d%d\",&n,&m);\n        if (n == 0 && m == 0) break;\n        REP (i,n) REP (j,n) {\n            dist1[i][j] = i == j ? 0 : LL_INF;\n            dist2[i][j] = i == j ? 0 : LL_INF;\n        }\n        REP (i,m) {\n            int x, y, t;\n            char sl;\n            scanf(\"%d %d %d %c\",&x,&y,&t,&sl);\n            x--; y--;\n            if (sl == 'S') {\n                dist1[x][y] = min<ll>(dist1[x][y],t);\n                dist1[y][x] = dist1[x][y];\n            }\n            else {\n                dist2[x][y] = min<ll>(dist2[x][y],t);\n                dist2[y][x] = dist2[x][y];\n            }\n        }\n        REP (k,n) REP (i,n) REP (j,n) {\n            dist1[i][j] = min(dist1[i][j],dist1[i][k] + dist1[k][j]);\n            dist2[i][j] = min(dist2[i][j],dist2[i][k] + dist2[k][j]);\n        }\n        int r;\n        scanf(\"%d\",&r);\n        int pre;\n        cin >> pre;\n        pre--;\n        REP (i,0,r) REP (j,n) dp[i][j] = LL_INF;\n        dp[0][pre] = 0;\n        REP (i,r-1) {\n            int x;\n            scanf(\"%d\",&x);\n            x--;\n            REP (j,n) REP (k,n) dp[i+1][j] = min(dp[i+1][j],dp[i][k] + dist2[pre][k] + dist1[k][j] + dist2[j][x]);\n            pre = x;\n        }\n        ll ans = LL_INF;\n        REP (j,n) ans = min(ans,dp[r-1][j]);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define ll long long\nusing namespace std;\n\nconst int N = 210;\n\nint n,m,cnt,p[N];\nll ans=1ll<<60,dis[N][N][2],dp[N][N];\n\nint gi() {\n  int x=0,o=1; char ch=getchar();\n  while(ch!='-' && (ch<'0' || ch>'9')) ch=getchar();\n  if(ch=='-') o=-1,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return o*x;\n}\n\nvoid init() {\n  ans=1<<30;\n  for(int i=0; i<=n; i++)\n    for(int j=0; j<=n; j++)\n      for(int k=0; k<2; k++)\n\tdis[i][j][k]=1ll<<30;\n}\n\nvoid floyed() {\n  for(int t=0; t<2; t++)\n    for(int k=1; k<=n; k++) \n      for(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++)\n\t  dis[i][j][t]=min(dis[i][j][t],dis[i][k][t]+dis[k][j][t]);\n}\n\nint main() {\n  freopen(\"!.in\",\"r\",stdin);\n  freopen(\"!.out\",\"w\",stdout);\n  while(scanf(\"%d%d\", &n, &m) && n+m) {\n    init();\n    for(int i=1; i<=m; i++) {\n      int x=gi(),y=gi(),z=gi(); char ch;\n      scanf(\"%c\", &ch);\n      if(ch=='L') dis[x][y][0]=dis[y][x][0]=z;\n      else dis[x][y][1]=dis[y][x][1]=z;\n    }\n    cnt=gi();\n    for(int i=1; i<=cnt; i++) p[i]=gi();\n    for(int i=1; i<=n; i++) dis[i][i][0]=dis[i][i][1]=0;\n    floyed();\n    for(int i=0; i<=cnt; i++)\n      for(int j=0; j<=n; j++)\n\tdp[i][j]=1<<30;\n    dp[0][1]=0,dis[0][1][0]=dis[0][1][1]=0;\n    for(int i=1; i<=cnt; i++)\n      for(int j=1; j<=n; j++) {\n\tdp[i][p[i]]=min(dp[i][p[i]],dp[i-1][j]+dis[p[i-1]][j][0]+dis[j][p[i]][1]);\n\tdp[i][j]=min(dp[i][j],min(dp[i-1][p[i-1]]+dis[p[i-1]][j][1]+dis[j][p[i]][0],min(dis[p[i-1]][j][1]+dis[j][p[i]][0],dis[p[i-1]][p[i]][0])+dp[i-1][j]));\n      }\n    for(int i=1; i<=n; i++) ans=min(ans,dp[n][i]);\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\nconst int INF=100000000;\n\n\nclass Node{\npublic:\n\tint now_mission,ship,sum;\n\tNode(int now_mission,int ship,int sum):now_mission(now_mission),ship(ship),sum(sum){};\n};\n\nbool operator < (Node a,Node b){\n\treturn a.sum>b.sum;\n}\n\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tvector<vector<int> > dist_ground(N,vector<int>(N,INF));\n\t\tvector<vector<int> > dist_sea(N,vector<int>(N,INF));\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y,t; char c;\n\t\t\tcin>>x>>y>>t>>c;\n\t\t\tx--;y--;\n\t\t\tif(c=='L'){\n\t\t\t\tdist_ground[x][y]=min(dist_ground[x][y],t);\n\t\t\t\tdist_ground[y][x]=min(dist_ground[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdist_sea[x][y]=min(dist_sea[x][y],t);\n\t\t\t\tdist_sea[y][x]=min(dist_sea[y][x],t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdist_sea[i][i]=dist_ground[i][i]=0;\n\t\t}\n\t\tint R;cin>>R;\n\t\tvector<int> mission(R);\n\t\tfor(int i=0;i<R;i++){cin>>mission[i];mission[i]--;}\n\n\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tdist_sea[i][j]=min(dist_sea[i][j],dist_sea[i][k]+dist_sea[k][j]);\n\t\t\t\t\tdist_ground[i][j]=min(dist_ground[i][j],dist_ground[i][k]+dist_ground[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpriority_queue<Node> que;\n\t\tvector<vector<int> > memo(R,vector<int>(N,INF));\n\t\tque.push(Node(0,mission[0],0));\n\n\t\twhile(!que.empty()){\n\t\t\tNode info=que.top(); que.pop();\n\t\t\tif(info.sum>=memo[info.now_mission][info.ship]) continue;\n//\t\t\tcout<<\"now \"<<info.now_mission<<\" \"<<info.ship<<\" \"<<info.sum<<endl;\n\t\t\tmemo[info.now_mission][info.ship]=info.sum;\n\n\t\t\tif(info.now_mission==R-1){cout<<info.sum<<endl;break;}\n\t\t\tint target=mission[info.now_mission+1];\n\t\t\t\n\t\t\tint now_area=mission[info.now_mission];\n\t\t\tque.push(Node(info.now_mission+1,info.ship,info.sum+dist_ground[now_area][target]));\n\n\t\t\tfor(int relay=0;relay<N;relay++){\n\t\t\t\tint next_cost=dist_ground[now_area][info.ship]+dist_sea[info.ship][relay]+dist_ground[relay][target];\n\t\t\t\tif(next_cost<INF)\n\t\t\t\t\tque.push(Node(info.now_mission+1,relay,info.sum+next_cost));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) {\n  for (int k = 1; k <= n; ++k) {\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while (scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n\n    while (m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if (tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n    b[0] = 1;\n    for (int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    d[0][1] = 0;\n    for (int i = 2; i <= n; ++i) {\n      d[0][i] = min(d[0][i], s[1][i] + l[i][1]);\n    }\n\n    for (int i = 1; i <= r; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (l[j][b[i]] >= INF) continue;\n        for (int k = 1; k <= n; ++k) {\n          if (d[i - 1][k] >= INF) continue;\n          if (j == k) {\n            if (l[b[i - 1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][b[i]]);\n            }\n          } else {\n            if (l[b[i - 1]][k] < INF && s[k][j] < INF && l[j][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <cstring>\n#include <cstdio>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = INT_MAX/3;\nint riku[210][210];\nint umi[210][210];\nint dp[1010][210]; // [ツ妥ョツ配][ツ船ツづ個暗環置]\n\nint main(){\n  int n,m;\n  int taku[1010];\n\n  while(cin>>n>>m,n|m){\n    //init\n    rep(i,210)rep(j,210)riku[i][j]=umi[i][j]=inf;\n    rep(i,210)riku[i][i]=umi[i][i]=0;\n    rep(i,1010)rep(j,210)dp[i][j]=inf;\n\n    rep(i,m){\n      int a,b,c; char l;\n      scanf(\" %d %d %d %c \",&a,&b,&c,&l);\n      a--, b--;\n      if( l=='S' ){\n\tint d = min(umi[a][b],c);\n\tumi[a][b] = umi[b][a] = d;\n      }else{\n\tint d = min(riku[a][b],c);\n\triku[a][b] = riku[b][a] = d;\n      }\n    }\n    int R; cin>>R;\n    rep(i,R){\n      int r; cin>>r; r--;\n      taku[i] = r;\n    }\n\n    // worshal\n    rep(k,n)rep(i,n)rep(j,n){\n      if( riku[i][k]!=inf && riku[k][j]!=inf ){\n\triku[i][j] = min(riku[i][j], riku[i][k]+riku[k][j]);\n      }\n      if( umi[i][k]!=inf && umi[k][j]!=inf ){\n\tumi[i][j] = min(umi[i][j], umi[i][k]+umi[k][j]);\n      }\n    }\n\n    dp[1][taku[0]] = 0;\n    REP(r,1,R){\n      int v = taku[r-1];\n      int u = taku[r];\n      rep(j,n){\n\tif( riku[v][u]!=inf ) dp[r+1][j] = min(dp[r+1][j], dp[r][j]+riku[v][u]);\n\tif( riku[v][j]==inf ) continue;\n\trep(i,n){\n\t  if( umi[j][i]==inf || riku[i][u]==inf )continue;\n\t  dp[r+1][i] = min(dp[r+1][i], dp[r][j]+riku[v][j]+umi[j][i]+riku[i][u]);\n\t}\n      }\n    }\n    int ans = inf;\n    rep(i,n)ans=min(ans,dp[R][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvll land;\n\t\tvvll sea;\n\t\tinitvv(land,n,n,INFL);\n\t\tinitvv(sea,n,n,INFL);\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tll c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L') land[a][b]=mins(land[b][a],c);\n\t\t\telse sea[a][b]=mins(sea[b][a],c);\n\t\t}\n\t\trep(i,2) rep(j,n) land[j][j]=sea[j][j]=0;\n\t\trep(k,n) rep(i,n) rep(j,n) mins(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n) rep(i,n) rep(j,n) mins(sea[i][j],sea[i][k]+sea[k][j]);\n\t\tint r;\n\t\tcin>>r;\n\t\tvint v(r);\n\t\trep(i,r){\n\t\t\tcin>>v[i],v[i]--;\n\t\t}\n\t\tvll pre(n,INFL);\n\t\tpre[v[0]]=0;\n\t\trep(i,r-1){\n\t\t\tvll dp(n,INFL);\n\t\t\trep(k,n){\n\t\t\t\trep(l,n){\n\t\t\t\t\tmins(dp[l],pre[k]+land[v[i]][k]+sea[k][l]+land[l][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp,pre);\n\t\t}\n\t\tcout<< *min_element(ALL(pre))<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nint land[200][200];\nint sea[200][200];\n\nint n;\nint R,z[1000];\n\nconst int INF = 0x0f0f0f0f;\t\n\nint memo[200][1000];\nint Solve(int boat, int index)\n{\n\tif(index >= R)\n\t\treturn 0;\n\tint &ref = memo[boat][index];\n\tif(ref >= 0)\n\t\treturn ref;\n\tint from = z[index-1];\n\tint to = z[index];\n\n\tref = land[from][to] + Solve(boat,index+1);\n\n\tfor(int i=0;i<n;++i)\n\t\tref = min(ref, land[from][boat]+sea[boat][i]+land[i][to] + Solve(i,index+1));\n\treturn ref;\n}\n\nint main()\n{\n\tint m,i,j,k;\n\tint x,y,t;\n\tchar c;\n\twhile(scanf(\"%d%d\",&n,&m),n)\n\t{\n\t\tmemset(land,INF,sizeof(land));\n\t\tmemset(sea,INF,sizeof(sea));\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tland[i][i]=0;\n\t\t\tsea[i][i]=0;\n\t\t}\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&t,&c);\n\t\t\t--x,--y;\n\t\t\tif(c=='L')\n\t\t\t\tland[y][x]=land[x][y] = min(land[y][x],t);\n\t\t\telse\n\t\t\t\tsea[y][x]=sea[x][y] = min(sea[y][x],t);\n\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(i=0; i<R; ++i)\n\t\t{\n\t\t\tscanf(\"%d\",z+i);\n\t\t\t--z[i];\n\t\t}\n\n\t\tfor(k=0;k<n;++k)\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tfor(j=0;j<n;++j)\n\t\t\t\t{\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j],sea[i][k] +sea[k][j]);\n\t\t\t\t}\n\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tprintf(\"%d\\n\",Solve(z[0],1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1ll<<55;\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n+m){\n        vector<vector<ll>> l(n, vector<ll>(n, INF)), s(n, vector<ll>(n, INF));\n        for(int i = 0; i < n; i++)  l[i][i] = s[i][i] = 0;\n\n        for(int i = 0; i < m; i++){\n            ll x, y, t;\n            string z;\n            cin >> x >> y >> t >> z;\n            x--, y--;\n            if(z == \"S\"){\n                ll to = min(s[x][y], t);\n                s[x][y] = s[y][x] = to;\n            }else{\n                ll to = min(l[x][y], t);\n                l[x][y] = l[y][x] = to;\n            }\n        }\n\n        // 陸のみ,海のみを通ったときの全点対間最短距離\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    l[i][j] = min(l[i][j], l[i][k]+l[k][j]);\n                    s[i][j] = min(s[i][j], s[i][k]+s[k][j]);\n                }\n            }\n        }\n\n        int r;\n        cin >> r;\n        vector<int> z(r);\n        for(int i = 0; i < r; i++)  cin >> z[i], z[i]--;\n\n        // dp[i][j] := 船をjに置いてz[i]まで到達した時のコスト\n        vector<vector<ll>> dp(r, vector<ll>(n, INF));\n        dp[0][z[0]] = 0;\n\n        // 最初の町にいるときの船の位置を全て試す\n        for(int i = 0; i < n; i++){\n            if(s[z[0]][i] != INF && l[i][z[0]] != INF){\n                dp[0][i] = min(dp[0][i], s[z[0]][i]+l[i][z[0]]);\n            }\n        }\n\n        for(int i = 1; i < r; i++){\n            // z[i-1] --(land)--> z[i]\n            for(int j = 0; j < n; j++){\n                dp[i][j] = min(dp[i][j], dp[i-1][j]+l[z[i-1]][z[i]]);\n            }\n            // z[i-1] --(land)-> j --(sea)-> k --(land)-> z[i]\n            for(int j = 0; j < n; j++){\n                for(int k = 0; k < n; k++){\n                    dp[i][k] = min(dp[i][k], dp[i-1][j] + l[z[i-1]][j]+s[j][k]+l[k][z[i]]);\n                }\n            }\n        }\n\n        ll ans = INF;\n        for(int i = 0; i < n; i++)  ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define rep(i, n)     for(auto i = 0; i != n; ++i)\n#define REP(i, k, n)  for(auto i = k; i != n; ++i)\n//#define rrep(i, n)    for(auto i = n; i != 0; --i)\n#define RREP(i, n, k) for(auto i = n; i != k; --i)\n\n#define debug(x) cerr << #x << \" \" << x << endl\n#define spc << \" \" <<\n\n#define mp make_pair\n#define mt make_tuple\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Tiii = tuple<int, int, int>;\ntemplate<typename T>using V = vector<T>;\nusing Vi = vector<int>;\nusing VVi = vector<vector<int>>;\n\nint n, m;\n//Vi z;\n//VVi GNDcost;  // from, to\n//VVi SEAcost;  // from, to\n\nVVi dp;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n >> m, n) {\n        VVi GNDcost = VVi(n+1, Vi(n+1, INT_MAX));\n        VVi SEAcost = VVi(n+1, Vi(n+1, INT_MAX));\n\n        REP(mi, 1, m+1) {\n            int x, y, t; char sl; cin >> x >> y >> t >> sl;\n            if (sl == 'L') {\n                GNDcost[x][y] = min(GNDcost[x][y], t);\n                GNDcost[y][x] = min(GNDcost[y][x], t);\n            } else {\n                SEAcost[x][y] = min(SEAcost[x][y], t);\n                SEAcost[y][x] = min(SEAcost[y][x], t);\n            }\n        }\n\n        REP(via, 1, n+1) {\n            REP(from, 1, n+1) {\n                REP(to, 1, n+1) {\n                    if (from == to) GNDcost[from][to] = 0;\n                    else if (GNDcost[from][via] != INT_MAX && GNDcost[via][to] != INT_MAX) {\n                        GNDcost[from][to] = min(GNDcost[from][to],\n                                GNDcost[from][via] + GNDcost[via][to]);\n                    }\n                }\n            }\n        }\n\n        REP(via, 1, n+1) {\n            REP(from, 1, n+1) {\n                REP(to, 1, n+1) {\n                    if (from == to) SEAcost[from][to] = 0;\n                    else if (SEAcost[from][via] != INT_MAX && SEAcost[via][to] != INT_MAX) {\n                        SEAcost[from][to] = min(SEAcost[from][to],\n                                SEAcost[from][via] + SEAcost[via][to]);\n                    }\n                }\n            }\n        }\n\n        int R; cin >> R;\n        Vi z = Vi(R+1); REP(r, 1, R+1) cin >> z[r];\n        dp = VVi(R+1, Vi(n+1, INT_MAX));\n\n        REP(ship, 1, n+1) {\n            if (SEAcost[z[1]][ship] != INT_MAX && GNDcost[z[1]][ship] != INT_MAX)\n                dp[1][ship] = SEAcost[z[1]][ship] + GNDcost[z[1]][ship];\n        }\n\n        REP(p, 1, R) {\n            int cur_pos = z[p];\n            int next_pos = z[p+1];\n            if (GNDcost[cur_pos][next_pos] != INT_MAX) {\n                REP(ship_pos, 1, n+1) {\n                    if (dp[p][ship_pos] != INT_MAX) {\n                        dp[p+1][ship_pos] = dp[p][ship_pos] + GNDcost[cur_pos][next_pos];\n                        if (dp[p][ship_pos] + GNDcost[cur_pos][next_pos] < 0) {\n                            cout << \"overflowed \" << p+1 spc ship_pos << endl;\n                            return 119;\n                        }\n                    }\n                }\n            }\n\n            REP(ship_to, 1, n+1) {\n                REP(ship_from, 1, n+1) {\n                    if (dp[p][ship_from] == INT_MAX) continue;\n\n                    int get_ship_time = GNDcost[cur_pos][ship_from];\n                    int shipping_time = SEAcost[ship_from][ship_to];\n                    int after_ship_time = GNDcost[ship_to][next_pos];\n                    if (get_ship_time==INT_MAX || shipping_time==INT_MAX || after_ship_time==INT_MAX)\n                        continue;\n                    dp[p+1][ship_to] = min(dp[p+1][ship_to],\n                            dp[p][ship_from] + get_ship_time + shipping_time + after_ship_time);\n                    if (dp[p][ship_from] + get_ship_time + shipping_time + after_ship_time < 0) {\n                        cout << \"overflowed \" << p+1 spc ship_to << endl;\n                        return 118;\n                    }\n                }\n\n//                if (SEAcost[z[1]][ship_to] != INT_MAX && GNDcost[z[1]][ship_to] != INT_MAX)\n//                    dp[1][ship_to] = SEAcost[z[1]][ship_to] + GNDcost[z[1]][ship_to];\n            }\n        }\n\n\n//        REP(ship, 1, n+1) {\n//            REP(p, 1, R+1) {\n//                cout << std::setw(10) << dp[p][ship] << \" \";\n//            } cout << endl;\n//        }\n\n        int ans = INT_MAX;\n        REP(i, 1, n+1) {\n            ans = min(ans, dp[R][i]);\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf = (INT_MAX >> 2) - 5;\nconst int maxn = 205;\nconst int maxm = int(1e4 + 5);\n\nint sea[maxn][maxn], land[maxn][maxn];\nint a[maxn];            //aim\nint dp[maxm][maxn];     //dp[i][j] -> 处理完i个目标, 船在j位置的最短路\nint n, m, x, y, cost;\nchar c;\n\nvoid ini() {\n\n    for(int i = 0; i < maxn; i++) {\n        fill(sea[i], sea[i] + maxn, inf);\n        fill(land[i], land[i] + maxn, inf);\n        sea[i][i] = land[i][i] = 0;\n    }\n    for(int i = 0; i < maxm; i++)\n        fill(dp[i], dp[i] + maxn, inf);\n}\nvoid solve() {\n\n    ini();\n    while(m--) {\n        scanf(\"%d%d%d\", &x, &y, &cost);\n        cin >> c;\n        if(c == 'S') sea[x][y] = sea[y][x] = min(sea[x][y], cost);\n        else land[x][y] = land[y][x] = min(land[x][y], cost);\n    }\n    scanf(\"%d\", &m);\n    for(int i = 1; i <= m; i++) scanf(\"%d\", a + i);\n\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++) {\n                sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n                land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n            }\n\n    dp[1][a[1]] = 0;\n    for(int i = 2; i <= m; i++)     //处理到第i个目标\n        for(int j = 1; j <= n; j++) //上一次船停在j位置\n            if(dp[i - 1][j] != inf) {\n                //从 a[i - 1] 走陆路到 a[i]\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + land[a[i - 1]][a[i]]);\n\n                //从 a[i - 1] 走陆路到船的位置 j, 开到 k 位置再走陆路到 a[i]\n                for(int k = 1; k <= n; k++)\n                    dp[i][k] = min(dp[i][k], dp[i - 1][j] + land[a[i - 1]][j] + sea[j][k] + land[k][a[i]]);\n            }\n    printf(\"%d\\n\", *min_element(dp[m] + 1, dp[m] + n + 1));\n}\nint main() {\n\n//    freopen(\"in.txt\", \"r\", stdin);\n\n    while(cin >> n >> m, n or m) solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define ve vector\nconst int INF=0x1f3f3f3f;\n\nvoid floyd(vector<vector<int>> &a,int n){\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\ta[k][j]=a[j][k]=min(a[j][i]+a[i][k],a[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0 && m==0)break;\n\t\tvector<vector<int>> s(n+1,vector<int>(n+1,INF));\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ts[i][i]=0;\n\t\t}\n\t\tvector<vector<int>> l=s;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='S'){\n\t\t\t\ts[y][x]=s[x][y]=min(s[x][y],t);\n\t\t\t}\n\t\t\telse l[y][x]=l[x][y]=min(l[x][y],t);\n\t\t}\n\t\tfloyd(l,n);\n\t\tfloyd(s,n);\n\t\tint r;\n\t\tcin>>r;\n\t\tvector<int> z;\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tz.push_back(t);\n\t\t}\n\t\tve<ve<int>> dp(r,ve<int>(n+1,INF));\n\t\tdp[0][z[0]]=0;\n\t\tfor (int i = 1; i <= r-1; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=1;i<=n;i++)ret=min(ret,dp[r-1][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nconst int N = 222;\nconst int R = 1111;\n\ntypedef unsigned char uchar;\n\nclass E{\n\tpublic:\n\tuchar to;\n\tint cost;\n\tchar kind;\n\tE(uchar to,int cost,string kind):to(to),cost(cost),kind(kind[0]){}\n};\n\nint n,m;\nvector<E> edge[N];\nvector<int> move;\n\n\nbool init(){\n\tcin>>n>>m;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i].clear();\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring s;\n\t\tcin>>a>>b>>c>>s;\n\t\tedge[a].push_back(E(b,c,s));\n\t\tedge[b].push_back(E(a,c,s));\n\t}\n\t\n\tint r;\n\tcin>>r;\n\t\n\tmove.clear();\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\treturn true;\n}\n\nclass Q{\n\tpublic:\n\tint val;\n\tuchar pos,fune;\n\tshort num;\n\tQ(int pos,int num,int fune,int val):\n\t\tpos(pos),num(num),fune(fune),val(val){}\n\tbool operator<(const Q& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\nint visit[N][N];\n\nint dijk(){\n\t\n\trep(i,n+1)rep(k,n+1)visit[i][k]=0;\n\t\n\tpriority_queue<Q> que;\n\tque.push(Q(move[0],1,1,0));\n\t\n\twhile(!que.empty()){\n\t\tQ u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.pos][u.fune]>=u.num)continue;\n\t\tvisit[u.pos][u.fune]=u.num;\n\t\t\n\t\t//printf(\"**%d %d %d %d\\n\",u.pos,u.num,u.fune,u.val);\n\t\t\n\t\tint next = u.num;\n\t\tif(u.pos==move[u.num]){\n\t\t\tnext++;\n\t\t}\n\t\t\n\t\tif(next==n){\n\t\t\treturn u.val;\n\t\t}\n\t\t\n\t\tif(u.pos==u.fune){\n\t\t\trep(i,edge[u.pos].size()){\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.kind!='S')continue;\n\t\t\t\tif(visit[e.to][e.to]<next)\n\t\t\t\tque.push(Q(e.to, next, e.to, u.val+e.cost));\n\t\t\t}\n\t\t}\n\t\trep(i,edge[u.pos].size()){\n\t\t\tE e = edge[u.pos][i];\n\t\t\tif(e.kind!='L')continue;\n\t\t\tif(visit[e.to][u.fune]<next)\n\t\t\tque.push(Q(e.to, next, u.fune, u.val+e.cost));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint solve(){\n\treturn dijk();\n}\n\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 28;\n\nint main(){\n  int N, M;\n  int city[2][200][200];\n  int dp[1000][200];\n  int R, z[1000];\n\n  while(cin >> N >> M, N){\n    \n    fill_n( **city, 2 * 200 * 200, INF);\n    fill_n( *dp, 1000 * 200, INF);\n\n    for(int i = 0; i < M; i++){\n      int a, b, t;\n      char c;\n      cin >> a >> b >> t >> c;\n      a--, b--;\n      if(c == 'L'){\n        city[0][a][b] = city[0][b][a] = t;\n      }else{\n        city[1][a][b] = city[1][b][a] = t;\n      }\n    }\n    cin >> R;\n    for(int i = 0; i < R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    for(int l = 0; l < 2; l++){\n      for(int k = 0; k < N; k++){\n        city[l][k][k] = 0;\n        for(int i = 0; i < N; i++){\n          for(int j = 0; j < N; j++){\n            city[l][i][j] = min( city[l][i][j], city[l][i][k] + city[l][k][j]);\n          }\n        }\n      }\n    }\n    dp[0][z[0]] = 0;\n    for(int i = 0; i < R - 1; i++){\n      for(int j = 0; j < N; j++){ //船を止めてある場所\n        if(dp[i][j] == INF) continue;\n        for(int k = 0; k < N; k++){ //次船を止める場所\n          dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + city[0][z[i]][j] + city[1][j][k] + city[0][k][z[i + 1]]);\n        }\n      }\n    }\n    cout << *min_element( dp[R - 1], dp[R]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\n\nconst ll INF = 1e17;\n\nint main(){\n  ll n,m,r;\n  while(cin >> n >> m){\n    if(n==0)break;\n    vector< vi > sg(n,vi(n,INF)), lg(n,vi(n,INF));\n    rep(i,n)sg[i][i] = lg[i][i] = 0;\n\n    rep(i,m){\n      ll x,y,t;\n      string s;\n      cin >> x >> y >> t >> s; x--; y--;\n      if(s == \"L\")lg[x][y] = lg[y][x] = min(lg[x][y],t);\n      else sg[x][y] = sg[y][x] =  min(sg[x][y],t);\n    }\n\n    rep(k,n)rep(i,n)rep(j,n)lg[i][j] = min(lg[i][j], lg[i][k] + lg[k][j]);\n    rep(k,n)rep(i,n)rep(j,n)sg[i][j] = min(sg[i][j], sg[i][k] + sg[k][j]);\n\n    /*\n    rep(i,n){rep(j,n)cout << lg[i][j] << \" \"; cout << endl;}\n    rep(i,n){rep(j,n)cout << sg[i][j] << \" \"; cout << endl;}\n    */\n\n    cin >> r;\n    ll cur; cin >> cur; cur--;\n    vi dis(n,INF); dis[cur] = 0;\n\n    rep(z,r-1){\n      ll nxt; cin >> nxt; nxt--;\n      vi ndis(n,INF);\n\n      rep(i,n){\n\tndis[i] = min(ndis[i], dis[i] + lg[cur][nxt]);\n\trep(j,n){\n\t  ndis[j] = min(ndis[j], dis[i] + lg[cur][i] + sg[i][j] + lg[j][nxt]);\n\t}\n      }\n\n      dis = ndis;\n      cur = nxt;\n    }\n\n    cout << *min_element(dis.begin(), dis.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  int n, m;\n  long long int INF = 1e14;\n  while(cin >> n >> m, n){\n    vector< vector<long long int> > L(n, vector<long long int>(n, INF)), S = L;\n    int x, y, t;\n    char s;\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> t >> s;\n      --x;--y;\n      if(s == 'L'){\n        L[x][y] = t;\n        L[y][x] = t;\n      }else{\n        S[x][y] = t;\n        S[y][x] = t;\n      }\n    }\n    for(int i = 0; i < n; ++i){\n      S[i][i] = 0;\n      L[i][i] = 0;\n    }\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          L[i][j] = min(L[i][j], L[i][k] + L[k][j]);\n          S[i][j] = min(S[i][j], S[i][k] + S[k][j]);\n        }\n      }\n    }\n    /*\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", L[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", S[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n    int r;\n    cin >> r;\n    vector<int> Z(r);\n    for(int i = 0; i < r; ++i){\n      cin >> Z[i];\n      --Z[i];\n    }\n    vector< vector<long long int> > DP(r, vector<long long int>(n,INF));\n    DP[0][Z[0]] = 0;\n    for(int i = 1; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          DP[i][k] = min(DP[i][k], DP[i-1][j] + L[Z[i-1]][j] + S[j][k] + L[k][Z[i]]);\n          DP[i][k] = min(DP[i][k], DP[i-1][k] + L[Z[i-1]][Z[i]]);\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", DP[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i) ans = min(ans, DP[r-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\nTASK: A2200 - Mr. Rito Post Office\nLANG: C++\nNAME: untitled.cpp\n*/\n#include <cstdio>\n#include <algorithm>\n\n#define NMAX 200\n#define RMAX 1000\nconst int INTMAX=0x0fffffff;\n\nusing namespace std;\n\nint n,m,swim[NMAX][NMAX],walk[NMAX][NMAX],route[RMAX],memo[RMAX][NMAX];\nbool bay[NMAX];\n\nint func(int pos,int ship)\n{return 1;\n\tif(-1!=memo[pos][ship]){\n\t\treturn memo[pos][ship];\n\t}\n\tif(0==pos){\n\t\tint ret=INTMAX;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(bay[i]){\n\t\t\t\tret = min(ret,swim[0][ship]+walk[ship][route[pos]]);\n\t\t\t}\n\t\t}\n\t\tif(0==ship) ret = min(ret,walk[0][route[pos]]);\n\t\treturn memo[pos][ship]=ret;\n\t}\n\n\tint ret=INTMAX;\n\tfor(int i=0;i<n;i++){\n\t\tif(bay[i]){\n\t\t\tret = min(ret,func(pos-1,i)+walk[route[pos-1]][i]+swim[i][ship]+walk[ship][route[pos]]);\n\t\t}\n\t}\n\tret = min(ret,func(pos-1,ship)+walk[route[pos-1]][route[pos]]);\n\n\treturn memo[pos][ship]=ret;\n}\n\nvoid solve()\n{\n\tfill(bay,bay+n,false);\n\tfor(int i=0;i<n;i++){\n\t\tfill(swim[i],swim[i]+n,INTMAX);\n\t\tfill(walk[i],swim[i]+n,INTMAX);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tswim[i][i] = 0; walk[i][i] = 0;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,t; char sl; scanf(\"%d%d%d\\n%c\",&x,&y,&t,&sl); x--; y--;\n\t\tif('L'==sl){\n\t\t\twalk[x][y] = walk[y][x] = min(walk[x][y],t);\n\t\t}else if('S'==sl){\n\t\t\tswim[x][y] = swim[y][x] = min(swim[x][y],t);\n\t\t\tbay[x] = bay[y] = true;\n\t\t}\n\t}\n\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\twalk[i][j] = walk[j][i] = min(walk[i][j],walk[i][k]+walk[k][j]);\n\t\t\t\tswim[i][j] = swim[j][i] = min(swim[i][j],swim[i][k]+swim[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint r; scanf(\"%d\",&r);\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d\",route+i); route[i]--;\n\t}\n\n\tint ret=INTMAX;\n\tfor(int i=0;i<r;i++){\n\t\tfill(memo[i],memo[i]+n,-1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(bay[i]){\n\t\t\tret = min(ret,func(r-1,i));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\n\treturn;\n}\n\nint main()\n{\n\t/*FILE *fin=NULL,*fout=NULL;\n\tfin = freopen(\"input.txt\",\"r\",stdin);\n\tfout = freopen(\"output.txt\",\"w\",stdout);*/\n\n\t//DP+Warshall-Floyd\n\t//func(i,j):i番目の集配先まで、j番目の町に船を置いて到着する最短時間。\n\n\twhile(scanf(\"%d%d\",&n,&m),0!=n){\n\t\tsolve();\n\t}\n\n\t//finalize\n\t/*if(NULL!=fin) fclose(fin);\n\tif(NULL!=fout) fclose(fout);*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint d1[205][205],d2[205][205];\nint d[1005][205];\nint v[1005];\nint M=1061109567;\nint main()\n{\n\tint n,m,p;\n\tscanf(\"%d%d\",&n,&m);\n\twhile(n&&m){\n\tmemset(d1,0x3f,sizeof d1);\n\tmemset(d2,0x3f,sizeof d2);\n\tmemset(d,0x3f,sizeof d);\n\tfor(int i=1;i<=n;i++)\n\t\td1[i][i]=d2[i][i]=0;\n\tfor(int i=1;i<=m;i++){\n\t\tint a,b,d;\n\t\tchar c;\n\t\tscanf(\"%d%d%d %c\",&a,&b,&d,&c);\n\t\tif(c=='L'){\n\t\t\td1[a][b]=min(d1[a][b],d);\n\t\t\td1[b][a]=min(d1[b][a],d);\n\t\t}\n\t\telse{\n\t\t\td2[a][b]=min(d2[a][b],d);\n\t\t\td2[b][a]=min(d2[b][a],d);\n\t\t}\n\t}\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(d1[i][k]!=M&&d1[k][j]!=M&&d1[i][k]+d1[k][j]<d1[i][j])\n\t\t\t\t\td1[i][j]=d1[i][k]+d1[k][j];\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(d2[i][k]!=M&&d2[k][j]!=M&&d2[i][k]+d2[k][j]<d2[i][j])\n\t\t\t\t\td2[i][j]=d2[i][k]+d2[k][j];\n\tscanf(\"%d\",&p);\n\tfor(int i=1;i<=p;i++)\n\t\tscanf(\"%d\",&v[i]);\n\tv[0]=1;\n\td[0][1]=0;\n\tfor(int i=1;i<=p;i++){\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t//printf(\"%d %d %d %d %d\\n\",d[i-1][j],d1[v[i-1]][j],d2[j][k],d1[k][v[i]],d[i][k]);\n\t\t\t\tif(d[i-1][j]!=M&&d1[v[i-1]][j]!=M&&d2[j][k]!=M&&d1[k][v[i]]!=M&&d[i-1][j]+d1[v[i-1]][j]+d2[j][k]+d1[k][v[i]]<d[i][k])\n\t\t\t\t\td[i][k]=d[i-1][j]+d1[v[i-1]][j]+d2[j][k]+d1[k][v[i]];\n\t\t\t}\n\t}\n\tint ans=M;\n\tfor(int j=1;j<=n;j++)\n\t\tans=min(d[p][j],ans);\n\tprintf(\"%d\\n\",ans);\n\tscanf(\"%d%d\",&n,&m);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF 1LL<<60\ntypedef long long ll;\n\nint N, M;\n\nll d1[200][200]; // Land\nll d2[200][200]; // Sea\n\nll dp[1010][200];\n\nint R;\nint Z[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> M)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) rep(j, 0, N) d1[i][j] = d2[i][j] = INF;\n\t\trep(i, 0, N) d1[i][i] = d2[i][i] = 0;\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tint x, y, t; char sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\n\t\t\tif (sl == 'L')\n\t\t\t\td1[x][y] = d1[y][x] = t;\n\t\t\telse\n\t\t\t\td2[x][y] = d2[y][x] = t;\n\t\t}\n\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n\n\t\tcin >> R;\n\t\trep(i, 0, R) cin >> Z[i];\n\t\trep(i, 0, R) Z[i]--;\n\n\t\trep(i, 0, R) rep(j, 0, N) dp[i][j] = INF;\n\t\tdp[0][Z[0]] = 0;\n\n\t\trep(i, 0, R - 1) rep(j, 0, N) if (dp[i][j] != INF)\n\t\t{\n\t\t\tll dd = dp[i][j] + d1[Z[i]][Z[i + 1]];\n\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dd);\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tdd = dp[i][j] + d1[Z[i]][j] + d2[j][k] + d1[k][Z[i + 1]];\n\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dd);\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\trep(i, 0, N) ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define INF (1<<25)\n\nint ladj[205][205];\nint sadj[205][205];\n\nint main()\n{\n\tint N, M;\n\twhile(cin >> N >> M, (N||M))\n\t{\n\t\tint x,y,s;\n\t\tchar l;\n\t\tfor(int i=0; i<=N; i++)\n\t\tfor(int j=0; j<=N; j++)\n\t\t{\n\t\t\tif(i==j)\n\t\t\t{\n\t\t\t\tladj[i][j]=0;\n\t\t\t\tsadj[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tladj[i][j]=INF;\n\t\t\t\tsadj[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tcin >> x >> y >> s >> l;\n\t\t\tif(l=='L')\n\t\t\t{\n\t\t\t\tladj[x][y]=min(ladj[x][y], s);\n\t\t\t\tladj[y][x]=min(ladj[y][x], s);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tsadj[x][y]=min(sadj[x][y], s);\n\t\t\t\tsadj[y][x]=min(sadj[y][x], s);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=1; k<=N; k++)\n\t\tfor(int y=1; y<=N; y++)\n\t\tfor(int x=1; x<=N; x++)\n\t\t{\n\t\t\tint d=ladj[x][k]+ladj[k][y];\n\t\t\tif(d<ladj[x][y]) ladj[x][y]=d;\n\t\t\t\n\t\t\t    d=sadj[x][k]+sadj[k][y];\n\t\t\tif(d<sadj[x][y]) sadj[x][y]=d;\n\t\t}\n\t\t\n\t\tint R[1005],RN;\n\t\tcin >> RN;\n\t\tfor(int i=0; i<RN; i++)\n\t\t\tcin >> R[i];\n\t\t\t\n\t\tint dp[1005][202];\n\t\tfor(int i=0; i<RN; i++)\n\t\tfor(int j=0; j<=N; j++)\n\t\t\tdp[i][j]=INF;\n\t\t\t\n\t\tdp[0][R[0]]=0;\n\t\t\n\t\tfor(int i=1; i<RN; i++)\n\t\tfor(int j=1; j<=N; j++)\n\t\t{\n\t\t\tdp[i][j]=min(dp[i][j], dp[i-1][j]+ladj[R[i-1]][R[i]]);\n\t\t\tfor(int k=1; k<=N; k++)\n\t\t\t{\n\t\t\t\tdp[i][k]=min(dp[i][k], dp[i-1][j]+ladj[R[i-1]][j]+sadj[j][k]+ladj[k][R[i]]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans=INF;\n\t\tfor(int i=1; i<=N; i++)\n\t\t\tans=min(ans,dp[RN-1][i]);\n\t\tcout <<ans<< endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntypedef long long ll;typedef unsigned long long ull;\ntemplate <typename T>struct iindex {T data;iindex() = default;iindex(long long i) : data(i) {}iindex(int       i) : data(i) {}iindex(size_t    i) : data(i) {}operator T &       () { return data; }operator long long () { return data; }operator int       () { return data; }operator size_t    () { return data; }typedef T value_type;};template <typename T>std::istream & operator >> (std::istream & input, iindex<T> & i) { input >> i.data; i.data -= 1; return input; }template <typename T>std::ostream & operator << (std::ostream & output, iindex<T> const & i) { return output << i.data+1; }typedef iindex<long long> index;\ntemplate <typename T>class irange {public:class iterator {public:iterator(T value) : value(value), step(1) {}iterator(T value, T step) : value(value), step(step) {}bool operator != (const iterator & other) const {return value != other.value;}T const & operator * () const {return value;}iterator & operator ++ () {value += step;return *this;}private:T value;T step;};public:irange(T last) : first(0), last(last), step(1) {}irange(T first, T last) : first(first), last(last), step(1) {}irange(T first, T last, T step) : first(first), last(last), step(step) {}iterator begin() const {return iterator(first, step);}iterator end() const {if (step == 0) return iterator(last, step);if (0 < step and last < first) return iterator(first, step);if (step < 0 and first < last) return iterator(first, step);return iterator(first + ((last - first + (0 < step ? -1 : 1)) / step + 1) * step, step);}typedef T value_type;private:T const first;T const last;T const step;};typedef irange<long long> lrange;inline lrange range(lrange::value_type last) { return lrange(last); }inline lrange range(lrange::value_type first, lrange::value_type last) { return lrange(first, last); }inline lrange range(lrange::value_type first, lrange::value_type last, lrange::value_type step) { return lrange(first, last, step); }template <typename T> lrange index_of(const T & a) { return range(a.size()); }inline lrange range(std::istream & input) { lrange::value_type i; input >> i; return range(i); }inline lrange reverse_range(lrange::value_type last) { return range(last-1,-1,-1); }inline lrange reverse_range(lrange::value_type first, lrange::value_type last) { return range(last-1,first-1,-1); }inline lrange inclusive_range(lrange::value_type last) { return range(last+1); }inline lrange inclusive_range(lrange::value_type first, lrange::value_type last) { return range(first,last+1); }template <typename T> lrange reverse_index_of(const T & a) { return range(a.size()-1,-1,-1); }\ntemplate <typename T>std::istream & operator >> (std::istream & input, std::vector<T> & a) {for (int i = 0; i < a.size(); ++i) {input >> a[i];}return input;}template <typename T>std::ostream & operator << (std::ostream & output, const std::vector<T> & a) {for (int i = 0; i < a.size(); ++i) {if (i != 0) output << ' ';output << a[i];}return output;}\nusing namespace std;\nint main() {\n    ios_base::sync_with_stdio(false);\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 and m == 0) break;\n        vector<vector<int> > e[2];\n        for (int sl : {0,1}) e[sl].resize(n, vector<int>(n, 1<<28));\n        for (int query : range(m)) {\n            index x, y; int t; char c; cin >> x >> y >> t; cin.ignore(); cin >> c;\n            assert (c == 'S' or c == 'L');\n            int sl = c == 'L' ? 0 : 1;\n            e[sl][x][y] = min(e[sl][x][y], t);\n            e[sl][y][x] = min(e[sl][y][x], t);\n        }\n        int r; cin >> r;\n        vector<index> z(r); cin >> z;\n        // warshall floyd\n        for (int sl : {0,1}) for (int i : range(n)) e[sl][i][i] = 0;\n        for (int sl : {0,1}) for (int k : range(n)) for (int i : range(n)) for (int j : range(n)) {\n            e[sl][i][j] = min(e[sl][i][j], e[sl][i][k] + e[sl][k][j]);\n        }\n        vector<int> dp[2];\n        for (int i : {0,1}) dp[i].resize(n, 1<<28);\n        vector<int> & cur = dp[0];\n        vector<int> & prv = dp[1];\n        prv[0] = 0;\n        z.insert(z.begin(), 0);\n        for (int i : range(1,r+1)) {\n            for (int j : range(n)) {\n                cur[j] = min(1<<28, prv[j] + e[0][z[i-1]][z[i]]);\n                for (int k : range(n)) {\n                    cur[j] = min(cur[j], prv[k] + e[0][z[i-1]][k] + e[1][k][j] + e[0][j][z[i]]);\n                }\n            }\n            swap(cur,prv);\n        }\n        cout << *min_element(prv.begin(), prv.end()) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\nconst int N = 222;\nconst int M = N*2;\nconst int R = 1111;\n\nint n,m;\nvector<pii> sea[N];\nvector<pii> land[N];\n\nvector<int> move;\n\nvoid clear(){\n\tmove.clear();\n\trep(i,N){\n\t\tsea[i].clear();\n\t\tland[i].clear();\n\t}\n}\nbool init(){\n\tclear();\n\tcin>>n>>m;\n\tif(n==0)return false;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(d==\"L\"){\n\t\t\tland[a].push_back(pii(b,c));\n\t\t\tland[b].push_back(pii(a,c));\n\t\t}\n\t\tif(d==\"S\"){\n\t\t\tsea[a].push_back(pii(b,c));\n\t\t\tsea[b].push_back(pii(a,c));\n\t\t}\n\t}\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\treturn true;\n}\n\n\nconst int INF = 100000000;\n\nint edge[M][M];\n\nvoid setEdgeSelf(){\n\trep(i,N){\n\t\tedge[i*2][i*2]=0;\n\t\tedge[i*2+1][i*2+1]=0;\n\t\tedge[i*2][i*2+1]=0;\n\t}\n}\nvoid setEdgeSeaLand(){\n\trep(i,n){\n\t\trep(j,sea[i].size()){\n\t\t\tpii e = sea[i][j];\n\t\t\tint a = e.first*2;\n\t\t\tint b = i*2;\n\t\t\tedge[a][b] = min(edge[a][b], e.second);\n\t\t\tedge[b][a] = min(edge[b][a], e.second);\n\t\t}\n\t\trep(j,land[i].size()){\n\t\t\tpii e = land[i][j];\n\t\t\tint a = e.first*2+1;\n\t\t\tint b = i*2+1;\n\t\t\tedge[a][b] = min(edge[a][b], e.second);\n\t\t\tedge[b][a] = min(edge[b][a], e.second);\n\t\t}\n\t}\n}\n\nvoid setEdge(){\n\trep(i,M)rep(j,M)edge[i][j] = INF;\n\t\n\tsetEdgeSelf();\n\tsetEdgeSeaLand();\n}\n\nvoid printEdge(){\n\treps(i,2,n*2+2){\n\t\treps(j,2,n*2+2){\n\t\t\tint e = edge[i][j];\n\t\t\tif(e==INF)printf(\"oo  \");\n\t\t\telse printf(\"%3d \",e);\n\t\t}puts(\"\");\n\t}puts(\"\");\n}\n\nvoid wf(){\n\trep(k,n*2+2){\n\t\trep(i,n*2+2){\n\t\t\trep(j,n*2+2){\n\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solvedp(){\n\tint dp[R][N];\n\trep(i,R)rep(j,N)dp[i][j]=INF;\n\t\n\tdp[0][move[0]]=0;\n\treps(i,1,move.size()){\n\t\tint prev = move[i-1];\n\t\tint now = move[i];\n\t\t\n\t\trep(j,n+1){\n\t\t\trep(k,n+1){\n\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+edge[prev*2+1][j*2+1]+edge[j*2][k*2]+edge[k*2+1][now*2+1]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,n+1)ans = min(ans, dp[move.size()-1][i]);\n\t\n\tif(ans==INF)return -1;\n\treturn ans;\n}\n\nint solve(){\n\tsetEdge();\n\twf();\n\t\n\t//printEdge();\n\t\n\treturn solvedp();\n}\n\nint main(){\n\twhile(init())printf(\"%d\\n\",solve());\n}\n\n\n/*\n3 3\n1 2 5 L\n1 2 7 S\n2 3 11 S\n3\n1 2 3\n0 0\n\n5 5\n1 2 15 L\n2 3 10 L\n4 5 7 L\n1 3 30 S\n3 4 100 S\n5\n1 3 5 4 1\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := 集配先\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      //if(dp[i][j] == inf)continue;\n\t      //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t      dp[i+1][j] = min(dp[i+1][j],\n\t\t\t       dp[i][j]+LG[v[i]][v[i+1]]);\n\t      //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl; \n\t      rep(k,N)\n\t\t{\n\t\t  if(SG[v[i]][k] != inf)\n\t\t    {\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t       dp[i][v[i]] + SG[v[i]][k] + LG[k][v[i+1]]);\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst int MAX_V = 10010;\nconst int INF = 1e9;\ntypedef pair<int, int> P;\n\nstruct WarshallFloyd{\n    int n;\n    const int INF = 1e6;\n    vector<vector<int> > d;\n    WarshallFloyd(int _n){\n        n = _n;\n        d.resize(n, vector<int>(n));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n    }\n    void build(){\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n    }\n};\n\nint n, m, r;\nint d[1010][210];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        WarshallFloyd wfl(n), wfs(n);\n        rep(i, 0, m){\n            int x, y, t; char c;\n            cin >> x >> y >> t >> c;\n            x--; y--;\n            if(c == 'L'){\n                wfl.d[x][y] = t;\n                wfl.d[y][x] = t;\n            }else{\n                wfs.d[x][y] = t;\n                wfs.d[y][x] = t;\n            }\n        }\n        cin >> r;\n        vector<int> z(r);\n        rep(i, 0, r){\n            cin >> z[i];\n            z[i]--;\n        }\n        wfl.build();\n        wfs.build();\n        rep(i, 0, r) rep(j, 0, n) d[i][j] = INF;\n        d[0][z[0]] = 0;\n        rep(i, 1, r){\n            rep(j, 0, n){\n                if(d[i - 1][j] >= INF) continue;                \n                rep(k, 0, n){\n                    int tmp = wfl.d[z[i - 1]][j] + wfs.d[j][k] + wfl.d[k][z[i]];\n                    if(j == k) tmp = wfl.d[z[i - 1]][z[i]];\n                    // cout << i << ' ' << j << ' ' << k << ' ' << tmp << endl;\n                    d[i][k] = min(d[i][k], d[i - 1][j] + tmp);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n) ans = min(ans, d[r - 1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int INF = 1000000000;\nstatic int land_mat[200][200];\nstatic int sea_mat[200][200];\n\nint main(){\n\tios_base::sync_with_stdio(false);;\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){ break; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tland_mat[i][j] = sea_mat[i][j] = INF;\n\t\t\t}\n\t\t\tland_mat[i][i] = sea_mat[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint a, b, c;\n\t\t\tstring t;\n\t\t\tcin >> a >> b >> c >> t;\n\t\t\t--a; --b;\n\t\t\tif(t[0] == 'S'){\n\t\t\t\tsea_mat[a][b] = min(sea_mat[a][b], c);\n\t\t\t\tsea_mat[b][a] = min(sea_mat[b][a], c);\n\t\t\t}else{\n\t\t\t\tland_mat[a][b] = min(land_mat[a][b], c);\n\t\t\t\tland_mat[b][a] = min(land_mat[b][a], c);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tland_mat[i][j] = min(\n\t\t\t\t\t\tland_mat[i][j], land_mat[i][k] + land_mat[k][j]);\n\t\t\t\t\tsea_mat[i][j] = min(\n\t\t\t\t\t\tsea_mat[i][j], sea_mat[i][k] + sea_mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\tint answer = 0;\n\t\tvector<int> cur(n, INF);\n\t\tcur[z[0]] = 0;\n\t\tfor(int i = 1; i < r; ++i){\n\t\t\tconst int u = z[i - 1], v = z[i];\n\t\t\tvector<int> from_dist(n, INF);\n\t\t\tvector<int> to_dist(n, INF);\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tfrom_dist[j] = land_mat[u][j];\n\t\t\t\tto_dist[j] = land_mat[j][v];\n\t\t\t}\n\t\t\tvector<int> next(n, INF);\n\t\t\tif(land_mat[u][v] < INF){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tnext[j] = cur[j] + land_mat[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(from_dist[j] >= INF){ continue; }\n\t\t\t\tfor(int k = 0; k < n; ++k){\n\t\t\t\t\tif(to_dist[k] >= INF){ continue; }\n\t\t\t\t\tconst int sea_dist = sea_mat[j][k];\n\t\t\t\t\tif(sea_dist >= INF){ continue; }\n\t\t\t\t\tnext[k] = min(next[k], cur[j] + from_dist[j] + to_dist[k] + sea_dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.swap(next);\n\t\t}\n\t\tcout << *min_element(cur.begin(), cur.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\n\nconst ll INF = 1e18;\n\nint main(){\n  ll n,m,r;\n  while(cin >> n >> m){\n    if(n==0)break;\n    vector< vi > sg(n,vi(n,INF)),lg(n,vi(n,INF));\n    rep(i,n)sg[i][i] = lg[i][i] = 0;\n\n    rep(i,m){\n      ll x,y,t;\n      char s;\n      cin >> x >> y >> t >> s; x--; y--;\n      if(s == 'L')lg[x][y] = lg[y][x] = t;\n      else sg[x][y] = sg[y][x] = t;\n    }\n\n    rep(k,n)rep(i,n)rep(j,n)lg[i][j] = min(lg[i][j], lg[i][k] + lg[k][j]);\n    rep(k,n)rep(i,n)rep(j,n)sg[i][j] = min(sg[i][j], sg[i][k] + sg[k][j]);\n\n    /*\n    rep(i,n){rep(j,n)cout << lg[i][j] << \" \"; cout << endl;}\n    rep(i,n){rep(j,n)cout << sg[i][j] << \" \"; cout << endl;}\n    */\n\n    cin >> r;\n    ll cur; cin >> cur; cur--;\n    vi dis(n,INF); dis[cur] = 0;\n\n    rep(z,r-1){\n      ll nxt; cin >> nxt; nxt--;\n      vi ndis(n,INF);\n\n      rep(i,n){\n\trep(j,n){\n\t  ndis[j] = min(ndis[j], dis[i] + lg[cur][i] + sg[i][j] + lg[j][nxt]);\n\t}\n      }\n\n      swap(dis,ndis);\n      cur = nxt;\n    }\n\n    cout << *min_element(dis.begin(), dis.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n || m){\n        auto Ld = vectors(301,301,(ll)INF);\n        auto Sd = vectors(301,301,(ll)INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                Ld[b][a] = Ld[a][b] = min(Ld[a][b],c);\n            }else{\n                Sd[b][a] = Sd[a][b] = min(Sd[a][b],c);\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(2001,2001,(ll)INF);\n        dp[0][v[0]] = 0;\n        rep(i,r){\n            if(i  ==  0)continue;\n            rep(j,n){\n                rep(k,n){\n                    if(j != k)cmin(dp[i][j],dp[i-1][k] + Ld[v[i-1]][k] + Sd[k][j] + Ld[j][v[i]]);\n                    else cmin(dp[i][j],dp[i-1][j] + Ld[v[i-1]][v[i]]);\n                }\n            }\n        }\n        int ans = INF;\n        for(auto val : dp[r-1]) cmin(ans, val);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000000\nint le[200][200];\nint se[200][200];\nint dp[2][200];\nint q[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<200;i++){\n\t\tfor(j=0;j<200;j++){\n\t\t\tle[i][j]=INF;\n\t\t\tse[i][j]=INF;\n\t\t}\n\t\tle[i][i]=0;\n\t\tse[i][i]=0;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar t;\n\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\ta--;b--;\n\t\tif(t=='L'){\n\t\t\tle[a][b]=min(le[a][b],c);\n\t\t\tle[b][a]=min(le[b][a],c);\n\t\t}\n\t\telse{\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tle[i][j]=min(le[i][j],le[i][k]+le[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint nq;\n\tscanf(\"%d\",&nq);\n\tfor(i=0;i<nq;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t\tq[i]--;\n\t}\n\tfor(i=0;i<200;i++)dp[0][i]=INF;\n\tdp[0][q[0]]=0;\n\tfor(i=1;i<nq;i++){\n\t\tfor(j=0;j<200;j++)dp[i%2][j]=INF;\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][k]=min(dp[i%2][k],dp[(i+1)%2][j]+le[q[i-1]][j]+se[j][k]+le[k][q[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+le[q[i-1]][q[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(nq+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nconst int MAX_V = 205;\nconst int MAX_R = 1005;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M, N||M){\n\t\tint gl[MAX_V][MAX_V], gs[MAX_V][MAX_V];\n\t\tinit(gl);\n\t\tinit(gs);\n\t\trep(i,M){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tgl[x][y] = min(t, gl[x][y]);\n\t\t\t\tgl[y][x] = gl[x][y];\n\t\t\t}else{\n\t\t\t\tgs[x][y] = min(t, gs[x][y]);\n\t\t\t\tgs[y][x] = gs[x][y];\n\t\t\t}\n\t\t}\n\t\twarshallFloyd(gl,N);\n\t\twarshallFloyd(gs,N);\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> z(R);\n\t\trep(i,R){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tint dp[MAX_R][MAX_V];\n\t\trep(i,MAX_R) rep(j,MAX_V) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\n\t\trep(i,R - 1){\n\n\t\t\tint cur = z[i];\n\t\t\tint next = z[i + 1];\n\t\t\trep(j,N) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][next]);\n\t\t\trep(j,N){\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\trep(k,N){\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\t\t\t//show(dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,R){\n\t\t//\trep(j,N){\n\t\t//\t\tif(dp[i][j] >= INF) cout << \"_\";\n\t\t//\t\telse cout << dp[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint mini = INT_MAX;\n\t\trep(i,N){\n\t\t\tmini = min(mini, dp[R - 1][i]);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nconst long long inf = 1LL<<55;\nconst int NODE = 210;\nint main()\n{\n  int n,m;\n  while(cin>>n>>m&&n&&m){\n    long long sea[n][n];\n    long long land[n][n];\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        if( i!=j ){\n          sea[i][j]=land[i][j]=inf;\n        }else{\n          sea[i][j]=land[i][j]=0;\n        }\n      }\n    }\n    for(int i = 0; i < m; ++i){\n      int x,y;\n      long long t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x;\n      --y;\n      if( sl == 'S' ){\n        sea[x][y]=min(sea[x][y],t);\n        sea[y][x]=min(sea[y][x],t);\n      }else{\n        land[x][y]=min(land[x][y],t);\n        land[y][x]=min(land[y][x],t);\n      }\n    }\n    for(int k=0;k<n;++k){\n      for(int i=0;i<n;++i){\n        for(int j=0;j<n;++j){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    int R;\n    int cur,ship;\n    int prez,z;\n    long long preA[n][n];\n    long long A[n][n];\n    \n    cin >> R;\n    cin >> z;\n    --z;\n    cur = ship = z;\n    for(int j = 0; j < n; ++j){\n      for(int k = 0; k < n; ++k){\n        preA[j][k] = A[j][k] = inf;\n      }\n    }\n    A[cur][ship] = 0;\n    for(int i = 1; i < R; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          preA[j][k] = A[j][k];\n          A[j][k] = inf;\n        }\n      }\n      prez = z;\n      cin >> z;\n      --z;\n      for(int j = 0; j < n; ++j){\n        A[z][j] = min( A[z][j], preA[prez][j] + land[prez][z]);\n        for(int k = 0; k < n; ++k){\n          A[z][k] = min( A[z][k], preA[prez][j] + land[prez][j] + sea[j][k] + land[k][z] );\n          //cout << z << ' ' << k << ' ' << A[z][k] << endl;\n        }\n      }\n    }\n    long long res = inf;\n    for(int i = 0; i < n; ++i){\n      res = min( res, A[z][i] );\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    int dis1=L[z[i-1]][k];\n                    int dis2=W[k][j];\n                    int dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  const int INF = 1 << 28;\n\n  int N, M;\n  while (~scanf(\"%d %d\\n\", &N, &M)) {\n    if (N == 0 && M == 0)\n      break;\n\n    vector<vector<int> > land(N, vector<int>(N, INF)), sea(N, vector<int>(N, INF));\n    for (int i = 0; i < N; ++i)\n      land[i][i] = sea[i][i] = 0;\n\n    for (int i = 0; i < M; ++i) {\n      int x, y, t;\n      char s;\n      scanf(\"%d %d %d %c\\n\", &x, &y, &t, &s);\n      --x;\n      --y;\n      if (s == 'L')\n\tland[x][y] = land[y][x] = min(land[x][y], t);\n      else\n\tsea[x][y] = sea[y][x] = min(sea[x][y], t); \n    }\n\n    for (int k = 0; k < N; ++k) {\n      for (int i = 0; i < N; ++i) {\n\tfor (int j = 0; j < N; ++j) {\n\t  land[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t  sea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t}\n      }\n    }\n    \n    int R, z1, z2;\n    scanf(\"%d\\n\", &R);\n    scanf(\"%d\", &z1);\n    --z1;\n    vector<vector<int> > dp(R, vector<int>(N, INF));\n    dp[0][z1] = 0;\n    for (int i = 0; i < R-1; ++i) {\n      scanf(\"%d\", &z2);\n      --z2;\n      for (int j = 0; j < N; ++j) {\n\tdp[i+1][j] = min(dp[i+1][j], dp[i][j]+land[z1][z2]);\n\tfor (int k = 0; k < N; ++k) {\n\t  dp[i+1][k] = min(dp[i+1][k], dp[i][j]+land[z1][j]+sea[j][k]+land[k][z2]);\n\t}\n      }\n      z1 = z2;\n    }\n\n    int ans = INF;\n    for (int i = 0; i < N; ++i)\n      ans = min(ans, dp[R-1][i]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint cost[201][201][201];\n\nclass edge{\npublic:\n\tint to,cost;\n\tedge(int to,int cost):to(to),cost(cost){}\n};\n\nclass state{\npublic:\n\tint now,cost,ship,done;\n\tstate(int now,int cost,int ship,int done):now(now),cost(cost),done(done),ship(ship){}\n};\n\nbool operator < (state a,state b){\n\treturn a.cost>b.cost;\n}\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tfor(int i=0;i<201;i++){\n\t\t\tfor(int j=0;j<201;j++)\n\t\t\t\tfor(int z=0;z<201;z++)\n\t\t\t\t\tcost[i][j][z]=1000000000;\n\t\t}\n\n\t\tvector<vector<edge> > grand(201);\n\t\tvector<vector<edge> >sea(201);\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint cost,in,out; \n\t\t\tchar kind;\n\t\t\tcin>>in>>out>>cost>>kind;\n\t\t\tif(kind=='L'){\n\t\t\t\tgrand[in].push_back(edge(out,cost));\n\t\t\t\tgrand[out].push_back(edge(in,cost));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsea[in].push_back(edge(out,cost));\n\t\t\t\tsea[out].push_back(edge(in,cost));\n\t\t\t}\n\t\t}\n\t\tint first,n;\n\t\tcin>>n;\n\t\tvector<int> dest(n-1);\n\t\tcin>>first;\n\t\tfor(int i=0;i<n-1;i++){\n\t\t\tcin>>dest[i];\n\t\t}\n\t\t\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(first,0,first,0));\n\t\twhile(!Q.empty()){\n\t\t\tstate t=Q.top(); Q.pop();\n\t\t\t\n\t\t\tif(t.now==dest[t.done]) t.done++;\n//\t\t\tcout<<t.now<<\" \"<<t.ship<<\" \"<<t.cost<<\" \"<<t.done<<endl;\n\t\t\tif(t.cost>=cost[t.now][t.ship][t.done]) continue;\n\t\t\tif(t.done==n-1){cout<<t.cost<<endl; break;}\n\t\t\tcost[t.now][t.ship][t.done]=t.cost;\n\n\n\t\t\tif(t.ship==t.now){\n\t\t\t\tfor(int i=0;i<sea[t.now].size();i++){\n\t\t\t\t\tif(t.cost+sea[t.now][i].cost<cost[sea[t.now][i].to][sea[t.now][i].to][t.done])\n\t\t\t\t\t\tQ.push(state(sea[t.now][i].to,t.cost+sea[t.now][i].cost,sea[t.now][i].to,t.done));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<grand[t.now].size();i++){\t\t\t\t\n\t\t\t\tif(t.cost+grand[t.now][i].cost<cost[grand[t.now][i].to][t.ship][t.done])\n\t\t\t\t\tQ.push(state(grand[t.now][i].to,t.cost+grand[t.now][i].cost,t.ship,t.done));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define INF 1LL<<60\ntypedef long long ll;\n\nint N, M;\n\nll d1[200][200]; // Land\nll d2[200][200]; // Sea\n\nll dp[1010][200];\n\nint R;\nint Z[1010];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile (cin >> N >> M)\n\t{\n\t\tif (N == 0) return 0;\n\t\t\n\t\trep(i, 0, N) rep(j, 0, N) d1[i][j] = d2[i][j] = INF;\n\t\trep(i, 0, N) d1[i][i] = d2[i][i] = 0;\n\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tint x, y, t; char sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\n\t\t\tif (sl == 'L')\n\t\t\t\td1[x][y] = d1[y][x] = t;\n\t\t\telse\n\t\t\t\td2[x][y] = d2[y][x] = t;\n\t\t}\n\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n\t\trep(k, 0, N) rep(i, 0, N) rep(j, 0, N)\n\t\t\td2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n\n\t\tcin >> R;\n\t\trep(i, 0, R) cin >> Z[i];\n\t\trep(i, 0, R) Z[i]--;\n\n\t\trep(i, 0, R) rep(j, 0, N) dp[i][j] = INF;\n\t\tdp[0][Z[0]] = 0;\n\n\t\trep(i, 0, R - 1) rep(j, 0, N) if (dp[i][j] != INF)\n\t\t{\n\t\t\tll dd = dp[i][j] + d1[Z[i]][Z[i + 1]];\n\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dd);\n\n\t\t\trep(k, 0, N)\n\t\t\t{\n\t\t\t\tdd = dp[i][j] + d1[Z[i]][j] + d2[j][k] + d1[k][Z[i + 1]];\n\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dd);\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\trep(i, 0, N) ans = min(ans, dp[R - 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Matrix &g, Matrix &dist) {\n  int n = g.size();\n  dist = g;\n  REP(k, n) REP(i, n) REP(j, n)\n    dist[i][j] = min(dist[i][j], dist[i][k]+dist[k][j]);\n}\n\nint main() {\n  int n,m;\n  while(cin>>n>>m,n) {\n    Matrix gl(n,Array(n,INF));\n    Matrix gs(n,Array(n,INF));\n    set<int> ses;\n    REP(i,n) {\n      gl[i][i] = 0;\n    }\n    REP(i,m) {\n      int a,b,c;\n      cin >> a>>b>>c;\n      a--;b--;\n      char ch;\n      cin >> ch;\n      if (ch=='L') {\n        gl[a][b] = c;\n        gl[b][a] = c;\n      }else {\n        gs[a][b] = c;\n        gs[b][a] = c;\n        ses.insert(a);\n        ses.insert(b);\n      }\n    }\n    FOR(it,ses)\n      gs[*it][*it] = 0;\n    int t;\n    cin >> t;\n    int z[t];\n    REP(i,t) {\n      cin >> z[i];\n      z[i]--;\n    }\n    Matrix distl, dists;\n    shortestPath(gl, distl);\n    shortestPath(gs, dists);\n    vector<int> ikerul[n], ikerus[n];\n    REP(i,n) {\n      REP(j,n) {\n        if (dists[i][j]!=INF)\n          ikerus[i].push_back(j);\n        if (distl[i][j]!=INF)\n          ikerul[i].push_back(j);\n      }\n    }\n\n    int dp[t][n];\n    REP(i,t)REP(j,n)dp[i][j] = INF;\n        dp[0][z[0]] = 0;\n    REP(i,t-1) {\n      FOR(it, ikerul[z[i]]) {\n        FOR(jt,ikerus[*it]) {\n          FOR(kt, ikerul[*jt]) {\n            if (*kt==z[i+1]) {\n              dp[i+1][*jt] = min(dp[i+1][*jt], dp[i][*it]+distl[z[i]][*it]+dists[*it][*jt]+distl[*jt][*kt]);\n              // printf(\"%d, %d->%d->%d->%d\\n\", i,z[i],*it,*jt,*kt);\n              // cout << dp[i+1][*jt] << endl;\n            }\n          }\n        }\n      }\n    }\n    cout << *min_element(dp[t-1], dp[t-1]+n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 205\n#define MAXR 1005\n#define MAXM 10005\nint N,M,R;\nint S[MAXN][MAXN],L[MAXN][MAXN];\nint task[MAXR];\nint dp[MAXR][MAXN];\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(!N&&!M)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tS[i][j]=L[i][j]=1000000;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tS[i][i]=L[i][i]=0;\n\t\tfor(int i=1;i<=M;i++)\n\t\t{\n\t\t\tint a,b,t;char s[3];\n\t\t\tscanf(\"%d%d%d%s\",&a,&b,&t,s);\n\t\t\tif(s[0]=='S')\n\t\t\t{\n\t\t\t\tS[a][b]=min(S[a][b],t);\n\t\t\t\tS[b][a]=min(S[b][a],t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[a][b]=min(L[a][b],t);\n\t\t\t\tL[b][a]=min(L[b][a],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=1;k<=N;k++)\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\t{\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(int i=1;i<=R;i++)\n\t\t\tscanf(\"%d\",task+i);\n\t\tfor(int i=1;i<=R;i++)\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tdp[i][j]=1000000;\n\t\tdp[1][task[1]]=0;\n\t\tfor(int i=2;i<=R;i++)//the Captain position\n\t\t\tfor(int j=1;j<=N;j++)//the Ship position\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+L[task[i-1]][task[i]]);\n\t\t\t\tfor(int k=1;k<=N;k++)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+L[task[i-1]][j]+S[j][k]+L[k][task[i]]);\n\t\t\t}\n\t\tint ans=0x7FFFFFFF;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tans=min(ans,dp[R][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = 10000000;\nint land[200][200];\nint sea[200][200];\nint dp[1000][200];\n\nint main() {\n    int N,M,R,x,y,i,j,k,t;\n  string s;\n  while(cin>>N>>M, N|M) {\n\n    rep(i,200) {\n      rep(j,200) land[i][j] = sea[i][j] = inf;\n      land[i][i] = sea[i][i] = 0;\n    }\n\n    rep(i,M) {\n      cin>>x>>y>>t>>s;\n      x--,y--;\n      if(s == \"S\") {\n\tsea[x][y] = min(t, sea[x][y]);\n\tsea[y][x] = sea[x][y];\n      }else{\n\tland[x][y] = min(t, land[x][y]);\n\tland[y][x] = land[x][y];\n      }\n    }\n\n    rep(k,N) {\n      rep(i,N) {\n\trep(j,N) {\n\t  sea[i][j] = min(sea[i][k]+sea[k][j], sea[i][j]);\n\t  land[i][j] = min(land[i][k]+land[k][j], land[i][j]);\n\t}\n      }\n    }\n\n    cin>>R;\n    vector<int> path;\n    rep(i,1000) rep(j,200) dp[i][j] = inf;\n    rep(i, R) {\n      int kt;\n      cin>>kt;\n      kt--;\n      path.push_back(kt);\n    }\n\n    dp[0][path[0]] = 0;\n    for(i=1; i<R; ++i) {\n      for(j=0; j<N; ++j) {\n\tdp[i][j] = min(dp[i-1][j]+land[path[i-1]][path[i]],dp[i][j]);\n\n\tfor(k=0; k<N; ++k) {\n\t  int t = dp[i-1][j]+land[path[i-1]][j]+sea[j][k]+land[k][path[i]];\n\t  dp[i][k] = min(dp[i][k], t);\n\t}\n\t//cout<<i<<\": \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n\n    int ans = inf;\n    rep(i,N) {\n      ans = min(ans, dp[R-1][i]);\n      //cout<<i<<\" : \"<<dp[R-1][i]<<endl;\n    }\n\n    cout<<ans<<endl;\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef TIII state;\nint INF;\nint dist[222][222];\nmap<int, int> S[222];\nint z[1111];\nmap<state, int> memo;\n\nint main(){\n\tINF = 1000000000;\n\tREP(i,222)REP(j,222)dist[i][j] = INF;\n\twhile(1){\n\t\tint n,m,r;\n\t\tcin>>n>>m;\n\t\tREP(i,222)S[i].clear();\n\t\tif(n==0)return 0;\n\t\tREP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--, y--;\n\t\t\tif(sl=='L')dist[y][x] = dist[x][y] = t;\n\t\t\telse{\n\t\t\t\tif(EXIST(S[x], y))S[y][x] = S[x][y] = min(S[x][y], t);\n\t\t\t\telse S[y][x] = S[x][y] = t;\n\t\t\t}\t\t\t\n\t\t}\n\t\tREP(i,n)dist[i][i] = 0;\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,i){\n\t\t\t\t\tdist[i][j] = dist[j][i] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>r;\n\t\tREP(i,r){\n\t\t\tscanf(\"%d\", &z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\tstate st = MT(0, 0, z[0]);\n\t\tpriority_queue<state, vector<state>, greater<state> > q;\n\t\tq.push(st);\n\t\twhile(!q.empty()){\n\t\t\tstate tst = q.top();\n\t\t\tq.pop();\n\t\t\tif(EXIST(memo, tst))continue;\n\t\t\tmemo[tst] = tst.first;\n\t\t\tif(tst.T2 == r-1){\n\t\t\t\tcout << tst.T1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dist[z[tst.T2]][z[tst.T2+1]]<INF){\n\t\t\t\tstate rst = MT(dist[z[tst.T2]][z[tst.T2+1]]+tst.T1, tst.T2+1, tst.T3);\n\t\t\t\tq.push(rst);\n\t\t\t}\n\t\t\tint D = dist[z[tst.T2]][tst.T3] + tst.T1;\n\t\t\tfor(map<int, int>::iterator it = S[tst.T3].begin(); it!=S[tst.T3].end(); it++){\n\t\t\t\tif(dist[it->first][z[tst.T2+1]]<INF){\n\t\t\t\t\tq.push(MT(D+it->second+dist[it->first][z[tst.T2+1]], tst.T2+1, it->first));\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nvi p;\nusing t = vector<pair<int, void*>>;\nvpii ki;\nt* c(int i) {\n\tif (ki.size() == i)return nullptr;\n\tt* a=new t(ki[i].second + 1);\n\trep(j, ki[i].second + 1) {\n\t\t(*a)[j].second = c(i + 1);\n\t}\n\treturn a;\n}\nvoid add(int k, int i, t* a) {\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second+0);\n\t(*a)[s].first++;\n\tif (i == ki.size() - 1) {\n\t\treturn;\n\t}\n\tadd(k, i + 1, (t*)((*a)[s].second));\n}\nll cnt(int k, int i, t*a) {\n\tll c = 0;\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second + 0);\n\tif (i == ki.size() - 1) {\n\t\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += (*a)[j].first;\n\t\treturn c;\n\t}\n\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += cnt(k, i + 1, (t*)((*a)[j].second));\n\treturn c;\n}\nint lw[200][200], sw[200][200];\nint dp[2][200];\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tfill(lw[0], lw[200], numeric_limits<int>::max() / 8);\n\t\tfill(sw[0], sw[200], numeric_limits<int>::max() / 8);\n\t\trep(i, n)lw[i][i] = 0;\n\t\trep(i, n)sw[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tcmin(lw[x - 1][y - 1], t);\n\t\t\t\tcmin(lw[y - 1][x - 1], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmin(sw[x - 1][y - 1], t);\n\t\t\t\tcmin(sw[y - 1][x - 1], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(lw[i][j], lw[i][k] + lw[k][j]);\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(sw[i][j], sw[i][k] + sw[k][j]);\n\t\t}\n\t\tfill(dp[0], dp[1], numeric_limits<int>::max() / 8);\n\t\tint r;\n\t\tcin >> r;\n\t\tvi z(r);\n\t\trep(i, r)cin >> z[i];\n\t\tint prev = z[0] - 1;\n\t\tdp[0][z[0] - 1] = 0;\n\t\trep(i, r) {\n\t\t\tfill(dp[i & 1^1], dp[(i&1^1) + 1], numeric_limits<int>::max() / 8);\n\t\t\trep(j, n)rep(k, n) {\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][j] + sw[j][k] + lw[k][z[i] - 1]);\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][z[i] - 1]);\n\t\t\t}\n\t\t\tprev = z[i] - 1;\n\t\t}\n\t\tint ans = numeric_limits<int>::max() / 8;\n\t\trep(i, n)cmin(ans, dp[r & 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e8;\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tvector<vector<int> > adjL(n, vector<int>(n, inf)), adjS(n, vector<int>(n, inf));\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl=='L'){\n\t\t\t\tadjL[x][y] = adjL[y][x] = min(adjL[x][y], t);\n\t\t\t}else{\n\t\t\t\tadjS[x][y] = adjS[y][x] = min(adjS[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tadjL[i][i]=0;\n\t\t\tadjS[i][i]=0;\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0; i<r; i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tadjL[i][j] = min(adjL[i][j], adjL[i][k]+adjL[k][j]);\n\t\t\t\t\tadjS[i][j] = min(adjS[i][j], adjS[i][k]+adjS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<vector<vector<int> > > dp(2, vector<vector<int> >(n, vector<int>(n, inf)));\n\t\tdp[0][z[0]][z[0]] = 0;\n\t\tfor(int i=0; i<r-1; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(k==j){\n\t\t\t\t\t\tdp[(i+1)%2][z[i+1]][k] = min(dp[(i+1)%2][z[i+1]][k], dp[i%2][z[i]][j]+adjL[z[i]][z[i+1]]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tdp[(i+1)%2][z[i+1]][k] = min(dp[(i+1)%2][z[i+1]][k], dp[i%2][z[i]][j]+adjL[z[i]][j]+adjS[j][k]+adjL[k][z[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(i==0) dp[0][z[0]][z[0]] = inf;\n\t\t}\n\t\t\n\t\tint ans=inf;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tans = min(ans, dp[(r-1)%2][z[r-1]][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct e{\n\tint to;\n\tint cost;\n\tchar c;\n};\n\nstruct state{\n\tint from;//????????´???\n\tint d;//??????????????°\n\tint ship;//????????´???\n\tint cost;//????????§????????????\n};\n\nbool operator<(const state& left, const state& right){\n\treturn left.cost > right.cost;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n){\n\t\tvector<vector<e>> edge(n);\n\t\t\n\t\tREP(i, m){\n\t\t\tint u, v, t;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> t >> c;\n\t\t\tu--; v--;\n\t\t\tedge[u].push_back({v, t, c});\n\t\t\tedge[v].push_back({ u, t, c });\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> goal(n);\n\t\tREP(i, r){\n\t\t\tcin >> goal[i];\n\t\t\tgoal[i]--;\n\t\t}\n\t\tint ans=0;\n\t\t//\n\t\tvector<vector<vector<int>>> memo(n,vector<vector<int>>(r,vector<int>(n,1e9)));\n\t\tmemo[0][0][0] = 0;\n\t\tpriority_queue<state> P;\n\t\tP.push({0,0,0,0});\n\t\twhile (!P.empty()){\n\t\t\tstate st = P.top(); P.pop();\n\t\t\tif (st.from == goal[st.d])\n\t\t\t\tst.d++;\n\t\t\tif (st.d == r){\n\t\t\t\tans = st.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tREP(i, edge[st.from].size()){\n\t\t\t\tif (edge[st.from][i].c == 'L'){\n\t\t\t\t\tif (memo[edge[st.from][i].to][st.d][st.ship]>st.cost + edge[st.from][i].cost){\n\t\t\t\t\t\tmemo[edge[st.from][i].to][st.d][st.ship] = st.cost + edge[st.from][i].cost;\n\t\t\t\t\t\tP.push({ edge[st.from][i].to, st.d, st.ship, st.cost + edge[st.from][i].cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (memo[edge[st.from][i].to][st.d][edge[st.from][i].to]>st.cost + edge[st.from][i].cost&&st.from==st.ship){\n\t\t\t\t\t\tmemo[edge[st.from][i].to][st.d][edge[st.from][i].to] = st.cost + edge[st.from][i].cost;\n\t\t\t\t\t\tP.push({ edge[st.from][i].to, st.d, edge[st.from][i].to, st.cost + edge[st.from][i].cost });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF=1001001001;\nint N,M;\nint A[200][200],B[200][200];\nint dp[2][200];\nint main(){\n    while(cin>>N>>M,N||M){\n        fill_n(*A,200*200,INF);\n        fill_n(*B,200*200,INF);\n        for(int i=0;i<N;i++){\n            A[i][i]=0;\n            B[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L')A[a][b]=A[b][a]=c;\n            else B[a][b]=B[b][a]=c;\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n\n        int R;cin>>R;\n        int prev;cin>>prev;prev--;\n        fill_n(*dp,2*200,INF);\n        dp[1][prev]=0;\n\n        for(int i=1;i<R;i++){\n            int cur;cin>>cur;cur--;\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if(A[prev][k]==INF||B[k][j]==INF||A[j][cur]==INF)continue;\n                    dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+A[prev][k]+B[k][j]+A[j][cur]);\n                }\n            }\n            for(int j=0;j<N;j++)dp[i&1][j]=INF;\n            prev=cur;\n        }\n\n        int mi=INF;\n        for(int i=0;i<N;i++)mi=min(mi,dp[R&1][i]);\n\n        cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n\nint n,m,r;\nconst int INF=1e7;\nint land[200][200],sea[200][200],z[1000];\ntypedef pair<int,int> P;\n\nint main(){\n\n\n\twhile(scanf(\"%d %d\",&n,&m),n){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) land[i][j]=sea[i][j]=INF;\n\t\t\tland[i][i]=sea[i][i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t\tx--; y--;\n\t\t\tif(c=='S'){\n\t\t\t\tsea[x][y]=min(sea[x][y],t);\n\t\t\t\tsea[y][x]=min(sea[y][x],t);\n\t\t\t}else{\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=min(land[y][x],t);\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tscanf(\"%d\",&z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(1001,vector<int>(201,INF));\n\t\tdp[0][z[0]]=0;\n\n\t\tint res=INF;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\n\t\t\t\t//z[i]???????????????????????¨??°???z[i-1]\n\t\t\t\t\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t//????????????j?????§?§???????j??????k????????????k??????z[i]?????????\t\t\t\t\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t\tif(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//????????§?§????\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\t\tif(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nint dijkstra(){\n  vector<vector<int> > D(n+1,vector<int>(r+1,INF));\n  vector<vector<int> > used(n+1,vector<int>(r+1,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n\n    \n    int npos=z[idx+1];\n    int ncost=cost+G[pos][npos][0];\n    if(pos!=ship&&D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    if(pos==ship)\n      for(int i=0;i<n;i++){\n\tncost=cost+G[pos][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n      }\n  }\n  return -1;  \n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dl[210][210];\nint ds[210][210];\nint dp[1010][210];\n// 何回目、船の場所\n\nvoid init(){\n    for(int i=0; i<210; i++){\n        for(int j=0; j<210; j++){\n            if(i == j) dl[i][j] = ds[i][j] = 0;\n            else dl[i][j] = ds[i][j] = 1e7;\n        }\n    }\n\n    for(int i=0; i<1010; i++){\n        for(int j=0; j<210; j++){\n            dp[i][j] = 1e7;\n        }\n    }\n\n    return ;\n}\n\nint main(){\n    while(1){\n        init();\n        int n, m; cin>>n>>m;\n        if(n == 0) return 0;\n\n        for(int i=0; i<m; i++){\n            int x, y, t; cin>>x>>y>>t;\n            char s; cin>>s;\n            x--, y--;\n\n            if(s == 'L'){\n                dl[x][y] = min(dl[x][y], t);\n                dl[y][x] = min(dl[y][x], t);\n            }\n            else{\n                ds[x][y] = min(ds[x][y], t);\n                ds[y][x] = min(ds[y][x], t);\n            }\n        }\n\n        int r; cin>>r;\n        vector<int> z(r);\n        for(int i=0; i<r; i++){\n            cin>>z[i];\n            z[i]--;\n        }\n\n        for(int k=0; k<n; k++){\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        dp[0][z[0]] = 0;\n\n        for(int i=0; i<r-1; i++){\n            for(int j=0; j<n; j++){\n                int cur = z[i];\n                int nxt = z[i+1];\n\n                // cur -> land -> nxt\n                dp[i+1][j] = min(dp[i+1][j], dp[i][j] + dl[cur][nxt]);\n                    \n                // cur -> land -> sea -> land -> nxtS\n                for(int k=0; k<n; k++){\n                    dp[i+1][k] = min(dp[i+1][k], dp[i][j] + dl[cur][j] + ds[j][k] + dl[k][nxt]);\n                }\n            }\n        }\n\n        int ans = 1e7;\n        for(int i=0; i<n; i++){\n            ans = min(ans, dp[r-1][i]);\n        }\n\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<60;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    ll dl[256][256],ds[256][256];\n    fill_n((ll*)dl,256*256,infll);\n    fill_n((ll*)ds,256*256,infll);\n    rep(i,0,256) dl[i][i]=ds[i][i]=0;\n    rep(i,0,m){\n        int x,y;\n        ll t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        if(sl=='L'){\n            dl[x][y]=min(dl[x][y],t);\n            dl[y][x]=min(dl[y][x],t);\n        }else{\n            ds[x][y]=min(ds[x][y],t);\n            ds[y][x]=min(ds[y][x],t);\n        }\n    }\n    int r,z[1000];\n    cin >> r;\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n\n    rep(k,0,n) rep(i,0,n) rep(j,0,n) dl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n    rep(k,0,n) rep(i,0,n) rep(j,0,n) ds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\n    ll dp[1000][256];\n    fill_n((ll*)dp,1000*256,infll);\n    rep(i,0,n) dp[0][i]=ds[z[0]][i]+dl[i][z[0]];\n    rep(i,1,r) rep(j,0,n) rep(k,0,n){\n        if(k!=j) dp[i][j]=min(dp[i][j],dp[i-1][k]+dl[z[i-1]][k]+ds[k][j]+dl[j][z[i]]);\n        else dp[i][j]=min(dp[i][j],dp[i-1][k]+dl[z[i-1]][z[i]]);\n    }\n\n    ll ans=infll;\n    rep(i,0,n) ans=min(ans,dp[r-1][i]);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nll dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(D[ship][idx]<cost)continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1))),D[ship][idx+1]=ncost;\n\n    for(int i=0;i<n;i++){\n      ncost=cost+G[pos][ship][0]+G[ship][i][1]+G[i][npos][0];\n      if(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1))),D[i][idx+1]=ncost;\n    }\n  }\n  assert(0);\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdint.h>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nconst long long INF = 1000000000000;\n//町,村の数\nint n;\n//道の数\nint m;\n//集配先の数\nint R;\n\n//集配順序\nint z[1003];\n\ntypedef pair<long long,long long> P;\ntypedef pair<pair<long long,long long>,pair<long long,long long> > PP;\n\nstruct edge\n{\n\tint to;\n\t//陸なら1\n\tint mode;\n\tlong long cost;\n\tedge(int to,int mode,long long cost) {\n\t\tthis->to = to;\n\t\tthis->mode = mode;\n\t\tthis->cost = cost;\n\t}\n\n};\n\nvector<edge> G[207];\n// 現在の頂点,船のある頂点,どこまで集配したか\nlong long dist[203][203][1003];\n\nlong long dijkstra() {\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tfor (int j = 0; j < 203; j++)\n\t\t{\n\t\t\tfill(dist[i][j],dist[i][j]+1003,INF);\n\t\t}\n\t}\n\tpriority_queue<PP,vector<PP>, greater<PP> > que;\n\n\tdist[0][0][0]=0;\n\n\tque.push(PP(P(0,0),P(0,0)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\n\t\tlong long cost = pp.first.first;\n\t\tlong long v=pp.first.second;\n\t\tlong long u=pp.second.first;\n\t\tlong long index = pp.second.second;\n\t\t\n\n\t\tif(z[index] == v) {\n\t\t\tdist[v][u][index+1]=dist[v][u][index];\n\t\t\tindex++;\n\t\t}\n\n\t\tif(index == R) {\n\t\t\t//dist[v][u][index+1]=dist[v][u][index];\n\t\t\tbreak;\n\t\t}\n\n\t\tif(dist[v][u][index] < cost) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t//printf(\"[debug] %d %d %d %d\\n\",cost,v,u,index);\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\t//printf(\"        %d %d %d\\n\",e.to,e.mode,e.cost);\n\n\t\t\t//船を使う\n\t\t\tif(u==v && e.mode == 0) {\n\t\t\t\t//printf(\"%d,%d\\n\",dist[e.to][e.to][index],dist[v][u][index]);\n\t\t\t\tif(dist[e.to][e.to][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][e.to][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][e.to][index],e.to),P(e.to,index)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.mode == 1) {\n\t\t\t\tif(dist[e.to][u][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][u][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][u][index],e.to),P(u,index)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong long ans=INF;\n\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tans=min(ans,dist[z[R-1]][i][R-1]);\n\t} \n\n\treturn ans;\n\n\n}\n\n\nvoid solve() {\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint x,y,t;\n\t\tchar c;\n\t\t//x-y はコスト t で c によって結ばれている\n\t\t\n\t\tcin>>x>>y>>t>>c;\n\t\tx--;\n\t\ty--;\n\t\t\n\t\tG[x].push_back(edge(y,c=='L',t));\n\t\tG[y].push_back(edge(x,c=='L',t));\n\t}\n\n\tcin>>R;\n\n\tfor (int i = 0; i < R; i++)\n\t{\n\t\tcin>>z[i];\n\t\tz[i]--;\n\t}\n\n\tcout<<dijkstra()<<endl;\n\t\n\tfor (int i = 0; i < 207; i++)\n\t{\n\t\tG[i].clear();\n\t}\n}\n\nint main() {\n\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<62;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    vector<pii> graph[256][2];\n    rep(i,0,m){\n        int x,y,t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        int a=(sl=='L'?0:1);\n        graph[x][a].push_back(make_pair(y,t));\n        graph[y][a].push_back(make_pair(x,t));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n    if(r==1){\n        cout << 0 << endl;\n        return;\n    }\n\n    typedef tuple<int,int,int> tpl;\n    static ll dist[128][128][1024];\n    fill_n((ll*)dist,128*128*1024,inf);\n    priority_queue<pair<ll,tpl>,vector<pair<ll,tpl>>,greater<pair<ll,tpl>>> que;\n    dist[z[0]][z[0]][1]=true;\n    que.push(make_pair(0,make_tuple(z[0],z[0],1)));\n    while(!que.empty()){\n        auto t=que.top();\n        que.pop();\n        ll d=t.first;\n        int p1=get<0>(t.second),p2=get<1>(t.second),num=get<2>(t.second);\n        if(d>dist[p1][p2][num]) continue;\n        if(p1==z.back() and num==r){\n            cout << d << endl;\n            return;\n        }\n        for(auto &e:graph[p1][0]){\n            int p_=e.first;\n            ll d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p2][num_]) continue;\n            dist[p_][p2][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p2,num_)));\n        }\n        if(p1!=p2) continue;\n        for(auto &e:graph[p1][1]){\n            int p_=e.first;\n            ll d_=d+e.second;\n            int num_=num+(p_==z[num]?1:0);\n            if(d_>=dist[p_][p_][num_]) continue;\n            dist[p_][p_][num_]=d_;\n            que.push(make_pair(d_,make_tuple(p_,p_,num_)));\n        }\n    }\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M,R;\nvector<int> A;\nll edgeL [201] [201],edgeS [201] [201];\nll dp [1001] [201];\nconst ll INF = 1e18;\n\nint main()\n{\n\twhile(cin >> N >> M && N){\n\t\tfill(edgeL [0],edgeL [201],INF);\n\t\tfill(edgeS [0],edgeS [201],INF);\n\t\tFOR(i,1,N + 1){\n\t\t\tedgeL [i] [i] = 0;\n\t\t\tedgeS [i] [i] = 0;\n\t\t}\n\t\tFOR(i,0,M){\n\t\t\tint u,v,w;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> w >> c;\n\t\t\tif(c == 'L'){\n\t\t\t\tchmin(edgeL [u] [v],(ll) w);\n\t\t\t\tchmin(edgeL [v] [u],(ll) w);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchmin(edgeS [u] [v],(ll) w);\n\t\t\t\tchmin(edgeS [v] [u],(ll) w);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tA.assign(R + 1,1);\n\t\tFOR(i,1,R + 1){\n\t\t\tscanf(\"%d\",&A [i]);\n\t\t}\n\n\t\tFOR(k,1,N + 1) FOR(i,1,N + 1) FOR(j,1,N + 1){\n\t\t\tchmin(edgeL [i] [j],edgeL [i] [k] + edgeL [k] [j]);\n\t\t\tedgeL [j] [i] = edgeL [i] [j];\n\t\t\tchmin(edgeS [i] [j],edgeS [i] [k] + edgeS [k] [j]);\n\t\t\tedgeS [j] [i] = edgeS [i] [j];\n\t\t}\n\n\t\tfill(dp [0],dp [1001],INF);\n\t\tdp [0] [1] = 0;\n\t\tFOR(i,0,R) FOR(j,1,N + 1) if(dp [i] [j] < INF){\n\t\t\tchmin(dp [i + 1] [j],dp [i] [j] + edgeL [A [i]] [A [i + 1]]);\n\t\t\tFOR(nxt,1,N + 1){\n\t\t\t\tchmin(dp [i + 1] [nxt],dp [i] [j] + edgeL [A [i]] [j] + edgeS [j] [nxt] + edgeL [nxt] [A [i + 1]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",*min_element(dp [R],dp [R + 1]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 500000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<int>> riku(n,vector<int>(n,INF));\n    vector<vector<int>> kai(n,vector<int>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    int x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    int r;\n    cin >> r;\n    vector<int> z(r+1);\n    z[0]=0;\n    for(int i=1;i<=r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<int>> dp(r+1,vector<int>(n,INF));\n    dp[0][0]=0;\n    for(int i=1;i<=r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    int ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x1f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvll land;\n\t\tvvll sea;\n\t\tinitvv(land,n,n,INFL);\n\t\tinitvv(sea,n,n,INFL);\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tll c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L') land[a][b]=mins(land[b][a],c);\n\t\t\telse sea[a][b]=mins(sea[b][a],c);\n\t\t}\n\t\trep(j,n) land[j][j]=sea[j][j]=0;\n\t\trep(k,n) rep(i,n) rep(j,n) mins(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n) rep(i,n) rep(j,n) mins(sea[i][j],sea[i][k]+sea[k][j]);\n\t\tint r;\n\t\tcin>>r;\n\t\tvint v(r);\n\t\trep(i,r){\n\t\t\tcin>>v[i],v[i]--;\n\t\t}\n\t\tvll pre(n,INFL);\n\t\tpre[v[0]]=0;\n\t\trep(i,r-1){\n\t\t\tvll dp(n,INFL);\n\t\t\trep(k,n){\n\t\t\t\tmins(dp[k],pre[k]+land[v[i]][v[i+1]]);\n\t\t\t\trep(l,n){\n\t\t\t\t\tmins(dp[l],pre[k]+land[v[i]][k]+sea[k][l]+land[l][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp,pre);\n\t\t}\n\t\tcout<< *min_element(ALL(pre))<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][now]=0;\n\t    \n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1].begin(),dp[r-1].end()));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    ll land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<201;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;ll t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=min(sea[x][y],t);\n        sea[y][x]=min(sea[x][y],t);\n      }else{\n        land[x][y]=min(sea[x][y],t);\n        land[y][x]=min(sea[x][y],t);\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>a[i];a[i]--;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    ll dp[1001][201];\n    for(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n        }\n      }\n    }\n    /*for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        cout<<dp[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;*/\n    ll ans=inf;\n    for(int i=0;i<201;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    //cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct Postman { int pos; int ship; int cost; };\n\nint V, E, R;\nint DL[MAX_V][MAX_V], DS[MAX_V][MAX_V], DP[MAX_R][MAX_V], PATH[MAX_R];\n\nvoid warshall_floyd(int d[][MAX_V]) {\n  for (size_t w = 0; w < V; w++)\n    for (size_t u = 0; u < V; u++)\n      for (size_t v = 0; v < V; v++) d[u][v] = min(d[u][v], d[u][w] + d[w][v]);\n}\n\nvoid solve() {\n  warshall_floyd(DL);\n  warshall_floyd(DS);\n\n  for (size_t i = 0; i < R; i++)\n    for (size_t v = 0; v < V; v++) DP[i][v] = INF;\n  DP[0][PATH[0]] = 0;\n\n  for (size_t i = 1; i < R; i++) {\n    int u = PATH[i - 1], v = PATH[i];\n    for (int w = 0; w < V; w++) {\n      for (int x = 0; x < V; x++) {\n        int d = DP[i-1][w] + DL[u][w] + DS[w][x] + DL[x][v];\n//        printf(\"DP[%d][%d]+DL[%d][%d]+DS[%d][%d]+DL[%d][%d] = %d\\n\",i-1,w,u,w,w,x,x,v,d);\n        DP[i][x] = (0 <= d && d < INF)? min(DP[i][x], d): DP[i][x];\n      }\n    }\n  }\n\n  int ans = INF;\n  for (size_t v = 0; v < V; v++) {\n    ans = min(ans, DP[R-1][v]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t v = 0; v < V; v++)\n      for (size_t u = 0; u < V; u++) DL[v][u] = DS[v][u] = (u == v)? 0: INF;\n\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost; char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      if (c == 'L') {\n        DL[u][v] = DL[v][u] = min(DL[u][v], cost);\n      } else {\n        DS[u][v] = DS[v][u] = min(DS[u][v], cost);\n      }\n    }\n\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#define INF 5e8\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\nint main()\n{\n\twhile(1){\n\t\tint n, m;\n\t\tcin>>n>>m;\n\t\tif(n==0 && m==0) return 0;\n\t\tint l[200][200], s[200][200];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tl[i][j]=0, s[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tl[i][j]=INF, s[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--; y--;\n\t\t\tif(sl=='L'){\n\t\t\t\tl[x][y]=min(l[x][y], t);\n\t\t\t\tl[y][x]=l[x][y];\n\t\t\t}else{\n\t\t\t\ts[x][y]=min(s[x][y], t);\n\t\t\t\ts[y][x]=s[x][y];\n\t\t\t}\n\t\t}\n\t\tfor(int k=0; k<n; k++){\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tif(l[i][j]>l[i][k]+l[k][j]) l[i][j]=l[i][k]+l[k][j];\n\t\t\t\t\tif(s[i][j]>s[i][k]+s[k][j]) s[i][j]=s[i][k]+s[k][j];\n\t\t\t\t}\n\t\t\t}\n        }\n\t\tint r;\n\t\tcin>>r;\n\t\tint z, w;\n\t\tcin>>z;\n\t\tz--;\n\t\tint ans[1000][200];\n\t\tfor(int i=0; i<r; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==0 && j==z) ans[i][j]=0;\n\t\t\t\telse ans[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1; i<r; i++){\n\t\t\tcin>>w;\n          w--;\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(j==k){\n\t\t\t\t\t\tans[i][j]=min(ans[i][j], ans[i-1][j]+l[z][w]);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tans[i][j]=min(ans[i][j], ans[i-1][k]+l[z][k]+s[k][j]+l[j][w]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tz=w;\n\t\t}\n\t\tint ans0=INF;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tans0=min(ans0, ans[r-1][i]);\n\t\t}\n\t\tcout<<ans0<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tll d;\n\tint z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nll dp[205][205];\t\t// boat, n\nll ans[205];  // boat\n\nll solve(){\n\tpriority_queue<ST> que;\n\tll d, z, b, n;\n\t//dp[ Z[0] ][ Z[0] ] = 0;\n\tans[ Z[0] ] = 0;\n\trep(i,R-1){\n\t\trep(b,N) if( ans[b] < INF ){\n\t\t\tque.push( ST{ans[b], i, b, Z[i]} );\n\t\t}\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\twhile( !que.empty() ){\n\t\t\tST st = que.top();\n\t\t\tque.pop();\n\t\t\td = st.d;\n\t\t\tz = st.z;\n\t\t\tb = st.b;\n\t\t\tn = st.n;\n\t\t\tif( dp[b][n] < d ) continue;\n\t\t\tdp[b][n] = d;\n\t\t\t//cout << \"hit \" << d << \" \" << z << \" \" << b << \" \" << n << endl;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\t\tint to = _v.first;\n\t\t\t\t\tll cost = _v.second;\n\t\t\t\t\tint nz = z, nb = b;\n\t\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\t\tif( k ) nb = to;\n\t\t\t\t\tif( chmin(dp[nb][to], dp[b][n] + cost) ){\n\t\t\t\t\t\tll nd = dp[b][n] + cost;\n\t\t\t\t\t\tif( nz == z ){\n\t\t\t\t\t\t\tque.push( ST{ nd, nz, nb, to } );\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tchmin( ans[nb], nd );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ret = INF;\n\trep(b,N){\n\t\tchmin( ret, ans[b] );\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x, y, t;\n\tchar sl;\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <cstring>\n#include <algorithm>\n#define ll long long\nusing namespace std;\nconst int NUM=210;\nll travel[10000];\nint n,m,num;\nll land[NUM][NUM],water[NUM][NUM],dp[10000][NUM];\nll solve();\nint main()\n{\n    int u,v,c;\n    char ch;\n    while(~scanf(\"%d%d\",&n,&m)&&n+m)\n    {\n        memset(land,0xf,sizeof land);\n        memset(water,0xf,sizeof water);\n        memset(dp,0xf,sizeof dp);\n        for (int i=0; i<m; i++)\n        {\n            scanf(\"%d%d%d %c\",&u,&v,&c,&ch);\n            if (ch=='L')\n                land[u][v]=land[v][u]=c;\n            else\n                water[u][v]=water[v][u]=c;\n        }\n        for (int i=1; i<=n; i++)\n            land[i][i]=water[i][i]=0;\n        scanf(\"%d\",&num);\n        for (int i=1; i<=num; i++)\n            scanf(\"%d\",&travel[i]);\n        ll ans=solve();\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}\nll solve()\n{\n    for (int k=1; k<=n; k++)\n        for (int i=1; i<=n; i++)\n            for (int j=1; j<=n; j++)\n            {\n                water[i][j]=min(water[i][j],water[i][k]+water[k][j]);\n                land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            }\n    dp[1][travel[1]]=0;\n    for (int i=1; i<=num; i++)\n    {\n        for (int j=1; j<=n; j++)\n        {\n            dp[i][j]=min(dp[i][j],dp[i-1][j]+land[travel[i-1]][travel[i]]);\n            for (int k=1; k<=n; k++)\n            {\n                dp[i][k]=min(dp[i][k],dp[i-1][j]+land[travel[i-1]][j]+water[j][k]+land[k][travel[i]]);\n            }\n        }\n    }\n    ll ans=0x5fffffff;\n    for (int i=1; i<=n; i++)\n        ans=min(ans,dp[num][i]);\n    return ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll l[201][201];\nll s[201][201];\nll dp[1001][201];\n\n\nint main(){\n\tint n,m,r;\n\twhile(cin >> n >> m && n!=0){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tl[i][j] = inf;\n\t\t\t\ts[i][j] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tl[i][j] = 0;\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(c=='L'){\n\t\t\t\tl[x][y] = min(l[x][y],t);\n\t\t\t\tl[y][x] = min(l[x][y],t);\n\t\t\t}else{\n\t\t\t\ts[x][y] = min(s[x][y],t);\n\t\t\t\ts[y][x] = min(s[x][y],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tl[i][j] = min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j] = min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst int INF = 10000000;\n\nint main(){\n    while(true){\n        int N,M;\n        cin >> N >> M;\n        if(N == 0 and M == 0) break;\n        vector<vector<vector<int> > > dist(2,vector<vector<int> >(N,vector<int>(N,INF)));\n        for(int i=0;i<M;i++){\n            int x,y,t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;y--;\n            int isl = (sl=='L')?0:1;\n            dist[isl][x][y] = min(dist[isl][x][y],t);\n            dist[isl][y][x] = min(dist[isl][y][x],t);\n        }\n        for(int i=0;i<N;i++){\n            dist[0][i][i] = dist[1][i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[0][i][j] = min(dist[0][i][j],dist[0][i][k]+dist[0][k][j]);\n                    dist[1][i][j] = min(dist[1][i][j],dist[1][i][k]+dist[1][k][j]);\n                }\n            }\n        }\n        int R;\n        cin >> R;\n        vector<int> togo(R);\n        for(int i=0;i<R;i++){\n            cin >> togo[i];\n            togo[i]--;\n        }\n        vector<vector<int> > dp(R,vector<int>(N,INF));\n        dp[0][togo[0]] = 0;\n        for(int i=0;i<R-1;i++){\n            for(int j=0;j<N;j++){\n                if(dp[i][j] == INF) continue;\n                for(int k=0;k<N;k++){\n                    dp[i+1][k] = min(dp[i+1][k],dp[i][j] + \n                            dist[0][togo[i]][j] +\n                            dist[1][j][k] +\n                            dist[0][k][togo[i+1]]);\n                }\n            }\n        }\n        int ret = INF;\n        for(int i=0;i<N;i++){\n            ret = min(ret,dp[R-1][i]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nint main(void){\n  int N, M, R;\n  while (cin >> N >> M) \n    {\n      if (N == 0 && M == 0)\n\tbreak;\n      int x,y,t;\n      char sl;\n      vector<VI> land(N, VI(N, INT_MAX/4)), sea(N, VI(N, INT_MAX/4));\n      REP(i,0,M)\n\t{\n\t  cin >> x >> y >> t >> sl;\n\t  if (sl == 'L') \n\t    {\n\t      land[x-1][y-1] = t;\n\t      land[y-1][x-1] = t;\n\t    }\n\t  else\n\t    {\n\t      sea[x-1][y-1] = t;\n\t      sea[y-1][x-1] = t;\n\t    }\n\t}\n      cin >> R;\n      VI z(R);\n      REP(i,0,R)\n\t{\n\t  cin >> z[i];\n\t  z[i]--;\n\t}\n      REP(i,0,N)\n\t{\n\t  land[i][i] = 0;\n\t  sea[i][i] = 0;\n\t}\n      for (int r = 0; r < N; r++)\n\tfor (int p = 0; p < N; p++)\n\t  for (int q = 0; q < N; q++)\n\t    {\n\t      if (land[p][q] > land[p][r] + land[r][q])\n\t\tland[p][q] = land[p][r] + land[r][q];\n\t      if (sea[p][q] > sea[p][r] + sea[r][q])\n\t\tsea[p][q] = sea[p][r] + sea[r][q];\n\t    }\n      vector<vector<ll> > dp(N, vector<ll>(R, INT_MAX/2));\n      dp[0][z[0]] = 0;\n      REP(i,1,R)\n\t  REP(j,0,N)\n\t      REP(k, 0, N)\n\t\t  dp[i][j] = min(dp[i][j], dp[i-1][k] + land[z[i-1]][k]+ sea[k][j] + land[j][z[i]]);\n      ll min_cost = dp[R-1][0];\n      REP(i, 1,R)\n\tmin_cost = min(min_cost, dp[R-1][i]);\n      cout << min_cost<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nconst ll inf=0x1f1f1f1f1f1f1f1f;//?造了一个三倍之后不会溢出的?..... \nconst ll maxn=205;\nll land[maxn][maxn],sea[maxn][maxn],num[maxn*5],cost[maxn*5][maxn];\nvoid init(int n)\n{\n\tmemset(land,inf,sizeof(land));\n\tmemset(sea,inf,sizeof(sea));\n\tmemset(cost,inf,sizeof(cost));\n\tfor(ll i=1;i<=n;++i)\n\t{\n\t\tsea[i][i]=land[i][i]=0;\n\t}\n}\nll slove(ll n,ll m,ll w)\n{\n\tfor(ll k=1;k<=n;++k)\n\t{\n\t\tfor(ll i=1;i<=n;++i)\n\t\t{\n\t\t\tfor(ll j=1;j<=n;++j)\n\t\t\t{\n\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcost[1][num[1]]=0;\n\tfor(ll i=1;i<=w;++i)\n\t{\n\t\tfor(ll j=1;j<=n;++j)\n\t\t{\n\t\t\tcost[i][j]=min(cost[i][j],cost[i-1][j]+land[num[i-1]][num[i]]);\n\t\t\tfor(ll k=1;k<=n;++k)\n\t\t\t{\n\t\t\t\tcost[i][k]=min(cost[i][k],\n\t\t\t\tcost[i-1][j]+land[num[i-1]][j]+sea[j][k]+land[k][num[i]]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=inf;\n\tfor(ll i=1;i<=n;++i)\n\t{\n\t\tans=min(ans,cost[w][i]);\n\t}\n\t//return *min_element(cost[w],cost[w]+n+1);\n\treturn ans;\n}\nint main()\n{\n\tll n,m;\n\twhile(scanf(\"%lld%lld\",&n,&m),n|m)\n\t{\n\t\tinit(n);\n\t\tfor(ll i=0;i<m;++i)\n\t\t{\n\t\t\tll a,b,c;char ch[10];\n\t\t\tscanf(\"%lld%lld%lld%s\",&a,&b,&c,ch);\n\t\t\tif(ch[0]=='S')\n\t\t\t{\n\t\t\t\tsea[a][b]=sea[b][a]=min(sea[a][b],c);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tland[a][b]=land[b][a]=min(land[a][b],c);\n\t\t\t}\n\t\t}\n\t\tll w;\n\t\tscanf(\"%lld\",&w);\n\t\tfor(ll i=1;i<=w;++i)\n\t\t{\n\t\t\tscanf(\"%lld\",&num[i]);\n\t\t}\n\t\tprintf(\"%lld\\n\",slove(n,m,w));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\n\nconst lint INF = 1ll << 56;\ninline void chmin(lint &a, lint b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1001];\n\nlint solve()\n{\n\tstatic lint ldist[200][200];\n\tstatic lint sdist[200][200];\n\tstatic lint dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1001 * 200, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tlint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r], dp[r + 1]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl == \"L\") ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#define RG register\n#define IL inline\n#define pi acos(-1.0)\n#define ll long long\n#define inf 1<<28\nusing namespace std;\n\nint n,m,R;\nlong long land[300][300],water[300][300],dp[1005][300];\nint a[1005];\n\nvoid pre(){\n\tmemset(dp,60,sizeof(dp));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t  land[i][j]=land[j][i]=inf;\n\t\t  water[i][j]=water[j][i]=inf;\n\t\t}\n}\n\nvoid floyd(){\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(k==i||k==j||i==j) continue;\n\t\t\t\twater[i][j]=min(water[i][j],water[i][k]+water[k][j]);\n\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t}\n}\n\nint main(){\n\twhile(1){\n   scanf(\"%d%d\",&n,&m);\n\t if(n==0&&m==0) break;\n\t pre();\n\t for(int i=1;i<=m;i++){\n\t\t int l,r; string str;\n     long long w;\n\t\t scanf(\"%d%d%lld\",&l,&r,&w);\n\t\t cin>>str;\n\t\t if(str==\"L\") land[l][r]=land[r][l]=min(land[r][l],w);\n\t\t else water[l][r]=water[r][l]=min(water[r][l],w);\n\t }\n\tfor(int i=1;i<=n;i++)\n\t\t land[i][i]=0,water[i][i]=0;\n  floyd();\n\tscanf(\"%d\",&R);\n\ta[0]=1; dp[0][1]=0;\n\tfor(int i=1;i<=R;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=R;i++)//目的地\n\t\tfor(int j=1;j<=n;j++)//上一次的下船点\n\t\t\tfor(int type=1;type<=2;type++){\n\t\t\t\tif(type==1) dp[i][j]=min(dp[i][j],land[a[i-1]][a[i]]+dp[i-1][j]);//走?地\n\t\t\t\telse\n\t\t\t\t\tfor(int k=1;k<=n;k++)//新的下船点\n\t\t\t\t\t\t dp[i][k]=min(dp[i][k],dp[i-1][j]+land[a[i-1]][j]+water[j][k]+land[k][a[i]]);//走水路\n\t\t\t}\n   long long minn=inf;\n\t for(int i=1;i<=n;i++)\n\t\t  minn=min(minn,dp[R][i]);\n\t printf(\"%lld\\n\",minn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n#define debug(x) cout << #x << \" = \" << x << endl;\n#define sq(x) ((x)*(x))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\n\nint Lcost[205][205];\nint Scost[205][205];\n\nint dp[1005][205];\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n|m){\n\t\tstatic const int INF = 1e8;\n\t\trep(i, n) rep(j, n){\n\t\t\tif(i == j) continue;\n\t\t\tLcost[i][j] = INF;\n\t\t\tScost[i][j] = INF;\n\t\t}\n\t\trep(i, m){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tLcost[x][y] = Lcost[y][x] = t;\n\t\t\t}else{\n\t\t\t\tScost[x][y] = Scost[y][x] = t;\n\t\t\t}\n\t\t}\n\t\trep(i, n) rep(j, n) rep(k, n){\n\t\t\tLcost[j][k] = min(Lcost[j][k], Lcost[j][i] + Lcost[i][k]);\n\t\t\tScost[j][k] = min(Scost[j][k], Scost[j][i] + Scost[i][k]);\n\t\t}\n\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\trep(i, r) rep(j, n) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 1; i < r; i++){\n\t\t\tint pos = z[i-1];\n\t\t\tint next = z[i];\n\t\t\trep(j, n){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j]+Lcost[pos][next]);\n\t\t\t\trep(k, n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+Lcost[pos][j]+Scost[j][k]+Lcost[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(i, n) ans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\n#ifdef DEBUG\n#include <cassert>\n#define debug(a) a\n#else\n#define debug(a)\n#endif\nusing namespace std;\ntypedef long long ll;\ntypedef size_t index;\n#define repeat(i,n) for (index i = 0; i < n; ++i)\n#define repeat1(i,n) for (index i = 1; i < n; ++i)\n#define repeat_from(i,m,n) for (index i = m; i < n; ++i)\n\n#define MAX_N 200\n#define MAX_M 10000\n#define MAX_R 1000\n#define MAX_T 1000\nindex N, M, R;\n#define S 0\n#define L 1\n#define SL 2\nint edge[MAX_N][MAX_N][SL];\nindex walk[MAX_R];\n\nstruct state {\n    index query; // [0,R)\n    index pos; // [0,N)\n    index ship; // [0,N)\n};\nbool operator<(const state & a, const state & b) { return a.query != b.query ? a.query > b.query : a.pos != b.pos ? a.pos > b.pos : a.ship > b.ship; }\ntypedef pair<state,ll> psttl;\nbool operator<(const psttl & a, const psttl & b) { return a.second != b.second ? a.second > b.second : a.first.query > b.first.query; }\ntypedef map<state,ll> mapsttl;\ntypedef priority_queue<psttl> pquelstt;\n\n\nint main() {\n    while (true) {\n        cin >> N >> M;\n        if (not N or not M) break;\n        repeat (i,N) repeat (j,N) repeat (k,2) edge[i][j][k] = i == j ? 0 : -1;\n        repeat (i,M) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t; cin.ignore(); cin >> sl;\n            debug(assert(sl == 'S' or sl == 'L'));\n            -- x; -- y;\n            sl = sl == 'S' ? S : L;\n            if (not (x < y)) swap(x, y);\n            edge[y][x][sl] = (edge[x][y][sl] = edge[x][y][sl] == -1 ? t : min(edge[x][y][sl], t));\n        }\n        repeat (sl,SL) repeat (k,N) repeat (i,N) repeat (j,N) {\n            if (edge[i][k][sl] != -1 and edge[k][j][sl] != -1) {\n                edge[j][i][sl] = edge[i][j][sl] = min(edge[i][j][sl], edge[i][k][sl] + edge[k][j][sl]);\n            }\n        }\n        cin >> R;\n        repeat (i,R) { cin >> walk[i]; -- walk[i]; }\n        pquelstt que = pquelstt(); {\n            int r = 0; while (walk[r] == 0) { ++ r; }\n            que.push(psttl((state){r, 0, 0}, 0));\n        }\n        mapsttl memo = mapsttl();\n        while (true) {\n            debug(assert(not que.empty()));\n            psttl a = que.top(); que.pop();\n            if (a.first.query == R and a.first.pos == walk[R-1]) {\n                cout << a.second << endl;\n                break;\n            }\n            memo.insert(a);\n            repeat (i,N) {\n                repeat (sl,SL) {\n                    if (sl == S and a.first.ship != a.first.pos) continue;\n                    if (0 < edge[a.first.pos][i][sl]) {\n                        state s;\n                        s.query = a.first.query + (i == walk[a.first.query] ? 1 : 0);\n                        s.pos = i;\n                        s.ship = sl == S ? i : a.first.ship;\n                        psttl b = psttl(s, a.second + edge[a.first.pos][i][sl]);\n                        if (not memo.count(s)) que.push(b);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2200 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2200)\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<limits>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconst int MAX_N = 200, MAX_R = 1000, INF = std::numeric_limits<int>::max()>>4;\n\nint N, M, R;\nint land[MAX_N][MAX_N], sea[MAX_N][MAX_N];\nint dp[MAX_R+1][MAX_N];\nint z[MAX_R];\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &N, &M ), N|M )\n\t{\n\t\trep( i, N ) rep( j, N )\n\t\t\tland[i][j] = sea[i][j] = i==j?0:INF;\n\n\t\trep( i, M )\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl[2];\n\n\t\t\tscanf( \"%d%d%d%s\", &x, &y, &t, sl );\n\t\t\t--x; --y;\n\n\t\t\tauto mat = *sl=='L'?land:sea;\n\t\t\tmat[x][y] = mat[y][x] = std::min( mat[x][y], t );\n\t\t}\n\n\t\tscanf( \"%d\", &R );\n\t\trep( i, R )\n\t\t\tscanf( \"%d\", z+i ), --z[i];\n\n\t\trep( k, N ) rep( i, N ) rep( j, N )\n\t\t{\n\t\t\tland[i][j] = std::min( land[i][j], land[i][k]+land[k][j] );\n\t\t\tsea[i][j] = std::min( sea[i][j], sea[i][k]+sea[k][j] );\n\t\t}\n\n\t\trep( i, R+1 ) rep( j, N+1 )\n\t\t\tdp[i][j] = INF;\n\t\t\n\t\tdp[0][z[0]] = 0;\n\t\trep( i, R-1 ) rep( j, N ) rep( k, N )\n\t\t{\n\t\t\tif( j != k )\n\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][k]+land[z[i]][k]+sea[k][j]+land[j][z[i+1]] );\n\t\t\telse\n\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][j]+land[z[i]][z[i+1]] );\n\t\t}\n\n\t\tprintf( \"%d\\n\", *std::min_element( dp[R-1], dp[R-1]+N ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//#include <iostream>\n\nusing namespace std;\ntypedef long long ll;\n\nconst int MAX_E = 100005, MAX_V = 205, MAX_R = 1001;\nconst int INF = 1e+7+1;\n\nint GL[MAX_V][MAX_V];\nint GS[MAX_V][MAX_V];\n\nint V,E;\n\nvoid init(){\n    for(int i = 0;i < V;i++){\n        for(int j = 0;j < V;j++){\n            GL[i][j] = GS[i][j] = INF;\n            if(i == j) GL[i][j] = GS[i][j] = 0;\n        }\n    }\n}\n\nvoid floyd(){\n    for(int k = 0;k < V;k++)\n        for(int i = 0;i < V;i++)\n            for(int j = 0;j < V;j++){\n                GL[i][j] = min(GL[i][j], GL[i][k]+GL[k][j]);\n                GS[i][j] = min(GS[i][j], GS[i][k]+GS[k][j]);\n            }\n}\n\nint R;\nint z[MAX_R];\nint dp[MAX_R][MAX_V];//此时船在j点的情况下,完成前i个任务的最小时间\n\nvoid solve(){\n    floyd();\n\n    for(int i = 0;i < R;i++){\n        for(int j = 0;j < V;j++){\n            dp[i][j] = INF;\n        }\n    }\n\n//    cout<<\"______________________________________\"<<endl;\n//    for(int i = 0;i < V;i++){\n//        for(int j = 0;j < V;j++){\n//            cout<<setw(9)<<GS[i][j]<<' ';\n//        }\n//        cout<<endl;\n//    }\n//\n//    cout<<\"______________________________________\"<<endl;\n//    for(int i = 0;i < V;i++){\n//        for(int j = 0;j < V;j++){\n//            cout<<setw(9)<<GL[i][j]<<' ';\n//        }\n//        cout<<endl;\n//    }\n\n    dp[0][z[0]] = 0;//默认第一个点ok了,且更第二个点的时候没法用dp[0][z[0]以外]的更,因为刚开始船只在z[0]\n\n    for(int i = 1;i < R;i++){\n        for(int j = 0;j < V;j++){//上次船停到哪\n            dp[i][j] = min(dp[i][j], dp[i-1][j]+GL[z[i-1]][z[i]]);//只走陆路\n            for(int k = 0;k < V;k++){//这次船要停哪\n                if(j != k)\n                    dp[i][k] = min(dp[i][k], dp[i-1][j]+GL[z[i-1]][j]+GS[j][k]+GL[k][z[i]]);//走陆路到船,走水路到停船,走陆路\n            }\n\n        }\n    }\n    int mint = INF;\n    for(int i = 0;i < V;i++){\n        mint = min(mint, dp[R-1][i]);\n    }\n//    cout<<\"______________________________________\"<<endl;\n//    for(int i = 0;i < V;i++){\n//        for(int j = 0;j < V;j++){\n//            cout<<setw(9)<<dp[i][j]<<' ';\n//        }\n//        cout<<endl;\n//    }\n    printf(\"%d\\n\", mint);\n}\n\nint main() {\n    while(~scanf(\"%d%d\", &V, &E)){\n        if(V==0&&E==0) break;\n\n        init();\n\n        for(int i = 0;i < E;i++){\n            int s,t,d;\n            char w;\n            scanf(\"%d %d %d %c\", &s,&t,&d,&w);\n            s--;t--;\n            if(w == 'L') GL[s][t] = GL[t][s] = min(d,GL[s][t]);\n            else GS[s][t] = GS[t][s] = min(d,GS[s][t]);\n        }\n\n\n        scanf(\"%d\", &R);\n        for(int i = 0;i < R;i++){\n            scanf(\"%d\", &z[i]);\n            z[i]--;\n        }\n        solve();\n    }\n    return 0;\n}\n\n\n\n/*\n3 3\n1 2 5 L\n1 2 7 S\n2 3 11 S\n3\n1 2 3\n5 5\n1 2 15 L\n2 3 10 L\n4 5 7 L\n1 3 30 S\n3 4 100 S\n5\n1 3 5 4 1\n0 0\n */\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n  \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n  \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n  \nconst int INF=100000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n  \nint main(){\n    while(1){\n        int n,m;\n        static int ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static int sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)return 0;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static int dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tint ret=1000000000;\n    \trep1(i,n){\n    \t\tret=min(ret,dp[r-1][i]);\n    \t}\n          \n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n\n#define int long long\n\nint road[200][200];\nint sea[200][200];\n\nvoid solve(){\n    while (true) {\n        int n, m;\n        cin >> n >> m;\n        if (n == 0) return;\n        REP(i, n) {\n            REP(q, n) {\n                road[i][q] = 1e9;\n                sea[i][q] = 1e9;\n            }\n            road[i][i] = 0;\n            sea[i][i] = 0;\n        }\n        REP(i, m) {\n            int a, b, c;\n            cin >> a >> b >> c;\n            a--; b--;\n            string d;\n            cin >> d;\n            if (d == \"L\") {\n                road[a][b] = min(road[a][b], c);\n                road[b][a] = min(road[b][a], c);\n            }\n            else {\n                sea[a][b] = min(sea[a][b], c);\n                sea[b][a] = min(sea[b][a], c);\n            }\n        }\n        REP(t, 3) {\n            REP(i, n) {\n                REP(q, n) {\n                    REP(j, n) {\n                        road[q][j] = min(road[q][j], road[i][q] + road[i][j]);\n                        sea[q][j] = min(sea[q][j], sea[q][i] + sea[i][j]);\n                    }\n                }\n            }\n        }\n        int query;\n        cin >> query;\n        vector<int> req;\n        REP(i, query) {\n            int a;\n            cin >> a;\n            a--;\n            req.push_back(a);\n        }\n        vector<vector<int>> dist(query,vector<int>(n,1000000000));\n        dist[0][req[0]] = 0;\n        for (int i = 0; i < query - 1; ++i) {\n            REP(q, n) {\n                dist[i + 1][q] = min(dist[i + 1][q], dist[i][q] + road[req[i]][req[i + 1]]);\n            }\n            vector<int> goi(n, 1e9);\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> next;\n            REP(q, n) {\n                goi[q] = dist[i][q] + road[req[i]][q];\n                next.push(mp(dist[i][q] + road[req[i]][q], q));\n            }\n            while (next.empty() == false) {\n                pair<int, int> now = next.top();\n                next.pop();\n                if (goi[now.second] != now.first) continue;\n                REP(q, n) {\n                    if (goi[q] > sea[now.second][q] + now.first) {\n                        goi[q] = sea[now.second][q] + now.first;\n                        next.push(mp(goi[q], q));\n                    }\n                }\n            }\n            REP(q, n) {\n                dist[i + 1][q] = min(dist[i + 1][q], goi[q] + road[q][req[i + 1]]);\n            }\n        }\n        int ans = 1e18;\n        REP(i, n) {\n            ans = min(dist[req.size()-1][i], ans);\n        }\n        cout << ans << endl;\n    }\n}\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nlong long int llmin(long long int a,long long b){\n  if(a<b) return a;\n  else return b;\n}\n\nint main(){\n  while(1){\n    int n,m,r;\n    long long int sea[N][N];\n    long long int land[N][N];\n    long long int dp[R][N];\n    int z[R];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n        }\n      }\n    }\n    long long int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nconst int inf=0x3f3f3f3f;\nconst int maxn=2e2+10;\nint n,m,num;\nint costl[maxn][maxn],costs[maxn][maxn];\nint dp[1005][maxn];\nint a[1005];\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)&&n&&m)\n    {\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++)\n            {\n                if(i==j)\n                {\n                    costl[i][j]=costs[i][j]=0;\n                }\n                else\n                {\n                     costl[i][j]=costs[i][j]=inf/3;\n                }\n            }\n        for(int i=1;i<=m;i++)\n        {\n            char s[2];\n            int x,y,val;\n            scanf(\"%d%d%d%s\",&x,&y,&val,s);\n            if(s[0]=='L')\n            {\n                costl[x][y]=costl[y][x]=min(val,costl[x][y]);\n            }\n            else\n            {\n                costs[x][y]=costs[y][x]=min(val,costs[x][y]);\n            }\n        }\n        scanf(\"%d\",&num);\n        for(int i=1;i<=num;i++)\n        {\n            scanf(\"%d\",&a[i]);\n        }\n        for(int k=1;k<=n;k++)\n            for(int i=1;i<=n;i++)\n                for(int j=1;j<=n;j++)\n                {\n                    costs[i][j]=min(costs[i][j],costs[i][k]+costs[k][j]);\n                    costl[i][j]=min(costl[i][j],costl[i][k]+costl[k][j]);\n                }\n        memset(dp,0x3f,sizeof(dp));\n        dp[1][a[1]]=0;\n        for(int i=2;i<=num;i++)\n            for(int j=1;j<=n;j++)\n            {\n                dp[i][j]=min(dp[i][j],dp[i-1][j]+costl[a[i-1]][a[i]]);\n                for(int k=1;k<=n;k++)\n                {\n                    //dp[i][k]=min(dp[i][k],dp[i-1][j]+costl[a[i-1]][j]+costs[j][k]+costl[k][a[i]]);\n                    dp[i][j]=min(dp[i][j],dp[i-1][k]+costl[a[i-1]][k]+costs[k][j]+costl[j][a[i]]);\n                }\n            }\n        int ans=inf;\n        for(int i=1;i<=n;i++)\n        {\n            ans=min(ans,dp[num][i]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            /*if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }*/\n            rep(j,n){\n                cmin(dp[i+1][j],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][k],dp[i][j] + Ld[v[i]][j] + Sd[j][k] + Ld[k][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nll dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(D[ship][idx]<cost)continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1))),D[ship][idx+1]=ncost;\n\n    for(int i=0;i<n;i++){\n      ncost=cost+G[pos][ship][0]+G[ship][i][1]+G[i][npos][0];\n      if(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1))),D[i][idx+1]=ncost;\n    }\n  }\n  assert(0);\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\n#include <iostream>\nusing namespace std;\n#define INF 2000*2000\n#define MAX_R 2010\n#define MAX_NODE 210\nint N, M;\nint distS[MAX_NODE][MAX_NODE];//水\nint distL[MAX_NODE][MAX_NODE];//?\nvoid init() {\n\t/*memset(distS, 0x3f, sizeof(distS));\n\tmemset(distL, 0x3f, sizeof(distL));*/\n\tfor (int i = 0; i < N; i++)for (int j = 0; j < N; j++) distS[i][j] = distL[i][j] = INF;\n\tfor (int i = 0; i < N; i++) distL[i][i] = distS[i][i] = 0;\n}\ninline void insertS(int x, int y, int weight) {\n#define NON_DIRECTED\n\tdistS[x][y] = weight;\n#ifdef NON_DIRECTED\n\tdistS[y][x] = weight;    //无向?\n#endif\n}\ninline void insertL(int x, int y, int weight) {\n#define NON_DIRECTED\n\tdistL[x][y] = weight;\n#ifdef NON_DIRECTED\n\tdistL[y][x] = weight;    //无向?\n#endif\n}\nvoid floyd() {\n\tfor (int k = 0; k < N; k++) {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tdistS[i][j] = min(distS[i][j], distS[i][k] + distS[k][j]);\n\t\t\t\tdistL[i][j] = min(distL[i][j], distL[i][k] + distL[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint dp[MAX_R][MAX_NODE];\nint city[MAX_R];\nint main() {\n\tfreopen(\"E:/2200-input.txt\", \"r\", stdin);\n\twhile (EOF != scanf(\"%d %d\", &N, &M) && N) {\n\t\tinit();\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint from, to, dis;\n\t\t\t\n\t\t\tchar type;\n\t\t\tscanf(\"%d %d %d %c\", &from, &to, &dis, &type);\n\t\t\tfrom--; to--;\n\t\t\tif (type == 'S')\n\t\t\t\tinsertS(from, to, dis);\n\t\t\telse if (type == 'L')\n\t\t\t\tinsertL(from, to, dis);\n\t\t}\n\t\tint city_cnt;\n\t\tscanf(\"%d\", &city_cnt);\n\t\tfor (int i = 0; i < city_cnt; i++) {\n\t\t\tscanf(\"%d\", &city[i]);\n\t\t\tcity[i]--;\n\t\t}\n\t\tfloyd();\n\n\n\t\tfor (int i = 0; i < city_cnt; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\t// 初始化拜?完第一个地点?的情况（?是拜?其?只是去?船，因?一?始就在第一个地点）\n\t\t\t// 走水路去i（??去把船?到i= =）\t+ 走回起点\n\t\t\tdp[0][i] = distS[city[0]][i] + distL[i][city[0]];\n\t\t}\n\t\tfor (int i = 1; i < city_cnt; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t{\n\t\t\t\t\t\t//到i-1已知的最短路     + 从i-1站走?路去j+ 从j走水路去k+从k走?路去i （从j到k也是??去?船的= =）\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + distL[city[i - 1]][j] + distS[j][k] + distL[k][city[i]]);\n\t\t\t\t\t}\n\t\t\t\t\telse //j==k\n\t\t\t\t\t{\n\t\t\t\t\t\t//(i-1)     + 从i-1走?路去i（因?不用移?船）\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + distL[city[i - 1]][city[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *min_element(dp[city_cnt - 1], dp[city_cnt - 1] + N) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n          if(k==j) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/4\n#define MAX_N 1000000001\n\nint main(){\n    cin.sync_with_stdio(false);\n    int n, m, r;\n    while(cin >> n >> m, n | m) {\n        int d[n][n][2];\n        rep(i, n)rep(j, n) d[i][j][0] = d[i][j][1] = (i != j) ? INF : 0;\n\n        map<int, int> sea;\n        int cnt = 0;\n        rep(i, m) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl; x--, y--;\n            if (t < d[x][y][sl == 'S']) d[x][y][sl == 'S'] = d[y][x][sl == 'S'] = t;\n            if (sl == 'S') {\n                if (!sea.count(x)) sea[x] = cnt++;\n                if (!sea.count(y)) sea[y] = cnt++;\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(i, r) cin >> z[i], z[i]--;\n\n        rep(i, n)rep(j, n)rep(k, n) {\n            minch(d[j][k][0], d[j][i][0] + d[i][k][0]);\n            minch(d[j][k][1], d[j][i][1] + d[i][k][1]);\n        }\n\n        if (cnt > 0) {\n            int dp[r][cnt];\n            rep(i, r)rep(j, cnt) dp[i][j] = INF;\n            dp[0][sea[z[0]]] = 0;\n            repl(i, 1, r) {\n                each(j, sea) {\n                    minch(dp[i][j.se], dp[i - 1][j.se] + d[z[i - 1]][z[i]][0]);\n                    each(k, sea) {\n                        minch(dp[i][j.se], dp[i - 1][k.se] + d[z[i - 1]][k.fi][0] + d[k.fi][j.fi][1] + d[j.fi][z[i]][0]);\n                    }\n                }\n            }\n            int ans = INF;\n            rep(i, cnt) minch(ans, dp[r - 1][i]);\n            cout << ans << endl;\n        } else {\n            int ans = 0;\n            rep(i, r - 1) {\n                ans += d[z[i]][z[i + 1]][0];\n            }\n            cout << ans << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e8;\nconst int maxq = 1024;\nconst int maxn = 255;\n\nint dp[maxq][maxn], l[maxn][maxn], s[maxn][maxn];\nint a[maxq];\nint n, m, q;\n\nvoid init() {\n    for(int k = 0; k < n; k ++) {\n        for(int i = 0; i < n; i ++) {\n            for(int j = 0; j < n; j ++) {\n                l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for(int i = 0; i < q; i ++)\n        for(int j = 0; j < n; j ++)\n            dp[i][j] = INF;\n    for(int i = 0; i < n; i ++) \n        dp[0][i] = min(dp[0][i], s[a[0]][i] + l[i][a[0]]);\n    for(int i = 1; i < q; i ++) {\n        for(int j = 0; j < n; j ++) {\n            for(int k = 0; k < n; k ++) {\n                dp[i][k] = min(dp[i][k], dp[i-1][j] + l[a[i-1]][j] + s[j][k] + l[k][a[i]]);\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 0; i < n; i ++)\n        ans = min(ans, dp[q-1][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        if(n==0 && m==0) break;\n        for(int i = 0; i < n; i ++) \n            for(int j = 0; j < n; j ++) \n                l[i][j] = s[i][j] = (i==j)?0:INF;\n        while(m --) {\n            int u, v, w; char o[2];\n            scanf(\"%d%d%d%s\", &u, &v, &w, o); u--, v--;\n            if(o[0] == 'L') l[u][v] = l[v][u] = min(l[u][v], w);\n            else s[u][v] = s[v][u] = min(s[u][v], w);\n        }   scanf(\"%d\", &q);\n        for(int i = 0; i < q; i ++) {\n            scanf(\"%d\" ,a+i);\n            a[i] --;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long int LL;\nconst LL INF = 1LL << 55;\n\nvector<vector<LL>> sea, land;\nvector<int> z;\nint n, m, r;\n\nLL dfs(int cur, int ship) {\n    // cout << cur << \" \" << ship << endl;\n    if (cur == r - 1) return 0;\n    LL ret = land[z[cur]][z[cur + 1]] + dfs(cur + 1, ship);\n    for (int i = 0; i < n; i++) {\n        LL tmp = land[z[cur]][ship] + sea[ship][i] + land[i][z[cur + 1]];\n        if (tmp >= INF) continue;\n        tmp += dfs(cur + 1, i);\n        ret = min(ret, tmp);\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> n >> m, n | m) {\n        sea.clear(); land.clear(); z.clear();\n        sea.resize(n, vector<LL>(n, INF));\n        land.resize(n, vector<LL>(n, INF));\n\n        for (int i = 0; i < n; i++) {\n            sea[i][i] = land[i][i] = 0;\n        }\n\n        for (int i = 0; i < m; i++) {\n            int tx, ty, tt;\n            char tsl;\n            cin >> tx >> ty >> tt >> tsl;\n            tx--; ty--;\n            if (tsl == 'L') {\n                land[tx][ty] = tt;\n                land[ty][tx] = tt;\n            } else {\n                sea[tx][ty] = tt;\n                sea[ty][tx] = tt;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    land[j][k] = min(land[j][k], land[j][i] + land[i][k]);\n                    sea[j][k] = min(sea[j][k], sea[j][i] + sea[i][k]);\n                }\n            }\n        }\n\n        cin >> r;\n        z.resize(r);\n        for (int i = 0; i < r; i++) {\n            int tz;\n            cin >> tz;\n            z[i] = tz - 1;\n        }\n\n        cout << dfs(0, z[0]) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\n\nconst int MAX_V=200;\nll dL[MAX_V][MAX_V];\nll dS[MAX_V][MAX_V];\nint V;\nvoid warshall_floyd(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n  return;\n}\nvoid warshall_floyd2(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdL[i][j]=0;\n      else\n\tdL[i][j]=llINF;\n    }\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdS[i][j]=0;\n      else\n\tdS[i][j]=llINF;\n    }\n    V=n;\n    for(int i=0;i<m;i++){\n      ll x,y,t;\n      char s;\n      cin>>x>>y>>t;\n      cin>>s;\n      x--;y--;\n      if(s=='L'){\n\tdL[x][y]=t;\n\tdL[y][x]=t;\n      }else{\n\tdS[x][y]=t;\n\tdS[y][x]=t;\n      }\n    }\n    warshall_floyd();\n    warshall_floyd2();\n    int r;cin>>r;\n    ll dp[r+10][n+10];\n    for(int i=0;i<r+10;i++)\n      for(int j=0;j<n+10;j++)\n\t  dp[i][j]=llINF;\n    int fffff;cin>>fffff;\n    dp[0][fffff-1]=0;\n    int v[r+10];\n    v[0]=fffff-1;\n    for(int i=1;i<r;i++){\n      cin>>v[i];\n      v[i]--;\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\t//if(dp[i-1][j]!=INF){\n\t  for(int k=0;k<n;k++){\n\t    dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[v[i-1]][j]+dS[j][k]+dL[k][v[i]]);\n\t  }\n\t  //}\n      }\n    }\n    ll ans=llINF;\n    for(int j=0;j<n;j++){\n      // cout<<dp[i][j]<<\" \";\n      ans=min(ans,dp[r-1][j]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<complex>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<set>\n#include<vector>\n#define maxm 10010\n#define maxn 210\n#define mk make_pair\n#define fi first\n#define se second\nusing namespace std;\nstruct data{\n  int nex,to,w,type;\n}e[maxm*2];\nint head[maxn],edge=0,dis[maxn][maxn],dis1[maxn][maxn];\nbool vis[maxn][maxn];\nqueue<pair<int,int> >q;\ninline void add(int from,int to,int w,int type){\n  e[++edge].nex=head[from];\n  e[edge].to=to;\n  e[edge].w=w;\n  e[edge].type=type;\n  head[from]=edge;\n}\nint main(){\n  int n,m,k,x,y,z,now,ans;\n  while(1){\n    memset(head,0,sizeof(head)),edge=0;\n    scanf(\"%d%d\",&n,&m);\n    if(n==0 && m==0) break;\n    char s[3];\n    for(int i=1;i<=m;i++)\n      scanf(\"%d%d%d%s\",&x,&y,&z,s),add(x,y,z,s[0]=='S'),add(y,x,z,s[0]=='S');\n    scanf(\"%d\",&k);\n    memset(dis,127/2,sizeof(dis));\n    dis[1][1]=0,vis[1][1]=1,q.push(mk(1,1));\n    for(int i=1;i<=k;i++){\n      scanf(\"%d\",&now);\n      if(i>1)memcpy(dis,dis1,sizeof(dis));\n      while(!q.empty()){\n\tint u=q.front().fi,p=q.front().se;q.pop();\n\tvis[u][p]=0;\n\tif(u==p){\n\t  for(int i=head[u];i;i=e[i].nex)\n\t    if(e[i].type==1){\n\t      int v=e[i].to;\n\t      if(dis[v][v]>dis[u][p]+e[i].w){\n\t\tdis[v][v]=dis[u][p]+e[i].w;\n\t\tif(!vis[v][v]) vis[v][v]=1,q.push(mk(v,v));\n\t      }\n\t    }\n\t}\n\tfor(int i=head[u];i;i=e[i].nex)\n\t  if(e[i].type==0){\n\t    int v=e[i].to;\n\t    if(dis[v][p]>dis[u][p]+e[i].w){\n\t      dis[v][p]=dis[u][p]+e[i].w;\n\t      if(!vis[v][p]) vis[v][p]=1,q.push(mk(v,p));\n\t    }\n\t  }\n      }\n      memset(dis1,127/2,sizeof(dis1));\n      for(int i=1;i<=n;i++)\n\tif(dis[now][i]<500000000)dis1[now][i]=dis[now][i],q.push(mk(now,i)),vis[now][i]=1;\n    }\n    ans=1000000000;\n    for(int i=1;i<=n;i++)\n      if(dis[now][i]<ans) ans=dis[now][i];\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define inf 100000000\n\nint N,M;\nint disL[200][200];//隣接行列の重みバージョン陸\nint disS[200][200];//海\nint r ;\nint z[1000];\nint disP[1000][200]={};\n\n/*町番号は0からN-1とする（入力は1からN）*/\n\n/*町Z(num)からZr（終点）への最短時間（船が町shipにある状況で）を返す\nz  宅配順列の何番目か0->(r-1)\nship 船のある町番号0->N-1\n*/\nint recur(int num,int ship){\n  int land,sea=inf,i;\n  if(disP[num][ship]!=0)return disP[num][ship];\n  if(num>=r-1)return 0;//ゴール\n  land=disL[z[num]][z[num+1]]+recur(num+1,ship);\n  \n  for(i=0;i<N;i++){\n    sea=min(sea,disL[ z[num] ][ship] + disS[ship][i] + disL[i][ z[num+1] ] + recur(num+1,i));\n  }\n\n  disP[num][ship]=min(land,sea);\n  return disP[num][ship];\n}\n\n\nint main(){\n  int i,j,k,x,y,t;\n  char ch;\n  while(true){\n\n    for(i=0;i<1000;i++)\n      for(j=0;j<200;j++)\n\tdisP[i][j]=0;\n\n    /*入力処理*/\n    cin >>N>>M;\n    if(N==0 && M==0)break;\n    for(i=0;i<200;i++){\n      for(j=0;j<200;j++){\n\tif(i!=j){\n\t  disL[i][j]=inf;\n\t  disS[i][j]=inf;\n\t}\n\telse {\n\t  disL[i][i]=0;\n\t  disS[i][i]=0;\n\t}\n      }\n    }\n    \n\n    /*陸路海路それぞれの最小値をセット*/\n    for(i=0;i<M;i++){\n      cin >>x>>y>>t>>ch;\n      if(ch=='L'){\n\tdisL[x-1][y-1]=min(disL[x-1][y-1],t);\n\tdisL[y-1][x-1]=min(disL[y-1][x-1],t);\n      }\n      else if(ch=='S'){\n\tdisS[x-1][y-1]=min(disS[x-1][y-1],t);\n\tdisS[y-1][x-1]=min(disS[y-1][x-1],t);\n      }\n    }\n\n    /*陸、海それぞれで各町同士の最短経路を出す*/  \n    for(i=0;i<N;i++){\n      for(j=0;j<N;j++){\n\tfor(k=0;k<N;k++){\n\t  disL[j][k]=min(disL[j][k],disL[j][i]+disL[i][k]);\n\t  disS[j][k]=min(disS[j][k],disS[j][i]+disS[i][k]);\n\t}\n      }\n    }\n    cin >> r;\n    for(i=0;i<r;i++){\n      cin >> j;\n      z[i]=j-1;//町番号は0からN-1にする\n    }\n    cout << recur(0,z[0]) <<endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int dist1[200][200], dist2[200][200];\n    REP(i, N)REP(j, N){\n      dist1[i][j] = (i != j) ? INF : 0;\n      dist2[i][j] = (i != j) ? INF : 0;\n    }\n    REP(i, M){\n      int x, y, t;\n      char sl;\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      x--; y--;\n      if(sl == 'L') {\n        dist1[x][y] = dist1[y][x] = min(t, dist1[y][x]);\n      } else{\n        dist2[x][y] = dist2[y][x] = min(t, dist2[y][x]);\n      }\n    }\n    REP(k, N)REP(i, N)REP(j, N){\n      dist1[i][j] = min(dist1[i][j], dist1[i][k] + dist1[k][j]);\n      dist2[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j]);\n    }\n    int R; cin>>R;\n    vector<int> z(R);\n    REP(i, R) {\n      cin>>z[i];\n      z[i]--;\n    }\n    int d[1001][200];\n    REP(i, 1001)fill(d[i], d[i] + N, INF);\n    d[0][z[0]] = 0;\n    REP(i, R - 1)REP(fship, N)REP(toship,N){\n      if(fship != toship) d[i+1][toship] = min(d[i][fship] + dist1[z[i]][fship] + dist2[fship][toship] + dist1[toship][z[i+1]], d[i+1][toship]);\n      else d[i+1][toship] = min(d[i][fship] + dist1[z[i]][z[i+1]], d[i+1][toship]);\n    }\n    int ans = INF;\n    REP(i, N) ans = min(ans, d[R-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(1001,1001,INF);\n        auto Sd = vectors(1001,1001,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1001,1001,INF);\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,r){\n                rep(k,r){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll long long\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,x;\n#define N 210\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nint dpl[N][N];\nint dps[N][N];\nint des[1010];\nint dp[1010][N];\nvoid Init(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(i == j) dpl[i][j] = dps[i][j] = 0;\n\t\t\telse\n\t\t\t\tdpl[i][j] = dps[i][j] = 100000000;\n\t\t}\n\t}\n}\nvoid Floyd(){\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdpl[i][j] = Min(dpl[i][j],dpl[i][k]+dpl[k][j]);\n\t\t\t\tdps[i][j] = Min(dps[i][j],dps[i][k]+dps[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n    while(scanf(\"%d%d\",&n,&m)!=EOF && n+m){\n    \tint u,v,c;\n    \tchar ch[5];\n    \tInit();\n    \tfor(int i=0;i<m;i++){\n    \t\tscanf(\"%d%d%d%s\",&u,&v,&c,ch);\n    \t\tu--,v--;\n    \t\tif(ch[0] == 'L'){\n    \t\t\tdpl[u][v] = dpl[v][u] = Min(dpl[u][v],c);\n    \t\t}else{\n    \t\t\tdps[u][v] = dps[v][u] = Min(dps[u][v],c);\n    \t\t}\n    \t}\n    \tint d;\n    \tsf(d);\n    \tfor(int i=0;i<d;i++){\n    \t\tsf(u);\n    \t\tu--;\n    \t\tdes[i] = u;\n    \t}\n    \tFloyd();\n    \tfor(int i=0;i<n;i++)\n    \t\tfor(int j=0;j<n;j++)\n    \t\t\tdp[i][j] = 100000000;\n\n    \tfor(int i=0;i<n;i++)\n    \t\tdp[0][i] = dps[des[0]][i]+dpl[i][des[0]];\n    \tfor(int i=1;i<d;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tfor(int k=0;k<n;k++){\n    \t\t\t\tif(j != k)\n    \t\t\t\tdp[i][k] = Min(dp[i][k],dp[i-1][j]+dpl[des[i-1]][j]+dps[j][k]+dpl[k][des[i]]);\n    \t\t\t\telse\n    \t\t\t\t\tdp[i][j] = Min(dp[i][j],dp[i-1][j]+dpl[des[i-1]][des[i]]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint ans = INF;\n    \tfor(int i=0;i<n;i++)\n    \t\tans = Min(ans,dp[d-1][i]);\n    \tprintf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int64_t INF=INT64_C(100000000000000);\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n)break;\n    int64_t dl[200][200];\n    int64_t ds[200][200];\n    REP(i,200)REP(j,200){\n      dl[i][j] = INF;\n      ds[i][j] = INF;\n    }\n    REP(i,200)\n      dl[i][i]=ds[i][i]=0;\n    REP(i,m){\n      int64_t x,y,t;\n      string s;\n      cin>>x>>y>>t>>s;\n      --x;--y;\n      if(s==\"L\")\n        dl[x][y]=dl[y][x]=min(dl[x][y],t);\n      else\n        ds[x][y]=ds[y][x]=min(ds[x][y],t);\n    }\n    REP(k,200)REP(i,200)REP(j,200){\n      dl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n      ds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    int64_t r;\n    cin>>r;\n    vector<int64_t> twn(r);\n    REP(i,r){\n      int64_t z;\n      cin>>z;\n      --z;\n      twn[i]=z;\n    }\n    int64_t dp[1001][200];\n    REP(i,1001)REP(j,200)dp[i][j]=INF;\n    dp[0][twn[0]] = 0;\n    REP(i,r-1){\n      REP(j,n)\n        dp[i+1][j]=min(dp[i+1][j],dl[twn[i]][twn[i+1]]+dp[i][j]);\n      REP(j,n)REP(k,n){\n        dp[i+1][k]=min(dp[i+1][k],dl[twn[i]][j]+ds[j][k]+dl[k][twn[i+1]]+dp[i][j]);\n      }\n    }\n    cout<<*min_element(begin(dp[r-1]),end(dp[r-1]))<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint n,m;\nll scost[200][200];\nll lcost[200][200];\nint z[1000];\nbool vis[1000][200];\n\nvoid solve(){\n  rep(i,n)rep(j,n) scost[i][j]=lcost[i][j]=1LL<<30LL;\n  rep(i,n) scost[i][i]=lcost[i][i]=0;\n  rep(i,m){\n    ll x,y,t;\n    char s;\n    cin >> x >> y >> t >> s;\n    --x,--y;\n    if(s=='S') scost[x][y]=scost[y][x]=min(scost[x][y],t);\n    else lcost[x][y]=lcost[y][x]=min(lcost[x][y],t);    \n  }\n  rep(k,n)rep(i,n)rep(j,n){\n    scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n    lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n  }\n\n  int r;\n  cin >> r;\n  rep(i,r){ cin >> z[i];--z[i];}\n  CLR(vis);\n  priority_queue<pair<ll,PI> > q;\n  q.push(mp(0,mp(0,z[0])));\n  while(!q.empty()){\n    ll cc=-q.top().F;\n    int cv=q.top().S.F;\n    int cs=q.top().S.S;\n    q.pop();\n    if(vis[cv][cs]) continue;\n    vis[cv][cs] = true;\n    if(cv==r-1){\n      cout << cc << endl;\n      return;\n    }\n    rep(i,n){\n      ll nc=cc;\n      if(i==cs) nc += lcost[z[cv]][z[cv+1]];\n      else nc += lcost[z[cv]][cs]+scost[cs][i]+lcost[i][z[cv+1]];\n      q.push(mp(-nc,mp(cv+1,i)));\n    }\n  }\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <set>\nusing namespace std;\n\nstruct State {\n  unsigned char p, s;\n  int r, cost;\n  State() {}\n  State(int p, int s, int r, int cost)\n    : p(p), s(s), r(r), cost(cost) {}\n  bool operator < (const State &_s) const {\n    if(cost != _s.cost) return cost > _s.cost;\n    if(r != _s.r) return r < _s.r;\n    if(p != _s.p) return p > _s.p;\n    return s > _s.s;\n  }\n};\n\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nconst int INF = 1<<24;\nint N, M, R;\nint G[MAX_N][MAX_N][2];\nvector<int> Z;\nset<State> vis;\npriority_queue<State> que;\n\nvoid init() {\n  for(int i = 0; i < MAX_N; ++i) {\n    for(int j = 0; j < MAX_N; ++j) {\n      G[i][j][0] = INF;\n      G[i][j][1] = INF;\n    }\n  }\n  Z.clear();\n}\n\nint solve() {\n  vis.clear();\n  State s(Z[0], Z[0], 1, 0);\n  while(!que.empty()) que.pop();\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(s.r == R && s.p == Z[R-1]) return s.cost;\n    if(vis.find(s) != vis.end()) continue;\n    vis.insert(s);\n    for(int j = 0; j <= (s.p == s.s); ++j) {\n      for(int i = 0; i < N; ++i) {\n\tif(G[s.p][i][j] == INF) continue;\n\tState t(i, (j ? i : s.s), s.r+(Z[s.r] == i), s.cost+G[s.p][i][j]);\n\tif(vis.find(t) != vis.end()) continue;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    init();\n    for(int i = 0; i < M; ++i) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      bool isS = (sl == 'S');\n      G[x][y][isS] = t;\n      G[y][x][isS] = t;\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      int z;\n      cin >> z;\n      Z.push_back(z-1);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            /*if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }*/\n            rep(j,n){\n                cmin(dp[i+1][j],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint n, m, r;\nint dl[201][201], ds[201][201], z[1001];\nint dp[1001][201];\n\nint solve(int i, int ship)\n{\n\tif (i == r - 1) return 0;\n\tif (dp[i][ship] > 0) return dp[i][ship];\n\tint res = solve(i + 1, ship) + dl[z[i]][z[i + 1]];\n\tREP(j, n)\n\t{\n\t\tint sum = dl[z[i]][ship] + ds[ship][j] + dl[j][z[i+1]];\n\t\tchmin(res, solve(i + 1, j) + sum);\n\t}\n\treturn dp[i][ship] = res;\n}\n\nint main()\n{\n\twhile (cin >> n >> m, n)\n\t{\n\t\tMS(dp, -1);\n\t\tREP(i, n)REP(j, n)\n\t\t{\n\t\t\tdl[i][j] = (i == j ? 0 : INF);\n\t\t\tds[i][j] = (i == j ? 0 : INF);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tint x, y, t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--; y--;\n\t\t\tif (c == 'L') dl[x][y] = dl[y][x] = t;\n\t\t\telse ds[x][y] = ds[y][x] = t;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n)\n\t\t{\n\t\t\tchmin(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\tchmin(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t}\n\t\tcin >> r;\n\t\tREP(i, r)\n\t\t{\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tcout << solve(0, z[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m,r;\nint dl[222][222];\nint ds[222][222];\nint dp[1111][222];\nint rs[1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,222)rep(j,222){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n      dist[i][j]=INF;\n    }\n    rep(i,m){\n      int x,y,t; string sl;\n      cin>>x>>y>>t>>sl; x--; y--;\n      if(sl==\"L\"){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    cin>>r;\n    rep(i,r){\n      cin>>rs[i];\n      rs[i]--;\n    }\n    dp[0][rs[0]]=0;\n    rep(i,r-1){\n      int crt=rs[i],nxt=rs[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        if(crt==j){\n          rep(k,n)minch(dp[i+1][k],dp[i][j]+dl[crt][j]+ds[j][k]+dl[k][nxt]);\n        }\n        rep(k,n)minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n      }\n    }\n    int res=INF;\n    rep(j,n)minch(res,dp[r-1][j]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n    int d[N];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship;\n\tint job, cost;\n\tP(int now, int ship, int job, int cost) :now(now), ship(ship), job(job), cost(cost) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\n\n\nint flag[300][300][1000];\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tvector<pii> a[300][2];\n\t\tvi b;\n\t\tINT(n); INT(m);\n\t\tif ( !n )break;\n\t\tFOR(i, m)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\ta[x][sl == 'L'].emplace_back(y, t);\n\t\t\ta[y][sl == 'L'].emplace_back(x, t);\n\t\t}\n\t\tINT(r);\n\t\tFOR(i, r)\n\t\t{\n\t\t\tINT(z);\n\t\t\tb.push_back(z);\n\t\t}\n\t\tmemset(flag, -1, sizeof flag);\n\t\tflag[b[0]][b[0]][1] = 0;\n\t\tpriority_queue< P, vector<P>, greater<P> >que;\n\t\tque.emplace(b[0], b[0], 1, 0);\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif ( now.job == b.size() )\n\t\t\t{\n\t\t\t\tcout << now.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( now.now == now.ship )\n\t\t\t{\n\t\t\t\tFOR(i, a[now.now][0].size())\n\t\t\t\t{\n\t\t\t\t\tP next = now;\n\t\t\t\t\tnext.now = next.ship = a[now.now][0][i].first;\n\t\t\t\t\tnext.cost += a[now.now][0][i].second;\n\t\t\t\t\tif ( next.now == b[next.job] )next.job++;\n\t\t\t\t\tint flg = flag[next.now][next.ship][next.job];\n\t\t\t\t\tif ( flg == -1 || flg > next.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t\tflag[next.now][next.ship][next.job] = next.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(i, a[now.now][1].size())\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tnext.now = a[now.now][1][i].first;\n\t\t\t\tnext.cost += a[now.now][1][i].second;\n\t\t\t\tif ( next.now == b[next.job] )next.job++;\n\t\t\t\tint flg = flag[next.now][next.ship][next.job];\n\t\t\t\tif ( flg == -1 || flg > next.cost )\n\t\t\t\t{\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tflag[next.now][next.ship][next.job] = next.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := 集配先\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      if(dp[i][j] == inf)continue;\n\n\t      //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t      dp[i+1][j] = min(dp[i+1][j],\n\t\t\t       dp[i][j]+LG[v[i]][v[i+1]]);\n\t      //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl; \n\t      rep(k,N)\n\t\t{\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t       min(dp[i][j] + LG[v[i]][j] + SG[j][v[i+1]],\n\t\t\t\t\t   dp[i][j] + SG[j][k] + LG[v[i]][j] + LG[k][v[i+1]]));\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t      \n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint result[101][101][10001];\nvector<pair<int, pair<int, bool> > > adjlist[201];\n\nint dijk(vector<int>& z, int n){\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < z.size(); k++){\n        result[i][j][k] = INF;\n      }\n    }\n  }\n\n  \n  //vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<int, pair<int, int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    for(int i = 0; i <= n; i++){\n      adjlist[i].resize(0);\n    }\n    \n    int x, y, t;\n    string sl;\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(z, n + 1);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nconst int MAX_V = 200;\nconst int MAX_R = 1000;\nint gl[MAX_V][MAX_V], gs[MAX_V][MAX_V];\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M, N||M){\n\t\tinit(gl);\n\t\tinit(gs);\n\t\trep(i,N){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tgl[x][y] = gl[y][x] = t;\n\t\t\t}else{\n\t\t\t\tgs[x][y] = gs[y][x] = t;\n\t\t\t}\n\t\t}\n\t\twarshallFloyd(gl,N);\n\t\twarshallFloyd(gs,N);\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> z(R);\n\t\trep(i,R){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tint dp[MAX_R + 1][MAX_V + 1];\n\t\trep(i,MAX_V) rep(j,MAX_V) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\n\t\trep(i,R - 1){\n\t\t\tint cur = z[i];\n\t\t\tint next = z[i + 1];\n\t\t\t//rep(j,N) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][next]);\n\t\t\trep(j,N){\n\t\t\t\trep(k,N){\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\t\t\t//show(dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,R){\n\t\t//\trep(j,N){\n\t\t//\t\tif(dp[i][j] >= INF) cout << \"_\";\n\t\t//\t\telse cout << dp[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint mini = INT_MAX;\n\t\trep(i,N){\n\t\t\tmini = min(mini, dp[R - 1][i]);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define show(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define show(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\ntemplate<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<60;\nconst double eps=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n,int m){\n    ll dl[256][256],ds[256][256];\n    fill_n((ll*)dl,256*256,infll);\n    fill_n((ll*)ds,256*256,infll);\n    rep(i,0,256) dl[i][i]=ds[i][i]=0;\n    rep(i,0,m){\n        int x,y;\n        ll t;\n        char sl;\n        cin >> x >> y >> t >> sl;\n        --x;\n        --y;\n        if(sl=='L'){\n            dl[x][y]=min(dl[x][y],t);\n            dl[y][x]=min(dl[y][x],t);\n        }else{\n            ds[x][y]=min(ds[x][y],t);\n            ds[y][x]=min(ds[y][x],t);\n        }\n    }\n    int r,z[1000];\n    cin >> r;\n    rep(i,0,r){\n        cin >> z[i];\n        --z[i];\n    }\n\n    rep(k,0,n) rep(i,0,n) rep(j,0,n) dl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n    rep(k,0,n) rep(i,0,n) rep(j,0,n) ds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\n    ll dp[1000][256];\n    fill_n((ll*)dp,1000*256,infll);\n    rep(i,0,n) dp[0][i]=ds[z[0]][i]+dl[i][z[0]];\n    rep(i,1,r) rep(j,0,n) rep(k,0,n) dp[i][j]=min(dp[i][j],dp[i-1][k]+dl[z[i-1]][k]+ds[k][j]+dl[j][z[i]]);\n\n    ll ans=infll;\n    rep(i,0,n) ans=min(ans,dp[r-1][i]);\n    cout << ans << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    while(true){\n        int n,m;\n        cin >> n >> m;\n        if(n==0 and m==0) break;\n        solve(n,m);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define ve vector\nconst int INF=0x3f3f3f;\n\nvoid floyd(vector<vector<int>> &a,int n){\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 1; j <= n; j++) {\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\ta[k][j]=a[j][k]=min(a[j][i]+a[i][k],a[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0 && m==0)break;\n\t\tvector<vector<int>> s(n+1,vector<int>(n+1,INF));\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\ts[i][i]=0;\n\t\t}\n\t\tvector<vector<int>> l=s;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='S'){\n\t\t\t\ts[y][x]=s[x][y]=min(s[x][y],t);\n\t\t\t}\n\t\t\telse l[y][x]=l[x][y]=min(l[x][y],t);\n\t\t}\n\t\tfloyd(l,n);\n\t\tfloyd(s,n);\n\t\tint r;\n\t\tcin>>r;\n\t\tvector<int> z;\n\t\tfor (int i = 0; i < r; i++){\n\t\t\tint t;\n\t\t\tcin>>t;\n\t\t\tz.push_back(t);\n\t\t}\n\t\tve<ve<int>> dp(r,ve<int>(n+1,INF));\n\t\tdp[0][z[0]]=0;\n\t\tfor (int i = 1; i <= r-1; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tfor(int i=1;i<=n;i++)ret=min(ret,dp[r-1][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\nusing namespace std;\n#define min(a,b)((a)<(b)?(a):(b))\n#define inf 0x01010101\nstruct State{\n\tint cost,rito,boat;\n\tState(int cost,int rito,int boat):cost(cost),rito(rito),boat(boat){}\n\tbool operator<(const State& r)const{return cost>r.cost;}\n};\nint N;//¬ºÌ\nint Edge[2][201][201];//[¤H0,CH1][¬º][¬º]\nint Cost[201][201];//[¡³ñÌÊu][DÌÊu]:=ÅZÚ®Ô\nvoid Dijkstra(int*C,int start,int dest){\n\tint boat,rito,boatmin,ritomin,c,cmin;\n\tstd::priority_queue<State> que;\n\tmemset(Cost,1,sizeof(Cost));//inf\n\tmemcpy(Cost+start,C,sizeof(int)*201);//startÊuÅÌóÔ\n\tfor(boat=1;boat<=N;boat++){\n\t\tif(C[boat]<inf){\n\t\t\tque.push(State(C[boat],start,boat));\n\t\t}\n\t}\n\tfor(;!que.empty();){\n\t\t//¢èÌóÔÌàAÅZÌàÌðIð\n\t\tritomin=que.top().rito;\n\t\tboatmin=que.top().boat;\n\t\tcmin=que.top().cost;\n\t\tque.pop();\n\t\t//printf(\"determine (%d,%d)=%d\\n\",ritomin,boatmin,cmin);\n\t\t//×ÚóÔðXV\n\t\tfor(rito=1;rito<=N;rito++){\n\t\t\t//¤H\n\t\t\tc=Cost[ritomin][boatmin]+Edge[0][ritomin][rito];\n\t\t\tif(c<Cost[rito][boatmin]){\n\t\t\t\tCost[rito][boatmin]=c;\n\t\t\t\tque.push(State(c,rito,boatmin));\n\t\t\t}\n\t\t\t//»±ÉDª êÎCH\n\t\t\tif(ritomin==boatmin){\n\t\t\t\tc=Cost[ritomin][boatmin]+Edge[1][ritomin][rito];\n\t\t\t\tif(c<Cost[rito][rito]){\n\t\t\t\t\tCost[rito][rito]=c;\n\t\t\t\t\tque.push(State(c,rito,rito));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(C,Cost+dest,sizeof(int)*201);//destÊuÅÌóÔ\n}\nint main(){\n\tint M,R,z;\n\tint C[201];//[DÌÊu]:=ÅZÚ®Ô\n\tfor(;scanf(\"%d%d\",&N,&M)*N;){\n\t\tmemset(Edge,1,sizeof(Edge));//inf\n\t\tfor(;M--;){\n\t\t\tint x,y,t,s;\n\t\t\tchar sl[2];\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,sl);\n\t\t\ts=sl[0]=='L'?0:1;\n\t\t\tEdge[s][x][y]=min(Edge[s][x][y],t);\n\t\t\tEdge[s][y][x]=min(Edge[s][y][x],t);\n\t\t}\n\t\tscanf(\"%d%d\",&R,&z);\n\t\tmemset(C,1,sizeof(C));//inf\n\t\tC[z]=0;\n\t\tfor(;--R;){\n\t\t\tint Z;\n\t\t\tscanf(\"%d\",&Z);\n\t\t\t//printf(\"dijkstra(%d,%d)\\n\",z,Z);\n\t\t\tDijkstra(C,z,Z);\n\t\t\tz=Z;\n\t\t}\n\t\t{\n\t\t\tint c=1<<20;\n\t\t\tfor(z=1;z<=N;z++)\n\t\t\t\tc=min(c,C[z]);\n\t\t\tprintf(\"%d \\n\",c);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<queue>\n\n\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\n\nconst int INF = 1<<28;\n\n\nint main(){\n\n\twhile(1){\t\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0&&m==0) break;\n\t\t\n\t\tvector<vector<int>> L(n+1,vector<int>(n+1,INF));\t\n\t\tvector<vector<int>> S(n+1,vector<int>(n+1,INF));\n\n\t\tint from,to,dist,r;string sl;\t\n\n\t\trep(i,m){\n\t\t\tcin >> from >> to >> dist >> sl;\n\t\t\tif(sl==\"L\"){\n\t\t\t\tL[from][to]=dist;\n\t\t\t\tL[to][from]=dist;\n\t\t\t}else{\n\t\t\t\tS[from][to]=dist;\n\t\t\t\tS[to][from]=dist;\n\t\t\t}\n\t\t}\n\t\n\t\trep(i,n+1){\n\t\t\tL[i][i]=0;\n\t\t\tS[i][i]=0;\n\t\t}\n\n\t\tcin >> r;\n\t\t\n\t\tvector<int> z(r+1);\n\t\trep(i,r) cin >> z[i];\n\n\t\tfor(int k=0;k<n+1;++k){\n\t\t\tfor(int i=0;i<n+1;++i){\n\t\t\t\tfor(int j=0;j<n+1;++j) L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int k=0;k<n+1;++k){\n\t\t\tfor(int i=0;i<n+1;++i){\n\t\t\t\tfor(int j=0;j<n+1;++j) S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint dp[r][n+1]; \n\t\tfill_n((int *)dp,sizeof(dp)/sizeof(int),INF);\n\t\tdp[0][z[0]] = 0;\n\t\tfor (int i = 1; i < r; i++) {\n\t\t\t//????????????\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (dp[i-1][j] != INF) {\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + L[z[i-1]][z[i]];\n\t\t\t\t} \n\t\t\t}\n\n\t\t\t//?????????\n\t\t\tfor(int j = 1; j<= n; j++){\n\t\t\t\tfor(int k = 1;k<= n;k++){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + L[z[i-1]][j] + S[j][k] + L[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t \n\t\tcout << *min_element(dp[r - 1], dp[r - 1]+n+1) << endl;\n\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[50][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int j=0;j<200;j++){\n\t\tfor(int k=0;k<200;k++){\n\t\t\tcost[0][j][k]=INF;\n\t\t}\n\t}\n\tmemset(reset,false,sizeof(reset));\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(0,0))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\treturn nc;\n\t\t}\n\t\tif(now==rt[np]){\n\t\t\tnp++;\n\t\t\tif(reset[np]==false){\n\t\t\t\tfor(int i=0;i<200;i++){\n\t\t\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\t\t\tcost[np%20][i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset[np]=true;\n\t\t\t}\n\t\t\tcost[np%20][now][ns]=nc;\n\t\t}\n\t\tif(cost[np%20][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np%20][e.t][ns]){\n\t\t\t\tcost[np%20][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np%20][e.t][e.t]){\n\t\t\t\t\tcost[np%20][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define mp\tmake_pair\n#define mt \tmake_tuple\n#define pb \tpush_back\nconst int inf=1e9;\n\nint dp[210][210];\nvector<pii> edgel[210],edges[210];\n\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d %d\",&n,&m),n){\n\t\trep(i,n){\n\t\t\tedgel[i].clear();\n\t\t\tedges[i].clear();\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,t;\tchar sl;\tscanf(\"%d %d %d %c\",&x,&y,&t,&sl);\n\t\t\tx--;\ty--;\n\t\t\tif(sl=='L'){\n\t\t\t\tedgel[x].pb(mp(y,t));\n\t\t\t\tedgel[y].pb(mp(x,t));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tedges[x].pb(mp(y,t));\n\t\t\t\tedges[y].pb(mp(x,t));\n\t\t\t}\n\t\t}\n\t\tint r;\tcin>>r;\n\t\tvint z(r);\n\t\trep(i,r){\n\t\t\tscanf(\"%d\",&z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,n)\trep(j,n)\tdp[i][j]=inf;\n\t\tdp[z[0]][z[0]]=0;\n\t\tsrep(i,1,r){\n\t\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\t\trep(j,n){\n\t\t\t\tif(z[i-1]==j){\n\t\t\t\t\trep(k,n)\tif(dp[j][k]!=inf)\tpq.push(mt(-dp[j][k],j,k));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trep(k,n)\tdp[j][k]=inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edgel[pos].size()){\n\t\t\t\t\tint to=edgel[pos][j].first,add=edgel[pos][j].second;\n\t\t\t\t\tif(dp[to][f]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][f]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][f],to,f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n)\tif(dp[j][j]!=inf)\tpq.push(mt(-dp[j][j],j,j));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edges[pos].size()){\n\t\t\t\t\tint to=edges[pos][j].first,add=edges[pos][j].second;\n\t\t\t\t\tif(dp[to][to]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][to]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][to],to,to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n)\trep(k,n)\tif(dp[j][k]!=inf)\tpq.push(mt(-dp[j][k],j,k));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edgel[pos].size()){\n\t\t\t\t\tint to=edgel[pos][j].first,add=edgel[pos][j].second;\n\t\t\t\t\tif(dp[to][f]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][f]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][f],to,f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=inf;\n\t\trep(i,n)\tret=min(ret,dp[z[r-1]][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint G[200][200][2];\nint n,m,r,z[1001];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\nint dijkstra(){\n  vector<vector<int> > D(n+1,vector<int>(r+1,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(D[ship][idx]<cost) continue;\n    \n    int npos=z[idx+1];\n    int ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    \n    for(int i=0;i<n&&ship==pos;i++){\n      ncost=cost+G[pos][i][1]+G[i][npos][0];\n      if(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n    }\n  }\n  return -1;  \n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mem(a) memset(a,2,sizeof(a))\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int mn=205;\n\nint n,m,r;\nint l[mn][mn];\nint s[mn][mn];//sea\nint c[1005];\nll d[1005][mn];\n\nll dp(int k,int t){\n    if (k==r) return 0;\n    ll &ans=d[k][t];\n    if (ans) return ans;\n    ans=1e18;\n    for(int i=1;i<=n;i++){//next boat position\n\t\tif (s[i][t]>3e7) continue;\n        ll u;\n        if (t==i) {\n\t\t\tif (l[c[k]][c[k+1]]>3e7) continue;\n\t\t\tu=l[c[k]][c[k+1]]+dp(k+1,i);\n        }\n        else {\n\t\t\tif (l[c[k]][t]>3e7||l[i][c[k+1]]>3e7) continue;\n\t\t\tu=l[c[k]][t]+l[i][c[k+1]]+s[i][t]+dp(k+1,i);\n        }\n       // printf(\"%d %d %d %lld\\n\",k,t,i,u);\n        ans=min(u,ans);\n    }\n    //printf(\"%d %d %lld\\n\",k,t,ans);\n    return ans;\n\n}\n\nchar S[6];\n\nint main() {\n\twhile(~scanf(\"%d%d\",&n,&m)&&n){\n        mem(l);mem(s);\n        for(int i=1;i<=n;i++) l[i][i]=s[i][i]=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u,v,w;\n\t\t\tscanf(\"%d%d%d%s\",&u,&v,&w,S);\n\t\t\tif (S[0]=='L') l[u][v]=l[v][u]=min(w,l[u][v]);\n\t\t\telse s[u][v]=s[v][u]=min(w,s[u][v]);\n\t\t}\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n                    l[i][j]=min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j]=min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tscanf(\"%d\",&c[i]);\n\t\t}\n\t\tmemset(d,0,sizeof d);\n\t\tprintf(\"%lld\\n\",dp(c[1],c[1]));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 29)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nint Shortest(int start, int goal, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[goal];\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_R; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] < INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Shortest(Z[i - 1], j, \"Land\");\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Shortest(j, k, \"Sea\");\n\n\t\t\t\t\t\tint Land_2 = Shortest(k, Z[i], \"Land\");\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nlong long int dp[10001][200];\n\nint main() {\n\t/*int N; cin >> N;\n\twhile (N--) {\n\t\tstring ast, bst; cin >> ast >> bst;\n\t\treverse(ast.begin(), ast.end());\n\t\tfor (char c : ast) {\n\t\t\tswitch (c) {\n\t\t\tcase 'A': {\n\t\t\t\treverse(bst.begin(), bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'C': {\n\t\t\t\trotate(bst.begin(), bst.begin() + 1, bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'J':{\n\t\t\t\t\t\t  rotate(bst.begin(), bst.end() - 1, bst.end());\n\t\t\t\t\t  }\n\t\t\t\t\t break;\n\t\t\tcase 'E': {\n\t\t\t\tbst = string(bst.begin() + (bst.size() + 1) / 2, bst.end()) + string(bst.begin() + bst.size() / 2, bst.begin()+(bst.size()+1)/2) + string(bst.begin(), bst.begin() + bst.size() / 2);\n\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'M': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '9')return '0';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c + 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'P': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '0')return '9';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c - 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\t\n\t\t\n\t\tcout << bst << endl;\n\t}*/\n\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < 10001; ++i) {\n\t\t\tfor (int j = 0; j < 200; ++j) {\n\t\t\t\tdp[i][j] = 999999999999;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>stimes(N, vector<long long int>(N, 999999999999)),ltimes(N, vector<long long int>(N,999999999999));\n\n\t\t\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; long long int  t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--; y--;\n\t\t\tif (c == 'L') {\n\t\t\t\tltimes[x][y] = min(ltimes[x][y], t);\n\t\t\t\tltimes[y][x] = min(ltimes[y][x], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstimes[x][y] = min(stimes[x][y], t);\n\t\t\t\tstimes[y][x] = min(stimes[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tltimes[i][i] = 0;\n\t\t\tstimes[i][i] = 0;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tltimes[i][j] = min(ltimes[i][j], ltimes[i][k] + ltimes[k][j]);\n\t\t\t\t\tstimes[i][j] = min(stimes[i][j], stimes[i][k] + stimes[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R; cin >> R;\n\t\tvector<int>vs(R);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tcin >> vs[i];\n\t\t\tvs[i]--;\n\t\t}\n\t\tdp[0][vs[0]] = 0;\n\t\tfor (int time = 0; time< R-1; ++time) {\n\t\t\tfor (int f= 0; f < N; ++f) {\n\t\t\t\tfor (int t = 0; t < N; ++t) {\n\t\t\t\t\tdp[time + 1][t] = min(dp[time + 1][t], dp[time][f] + ltimes[vs[time]][f] + stimes[f][t] + ltimes[t][vs[time + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 999999999999;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\n\n\t\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nsigned main(){\n    \n    while(1){\n        int n, m; cin >> n >> m;\n        if(!n) break;\n        vector<vector<int>> gl(n, vector<int> (n, INF));\n        vector<vector<int>> gs(n, vector<int> (n, INF));\n        for(int i = 0; i < m; i++){\n            int x, y, t; char sl; cin >> x >> y >> t >> sl;\n            x--;\n            y--;\n            if(sl == 'L') gl[x][y] = gl[y][x] = t;\n            if(sl == 'S') gs[x][y] = gs[y][x] = t;\n        }\n        \n\n        // 自分の場所へは 0\n        for(int i = 0; i < n; i++){\n            gl[i][i] = 0;\n            gs[i][i] = 0;\n        }\n\n        // ワーシャル 2 発\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    gl[i][j] = min(gl[i][j], gl[i][k] + gl[k][j]);\n                    gs[i][j] = min(gs[i][j], gs[i][k] + gs[k][j]);\n                }\n            }\n        }\n\n\n        int r; cin >> r;\n        vector<int> z(r);\n        for(int i = 0; i < r; i++){\n            cin >> z[i];\n            z[i]--;\n        }\n        vector<vector<int>> dp(r, vector<int> (n, INF));\n        dp[0][z[0]] = 0;\n        for(int i = 0; i < r - 1; i++){\n            for(int j = 0; j < n; j++){\n                if(dp[i][j] == INF) continue;\n\n                // 次に行くのは z[i + 1]\n                int cur = z[i];\n                int nxt = z[i + 1];\n\n                // 陸路で行く\n                if(gl[cur][nxt] != INF) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][nxt]);\n\n                // 徒歩で船があるところまで行って、船で適当な頂点まで行って、そっから徒歩\n                for(int v = 0; v < n; v++){\n                    if(gl[cur][j] != INF && gs[j][v] != INF && gl[v][nxt] != INF) dp[i + 1][v] = min(dp[i + 1][v], dp[i][j] + gl[cur][j] + gs[j][v] + gl[v][nxt]);\n                }\n            }\n        }\n        \n        /*\n        for(int i = 0; i < r; i++){\n            for(int j = 0; j < n; j++){\n                cout << dp[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n\n        int ans = INF;\n        for(int j = 0; j < n; j++) ans = min(ans, dp[r - 1][j]);\n        cout << ans << endl;\n    \n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\n\nconst int MAX_V=210;\nll dL[MAX_V][MAX_V];\nll dS[MAX_V][MAX_V];\nint V;\nvoid warshall_floyd(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n  return;\n}\nvoid warshall_floyd2(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n  return;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdL[i][j]=0;\n      else\n\tdL[i][j]=llINF;\n    }\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdS[i][j]=0;\n      else\n\tdS[i][j]=llINF;\n    }\n    V=n;\n    for(int i=0;i<m;i++){\n      ll x,y,t;\n      char s;\n      cin>>x>>y>>t;\n      cin>>s;\n      x--;y--;\n      if(s=='L'){\n\tdL[x][y]=t;\n\tdL[y][x]=t;\n      }else{\n\tdS[x][y]=t;\n\tdS[y][x]=t;\n      }\n    }\n    warshall_floyd();\n    warshall_floyd2();\n    int r;cin>>r;\n    ll dp[r+10][n+10];\n    for(int i=0;i<r+10;i++)\n      for(int j=0;j<n+10;j++)\n\t  dp[i][j]=llINF;\n    int fffff;cin>>fffff;\n    dp[0][fffff-1]=0;\n    int v[r+10];\n    v[0]=fffff-1;\n    for(int i=1;i<r;i++){\n      cin>>v[i];\n      v[i]--;\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\tif(dp[i-1][j]!=INF){\n\t  for(int k=0;k<n;k++){\n\t    dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[v[i-1]][v[i]]);\n\t    dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[v[i-1]][j]+dS[j][k]+dL[k][v[i]]);\n\t  }\n\t}\n      }\n    }\n    ll ans=llINF;\n    for(int j=0;j<n;j++){\n      // cout<<dp[i][j]<<\" \";\n      ans=min(ans,dp[r-1][j]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<VVI> VVVI;\nconst int INF = 1 << 22;\nint N, M, R;\nvoid wf(VVI &adj){\n  for(int k = 0; k < N; ++k){\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n      }\n    }\n  }\n}\nvoid print_adj(VVI adj){\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < N; ++j){\n      if(adj[i][j] >= INF){\n\tcout << \"INF\" << \" \";\n      }\n      else{\n\tcout << adj[i][j] << \" \";\n      }\n    }\n    cout << endl;\n  }\n}\nvoid db_print(int line[]){\n  for(int i = 0; i < N; ++i){\n    if(line[i] >= INF){\n      cout << \"INF\" << \" \";\n    }\n    else{\n      cout << line[i] << \" \";\n    }\n  }\n  cout << endl;\n}\nint solve(VVI sea, VVI land, VI que){  \n  int table[R][N];  \n  fill_n((int *) table, R*N, INF);\n  table[0][que[0]] = 0;\n  for(int r = 1; r < R; ++r){\n    //db_print(table[r-1]);\n    for(int from = 0; from < N; ++from){\n      for(int to = 0; to < N; ++to){\n\tif(from == to){\n\t  int cost = table[r-1][from];\n\t  cost += land[que[r-1]][que[r]];\n\t  table[r][to] = min(table[r][to], cost);\n\t}\n\telse{\n\t  int cost = table[r-1][from];\n\t  cost += land[que[r-1]][from];\n\t  cost += sea[from][to];\n\t  cost += land[to][que[r]];\n\t  table[r][to] = min(table[r][to], cost);\n\t}\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      if(table[r][i] > INF){\n\ttable[r][i] = INF;\n      }\n    }\n  }\n  int res = INF;\n  //db_print(table[R-1]);\n  for(int i = 0; i < N; ++i){\n    res = min(res, table[R-1][i]);\n  }\n  return res;\n}\nint main(){\n  while(true){\n    cin >> N >> M;\n    if((N|M) == 0){\n      break;\n    }\n    VVI sea(N, vector<int>(N, INF));\n    VVI land(N, vector<int>(N, INF));\n    for(int i = 0; i < N; ++i){\n      sea[i][i] = 0;\n      land[i][i] = 0;\n    }\n    for(int i = 0; i < M; ++i){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      if(sl == 'S'){\n\tsea[x][y] = sea[y][x] = min(sea[y][x], t);\n      }\n      else{\n\tland[x][y] = land[y][x] = min(land[y][x], t);\n      }\n    }\n    wf(sea); wf(land);    \n    //print_adj(sea);\n    //print_adj(land);\n    cin >> R;\n    vector<int> que(R);\n    for(int i = 0; i < R; ++i){\n      cin >> que[i];\n      --que[i];\n    }    \n    cout << solve(sea, land, que) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int INF = 1000000000;\nstatic int land_mat[200][200];\nstatic int sea_mat[200][200];\n\nint main(){\n\tios_base::sync_with_stdio(false);;\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){ break; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tland_mat[i][j] = sea_mat[i][j] = INF;\n\t\t\t}\n\t\t\tland_mat[i][i] = sea_mat[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint a, b, c;\n\t\t\tstring t;\n\t\t\tcin >> a >> b >> c >> t;\n\t\t\t--a; --b;\n\t\t\tif(t[0] == 'S'){\n\t\t\t\tsea_mat[a][b] = min(sea_mat[a][b], c);\n\t\t\t\tsea_mat[b][a] = min(sea_mat[b][a], c);\n\t\t\t}else{\n\t\t\t\tland_mat[a][b] = min(land_mat[a][b], c);\n\t\t\t\tland_mat[b][a] = min(land_mat[b][a], c);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tland_mat[i][j] = min(\n\t\t\t\t\t\tland_mat[i][j], land_mat[i][k] + land_mat[k][j]);\n\t\t\t\t\tsea_mat[i][j] = min(\n\t\t\t\t\t\tsea_mat[i][j], sea_mat[i][k] + sea_mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\tint answer = 0;\n\t\tvector<int> cur(n, INF);\n\t\tcur[z[0]] = 0;\n\t\tfor(int i = 1; i < r; ++i){\n\t\t\tconst int u = z[i - 1], v = z[i];\n\t\t\tvector<int> from_dist(n, INF);\n\t\t\tvector<int> to_dist(n, INF);\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tfrom_dist[j] = land_mat[u][j];\n\t\t\t\tto_dist[j]   = land_mat[j][v];\n\t\t\t}\n\t\t\tvector<int> next(n, INF);\n\t\t\tif(land_mat[u][v] < INF){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif(cur[j] >= INF){ continue; }\n\t\t\t\t\tnext[j] = cur[j] + land_mat[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(cur[j] >= INF){ continue; }\n\t\t\t\tif(from_dist[j] >= INF){ continue; }\n\t\t\t\tfor(int k = 0; k < n; ++k){\n\t\t\t\t\tif(to_dist[k] >= INF){ continue; }\n\t\t\t\t\tconst int sea_dist = sea_mat[j][k];\n\t\t\t\t\tif(sea_dist >= INF){ continue; }\n\t\t\t\t\tnext[k] = min(\n\t\t\t\t\t\tnext[k], cur[j] + from_dist[j] + sea_dist + to_dist[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.swap(next);\n\t\t}\n\t\tcout << *min_element(cur.begin(), cur.end()) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\nconst ll INF = 1LL << 50;\n\nint main(){\n    int n, m, x, y, r;\n    ll t;\n    char sl;\n    while(scanf(\"%d%d\", &n, &m) &&  n!=0){\n        vector< vector<ll> > st(n, vector<ll>(n, INF)), lt(n, vector<ll>(n, INF));\n        rep(n){\n            st[i][i] = 0LL;\n            lt[i][i] = 0LL;\n        }\n        rep(m){\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'S'){\n                st[x][y] = min(st[x][y], t);\n                st[y][x] = min(st[y][x], t);\n            }else{\n                lt[x][y] = min(lt[x][y], t);\n                lt[y][x] = min(lt[y][x], t);\n            }\n        }\n\n        repp(k, n){\n            repp(i, n){\n                repp(j, n){\n                        st[i][j] = min(st[i][j], st[i][k] + st[k][j]);\n                        lt[i][j] = min(lt[i][j], lt[i][k] + lt[k][j]);\n                }\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(r){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // dp[i][j]: z[i]にいる，お船はjにあるときの最短時間\n        ll dp[r][n];\n        fill(dp[0], dp[r], INF);\n        dp[0][0] = 0LL;\n        rep(r-1){\n            // z[i]からkまで徒歩，kからlまで船，lからz[i+1]まで徒歩\n            repp(k, n){\n                if(lt[z[i]][k] >= INF) continue;\n                repp(l, n){\n                    dp[i+1][l] = min(dp[i+1][l], dp[i][k]+lt[z[i]][k]+st[k][l]+lt[l][z[i+1]]);\n                }\n            }\n            // repp(j, n) printf(\"%5lld\", dp[z[i+1]][j] == INF ? -1 : dp[z[i+1]][j]);\n            // printf(\"\\n\");\n        }\n\n        ll ans = INF;\n        rep(n) ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct Edge{\n  int dst;\n  int time;\n  char type;\n  Edge(int _d,int _ti,char _ty) : dst(_d),time(_ti),type(_ty){}\n  Edge(){}\n};\n\nclass State{\npublic:\n  int next_target_idx;\n  int current_pos;\n  int cost;\n  int ship_pos;\n  State(int _nt,int _cp,int _c,int _s) : next_target_idx(_nt), current_pos(_cp),cost(_c),ship_pos(_s) {}\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint dp[201][201][201]; //current_pos,target_pos,ship_pos\n\nint main(){\n  int total_cities;\n  int total_roads;\n\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n\n    vector<Edge> edges[201];\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int src,dst,time;\n      char type[2];\n      scanf(\"%d %d %d %s\",&src,&dst,&time,type);\n      edges[src].push_back(Edge(dst,time,type[0]));\n      edges[dst].push_back(Edge(src,time,type[0]));\n    }\n\n    int total_routes;\n    int routes[1001];\n    scanf(\"%d\",&total_routes);\n    for(int route_idx = 0; route_idx < total_routes; route_idx++){\n      int route;\n      scanf(\"%d\",&route);\n      routes[route_idx] = route;\n    }\n\n    priority_queue<State,vector<State>,greater<State> > que;\n\n    // next_target_idx,current_pos,cost,ship_pos\n    que.push(State(0,routes[0],0,routes[0]));\n\n    memset(dp,0x3f,sizeof(dp));\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(dp[s.current_pos][routes[s.next_target_idx]][s.ship_pos] <= s.cost) continue;\n      dp[s.current_pos][routes[s.next_target_idx]][s.ship_pos] = s.cost;\n\n      if(s.next_target_idx == total_routes - 1\n\t && routes[s.next_target_idx] == s.current_pos){\n\tres = s.cost;\n\tgoto found;\n      }\n\n      for(int dst_idx = 0; dst_idx < edges[s.current_pos].size(); dst_idx++){\n\tint dst = edges[s.current_pos][dst_idx].dst;\n\tint time = edges[s.current_pos][dst_idx].time;\n\tchar type = edges[s.current_pos][dst_idx].type;\n\n\tif(type == 'S' && s.ship_pos != s.current_pos) continue;\n\n\tint next_target_idx = s.next_target_idx;\n\tif(s.current_pos == routes[s.next_target_idx]){\n\t  next_target_idx++;\n\t}\n\tint next_ship_pos = s.ship_pos;\n\tif(type == 'S' && s.current_pos == s.ship_pos){\n\t  next_ship_pos = dst;\n\t}\n\t// next_target_idx,current_pos,cost,ship_pos\n\tState next(next_target_idx,dst,s.cost + time,next_ship_pos);\n\tque.push(next);\n      }\n    }\n  found:;\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N, M, R;\nint land[202][202], sea[202][202];\nint z[1001];\n\nint dp[1001][202];\n\nint solve(int idx, int ship) {\n  if(idx == R-1) return 0;\n  int& res = dp[idx][ship];\n  if(~res) return res;\n  res = inf;\n  chmin(res, solve(idx+1, ship)+land[z[idx]][z[idx+1]]);\n  rep(i, N) {\n    chmin(res, solve(idx+1, i)+land[z[idx]][ship]+sea[ship][i]+land[i][z[idx+1]]);\n  }\n  return res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M, N) {\n    rep(i, 202) rep(j, 202) land[i][j] = (i == j ? 0 : inf);\n    rep(i, 202) rep(j, 202) sea[i][j] = (i == j ? 0 : inf);\n    rep(i, M) {\n      int x, y, t;\n      char c;\n      cin >> x >> y >> t >> c;\n      x--, y--;\n      if(c == 'S') sea[x][y] = sea[y][x] = min(sea[x][y], t);\n      if(c == 'L') land[x][y] = land[y][x] = min(land[x][y], t);\n    }\n    cin >> R;\n    rep(i, R) cin >> z[i], z[i]--;\n    rep(i, N) rep(j, N) rep(k, N) {\n      chmin(sea[j][k], sea[j][i]+sea[i][k]);\n      chmin(land[j][k], land[j][i]+land[i][k]);\n    }\n    memset(dp, -1, sizeof(dp));\n    cout << solve(0, z[0]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 1e4 + 16;\nconst int MAXR = 1e3 + 16;\n\nint N, M, R;\nunsigned dl[MAXN][MAXN], ds[MAXN][MAXN];\nint path[MAXR];\nunsigned dp[2][MAXN];\n\nint x, y, t;\nchar sl;\n\nvoid floyd() {\n    for (int k = 1; k <= N; k++) {\n        for (int u = 1; u <= N; u++) {\n            for (int v = 1; v <= N; v++) {\n                if (dl[u][v] > dl[u][k] + dl[k][v]) dl[u][v] = dl[u][k] + dl[k][v];\n                if (ds[u][v] > ds[u][k] + ds[k][v]) ds[u][v] = ds[u][k] + ds[k][v];\n            }\n        }\n    }\n}\n\nint main() {\n    //freopen(\"2200.txt\", \"r\", stdin);\n    while (cin >> N >> M, N | M) {\n        memset(dl, 0x3f, sizeof(dl));\n        memset(ds, 0x3f, sizeof(ds));\n        for (int i = 1; i <= N; i++) {\n            dl[i][i] = ds[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            cin >> x >> y >> t >> sl;\n            if (sl == 'L') {\n                dl[x][y] = dl[y][x] = t;\n            } else {\n                ds[x][y] = ds[y][x] = t;\n            }\n        }\n        floyd();\n        /*for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                //cout << i << \" \" << j << \" \" << dl[i][j] << \" \" << ds[i][j] << \"\\n\";\n            }\n        }*/\n        cin >> R;\n        for (int i = 1; i <= R; ++i) {\n            cin >> path[i];\n        }\n        memset(dp[0], 0x3f, sizeof(dp[0]));\n        dp[0][1] = 0;\n        int prev = 1;\n        for (int i = 1; i <= R; ++i) {\n            memset(dp[i & 1], 0x3f, sizeof(dp[i & 1]));\n            int to = path[i];\n            for (int j = 1; j <= N; ++j) {\n                for (int k = 1; k <= N; k++) {\n                    dp[i & 1][k] = min(dp[!(i & 1)][j] + dl[prev][j] + ds[j][k] + dl[k][to], \n                        dp[i & 1][k]);\n                }\n            }\n            prev = to;\n        }\n        cout << *min_element(dp[R & 1] + 1, dp[R & 1] + N + 1) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e9\n\ntypedef long long ll;\n\nstruct Edge {\n\tint to, cost;\n};\n\nll dp[1001][200];\n\nll min(ll a, ll b) { return a > b ? b : a; }\n\nint main() {\n\tint N, M;\n\twhile ( cin >> N >> M, N || M ) {\n\t\tll m[200][200];\n\t\tll s[200][200];\n\n\t\tfill(&m[0][0], &m[0][0]+200*200, INF);\n\t\tfill(&s[0][0], &s[0][0]+200*200, INF);\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\ts[i][i] = m[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y, t; char sl; cin >> x >> y >> t >> sl; --x, --y;\n\t\t\tif (sl == 'S') {\n\t\t\t\ts[x][y] = s[y][x] = min(s[y][x], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tm[x][y] = m[y][x] = min(m[y][x], t);\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill(&dp[0][0], &dp[0][0]+1001*200, INF);\n\t\tint R; cin >> R;\n\t\tvector<int> v(R);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tcin >> v[i]; --v[i];\n\t\t}\n\t\tdp[0][v[0]] = 0;\n\t\tfor (int t = 1; t < R; ++t) {\n\t\t\tfor (int b = 0; b < N; ++b) {\n\t\t\t\tfor (int nb = 0; nb < N; ++nb) {\n\t\t\t\t\tll cost = b == nb ? m[v[t-1]][v[t]] : m[v[t-1]][b]+s[b][nb]+m[nb][v[t]];\n\t\t\t\t\tdp[t][nb] = min(min(dp[t][nb], dp[t-1][b]+cost), INF);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\n#define ma 23456789\nint sea[200][200];\nint load[200][200];\nint dp[1000][200];\nint to[1000] = {0};\n\nsigned main(void){\n  int i, j, k;\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int2(n, m);\n    if(!(n | m))break;\n    rep(i, n)rep(j, n){\n      sea[i][j] = ma;\n      if(i == j)sea[i][j] = 0;\n    }\n    rep(i, n)rep(j, n){\n      load[i][j] = ma;\n      if(i == j)load[i][j] = 0;\n    }\n    rep(i, m){\n      int x, y, t;\n      char sl;\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      --x; --y;\n      if(sl == 'S'){\n        sea[x][y] = min(sea[x][y], t);\n        sea[y][x] = min(sea[y][x], t);\n      }else{\n        load[x][y] = min(load[x][y], t);\n        load[y][x] = min(load[y][x], t);\n      }\n    }\n\n    rep(k, n)rep(i, n)rep(j, n){\n      sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n      load[i][j] = min(load[i][j], load[i][k] + load[k][j]);\n    }\n\n    int(r);\n    rep(i, r)rep(j, n)dp[i][j] = ma;\n\n    scanf(\"%d\", &to[0]); --to[0];\n    dp[0][to[0]] = 0;\n    rep(j, n)dp[0][j] = min(dp[0][j], sea[to[0]][j] + load[j][to[0]]);\n\n    rep1(i, r){\n      scanf(\"%d\", &to[i]); --to[i];\n      rep(j, n){\n        dp[i][j] = min(dp[i][j], dp[i - 1][j] + load[to[i - 1]][to[i]]);\n        rep(k, n)dp[i][j] = min(dp[i][j], dp[i - 1][k] + load[to[i - 1]][k] + sea[k][j] + load[j][to[i]]);\n      }\n    }\n\n    int res = ma;\n    rep(j, n)res = min(res, dp[r - 1][j]);\n    pri(res);\n\n    /*if(testcase == 1){\n      rep(i, n)rep(j, n)pri3(i, j, load[i][j]);\n      rep(i, n)rep(j, n)debug3(i, j, sea[i][j]);\n      rep(i, r)rep(j, n)pri3(i, j, dp[i][j]);\n    }*/\n\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n  \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n  \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n  \nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n  \nint main(){\n    while(1){\n        int n,m;\n        static LL ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static LL sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)return 0;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static LL dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tLL ret=INF;\n    \trep1(i,n){\n    \t\tret=min(ret,dp[r-1][i]);\n    \t}\n          \n        printf(\"%I64d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <vector>\n\nusing namespace std;\n\nstatic int N, M, R;\n\n\n\nstatic int dist_l[201][201];\nstatic int dist_s[201][201];\n\nstatic int dest[1001];\n\n\n\nstatic void flood()\n{\n\tint i, j, k;\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (i==k || dist_l[i][k]==INT_MAX)\n\t\t\t\tcontinue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_l[k][j]==INT_MAX)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (dist_l[i][j] > dist_l[i][k]+dist_l[k][j]) {\n\t\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_l[i][k]+dist_l[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tfor (k=1; k<=N; k++) {\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tif (k==i || dist_s[i][k]==INT_MAX) continue;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tif (j==k || dist_s[k][j]==INT_MAX) continue;\n\t\t\t\tif (dist_s[i][j] > dist_s[i][k] + dist_s[k][j]) {\n\t\t\t\t\tdist_s[i][j] = dist_s[j][i] = dist_s[i][k] + dist_s[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n}\n\n\nstatic int dp[1001][201];\n\nstatic void solve()\n{\n\tflood();\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tint z0 = dest[1];\n\t\n\tfor (j=1; j<=N; j++) {\n\t\tif (dist_l[j][z0]!=INT_MAX && dist_s[z0][j]!=INT_MAX) {\n\t\t\tif (dp[1][j] > dist_l[j][z0] + dist_s[z0][j])\n\t\t\t\tdp[1][j] = dist_l[j][z0] + dist_s[z0][j];\n\t\t}\n\t}\n\n\tfor (i=2; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k!=j) {\n\t\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (dist_l[start][end]!=INT_MAX && dp[i][k] > dp[i-1][k]+dist_l[start][end])\n\t\t\t\t\t\t\tdp[i][k] = dp[i-1][k]+dist_l[start][end];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nstatic void solve1()\n{\n\tflood();\n\n\n\n\tint i, j;\n\n\tfor (i=0; i<=R; i++) {\n\t\tfor (j=1; j<=N; j++)\n\t\t\tdp[i][j] = INT_MAX;\n\t}\n\tdp[0][1] = 0;\n\n\tfor (i=1; i<=R; i++) {\n\n\t\tint start, end;\n\t\tint total_land_cost;\n\n\t\tstart = dest[i-1]; end = dest[i];\n\n\t\ttotal_land_cost = dist_l[start][end];\n\n\t\tfor (j=1; j<=N; j++) {\n\t\t\tif (dp[i-1][j]!=INT_MAX) {\n\t\t\t\tif (total_land_cost!=INT_MAX) {\n\t\t\t\t\tif (dp[i][j] > dp[i-1][j]+total_land_cost)\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+total_land_cost;\n\t\t\t\t}\n\t\t\t\tint k;\n\n\t\t\t\tfor (k=1; k<=N; k++) {\n\t\t\t\t\tif (k==j) continue;\n\t\t\t\t\tint c1, c2, c3;\n\t\t\t\t\tc1 = dist_l[start][j];\n\t\t\t\t\tc2 = dist_s[j][k];\n\t\t\t\t\tc3 = dist_l[k][end];\n\t\t\t\t\t//printf(\"c1=%d c2=%d c3=%d\\n\", c1, c2, c3);\n\t\t\t\t\tif (c1==INT_MAX || c2==INT_MAX || c3==INT_MAX) continue;\n\t\t\t\t\tif (dp[i][k] > c1+c2+c3+dp[i-1][j]) {\n\t\t\t\t\t\tdp[i][k] = c1+c2+c3+dp[i-1][j];\n\t\t\t\t\t\t//printf(\"s_end[%d] = %d\\n\", k, s_end[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tint min = INT_MAX;\n\tfor (i=1; i<=N; i++) {\n\t\tif (min > dp[R][i])\n\t\t\tmin = dp[R][i];\n\t}\n\n\tprintf(\"%d\\n\", min);\n\n}\n\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n\twhile (scanf(\"%d%d\", &N, &M)==2) {\n\t\tif (N==0 && M==0) break;\n\t\tint i, j;\n\n\t\tfor (i=1; i<=N; i++) {\n\t\t\tdist_l[i][i] = dist_s[i][i] = 0;\n\t\t\tfor (j=i+1; j<=N; j++) {\n\t\t\t\tdist_l[i][j] = dist_l[j][i] = dist_s[i][j] = dist_s[j][i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tfor (i=0; i<M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &t);\n\t\t\tdo { c=getchar();\n\t\t\t} while (c!='S' && c!='L');\n\n\t\t\tif (c=='S') {\n\t\t\t\tif (dist_s[x][y] > t)\n\t\t\t\t\tdist_s[x][y] = dist_s[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dist_l[x][y] > t)\n\t\t\t\t\tdist_l[x][y] = dist_l[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &R);\n\t\tdest[0] = 1;\n\t\tfor (i=1; i<=R; i++) {\n\t\t\tscanf(\"%d\", &dest[i]);\n\t\t}\n\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,i,j,k,r,a[256],ans,map[256][256][2],dp[256][256];\nint main()\n{\n\twhile(~scanf(\"%d %d\",&n,&m)&&n&&m)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tmap[i][j][0]=2147483647;\n\t\t\t\tmap[i][j][1]=2147483647;\n\t\t\t}\n\t\t\tmap[i][i][0]=0;\n\t\t\tmap[i][i][1]=0;\n\t\t}\n\t\tint x,y,t,o;\n\t\tchar s;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%d %d %d %c\",&x,&y,&t,&s);\n\t\t\tif(s=='L')\n\t\t\t\to=0;\n\t\t\tif(s=='S')\n\t\t\t\to=1;\n\t\t\tmap[x][y][o]=min(map[x][y][o],t);\n\t\t\tmap[y][x][o]=map[x][y][o];\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\ta[0]=1;\n\t\tfor(k=1;k<=n;k++)\n\t\t{\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][k][0]<2147483647&&map[k][j][0]<2147483647)\n\t\t\t\t\t\tmap[i][j][0]=min(map[i][j][0],map[i][k][0]+map[k][j][0]);\n\t\t\t\t\tif(map[i][k][1]<2147483647&&map[k][j][1]<2147483647)\n\t\t\t\t\t\tmap[i][j][1]=min(map[i][j][1],map[i][k][1]+map[k][j][1]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=r;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tdp[i][j]=2147483647;\n\t\t}\n\t\tfor(i=1;i<=n;i++)\n\t\t\tdp[0][i]=map[a[0]][i][1]+map[i][a[0]][0];\n\t\tfor(i=1;i<=r;i++)\n\t\t{\n\t\t\tfor(k=1;k<=n;k++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][k]<2147483647&&map[a[i-1]][k][0]<2147483647)\n\t\t\t\t{\n\t\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(map[k][j][1]<2147483647&&map[j][a[i]][0]<2147483647)\n\t\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+map[a[i-1]][k][0]+map[k][j][1]+map[j][a[i]][0]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=2147483647;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=min(ans,dp[r][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint d1[205][205], d2[205][205];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(true) {\n    int n, m;\n    cin >> n >> m;\n    if(!n) break;\n    REP(i, n) REP(j, n) {\n      d1[i][j] = i==j?0:INF;\n      d2[i][j] = i==j?0:INF;\n    }\n    REP(i, m) {\n      int x, y, c;\n      char t;\n      cin >> x >> y >> c >> t;\n      x--, y--;\n      if(t == 'L') {\n        chmin(d1[x][y], c);\n        chmin(d1[y][x], c);\n      } else {\n        chmin(d2[x][y], c);\n        chmin(d2[y][x], c);\n      }\n    }\n\n    REP(k, n) REP(i, n) REP(j, n) {\n      chmin(d1[i][j], d1[i][k] + d1[k][j]);\n      chmin(d2[i][j], d2[i][k] + d2[k][j]);\n    }\n\n    int r;\n    cin >> r;\n    VI cur(n, INF), nxt(n, INF);\n    int now;\n    cin >> now; now--;\n    REP(i, n) cur[i] = i==now?0:INF;\n    REP(i, r-1) {\n      int g;\n      cin >> g; g--;\n\n      REP(j, n) {\n        // (now, j) からスタートする\n        REP(k, n) {\n          // (g, k) を目的とする\n          // 陸でnow->j 船でj->k 陸でk->g\n          chmin(nxt[k], cur[j] + d1[now][j] + d2[j][k] + d1[k][g]);\n        }\n      }\n\n      cur = nxt;\n      nxt.assign(n, INF);\n      now = g;\n    }\n\n    int ret = INF;\n    REP(i, n) chmin(ret, cur[i]);\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, disl[210][210], diss[210][210], h, V[1010];\nlong long dp[1010][210], ans;\n\nvoid init() {\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = 1; j <= n; ++j)\n\t\t\tdisl[i][j] = diss[i][j] = ((i == j) ? 0 : 0x3f3f3f3f);\n\t\n\tmemset(dp, 0x3f3f3f3f, sizeof dp);\n\tans = 0x3f3f3f3f;\n}\n\nint main() {\n\tint u, v, w; char ch;\n\twhile(scanf(\"%d%d\", &n, &m) && (n || m)) {\n\t\tinit();\n\t\tfor(int i = 1; i <= m; ++i) {\n\t\t\tscanf(\"%d%d%d %c\", &u, &v, &w, &ch);\n\t\t\tif(ch == 'L') disl[u][v] = disl[v][u] = min(disl[u][v], w);\n\t\t\telse diss[u][v] = diss[v][u] = min(diss[u][v], w);\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; ++k)\n\t\t\tfor(int i = 1; i <= n; ++i)\n\t\t\t\tfor(int j = 1; j <= n; ++j) {\n\t\t\t\t\tdisl[i][j] = min(disl[i][j], disl[i][k] + disl[k][j]);\n\t\t\t\t\tdiss[i][j] = min(diss[i][j], diss[i][k] + diss[k][j]);\n\t\t\t\t}\n\t\t\n\t\tscanf(\"%d\", &h);\n\t\tfor(int i = 1; i <= h; ++i) scanf(\"%d\", &V[i]);\n\t\tdp[0][1] = 0;\n\t\tfor(int i = 1; i <= h; ++i) {\n\t\t\tfor(int j = 1; j <= n; ++j)\n\t\t\t\tfor(int k = 1; k <= n; ++k)\n\t\t\t\t\tif(j != k) dp[i][k] = min(dp[i][k], dp[i - 1][j] + disl[V[i - 1]][j] + diss[j][k] + disl[k][V[i]]);\n\t\t\t\t\telse dp[i][k] = min(dp[i][k], dp[i - 1][k] + disl[V[i - 1]][V[i]]);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; ++i)\n\t\t\tif(dp[h][i] < ans) ans = dp[h][i];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\nconst int inf=(int)1e9;\nconst double PI=acos(-1.0);\n  \n  \n  \nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n        int ldp[201][201];\n        int sdp[201][201];\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                ldp[i][j]=inf;\n                sdp[i][j]=inf;\n            }\n        }\n        for(int i=0;i<n;i++){\n            ldp[i][i]=0;\n            sdp[i][i]=0;\n        }\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L'){\n                ldp[a][b]=c;\n                ldp[b][a]=c;\n            }else{\n                sdp[a][b]=c;\n                sdp[b][a]=c;\n            }\n        }\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    ldp[i][j]=min(ldp[i][k]+ldp[k][j],ldp[i][j]);\n                    sdp[i][j]=min(sdp[i][k]+sdp[k][j],sdp[i][j]);\n                }\n            }\n        }\n        int r;cin>>r;\n        int a[1001];\n        for(int i=0;i<r;i++){\n            cin>>a[i];\n            a[i]--;\n        }\n        int dp[1001][201];\n        for(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n        dp[0][a[0]]=0;\n        for(int i=0;i<r-1;i++){\n            for(int j=0;j<n;j++){\n                if(dp[i][j]==inf)continue;\n                for(int k=0;k<n;k++){\n                    dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][j]+sdp[j][k]+ldp[k][a[i+1]]);\n                }\n            }\n        }\n        /*for(int i=0;i<r;i++){\n            for(int j=0;j<n;j++){\n                cerr<<dp[i][j]<<\" \";\n            }\n            cerr<<\"\\n\";\n        }*/\n        int ans=inf;\n        for(int i=0;i<n;i++){\n            ans=min(ans,dp[r-1][i]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\nconst int INF=1001001001001001001ll;\n\nint L[333][333],S[333][333];\n\nsigned main(){\n\tint N,M;\n\twhile(cin>>N>>M,N){\n\t\tfill_n(*L,333*333,INF);\n\t\tfill_n(*S,333*333,INF);\n\t\trep(i,M){\n\t\t\tint a,b,d;\n\t\t\tchar c;\n\t\t\tcin>>a>>b>>d>>c;\n\t\t\ta--;b--;\n\t\t\tif(c=='L'){\n\t\t\t\tchmin(L[a][b],d);\n\t\t\t\tchmin(L[b][a],d);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchmin(S[a][b],d);\n\t\t\t\tchmin(S[b][a],d);\n\t\t\t}\n\t\t}\n\n\t\trep(i,N)L[i][i]=S[i][i]=0;\n\t\trep(k,N)rep(i,N)rep(j,N){\n\t\t\tchmin(L[i][j],L[i][k]+L[k][j]);\n\t\t\tchmin(S[i][j],S[i][k]+S[k][j]);\n\t\t}\n\n\t\tint R;cin>>R;\n\t\tvint z(R);\n\t\trep(i,R)cin>>z[i],z[i]--;\n\n\t\tvint dp(N,INF);\n\t\tdp[z[0]]=0;\n\t\tfor(int i=1;i<R;i++){\n\t\t\tvint nex(N,INF);\n\t\t\trep(j,N)rep(k,N){\n\t\t\t\tchmin(nex[k],dp[j]+L[z[i-1]][j]+S[j][k]+L[k][z[i]]);\n\t\t\t}\n\t\t\trep(j,N)chmin(nex[j],dp[j]+L[z[i-1]][z[i]]);\n\t\t\tdp=nex;\n\t\t}\n\t\tint ans=*min_element(all(dp));\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stdlib.h>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define min(a,b)    (((a) < (b)) ? (a) : (b))\n#define max(a,b)    (((a) > (b)) ? (a) : (b))\n#define abs(x)    ((x) < 0 ? -(x) : (x))\n//#define INF 0x3f3f3f3f\n#define delta 0.85\n#define eps 1e-3\n#define PI 3.14159265358979323846\n#define MAX_V 205\n#define MAX_R 1005\nusing namespace std;\nconst int INF = 1e8;\nint E, V, R;\nint order[MAX_R];\nint dl[MAX_V][MAX_V], ds[MAX_V][MAX_V], dp[MAX_R][MAX_V];\n\nint main(){\n\twhile(~scanf(\"%d%d\", &V, &E) && V){\n\t\tfor(int i = 0; i < V; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tdl[i][j] = ds[i][j] = INF;\n\t\t\t}\n\t\t\tdl[i][i] = ds[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < E; i++){\n\t\t\tchar c;\n\t\t\tint u, v, d;\n\t\t\tscanf(\"%d%d%d %c\", &u, &v, &d, &c);\n\t\t\t--u, --v;\n\t\t\tif(c == 'L') dl[u][v] = dl[v][u] = min(dl[u][v], d);\n\t\t\telse ds[u][v] = ds[v][u] = min(ds[u][v], d);\n\t\t}\n\t\tscanf(\"%d\", &R);\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tscanf(\"%d\", order + i);\n\t\t\t--order[i];\n\t\t}\n\t\t// Warshall_floyd\n\t\tfor(int k = 0; k < V; k++){\n\t\t\tfor(int i = 0; i < V; i++){\n\t\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// Dp\n\t\tfor (int i = 0; i < R; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][order[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++){\n\t\t\tfor(int j = 0; j < V; j++){\n\t\t\t\tif(dp[i][j] != INF){\n\t\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dl[order[i]][order[i + 1]]);\n\t\t\t\t\tfor(int k = 0; k < V; k++){\n\t\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dl[order[i]][j] + ds[j][k] + dl[k][order[i + 1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *min_element(dp[R - 1], dp[R - 1] + V));\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define INF (1ll<<58)\n\nlong long land[200][200] , ship[200][200] ;\n\t\nint main(){\n\tlong long n,m;\n\twhile(cin >> n >> m && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tlong long a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tlong long r; cin >> r;\n\t\tlong long R[1000];\t\n\t\trep(i,r)cin >> R[i] , R[i]--;\n\t\t\n\t\tlong long dp[1000][200];\n\t\trep(j,1000)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tlong long newCost = dp[bit][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[bit+1][next] = min( dp[bit+1][next],newCost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long ret = INF;\n\t\trep(i,n){\n\t\t\tret = min(dp[r-1][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\nconst int INF = 1 << 29;\n\nint N, M, R;\nint z[1010];\nint dl[210][210], ds[210][210], dist[1010][210];\n\nint main() {\n    while(cin >> N >> M, N || M) {\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                dl[i][j] = ds[i][j] = INF;\n            }\n        }\n        for(int i=0; i<M; i++) {\n            int x, y, t; string sl; cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == \"L\") {\n                chmin(dl[x][y], t);\n                chmin(dl[y][x], t);\n            }\n            else {\n                chmin(ds[x][y], t);\n                chmin(ds[y][x], t);\n            }\n        }\n\n        cin >> R;\n        for(int i=0; i<R; i++) cin >> z[i], z[i]--;\n        for(int i=0; i<R; i++) {\n            for(int j=0; j<N; j++) {\n                dist[i][j] = INF;\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    chmin(dl[i][j], dl[i][k] + dl[k][j]);\n                    chmin(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        dist[0][0] = 0;\n        for(int i=0; i<R-1; i++) {\n            int cur = z[i], to = z[i+1];\n            for(int j=0; j<N; j++) {\n                if(dist[i][j] == INF) continue;\n\n                // land only\n                chmin(dist[i+1][j], dist[i][j] + dl[cur][to]);\n\n                // sea\n                for(int k=0; k<N; k++) {\n                    chmin(dist[i+1][k], dist[i][j] + dl[cur][j] + ds[j][k] + dl[k][to]);\n                }\n            }\n        }\n\n        int ans = INF;\n        for(int i=0; i<N; i++) chmin(ans, dist[R-1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 1000000000000LL\ntypedef long long ll;\nll d[200][200];\nll se[200][200];\nll dp[2][200];\nint z[1000];\nll min(ll a,ll b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\td[i][j]=INF;\n\t\tse[i][j]=INF;\n\t\tif(i==j){\n\t\t\td[i][j]=0;\n\t\t\tse[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b;\n\t\tll c;\n\t\tchar p;\n\t\tscanf(\"%d %d %lld %c\",&a,&b,&c,&p);\n\t\ta--;b--;\n\t\tif(p=='L'){\n\t\t\td[a][b]=min(d[a][b],c);\n\t\t\td[b][a]=min(d[b][a],c);\n\t\t}\n\t\tif(p=='S'){\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++){\n\t\tscanf(\"%d\",&z[i]);\n\t\tz[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][z[0]]=0;\n\tfor(i=1;i<p;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i%2][j]=INF;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][k]+d[z[i-1]][k]+se[k][j]+d[j][z[i]]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(p+1)%2][i]);\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF ( 1<<29 )\n\nint N,M;\n\nint dp[1111][111];\nint WS[111][111];\nint WL[111][111];\n\nvoid warshall(int (*W)[111]){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++)\n      for(int k=0;k<N;k++)\n\tW[j][k] = min(W[j][k],W[j][i]+W[i][k]);\n}\n\nint main(){\n  while(  cin >> N >> M && ( N||M ) ){\n    fill(WS[0],WS[N],INF);\n    fill(WL[0],WL[N],INF);\n    fill(dp[0],dp[1001],INF);\n    for(int i=0;i<N;i++) WS[i][i] = WL[i][i] = 0;\n    for(int i=0;i<M;i++){\n      int x,y,t;\n      char s;\n      cin >> x >> y >> t >> s;\n      --x; --y;\n      if( s == 'L' ) WL[x][y] = WL[y][x] = t;\n      else WS[x][y] = WS[y][x] = t;\n    }\n    warshall(WL);\n    warshall(WS);\n    int R;\n    cin >> R;\n    int d; cin >> d;\n    --d;\n    dp[0][d] = 0;\n    for(int i=1;i<R;i++){\n      int nd; \n      cin >> nd; --nd;\n      for(int j=0;j<N;j++){\n\tif(dp[i-1][j] != INF ) {\n\t  dp[i][j] = min(dp[i][j],dp[i-1][j] + WL[d][nd]);\n\t  for(int k=0;k<N;k++){\n\t    dp[i][k] = min( dp[i][k],\n\t\t\t    dp[i-1][j] + WL[d][j] + WS[j][k] + WL[k][nd] );\n\t  }\n\t}\n      }\n      d = nd;\n    }\n    int res = INF;\n    for(int i=0;i<N;i++) res = min( res, dp[R-1][i] );\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nclass WarshallFloyd {\nprivate:\n    const int n;\n    vector<vector<int>> d;\npublic:\n    WarshallFloyd(int _n) : n(_n), d(_n, vector<int>(_n)) {\n        rep(i, n) rep(j, n) {\n            d[i][j] = (i == j ? 0 : inf);\n        }\n    }\n    // undirected\n    void setDist(int i, int j, int c) {\n        d[i][j] = c;\n        d[j][i] = c;\n    }\n    int getDist(int i, int j) {\n        return d[i][j];\n    }\n    void calc() {\n        rep(k, n) rep(i, n) rep(j, n) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n    }\n    void disp() {\n        printVV(d);\n    }\n};\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        vector<WarshallFloyd> wf(2, WarshallFloyd(n));\n        rep(i, m) {\n            int a, b, c;\n            char t;\n            cin >> a >> b >> c >> t;\n            a--, b--;\n            wf[t == 'S'].setDist(a, b, c);\n        }\n\n        rep(k, 2) wf[k].calc();\n\n        int q;\n        cin >> q;\n        int s = -1;\n        vi a(n, inf);\n        rep(i, q) {\n            int t;\n            cin >> t;\n            t--;\n            if (i == 0) {\n                a[t] = 0;\n            }\n            else {\n                vi b(n, inf);\n                rep(j, n) {\n                    chmin(b[j], a[j] + wf[0].getDist(s, t));\n                    rep(k, n) {\n                        if (j == k) continue;\n                        chmin(b[k], a[j] + wf[0].getDist(s, j) + wf[1].getDist(j, k) + wf[0].getDist(k, t));\n                    }\n                }\n                a = b;\n            }\n            s = t;\n        }\n\n        cout << *min_element(all(a)) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\nconst int INF = 1e9;\n\nstruct WarshallFloyd{\n    int n;\n    const int INF = 1e6;\n    vector<vector<int> > d;\n    WarshallFloyd(int _n){\n        n = _n;\n        d.resize(n, vector<int>(n));\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n    }\n    void build(){\n        for(int k = 0; k < n; k++){\n            for(int i = 0; i < n; i++){\n                for(int j = 0; j < n; j++){\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n    }\n};\n\nint n, m, r;\nint d[1010][210];\n\nint main(){\n    while(1){\n        cin >> n >> m;\n        if(n + m == 0) break;\n        WarshallFloyd wfl(n), wfs(n);\n        rep(i, 0, m){\n            int x, y, t; char c;\n            cin >> x >> y >> t >> c;\n            x--; y--;\n            if(c == 'L'){\n                wfl.d[x][y] = t;\n                wfl.d[y][x] = t;\n            }else{\n                wfs.d[x][y] = t;\n                wfs.d[y][x] = t;\n            }\n        }\n        cin >> r;\n        vector<int> z(r);\n        rep(i, 0, r){\n            cin >> z[i];\n            z[i]--;\n        }\n        wfl.build();\n        wfs.build();\n        rep(i, 0, r) rep(j, 0, n) d[i][j] = INF;\n        d[0][z[0]] = 0;\n        rep(i, 1, r){\n            rep(j, 0, n){\n                if(d[i - 1][j] >= INF) continue;                \n                rep(k, 0, n){\n                    int tmp = wfl.d[z[i - 1]][j] + wfs.d[j][k] + wfl.d[k][z[i]];\n                    if(j == k) tmp = wfl.d[z[i - 1]][z[i]];\n                    d[i][k] = min(d[i][k], d[i - 1][j] + tmp);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i, 0, n) ans = min(ans, d[r - 1][i]);\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M , N) {\n\t\tvvi ldist(N, vi(N, INF));\n\t\tvvi sdist(N, vi(N, INF));\n\t\tint x, y, t;\n\t\tchar sl;\n\t\tREP(i, M) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif(sl == 'L') {\n\t\t\t\tldist[x-1][y-1] = min(ldist[x-1][y-1], t);\n\t\t\t\tldist[y-1][x-1] = min(ldist[y-1][x-1], t);\n\t\t\t}\n\t\t\tif(sl == 'S') {\n\t\t\t\tsdist[x-1][y-1] = min(sdist[x-1][y-1], t);\n\t\t\t\tsdist[y-1][x-1] = min(sdist[y-1][x-1], t);\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tldist[i][i] = sdist[i][i] = 0;\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tldist[j][k] = min(ldist[j][k], ldist[j][i] + ldist[i][k]);\n\t\t\t\t\tsdist[j][k] = min(sdist[j][k], sdist[j][i] + sdist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvi z(R);\n\t\tREP(i, R) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tvvi cost(R, vi(N, INF));\n\t\tREP(i, R) {\n\t\t\tif(i == 0) {\n\t\t\t\tcost[0][z[0]] = 0;\n\t\t\t} else {\n\t\t\t\tint fr = z[i-1];\n\t\t\t\tint to = z[i];\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tcost[i][k] = min(cost[i][k], cost[i-1][j]+ldist[fr][j]+sdist[j][k]+ldist[k][to]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, cost[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\n\nconst ll INF = 1e17;\n\nint main(){\n  ll n,m,r;\n  while(cin >> n >> m){\n    if(n==0)break;\n    vector< vi > sg(n,vi(n,INF)), lg(n,vi(n,INF));\n    rep(i,n)sg[i][i] = lg[i][i] = 0;\n\n    rep(i,m){\n      ll x,y,t;\n      string s;\n      cin >> x >> y >> t >> s; x--; y--;\n      if(s == \"L\")lg[x][y] = lg[y][x] = min(lg[x][y],t);\n      else sg[x][y] = sg[y][x] =  min(sg[x][y],t);\n    }\n\n    rep(k,n)rep(i,n)rep(j,n)lg[i][j] = min(lg[i][j], lg[i][k] + lg[k][j]);\n    rep(k,n)rep(i,n)rep(j,n)sg[i][j] = min(sg[i][j], sg[i][k] + sg[k][j]);\n\n    /*\n    rep(i,n){rep(j,n)cout << lg[i][j] << \" \"; cout << endl;}\n    rep(i,n){rep(j,n)cout << sg[i][j] << \" \"; cout << endl;}\n    */\n\n    cin >> r;\n    ll cur; cin >> cur; cur--;\n    vi dis(n,INF); dis[cur] = 0;\n\n    rep(z,r-1){\n      ll nxt; cin >> nxt; nxt--;\n      vi ndis(n,INF);\n\n      rep(i,n){\n\trep(j,n){\n\t  ndis[j] = min(ndis[j], dis[i] + lg[cur][i] + sg[i][j] + lg[j][nxt]);\n\t}\n      }\n\n      dis = ndis;\n      cur = nxt;\n    }\n\n    cout << *min_element(dis.begin(), dis.end()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<long long, int> P;\n\nstruct E{\n\tint t, c;\n};\n\nint n, m, r;\nvector<E> g[40000];\nlong long d[40000];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, m){\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d %c\", &x, &y, &t, &c);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tif(c == 'L'){\n\t\t\t\trep(j, n){\n\t\t\t\t\tg[x * n + j].push_back(E{y * n + j, t});\n\t\t\t\t\tg[y * n + j].push_back(E{x * n + j, t});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tg[x * n + x].push_back(E{y * n + y, t});\n\t\t\t\tg[y * n + y].push_back(E{x * n + x, t});\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &r);\n\n\t\trep(i, r - 1){\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\t--z;\n\n\t\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\t\tif(i == 0){\n\t\t\t\tfill(d, d + n * n, 3e12);\n\t\t\t\td[z * n + z] = 0;\n\t\t\t\tq.push({0, z * n + z});\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(j, n){\n\t\t\t\t\trep(k, n){\n\t\t\t\t\t\tif(j == z){\n\t\t\t\t\t\t\tq.push({d[j * n + k], j * n + k});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\td[j * n + k] = 3e12;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.empty()){\n\t\t\t\tauto v = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif(v.first > d[v.second]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(auto& x: g[v.second]){\n\t\t\t\t\tif(d[x.t] > d[v.second] + x.c){\n\t\t\t\t\t\td[x.t] = d[v.second] + x.c;\n\t\t\t\t\t\tq.push({d[x.t], x.t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint z;\n\t\tscanf(\"%d\", &z);\n\t\t--z;\n\t\tprintf(\"%lld\\n\", *min_element(d + z * n, d + z * n + n));\n\n\t\trep(i, n * n){\n\t\t\tg[i].clear();\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][j] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nstruct road{int to,cost;};\nstruct situ{\n  int dist,pos,boat;\n  situ(int a,int b,int c){\n    dist = a;pos = b;boat = c;\n  }\n};\nbool operator < (const situ &a,const situ &b){\n  return a.dist > b.dist;\n}\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n    int d[N];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<n;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<n;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(dp[i][j],dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]]);\n          //printf(\"k=%d dp[%d][%d]=%d\\n\",k,i,j,dp[i][j]);\n          //printf(\"dp[%d][%d]+land[%d][%d]+sea[%d][%d]+land[%d][%d] = %d\\n\",i-1,k,z[i-1],k,k,j,j,z[i],dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n\nint n,m,r;\nconst int INF=1e7;\nint land[200][200],sea[200][200],z[1000];\ntypedef pair<int,int> P;\n\nint main(){\n\n\n\twhile(scanf(\"%d %d\",&n,&m),n){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) land[i][j]=sea[i][j]=INF;\n\t\t\tland[i][i]=sea[i][i]=0;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t\tx--; y--;\n\t\t\tif(c=='S'){\n\t\t\t\tsea[x][y]=min(sea[x][y],t);\n\t\t\t\tsea[y][x]=min(sea[y][x],t);\n\t\t\t}else{\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=min(land[y][x],t);\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tscanf(\"%d\",&z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(1001,vector<int>(201,INF));\n\t\tdp[0][z[0]]=0;\n\n\t\tint res=INF;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\n\t\t\t\t//z[i]???????????????????????¨??°???z[i-1]\n\t\t\t\t\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t//????????????j?????§?§???????j??????k????????????k??????z[i]?????????\t\t\t\t\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t\tif(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//????????§?§????\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\t\tif(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int MAX_N=205;\nconst int MAX_M=10000;\nconst int MAX_R=1005;\nconst int INF=0x3f3f3f3f;\n\nint land[MAX_N][MAX_N];\nint water[MAX_N][MAX_N];\nint N, M, R;\nint dp[MAX_R][MAX_N];\nint dest[MAX_R];\n\nint main(){\n    #ifndef ONLINE_JUDGE\n    freopen(\"in.txt\", \"r\", stdin);\n    #endif\n    while((cin>>N>>M) && N>0){\n        memset(land, 0x3f, sizeof(land));\n        memset(water, 0x3f, sizeof(water));\n        memset(dp, 0x3f, sizeof(dp));\n        int x, y, t; char sl;\n        for(int i=0; i<M; i++){\n            scanf(\"%d %d %d %c \", &x, &y, &t, &sl);\n            --x; --y;\n            if(sl=='L'){\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=land[x][y];\n\t\t\t}\n            else {\n\t\t\t\twater[x][y]=min(water[x][y], t);\n\t\t\t\twater[y][x]=water[x][y];\n\t\t\t}\n        }\n        for(int i=0; i<N; i++) water[i][i]=land[i][i]=0;\n        for(int i=0; i<N; i++){\n        \tfor(int j=0; j<N; j++){\n            \tfor(int k=0; k<N; k++){\n                \tland[j][k]=min(land[j][k], land[j][i]+land[i][k]);\n                \twater[j][k]=min(water[j][k], water[j][i]+water[i][k]);\n            \t}\n        \t}\n   \t    }\n        cin>>R;\n        for(int i=0; i<R; i++) {\n\t\t\tcin>>dest[i]; --dest[i];\n\t\t}\n        for(int i=0; i<N; i++) dp[0][i]=water[dest[0]][i]+land[dest[0]][i];\n        int pre=dest[0], z;\n        for(int i=1; i<R; i++){\n            z=dest[i]; \n            for(int j=0; j<N; j++){\n                int mincost=INF;\n                for(int k=0; k<N; k++){\n                    if(dp[i-1][k]!=INF && water[j][k]!=INF \n                    && land[pre][k]!=INF && land[z][j]!=INF){\n                        if(j==k) t=dp[i-1][k]+land[pre][z];\n                        else t=dp[i-1][k]+water[k][j]+land[pre][k]+land[j][z];\n                        mincost=min(mincost, t);\n                    }\n                }\n                dp[i][j]=mincost;\n            }\n            pre=z;\n        }\n        int mincost=INF;\n        for(int i=0; i<N; i++) mincost=min(mincost, dp[R-1][i]);\n        cout<<mincost<<endl;\n    }\n    #ifndef ONLINE_JUDGE\n    fclose(stdin);\n    #endif\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\n\ntypedef int weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint n, m, r;\nint dl[201][201], ds[201][201], z[1001];\nint dp[1001][201];\n\nint solve(int i, int ship)\n{\n\tif (i == r - 1) return 0;\n\tif (dp[i][ship] > 0) return dp[i][ship];\n\tint res = solve(i + 1, ship) + dl[z[i]][z[i + 1]];\n\tREP(j, n)\n\t{\n\t\tint sum = dl[z[i]][ship] + ds[ship][j] + dl[j][z[i+1]];\n\t\tchmin(res, solve(i + 1, j) + sum);\n\t}\n\treturn dp[i][ship] = res;\n}\n\nint main()\n{\n\twhile (cin >> n >> m, n)\n\t{\n\t\tMS(dp, -1);\n\t\tREP(i, n)REP(j, n)\n\t\t{\n\t\t\tdl[i][j] = (i == j ? 0 : INF);\n\t\t\tds[i][j] = (i == j ? 0 : INF);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tint x, y, t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--; y--;\n\t\t\tif (c == 'L') dl[x][y] = dl[y][x] = t;\n\t\t\telse ds[x][y] = ds[y][x] = t;\n\t\t}\n\t\tREP(k, n)REP(i, n)REP(j, n)\n\t\t{\n\t\t\tchmin(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\tchmin(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t}\n\t\tcin >> r;\n\t\tREP(i, r)\n\t\t{\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tcout << solve(z[0], z[0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e16;\nlong long int MOD = 1000000007;\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tlong long int CL[300][300], CS[300][300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tCL[i][j] = INF;\n\t\t\t\tCS[i][j] = INF;\n\t\t\t}\n\t\t\tCL[i][i] = 0;\n\t\t\tCS[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(str == \"L\"){\n\t\t\t\tCL[u][v] = cost;\n\t\t\t\tCL[v][u] = cost;\n\t\t\t}else{\n\t\t\t\tCS[u][v] = cost;\n\t\t\t\tCS[v][u] = cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tCL[i][j] = min(CL[i][j], CL[i][k] + CL[k][j]);\n\t\t\tCS[i][j] = min(CS[i][j], CS[i][k] + CS[k][j]);\n\t\t}\n\t\t\n\t\tint R, pre, num;\n\t\tcin >> R;\n\t\tcin >> pre;\n\t\tpre--;\n\t\t\n\t\tlong long int ans = INF, DP1[300], DP2[300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tDP1[i] = INF;\n\t\t}\n\t\tDP1[pre] = 0;\n\t\tfor(int i = 1; i < R; i++){\n\t\t\tcin >> num;\n\t\t\tnum--;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tDP2[j] = DP1[j] + CL[pre][num];\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tDP2[j] = min(DP2[j], CL[pre][k] + DP1[k] + CS[k][j] + CL[j][num]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(DP1, DP2);\n\t\t\tpre = num;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans = min(ans, DP1[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N,M,R;\nvector<int> A;\nll edgeL [201] [201],edgeS [201] [201];\nll dp [1001] [201];\nconst ll INF = 1e18;\n\nint main()\n{\n\twhile(cin >> N >> M && N){\n\t\tfill(edgeL [0],edgeL [201],INF);\n\t\tfill(edgeS [0],edgeS [201],INF);\n\t\tFOR(i,1,N + 1){\n\t\t\tedgeL [i] [i] = 0;\n\t\t\tedgeS [i] [i] = 0;\n\t\t}\n\t\tFOR(i,0,M){\n\t\t\tint u,v,w;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> w >> c;\n\t\t\tif(c == 'L'){\n\t\t\t\tchmin(edgeL [u] [v],(ll) w);\n\t\t\t\tchmin(edgeL [v] [u],(ll) w);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchmin(edgeS [u] [v],(ll) w);\n\t\t\t\tchmin(edgeS [v] [u],(ll) w);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tA.assign(R,0);\n\t\tFOR(i,0,R){\n\t\t\tscanf(\"%d\",&A [i]);\n\t\t}\n\n\t\tFOR(k,1,N + 1) FOR(i,1,N + 1) FOR(j,1,N + 1){\n\t\t\tchmin(edgeL [i] [j],edgeL [i] [k] + edgeL [k] [j]);\n\t\t\tedgeL [j] [i] = edgeL [i] [j];\n\t\t\tchmin(edgeS [i] [j],edgeS [i] [k] + edgeS [k] [j]);\n\t\t\tedgeS [j] [i] = edgeS [i] [j];\n\t\t}\n\n\t\tfill(dp [0],dp [1001],INF);\n\t\tdp [0] [A.front()] = 0;\n\t\tFOR(i,0,R - 1) FOR(j,1,N + 1) if(dp [i] [j] < INF){\n\t\t\tchmin(dp [i + 1] [j],dp [i] [j] + edgeL [A [i]] [A [i + 1]]);\n\t\t\tFOR(nxt,1,N + 1){\n\t\t\t\tchmin(dp [i + 1] [nxt],dp [i] [j] + edgeL [A [i]] [j] + edgeS [j] [nxt] + edgeL [nxt] [A [i + 1]]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",*min_element(dp [R - 1],dp [R]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint const MAX_N = 210;\nint const MAX_R = 1010;\nint const INF = 1<<29;\nll dpl[MAX_N][MAX_N];\nll dps[MAX_N][MAX_N];\nll dp[MAX_R][MAX_N];\nll N, M, R;\nint z[MAX_R];\n\nint main() {\n     \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      dpl[i][i] = dps[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n        dpl[i][j] = dpl[j][i] = INF;\n        dps[i][j] = dps[j][i] = INF;\n      }\n    }\n     \n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dpl[x][y] = dpl[y][x] = t;\n      }\n      else {\n        dps[x][y] = dps[y][x] = t;\n      }\n    }\n     \n    int R; cin >> R;\n    for(int i=0; i<R; i++) {\n      cin >> z[i]; z[i] --;\n    }\n     \n    // warshall floyd\n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dpl[i][j] = min(dpl[i][j], dpl[i][k]+dpl[k][j]);\n          dps[i][j] = min(dps[i][j], dps[i][k]+dps[k][j]);\n        }\n     \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    for(int i=1; i<R; i++) {\n      for(int u=0; u<N; u++) {\n        for(int v=0; v<N; v++) {\n          dp[i][v] = min(dp[i][v], dp[i-1][u] + dpl[z[i-1]][u] + dps[u][v] + dpl[v][z[i]]);\n          dp[i][v] = min(dp[i][v], dp[i-1][v] + dpl[z[i-1]][z[i]]);\n        }\n      }\n    }\n     \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)1024;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n\n/* The main code follows. */\n\nint n,m,R;\nvector<pii> riku[210],umi[210];\nint route[1010];\ni64 lan[210][210],sea[210][210];\ni64 dp[2][210];\n\nvoid solve() {\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                chmin(lan[j][k],lan[j][i]+lan[i][k]);\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        for(int j=0; j<n; ++j) {\n            for(int k=0; k<n; ++k) {\n                chmin(sea[j][k],sea[j][i]+sea[i][k]);\n            }\n        }\n    }\n    init(dp,inf<int>);\n    int now=0;\n    i64 ans=inf<int>;\n    dp[now][route[0]]=0;\n    for(int r=1; r<R; ++r,now^=1) {\n        init(dp[now^1],inf<int>);\n        for(int i=0; i<n; ++i) {\n            if(dp[now][i]>=inf<int>) continue;\n            for(int j=0; j<n; ++j) {\n                if(i==j) {\n                    chmin(dp[now^1][j],dp[now][i]+lan[route[r]][route[r-1]]);\n                } else {\n                    chmin(dp[now^1][j],dp[now][i]+lan[route[r-1]][i]+sea[i][j]+lan[route[r]][j]);\n                }\n            }\n        }\n    }\n    for(int i=0; i<n; ++i) {\n        chmin(ans,dp[now][i]);\n    }\n    writeln(ans);\n}\n\nsigned main() {\n    while(true) {\n        cin>>n>>m;\n        if(!n) break;\n        init(lan,inf<int>);\n        init(sea,inf<int>);\n        for(int i=0; i<n; ++i) lan[i][i]=sea[i][i]=0;\n        for(int i=0; i<n; ++i) {\n            riku[i].clear();\n            umi[i].clear();\n        }\n        for(int _=0; _<m; ++_) {\n            i64 x,y,t;\n            char sl;\n            cin>>x>>y>>t>>sl;\n            x--,y--;\n            if(sl=='L') {\n                riku[x].emplace_back(y,t);\n                riku[y].emplace_back(x,t);\n                chmin(lan[x][y],t);\n                chmin(lan[y][x],t);\n            } else {\n                umi[x].emplace_back(y,t);\n                umi[y].emplace_back(x,t);\n                chmin(sea[x][y],t);\n                chmin(sea[y][x],t);\n            }\n        }\n        cin>>R;\n        for(int i=0; i<R; ++i) {\n            cin>>route[i];\n            route[i]--;\n        }\n        solve();\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\ntypedef pair<long long, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<58)\n#define MOD 1000000007\n\nint N, M, Q;\nvector<P> G[200], S[200];\nint Z[1000];\nlong long dp[1000][200];\nlong long rikuro[200][200], kairo[200][200];\n\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N >> M) {\n    if (N == 0 && M == 0) break;\n    rep(i, N) G[i].clear(), S[i].clear();\n    rep(i, M) {\n      int x, y, d; char t;\n      cin >> x >> y >> d >> t;\n      x--, y--;\n      if (t == 'L') {\n        G[x].pb(P(y, d));\n        G[y].pb(P(x, d));\n      }\n      else {\n        S[x].pb(P(y, d));\n        S[y].pb(P(x, d));\n      }\n    }\n    rep(i, N) {\n      rep(j, N) rikuro[i][j] = kairo[i][j] = INF;\n      rikuro[i][i] = kairo[i][i] = 0;\n      priority_queue<P, vector<P>, greater<P> > q;\n      q.push(P(0, i));\n      while (!q.empty()) {\n        long long d; int x;\n        tie(d, x) = q.top(); q.pop();\n        if (rikuro[i][x] < d) continue;\n        for (P p : G[x]) {\n          int t = p._1;\n          long long nd = d + p._2;\n          if (rikuro[i][t] > nd) {\n            rikuro[i][t] = nd;\n            q.push(P(nd, t));\n          }\n        }\n      }\n      q.push(P(0, i));\n      while (!q.empty()) {\n        long long d; int x;\n        tie(d, x) = q.top(); q.pop();\n        if (kairo[i][x] < d) continue;\n        for (P p : S[x]) {\n          int t = p._1;\n          long long nd = d + p._2;\n          if (kairo[i][t] > nd) {\n            kairo[i][t] = nd;\n            q.push(P(nd, t));\n          }\n        }\n      }\n    }\n\n    cin >> Q;\n    rep(i, Q) {\n      cin >> Z[i];\n      Z[i]--;\n    }\n\n    rep(i, Q) {\n      rep(j, N) dp[i][j] = INF;\n    }\n    dp[0][Z[0]] = 0;\n    for (int i=1; i<Q; i++) {\n      int x = Z[i-1], t = Z[i];\n      rep(s, N) {\n        // x (s) -> t (st)\n        if (dp[i-1][s] == INF) continue;\n        dp[i][s] = min(dp[i][s], dp[i-1][s] + rikuro[x][t]);\n\n        rep(st, N) {\n          dp[i][st] = min(dp[i][st], dp[i-1][s] + rikuro[x][s] + kairo[s][st] + rikuro[st][t]);\n        }\n      }\n    }\n    cout << *min_element(dp[Q-1], dp[Q-1]+N) << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nTASK: A2200 - Mr. Rito Post Office\nLANG: C++\nNAME: untitled.cpp\n*/\n#include <cstdio>\n#include <algorithm>\n\n#define NMAX 200\n#define RMAX 1000\nconst int INTMAX=0x0fffffff;\n\nusing namespace std;\n\nint n,m,swim[NMAX][NMAX],walk[NMAX][NMAX],route[RMAX],memo[RMAX][NMAX];\nbool bay[NMAX];\n\nint func(int pos,int ship)\n{\n\tif(-1!=memo[pos][ship]){\n\t\treturn memo[pos][ship];\n\t}\n\tif(0==pos){\n\t\tint ret=INTMAX;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(bay[i]){\n\t\t\t\tret = min(ret,swim[0][ship]+walk[ship][route[pos]]);\n\t\t\t}\n\t\t}\n\t\tif(0==ship) ret = min(ret,walk[0][route[pos]]);\n\t\treturn memo[pos][ship]=ret;\n\t}\n\n\tint ret=INTMAX;\n\tfor(int i=0;i<n;i++){\n\t\tif(bay[i]){\n\t\t\tret = min(ret,func(pos-1,i)+walk[route[pos-1]][i]+swim[i][ship]+walk[ship][route[pos]]);\n\t\t}\n\t}\n\tret = min(ret,func(pos-1,ship)+walk[route[pos-1]][route[pos]]);\n\n\treturn memo[pos][ship]=ret;\n}\n\nvoid solve()\n{\n\tfill(bay,bay+n,false);\n\tfor(int i=0;i<n;i++){\n\t\tfill(swim[i],swim[i]+n,INTMAX);\n\t\tfill(walk[i],swim[i]+n,INTMAX);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tswim[i][i] = 0; walk[i][i] = 0;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,t; char sl; scanf(\"%d%d%d\\n%c\",&x,&y,&t,&sl); x--; y--;\n\t\tif('L'==sl){\n\t\t\twalk[x][y] = walk[y][x] = min(walk[x][y],t);\n\t\t}else if('S'==sl){\n\t\t\tswim[x][y] = swim[y][x] = min(swim[x][y],t);\n\t\t\tbay[x] = bay[y] = true;\n\t\t}\n\t}\n\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\twalk[i][j] = walk[j][i] = min(walk[i][j],walk[i][k]+walk[k][j]);\n\t\t\t\tswim[i][j] = swim[j][i] = min(swim[i][j],swim[i][k]+swim[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tint r; scanf(\"%d\",&r);\n\tfor(int i=0;i<r;i++){\n\t\tscanf(\"%d\",route+i); route[i]--;\n\t}\n\n\tint ret=INTMAX;\n\tfor(int i=0;i<r;i++){\n\t\tfill(memo[i],memo[i]+n,-1);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(bay[i]){\n\t\t\tret = min(ret,func(r-1,i));\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n\n\treturn;\n}\n\nint main()\n{\n\t/*FILE *fin=NULL,*fout=NULL;\n\tfin = freopen(\"input.txt\",\"r\",stdin);\n\tfout = freopen(\"output.txt\",\"w\",stdout);*/\n\n\t//DP+Warshall-Floyd\n\t//func(i,j):i番目の集配先まで、j番目の町に船を置いて到着する最短時間。\n\n\twhile(scanf(\"%d%d\",&n,&m),0!=n){\n\t\tsolve();\n\t}\n\n\t//finalize\n\t/*if(NULL!=fin) fclose(fin);\n\tif(NULL!=fout) fclose(fout);*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\ntypedef long long  ll;\n\nconst int inf=1<<29;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint n,m;\n\nint lcost[210][210];\nint scost[210][210];\nll dp[1010][210];\n\nint r;\nint z[1010];\n\nint main(void){\n\t\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,210)rep(j,210) lcost[i][j]=scost[i][j]=((i==j)?0:inf);\n\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;y--;\n\t\t\tif(sl=='S'){\n\t\t\t\tscost[x][y]=min(scost[x][y],t);\n\t\t\t\tscost[y][x]=min(scost[y][x],t);\n\t\t\t}else{\n\t\t\t\tlcost[x][y]=min(lcost[x][y],t);\n\t\t\t\tlcost[y][x]=min(lcost[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tcin >> r;\n\t\trep(i,r){cin >> z[i];z[i]--;}\n\n\t\trep(k,n)rep(i,n)rep(j,n) scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n) lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n\n\t\trep(i,1010)rep(j,210) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n)rep(k,n) dp[i+1][k]=min(dp[i+1][k],dp[i][j]+lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]]);\n\t\tll ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl; \n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nconst lnt INF = 0xffffffffffff;\nlnt n,m,x,y,z,s;\nlnt dl[200][200];\nlnt ds[200][200];\nlnt vis[1000];\nlnt ans[200][1000];\nchar str[10];\nint main()\n{while(1){\n\tcin>>n>>m;\n\tif(!n&&!m) return 0;\n\tfor(int i=0;i<200;i++) {\n\t\tfor(int j=0;j<1000;j++) {\n\t\t\tif(j<200){\n\t\t\t\tdl[i][j]=INF;\n\t\t\t\tds[i][j]=INF;\n\t\t\t}\n\t\t\tans[i][j]=INF;\n\t\t}\n\t}//fill(dl[0],dl[200]+200,INF);\n\t//fill(ds[0],ds[200]+200,INF);\n\t//fill(ans[0],ans[200]+1000,INF);\n\tfor(int i=0;i<n;i++) dl[i][i]=ds[i][i]=0;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%lld%lld%lld%s\",&x,&y,&z,str);\n\t\tx--; y--;\n\t\tif(*str=='L') dl[x][y]=dl[y][x]=z;\n\t\telse ds[x][y]=ds[y][x]=z;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n\t\t\t\tds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcin>>s;\n\tfor(lnt i=0;i<s;i++){\n\t\tcin>>vis[i];\n\t\tvis[i]--;\n\t}\n\tans[vis[0]][0]=0;\n\tfor(int i=1;i<s;i++){\n\t\tif(i==1){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tans[j][1]=ds[vis[0]][j]+dl[j][vis[1]];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<n;j++){//vis[i-1]????????????j????????????k ?????? vis[i]\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(j==k) ans[k][i]=min(ans[k][i],ans[j][i-1]+dl[vis[i-1]][vis[i]]);\n\t\t\t\t\telse ans[k][i]=min(ans[k][i],ans[j][i-1]+dl[vis[i-1]][j]+ds[j][k]+dl[k][vis[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlnt res=INF;\n\tfor(int i=0;i<n;i++) res=min(res,ans[i][s-1]);\n\tcout<<res<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct edge { int to; int cost; char type; };\nstruct Postman { int pos; int ship; int cost; };\nint V, E, R;\nstd::vector<edge> G[MAX_V];\nint D[MAX_V][MAX_V], PATH[MAX_R];\n\nbool cmp(const Postman &p1, const Postman &p2) {\n  return p1.cost > p2.cost;\n}\n\nvoid solve() {\n  for (size_t v = 0; v < V; v++) fill(D[v], D[v] + V, INF);\n  D[PATH[0]][PATH[0]] = 0;\n\n  for (size_t i = 0; i < R - 1; i++) {\n    std::priority_queue<Postman, vector<Postman>, function<bool(const Postman &, const Postman &)> > pque(&cmp);\n    int v0 = PATH[i], vf = PATH[i + 1];\n    // printf(\"%d -> %d\\n\", v0, vf);\n    for (int s = 0; s < V; s++) {\n      Postman p = {v0, s, D[v0][s]};\n      if (D[v0][s] < INF) pque.push(p);\n    }\n    while (!pque.empty()) {\n      Postman p = pque.top(); pque.pop();\n      int v = p.pos, s = p.ship;\n      if(D[v][s] < p.cost) continue;\n      // printf(\"v=%d,s=%d,c=%d\\n\", v, s, p.cost);\n      for (size_t j = 0; j < G[v].size(); j++) {\n        edge e = G[v][j];\n        int u = e.to, cost = e.cost;\n        if (e.type == 'L') {\n          if (D[v][s] + cost < D[u][s]) {\n            D[u][s] = D[v][s] + cost;\n            pque.push((Postman) {u, s, D[u][s]});\n//            printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, s, D[u][s], e.type);\n          }\n        } else if (v == s) {\n          if (D[v][s] + cost < D[u][u]) {\n            D[u][u] = D[v][s] + cost;\n            pque.push((Postman) {u, u, D[u][u]});\n            // printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, u, D[u][u], e.type);\n          }\n        }\n      }\n    }\n    for (size_t v = 0; v < V; v++) {\n      if (v != vf) fill(D[v], D[v] + V, INF);\n    }\n  }\n\n  int vF = PATH[R - 1];\n  int ans = INF;\n  for (size_t s = 0; s < V; s++) {\n    ans = min(ans, D[vF][s]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost;\n      char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      G[v].push_back((edge) {u, cost, c});\n      G[u].push_back((edge) {v, cost, c});\n    }\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n\n    for (size_t v = 0; v < V; v++) G[v].clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Warshall-Floyd + DP (O(n^3)+O(r*n^2)) */\n\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int inf=1000000000;\nint wf_l[200][200],wf_s[200][200],memo[1000][200];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\twf_l[i][j]=wf_s[i][j]=(i==j?0:inf);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\tscanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n\t\t\tx--;\ty--;\n\t\t\tif(sl=='S')\twf_s[x][y]=wf_s[y][x]=min(wf_s[x][y],t);\n\t\t\tif(sl=='L')\twf_l[x][y]=wf_l[y][x]=min(wf_l[x][y],t);\n\t\t}\n\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf_l[i][j]=min(wf_l[i][j],wf_l[i][k]+wf_l[k][j]);\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf_s[i][j]=min(wf_s[i][j],wf_s[i][k]+wf_s[k][j]);\n\n\t\tint r,from,to;\tscanf(\"%d%d\",&r,&from);\tfrom--;\n\t\tfor(int j=0;j<n;j++)\tmemo[0][j]=(j==from?0:inf);\n\t\tfor(int i=1;i<r;i++){\n\t\t\tscanf(\"%d\",&to);\tto--;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tmemo[i][j]=inf;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(j==k)\tmemo[i][j]=min(memo[i][j],memo[i-1][k]+wf_l[from][to]);\n\t\t\t\t\tlong long dis=1LL*wf_l[from][k]+wf_s[k][j]+wf_l[j][to];\n\t\t\t\t\tif(dis<inf)\tmemo[i][j]=min(memo[i][j],memo[i-1][k]+(int)dis);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfrom=to;\n\t\t}\n\n\t\tint tmin=inf;\n\t\tfor(int j=0;j<n;j++)\ttmin=min(tmin,memo[r-1][j]);\n\t\tprintf(\"%d\\n\",tmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e12;\n\nll land[210][210];\nll sea[210][210];\nint N, M;\nint R;\nvector<int> z;\n\n// even/odd, ship\nll cost[2][210];\n\nint main() {\n\twhile(cin >> N >> M, N || M) {\n\t\t// init\n\t\tfor(int i = 0; i < 210; i++) {\n\t\t\tfor(int j = 0; j < 210; j++) {\n\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\tcost[0][i] = cost[1][i] = INF;\n\t\t}\n\t\tz.clear();\n\n\t\t// input\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tll x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == \"L\")\n\t\t\t\tland[x][y] = land[y][x] = min(land[x][y], t);\n\t\t\telse if(sl == \"S\")\n\t\t\t\tsea[x][y] = sea[y][x] = min(sea[x][y], t);\n\t\t\telse\n\t\t\t\tassert(1);\n\t\t}\n\t\tcin >> R;\n\t\tz.resize(R);\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tland[j][k] = min(land[j][k], land[j][i] + land[i][k]);\n\t\t\t\t\tsea[j][k] = min(sea[j][k], sea[j][i] + sea[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcost[0][z[0]] = 0;\n\t\tfor(int i = 1; i < z.size(); i++) {\n\t\t\tfor(int j = 0; j < 210; j++)\n\t\t\t\tcost[i%2][j] = INF;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tcost[i%2][j] = min(cost[i%2][j],\n\t\t\t\t\t\t\tland[z[i-1]][k] + sea[k][j] + land[j][z[i]] + cost[(i-1)%2][k]);\n\t\t\t\t}\n\t\t\t\tcost[i%2][j] = min(cost[i%2][j], land[z[i-1]][z[i]] + cost[(i-1)%2][j]);\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tres = min(res, cost[(N-1)%2][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nint dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  vector<vector<int> > used(n,vector<int>(r,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(cost<0)assert(0);\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    if(pos==ship)\n      for(int i=0;i<n;i++){\n\tncost=cost+G[pos][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n      }\n  }\n  assert(0);\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct Postman { int pos; int ship; int cost; };\n\nint V, E, R;\nint DL[MAX_V][MAX_V], DS[MAX_V][MAX_V], DP[MAX_R][MAX_V], PATH[MAX_R];\n\nvoid warshall_floyd(int d[][MAX_V]) {\n  for (size_t w = 0; w < V; w++)\n    for (size_t u = 0; u < V; u++)\n      for (size_t v = 0; v < V; v++) d[u][v] = min(d[u][v], d[u][w] + d[w][v]);\n}\n\nvoid solve() {\n  warshall_floyd(DL);\n  warshall_floyd(DS);\n\n  for (size_t i = 0; i < R; i++)\n    for (size_t v = 0; v < V; v++) DP[i][v] = INF;\n  DP[0][PATH[0]] = 0;\n\n  for (size_t i = 1; i < R; i++) {\n    int u = PATH[i - 1], v = PATH[i];\n    for (int w = 0; w < V; w++) {\n      for (int x = 0; x < V; x++) {\n//        printf(\"DP[%d][%d]+DL[%d][%d]+DS[%d][%d]+DL[%d][%d] = %d\\n\",i-1,w,u,w,w,x,x,v,d);\n        int d;\n        if (w == x) {\n          d = DP[i-1][w] + DL[u][v];\n        } else {\n          d = DP[i-1][w] + DL[u][w] + DS[w][x] + DL[x][v];\n        }\n        DP[i][x] = (0 <= d)? min(DP[i][x], d): DP[i][x];\n      }\n    }\n  }\n\n  int ans = INF;\n  for (size_t v = 0; v < V; v++) {\n    ans = min(ans, DP[R-1][v]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t v = 0; v < V; v++)\n      for (size_t u = 0; u < V; u++) DL[v][u] = DS[v][u] = (u == v)? 0: INF;\n\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost; char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      if (c == 'L') {\n        DL[u][v] = DL[v][u] = min(DL[u][v], cost);\n      } else {\n        DS[u][v] = DS[v][u] = min(DS[u][v], cost);\n      }\n    }\n\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\n\n#define REP(j,n) for (int (j)=0; j<(int)(n); ++j)\n#define FOR(j,k,n) for (int (j)=(k); j<(int)(n); ++j)\n#define FOREQ(j,k,n) for (int (j)=(k); j<=(int)(n); ++j)\n\n#define MEMSET(z,val) memset(z,val,sizeof(z))\n#define SZ(z) ((int)(z).size())\n\nint sea[300][300];\nint land[300][300];\nint dp[2][300];\nint ar[2000];\n\nint main() {\n    int N,M;\n    while (cin>>N>>M,N|M) {\n        MEMSET(sea, 0x0f);\n        MEMSET(land, 0x0f);\n        REP(k,M) {\n            int x,y,w; char c;\n            cin>>x>>y>>w>>c;\n            x--; y--;\n            if (c == 'L') {\n                land[x][y] = min(land[x][y], w);\n                land[y][x] = min(land[y][x], w);\n            } else {\n                sea[x][y] = min(sea[x][y], w);\n                sea[y][x] = min(sea[y][x], w);\n            }\n        }\n        REP(k, N) REP(i, N) REP(j, N) {\n            sea[i][i] = 0;\n            land[i][i] = 0;\n            sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n        }\n        int R; cin>>R;\n        REP(j,R) { cin>>ar[j]; ar[j]--; }\n        int px = ar[0];\n        MEMSET(dp, 0x0f);\n        dp[0][px] = 0;\n        REP(iter, R) {\n            int nx = ar[iter];\n            int prev = iter & 1;\n            int next = (iter + 1) & 1;\n            MEMSET(dp[next], 0x0f);\n            REP(i, N) {\n                REP(j, N) {\n                    dp[next][j] = min(dp[next][j], dp[prev][i] + land[px][i] + sea[i][j] + land[j][nx]);\n                }\n                dp[next][i] = min(dp[next][i], dp[prev][i] + land[px][nx]);\n                assert(dp[next][i] >= 0);\n            }\n            px = nx;\n        }\n        int ans = 0x0f0f0f0f;\n        REP(i, N) {\n            ans = min(ans, dp[R & 1][i]);\n        }\n        assert(ans >= 0 && ans != 0x0f0f0f0f);\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n\ntypedef long long LL;\ntemplate<typename T> using V = std::vector<T>;\ntemplate<typename T> using VV = std::vector<std::vector<T>>;\ntemplate<typename T> using VVV = std::vector<std::vector<std::vector<T>>>;\n\ntemplate<class T> inline T ceil(T a, T b) { return (a + b - 1) / b; }\ntemplate<class T> inline void print(T x) { std::cout << x << std::endl; }\ntemplate<class T> inline void print_vec(const std::vector<T> &v) { for (int i = 0; i < v.size(); ++i) {  if (i != 0) {std::cout << \" \";} std::cout << v[i];} std::cout << \"\\n\"; }\ntemplate<class T> inline bool inside(T y, T x, T H, T W) {return 0 <= y and y < H and 0 <= x and x < W; }\ntemplate<class T> inline double euclidean_distance(T y1, T x1, T y2, T x2) { return sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); }\ntemplate<class T> inline double manhattan_distance(T y1, T x1, T y2, T x2) { return abs(x1 - x2) + abs(y1 - y2); }\n\nconst int INF = 1L << 30;\nconst double EPS = 1e-9;\nconst std::string YES = \"YES\", Yes = \"Yes\", NO = \"NO\", No = \"No\";\nconst std::vector<int> dy4 = { 0, 1, 0, -1 }, dx4 = { 1, 0, -1, 0 };    // 4近傍（右, 下, 左, 上）\nconst std::vector<int> dy8 = { 0, -1, 0, 1, 1, -1, -1, 1 }, dx8 = { 1, 0, -1, 0, 1, 1, -1, -1 };\n\nusing namespace std;\n\n\n/**\n * 全ノード間の最短距離をもとめる\n * matrix[i][j]には辺e=(i,j)のコスト(辺が存在しない場合はINT_MAX)\n * 負の閉路がある場合は空を返す\n * O(|V|^3)\n */\nstd::vector<std::vector<LL>> warshall_floyd(std::vector<std::vector<LL>> matrix) {\n    const unsigned long num_node = matrix.size();\n\n    // 自分の距離は0\n    for (int i = 0; i < num_node; ++i) {\n        matrix.at(i).at(i) = 0;\n    }\n\n    for (int m = 0; m < num_node; ++m) {\n        for (int s = 0; s < num_node; ++s) {\n            for (int e = 0; e < num_node; ++e) {\n                // sからeへmを経由して到達可能\n                if (matrix.at(s).at(m) != INT_MAX and matrix.at(m).at(e) != INT_MAX) {\n                    matrix.at(s).at(e) = std::min(matrix.at(s).at(e), matrix.at(s).at(m) + matrix.at(m).at(e));\n                }\n            }\n        }\n    }\n\n    // 負閉路チェック\n    for (int u = 0; u < num_node; ++u) {\n        if (matrix.at(u).at(u) < 0) {\n            return {};\n        }\n    }\n\n    return matrix;\n}\n\n\nint main() {\n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        vector<vector<LL>> matrix1(N, vector<LL>(N, INT_MAX)), matrix2(N, vector<LL>(N, INT_MAX));\n        FOR(i, 0, M) {\n            int X, Y, T;\n            char S;\n            cin >> X >> Y >> T >> S;\n            X--; Y--;\n            if (S == 'L') {\n                matrix1[X][Y] = T;\n                matrix1[Y][X] = T;\n            }\n            else if (S == 'S') {\n                matrix2[X][Y] = T;\n                matrix2[Y][X] = T;\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> route(R);\n        FOR(i, 0, R) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        matrix1 = warshall_floyd(matrix1);\n        matrix2 = warshall_floyd(matrix2);\n\n        vector<vector<LL>> dp(R, vector<LL>(N, INF));\n        dp[route[0]][route[0]] = 0;\n\n        FOR(i, 0, R - 1) {\n            int now = route[i];\n            int next = route[i + 1];\n\n            FOR(j, 0, N) {\n                FOR(k, 0, N) {\n                    // 船がjにあるとき、町nowから町jに陸路、町jから町kに海路、町kから町nextに陸路でいく\n                    LL dist = dp[i][j] + matrix1[now][j] + matrix2[j][k] + matrix1[k][next];\n                    dp[i + 1][k] = min(dp[i + 1][k], dist);\n                }\n            }\n        }\n\n        LL ans = INF;\n        FOR(i, 0, N) {\n            ans = min(ans, dp[R - 1][i]);\n        }\n        print(ans);\n    }\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        const ll inf = ten(14);\n        ll l[256][256], s[256][256];\n        rep(i, n) rep(j, n)\n            l[i][j] = s[i][j] = i == j ? 0 : inf;\n        while (m--)\n        {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if (sl == 'L')\n                l[x][y] = l[y][x] = t;\n            else\n                s[x][y] = s[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(l[i][j], l[i][k] + l[k][j]);\n            chmin(s[i][j], s[i][k] + s[k][j]);\n        }\n\n        int r, z[1024];\n        cin >> r;\n        input(z, r);\n        rep(i, r)\n            --z[i];\n\n        ll dp[1024][256];\n        rep(i, r) rep(j, n)\n            dp[i][j] = inf;\n        dp[0][z[0]] = 0;\n        rep(i, r - 1) rep(j, n) rep(k, n)\n            chmin(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n        ll res = *min_element(dp[r - 1], dp[r - 1] + n);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <cmath>\n\nusing namespace std;\n\nint n,m;\nint dl[200][200], ds[200][200],dp[1001][200];\nconst int inf = 1000000000;\n\nint main() {\n while(cin >> n >> m, n) {\n  for (int i = 0; i < n; i++)for (int j = 0; j < n; j++)dl[i][j] = ds[i][j] = inf;\n  for (int i = 0; i < n; i++)dl[i][i] = ds[i][i] = 0;\n  for (int i = 0; i < m; i++) {\n   int x,y,t;\n   char c;\n   cin >> x >> y >> t >> c;\n   x--, y--;\n   if (c == 'L') {\n    dl[x][y] = min(dl[x][y],t);\n    dl[y][x] = min(dl[y][x], t);\n   } else {\n    ds[x][y] = min(ds[x][y],t);\n    ds[y][x] = min(ds[y][x], t);\n   }\n  }\n  for (int k = 0; k < n; k++) {\n   for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n     dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n     ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n    }\n   }\n  }\n  int r, initz, pos;\n  cin >> r >> initz;\n  for (int i = 0; i < r; i++)for (int j = 0; j < n; j++)dp[i][j] = inf;\n  dp[0][initz] = 0;\n  pos = initz;\n  for (int i = 1; i < r; i++) {\n   int z;\n   cin >> z;\n   z--;\n   for (int j = 0; j < n; j++) {\n    dp[i][j] = min(dp[i][j], dp[i-1][j] + dl[pos][z]);\n    for (int k = 0; k < n; k++) {\n     dp[i][j] = min(dp[i][j], dp[i-1][k] + dl[pos][k] + ds[k][j] + dl[j][z]);\n    }\n   }\n   pos = z;\n  }\n  int ans = inf;\n  for (int i = 0; i < n; i++) {\n   ans = min(ans, dp[n-1][i]);\n  }\n  cout << ans << endl;\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int INF = 0x3f3f3f3f;\nconst int maxn = 10001;\n\nint a[1001];\nint s[201][201], l[201][201], dp[1001][201];\nint n, m, q;\n\nvoid init() {\n    for(int k = 1; k <= n; k ++) {\n        for(int i = 1; i <= n; i ++) {\n            for(int j = 1; j <= n; j ++) {\n                s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n                l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    memset(dp, INF, sizeof(dp));\n    for(int i = 1; i <= n; i ++) dp[1][i] = s[a[1]][i] + l[i][a[1]];\n    for(int i = 1; i <= q; i ++) {\n        for(int j = 1; j <= n; j ++) {\n            for(int k = 1; k <= n; k ++) {\n                dp[i][j] = min(1ll*dp[i][j], 1ll*dp[i-1][k] + l[a[i-1]][k] + s[k][j] + l[j][a[i]]);\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 1; i <= n; i ++) \n        ans = min(ans, dp[q][i]);\n    printf(\"%d\\n\", ans);\n}\n\nint main() {\n    while(scanf(\"%d%d\", &n, &m) != EOF, n||m) {\n        memset(s, INF, sizeof(s));\n        memset(l, INF, sizeof(l));\n        for(int i = 1; i <= n; i ++) \n            s[i][i] = l[i][i] = 0;\n        while(m --) {\n            int u, v, w; \n            char o[2];\n            scanf(\"%d%d%d%s\", &u, &v, &w, o);\n            if(o[0] == 'L' && w < l[u][v]) l[u][v] = l[v][u] = w;\n            if(o[0] == 'S' && w < s[u][v]) s[u][v] = s[v][u] = w;\n        }   scanf(\"%d\", &q);\n        for(int i = 1; i <= q; i ++) {\n            scanf(\"%d\", &a[i]);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <iterator>\nusing namespace std;\n\nconst int MAXN = 256;\nconst int MAXR = 1e3 + 16;\n\nint N, M, R;\nint dl[MAXN][MAXN], ds[MAXN][MAXN];\nint path[MAXR];\nint dp[2][MAXN];\n\nint x, y, t;\nchar sl;\n\nvoid floyd() {\n    for (int k = 1; k <= N; k++) {\n        for (int u = 1; u <= N; u++) {\n            for (int v = 1; v <= N; v++) {\n                if (dl[u][v] > dl[u][k] + dl[k][v]) dl[u][v] = dl[u][k] + dl[k][v];\n                if (ds[u][v] > ds[u][k] + ds[k][v]) ds[u][v] = ds[u][k] + ds[k][v];\n            }\n        }\n    }\n}\n\nint main() {\n    //freopen(\"2200-input.txt\", \"r\", stdin);\n    //freopen(\"mine.txt\", \"w\", stdout);\n    while (cin >> N >> M, N || M) {\n        memset(dl, 0x1f, sizeof(dl));\n        memset(ds, 0x1f, sizeof(ds));\n        for (int i = 1; i <= N; i++) {\n            dl[i][i] = ds[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            cin >> x >> y >> t >> sl;\n            if (sl == 'L') {\n                dl[x][y] = dl[y][x] = min(dl[x][y], t);\n            } else {\n                ds[x][y] = ds[y][x] = min(ds[x][y], t);\n            }\n        }\n        floyd(); \n        cin >> R;\n        for (int i = 1; i <= R; ++i) {\n            cin >> path[i];\n        }\n        path[0] = path[1];\n        memset(dp[0], 0x1f, sizeof(dp[0]));\n        dp[0][path[0]] = 0;\n        for (int i = 1; i <= R; ++i) {\n            memset(dp[i & 1], 0x1f, sizeof(dp[i & 1]));\n            for (int j = 1; j <= N; ++j) {\n                for (int k = 1; k <= N; k++) {\n                    dp[i & 1][k] = min(dp[!(i & 1)][j] + dl[path[i-1]][j] + ds[j][k] + dl[k][path[i]], \n                        dp[i & 1][k]);\n                    if (j == k) dp[i & 1][k] = min(dp[i & 1][k], dp[!(i & 1)][j] + dl[path[i-1]][path[i]]);\n                }\n            }\n            //copy(dp[i & 1] + 1, dp[i & 1] + N + 1, ostream_iterator<int>(cout, \" \"));\n            //cout << \"\\n\";\n        }\n        cout << *min_element(dp[R & 1] + 1, dp[R & 1] + N + 1) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\tlong long cnt = 0;\n\twhile (!Q.empty()) {\n\t\tif (cnt == N * N) { \n\t\t\treturn; \n\t\t}\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!Q.empty()) { Q.pop(); }\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF=1001001001001001001LL;\nint N,M;\nint A[200][200],B[200][200];\nint dp[2][200];\nsigned main(){\n    while(cin>>N>>M,N||M){\n        fill_n(*A,200*200,INF);\n        fill_n(*B,200*200,INF);\n        for(int i=0;i<N;i++){\n            A[i][i]=0;\n            B[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L')A[a][b]=A[b][a]=c;\n            else B[a][b]=B[b][a]=c;\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n\n        int R;cin>>R;\n        int prev;cin>>prev;prev--;\n        fill_n(*dp,2*200,INF);\n        dp[1][prev]=0;\n\n        for(int i=1;i<R;i++){\n            int cur;cin>>cur;cur--;\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if(A[prev][k]==INF||B[k][j]==INF||A[j][cur]==INF)continue;\n                    dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+A[prev][k]+B[k][j]+A[j][cur]);\n                }\n            }\n            for(int j=0;j<N;j++)dp[i&1][j]=INF;\n            prev=cur;\n        }\n\n        int mi=INF;\n        for(int i=0;i<N;i++)mi=min(mi,dp[R&1][i]);\n\n        cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1e9)\n#define s second\n#define f first\nusing namespace std;\ntypedef pair<int,int>P;\ntypedef pair<int,P> PP;\nint G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nint dijkstra(){\n  vector<vector<int> > D(n,vector<int>(r,INF));\n  vector<vector<int> > used(n,vector<int>(r,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    int cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(cost<0)assert(0);\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n    \n    int npos=z[idx+1];\n    int ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    if(pos==ship)\n      for(int i=0;i<n;i++){\n\tncost=cost+G[pos][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n      }\n  }\n  assert(0);\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int INF = 1000000007;\n\nint main(){\n\tint n, m;\n\tint land[200][200];\n\tint sea[200][200];\n\tint z[1000];\n\twhile(cin >> n >> m && m){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tland[i][j] = (i==j ? 0 : INF);\n\t\t\t\tsea[i][j] = (i==j ? 0 : INF);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x, y, t; char s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t--x; --y;\n\t\t\tif(s == 'L') land[x][y] = land[y][x] = t;\n\t\t\telse         sea[x][y] = sea[y][x] = t;\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cost[2][200];\n\t\tfor(int i=0;i<n;i++) cost[0][i] = cost[1][i] = INF;\n\t\tint R; cin >> R;\n\t\tfor(int i=0;i<R;i++){\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\tcost[0][z[0]] = 0;\n\t\tfor(int i=1;i<R;i++){\n\t\t\tint cur = 1-i%2, next = 1-cur;\n\t\t\tfor(int j=0;j<n;j++) cost[next][j] = INF;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[next][j] = min(cost[next][j], cost[cur][j]+land[z[i-1]][z[i]]);\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tint add = min(land[z[i-1]][j] + sea[j][k], INF);\n\t\t\t\t\tadd = min(add + land[k][z[i]], INF);\n\t\t\t\t\tcost[next][k] = min(cost[next][k], cost[cur][j]+add);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i=0;i<n;i++) res = min(res, cost[1-R%2][i]);\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(c=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        if(pos==route[i+1]) continue; // really?\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(i!=r-2 && e.type=='L' && !uf.same(nxtp, route[i+1])) continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    int res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct edge { int to; int cost; char type; };\nstruct Postman { int pos; int ship; int cost; };\nclass Compare {\npublic:\n    bool operator () (const Postman &p1, const Postman &p2) {\n      return p1.cost > p2.cost;\n    }\n};\n\nint V, E, R;\nstd::vector<edge> G[MAX_V];\nint D[MAX_V][MAX_V], PATH[MAX_R];\n\nvoid solve() {\n  for (size_t v = 0; v < V; v++) fill(D[v], D[v] + V, INF);\n  D[PATH[0]][PATH[0]] = 0;\n\n  for (size_t i = 0; i < R - 1; i++) {\n    std::priority_queue<Postman, vector<Postman>, Compare > pque;\n    int v0 = PATH[i], vf = PATH[i + 1];\n    // printf(\"%d -> %d\\n\", v0, vf);\n    for (int s = 0; s < V; s++) {\n      Postman p = {v0, s, D[v0][s]};\n      if (D[v0][s] < INF) pque.push(p);\n    }\n    while (!pque.empty()) {\n      Postman p = pque.top(); pque.pop();\n      int v = p.pos, s = p.ship;\n      if(D[v][s] < p.cost) continue;\n      // printf(\"v=%d,s=%d,c=%d\\n\", v, s, p.cost);\n      for (size_t j = 0; j < G[v].size(); j++) {\n        edge e = G[v][j];\n        int u = e.to, cost = e.cost;\n        if (e.type == 'L') {\n          if (D[v][s] + cost < D[u][s]) {\n            D[u][s] = D[v][s] + cost;  \n            if (u != vf) pque.push((Postman) {u, s, D[u][s]});\n//            printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, s, D[u][s], e.type);\n          }\n        } else if (v == s) {\n          if (D[v][s] + cost < D[u][u]) {\n            D[u][u] = D[v][s] + cost;\n            if (u != vf) pque.push((Postman) {u, u, D[u][u]});\n            // printf(\"push: v=%d,s=%d,c=%d,t=%c\\n\", u, u, D[u][u], e.type);\n          }\n        }\n      }\n    }\n    for (size_t v = 0; v < V; v++) {\n      if (v != vf) fill(D[v], D[v] + V, INF);\n    }\n  }\n\n  int vF = PATH[R - 1];\n  int ans = INF;\n  for (size_t s = 0; s < V; s++) {\n    ans = min(ans, D[vF][s]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost;\n      char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      G[v].push_back((edge) {u, cost, c});\n      G[u].push_back((edge) {v, cost, c});\n    }\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n\n    for (size_t v = 0; v < V; v++) G[v].clear();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint const MAX_R = 1010;\nint const MAX_N = 210;\nint const INF = 1<<29;\n\nint dl[MAX_N][MAX_N];\nint ds[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];\nint z[MAX_R];\nint N, M, R;\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dl[i][j] = dl[j][i] = INF;\n        ds[i][j] = ds[j][i] = INF;\n      }\n      dl[i][i] = dl[i][i] = ds[i][i] = ds[i][i] = 0;\n    }\n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dl[x][y] = dl[y][x] = t;\n      }\n      else {\n        ds[x][y] = ds[y][x] = t;\n      }\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k]+dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j]);\n        }\n    \n    cin >> R;\n    for(int i=0; i<R; i++) { cin >> z[i]; z[i]--; }\n    \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    \n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++) {\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s]+dl[z[i-1]][s]+ds[s][t]+dl[t][z[i]]);\n        }\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 100000000\n#define MOD 1000000007\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\ntypedef int COST;\nstruct Path\n{\n\tint from;\n\tint to;\n\tCOST cost;\n\tCOST capacity;\n\tPath(int from = 0, int to = 0, COST cost = 0, COST capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n, m);\n\t\tif (!(n | m)){ break; }\n\n\t\t// read\n\t\tvevector<int> landMap(n, n, INF), seaMap(n, n, INF);\n\t\tREP(_, n) { landMap[_][_] = seaMap[_][_] = 0; }\n\t\tREP(_, m)\n\t\t{\n\t\t\tREAD(int, x, y, t); READ(char, sl); x--; y--;\n\t\t\tif (sl == 'S') { seaMap[x][y] = seaMap[y][x] = min(seaMap[x][y], t); }\n\t\t\telse { landMap[x][y] = landMap[y][x] = min(landMap[x][y], t); }\n\t\t}\n\n\t\t//// make routemap\n\t\t//vevector<Path> landGraph(n, 0), seaGraph(n, 0);\n\t\t//REP(x, n) REP(y, n){\n\t\t//\tif (landMap[x][y] != INF) { landGraph[x].push_back(Path(x, y, landMap[x][y])); }\n\t\t//\tif (seaMap[x][y] != INF) { seaGraph[x].push_back(Path(x, y, seaMap[x][y])); }\n\t\t//}\n\n\t\t//landMap.clear();\n\t\t//seaMap.clear();\n\t\t//REP(i, n)\n\t\t//{\n\t\t//\tlandMap.push_back(dijkstra(landGraph, i).first);\n\t\t//\tseaMap.push_back(dijkstra(seaGraph, i).first);\n\t\t//}\n\n\n\t\tREP(k, n) REP(i, n) REP(j, n)\n\t\t{\n\t\t\tlandMap[i][j] = min(landMap[i][j], landMap[i][k] + landMap[k][j]);\n\t\t\tseaMap[i][j] = min(seaMap[i][j], seaMap[i][k] + seaMap[k][j]);\n\t\t}\n\n\t\t// route map できた\n\t\tREAD(int, R);\n\t\tvector<int> r = read<int>(R);\n\n\t\t// dp[i][j] 船をjにおいてi番目の町にいるよ。\n\t\tvevector<int> dp(R, n, INF);\n\t\t\n\t\tdp[0][r[0] - 1] = 0; // 初期値\n\t\tFOR(i, 1, R) // 最後の町まで行く\n\t\t{\n\t\t\tint cur = r[i - 1] - 1, next = r[i] - 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\t// 船をjにおいたまま。\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + landMap[cur][next]); // 陸路のみ\n\n\t\t\t\t// 船をkに移動してから行く。\n\t\t\t\tREP(k, n)\n\t\t\t\t{\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + landMap[cur][j] + seaMap[j][k] + landMap[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = *min_element(allof(dp[R - 1]));\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> Vl;\ntypedef vector<int> Vi;\ntypedef pair<int, int> Pi;\n\n#define INF   (1e9+7)\n#define MAX_V (200)\n#define MAX_E (10000)\n#define MAX_R (1000)\n#define MAX_C (1000)\n\nstruct Postman { int pos; int ship; int cost; };\n\nint V, E, R;\nint DL[MAX_V][MAX_V], DS[MAX_V][MAX_V], DP[MAX_R][MAX_V], PATH[MAX_R];\n\nvoid warshall_floyd(int d[][MAX_V]) {\n  for (size_t w = 0; w < V; w++)\n    for (size_t u = 0; u < V; u++)\n      for (size_t v = 0; v < V; v++) d[u][v] = min(d[u][v], d[u][w] + d[w][v]);\n}\n\nvoid solve() {\n  warshall_floyd(DL);\n  warshall_floyd(DS);\n\n  for (size_t i = 0; i < R; i++)\n    for (size_t v = 0; v < V; v++) DP[i][v] = INF;\n  DP[0][PATH[0]] = 0;\n\n  for (size_t i = 1; i < R; i++) {\n    int u = PATH[i - 1], v = PATH[i];\n    for (int w = 0; w < V; w++) {\n      for (int x = 0; x < V; x++) {\n//        printf(\"DP[%d][%d]+DL[%d][%d]+DS[%d][%d]+DL[%d][%d] = %d\\n\",i-1,w,u,w,w,x,x,v,d);\n        int d = DP[i-1][w];\n        d += (w == x)? DL[u][v]: DL[u][w] + DS[w][x] + DL[x][v];\n        DP[i][x] = (0 <= d)? min(DP[i][x], d): DP[i][x];\n      }\n    }\n  }\n\n  int ans = INF;\n  for (size_t v = 0; v < V; v++) {\n    ans = min(ans, DP[R-1][v]);\n  }\n  printf(\"%d\\n\", ans);\n}\n\nint main() {\n  while (true) {\n    scanf(\"%d %d\", &V, &E);\n    if (V == 0) break;\n    for (size_t v = 0; v < V; v++)\n      for (size_t u = 0; u < V; u++) DL[v][u] = DS[v][u] = (u == v)? 0: INF;\n\n    for (size_t i = 0; i < E; i++) {\n      int v, u, cost; char c;\n      scanf(\"%d %d %d %c\\n\", &v, &u, &cost, &c);\n      v--; u--;\n      if (c == 'L') {\n        DL[u][v] = DL[v][u] = min(DL[u][v], cost);\n      } else {\n        DS[u][v] = DS[v][u] = min(DS[u][v], cost);\n      }\n    }\n\n    scanf(\"%d\", &R);\n    for (size_t i = 0; i < R; i++) {\n      scanf(\"%d\", &PATH[i]);\n      PATH[i]--;\n    }\n\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\n\nint N,M,R;\nint land[205][205];\nint sea[205][205];\nint order[1005];\n\nvoid floydWarshall()\n{\n    for(int k=1;k<=N;k++){\n        for(int i=1;i<=N;i++){\n            for(int j=1;j<=N;j++){\n                if(i==j)\n                    land[i][j] = sea[i][j] = 0;\n                if(land[i][k]+land[k][j]<land[i][j]) \n                    land[i][j] = land[i][k]+land[k][j];\n                if(sea[i][k]+sea[k][j]<sea[i][j])\n                    sea[i][j] = sea[i][k]+sea[k][j];\n            }\n        }\n    }\n}\n\nint solve()\n{\n    int dp[1005][205];\n    memset(dp,0x3f3f,sizeof(dp));\n    dp[0][order[0]] = 0;\n    for(int i=0;i+1<R;i++){\n        for(int j=1;j<=N;j++){\n            if(dp[i][j]==0x3f3f3f3f)\n                continue;\n            dp[i+1][j] = min(dp[i+1][j],dp[i][j]+land[order[i]][order[i+1]]);\n            for(int k=1;k<=N;k++){\n                dp[i+1][k] = min(dp[i+1][k],dp[i][j]+land[order[i]][j]+sea[j][k]+land[k][order[i+1]]);\n            }\n        }\n    }\n\n    int ans = 0x3f3f3f3f;\n    for(int j=1;j<=N;j++)\n        ans = min(ans,dp[R-1][j]);\n    return ans;\n}\n\n\n\n\nint main()\n{   \n    // freopen(\"in\",\"r\",stdin);\n    while(scanf(\"%d%d\",&N,&M) && (N+M)){\n        memset(land,0x3f3f,sizeof(land));\n        memset(sea,0x3f3f,sizeof(sea));\n        for(int i=0;i<M;i++){\n            int u,v,d;\n            char c;\n            scanf(\"%d%d%d %c\",&u,&v,&d,&c);\n            if(c=='L')\n                land[u][v]=land[v][u]=d;\n            else\n                sea[u][v]=sea[v][u]=d;\n        }\n        scanf(\"%d\",&R);\n        for(int i=0;i<R;i++)\n            scanf(\"%d\",&order[i]);\n        floydWarshall();\n        int ans = solve();\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(i,s)cout <<\" \"<<i;cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 205;\nconst int MAX_R = 1005;\n\nint sd[MAX_N][MAX_N];\nint ld[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> n >> m;\n        if(n == 0){\n            break;\n        }\n        rep(i,n){\n            rep(j,n){\n                sd[i][j] = INF;\n                ld[i][j] = INF;\n            }\n        }\n        rep(i,m){\n            int p,q,r;\n            string s;\n            cin >> p >> q >> r >> s;\n            if(s == \"L\"){\n                ld[p-1][q-1] = r;\n                ld[q-1][p-1] = r;\n            }else{\n                sd[p-1][q-1] = r;\n                sd[q-1][p-1] = r;\n            }\n        }\n        rep(i,n){\n            ld[i][i] = 0;\n            sd[i][i] = 0;\n        }\n        for(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tld[i][j] = min(ld[i][j],ld[i][k]+ld[k][j]);\n                    sd[i][j] = min(sd[i][j],sd[i][k]+sd[k][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n        int R;\n        cin >> R;\n        vector<int> vec(R);\n        rep(i,R){\n            cin >> vec[i];\n            vec[i]--;\n        }\n        rep(i,R){\n            rep(j,n){\n                dp[i][j] = INF;\n            }\n        }\n        dp[0][vec[0]] = 0;\n        rep(i,R-1){\n            rep(j,n){\n                rep(k,n){\n                    dp[i+1][j] = min((ll)dp[i+1][j],(ll)dp[i][k]+ld[vec[i]][k]+sd[k][j]+ld[j][vec[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n){\n            ans = min(ans,dp[R-1][i]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(c=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        if(pos==route[i+1]) continue; // really?\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(e.type=='L' && !uf.same(e.to, nxtp)) continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    int res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000000\nint le[200][200];\nint se[200][200];\nint dp[2][200];\nint q[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<200;i++){\n\t\tfor(j=0;j<200;j++){\n\t\t\tle[i][j]=INF;\n\t\t\tse[i][j]=INF;\n\t\t}\n\t\tle[i][i]=0;\n\t\tse[i][i]=0;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar t;\n\t\tscanf(\"%d %d %d %c\",&a,&b,&c,&t);\n\t\ta--;b--;\n\t\tif(t=='L'){\n\t\t\tle[a][b]=min(le[a][b],c);\n\t\t\tle[b][a]=min(le[b][a],c);\n\t\t}\n\t\telse{\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tle[i][j]=min(le[i][j],le[i][k]+le[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint nq;\n\tscanf(\"%d\",&nq);\n\tfor(i=0;i<nq;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t\tq[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][q[0]]=0;\n\tfor(i=1;i<nq;i++){\n\t\tfor(j=0;j<n;j++)dp[i%2][j]=INF;\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][k]=min(dp[i%2][k],dp[(i+1)%2][j]+le[q[i-1]][j]+se[j][k]+le[k][q[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+le[q[i-1]][q[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(nq+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\ntypedef long long ll;\n\nconst int N   = 200;\nconst ll inf =(1LL<<58);\n\nll land[N][N];\nll sea[N][N];\n\nvoid wf(int n,ll mat[N][N]){\n  rep(k,n)rep(i,n)rep(j,n)mat[i][j]=min(mat[i][j],mat[i][k]+mat[k][j]);\n}\n\n\nll dp[1000][N];\nll solve(int n,vector<int> &in,int s){\n  wf(n,land);\n  wf(n,sea);\n  rep(i,in.size())rep(j,n)dp[i][j]=inf;\n//   rep(i,n){\n//     rep(j,n){\n//       dp[0][j]=min(dp[0][j],land[s][i]+sea[i][j]+land[j][in[0]]);\n//       cout << dp[0][j] << endl;\n//     }\n//   }\n\n  dp[0][s]=0;\n\n  REP(i,1,in.size()){\n    rep(j,n){\n      rep(k,n){\n\tdp[i][k]=min(dp[i][k],\n\t\t     dp[i-1][j]+land[in[i-1]][j]+sea[j][k]+land[k][in[i]]);\n\t//dp[i][k]=min(dp[i][k],dp[i-1][k]+land[in[i-1]][in[i]]);\n      }\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+land[in[i-1]][in[i]]);\n    }\n  }\n\n  ll ret = inf;\n  rep(i,n)ret=min(ret,dp[n-1][i]);\n  return ret;\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m && n){\n    rep(i,n){\n      rep(j,n)sea[i][j]=land[i][j]=inf;\n      sea[i][i]=0;land[i][i]=0;\n    }\n    rep(i,m){\n      int f,t;ll c;char tmp;\n      cin>>f>>t>>c>>tmp;\n      f--;t--;\n      if (tmp == 'L')land[f][t]=land[t][f]=min(land[t][f],c);\n      if (tmp == 'S')sea[f][t] =sea[t][f] =min( sea[t][f],c);\n    }\n\n\n    int q;\n    cin>>q;\n    vector<int> in(q);\n    rep(i,q)cin>>in[i],in[i]--;\n    cout << solve(n,in,in[0]) << endl;\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\n\nll dp[1010][210];\nll riku[210][210], fune[210][210];\n\n\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m && (n | m)) {\n\t\trep(i, 1010) rep(j, 210) dp[i][j] = LINF;\n\t\trep(i, 210) rep(j, 210) riku[i][j] = fune[i][j] = (i == j ? 0LL : LINF);\n\t\trep(i, m) {\n\t\t\tint a, b;\n\t\t\tll t;\n\t\t\tstring s;\n\t\t\tcin >> a >> b >> t >> s;\n\t\t\ta--; b--;\n\t\t\tif(s == \"L\") riku[a][b] = riku[b][a] = min(riku[a][b], t);\n\t\t\telse fune[a][b] = fune[b][a] = min(fune[a][b], t);\n\t\t}\n\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\tfune[i][j] = min(fune[i][j], fune[i][k] + fune[k][j]);\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvi v(r);\n\t\trep(i, r) cin >> v[i], v[i]--;\n\t\tdp[0][v[0]] = 0LL;\n\t\trep(i, r - 1) {\n\t\t\trep(j, n) if(dp[i][j] != LINF) {\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + riku[v[i]][v[i+1]]);\n\t\t\t\trep(k, n) {\n\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j] + riku[v[i]][j] + fune[j][k] + riku[k][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = LINF;\n\t\tfor(int i = 0; i < 210; i++) ans = min(ans, dp[r-1][i]);\n\t\tcout<<ans<<endl;\n \t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 214748360012345\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to;\n  long cost;\n  char type;\n};\n\ntypedef pair<long, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(c=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<long> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(i!=r-2 && e.type=='L' && !uf.same(nxtp, route[i+1])) continue;\n          long nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    long res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint n,m;\nll scost[200][200];\nll lcost[200][200];\nint z[1000];\nll cost[1000][200];\n\nvoid solve(){\n  rep(i,n)rep(j,n) scost[i][j]=lcost[i][j]=1LL<<30LL;\n  rep(i,n) scost[i][i]=lcost[i][i]=0;\n  rep(i,m){\n    ll x,y,t;\n    char s;\n    cin >> x >> y >> t >> s;\n    --x,--y;\n    if(s=='S') scost[x][y]=scost[y][x]=min(scost[x][y],t);\n    else lcost[x][y]=lcost[y][x]=min(lcost[x][y],t);    \n  }\n  rep(k,n)rep(i,n)rep(j,n){\n    scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n    lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n  }\n\n  int r;\n  cin >> r;\n  rep(i,r){ cin >> z[i];--z[i];}\n  rep(i,r)rep(j,n) cost[i][j]=1LL<<50LL;\n  cost[0][z[0]]=0;\n  ll ans=1LL<<60LL;\n  rep(i,r-1)rep(j,n){\n    rep(k,n){\n      ll nc=cost[i][j];\n      if(k==j)  nc += lcost[z[i]][z[i+1]];\n      else nc += lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]];\n      cost[i+1][k]=min(cost[i+1][k],nc);\n      if(i+1==r-1) ans=min(ans,cost[i+1][k]);\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                //if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                //    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                //}\n                assert(z[i]<5*N);\n                if (dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#define maxn (210)\n#define ll long long\n#define il inline\n#define RG register\nusing namespace std;\nconst ll inf=0x1f1f1f1f1f1f1f1f;\nil ll gi(){ RG ll x=0,q=1; RG char ch=getchar(); while( ( ch<'0' || ch>'9' ) && ch!='-' ) ch=getchar();\n  if( ch=='-' ) q=-1,ch=getchar(); while(ch>='0' && ch<='9') x=x*10+ch-48,ch=getchar(); return q*x; }\n\nchar s[2];\nint n,m,R,Q[maxn*5];\nll L[maxn][maxn],S[maxn][maxn],C[maxn*5][maxn];\n\nil ll dfs(){  \n  for(RG int k=1;k<=n;k++){  \n    for(RG int i=1;i<=n;i++)    \n      for(RG int j=1;j<=n;j++){  \n        S[i][j]=min(S[i][j],S[i][k]+S[k][j]);  \n        L[i][j]=min(L[i][j],L[i][k]+L[k][j]);  \n      }  \n  }  \n  C[1][Q[1]]=0;  \n  for(RG int i=1;i<=R;i++) \n    for(RG int j=1;j<=n;j++){\n      C[i][j]=min(C[i][j],C[i-1][j]+L[ Q[i-1] ][ Q[i] ]);\n      for(RG int k=1;k<=n;k++){  \n        C[i][k]=min(C[i][k],C[i-1][j]+L[ Q[i-1] ][j]+S[j][k]+L[k][ Q[i] ]);  \n      }\n    }  \n  RG ll ans=inf;  \n  for(RG int i=1;i<=n;i++) ans=min(ans,C[R][i]);  \n  return ans;  \n} \n\nil void init(){\n  memset(L,inf,sizeof(L));  \n  memset(S,inf,sizeof(S));  \n  memset(C,inf,sizeof(C));  \n  for(RG int i=1;i<=n;++i) L[i][i]=S[i][i]=0;\n}\n\nint main(){\n  while(scanf(\"%d%d\",&n,&m),n|m){  \n    init();  \n    for(int i=1;i<=m;++i){  \n      RG int a=gi(),b=gi();RG ll c=gi();\n      scanf(\"%s\",s);  \n      if(s[0]=='S') S[a][b]=S[b][a]=min(S[a][b],c);   \n      else L[a][b]=L[b][a]=min(L[a][b],c);  \n    }\n    R=gi();  \n    for(RG int i=1;i<=R;++i) Q[i]=gi();\n    printf(\"%lld\\n\",dfs());  \n  }  \n  return 0;  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n\nint n,m,r;\nconst int INF=1e7;\nint land[200][200],sea[200][200],z[1000];\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\n\nstruct edge{\n\tint to,cost;\n\tinline edge(int t,int c){\n\t\tto=t,cost=c;\n\t}\t\n};\n\n// ?????????????????????n?????????\npriority_queue<P,vector<P>,greater<P> > q;\nvector<edge> GS[200],GL[200];\nint dl[200][200],ds[200][200];\n\nint main(){\n\n\n\twhile(scanf(\"%d %d\",&n,&m),n){\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++) dl[i][j]=ds[i][j]=land[i][j]=sea[i][j]=INF;\n\t\t\tland[i][i]=sea[i][i]=0;\n\t\t\tdl[i][i]=ds[i][i]=0;\n\t\t\tGS[i].clear();\n\t\t\tGL[i].clear();\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t\tx--; y--;\n\t\t\tif(c=='S'){\n\t\t\t\tGS[x].push_back(edge(y,t));\n\t\t\t\tGS[y].push_back(edge(x,t));\n\t\t\t\tsea[x][y]=min(sea[x][y],t);\n\t\t\t\tsea[y][x]=min(sea[y][x],t);\n\t\t\t}else{\n\t\t\t\tGL[x].push_back(edge(y,t));\n\t\t\t\tGL[y].push_back(edge(x,t));\n\t\t\t\tland[x][y]=min(land[x][y],t);\n\t\t\t\tland[y][x]=min(land[y][x],t);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\t\n\t\t\tds[i][i]=0;\n\t\t\tq.push(P(0,i));\n\t\t\twhile(!q.empty()){\n\t\t\t\t\n\t\t\t\tP p=q.top(); q.pop();\n\t\t\t\tint cost=p.first,pos=p.second;\n\t\t\t\tif(ds[i][pos]<cost) continue;\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<GS[pos].size();j++){\n\t\t\t\t\tedge e=GS[pos][j];\n\t\t\t\t\tif(ds[i][e.to]>ds[i][pos]+e.cost){\n\t\t\t\t\t\tds[i][e.to]=ds[i][pos]+e.cost;\n\t\t\t\t\t\tq.push(P(ds[i][e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\n\t\t\tdl[i][i]=0;\n\t\t\tq.push(P(0,i));\n\t\t\twhile(!q.empty()){\n\t\t\t\t\n\t\t\t\tP p=q.top(); q.pop();\n\t\t\t\tint cost=p.first,pos=p.second;\n\t\t\t\tif(dl[i][pos]<cost) continue;\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<GL[pos].size();j++){\n\t\t\t\t\tedge e=GL[pos][j];\n\t\t\t\t\tif(dl[i][e.to]>dl[i][pos]+e.cost){\n\t\t\t\t\t\tdl[i][e.to]=dl[i][pos]+e.cost;\n\t\t\t\t\t\tq.push(P(dl[i][e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t}\n\t\t\t\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tscanf(\"%d\",&z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tvector<vector<int> > dp(1001,vector<int>(201,INF));\n\t\tdp[0][z[0]]=0;\n\n\t\tint res2=INF;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\n\t\t\t\t//z[i]???????????????????????¨??°???z[i-1]\n\t\t\t\t\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t//????????????j?????§?§???????j??????k????????????k??????z[i]?????????\t\t\t\t\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+dl[z[i-1]][j]+ds[j][k]+dl[k][z[i]]);\n\t\t\t\t\tif(i==r-1 && res2>dp[i][k]) res2=dp[i][k];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//????????§?§????\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+dl[z[i-1]][z[i]]);\n\t\t\t\tif(i==r-1 && res2>dp[i][j]) res2=dp[i][j];\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res2);\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 26;\ninline void chmin(int &a, int b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1001];\n\nint solve()\n{\n\tstatic int ldist[200][200];\n\tstatic int sdist[200][200];\n\tstatic int dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1001 * 200, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r], dp[r + 1]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl[0] == 'L') ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nll dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(D[ship][idx]<cost) continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1))),D[ship][idx+1]=ncost;\n\n    for(int i=0;i<n;i++){\n\tncost=cost+G[pos][ship][0]+G[ship][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1))),D[i][idx+1]=ncost;\n      }\n  }\n  assert(0);\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint q[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x7ffffff;\n\nvoid Floyd(int n) {\n  for(int i = 1; i <= n; ++i) {\n    for(int j = 1; j <= n; ++j) {\n      for(int k = 1; k <= n; ++k) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while(scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n    memset(q, 0x3f, sizeof(q));\n\n    while(m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if(tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for(int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n    b[0] = 1;\n    for(int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    for(int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if(s[i][j] < INF && l[i][j] < INF) {\n          q[i][j] = s[i][j] + l[i][j];\n        }\n      }\n    }\n\n    d[0][1] = 0;\n\n    for(int i = 1; i <= r; ++i) {\n      for(int j = 1; j <= n; ++j) {\n        if(l[j][b[i]] >= INF) continue;\n        for(int k = 1; k <= n; ++k) {\n          if(d[i-1][k] >= INF) continue;\n          if(j == k){\n            if(l[b[i-1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i-1][k] + l[b[i-1]][b[i]]);\n            }\n          } else{\n            if(l[b[i-1]][k] < INF && s[k][j] < INF) {\n              d[i][j] = min(d[i][j], d[i-1][k] + l[b[i-1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for(int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 220\n#define MAX_R 1020\n#define INF 123456789\n\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> Q;\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> Q2;\nvector<tuple<int, int, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nint A1, A2, A3;\nint travel[MAX_R];\nint DIST[MAX_N][MAX_N], DIST2[MAX_N];\nint COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nint PATH[MAX_N][MAX_N][MAX_N];\nint DP[MAX_R][MAX_N];\nint cnt, cnt2;\n\nvoid dijkstra(int st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<int, int, int>tup = Q.top();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint a4 = get<0>(X[a2][i]);\n\t\t\tint a5 = get<1>(X[a2][i]);\n\t\t\tint a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tint a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tint a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (M >= 10000) { cnt2++; }\n\t\tif (cnt2 == 2) { break; }\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = DIST[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tint start = travel[i];\n\t\t\t\tint goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+2][NMAX+2];\n\tll sdp[NMAX+2][NMAX+2];\n\tll dp[NMAX+2][RMAX+2];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=min(ldp[x][y],t);\n\t\t\t\tldp[y][x]=min(ldp[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=min(sdp[x][y],t);\n\t\t\t\tsdp[y][x]=min(sdp[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=R;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\t\tcin>>bzi;\n\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tdp[i][0]=sdp[bzi][i]+ldp[i][bzi];\n\t\t}\n\n\t\tfor(int i=1;i<R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<\",\"<<ldp[zi][bzi]<<endl;\n\t\t\t\t\tif(j!=k) dp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t\telse dp[j][i]=min(dp[j][i],dp[k][i-1]+ldp[bzi][zi]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R-1];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R-1]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    int dist1[200][200], dist2[200][200];\n    REP(i,200)REP(j, 200){\n      dist1[i][j] = (i != j) ? INF : 0;\n      dist2[i][j] = (i != j) ? INF : 0;\n    }\n    REP(i, M){\n      int x, y, t;\n      char sl;\n      scanf(\"%d %d %d %c\", &x, &y, &t, &sl);\n      x--; y--;\n      if(sl == 'L') dist1[x][y] = dist1[y][x] = t;\n      else dist2[x][y] = dist2[y][x] = t;\n    }\n    REP(k, 200)REP(i, 200)REP(j, 200){\n      dist1[i][j] = min(dist1[i][j], dist1[i][k] + dist1[k][j]);\n      dist2[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j]);\n    }\n    int R; cin>>R;\n    vector<int> z(R);\n    REP(i, R) {\n      cin>>z[i];\n      z[i]--;\n    }\n    int d[1001][200];\n    REP(i, 1001)fill(d[i], d[i] + 200, INF);\n    d[0][z[0]] = 0;\n    REP(i, R - 1)REP(fship, N)REP(toship,N){\n      d[i+1][toship] = min(d[i][fship] + dist1[z[i]][fship] + dist2[fship][toship] + dist1[toship][z[i+1]], d[i+1][toship]);\n    }\n    int ans = INF;\n    REP(i, N) ans = min(ans, d[R-1][i]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][j] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int k = 0; k < n; k++){\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF=1001001001001001LL;\nint N,M;\nint A[200][200],B[200][200];\nint dp[2][200];\nsigned main(){\n    while(cin>>N>>M,N||M){\n        fill_n(*A,200*200,INF);\n        fill_n(*B,200*200,INF);\n        for(int i=0;i<N;i++){\n            A[i][i]=0;\n            B[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L')A[a][b]=A[b][a]=min(A[a][b],c);\n            else B[a][b]=B[b][a]=min(B[a][b],c);\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n\n        int R;cin>>R;\n        int prev;cin>>prev;prev--;\n        fill_n(*dp,2*200,INF);\n        dp[1][prev]=0;\n\n        for(int i=1;i<R;i++){\n            int cur;cin>>cur;cur--;\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if(j!=k)dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+A[prev][k]+B[k][j]+A[j][cur]);\n                    else dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][j]+A[prev][cur]);\n                }\n            }\n            for(int j=0;j<N;j++)dp[i&1][j]=INF;\n            prev=cur;\n        }\n\n        int mi=INF;\n        for(int i=0;i<N;i++)mi=min(mi,dp[R&1][i]);\n\n        cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct State {\n  unsigned char p, s;\n  int r, cost;\n  State() {}\n  State(int p, int s, int r, int cost)\n    : p(p), s(s), r(r), cost(cost) {}\n  bool operator < (const State &_s) const {\n    if(cost != _s.cost) return cost > _s.cost;\n    if(r != _s.r) return r > _s.r;\n    if(p != _s.p) return p > _s.p;\n    return s > _s.s;\n  }\n};\n\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nconst int INF = 1<<24;\nint N, M, R;\nint G[MAX_N][MAX_N][2];\nvector<int> Z;\nbool vis[MAX_N][MAX_N][MAX_R];\npriority_queue<State> que;\n\nvoid init() {\n  for(int i = 0; i < MAX_N; ++i) {\n    for(int j = 0; j < MAX_N; ++j) {\n      G[i][j][0] = INF;\n      G[i][j][1] = INF;\n    }\n  }\n  Z.clear();\n}\n\nint solve() {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      for(int k = 0; k < R; ++k) {\n\tvis[i][j][k] = false;\n      }\n    }\n  }\n  State s(Z[0], Z[0], 1, 0);\n  while(!que.empty()) que.pop();\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(s.r == R && s.p == Z[R-1]) return s.cost;\n    if(vis[s.p][s.s][s.r]) continue;\n    vis[s.p][s.s][s.r] = true;\n    for(int j = 0; j <= (s.p == s.s); ++j) {\n      for(int i = 0; i < N; ++i) {\n\tif(G[s.p][i][j] == INF) continue;\n\tState t(i, (j ? i : s.s), s.r+(Z[s.r] == i), s.cost+G[s.p][i][j]);\n\tif(vis[t.p][t.s][t.r]) continue;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    init();\n    for(int i = 0; i < M; ++i) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      bool isS = (sl == 'S');\n      G[x][y][isS] = t;\n      G[y][x][isS] = t;\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      int z;\n      cin >> z;\n      Z.push_back(z-1);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 21:22 ~\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tint d, z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nint dp[1005][205][205];\t\t// z, boat, n\n\nint solve(){\n\tpriority_queue<ST> que;\n\tint d, z, b, n;\n\tint count = 0;\n\tdp[0][ Z[0] ][ Z[0] ] = 0;\n\trep(i,R){\n\t\trep(b,N) rep(n,N) if( dp[i][b][n] < INF ){\n\t\t\tque.push( ST{dp[i][b][n], i, b, n} );\n\t\t}\n\t\twhile( !que.empty() ){\n\t\t\tST st = que.top();\n\t\t\tque.pop();\n\t\t\td = st.d;\n\t\t\tz = st.z;\n\t\t\tb = st.b;\n\t\t\tn = st.n;\n\t\t\tcount++;\n\t\t\tif( dp[z][b][n] < d || z+1 >= R ) continue;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\t\tint to = _v.first;\n\t\t\t\t\tint cost = _v.second;\n\t\t\t\t\tint nz = z, nb = b;\n\t\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\t\tif( k ) nb = to;\n\t\t\t\t\tif( chmin( dp[nz][nb][to], dp[z][b][n] + cost) ){\n\t\t\t\t\t\tif( nz == z )\n\t\t\t\t\t\t\tque.push( ST{ dp[nz][nb][to], nz, nb, to } );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(b,N) rep(n,N){\n\t\tchmin( ans, dp[R-1][b][n] );\n\t}\n\t//cout << \"count: \" << count << endl;\n\treturn ans;\n}\n\nint main(){\n\tint x, y, t;\n\tchar sl;\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\nll dp[1010][210][210];\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tVV(pii) land(n);\n\t\tVV(pii) sea(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L'){\n\t\t\t\tland[a].PB(pii(b,c));\n\t\t\t\tland[b].PB(pii(a,c));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsea[a].PB(pii(b,c));\n\t\t\t\tsea[b].PB(pii(a,c));\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin>>r;\n\t\tvint dest(r);\n\t\trep(i,r) cin>>dest[i],dest[i]--;\n\t\trep(i,r){\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i][j][k]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttypedef pair<pll,pll> P;\n\t\tpriority_queue<P> pq;\n\t\tpq.push(mkp(pll(0,0),pll(dest[0],dest[0])));\n\t\twhile(!pq.empty()){\n\t\t\tP top=pq.top();\n\t\t\tpq.pop();\n\t\t\tif(dp[top.F.S][top.S.F][top.S.S]>=0) continue;\n\t\t\tdp[top.F.S][top.S.F][top.S.S]=-top.F.F;\n\t\t\t// cout<<-top.F.F<<\" \"<<top.F.S<<\" \"<<top.S.F<<\" \"<<top.S.S<<endl;\n\t\t\tif(top.F.S==r-1&&dest[r-1]==top.S.F){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(pii x:land[top.S.F]){\n\t\t\t\tif(x.F==dest[top.F.S+1]){\n\t\t\t\t\tif(dp[top.F.S+1][x.F][top.S.S]==-1){\n\t\t\t\t\t\tpq.push(mkp(pll(top.F.F-x.S,top.F.S+1),pll(x.F,top.S.S)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(dp[top.F.S][x.F][top.S.S]==-1){\n\t\t\t\t\t\tpq.push(mkp(pll(top.F.F-x.S,top.F.S),pll(x.F,top.S.S)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(top.S.F==top.S.S) for(pii x:sea[top.S.F]){\n\t\t\t\tif(x.F==dest[top.F.S+1]){\n\t\t\t\t\tif(dp[top.F.S+1][x.F][x.F]==-1){\n\t\t\t\t\t\tpq.push(mkp(pll(top.F.F-x.S,top.F.S+1),pll(x.F,x.F)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(dp[top.F.S][x.F][x.F]==-1){\n\t\t\t\t\t\tpq.push(mkp(pll(top.F.F-x.S,top.F.S),pll(x.F,x.F)));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans=INFL;\n\t\t// dp[r-1][dest[r-1]]\n\t\t// cout<<r-1<<\" \"<<dest[r-1]<<endl;\n\t\trep(i,n){\n\t\t\tif(dp[r-1][dest[r-1]][i]==-1) continue;\n\t\t\tmins(ans,dp[r-1][dest[r-1]][i]);\n\t\t\t// cout<<dp[r-1][dest[r-1]][i]<<endl;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\n#define MP make_pair\n#define PB push_back\n#define inf (1LL<<60)\n#define mod 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\nint main(){\n    int n,m;\n    while(cin >> n >> m && n!=0){\n        vector<vector<ll> > L(n,vector<ll>(n,inf)),S(n,vector<ll>(n,inf));\n        rep(i,n){\n            L[i][i] = 0;\n            S[i][i] = 0;\n        }\n        rep(i,m){\n            int a,b;\n            ll t;\n            cin >> a >> b >> t;\n            a--;b--;\n            char c;\n            cin >> c;\n            if(c=='L'){\n                L[a][b] = min(L[a][b],t);\n                L[b][a] = min(L[b][a],t);\n            }else{\n                S[a][b] = min(S[a][b],t);\n                S[b][a] = min(S[b][a],t);\n            }\n        }\n        int rr;\n        cin >> rr;\n        vector<int> r(rr);\n        rep(i,rr){\n            cin >> r[i];\n            r[i]--;\n        }\n        rep(k,n){\n            rep(i,n){\n                rep(j,n){\n                    L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n                    S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n                }\n            }\n        }\n        vector<vector<ll> > dp(rr,vector<ll>(n,inf));\n        dp[0][r[0]] = 0;\n        for(int i=1;i<rr;i++){\n            int s = r[i-1];\n            int t = r[i];\n            rep(j,n){\n                rep(k,n){\n                    dp[i][k] = min(dp[i][k],dp[i-1][j]+L[s][j]+S[j][k]+L[k][t]);\n                    if(j==k){\n                        dp[i][k] = min(dp[i][k],dp[i-1][j]+L[s][t]);\n                    }\n                }\n            }\n        }\n        ll mi = inf;\n        rep(i,n){\n            mi = min(mi,dp[rr-1][i]);\n        }\n        cout << mi << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\nconst int INF = 1e9;\n\ntypedef long long ll;\n\nll land[210][210];\nll sea[210][210];\nint N, M;\nint R;\nvector<int> z;\n\n// even/odd, ship\nll cost[2][210];\n\nint main() {\n\twhile(cin >> N >> M, N || M) {\n\t\t// init\n\t\tfor(int i = 0; i < 210; i++) {\n\t\t\tfor(int j = 0; j < 210; j++) {\n\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\tcost[0][i] = cost[1][i] = INF;\n\t\t}\n\t\tz.clear();\n\n\t\t// input\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tll x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == \"L\")\n\t\t\t\tland[x][y] = land[y][x] = min(land[x][y], t);\n\t\t\telse\n\t\t\t\tsea[x][y] = sea[y][x] = min(sea[x][y], t);\n\t\t}\n\t\tcin >> R;\n\t\tz.resize(R);\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tland[j][k] = min(land[j][k], land[j][i] + land[i][k]);\n\t\t\t\t\tsea[j][k] = min(sea[j][k], sea[j][i] + sea[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++)\n\t\t\t\tcout << sea[i][j] << \" \";\n\t\t\tcout << endl;\n\t\t}\n\t\t// */\n\n\t\tcost[0][z[0]] = 0;\n\t\tfor(int i = 1; i < z.size(); i++) {\n\t\t\tfor(int j = 0; j < 210; j++)\n\t\t\t\tcost[i%2][j] = INF;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tcost[i%2][j] = min(cost[i%2][j],\n\t\t\t\t\t\t\tland[z[i-1]][k] + sea[k][j] + land[j][z[i]] + cost[(i+1)%2][k]);\n\t\t\t\t}\n\t\t\t\tcost[i%2][j] = min(cost[i%2][j], land[z[i-1]][z[i]] + cost[(i+1)%2][j]);\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tres = min(res, cost[(N-1)%2][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[1010][210];\nint land[210][210];\nint sea[210][210];\nint Z[1005];\nint N,M,x,y,t,R;\nchar sl;\nint main () {\n\t\n\tcin >> N >> M;\n\twhile (N) {\n\t\tfor (int i = 0; i < 1010; i++) {\n\t\t\tfor (int j = 0; j < 201; j++) {\n\t\t\t\tdp[i][j] = 300000000;\n\t\t\t\tif (i > 201) continue;\n\t\t\t\tland[i][j] = 10000000;\n\t\t\t\tsea[i][j] = 10000000;\n\t\t\t\tif (i == j) {\n\t\t\t\t\tland[i][j] = 0;\n\t\t\t\t\tsea[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int m = 0; m < M; m++) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tland[x][y] = min(land[x][y], t);\n\t\t\t\tland[y][x] = min(land[y][x], t);\n\t\t\t} else {\n\t\t\t\tsea[x][y] = min(sea[x][y], t);\n\t\t\t\tsea[y][x] = min(sea[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 1; k <= N; k++) {\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfor (int j = 1; j <= N; j ++) {\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor(int r = 0; r < R; r++) cin >> Z[r];\n\t\tdp[0][Z[0]] = 0;\n\t\t\n\t\tfor (int i = 0 ; i < R - 1; i++) {\n\t\t\tfor (int n = 1; n <= N; n++) {\n\t\t\t\tfor (int n2 = 1; n2 <= N; n2++) {\n\t\t\t\t\tdp[i + 1][n2] = min(dp[i + 1][n2], dp[i][n] + land[Z[i]][n] + sea[n][n2] + land[n2][Z[i + 1]]);\n\t\t\t\t\tif(n == n2) dp[i + 1][n] = min(dp[i + 1][n], dp[i][n] + land[Z[i]][Z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 10000000;\n\t\tfor (int n = 1; n <= N; n++) {\n\t\t\tans = min(ans, dp[R - 1][n]);\n\t\t}\n\t\tcout << ans << endl;\n\t\tcin >> N >> M;\n\t}\n}\n\t\t\t\t\n\t\t\t\n\t\t\n\t\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define INF 1e6\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[1000];\n    for(int i = 0 ; i < MAX ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        dp[r][now] = min(dp[r][now], dp[r-1][now] + G1[now][next]);\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 256;\nconst int MAXR = 1e3 + 16;\n\nint N, M, R;\nunsigned dl[MAXN][MAXN], ds[MAXN][MAXN];\nint path[MAXR];\nunsigned dp[2][MAXN];\n\nint x, y, t;\nchar sl;\n\nvoid floyd() {\n    for (int k = 1; k <= N; k++) {\n        for (int u = 1; u <= N; u++) {\n            for (int v = 1; v <= N; v++) {\n                if (dl[u][v] > dl[u][k] + dl[k][v]) dl[u][v] = dl[u][k] + dl[k][v];\n                if (ds[u][v] > ds[u][k] + ds[k][v]) ds[u][v] = ds[u][k] + ds[k][v];\n            }\n        }\n    }\n}\n\nint main() {\n    //freopen(\"2200.txt\", \"r\", stdin);\n    while (cin >> N >> M, N | M) {\n        memset(dl, 0x3f, sizeof(dl));\n        memset(ds, 0x3f, sizeof(ds));\n        for (int i = 1; i <= N; i++) {\n            dl[i][i] = ds[i][i] = 0;\n        }\n        for (int i = 0; i < M; i++) {\n            cin >> x >> y >> t >> sl;\n            if (sl == 'L') {\n                dl[x][y] = dl[y][x] = t;\n            } else {\n                ds[x][y] = ds[y][x] = t;\n            }\n        }\n        floyd();\n        /*for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                //cout << i << \" \" << j << \" \" << dl[i][j] << \" \" << ds[i][j] << \"\\n\";\n            }\n        }*/\n        cin >> R;\n        for (int i = 1; i <= R; ++i) {\n            cin >> path[i];\n        }\n        memset(dp[0], 0x3f, sizeof(dp[0]));\n        dp[0][1] = 0;\n        int prev = 1;\n        for (int i = 1; i <= R; ++i) {\n            memset(dp[i & 1], 0x3f, sizeof(dp[i & 1]));\n            int to = path[i];\n            for (int j = 1; j <= N; ++j) {\n                for (int k = 1; k <= N; k++) {\n                    dp[i & 1][k] = min(dp[!(i & 1)][j] + dl[prev][j] + ds[j][k] + dl[k][to], \n                        dp[i & 1][k]);\n                }\n            }\n            prev = to;\n        }\n        cout << *min_element(dp[R & 1] + 1, dp[R & 1] + N + 1) << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nconst int INF = 10000000;\nconst int MAX_N = 200;\nconst int MAX_R = 1000;\n//struct edge {int };\n\nint main() {\n  // ifstream cin(\"../test.txt\");\n  while (true) {\n    int N, M;\n    cin >> N >> M;\n    if (!(N | M)) break;\n    // dl, dsの初期化\n    int dl[MAX_N][MAX_N]; // 陸路の最短距離\n    int ds[MAX_N][MAX_N]; // 海路の最短距離\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        if (i == j) {\n          dl[i][i] = 0;\n          ds[i][i] = 0;\n        } else {\n          dl[i][j] = INF;\n          ds[i][j] = INF;\n        }\n      }\n    }\n    int x, y, t;\n    char sl;\n    while (M--) {\n      cin >> x >> y >> t >> sl;\n      x--; y--;\n      if (sl == 'L') {\n        dl[x][y] = t;\n        dl[y][x] = t;\n      } else if (sl == 'S') {\n        ds[x][y] = t;\n        ds[y][x] = t;\n      }\n    }\n    // ワーシャルフロイド\n    for (int k = 0; k < N; k++) {\n      for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n        }\n      }\n    }\n    // 表示\n    cout << \"dl----------\" << endl;\n    for (int k = 0 ; k < N; k++) {\n     for (int i = 0; i < N; i++) {\n       cout << k+1 << \" \" << i+1 << \" \";\n       cout << dl[k][i] << endl;\n     }\n   }\n   cout << \"ds----------\" << endl;\n   for (int k = 0 ; k < N; k++) {\n    for (int i = 0; i < N; i++) {\n      cout << k+1 << \" \" << i+1 << \" \";\n      cout << ds[k][i] << endl;\n    }\n  }\n  cout << \"------------\" <<endl;\n    // dp 初期化\n    int dp[MAX_R][MAX_N];\n    int z[MAX_R];\n    int R;\n    cin >> R;\n    for (int i = 0; i < R; i++) {\n      cin >> z[i];\n      z[i]--;\n    }\n    for (int i = 0; i < R; i++) {\n      for (int j = 0; j < N; j++) {\n        dp[i][j] = INF;\n      }\n    }\n    dp[0][z[0]] = 0;\n    for (int j = 0; j < N; j++) {\n      dp[0][j] = ds[z[0]][j];\n    }\n    // dp 計算\n    int s, g;\n    for (int i = 1; i < R; i++) {\n      for (int j = 0; j < N; j++) {\n        s = z[i-1];\n        g = z[i];\n        // dp[i-1][k] + dl[s][k] + ds[k][j] + dl[j][g] の最小値\n        int min_s = INF;\n        for (int k = 0; k < N; k++) {\n          if (INF > dp[i-1][k] + dl[s][k] + ds[k][j])\n            min_s = min(min_s, dp[i-1][k] + dl[s][k] + ds[k][j]);\n        }\n        min_s += dl[j][g];\n        dp[i][j] = min(dp[i-1][j] + dl[s][g], min_s);\n      }\n    }\n    // 出力\n    int ans = INF;\n    for (int i = 0; i < N; i++) {\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int INF = 1 << 28;\n\nint main() {\n\tint n, m;\n\t\n\twhile ( cin >> n >> m, n | m ) {\n\t\tVVI L( n, VI( n, INF ) ),\n\t\t\tS( n, VI( n, INF ) );\n\t\t\n\t\tfor ( int i = 0; i < m; ++i ) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t\n\t\t\tswitch ( s ) {\n\t\t\tcase 'L':\n\t\t\t\tL[x - 1][y - 1] = L[y - 1][x - 1] = min( t, L[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tS[x - 1][y - 1] = S[y - 1][x - 1] = min( t, S[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\t\n\t\tVI Z( r, 0 );\n\t\t\n\t\tfor ( int i = 0; i < r; ++i ) {\n\t\t\tcin >> Z[i];\n\t\t\t--Z[i];\n\t\t}\n\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tL[i][i] = S[i][i] = 0;\n\t\t}\n\n\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\t\tL[i][j] = min( L[i][j], L[i][k] + L[k][j] );\n\t\t\t\t\tS[i][j] = min( S[i][j], S[i][k] + S[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVVI d( r, VI( n, INF ) );\n\t\td[0][Z[0]] = 0;\n\t\tfor ( int i = 0; i + 1 < r; ++i ) {\n\t\t\tint from = Z[i], to = Z[i + 1];\n\t\t\t//d[i + 1][to] = min( d[i + 1][to], d[i][from] + S[from][to] );\n\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\td[i + 1][to] = min( d[i + 1][to], d[i][j] + L[from][j] + S[j][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][j] + L[from][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][from] + S[from][j] + L[j][to] );\n\t\t\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\t\t\td[i + 1][k] = min( d[i + 1][k], d[i][j] + L[from][j] + S[j][k] + L[k][to] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tans = min( ans, d[r - 1][i] );\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int64 INF = 1LL << 55;\n\nvoid Floyd_Warshall(vector< vector< int64 > >& graph){\n  for(int k = 0; k < graph.size(); k++){\n    for(int i = 0; i < graph.size(); i++){\n      for(int j = 0; j < graph.size(); j++){\n        graph[i][j] = min( graph[i][j], graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n  return ;\n}\n\nint main(){\n  int N, M, R, z[1001];\n  vector< vector< int64 > > Road_graph, Sea_graph;\n  int64 dp[1001][200];\n\n  while(cin >> N >> M, N){\n    \n    Road_graph = vector< vector< int64 > >( N, vector< int64 >( N, INF));\n    Sea_graph  = vector< vector< int64 > >( N, vector< int64 >( N, INF));\n    for(int i = 0; i < N; i++){\n      Road_graph[i][i] = Sea_graph[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if(sl == 'L') Road_graph[x][y] = Road_graph[y][x] = t;\n      else          Sea_graph [x][y] = Sea_graph [y][x] = t;\n    }\n    cin >> R;\n    z[0] = 0;\n    for(int i = 1; i <= R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    Floyd_Warshall(Road_graph);\n    Floyd_Warshall( Sea_graph);\n\n    //dp[idx][船の場所]\n    fill_n( *dp, 1001 * 200, INF);\n    dp[z[0]][0] = 0;\n    for(int i = 0; i < R; i++){\n      for(int j = 0; j < N; j++){ //船の場所\n        if(dp[i][j] == INF) continue;\n        dp[i + 1][j] = min( dp[i + 1][j], dp[i][j] + Road_graph[z[i]][z[i + 1]]);\n        for(int k = 0; k < N; k++){\n          int Cost = Road_graph[z[i]][j] + Sea_graph[j][k] + Road_graph[k][z[i + 1]];\n          if(Cost > INF) continue;\n          dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + Cost);\n        }\n      }\n    }\n    int64 ret = INF;\n    for(int i = 0; i < N; i++){\n      ret = min( ret, dp[R][i]);\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define mp(a,b) make_pair((a),(b))\n#define eq ==\n\ntypedef long long ll;\ntypedef complex<double> point;\ntypedef pair<int,int> pii;\n\n// →↑←↓\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,-1,0,1};\n\n\nconst double EPS = 1e-9;\nconst int INF = 1 << 20;\n\nint main(){\n    while(true){\n        int N,M;\n        cin >> N >> M;\n        if(N == 0 and M == 0) break;\n        vector<vector<vector<int> > > dist(2,vector<vector<int> >(N,vector<int>(N,INF)));\n        for(int i=0;i<M;i++){\n            int x,y,t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;y--;\n            int isl = (sl=='L')?0:1;\n            dist[isl][x][y] = min(dist[isl][x][y],t);\n            dist[isl][y][x] = min(dist[isl][y][x],t);\n        }\n        for(int i=0;i<N;i++){\n            dist[0][i][i] = dist[1][i][i] = 0;\n        }\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    dist[0][i][j] = min(dist[0][i][j],dist[0][i][k]+dist[0][k][j]);\n                    dist[1][i][j] = min(dist[1][i][j],dist[1][i][k]+dist[1][k][j]);\n                }\n            }\n        }\n        int R;\n        cin >> R;\n        vector<int> togo(R);\n        for(int i=0;i<R;i++){\n            cin >> togo[i];\n            togo[i]--;\n        }\n        vector<vector<int> > dp(R+1,vector<int>(N,INF));\n        dp[0][togo[0]] = 0;\n        for(int i=0;i<R;i++){\n            for(int j=0;j<N;j++){\n                if(dp[i][j] == INF) continue;\n                for(int k=0;k<N;k++){\n                    dp[i+1][k] = min(dp[i+1][k],dp[i][j] + \n                            dist[0][togo[i]][j] +\n                            dist[1][j][k] +\n                            dist[0][k][togo[i+1]]);\n                }\n            }\n        }\n        int ret = INF;\n        for(int i=0;i<N;i++){\n            ret = min(ret,dp[R-1][i]);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX\n#define EPS 1e-14\n\n#define LAND dist[0]\n#define SEA dist[1]\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> Triple;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\nconst int NMAX = 201, RMAX = 1001;\nlli dist[2][NMAX][NMAX]; // land, sea;\nlli dp[RMAX][NMAX][NMAX];\nlli N,M,R;\nvector<int> z_;\n\nint main() {\n  while (cin >> N >> M and N) {\n    REP(sl,2) REP(i,N) REP(j,N) { dist[sl][i][j] = (i == j ? 0:INF); }\n    REP(i,M) {\n      int x,y,t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      x--; y--;\n      dist[(sl == 'L'? 0:1)][x][y] = dist[(sl == 'L'? 0:1)][y][x] = t;\n    }\n    REP(sl,2) REP(k,N) REP(i,N) REP(j,N) {\n      chmin(dist[sl][i][j], dist[sl][i][k] + dist[sl][k][j]);\n    }\n    cin >> R;\n    REP(i,N) REP(j,N) { dp[R][i][j] = 0; }\n    z_.resize(R);\n    REP(i, R) { cin >> z_[i]; z_[i]--; }\n    RREP(r,R) REP(man,N) REP(ship,N) {\n      lli v = z_[r];\n      dp[r][man][ship] = dp[r+1][v][ship] + LAND[man][v];\n      REP(p,N) {\n        chmin(dp[r][man][ship], dp[r+1][v][p] + LAND[man][ship] + SEA[ship][p] + LAND[p][v]);\n      }\n    }\n    cout << dp[0][z_[0]][z_[0]] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint ord[1111];\nint dl[222][222],ds[222][222],dp[1111][222];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    int n,m,r;\n    vector<P> g[222];\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,n)rep(j,n){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n    }\n    rep(i,m){\n      int x,y,t;\n      char c;\n      cin>>x>>y>>t>>c;\n      x--; y--;\n      if(c=='L'){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    //rep(i,n)rep(j,n)dbg(ds[i][j]);\n    cin>>r;\n    rep(i,r){\n      cin>>ord[i];\n      ord[i]--;\n    }\n    rep(i,r+1)rep(j,n)dp[i][j]=INF;\n    dp[0][ord[0]]=0;\n    rep(i,r-1){\n      int crt=ord[i],nxt=ord[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        minch(dp[i+1][nxt],dp[i][j]+dl[crt][j]+ds[j][nxt]);\n        if(crt==j){\n          rep(k,n){\n            minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n          }\n        }\n      }\n    }\n    int res=INF;\n    rep(i,n)minch(res,dp[r-1][i]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst int INF = 1000000000;\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n#define rep(i,n) REP(i, 0, n)\nint sea[200][200], land[200][200], z[1000];\nll dp[1000][200];\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, M, R, x, y, t;\n    char _c;\n    while(cin >> N >> M && N){\n        rep(i, N) rep(j, N)\n          sea[i][j] = land[i][j] = i == j ? 0: INF;\n        rep(i, M){\n            cin >> x >> y >> t >> _c; --x; --y;\n            if(_c == 'L')\n              land[x][y] = land[y][x] = min(land[x][y], t);\n            else\n              sea[x][y] = sea[y][x] = min(sea[x][y], t);\n        }\n        cin >> R;\n        rep(i, R){\n            cin >> z[i];\n            --z[i];\n        }\n        \n        rep(k, N) rep(i, N) rep(j, N){\n            sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n        }\n        \n        rep(i, 1000) rep(j, 200) dp[i][j] = INF;\n        dp[0][z[0]] = 0;\n        REP(i, 1, R) rep(j, N){\n            dp[i][j] = min(dp[i][j], dp[i - 1][j] + (ll)land[z[i - 1]][z[i]]);\n            rep(k, N)\n              dp[i][k] = min(dp[i][k], dp[i - 1][j] + (ll)land[z[i - 1]][j] + (ll)sea[j][k] + (ll)land[k][z[i]]);\n        }\n        \n        ll ans = INF;\n        rep(i, N) ans = min(ans, dp[R - 1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n \nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n \nint main(){\n    int N, M;\n \n    while(cin >> N >> M ,(N | M)){\n\tfill(G1[0], G1[MAX], INF);\n\tfill(G2[0], G2[MAX], INF);\n \n\tint x, y, t;\n\tchar ch;\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> x >> y >> t >> ch;\n\t    x--, y--;\n\t    if(ch == 'L'){\n\t\tG1[x][y] = G1[y][x] = t;\n\t    }else{\n\t\tG2[x][y] = G2[y][x] = t;\n\t    }\n\t}\n     \n\tfor(int i = 0 ; i < N ; i++){\n\t    G1[i][i] = G2[i][i] = 0;\n\t}\n     \n\tfor(int k = 0 ; k < N ; k++){\n\t    for(int i = 0 ; i < N ; i++){\n\t\tfor(int j = 0 ; j < N ; j++){\n\t\t    G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n\t\t    G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n\t\t}\n\t    }\n\t}\n \n\tint R, z[MAX_R];\n\tfor(int i = 0 ; i < MAX_R ; i++){\n\t    for(int j = 0 ; j < MAX ; j++){\n\t\tdp[i][j] = INF;\n\t    }\n\t}\n \n\tcin >> R;\n\tfor(int i = 0 ; i < R ; i++){\n\t    cin >> z[i]; z[i]--;\n\t}\n \n\tint now = z[0];\n\tdp[0][now] = 0;\n\tfor(int r = 1 ; r < R ; r++){\n\t    int next = z[r];\n\t    for(int j = 0 ; j < N ; j++){\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t    dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n\t\t}\n\t\tdp[r][j]=min(dp[r][j], dp[r-1][j] + G1[now][next]);\n\t    }\n\t    now = next; \n\t}\n \n\tint ans = INF;\n\tfor(int i = 0 ; i < N ; i++){\n\t    ans = min(ans, dp[R-1][i]);\n\t}\n\tcout << ans << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N, M;\nvector<int> z;\nint Land[210][210];\nint Sea[210][210];\nlong long dp[1001][210];\n\n#define INF (1<<29)\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    z.clear();\n    for(int i=0; i<N; i++) {\n      Land[i][i] = Sea[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n\tLand[i][j] = Land[j][i] = INF;\n\tSea[i][j] = Sea[j][i] = INF;\n      }\n    }\n    \n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n\tLand[x][y] = Land[y][x] = min(Land[x][y], t); // taju hen ari\n      }\n      else {\n\tSea[x][y] = Sea[y][x] = min(Sea[x][y], t); // taju hen ari\n      }\n    }\n    \n    int R; cin >> R;\n    z.resize(R);\n    for(int i=0; i<R; i++) {\n      cin >> z[i]; z[i] --;\n    }\n    \n    // warshall floyd\n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n\tfor(int j=0; j<N; j++) {\n\t  Land[i][j] = min(Land[i][j], Land[i][k]+Land[k][j]);\n\t  Sea[i][j] = min(Sea[i][j], Sea[i][k]+Sea[k][j]);\n\t}\n    \n    fill(dp[0], dp[0]+1001*210, INF);\n    dp[0][z[0]] = 0;\n    for(int i=1; i<R; i++) {\n      for(int u=0; u<N; u++) {\n\tfor(int v=0; v<N; v++) {\n\t  dp[i][v] = min(dp[i][v], dp[i-1][u] + Land[z[i-1]][u] + Sea[u][v] + Land[v][z[i]]);\n\t  dp[i][v] = min(dp[i][v], dp[i-1][v] + Land[z[i-1]][z[i]]);\n\t}\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\n#define mp            make_pair\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 100000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint N, M;\nint x[11111], y[11111];\nint s[11111][11111], t[11111][11111];\nint tx;\nchar q;\nint R;\nint z[1111];\nint dp[1111][222];\n\nint main(int argc, char *argv[])\n{\n  while(cin >> N >> M, N){\n    rep(i, N) rep(j, N) s[i][j] = t[i][j] = INF;\n    rep(i, M){\n      cin >> x[i] >> y[i] >> tx >> q;\n      if(q == 'L') minup(s[x[i] - 1][y[i] - 1], tx);\n      if(q == 'L') minup(s[y[i] - 1][x[i] - 1], tx);\n      if(q == 'S') minup(t[x[i] - 1][y[i] - 1], tx);\n      if(q == 'S') minup(t[y[i] - 1][x[i] - 1], tx);\n    }\n    cin >> R;\n    rep(i, R) cin >> z[i];\n    rep(i, R) z[i] -= 1;\n    rep(i, N) s[i][i] = t[i][i] = 0;\n    rep(k, N) rep(i, N) rep(j, N) minup(s[i][j], s[i][k] + s[k][j]);\n    rep(k, N) rep(i, N) rep(j, N) minup(t[i][j], t[i][k] + t[k][j]);\n\n    rep(i, R) rep(j, N) dp[i][j] = INF;\n    rep(i, N) dp[0][i] = s[z[0]][i] + t[i][z[0]];\n    rep(i, R - 1) rep(j, N) rep(k, N){\n      minup(dp[i + 1][k], dp[i][j] + s[z[i]][j] + t[j][k] + s[k][z[i + 1]]);\n      if(j == k) minup(dp[i + 1][k], dp[i][k] + s[z[i]][z[i + 1]]);\n    }\n\n    int res = INF;\n    rep(i, N) minup(res, dp[R - 1][i]);\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n    }\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    int res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 500000000\nint le[200][200];\nint se[200][200];\nint dp[2][200];\nint q[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tle[i][j]=INF;\n\t\t\tse[i][j]=INF;\n\t\t}\n\t\tle[i][i]=0;\n\t\tse[i][i]=0;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar t;\n\t\tscanf(\"%d %d %d %c\",&a,&b,&c,&t);\n\t\ta--;b--;\n\t\tif(t=='L'){\n\t\t\tle[a][b]=min(le[a][b],c);\n\t\t\tle[b][a]=min(le[b][a],c);\n\t\t}\n\t\telse{\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tle[i][j]=min(le[i][j],le[i][k]+le[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p,nq;\n\tscanf(\"%d\",&nq);\n\tfor(i=0;i<nq;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t\tq[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][q[0]]=0;\n\tfor(i=1;i<nq;i++){\n\t\tfor(j=0;j<n;j++)dp[i%2][j]=INF;\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][k]=min(dp[i%2][k],dp[(i+1)%2][j]+le[q[i-1]][j]+se[j][k]+le[k][q[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+le[q[i-1]][q[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(nq-1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    ll land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<n;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;ll t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>a[i];a[i]--;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    ll dp[1001][201];\n    for(int i=0;i<r;i++)for(int j=0;j<n;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n        }\n      }\n    }\n    /*for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        cout<<dp[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;*/\n    ll ans=inf;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define NMAX 200\n#define RMAX 1000\n#define INF 100000000\n\ntypedef long long ll;\n\nint main(void){\n\n\tll N,M;\n\tll x,y,t;\n\tchar sl;\n\tll R,zi;\n\tll bzi;\n\tll ans;\n\tll ldp[NMAX+1][NMAX+1];\n\tll sdp[NMAX+1][NMAX+1];\n\tll dp[NMAX+1][RMAX+1];\n\n\twhile(1){\n\n\t\tcin>>N>>M;\n\t\tif(N==0&&M==0) break;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tldp[i][j]=INF;\n\t\t\t\tsdp[i][j]=INF;\n\t\t\t}\n\t\t\tldp[i][i]=0;\n\t\t\tsdp[i][i]=0;\n\t\t}\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='L'){\n\t\t\t\tldp[x][y]=min(ldp[x][y],t);\n\t\t\t\tldp[y][x]=min(ldp[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsdp[x][y]=min(sdp[x][y],t);\n\t\t\t\tsdp[y][x]=min(sdp[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=1;k<=N;k++){\n\t\t\tfor(int i=1;i<=N;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tldp[i][j]=min(ldp[i][j],ldp[i][k]+ldp[k][j]);\n\t\t\t\t\tsdp[i][j]=min(sdp[i][j],sdp[i][k]+sdp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin>>R;\n\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tfor(int j=0;j<=N;j++){\n\t\t\t\tdp[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tdp[1][0]=0;\n\t\tbzi=1;\n\n\t\tfor(int i=1;i<=R;i++){\n\t\t\tcin>>zi;\n\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t//cout<<i<<\",\"<<j<<\",\"<<k<<\",\"<<dp[j][i]<<\",\"<<ldp[j][zi]<<\",\"<<sdp[k][j]<<\",\"<<ldp[bzi][k]<<\",\"<<dp[k][i-1]<<endl;\n\t\t\t\t\tdp[j][i]=min(dp[j][i],ldp[j][zi]+sdp[k][j]+ldp[bzi][k]+dp[k][i-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbzi=zi;\n\t\t}\n\n\t\tans=dp[1][R];\n\t\tfor(int i=2;i<=N;i++){\n\t\t\tans=min(ans,dp[i][R]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<LL>> riku(n,vector<LL>(n,INF));\n    vector<vector<LL>> kai(n,vector<LL>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    LL x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    // for(int i=0;i<n;i++){\n    //   for(int j=0;j<n;j++){\n    //     cout << kai[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    int r;\n    cin >> r;\n    vector<LL> z(r);\n    for(int i=0;i<r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<LL>> dp(r,vector<LL>(n,INF));\n    for(int i=0;i<n;i++) dp[0][i]=riku[i][z[0]];\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    // for(int i=0;i<=r;i++){\n    //   for(int j=0;j<n;j++){\n    //     cout << dp[i][j] << \" \";\n    //   }\n    //   cout << endl;\n    // }\n    LL ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};//URDL\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nstruct Edge{\n  int dst;\n  int time;\n  char type;\n  Edge(int _d,int _ti,char _ty) : dst(_d),time(_ti),type(_ty){}\n  Edge(){}\n};\n\nclass State{\npublic:\n  int next_target_idx;\n  int current_pos;\n  int cost;\n  int ship_pos;\n  State(int _nt,int _cp,int _c,int _s) : next_target_idx(_nt), current_pos(_cp),cost(_c),ship_pos(_s) {}\n  bool operator <(const State& s) const {\n    return cost < s.cost;\n  }\n  bool operator >(const State& s) const {\n    return cost > s.cost;\n  }\n};\n\nint heuristic(int src,int dst,int warshall_floyd[201][201]){\n  return warshall_floyd[src][dst];\n}\n\nint dp[201][201][201]; //current_pos,target_pos,ship_pos\n\nint main(){\n  int total_cities;\n  int total_roads;\n\n  while(~scanf(\"%d %d\",&total_cities,&total_roads)){\n    if(total_cities == 0 && total_roads == 0) break;\n\n    vector<Edge> edges[201];\n    int warshall_floyd[201][201];\n    memset(warshall_floyd,0x3f,sizeof(warshall_floyd));\n\n    for(int road_idx = 0; road_idx < total_roads; road_idx++){\n      int src,dst,time;\n      char type[2];\n      scanf(\"%d %d %d %s\",&src,&dst,&time,type);\n      edges[src].push_back(Edge(dst,time,type[0]));\n      edges[dst].push_back(Edge(src,time,type[0]));\n      warshall_floyd[src][dst] = time;\n      warshall_floyd[dst][src] = time;\n    }\n\n    int total_routes;\n    int routes[1001];\n    scanf(\"%d\",&total_routes);\n    for(int route_idx = 0; route_idx < total_routes; route_idx++){\n      int route;\n      scanf(\"%d\",&route);\n      routes[route_idx] = route;\n    }\n\n    for(int k = 0; k <= total_cities; k++){\n      for(int i = 0; i <= total_cities; i++){\n\tfor(int j = 0; j <= total_cities; j++){\n\t  warshall_floyd[i][j]\n\t    = min(warshall_floyd[i][j],\n\t\t  warshall_floyd[i][k]+warshall_floyd[k][j]);\n\t}\n      }\n    }\n    priority_queue<State,vector<State>,greater<State> > que;\n\n    // next_target_idx,current_pos,cost,ship_pos\n    que.push(State(0,routes[0],0,routes[0]));\n\n    memset(dp,0x3f,sizeof(dp));\n\n    int res = INF;\n    while(!que.empty()){\n      State s = que.top();\n      que.pop();\n      if(dp[s.current_pos][routes[s.next_target_idx]][s.ship_pos]\n\t <= s.cost + heuristic(s.current_pos,routes[total_routes-1],warshall_floyd)) continue;\n      dp[s.current_pos][routes[s.next_target_idx]][s.ship_pos]\n\t= s.cost + heuristic(s.current_pos,routes[total_routes-1],warshall_floyd);\n\n      if(s.next_target_idx == total_routes - 1\n\t && routes[s.next_target_idx] == s.current_pos){\n\tres = s.cost;\n\tgoto found;\n      }\n\n      for(int dst_idx = 0; dst_idx < edges[s.current_pos].size(); dst_idx++){\n\tint dst = edges[s.current_pos][dst_idx].dst;\n\tint time = edges[s.current_pos][dst_idx].time;\n\tchar type = edges[s.current_pos][dst_idx].type;\n\n\tif(type == 'S' && s.ship_pos != s.current_pos) continue;\n\n\tint next_target_idx = s.next_target_idx;\n\tif(s.current_pos == routes[s.next_target_idx]){\n\t  next_target_idx++;\n\t}\n\tint next_ship_pos = s.ship_pos;\n\tif(type == 'S' && s.current_pos == s.ship_pos){\n\t  next_ship_pos = dst;\n\t}\n\t// next_target_idx,current_pos,cost,ship_pos\n\tState next(next_target_idx,dst,s.cost + time,next_ship_pos);\n\tque.push(next);\n      }\n    }\n  found:;\n\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nconst int INF = 1e8;\nconst int MAX_V = 205;\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tint riku[MAX_V][MAX_V];\n\t\tint umi[MAX_V][MAX_V];\n\t\tinit(riku);\n\t\tinit(umi);\n\t\trep(i,m){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl[0] == 'L') riku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\telse umi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t}\n\t\twarshallFloyd(riku, n);\n\t\twarshallFloyd(umi, n);\n\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i,r) cin >> z[i];\n\t\tfor(auto& i : z) i--;\n\n\t\tvector<vector<int>> dp(r, vector<int>(n, INF));\n\t\tdp[0][z[0]] = 0;\n\t\trep(i,r - 1){\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tint cur = z[i];\n\t\t\t\t\tint nxt = z[i + 1];\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + riku[cur][j] +\n\t\t\t\t\t\t\tumi[j][k] + riku[k][nxt]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,n) cout << dp.back()\n\n\t\tcout << *min_element(all(dp.back())) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//{??????(???)?????????(???)?????????(???)??????, ??????(???)??????}??¨???????§?????????°?????????????????£?????????.\n//??????????§??????????????????¶????????????????????????(????????????????????°, ????????´???)???????????§???????????§DP?????§????????????\n//?§?????????????????????¶???????????????O(N)?????????????????????O(N^3)???????¨??????§???????§?O(1)?????§???????????§???O(RN^2)???DP????????£????????????????????????\n#include <iostream>\n#include <algorithm>\n#define int long long\nusing namespace std;\n\nvoid chmin(int &a, int b) {\n\ta = min(a, b);\n}\n\nint INF = 1145141919;\nint n, m;\nint cost[2][200][200];\nint r;\nint z[1000];\nint dp[1000][200];\n\nvoid initCost() {\n\tint i, j, k;\n\tfor (i = 0; i < 2; i++) {\n\t\tfor (j = 0; j < n; j++) for (k = 0; k < n; k++) cost[i][j][k] = INF;\n\t\tfor (j = 0; j < n; j++) cost[i][j][j] = 0;\n\t}\n}\n\nvoid initDp() {\n\tint i, j;\n\tfor (i = 0; i < r; i++) for (j = 0; j < n; j++) dp[i][j] = INF;\n}\n\nsigned main() {\n\tint i, j, k, l;\n\t\n\twhile (cin >> n >> m) {\n\t\tif (!n) break;\n\t\tinitCost();\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tint s, d, c; char type;\n\t\t\tcin >> s >> d >> c >> type;\n\t\t\ts--; d--;\n\t\t\tif (type == 'L') {\n\t\t\t\tcost[0][s][d] = c;\n\t\t\t\tcost[0][d][s] = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcost[1][s][d] = c;\n\t\t\t\tcost[1][d][s] = c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> r;\n\t\tfor (i = 0; i < r; i++) { cin >> z[i]; z[i]--; }\n\t\t\n\t\tfor (i = 0; i < 2; i++)\n\t\t\tfor (l = 0; l < n; l++)\n\t\t\t\tfor (j = 0; j < n; j++)\n\t\t\t\t\tfor (k = 0; k < n; k++)\n\t\t\t\t\t\tchmin(cost[i][j][k], cost[i][j][l] + cost[i][l][k]);\n\t\t\n\t\tinitDp();\n\t\tdp[0][z[0]] = 0;\n\t\tfor (i = 0; i < r - 1; i++) {\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t//???z[i]???(???)???z[i+1]\n\t\t\t\tchmin(dp[i + 1][j], dp[i][j] + cost[0][z[i]][z[i + 1]]);\n\t\t\t\tfor (k = 0; k < n; k++) {\n\t\t\t\t\t//???z[i]???j???(???)???k???z[i+1]\n\t\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost[0][z[i]][j] + cost[1][j][k] + cost[0][k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor (i = 0; i < n; i++) chmin(ans, dp[r - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n#include <tuple>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define int long long\ntypedef pair<int, int> p;\nconst int INF = 1e16;\n\nint dp[1001][201];\n\nint ld[201][201];\nint sd[201][201];\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\trep(i, 201)rep(j, 201) {\n\t\t\tld[i][j] = sd[i][j] = INF;\n\t\t}\n\t\trep(i, 1001)rep(j, 201) {\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--; y--;\n\t\t\tif (s == 'S') {\n\t\t\t\tsd[y][x] = sd[x][y] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld[y][x] = ld[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tdp[0][z[0]] = 0;\n\t\trep(i, r-1) {\n\t\t\trep(s, n) {\n\t\t\t\t//z[i]テ」ツ?凝」ツつ越[i+1]テ」ツ?ク\n\t\t\t\t//ティツ按ケテ」ツ?ョテ、ツスツ催ァツスツョテ」ツ?茎\n\t\t\t\ttypedef tuple<int, int, int> p;\n\t\t\t\tint me[201][201];\n\t\t\t\trep(i, 201)rep(j, 201) {\n\t\t\t\t\tme[i][j] = INF;\n\t\t\t\t}\n\t\t\t\tpriority_queue<p,vector<p>,greater<p>> q;\n\t\t\t\tq.push(p(dp[i][s], z[i], s));\n\t\t\t\tme[z[i]][s] = dp[i][s];\n\t\t\t\twhile (q.size()) {\n\t\t\t\t\tint cost = get<0>(q.top());\n\t\t\t\t\tint nw = get<1>(q.top());\n\t\t\t\t\tint sh = get<2>(q.top());\n\t\t\t\t\tq.pop();\n\t\t\t\t\tif (me[nw][sh] < cost)continue;\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tif (me[j][sh] > ld[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\tme[j][sh] = ld[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\tq.push(p(me[j][sh], j, sh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sh == nw) {\n\t\t\t\t\t\t\tif (me[j][j] > sd[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\t\tme[j][j] = sd[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\t\tq.push(p(me[j][j], j, j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(sh, n) {\n\t\t\t\t\tdp[i + 1][sh] = min(dp[i + 1][sh], me[z[i + 1]][sh]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(s, n) {\n\t\t\tans = min(ans, dp[r - 1][s]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n#define MAXN 205\n#define MAXR 1005\n#define MAXM 10005\nint N,M,R;\nint S[MAXN][MAXN],L[MAXN][MAXN];\nint task[MAXR];\nint dp[MAXR][MAXN];\nint main()\n{\n\twhile(1)\n\t{\n\t\tscanf(\"%d%d\",&N,&M);\n\t\tif(!N&&!M)break;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tS[i][j]=L[i][j]=1000000;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tS[i][i]=L[i][i]=0;\n\t\tfor(int i=1;i<=M;i++)\n\t\t{\n\t\t\tint a,b,t;char s[3];\n\t\t\tscanf(\"%d%d%d%s\",&a,&b,&t,s);\n\t\t\tif(s[0]=='S')\n\t\t\t{\n\t\t\t\tS[a][b]=min(S[a][b],t);\n\t\t\t\tS[b][a]=min(S[b][a],t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[a][b]=min(L[a][b],t);\n\t\t\t\tL[b][a]=min(L[b][a],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=1;k<=N;k++)\n\t\t\tfor(int i=1;i<=N;i++)\n\t\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\t{\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(int i=1;i<=R;i++)\n\t\t\tscanf(\"%d\",task+i);\n\t\tfor(int i=1;i<=R;i++)\n\t\t\tfor(int j=1;j<=N;j++)\n\t\t\t\tdp[i][j]=1000000;\n\t\tdp[1][task[1]]=0;\n\t\tfor(int i=2;i<=R;i++)//the Captain position\n\t\t\tfor(int j=1;j<=N;j++)//the Ship position\n\t\t\t{\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+L[task[i-1]][task[i]]);\n\t\t\t\tfor(int k=1;k<=N;k++)\n\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+L[task[i-1]][j]+S[j][k]+L[k][task[i]]);\n\t\t\t}\n\t\tint ans=0x7FFFFFFF;\n\t\tfor(int i=1;i<=N;i++)\n\t\t\tans=min(ans,dp[R][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M , N) {\n\t\tvvi ldist(N, vi(N, INF));\n\t\tvvi sdist(N, vi(N, INF));\n\t\tint x, y, t;\n\t\tchar sl;\n\t\tREP(i, M) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif(sl == 'L') {\n\t\t\t\tldist[x-1][y-1] = min(ldist[x-1][y-1], t);\n\t\t\t\tldist[y-1][x-1] = min(ldist[y-1][x-1], t);\n\t\t\t}\n\t\t\tif(sl == 'S') {\n\t\t\t\tsdist[x-1][y-1] = min(sdist[x-1][y-1], t);\n\t\t\t\tsdist[y-1][x-1] = min(sdist[y-1][x-1], t);\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tldist[i][i] = sdist[i][i] = 0;\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tldist[j][k] = min(ldist[j][k], ldist[j][i] + ldist[i][k]);\n\t\t\t\t\tsdist[j][k] = min(sdist[j][k], sdist[j][i] + sdist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvi z(R);\n\t\tREP(i, R) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tvvi cost(R, vi(N, INF));\n\t\tREP(i, R) {\n\t\t\tif(i == 0) {\n\t\t\t\tcost[0][z[0]] = 0;\n\t\t\t} else {\n\t\t\t\tint fr = z[i-1];\n\t\t\t\tint to = z[i];\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tcost[i][k] = min(cost[i][k], cost[i-1][j]+ldist[fr][j]+sdist[j][k]+ldist[k][to]);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][j]+ldist[fr][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, cost[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        cout << __LINE__ << endl;\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct E{\n  int d,t;\n  bool s;\n};\n\nstruct S{\n  int t,x,p,b;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    vector<E> e[201];\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      E a={y,t,sl=='S'};\n      e[x].push_back(a);\n      E b={x,t,sl=='S'};\n      e[y].push_back(b);\n    }\n    int r;\n    cin>>r;\n    int z[1000];\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n    }\n    priority_queue<S> que;\n    S is={0,0,z[0],z[0]};\n    que.push(is);\n    int p[201][201]={{}};\n    fill(p[0],p[201],false);\n    for(;;){\n      S c=que.top();\n      if(c.x==r-1)break;\n      que.pop();\n      if(p[c.p][c.b]>=c.x+1)continue;\n      p[c.p][c.b]=c.x+1;\n      for(int i=0;i<e[c.p].size();i++){\n\tE ce=e[c.p][i];\n\tif(!ce.s||c.b==c.p){\n\t  S n={c.t+ce.t,c.x+(ce.d==z[c.x+1]),ce.d,ce.s?ce.d:c.b};\n\t  que.push(n);\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 100000000\n#define MOD 1000000007\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\ntypedef int COST;\nstruct Path\n{\n\tint from;\n\tint to;\n\tCOST cost;\n\tCOST capacity;\n\tPath(int from = 0, int to = 0, COST cost = 0, COST capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n, m);\n\t\tif (!(n | m)){ break; }\n\n\n\t\t// read\n\t\tvevector<int> landMap(n, n, INF), seaMap(n, n, INF);\n\t\tREP(_, n) { landMap[_][_] = seaMap[_][_] = 0; }\n\t\tREP(_, m)\n\t\t{\n\t\t\tREAD(int, x, y, t); READ(char, sl); x--; y--;\n\t\t\tif (sl == 'S') { seaMap[x][y] = seaMap[y][x] = min(seaMap[x][y], t); }\n\t\t\telse { landMap[x][y] = landMap[y][x] = min(landMap[x][y], t); }\n\t\t}\n\n\t\t// make routemap わーしゃるふろいどとどっちはやい？\n\t\tvevector<Path> landGraph(n, 0), seaGraph(n, 0);\n\t\tREP(x, n) REP(y, n){\n\t\t\tif (landMap[x][y] != INF) { landGraph[x].push_back(Path(x, y, landMap[x][y])); }\n\t\t\tif (seaMap[x][y] != INF) { seaGraph[x].push_back(Path(x, y, seaMap[x][y])); }\n\t\t}\n\n\t\tlandMap.clear();\n\t\tseaMap.clear();\n\t\tREP(i, n)\n\t\t{\n\t\t\tlandMap.push_back(dijkstra(landGraph, i).first);\n\t\t\tseaMap.push_back(dijkstra(seaGraph, i).first);\n\t\t}\n\n\t\t// route map できた\n\t\tREAD(int, R);\n\t\tvector<int> r = read<int>(R);\n\n\t\t// dp[i][j] 船をjにおいてi番目の町にいるよ。\n\t\tvevector<int> dp(R, n, INF / 10);\n\t\t\n\t\tdp[0][r[0] - 1] = 0; // 初期値\n\t\tFOR(i, 1, R) // 最後の町まで行く\n\t\t{\n\t\t\tint cur = r[i - 1] - 1, next = r[i] - 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\t// 船をjにおいたまま。\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + landMap[cur][next]); // 陸路のみ\n\n\t\t\t\t// 船をkに移動してから行く。\n\t\t\t\tREP(k, n)\n\t\t\t\t{\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + landMap[cur][j] + seaMap[j][k] + landMap[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = *min_element(allof(dp[R - 1]));\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "                            #include <bits/stdc++.h>\n                            #include<iostream>\n                            #include<cstdio>\n                            #include<vector>\n                            #include<queue>\n                            #include<map>\n                            #include<cstring>\n                            #include<string>\n                            #include <math.h>\n                            #include<algorithm>\n                        //    #include <boost/multiprecision/cpp_int.hpp>\n                            #include<functional>\n                     #define int long long\n                            #define inf  1000000007\n                            #define pa pair<int,int>\n                            #define ll long long\n                            #define pal pair<double,pa>\n                            #define ppa pair<pa,int>\n                            #define ppap pair<int,pa>\n                            #define ssa pair<string,int>\n                            #define  mp make_pair\n                            #define  pb push_back\n                            #define EPS (1e-10)\n                            #define equals(a,b) (fabs((a)-(b))<EPS)\n                     \n                            using namespace std;\n                     //priority_queue<int, vector<int>, greater<int> > que;\n                            class Point{\n                            \tpublic:\n                            \tdouble x,y;\n                            \tPoint(double x=0,double y=0):x(x),y(y) {}\n                            \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                            \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                            \tPoint operator * (double a) {return Point(x*a,y*a);}\n                            \tPoint operator / (double a) {return Point(x/a,y/a);}\n                            \tdouble absv() {return sqrt(norm());}\n                            \tdouble norm() {return x*x+y*y;}\n                            \tbool operator < (const Point &p) const{\n                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                            \t}\n                            \tbool operator == (const Point &p) const{\n                            \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                            \t}\n                            };\n                            typedef Point Vector;\n                     \n                            struct Segment{\n                            Point p1,p2;\n                            };\n                     \n                        double hen(Vector a){\n                        if(fabs(a.x)<EPS && a.y>0) return acos(0);\n                        else if(fabs(a.x)<EPS && a.y<0) return 3*acos(0);\n                        else if(fabs(a.y)<EPS && a.x<0) return 2*acos(0);\n                        else if(fabs(a.y)<EPS && a.x>0) return 0.0;\n                        else if(a.y>0) return acos(a.x/a.absv());\n                        else return 2*acos(0)+acos(-a.x/a.absv());\n                     \n                        }\n                     \n                string itos( int i ) {\n                ostringstream s ;\n                s << i ;\n                return s.str() ;\n                }\n                 \n                int gcd(int v,int b){\n                \tif(v>b) return gcd(b,v);\n                \tif(v==b) return b;\n                \tif(b%v==0) return v;\n                \treturn gcd(v,b%v);\n                }\n                            double dot(Vector a,Vector b){\n                            \treturn a.x*b.x+a.y*b.y;\n                            }\n                            double cross(Vector a,Vector b){\n                            \treturn a.x*b.y-a.y*b.x;\n                            }\n                        \n                double distans(double x1,double y1,double x2,double y2){\n                \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                \treturn sqrt(rr);\n                \t\n                }\n                /*}\nint pr[100010];\n//int inv[100010];\n \nint beki(int wa,int rr){\n\tif(rr==0) return 1ll;\n\tif(rr==1) return wa;\n\tif(rr%2==1) return (beki(wa,rr-1)*wa)%inf;\n\tint zx=beki(wa,rr/2);\n\treturn (zx*zx)%inf;\n}\n  \nvoid gya(){\n\tpr[0]=1;\n\tfor(int i=1;i<100010;i++){\n\t\tpr[i]=(pr[i-1]*i)%inf;\n\t}\n\tfor(int i=0;i<100010;i++) inv[i]=beki(pr[i],inf-2);\n\t\n}\n\n*/\n\n                         //----------------kokomade tenpure------------\nint dp[1010][300]={0};\nint L[201][201],S[201][201];\nsigned main(){\n\n\t\n\n\tint n,m;\n\twhile(1){\n\t\tcin>>n>>m;\n\t\tif(n==0) return 0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tL[i][j]=inf;\n\t\t\t\tS[i][j]=inf;\n\t\t\t}\n\t\t\tL[i][i]=0;\n\t\t\tS[i][i]=0;\n\t\t\t\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tif(s==\"S\"){\n\t\t\t\tS[x][y]=min(S[x][y],t);\n\t\t\t\tS[y][x]=min(S[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tL[x][y]=min(L[x][y],t);\n\t\t\t\tL[y][x]=min(L[y][x],t);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tfor(int k=1;k<=n;k++)for(int i=1;i<=n;i++)for(int j=1;j<=n;j++){\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t}\n\t\tfor(int i=0;i<1010;i++)for(int j=0;j<300;j++)dp[i][j]=inf;\n\t\tvector<int>ve;\n\t\tve.pb(-1);\n\t\tint r;\n\t\tcin>>r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint rt;\n\t\t\tcin>>rt;\n\t\t\tve.pb(rt);\n\t\t}\n\t\tdp[0][ve[1]]=0;\n\t\t\n\t\tfor(int i=1;i<=r-1;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t//\t\tif(dp[i-1][j]>=inf) continue;\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tif(k!=j)\tdp[i][j]=min(dp[i][j],dp[i-1][k]+L[ve[i]][k]+S[k][j]+L[j][ve[i+1]]);\n\t\t\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][k]+L[ve[i]][ve[i+1]]);\n\t\t\t\t}\n\t//\t\t\tif(n==2 &&m==1)\tcout<<\"dp \"<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n\t\t\t}\n\t\t}\n\tint ans=inf;\n\t\tfor(int i=1;i<=n;i++) ans=min(ans,dp[r-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e6\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        if(i != next){\n          dp[r][next] = min(dp[r][next], dp[r-1][i] + G2[i][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define inf 1e8\n\nusing namespace std;\n\nint n, m, s[202][202], h[202][202], dp[202][202], l[202];\n\nint main()\n{\n\tint i, j, k, x, y, z;\n\tchar c[2];\n\twhile (scanf(\"%d%d\", &n, &m) && (n || m))\n\t{\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tfill(h[i], h[i] + n + 1, inf);\n\t\t\tfill(s[i], s[i] + n + 1, inf);\n\t\t\tfill(dp[i], dp[i] + n + 1, inf);\n\t\t\th[i][i] = s[i][i] = 0;\n\t\t}\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%s\", &x, &y, &z, c);\n\t\t\tif (c[0] == 'L')\n\t\t\t{\n\t\t\t\th[y][x] = min(h[y][x], z);\n\t\t\t\th[x][y] = h[y][x];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[y][x] = min(s[y][x], z);\n\t\t\t\ts[x][y] = s[y][x];\n\t\t\t}\n\t\t}\n\t\tfor (k = 1; k <= n; k++)\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t\t{\n\t\t\t\t\th[i][j] = min(h[i][j], h[i][k] + h[k][j]);\n\t\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++)\n\t\t\tscanf(\"%d\", &l[i]);\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tdp[0][j] = s[l[0]][j] + h[j][l[0]];\n\t\tfor (i = 1; i < m; i++)\n\t\t{\n\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tfor (k = 1; k <= n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + h[l[i-1]][j] + s[j][k] + h[k][l[i]]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][k] + h[l[i-1]][l[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *min_element(dp[m-1] + 1, dp[m-1] + n + 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nll dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  vector<vector<int> > used(n,vector<int>(r,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1))),D[ship][idx+1]=ncost;\n\n    for(int i=0;i<n;i++){\n\tncost=cost+G[pos][ship][0]+G[ship][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1))),D[i][idx+1]=ncost;\n      }\n  }\n  assert(0);\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum\n{\n    MAX_V = 200 + 10, MAX_Z = 1000 + 50\n};\n\nconst long long INF = 1000000000000;\nlong long dp[MAX_Z][MAX_V];\nlong long SG[MAX_V][MAX_V], LG[MAX_V][MAX_V];\nint rt[MAX_Z], rtl;\nint n, m;\n\nvoid floyd()\n{\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = min(SG[i][j], SG[i][k] + SG[k][j]);\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                LG[i][j] = min(LG[i][j], LG[i][k] + LG[k][j]);\n    for(int i = 1; i <= n; i++)\n        LG[i][i] = SG[i][i] = 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n+m)\n    {\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = LG[i][j] = INF;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y;\n            long long cs;\n            char tp;\n            scanf(\"%d %d %lld %c\", &x, &y, &cs, &tp);\n            if(tp == 'S')\n            {\n                SG[x][y] = min(SG[x][y], cs);\n                SG[y][x] = min(SG[y][x], cs);\n            }\n            else\n            {\n                LG[x][y] = min(LG[x][y], cs);\n                LG[y][x] = min(LG[y][x], cs);\n            }\n        }\n        scanf(\"%d\", &rtl);\n        for(int i = 1; i <= rtl; i++)\n            scanf(\"%d\", &rt[i]);\n\n        floyd();\n        for(int i = 1; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                dp[i][j] = INF;\n\n        dp[1][rt[1]] = 0;\n        for(int i = 2; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                for(int k = 1; k <= n; k++)\n                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[k][rt[i - 1]] + SG[k][j] + LG[j][rt[i]]);\n\n        long long ans = *min_element(dp[rtl] + 1, dp[rtl] + n + 1);\n        if(ans == INF) printf(\"-1\\n\");\n        else printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tif(j == k) continue;\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < r; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[r-1], dp[r-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nint main(void){\n    int n,m;\n    while(cin>>n>>m,n){\n        vvi riku(n,vi(n,99999999));\n        vvi kai(n,vi(n,99999999));\n        rep(i,n){\n            riku[i][i]=0;\n            kai[i][i]=0;\n        }\n        int x,y,t;\n        char sl;\n        rep(i,m){\n            cin>>x>>y>>t>>sl;\n            if(sl=='L'){\n                riku[x-1][y-1]=t;\n                riku[y-1][x-1]=t;\n            }else{\n                kai[x-1][y-1]=t;\n                kai[y-1][x-1]=t;\n            }\n        }\n        int r;\n        cin>>r;\n        vvi dp(r+1,vi(n,99999999));\n        vi jun(r,0);\n        rep(i,r){\n            cin>>jun[i];\n            jun[i]--;\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            riku[i][j]=min(riku[i][j],riku[i][k]+riku[k][j]);\n            kai[i][j]=min(kai[i][j],kai[i][k]+kai[k][j]);\n        }\n        dp[1][jun[0]]=0;\n        for(int i=1;i<r;i++)rep(j,n)rep(k,n){\n            if(j!=k) dp[i+1][k]=min(dp[i+1][k],dp[i][j]+riku[jun[i-1]][j]+kai[j][k]+riku[k][jun[i]]);\n            else dp[i+1][k]=min(dp[i+1][k],dp[i][j]+riku[jun[i-1]][jun[i]]);\n        }\n        cout<<*min_element(dp[r].begin(),dp[r].end())<<endl;\n    }\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n, m; cin >> n >> m;\n    if(n == 0) break;\n    vvi d1(n, vi(n, INF)), d2(n, vi(n, INF));\n    for(int i=0;i<n;++i) {\n      d1[i][i] = 0;\n      d2[i][i] = 0;\n    }\n    for(int i=0;i<m;++i) {\n      int x, y, t; char c; cin >> x >> y >> t >> c;\n      x--; y--;\n      if(c == 'L') {\n        d1[x][y] = t;\n        d1[y][x] = t;\n      } else {\n        d2[x][y] = t;\n        d2[y][x] = t;\n      }\n    }\n    for(int k=0;k<n;++k) {\n      for(int i=0;i<n;++i) {\n        for(int j=0;j<n;++j) {\n          if(d1[i][k] == INF || d1[k][j] == INF) continue;\n          d1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n        }\n      }\n    }\n    for(int k=0;k<n;++k) {\n      for(int i=0;i<n;++i) {\n        for(int j=0;j<n;++j) {\n          if(d2[i][k] == INF || d2[k][j] == INF) continue;\n          d2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n        }\n      }\n    }\n    int r; cin >> r;\n    vector<int> z(r);\n    for(int i=0;i<r;++i) {\n      cin >> z[i];\n      z[i]--;\n    }\n    vvi dp(r, vi(n, INF));\n    dp[0][z[0]] = 0;\n    for(int i=0;i<r-1;++i) {\n      for(int j=0;j<n;++j) {\n        if(dp[i][j] != INF && d1[z[i]][z[i+1]]) {\n          dp[i+1][j] = min(dp[i+1][j], dp[i][j] + d1[z[i]][z[i+1]]);\n        }\n        for(int k=0;k<n;++k) {\n          if(dp[i][j] == INF || d1[z[i]][j] == INF ||\n            d2[j][k] == INF || d1[k][z[i+1]] == INF) continue;\n          dp[i+1][k] = min(dp[i+1][k], dp[i][j] + d1[z[i]][j] + d2[j][k] + d1[k][z[i+1]]);\n        }\n      }\n    }\n    int mi = INF;\n    for(int i=0;i<n;++i) {\n      mi = min(mi, dp[r-1][i]);\n    }\n    cout << mi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//-------------include\n#include<cstdio>\n#include<string>\n#include<iostream>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<cmath>\n#include<cstdlib>\n#include<climits>\n#include<vector>\n#include<list>\n#include<deque>\n#include<functional>\n#include<sstream>\n\n//-------------define\n#define ALL(a)  (a).begin(),(a).end()\n#define PB push_back\n#define MP make_pair\n#define SORT(c) sort((c).begin(),(c).end())\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define fi first\n#define se second\n#define INF 1 << 28\n\n//-------------namespace\nusing namespace std;\n\n//-------------inline\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//-------------typedef\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\n\n//-------------var\nint dx[]={0,-1,0,1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};\n\nint l[201][201];\nint s[201][201];\nint dp[1001][201];\n\nint main()\n{\n  int n,m;\n  while(cin >> n >> m,n){\n    for(int i=0;i<200;i++){\n      s[i][i] = l[i][i] = 0;\n      for(int j=0;j<200;j++){\n        if(i!=j)s[i][j] = l[i][j] = INF;\n      }\n    }\n\n    for(int i=0;i<1000;i++){\n      for(int j=0;j<200;j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    for(int i=0;i<m;i++){\n      int a,b,t;\n      char p;\n      cin >> a >> b >> t >> p;\n      a--;b--;\n      if(p=='S'){\n        s[a][b] = s[b][a] = t;\n      }else{\n        l[a][b] = l[b][a] = t;\n      }\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n          l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n        }\n      }\n    }\n\n    int r;\n    cin >> r;\n\n    vi v(r);\n    for(int i=0;i<r;i++){\n      cin >> v[i];\n      v[i]--;\n    }\n\n    dp[0][v[0]] = 0;\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][k] = min(dp[i][k], dp[i-1][j] + l[v[i-1]][j] + s[j][k] + l[k][v[i]]);\n        }\n        dp[i][j] = min(dp[i][j], dp[i-1][j] + l[v[i-1]][v[i]]);\n      }\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans, dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n\nusing namespace std;\n\n#define mod 1000000007\n\nint n, m;\nlong long int rikuro[201][201], kairo[201][201];\n\nint solve(vector<int> z, int r)\n{\n\tvector<vector<long long int> > result(1001, vector<long long int>(201, mod));\n\tresult[0][z[0]] = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tresult[0][i] = min(result[0][i], kairo[z[0]][i] + rikuro[i][z[0]]);\n\t}\n\tfor(int i = 0; i < r - 1; i++){\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tresult[i + 1][j] = min(result[i + 1][j], result[i][j] + rikuro[z[i]][z[i + 1]]);\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tresult[i + 1][k] = min(result[i + 1][k], result[i][j] + rikuro[z[i]][j] + kairo[j][k] + rikuro[k][z[i + 1]]);\n\t\t\t}\n\t\t}\n\t}\n\tlong long int ans = mod;\n\tfor(int i = 0; i < n; i++){\n\t\tans = min(ans, result[r - 1][i]);\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\twhile(1){\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\trikuro[i][j] = mod;\n\t\t\t\tkairo[i][j] = mod;\n\t\t\t}\n\t\t\trikuro[i][i] = 0;\n\t\t\tkairo[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint x, y;\n\t\t\tlong long int t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(sl == 'S'){\n\t\t\t\tkairo[x][y] = min(kairo[x][y], t);\n\t\t\t\tkairo[y][x] = min(kairo[y][x], t);\n\t\t\t} else {\n\t\t\t\trikuro[x][y] = min(rikuro[x][y], t);\n\t\t\t\trikuro[y][x] = min(rikuro[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tkairo[i][j] = min(kairo[i][j], kairo[i][k] + kairo[k][j]);\n\t\t\t\t\trikuro[i][j] = min(rikuro[i][j], rikuro[i][k] + rikuro[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z;\n\t\tfor(int i = 0; i < r; i++){\n\t\t\tint tmpz;\n\t\t\tcin >> tmpz;\n\t\t\ttmpz--;\n\t\t\tz.push_back(tmpz);\n\t\t}\n\t\tcout << solve(z, r) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct CWW{CWW(){ios::sync_with_stdio(false);cin.tie(0);}}cww;\ntypedef long long LL;\nconst LL INF=1e16;\ntypedef vector<LL> V;\ntypedef vector<V> VV;\nint main(){\n    for(int N,M;cin>>N>>M,N+M;){\n\tVV riku(N,V(N,INF)),umi(N,V(N,INF));\n\tfor(int i=0;i<N;i++)riku[i][i]=umi[i][i]=0;\n\twhile(M--){\n\t    int a,b;LL t;string s;\n\t    cin>>a>>b>>t>>s;\n\t    a--;b--;\n\t    if(s==\"L\")riku[a][b]=riku[b][a]=t;\n\t    else umi[a][b]=umi[b][a]=t;\n\t}\n\tfor(int k=0;k<N;k++)\n\t    for(int i=0;i<N;i++)\n\t\tfor(int j=0;j<N;j++){\n\t\t    riku[i][j]=min(riku[i][j],riku[i][k]+riku[k][j]);\t    \n\t\t    umi[i][j]=min(umi[i][j],umi[i][k]+umi[k][j]);\n\t\t}\n\tint R;\n\tcin>>R;\n\tvector<int> z(R);\n\tfor(auto &it:z){\n\t    cin>>it;it--;\n\t}\n\tVV dp(R,V(N,INF));\n\tdp[0][z[0]]=0;\n\tfor(int i=1;i<R;i++){\n\t    for(int j=0;j<N;j++){\n\t\tdp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n\t\tfor(int k=0;k<N;k++)\n\t\t    dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+umi[k][j]+riku[j][z[i]]);\n\t    }\n\t}\n\tLL res=INF;\n\tfor(auto &it:dp.back())res=min(res,it);\n\tcout<<res<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int inf=500000000;\nint wf_l[200][200],wf_s[200][200],memo[1000][200];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\twf_l[i][j]=wf_s[i][j]=(i==j?0:inf);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\tscanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n\t\t\tx--;\ty--;\n\t\t\tif(sl=='S')\twf_s[x][y]=wf_s[y][x]=min(wf_s[x][y],t);\n\t\t\tif(sl=='L')\twf_l[x][y]=wf_l[y][x]=min(wf_l[x][y],t);\n\t\t}\n\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf_l[i][j]=min(wf_l[i][j],wf_l[i][k]+wf_l[k][j]);\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf_s[i][j]=min(wf_s[i][j],wf_s[i][k]+wf_s[k][j]);\n\n\t\tint r,from,to;\tscanf(\"%d%d\",&r,&from);\tfrom--;\n\t\tfor(int j=0;j<n;j++)\tmemo[0][j]=(j==from?0:inf);\n\t\tfor(int i=1;i<r;i++){\n\t\t\tscanf(\"%d\",&to);\tto--;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tmemo[i][j]=inf;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(j==k)\tmemo[i][j]=min(memo[i][j],memo[i-1][k]+wf_l[from][to]);\n\t\t\t\t\tmemo[i][j]=min(memo[i][j],memo[i-1][k]+wf_l[from][k]+wf_s[k][j]+wf_l[j][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfrom=to;\n\t\t}\n\n\t\tint tmin=inf;\n\t\tfor(int j=0;j<n;j++)\ttmin=min(tmin,memo[r-1][j]);\n\t\tprintf(\"%d\\n\",tmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n \ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n \n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n \nconst LL INF=100000000000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n \nint main(){\n    while(1){\n        int n,m;\n        static LL ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static LL sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n         \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)break;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n         \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n         \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n         \n        int r,z;\n        static LL dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n         \n        scanf(\"%d\",&r);\n        scanf(\"%d\",&z);\n        dp[0][z]=0;\n         \n        LL ret=INF;\n        rep1(i,r-1){\n            scanf(\"%d\",&z);\n            rep1(j,n){\n                if(ld[j][z]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+sd[k][j]);\n                    }\n                    if(i!=r-1){\n                        if(dp[i][j]!=INF)dp[i][j]+=2*ld[j][z];\n                    }\n                    else{\n                        dp[i][j]+=ld[j][z];\n                        ret=min(ret,dp[i][j]);\n                    }\n                }\n            }\n        }\n         \n        printf(\"%I64d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdint.h>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nconst int INF = 100000000;\n//町,村の数\nint n;\n//道の数\nint m;\n//集配先の数\nint R;\n\n//集配順序\nint z[1003];\n\ntypedef pair<int,int> P;\ntypedef pair<pair<int,int>,pair<int,int> > PP;\n\nstruct edge\n{\n\tint to;\n\t//陸なら1\n\tint mode;\n\tint cost;\n\tedge(int to,int mode,int cost) {\n\t\tthis->to = to;\n\t\tthis->mode = mode;\n\t\tthis->cost = cost;\n\t}\n\n};\n\nvector<edge> G[207];\nint dist[203][203][1003];\n\nint dijkstra() {\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tfor (int j = 0; j < 203; j++)\n\t\t{\n\t\t\tfill(dist[i][j],dist[i][j]+1003,INF);\n\t\t}\n\t}\n\tpriority_queue<PP,vector<PP>, greater<PP> > que;\n\n\tdist[0][0][0]=0;\n\n\tque.push(PP(P(0,0),P(0,0)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\n\t\tint cost = pp.first.first;\n\t\tint v=pp.first.second;\n\t\tint u=pp.second.first;\n\t\tint index = pp.second.second;\n\t\t\n\n\t\tif(z[index] == v) {\n\t\t\tdist[v][u][index+1]=dist[v][u][index];\n\t\t\tindex++;\n\t\t}\n\n\t\tif(index == R) {\n\t\t\t//dist[v][u][index+1]=dist[v][u][index];\n\t\t\tbreak;\n\t\t}\n\n\t\tif(dist[v][u][index] < cost) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t//printf(\"[debug] %d %d %d %d\\n\",cost,v,u,index);\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\t//printf(\"        %d %d %d\\n\",e.to,e.mode,e.cost);\n\n\t\t\t//船を使う\n\t\t\tif(u==v && e.mode == 0) {\n\t\t\t\t//printf(\"%d,%d\\n\",dist[e.to][e.to][index],dist[v][u][index]);\n\t\t\t\tif(dist[e.to][e.to][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][e.to][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][e.to][index],e.to),P(e.to,index)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.mode == 1) {\n\t\t\t\tif(dist[e.to][u][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][u][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][u][index],e.to),P(u,index)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tint ans=INF;\n\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tans=min(ans,dist[z[R-1]][i][R-1]);\n\t} \n\n\treturn ans;\n\n\n}\n\n\nvoid solve() {\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint x,y,t;\n\t\tchar c;\n\t\t//x-y はコスト t で c によって結ばれている\n\t\t\n\t\tcin>>x>>y>>t>>c;\n\t\tx--;\n\t\ty--;\n\t\t\n\t\tG[x].push_back(edge(y,c=='L',t));\n\t\tG[y].push_back(edge(x,c=='L',t));\n\t}\n\n\tcin>>R;\n\n\tfor (int i = 0; i < R; i++)\n\t{\n\t\tcin>>z[i];\n\t\tz[i]--;\n\t}\n\n\tcout<<dijkstra()<<endl;\n\n}\n\nint main() {\n\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define ll long long\nusing namespace std;\n\nconst int N = 210;\nconst int M = 10010;\n\nint n,m,e_num,s,ans;\nint nxt[M*2],to[M*2],w[M*2],c[M*2],h[N],p[1010],dis[N][N][1010];\nbool in[N][N][1010];\n\nstruct Node {int x,y,k;};\n\nqueue<Node> q;\n \nint gi() {\n  int x=0,o=1; char ch=getchar();\n  while(ch!='-' && (ch<'0' || ch>'9')) ch=getchar();\n  if(ch=='-') o=-1,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return o*x;\n}\n\nvoid add(int x, int y, int z, int f) {\n  nxt[++e_num]=h[x],to[e_num]=y,w[e_num]=z,c[e_num]=f,h[x]=e_num;\n} \n\nvoid spfa() {\n  memset(dis,63,sizeof(dis));\n  dis[1][1][p[1]==1]=0,in[1][1][p[1]==1]=1,q.push((Node){1,1,p[1]==1});\n  while(!q.empty()) {\n    Node u=q.front();\n    int x=u.x,y=u.y,k=u.k;\n    in[x][y][k]=0,q.pop();\n    for(int i=h[x]; i; i=nxt[i]) {\n      int v=to[i];\n      if(c[i]==0) {\n\tif(v==p[k+1]) {\n\t  if(dis[x][y][k]+w[i]<dis[v][y][k+1]) {\n\t    dis[v][y][k+1]=dis[x][y][k]+w[i];\n\t    if(!in[v][y][k+1] && k+1!=s) in[v][y][k+1]=1,q.push((Node){v,y,k+1});\n\t  }\n\t}\n\telse {\n\t  if(dis[x][y][k]+w[i]<dis[v][y][k]) {\n\t    dis[v][y][k]=dis[x][y][k]+w[i];\n\t    if(!in[v][y][k] && k!=s) in[v][y][k]=1,q.push((Node){v,y,k});\n\t  }\n\t}\n      }\n      else if(x==y) {\n\tif(v==p[k+1]) {\n\t  if(dis[x][y][k]+w[i]<dis[v][v][k+1]) {\n\t    dis[v][v][k+1]=dis[x][y][k]+w[i];\n\t    if(!in[v][v][k+1] && k+1!=s) in[v][v][k+1]=1,q.push((Node){v,v,k+1}); \n\t  }\n\t}\n\telse {\n\t  if(dis[x][y][k]+w[i]<dis[v][v][k]) {\n\t    dis[v][v][k]=dis[x][y][k]+w[i];\n\t    if(!in[v][v][k] && k!=s) in[v][v][k]=1,q.push((Node){v,v,k});\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nvoid init() {\n  e_num=0;\n  memset(h,0,sizeof(h));\n  memset(p,0,sizeof(p));\n}\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) && n+m) {\n    init();\n    for(int i=1; i<=m; i++) {\n      int x=gi(),y=gi(),z=gi(); char ch;\n      scanf(\"%c\", &ch);\n      if(ch=='L') add(x,y,z,0),add(y,x,z,0);\n      else add(x,y,z,1),add(y,x,z,1);\n    }\n    s=gi(),ans=1<<30;\n    for(int i=1; i<=s; i++) p[i]=gi(); \n    spfa();\n    for(int i=1; i<=n; i++) {\n      ans=min(ans,dis[p[s]][i][s]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<utility>\n#include<vector>\n#include<queue>\n#define MAX_N 200\nusing namespace std;\ntypedef pair<int,int>p;\ntypedef struct node\n{\n\tint p,n,b,c;\n\tbool operator <(const node &a)const{ return c>a.c;};\n}node;\nvector<p> Sea[MAX_N],Land[MAX_N];\nint N,M,R,des[1000];\nint d[1005][205][205];\npriority_queue<node>Q;\n\nvoid f(node tmp,vector<p> edge,bool Boat)\n{\n\tnode ins;\n\tins.n=tmp.p==des[tmp.n]?tmp.n+1:tmp.n;\n\tfor(int i=0;i<edge.size();i++)\n\t{\n\t\tins.p=edge[i].first;\n\t\tins.b=Boat?edge[i].first:tmp.b;\n\t\tif(d[ins.n][ins.p][ins.b]>tmp.c+edge[i].second)\n\t\t{\n\t\t\tins.c=d[ins.n][ins.p][ins.b]=tmp.c+edge[i].second;\n\t\t\tQ.push(ins);\n\t\t}\n\t}\n}\n\nint dij()\n{\n\tfor(;!Q.empty();Q.pop());\n\tmemset(d,0x77,sizeof(d));\n\td[0][des[0]][des[0]]=0;\n\tnode tmp={des[0],1,des[0],0};\n\tQ.push(tmp);\n\tfor(;!Q.empty();)\n\t{\n\t\ttmp=Q.top();Q.pop();\n\t\tif(d[tmp.n][tmp.p][tmp.b]<tmp.c)continue;\n\t\tif(tmp.n==R-1&&tmp.p==des[tmp.n])return tmp.c;\n\t\tf(tmp,Land[tmp.p],0);\n\t\tif(tmp.b==tmp.p)f(tmp,Sea[tmp.p],1);\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tfor(int i=0;i<M;i++)\n\t\t{\n\t\t\tint x,y,s;\n\t\t\tchar t;\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&s,&t);\n\t\t\tif(t=='L')\n\t\t\t{\n\t\t\t\tLand[x].push_back(make_pair(y,s));\n\t\t\t\tLand[y].push_back(make_pair(x,s));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSea[x].push_back(make_pair(y,s));\n\t\t\t\tSea[y].push_back(make_pair(x,s));\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&R);\n\t\tfor(int i=0;i<R;i++)scanf(\"%d\",&des[i]);\n\t\tprintf(\"%d\\n\",dij());\n\t\tfor(int i=0;i<200;i++){Land[i].clear();Sea[i].clear();}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = (1<<28);\nint dp[1010][210];\n\nint main()\n{\n    \n    int n,m,x,y,t,r,z[1010],ans;\n    char sl;\n    int land[210][210],sea[210][210];\n    \n    while(cin >> n >> m,n!=0||m!=0){\n        \n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                land[i][j] = INF;\n                sea[i][j] = INF;\n            }\n            land[i][i] = 0;\n            sea[i][i] = 0;\n        }\n    \n        for(int i=0;i<m;i++){\n            cin >> x >> y >> t >> sl;\n            if(sl == 'L'){\n                land[x][y] = t;\n                land[y][x] = t;\n            }\n            else if(sl == 'S'){\n                sea[x][y] = t;\n                sea[y][x] = t;\n            }\n        }\n    \n        for(int i=1;i<=n;i++){\n            for(int j=1;j<=n;j++){\n                for(int k=1;k<=n;k++){\n                    land[j][k] = min(land[j][k],land[j][i]+land[i][k]);\n                    sea[j][k] = min(sea[j][k],sea[j][i]+sea[i][k]);\n                }\n            }\n        }\n    \n        cin >> r >> z[0];\n        fill_n(*dp,1010*210,INF);\n        dp[0][ z[0] ] = 0;\n        for(int i=1;i<r;i++){\n            cin >> z[i];\n            for(int j=1;j<=n;j++){\n                dp[i][j] = min(dp[i][j],dp[i-1][j]+land[ z[i-1] ][ z[i] ]);\n                for(int k=1;k<=n;k++){\n                    dp[i][k] = min(dp[i][k],dp[i-1][j]+land[ z[i-1] ][j]+sea[j][k]+land[k][ z[i] ]);\n               }\n            }\n        }\n    \n        ans = INF;\n        for(int i=1;i<=n;i++) ans = min(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int INF=123456789;\n\nint n,m;\nint R;\nint z[1000];\n\nint ld[200][200],sd[200][200];\n\nvector<int> island[200];\nint island_idx;\nint island_id[200];\n\nll dp[1001][200];\n\nvoid init()\n{\n    fill(ld[0],ld[200],INF);\n    fill(sd[0],sd[200],INF);\n    rep(i,200) island[i].clear();\n    island_idx=0;\n    fill(island_id,island_id+200,-1);\n    fill(dp[0],dp[1001],10000LL*INF);\n}\n\n\nint main()\n{\n    while(scanf(\" %d %d\",&n,&m),n)\n    {\n        init();\n\n        // input\n        rep(i,m)\n        {\n            int x,y,t;\n            char sl;\n            scanf(\" %d %d %d %c\",&x,&y,&t,&sl);\n            --x;\n            --y;\n            if(sl=='L') ld[x][y]=ld[y][x]=min(ld[x][y],t);\n            else sd[x][y]=sd[y][x]=min(sd[x][y],t);\n        }\n        scanf(\" %d\",&R);\n        rep(i,R)\n        {\n            scanf(\" %d\",&z[i]);\n            --z[i];\n        }\n\n        // Warshall-Floyd\n        rep(i,n)\n        {\n            ld[i][i]=0;\n            sd[i][i]=0;\n        }\n        rep(k,n)rep(i,n)rep(j,n)\n        {\n            ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n            sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n        }\n\n        // determine the island i-th town belongs\n        rep(i,n)\n        {\n            if(island_id[i]!=-1) continue;\n\n            island_id[i]=island_idx;\n            rep(j,n) if(ld[i][j]<INF) island_id[j]=island_idx;\n\n            ++island_idx;\n        }\n        rep(i,n) island[island_id[i]].pb(i);\n\n        // calc ans\n        dp[0][0]=0;\n        if(island_id[0]==island_id[z[0]]) dp[1][0] = min(dp[1][0], (ll)ld[0][z[0]]);\n        rep(i,island[island_id[z[0]]].size())\n        {\n            int nxt_boat_stop = island[island_id[z[0]]][i];\n            dp[1][nxt_boat_stop] = min(dp[1][nxt_boat_stop], (ll)sd[0][nxt_boat_stop]+ld[nxt_boat_stop][z[0]]);\n        }\n\n        for(int i=1; i<R; ++i)\n        {\n            int p_id=island_id[z[i-1]], c_id=island_id[z[i]];\n            if(p_id==c_id)\n            {\n                rep(j,island[p_id].size()) dp[i+1][j] = min(dp[i+1][j], dp[i][j]+ld[z[i-1]][z[i]]);\n            }\n            rep(j,island[p_id].size())rep(k,island[c_id].size())\n            {\n                int now_b=island[p_id][j], nx_b=island[c_id][k];\n                dp[i+1][nx_b] = min(dp[i+1][nx_b], dp[i][now_b]+ld[z[i-1]][now_b]+sd[now_b][nx_b]+ld[nx_b][z[i]]);\n            }\n        }\n\n        ll ans=10000LL*INF;\n        rep(i,n) ans=min(ans,dp[R][i]);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define size_of(a) (int)(a).size()\n#define allof(a) (a).begin(),(a).end()\n\ntypedef long long lint;\n\nint N, M, R, z[1010];\n\nlint cstL[222][222], cstS[222][222];\nlint dp[1010][222];\n\nvoid minUpdate(lint& a, lint b) {\n\ta = min(a, b);\n}\n\nvoid solve() {\t\n\tfor_(k,0,N) for_(i,0,N) for_(j,0,N) {\n\t\tminUpdate(cstL[i][j], cstL[i][k] + cstL[k][j]);\n\t\tminUpdate(cstS[i][j], cstS[i][k] + cstS[k][j]);\n\t}\n\t\n\tfor_(i,0,1010) for_(j,0,222) dp[i][j] = 1LL << 60;\n\tdp[0][z[0]] = 0;\n\t\n\tfor_(i,0,R-1) for_(j,0,N) {\n\t\tif (dp[i][j] >= 1LL << 60) continue;\n\t\t\n\t\tlint cc = cstL[z[i]][z[i + 1]];\n\t\tif (cc < 1LL << 60) minUpdate(dp[i + 1][j], dp[i][j] + cc);\n\t\t\n\t\tfor_(v,0,N) {\n\t\t\tlint c1 = cstL[z[i]][j];\n\t\t\tlint c2 = cstS[j][v];\n\t\t\tlint c3 = cstL[v][z[i + 1]];\n\t\t\t\n\t\t\tcc = c1 + c2 + c3;\n\t\t\tif (cc < 1LL << 60) minUpdate(dp[i+1][v], dp[i][j] + cc);\n\t\t}\n\t}\n\t\n\tlint ans = 1LL << 60;\n\tfor_(i,0,N) minUpdate(ans, dp[R-1][i]);\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N >> M, N) {\t\t\n\t\tfor_(i,0,N) for_(j,0,N) cstL[i][j] = cstS[i][j] = 1LL << 60;\n\t\tfor_(i,0,N) cstS[i][i] = cstL[i][i] = 0;\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t--x; --y;\n\t\t\tif (s == 'L') cstL[x][y] = cstL[y][x] = t;\n\t\t\telse cstS[x][y] = cstS[y][x] = t;\n\t\t}\n\t\t\n\t\tcin >> R;\n\t\t\n\t\tfor_(i,0,R) {\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\t\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[50][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\nbool reset[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<200;j++){\n\t\t\tfor(int k=0;k<200;k++){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(reset,false,sizeof(reset));\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(0,0))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\tres=min(res,nc);\n\t\t\tcontinue;\n\t\t}\n\t\tif(now==rt[np]){\n\t\t\tnp++;\n\t\t\tif(reset[np]==false){\n\t\t\t\tfor(int i=0;i<200;i++){\n\t\t\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\t\t\tcost[np%20][i][j]=INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treset[np]=true;\n\t\t\t}\n\t\t}\n\t\tif(cost[np%20][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np%20][e.t][ns]){\n\t\t\t\tcost[np%20][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np%20][e.t][e.t]){\n\t\t\t\t\tcost[np%20][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) x.begin(),x.end()\n#define dbg(x) cout<<#x<<\":\"<<x<<endl\n#define int long long\n#define MOD 1e9+7\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nstruct WF{\n  int v;\n  vector<vector<int> > d;\n  const int INF = 1LL<<60; \n  WF(int n):\n    v(n),\n    d(n,vector<int>(n))\n  {\n    for(int i=0;i<v;i++){\n\t for(int j=0;j<v;j++){\n\t   if(i==j)d[i][j]=0;\n\t   else d[i][j]=INF;\n\t }\n    }\n  }\n\n  void add(int s,int t,int cost){\n    d[s][t]=min(d[s][t],cost);\n  }\n\n  void wf(){\n    for(int k=0;k<v;k++){\n\t for(int i=0;i<v;i++){\n\t   for(int j=0;j<v;j++){\n\t\tif(d[i][k]!=INF&&d[k][j]!=INF)\n\t\t  d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t   }\n\t }\n    }\n  }\n\n  int get(int i,int j){\n    return d[i][j];\n  }\n};\n\nsigned main(){\n  int n,m;\n  const int INF=1LL<<60;\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    WF land(n),sea(n);\n    for(int i=0;i<m;i++){\n\t int x,y,t;\n\t char s;\n\t cin>>x>>y>>t>>s;\n\t x--,y--;\n\t if(s=='L'){\n\t   land.add(x,y,t);\n\t   land.add(y,x,t);\n\t }else{\n\t   sea.add(x,y,t);\n\t   sea.add(y,x,t);\n\t }\n    }\n    land.wf();\n    sea.wf();\n  \n    int r;\n    cin>>r;\n    vector<int> z(r);\n    for(int i=0;i<r;i++){\n\t cin>>z[i];\n\t z[i]--;\n    }\n\n    vector<vector<int> > dp(r,vector<int>(n,INF));\n    dp[0][z[0]]=0;\n    for(int i=0;i<r-1;i++){\n\t for(int j=0;j<n;j++){\n\t   if(dp[i][j]==INF)continue;\n\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+land.get(z[i],z[i+1]));\n\t   for(int k=0;k<n;k++){\n\t\tint cost=land.get(z[i],j)+sea.get(j,k)+land.get(k,z[i+1]);\n\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+cost);\n\t   }\n\t }\n    }\n\n    int mi=INF;\n    for(int i=0;i<n;i++){\n\t mi=min(mi,dp[r-1][i]);\n    }\n    cout<<mi<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n\nusing namespace std;\n\nconst int N = 2100;\n\nint main()\n{\n    int l[N][N],s[N][N],v,e,r,tar[1010];\n\n    while(cin >> v >> e && e+v)\n    {\n        char ch;\n        int x,y,z;\n        memset(l,0x3f3f,sizeof l);//l,s初始化\n        memset(s, 0x3f3f, sizeof s);\n        long long dp[N][N];//dp[i][j]表示到了第i个点,船在j\n        memset(dp, 0x3f3f, sizeof dp);\n        memset(tar, 0 ,sizeof tar);\n\n        for(int i = 1; i <= e; i++)\n        {\n            cin >> x >> y >> z >> ch;\n            if(ch == 'L')\n                l[x][y] = l[y][x] = min(l[x][y], z);\n            else\n                s[x][y] = s[y][x] = min(s[x][y], z);\n        }\n        cin>>r;\n        for(int i = 1; i <= r; i++)\n            cin>>tar[i];\n\n        for(int i = 1; i <= v; i++) l[i][i] = s[i][i] = 0;\n        for(int k = 1; k <= v; k++)\n            for(int i = 1; i <= v; i++)\n                for(int j = 1; j <= v; j++)\n                {\n                    l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                    s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n                }\n\n        dp[1][tar[1]] = 0;//人在1,船在第一个地点\n\n        for(int i = 2; i <= r; i++)\n            for(int j = 1; j <= v; j++)\n            {\n                dp[i][j] = min(dp[i][j], dp[i-1][j] + l[tar[i-1]][tar[i]]);\n                for(int k = 1; k <= v; k++)\n                    dp[i][j] = min(dp[i][j], dp[i-1][k] + l[tar[i-1]][k] + s[k][j] + l[j][tar[i]]);//到了i-1个点，回k处坐船去j,从j走到i,就是dp[i][j]\n            }\n\n        long long ans = 0x3f3f3f;\n        for(int i = 1; i <= v; i++)\n            ans = min(ans, dp[r][i]);\n        cout<<ans<<endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &st) const { return d > st.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > ans(2,vector<int>(n,INF));\n    ans[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){    \n\n      for(int j=0;j<n;j++){\n\tif(ans[0][j] >= INF) continue;\t\n\n\tpriority_queue<State> Q;\n\tvector<vector<State2> > d(n,vector<State2>(n));\n\tState u(ans[0][j],dest[i-1],j);\n\td[dest[i-1]][j].d = ans[0][j];\n\tQ.push(u);\n\n\twhile(!Q.empty()){\n\t  u = Q.top();\n\t  Q.pop();\n\n\t  if(d[u.n][u.s].f) continue;\n\t  d[u.n][u.s].f = true;\n\t  if(u.n == dest[i]){\n\t    ans[1][u.s] = min(ans[1][u.s],u.d);\n\t    continue;\n\t  }\n\n\t  for(int k=0;k<n;k++){\n\t    if(!d[k][u.s].f && d[u.n][u.s].d + L[u.n][k] < d[k][u.s].d){\n\t      State v = u;\n\t      v.d = d[k][u.s].d = d[u.n][u.s].d + L[u.n][k];\n\t      v.n = k;\n\t      Q.push(v);\n\t    }\n\t    if(u.s == u.n){\n\t      if(!d[k][k].f && d[u.n][u.s].d + S[u.n][k] < d[k][k].d){\n\t\tState v2 = u;\n\t\tv2.d = d[k][k].d = d[u.n][u.s].d + S[u.n][k];\n\t\tv2.s = v2.n = k;\n\t\tQ.push(v2);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      ans[0].assign(ans[1].begin(),ans[1].end());\n      //for(int j=0;j<n;j++) if(ans[0][j] != INF) cout << ans[0][j] << \" \";\n      ans[1].assign(n,INF);\n    }\n\n    int ans2 = INF;\n    for(int i=0;i<n;i++) ans2 = min(ans2,ans[0][i]);\n    cout << ans2 << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship, cost;\n\tP(int now, int ship, int cost) :now(now), ship(ship), cost(cost) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\n\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tint N, M;\n\t\tvector<pii> SeaRoutes[201];\n\t\tvector<pii> LandRoutes[201];\n\t\tint R;\n\t\tvi Destinations;\n\n\t\tcin >> N >> M;\n\t\tif ( N == 0 && M == 0 )break;\n\n\t\tFOR(i, M)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif ( sl == 'S' )\n\t\t\t{\n\t\t\t\tSeaRoutes[x].emplace_back(t,y);\n\t\t\t\tSeaRoutes[y].emplace_back(t,x);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLandRoutes[x].emplace_back(t,y);\n\t\t\t\tLandRoutes[y].emplace_back(t,x);\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tFOR(i, R)\n\t\t{\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tDestinations.push_back(z);\n\t\t}\n\t\t\n\t\tint Flags[201][201];\n\t\tvector<P> StartPoints(1,P(Destinations[0],Destinations[0],0));\n\t\tint Score;\n\t\tFORI(r, 1, R)\n\t\t{\n\t\t\tINIT(Flags);\n\t\t\tpriority_queue< P, vector<P>, greater<P> > Queue(ALL(StartPoints));\n\t\t\tfor ( P StartPoint : StartPoints )\n\t\t\t\tFlags[StartPoint.now][StartPoint.ship] = StartPoint.cost;\n\t\t\tvector<P> Empty;\n\t\t\tswap(StartPoints, Empty);\n\t\t\tScore = INT_MAX;\n\t\t\twhile ( !Queue.empty() )\n\t\t\t{\n\t\t\t\tP CurrentPoint = Queue.top();\n\t\t\t\tQueue.pop();\n\t\t\t\tif ( CurrentPoint.now == Destinations[r] )\n\t\t\t\t{\n\t\t\t\t\tScore = min(Score,CurrentPoint.cost);\n\t\t\t\t\tStartPoints.push_back(CurrentPoint);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( CurrentPoint.now == CurrentPoint.ship )\n\t\t\t\t{\n\t\t\t\t\tFOR(i, SeaRoutes[CurrentPoint.now].size())\n\t\t\t\t\t{\n\t\t\t\t\t\tP NextPoint = CurrentPoint;\n\t\t\t\t\t\tNextPoint.now = NextPoint.ship = SeaRoutes[CurrentPoint.now][i].second;\n\t\t\t\t\t\tNextPoint.cost += SeaRoutes[CurrentPoint.now][i].first;\n\t\t\t\t\t\tint* Flag=&Flags[NextPoint.now][NextPoint.ship];\n\t\t\t\t\t\tif ( *Flag == -1 || *Flag > NextPoint.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*Flag = NextPoint.cost;\n\t\t\t\t\t\t\tQueue.push(NextPoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFOR(i, LandRoutes[CurrentPoint.now].size())\n\t\t\t\t{\n\t\t\t\t\tP NextPoint = CurrentPoint;\n\t\t\t\t\tNextPoint.now = LandRoutes[CurrentPoint.now][i].second;\n\t\t\t\t\tNextPoint.cost += LandRoutes[CurrentPoint.now][i].first;\n\t\t\t\t\tint* Flag = &Flags[NextPoint.now][NextPoint.ship];\n\t\t\t\t\tif ( *Flag == -1 || *Flag > NextPoint.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\t*Flag = NextPoint.cost;\n\t\t\t\t\t\tQueue.push(NextPoint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = 10000000;\nint land[200][200];\nint sea[200][200];\nint dp[1000][200];\n\nint main() {\n    int N,M,R,x,y,i,j,k,t;\n  string s;\n  while(cin>>N>>M, N|M) {\n\n    rep(i,200) {\n      rep(j,200) land[i][j] = sea[i][j] = inf;\n      land[i][i] = sea[i][i] = 0;\n    }\n\n    rep(i,M) {\n      cin>>x>>y>>t>>s;\n      x--,y--;\n      if(s == \"S\") {\n\tsea[x][y] = min(t, sea[x][y]);\n\tsea[y][x] = sea[x][y];\n      }else{\n\tland[x][y] = min(t, land[x][y]);\n\tland[y][x] = land[x][y];\n      }\n    }\n\n    rep(k,N) {\n      rep(i,N) {\n\trep(j,N) {\n\t  sea[i][j] = min(sea[i][k]+sea[k][j], sea[i][j]);\n\t  land[i][j] = min(land[i][k]+land[k][j], land[i][j]);\n\t}\n      }\n    }\n\n    cin>>R;\n    vector<int> path;\n    rep(i,1000) rep(j,200) dp[i][j] = inf;\n    rep(i, R) {\n      int kt;\n      cin>>kt;\n      kt--;\n      path.push_back(kt);\n    }\n\n    dp[0][path[0]] = 0;\n    for(i=1; i<R; ++i) {\n      for(j=0; j<N; ++j) {\n\tdp[i][j] = min(dp[i-1][j]+land[path[i-1]][path[i]],dp[i][j]);\n\n\tfor(k=0; k<N; ++k) {\n\t  int t = dp[i-1][j]+land[path[i-1]][j]+sea[j][k]+land[k][path[i]];\n\t  dp[i][k] = min(dp[i][k], t);\n\t}\n\t//cout<<i<<\": \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n\n    int ans = inf;\n    rep(i,N) {\n      ans = min(ans, dp[R-1][i]);\n      //cout<<i<<\" : \"<<dp[R-1][i]<<endl;\n    }\n\n    cout<<ans<<endl;\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\ntypedef long long ll;\n\nconstexpr ll LL_INF = 1e15;\n\nll dist1[200][200], dist2[200][200];\nll dp[1001][200];\n\n/*\n * 2 <= N <= 200\n * 1 <= M <= 10000\n * 1 <= xi, yi <= N\n * 1 <= ti <= 1000\n * 1 <= R <= 1000\n * 1 <= zi <= N\n */\n\nint main(void) {\n    while (true) {\n        int i, j, k, n, m;\n        scanf(\"%d%d\",&n,&m);\n        if (n == 0 && m == 0) break;\n        REP (i,n) REP (j,n) {\n            dist1[i][j] = i == j ? 0 : LL_INF;\n            dist2[i][j] = i == j ? 0 : LL_INF;\n        }\n        REP (i,m) {\n            int x, y, t;\n            char sl;\n            scanf(\"%d %d %d %c\",&x,&y,&t,&sl);\n            x--; y--;\n            if (sl == 'S') {\n                dist1[x][y] = min<ll>(dist1[x][y],t);\n                dist1[y][x] = dist1[x][y];\n            }\n            else {\n                dist2[x][y] = min<ll>(dist2[x][y],t);\n                dist2[y][x] = dist2[x][y];\n            }\n        }\n        REP (k,n) REP (i,n) REP (j,n) {\n            dist1[i][j] = min(dist1[i][j],dist1[i][k] + dist1[k][j]);\n            dist2[i][j] = min(dist2[i][j],dist2[i][k] + dist2[k][j]);\n        }\n        int r;\n        scanf(\"%d\",&r);\n        REP (i,1,r) REP (j,n) dp[i][j] = LL_INF;\n        int pre = 0;\n        REP (i,r) {\n            int x;\n            scanf(\"%d\",&x);\n            x--;\n            REP (j,n) REP (k,n) dp[i+1][j] = min(dp[i+1][j],dp[i][k] + dist2[pre][k] + dist1[k][j] + dist2[j][x]);\n            pre = x;\n        }\n        ll ans = LL_INF;\n        REP (j,n) ans = min(ans,dp[r][j]);\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nvoid chmin(int &a, int b) {\n     a = min(a, b);\n}\n\nconst int INF = 1 << 25;\nint N, M, R;\nint dl[210][210], ds[210][210], dist[1010][210], op[1010];\n\nint main() {\n    while(scanf(\"%d%d\", &N, &M)) {\n        if(N == M && M == 0) break;\n        for(int i=0; i<N; i++) {\n            fill(dl[i], dl[i] + N, INF);\n            fill(ds[i], ds[i] + N, INF);\n            dl[i][i] = ds[i][i] = 0;\n        }\n\n        for(int i=0; i<M; i++) {\n            int x, y, t; char s;\n            scanf(\" %d%d%d %c\", &x, &y, &t, &s);\n            x--; y--;\n            if(s == 'L') {\n                chmin(dl[x][y], t);\n                chmin(dl[y][x], t);\n            }\n            else {\n                chmin(ds[x][y], t);\n                chmin(ds[y][x], t);\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    chmin(dl[i][j], dl[i][k] + dl[k][j]);\n                    chmin(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        scanf(\"%d\", &R);\n        for(int i=0; i<R; i++) {\n            scanf(\"%d\", &op[i]); op[i]--;\n            fill(dist[i], dist[i] + N, INF);\n        }\n\n        dist[0][op[0]] = 0;\n        for(int i=0; i<R-1; i++) {\n            for(int j=0; j<N; j++) {\n                if(dist[i][j] == INF) continue;\n                int cur = op[i], nxt = op[i+1];\n\n                // land only\n                chmin(dist[i+1][j], dist[i][j] + dl[cur][nxt]);\n\n                // land + sea\n                for(int k=0; k<N; k++) {\n                    chmin(dist[i+1][k], dist[i][j] + dl[cur][j] + ds[j][k] + dl[k][nxt]);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", *min_element(dist[R-1], dist[R-1] + N));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 100000000;\nconst int MAX_N = 200, MAX_M = 10000, MAX_R = 1000;\ntypedef pair<int, int> P;\ntypedef pair<P, char> edge;\ntypedef pair<P, int> cond;\n\nint main(){\n\tint d[MAX_N + 1][MAX_N + 1];\n\tint N, M, R;\n\tvector<edge> E[MAX_N + 1];\n\tint order[MAX_R];\n\tint u, v, c, node, cost, boat, res, from, to;\n\tint mnode, mcost, mboat;//after move\n\tint minimum;\n\tchar ch;\n\tqueue<cond> que;\n\t\n\twhile(true){\n\t\tscanf(\"%d%d\", &N, &M);\n\t\tif(N == 0 && M == 0) break;\n\t\tfor(int i = 0; i < M; i++){\n\t\t\tscanf(\"%d %d %d %c\", &u, &v, &c, &ch);\n\t\t\tE[u].push_back(edge(P(v, c), ch));\n\t\t\tE[v].push_back(edge(P(u, c), ch));\n\t\t}\n\t\tscanf(\"%d\", &R);\n\t\tfor(int i = 0; i < R; i++){\n\t\t\tscanf(\"%d\", &order[i]);\n\t\t}\n\t\t\n\t\tfrom = order[0];\n\t\tboat = from;\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\td[from][boat] = 0;\n\t\twhile(!que.empty()) que.pop();\n\t\tque.push(cond(P(from, 0), boat));\n\t\tfor(int i = 1; i < R; i++){\n\t\t\tto = order[i];\n\t\t\twhile(!que.empty()){\n\t\t\t\tcond c = que.front(); que.pop();\n\t\t\t\tP p = c.first; boat = c.second;\n\t\t\t\tnode = p.first; cost = p.second;\n\t\t\t\tfor(int j = 0; j < E[node].size(); j++){\n\t\t\t\t\tmnode = (E[node][j].first).first;\n\t\t\t\t\tmcost = (E[node][j].first).second;\n\t\t\t\t\tif(cost + mcost < d[mnode][boat] && E[node][j].second == 'L'){\n\t\t\t\t\t\td[mnode][boat] = cost + mcost;\n\t\t\t\t\t\tque.push(cond(P(mnode, d[mnode][boat]), boat));\n\t\t\t\t\t}\n\t\t\t\t\tif(cost + mcost < d[mnode][mnode] && E[node][j].second == 'S' && boat == node){\n\t\t\t\t\t\td[mnode][mnode] = cost + mcost;\n\t\t\t\t\t\tque.push(cond(P(mnode, d[mnode][mnode]), mnode));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfrom = to;\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tfor(int k = 1; k <= N; k++){\n\t\t\t\t\tif(j != from){\n\t\t\t\t\t\td[j][k] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 1; j <= N; j++){\n\t\t\t\tif(d[from][j] != INF){\n\t\t\t\t\tque.push(cond(P(from, d[from][j]), j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tres = INF;\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tres = min(res, d[from][j]);\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t\t\n\t\tfor(int j = 1; j <= N; j++){\n\t\t\tE[j].clear();\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nvoid chmin(int &a, int b) {\n     a = min(a, b);\n}\n\nconst int INF = 1 << 25;\nint N, M, R;\nint dl[210][210], ds[210][210], dist[1010][210], op[1010];\n\nint main() {\n    while(scanf(\"%d%d\", &N, &M)) {\n        if(N == M && M == 0) break;\n        for(int i=0; i<N; i++) {\n            fill(dl[i], dl[i] + N, INF);\n            fill(ds[i], ds[i] + N, INF);\n            dl[i][i] = ds[i][i] = 0;\n        }\n\n        for(int i=0; i<M; i++) {\n            int x, y, t; char s;\n            scanf(\" %d%d%d %c\", &x, &y, &t, &s);\n            x--; y--;\n            if(s == 'L') {\n                chmin(dl[x][y], t);\n                chmin(dl[y][x], t);\n            }\n            else {\n                chmin(ds[x][y], t);\n                chmin(ds[y][x], t);\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    chmin(dl[i][j], dl[i][k] + dl[k][j]);\n                    chmin(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        scanf(\"%d\", &R);\n        for(int i=0; i<R; i++) {\n            scanf(\"%d\", &op[i]); op[i]--;\n            fill(dist[i], dist[i] + N, INF);\n        }\n\n        dist[0][op[0]] = 0;\n        for(int i=0; i<R-1; i++) {\n            for(int j=0; j<N; j++) {\n                if(dist[i][j] == INF) continue;\n                int cur = op[i], nxt = op[i+1];\n\n                // land only\n                chmin(dist[i+1][j], dist[i][j] + dl[cur][nxt]);\n\n                // land + sea\n                for(int k=0; k<N; k++) {\n                    chmin(dist[i+1][k], dist[i][j] + dl[cur][j] + ds[j][k] + dl[k][nxt]);\n                }\n            }\n        }\n\n        printf(\"%d\\n\", *min_element(dist[R-1], dist[R-1] + N));\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 1000000000000LL\ntypedef long long ll;\nll d[200][200];\nll se[200][200];\nll dp[2][200];\nint z[1000];\nll min(ll a,ll b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\td[i][j]=INF;\n\t\tse[i][j]=INF;\n\t\tif(i==j){\n\t\t\td[i][j]=0;\n\t\t\tse[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b;\n\t\tll c;\n\t\tchar p;\n\t\tscanf(\"%d %d %lld %c\",&a,&b,&c,&p);\n\t\ta--;b--;\n\t\tif(p=='L'){\n\t\t\td[a][b]=min(d[a][b],c);\n\t\t\td[b][a]=min(d[b][a],c);\n\t\t}\n\t\tif(p=='S'){\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++){\n\t\tscanf(\"%d\",&z[i]);\n\t\tz[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][z[0]]=0;\n\tfor(i=1;i<p;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i%2][j]=INF;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][k]+d[z[i-1]][k]+se[k][j]+d[j][z[i]]);\n\t\t\t}\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(p+1)%2][i]);\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF=1001001001001001LL;\nint N,M;\nint A[200][200],B[200][200];\nint dp[2][200];\nsigned main(){\n    while(cin>>N>>M,N||M){\n        fill_n(*A,200*200,INF);\n        fill_n(*B,200*200,INF);\n        for(int i=0;i<N;i++){\n            A[i][i]=0;\n            B[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L')A[a][b]=A[b][a]=min(A[a][b],c);\n            else B[a][b]=B[b][a]=min(B[a][b],c);\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n\n        int R;cin>>R;\n        int prev;cin>>prev;prev--;\n        fill_n(*dp,2*200,INF);\n        dp[1][prev]=0;\n\n        for(int i=1;i<R;i++){\n            int cur;cin>>cur;cur--;\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if(A[prev][k]==INF||B[k][j]==INF||A[j][cur]==INF)continue;\n                    dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+A[prev][k]+B[k][j]+A[j][cur]);\n                }\n            }\n            for(int j=0;j<N;j++)dp[i&1][j]=INF;\n            prev=cur;\n        }\n\n        int mi=INF;\n        for(int i=0;i<N;i++)mi=min(mi,dp[R&1][i]);\n\n        cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define fi first\n#define se second\n#define ve vector\nconst ll INF=0x3f3f3f3f3f3f;\n\nvoid floyd(vector<vector<ll>> &a,ll n){\n\tfor (ll i = 1; i <= n; i++) {\n\t\tfor (ll j = 1; j <= n; j++) {\n\t\t\tfor (ll k = 1; k <= n; k++) {\n\t\t\t\ta[k][j]=a[j][k]=min(a[j][i]+a[i][k],a[j][k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tll n,m;\n\twhile(cin>>n>>m){\n\t\tif(n==0 && m==0)break;\n\t\tvector<vector<ll>> s(n+1,vector<ll>(n+1,INF));\n\t\tfor (ll i = 1; i <= n; i++) {\n\t\t\ts[i][i]=0;\n\t\t}\n\t\tvector<vector<ll>> l=s;\n\t\tfor (ll i = 0; i < m; i++){\n\t\t\tll x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tif(sl=='S'){\n\t\t\t\ts[y][x]=s[x][y]=min(s[x][y],t);\n\t\t\t}\n\t\t\telse l[y][x]=l[x][y]=min(l[x][y],t);\n\t\t}\n\t\tfloyd(l,n);\n\t\tfloyd(s,n);\n\t\tll r;\n\t\tcin>>r;\n\t\tvector<ll> z;\n\t\tfor (ll i = 0; i < r; i++){\n\t\t\tll t;\n\t\t\tcin>>t;\n\t\t\tz.push_back(t);\n\t\t}\n\t\tve<ve<ll>> dp(r,ve<ll>(n+1,INF));\n\t\tdp[0][z[0]]=0;\n\t\tfor (ll i = 1; i <= r-1; i++) {\n\t\t\tfor (ll j = 1; j <= n; j++) {\n\t\t\t\tfor (ll k = 1; k <= n; k++) {\n\t\t\t\t\tif(j==k)dp[i][j]=min(dp[i][j],dp[i-1][k]+l[z[i-1]][z[i]]);\n\t\t\t\t\telse dp[i][j]=min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ret=INF;\n\t\tfor(ll i=1;i<=n;i++)ret=min(ret,dp[r-1][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<29);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &st) const { return d > st.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b;\n      int c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n\n    \n    for(int k=0;k<n;k++){\n      L[k][k] = S[k][k] = 0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int l=0;l<2;l++){\n\t    if(l == 0){\n\t      if(L[i][k] >= INF || L[k][j] >= INF) continue;\n\t      L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t    }\n\t    else{\n\t      if(S[i][k] >= INF || S[k][j] >= INF) continue;\n\t      S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > dp(2,vector<int>(n,INF));\n    dp[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){\n      for(int j=0;j<n;j++){\n\tif(dp[0][j] >= INF || L[dest[i-1]][j] >= INF) continue;\n\tfor(int k=0;k<n;k++){\n\t  if(S[j][k] >= INF || L[k][dest[i]] >= INF) continue;\n\t  dp[1][k] = min(dp[1][k], dp[0][j] + L[dest[i-1]][j] + S[j][k] + L[k][dest[i]]);\n\t  if(j == k) dp[1][k] = min(dp[1][k], dp[0][j] + L[dest[i-1]][dest[i]]);\n\t}\n      }\n      dp[0].assign(dp[1].begin(),dp[1].end());\n      dp[1].assign(n,INF);\n    }\n\n    int ans = INF;\n    for(int i=0;i<n;i++) ans = min(ans,dp[0][i]);\n\n    cout << ans << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1e5;\n\nvector<vector<int> > ld, sd, dp;\nint N, M, R;\nvector<int> z;\n\nint dfs(int n, int fune) {\t\n\tif ( n == R-1 ) return 0;\n\tif ( dp[n][fune] >= 0 ) return dp[n][fune];\n\n\tint ret = dfs(n+1, fune)+ld[z[n]][z[n+1]];\n\tfor ( int i = 0; i < N; i++ ) {\n\t\tret = min(ret, dfs(n+1, i)+ld[z[n]][fune]+sd[fune][i]+ld[i][z[n+1]]);\t\t\t\t\t\t\t\n\t}\n\n\t\n\treturn dp[n][fune] = ret;\t\n}\n\nint main() {\n\twhile ( cin >> N >> M, N ) {\n\t\tld = vector<vector<int> >(N+1, vector<int>(N+1, INF));\n\t\tsd = vector<vector<int> >(N+1, vector<int>(N+1, INF));\n\t\tfor ( int i = 0; i < N; i++ ) ld[i][i] = sd[i][i] = 0;\n\t\t\n\t\tfor ( int i = 0; i < M; i++ ) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif ( sl == 'L' ) ld[x][y] = ld[y][x] = t;\n\t\t\telse sd[x][y] = sd[y][x] = t;\t\t\t\n\t\t}\n\n\t\tfor ( int i = 0; i < N; i++ )\n\t\t\tfor  ( int j = 0; j < N; j++ )\n\t\t\t\tfor ( int k = 0; k < N; k++ ) {\n\t\t\t\t\tld[j][k] = min(ld[j][k], ld[j][i]+ld[i][k]);\n\t\t\t\t\tsd[j][k] = min(sd[j][k], sd[j][i]+sd[i][k]);\n\t\t\t\t}\n\t\t\n\t\tcin >> R;\n\t\tz = vector<int>(R);\n\t\tfor ( int i = 0; i < R; i++ ) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tdp = vector<vector<int> >(R+1, vector<int>(N+1, -1));\n\t\tcout << dfs(0, z[0]) << endl;\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\n\nconst int inf=1000000000;\nint wf_l[200][200],wf_s[200][200],memo[1000][200];\n\nint main()\n{\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)\twf_l[i][j]=wf_s[i][j]=(i==j?0:inf);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\tscanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n\t\t\tx--;\ty--;\n\t\t\tif(sl=='S')\twf_s[x][y]=wf_s[y][x]=min(wf_s[x][y],t);\n\t\t\tif(sl=='L')\twf_l[x][y]=wf_l[y][x]=min(wf_l[x][y],t);\n\t\t}\n\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf_l[i][j]=min(wf_l[i][j],wf_l[i][k]+wf_l[k][j]);\n\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf_s[i][j]=min(wf_s[i][j],wf_s[i][k]+wf_s[k][j]);\n\n\t\tint r,from,to;\tscanf(\"%d%d\",&r,&from);\tfrom--;\n\t\tfor(int j=0;j<n;j++)\tmemo[0][j]=(j==from?0:inf);\n\t\tfor(int i=1;i<r;i++){\n\t\t\tscanf(\"%d\",&to);\tto--;\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tmemo[i][j]=inf;\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tlong long dis=0LL+wf_l[from][k]+wf_s[k][j]+wf_l[j][to];\n\t\t\t\t\tif(dis<inf)\tmemo[i][j]=min(memo[i][j],memo[i-1][k]+(int)dis);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfrom=to;\n\t\t}\n\n\t\tint tmin=inf;\n\t\tfor(int j=0;j<n;j++)\ttmin=min(tmin,memo[r-1][j]);\n\t\tprintf(\"%d\\n\",tmin);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <queue>\n#include <map>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef int gitype;\ntypedef long long LL;\ngitype gi () {\n    gitype ret=0; char ch=getchar();\n    while((ch<'0' || ch>'9') && ch!='-') ch=getchar();\n    char c=ch=='-'?getchar():ch;\n    while(c>='0' && c<='9') ret=ret*10+c-'0',c=getchar();\n    return ch=='-'?-ret:ret;\n}\nconst int N = 500;\nconst int R = 2000;\nint n,m,tot;\nLL f[R][N],w1[N][N],w2[N][N];\nint main () {\n    while(scanf(\"%d%d\",&n,&m) && (n||m)) {\n        int u,v; LL t; char ops[10];\n        memset(w1,127/4,sizeof(w1));\n        memset(w2,127/4,sizeof(w2));\n        memset(f,127/4,sizeof(f));\n        for(int i=1;i<=m;i+=1) {\n            u=gi(); v=gi(); t=gi(); scanf(\"%s\",ops);\n            if(ops[0]=='L') w1[v][u] = w1[u][v] = min(w1[u][v],t);\n            else w2[v][u] = w2[u][v] = min(w2[u][v],t);\n        }\n        for(int i=1;i<=n;i+=1) w1[i][i]=w2[i][i]=0;\n        for(int k=1;k<=n;k+=1) {\n            for(int i=1;i<=n;i+=1) {\n                for(int j=1;j<=n;j+=1) {\n                    w1[i][j] = min(w1[i][j], w1[i][k] + w1[k][j]);\n                    w2[i][j] = min(w2[i][j], w2[i][k] + w2[k][j]);\n                }\n            }\n        }\n        f[0][1]=0;\n        int b,p=1,r=gi(); LL ans=(1ll<<60);\n        for(int i=1;i<=r;i+=1) {\n            swap(b,p); p=gi();\n            for(int j=1;j<=n;j+=1) {\n                for(int k=1;k<=n;k+=1) {\n                    f[i][j] = min(f[i][j], f[i-1][k] + w1[b][k] + w2[k][j] + w1[j][p]);\n                }\n                if(i==r) ans=min(ans,f[i][j]);\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_N];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nint n,m,r;\nvi route;\nvvi L,S;\n\nint solve(){\n    vvi dp(r,vi(n,INF));\n    dp[0][route[0]]=0;\n        //i番目の集配が終了した時点で、頂点jに船を乗り捨てているときの累計コスト\n    rep(p,r-1){\n        int s=route[p],t=route[p+1];\n        rep(i,n)rep(j,n){\n            //cout<<s<<\"->\"<<i<<\"->\"<<j<<\"->\"<<t<<endl;\n            //cout<<vi{dp[p][i],L[s][i],S[i][j],L[j][t]}<<endl;\n            if(dp[p][i]!=INF and L[s][i]!=INF and S[i][j]!=INF and L[j][t]!=INF){\n\t\t\t\tif(i==j)\n\t\t\t\t\tdp[p+1][j]=min(dp[p+1][j],dp[p][i]+L[s][i]+S[i][j]+L[j][t]);\n\t\t\t\telse\n\t\t\t\t\tdp[p+1][j]=min(dp[p+1][j],dp[p][i]+L[s][t]);\n            }\n        }\n        //cout<<p+1<<\":\"<<dp[p+1]<<endl;\n    }\n    return *min_element(all(dp[r-1]));\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\twhile(cin>>n>>m,n){\n\t    L=vvi(n,vi(n,INF));\n\t    S=vvi(n,vi(n,INF));\n\t    rep(_,m){\n\t        int x,y,t; char c;\n\t        cin>>x>>y>>t>>c;\n\t        x--;y--;\n\t\t\tt=min((c=='L'?L:S)[x][y],t);\n\t        (c=='L'?L:S)[x][y]=(c=='L'?L:S)[y][x]=t;\n\t    }\n\t    rep(k,n)rep(i,n)rep(j,n)if(i!=j){\n\t        if(L[i][k]!=INF&&L[k][j]!=INF)\n\t            L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t        if(S[i][k]!=INF&&S[k][j]!=INF)\n\t            S[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t    }else L[i][j]=S[i][j]=0;\n\t    cin>>r;\n\t    route.resize(r);\n\t    rep(i,r){\n\t        cin>>route[i];\n\t        route[i]--;\n\t    }\n\t    cout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <fstream>\n#include <bitset>\n   \nusing namespace std;\n   \n \n#define rep(i, n) for (int i = 0; i < (int)(n); ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n#define ten(n) ((long long)(1e##n))\n#define bin(n) (1LL << (n))\n#define erep(i, n) for (int i = 0; i <= (int)(n); ++i)\n#define revrep(i, n) for (int i = (n); i >= 0; --i)\n#define pb push_back\n\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void uniq(T& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n\ntemplate <typename T> void print_container(ostream& os, const T& c) { const char* _s = \" \"; if (!c.empty()) { __typeof__(c.begin()) last = --c.end(); foreach (it, c) { os << *it; if (it != last) cout << _s; } } }\ntemplate <typename T> ostream& operator<<(ostream& os, const vector<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const set<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const multiset<T>& c) { print_container(os, c); return os; }\ntemplate <typename T> ostream& operator<<(ostream& os, const deque<T>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const map<T, U>& c) { print_container(os, c); return os; }\ntemplate <typename T, typename U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os; }\n\ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nvoid fix_pre(int n) { cout.setf(ios::fixed, ios::floatfield); cout.precision(10); }\nvoid fast_io() { cin.tie(0); ios::sync_with_stdio(false); }\n#define trace(x) (cout << #x << \": \" << (x) << endl)\n \nbool in_rect(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n// y(v): v>^<  y(^): ^>v<\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst double PI = acos(-1.0);\n#define mp make_pair\n\n\n\nint main()\n{\n    fast_io();\n\n    int n, m;\n    while (cin >> n >> m, n)\n    {\n        const int inf = ten(8);\n        int l[256][256], s[256][256];\n        rep(i, n) rep(j, n)\n            l[i][j] = s[i][j] = i == j ? 0 : inf;\n        while (m--)\n        {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x, --y;\n            if (sl == 'L')\n                l[x][y] = l[y][x] = t;\n            else\n                s[x][y] = s[y][x] = t;\n        }\n        rep(k, n) rep(i, n) rep(j, n)\n        {\n            chmin(l[i][j], l[i][k] + l[k][j]);\n            chmin(s[i][j], s[i][k] + s[k][j]);\n        }\n\n        int r, z[1024];\n        cin >> r;\n        input(z, r);\n        rep(i, r)\n            --z[i];\n\n        int dp[1024][256];\n        rep(i, r) rep(j, n)\n            dp[i][j] = inf;\n        dp[0][z[0]] = 0;\n        rep(i, r - 1) rep(j, n) rep(k, n)\n            chmin(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n        int res = *min_element(dp[r - 1], dp[r - 1] + n);\n        assert(res < inf / 10);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum\n{\n    MAX_V = 300 + 10, MAX_Z = 2000 + 50\n};\n\nconst int INF = 2000000000;\nint dp[MAX_Z][MAX_V], SG[MAX_V][MAX_V], LG[MAX_V][MAX_V];\nint rt[MAX_Z], rtl;\nint n, m;\n\nvoid floyd()\n{\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = min(SG[i][j], SG[i][k] + SG[k][j]);\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                LG[i][j] = min(LG[i][j], LG[i][k] + LG[k][j]);\n    for(int i = 1; i <= n; i++)\n        LG[i][i] = SG[i][i] = 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n+m)\n    {\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = LG[i][j] = INF;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y, cs;\n            char tp;\n            scanf(\"%d %d %d %c\", &x, &y, &cs, &tp);\n            if(tp == 'S')\n            {\n                SG[x][y] = min(SG[x][y], cs);\n                SG[y][x] = min(SG[y][x], cs);\n            }\n            else\n            {\n                LG[x][y] = min(LG[x][y], cs);\n                LG[y][x] = min(LG[y][x], cs);\n            }\n        }\n        scanf(\"%d\", &rtl);\n        for(int i = 1; i <= rtl; i++)\n            scanf(\"%d\", &rt[i]);\n\n        floyd();\n        for(int i = 1; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                dp[i][j] = INF;\n\n        dp[1][rt[1]] = 0;\n        for(int i = 2; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                for(int k = 1; k <= n; k++)\n                {\n                    if(j != k)\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[k][rt[i - 1]] + SG[k][j] + LG[j][rt[i]]);\n                    else\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[rt[i-1]][rt[i]]);\n                }\n\n    /*    for(int i = 1; i <= rtl; i++)\n        {\n            for(int j = 1; j <= n; j++)\n            {\n                printf(\"%d %d %lld\\n\", i, j, dp[i][j]);\n            }\n        }\n*/\n        long long ans = *min_element(dp[rtl] + 1, dp[rtl] + n + 1);\n        if(ans == INF);\n        else printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 29)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nint Shortest(int start, int goal, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn D[goal];\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i <= MAX_R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] < INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Shortest(Z[i - 1], j, \"Land\");\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Shortest(j, k, \"Sea\");\n\n\t\t\t\t\t\tint Land_2 = Shortest(k, Z[i], \"Land\");\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<vector<int> > > dp;\nvector<vector<int> > g;\nvector<vector<int> > ti;\nvector<vector<char> > sl;\n\nstruct State{\n\tint pos;\n\tint hune;\n\tint r;\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tg.clear();\n\t\tti.clear();\n\t\tsl.clear();\n\t\tg.resize(N);\n\t\tti.resize(N);\n\t\tsl.resize(N);\n\t\t\n\t\tint res = 0;\n\t\tint a, b, c;\n\t\tchar d;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t\tti[a].push_back(c);\n\t\t\tti[b].push_back(c);\n\t\t\tsl[a].push_back(d);\n\t\t\tsl[b].push_back(d);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> A(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> A[i];\n\t\t\tA[i]--;\n\t\t}\n\t\tdp.clear();\n\t\tdp.resize(N, vector < vector<int> >(N, vector<int>(R + 1, (int)1 << 60)));\n\t\tdp[A[0]][A[0]][1] = 0;\n\t\tqueue<State> qu;\n\t\tqu.push(State{ A[0], A[0],1 });\n\t\tState t;\n\t\twhile ((int)qu.size() > 0) {\n\t\t\tState st = qu.front(); qu.pop();\n\t\t\t//cerr << st.pos << \" \" << st.hune << \" \" << st.r << endl;\n\t\t\tif (st.r == R)continue;\n\t\t\tfor (int i = 0; i < g[st.pos].size(); i++) {\n\t\t\t\tif (st.pos == st.hune || sl[st.pos][i] == 'L') {\n\t\t\t\t\tt.pos = g[st.pos][i];\n\t\t\t\t\tif (sl[st.pos][i] == 'S') {\n\t\t\t\t\t\tt.hune = g[st.pos][i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tt.hune = st.hune;\n\t\t\t\t\t}\n\t\t\t\t\tt.r = st.r;\n\t\t\t\t\tif (A[st.r] == g[st.pos][i]) {\n\t\t\t\t\t\tt.r++;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[t.pos][t.hune][t.r] > dp[st.pos][st.hune][st.r] + ti[st.pos][i]) {\n\t\t\t\t\t\tdp[t.pos][t.hune][t.r] = dp[st.pos][st.hune][st.r] + ti[st.pos][i];\n\t\t\t\t\t\tqu.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = (int)1 << 60;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, dp[A[R - 1]][i][R]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst int N = 207;\nconst int M = 1024;\nconst int inf = (int)1E8;\nint sea[N][N],land[N][N],dp[M][N],n,m,z[M];\n#define REP(i,j,k) for(int i = j;i <= k;i ++)\nint main()\n{\n    std::ios::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n    int a,b,c;\n    char ch;\n    while(cin >> n >> m && (n + m)) {\n        REP(i,1,n) REP(j,1,n) sea[i][j] = land[i][j] = i == j ? 0 : inf;\n        REP(i,1,m) {\n            cin >> a >> b >> c >> ch;\n            if(ch == 'L') land[a][b] = land[b][a] = min(land[a][b], c);\n            else sea[a][b] = sea[b][a] = min(sea[a][b], c);\n        }\n        REP(k,1,n) REP(i,1,n) REP(j,1,n) {\n            sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n            land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n        }\n        int R;\n        cin >> R;\n        REP(i,1,R) cin >> z[i];\n        REP(i,1,R) REP(j,1,n) dp[i][j] = inf;\n        REP(i,1,n) dp[1][i] = sea[z[1]][i] + land[i][z[1]];\n        REP(i,2,R) {\n            REP(j,1,n) {\n                REP(k,1,n) {\n                    if(k != j)\n                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + sea[k][j] + land[z[i - 1]][k] + land[j][z[i]]);\n                    else\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + land[z[i - 1]][z[i]]);\n                }\n            }\n        }\n        cout << *min_element(dp[R] + 1, dp[R] + 1 + n) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long LL;\ntypedef long double LD;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dre_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dre_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tstatic int ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n\t\tstatic int sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n\t\t\n\t\tscanf(\"%d%d\",&n,&m); if(n==0&&m==0)break;\n\t\trep(i,m){\n\t\t\tint x,y,t; char sl;\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n\t\t\tif(sl=='L'){\n\t\t\t\tld[x][y]=t;\n\t\t\t\tld[y][x]=t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsd[x][y]=t;\n\t\t\t\tsd[y][x]=t;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n\t\trep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n\t\t\n\t\t/*rep1(i,n){\n\t\t\trep1(j,n){\n\t\t\t\tcout<<sd[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}*/\n\t\t\n\t\tint r,z;\n\t\tstatic int dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n\t\t\n\t\tscanf(\"%d\",&r);\n\t\tscanf(\"%d\",&z);\n\t\tdp[0][z]=0;\n\t\t\n\t\tint ret=INF;\n\t\trep1(i,r-1){\n\t\t\tscanf(\"%d\",&z);\n\t\t\trep1(j,n){\n\t\t\t\tif(ld[j][z]!=INF){\n\t\t\t\t\trep1(k,n){\n\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+sd[k][j]);\n\t\t\t\t\t}\n\t\t\t\t\tif(i!=r-1){\n\t\t\t\t\t\tif(dp[i][j]!=INF)dp[i][j]+=2*ld[j][z];\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tdp[i][j]+=ld[j][z];\n\t\t\t\t\t\tret=min(ret,dp[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int INF=123456789;\n\nint n,m;\nint R;\nint z[1001];\nint ld[200][200],sd[200][200];\nvector<int> island[200];\nint island_id[200];\nll dp[1001][200];\n\nvoid init()\n{\n    fill(ld[0],ld[200],INF);\n    fill(sd[0],sd[200],INF);\n    rep(i,200) island[i].clear();\n    fill(island_id,island_id+200,-1);\n    fill(dp[0],dp[1001],10000LL*INF);\n}\n\nvoid Warshall_Floyd()\n{\n    rep(i,n)\n    {\n        ld[i][i]=0;\n        sd[i][i]=0;\n    }\n    rep(k,n)rep(i,n)rep(j,n)\n    {\n        ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n    }\n}\n\nvoid divide()\n{\n    int island_idx=0;\n    rep(i,n)\n    {\n        if(island_id[i]!=-1) continue;\n\n        island_id[i]=island_idx;\n        rep(j,n) if(ld[i][j]<INF) island_id[j]=island_idx;\n\n        ++island_idx;\n    }\n    rep(i,n) island[island_id[i]].pb(i);\n}\n\nint main()\n{\n    while(scanf(\" %d %d\",&n,&m),n)\n    {\n        init();\n\n        // input\n        rep(i,m)\n        {\n            int x,y,t;\n            char sl;\n            scanf(\" %d %d %d %c\",&x,&y,&t,&sl);\n            --x;\n            --y;\n            if(sl=='L') ld[x][y]=ld[y][x]=min(ld[x][y],t);\n            else sd[x][y]=sd[y][x]=min(sd[x][y],t);\n        }\n        scanf(\" %d\",&R);\n        rep(i,R)\n        {\n            scanf(\" %d\",&z[i]);\n            --z[i];\n        }\n\n        Warshall_Floyd();\n\n        // determine the island i-th town belongs\n        divide();\n\n        // calc ans\n        dp[0][z[0]]=0;\n        for(int i=1; i<R; ++i)\n        {\n            int p_id=island_id[z[i-1]], c_id=island_id[z[i]];\n            if(p_id==c_id)\n            {\n                rep(j,island[p_id].size())\n                {\n                    int boat=island[p_id][j];\n                    dp[i][boat] = min(dp[i][boat], dp[i-1][boat]+ld[z[i-1]][z[i]]);\n                }\n            }\n            rep(j,island[p_id].size())rep(k,island[c_id].size())\n            {\n                int now_b=island[p_id][j], nx_b=island[c_id][k];\n                dp[i][nx_b] = min(dp[i][nx_b], dp[i-1][now_b]+ld[z[i-1]][now_b]+sd[now_b][nx_b]+ld[nx_b][z[i]]);\n            }\n        }\n\n        ll ans=10000LL*INF;\n        rep(i,n) ans=min(ans,dp[R-1][i]);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <iomanip>\n#include <cassert>\nusing namespace std;\n\n#define GET_ARG(a,b,c,F,...) F\n#define REP3(i,s,e) for (i = s; i <= e; i++)\n#define REP2(i,n) REP3 (i,0,(int)(n)-1)\n#define REP(...) GET_ARG (__VA_ARGS__,REP3,REP2) (__VA_ARGS__)\n#define RREP3(i,s,e) for (i = s; i >= e; i--)\n#define RREP2(i,n) RREP3 (i,(int)(n)-1,0)\n#define RREP(...) GET_ARG (__VA_ARGS__,RREP3,RREP2) (__VA_ARGS__)\n#define DEBUG(x) cerr << #x \": \" << x << endl\n\nconstexpr int INF = 1e9;\n\nvector<pair<int,pair<int,char>>> e[200]; // (y, t, sl)\nint dist[200][200]; // (pos, ship)\n\nint main(void) {\n    while (true) {\n        int i, j, n, m;\n        cin >> n >> m;\n        if (n == 0 && m == 0) break;\n        REP (i,n) e[i].clear();\n        REP (i,m) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            e[x].push_back({y,{t,sl}});\n            e[y].push_back({x,{t,sl}});\n        }\n        priority_queue<pair<int,pair<int,int>>> q; // (-dist,x,ship)\n        int r, goal = 0;\n        cin >> r;\n        REP (i,n) REP (j,n) dist[i][j] = INF;\n        dist[0][0] = 0;\n        while (r--) {\n            REP (i,n) REP (j,n) if (i != goal) dist[i][j] = INF;\n            REP (j,n) q.push({dist[goal][j],{goal,j}});\n            cin >> goal;\n            goal--;\n            while (!q.empty()) {\n                auto p = q.top(); q.pop();\n                int d = -p.first;\n                int x = p.second.first;\n                int ship = p.second.second;\n                if (d > dist[x][ship]) continue;\n                for (auto pp: e[x]) {\n                    int y = pp.first;\n                    int t = pp.second.first;\n                    char sl = pp.second.second;\n                    if (sl == 'S') {\n                        if (ship == x && dist[y][y] > dist[x][x] + t) {\n                            dist[y][y] = dist[x][x] + t;\n                            q.push({-dist[y][y],{y,y}});\n                        }\n                    }\n                    else {\n                        if (dist[y][ship] > dist[x][ship] + t) {\n                            dist[y][ship] = dist[x][ship] + t;\n                            q.push({-dist[y][ship],{y,ship}});\n                        }\n                    }\n                }\n            }\n        }\n        int ans = INF;\n        REP (j,n) ans = min(ans,dist[goal][j]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,(int)INF);\n        dp[0][v[0]]=0;\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 210;\nconst int MAX_R = 1010;\nconst int INF = 100000;\nint N, M, R;\nint dS[MAX_N][MAX_N];  // 海路\nint dL[MAX_N][MAX_N];  // 陸路\n// dp[i][j] := 船がjの場所にあって，z[0], z[1], ..., z[i]までの経過時間\nint dp[MAX_R][MAX_N];\nint z[MAX_R];\n\nvoid warshall_floyd(int d[MAX_N][MAX_N])\n{\n    for (int k = 0; k < N; k++)\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++)\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n}\n\nint main()\n{\n    while (cin >> N >> M, N || M) {\n        // dL,dSの初期化\n        for (int i = 0; i < N; i++)\n            for (int j = 0; j < N; j++) {\n                dp[i][j] = INF;\n                if (i == j)\n                    dL[i][j] = dS[i][j] = 0;\n                else\n                    dL[i][j] = dS[i][j] = INF;\n            }\n\n        // Input\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char c;\n\n            cin >> x >> y >> t >> c;\n            x--, y--;\n\n            if (c == 'S' && dS[x][y] > t) // 海路\n                dS[x][y] = dS[y][x] = t;\n            else if (c == 'L' && dL[x][y] > t) // 陸路\n                dL[x][y] = dL[y][x] = t;\n        }\n\n        cin >> R;\n        for (int i = 0; i < R; i++) {\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // Warshall-Floyd\n        warshall_floyd(dL);\n        warshall_floyd(dS);\n\n        // dpの初期化\n        for (int i = 0; i < R; i++)\n            for (int j = 0; j < N; j++)\n                dp[i][j] = INF;\n\n        dp[0][z[0]] = 0;\n        for (int i = 0; i < R - 1; i++) {\n            for (int j = 0; j < N; j++) {\n                int from = z[i], to = z[i + 1];\n\n                // とりえない状態\n                if (dp[i][j] == INF)\n                    continue;\n\n                // 陸路のみを使う場合\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dL[from][to]);\n\n                // 陸路+海路を使う場合\n                for (int k = 0; k < N; k++)\n                    dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dL[from][j] +\n                                       dS[j][k] + dL[k][to]);\n            }\n        }\n\n        int ans = INF;\n        for (int i = 0; i < N; i++)\n            ans = min(ans, dp[R - 1][i]);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Edge {\n  int to, t;\n  Edge() {}\n  Edge(int to, int t) : to(to), t(t) {}\n};\n\nstruct State {\n  int p, s, r, cost;\n  State() {}\n  State(int p, int s, int r, int cost)\n    : p(p), s(s), r(r), cost(cost) {}\n  bool operator < (const State &_s) const {\n    if(cost != _s.cost) return cost > _s.cost;\n    if(r != _s.r) return r > _s.r;\n    if(p != _s.p) return p > _s.p;\n    return s > _s.s;\n  }\n};\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\nint N, M, R;\nvector<Edge> E[MAX_N][2];\nvector<int> Z;\nbool vis[MAX_N][MAX_N][MAX_R];\n\nvoid init() {\n  for(int i = 0; i < MAX_N; ++i) {\n    E[i][0].clear();\n    E[i][1].clear();\n  }\n  Z.clear();\n}\n\nint solve() {\n  for(int i = 0; i < N; ++i) {\n    for(int j = 0; j < N; ++j) {\n      for(int k = 0; k < R; ++k) {\n\tvis[i][j][k] = false;\n      }\n    }\n  }\n\n  priority_queue<State> que;\n  State s(Z[0], Z[0], 1, 0);\n  que.push(s);\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(s.r == R && s.p == Z[R-1]) return s.cost;\n    if(vis[s.p][s.s][s.r]) continue;\n    vis[s.p][s.s][s.r] = true;\n    for(int j = 0; j <= (s.p == s.s); ++j) {\n      for(int i = 0; i < E[s.p][j].size(); ++i) {\n\tEdge &e = E[s.p][j][i];\n\tState t(e.to, (j ? e.to : s.s), s.r+(Z[s.r] == e.to), s.cost+e.t);\n\tif(vis[t.p][t.s][t.r]) continue;\n\tque.push(t);\n      }\n    }\n  }\n  return -1;\n}\n\nint main() {\n  while(cin >> N >> M && (N | M)) {\n    init();\n    for(int i = 0; i < M; ++i) {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      bool isS = (sl == 'S');\n      E[x][isS].push_back(Edge(y,t));\n      E[y][isS].push_back(Edge(x,t));\n    }\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      int z;\n      cin >> z;\n      Z.push_back(z-1);\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge{\n  int src, dest; Weight weight;\n  //bool operator < (const Edge &rhs) const {return weight > rhs.weight;}\n};\n//(Edge){src, dest, weight}でインスタンス化できる\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n// Dijkstra (Verified: AOJ2005)\n// dの要素数は頂点数と等しくあるべき．\nvoid dijkstra(Graph &g, Array &d, int s) {\n  fill(d.begin(), d.end(), INF);\n  d[s] = 0;\n  typedef pair<Weight,int> P;\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  while (!que.empty()) {\n    Weight dist = que.top().first;\n    int v = que.top().second;\n    que.pop();\n    if (d[v] < dist) continue;\n    REP(i, g[v].size()) {\n      Edge e = g[v][i];\n      if (d[e.dest] > d[v] + e.weight) {\n        d[e.dest] = d[v] + e.weight;\n        que.push(P(d[e.dest], e.dest));\n      }\n    }\n  }\n}\n\n\nint uf[256];\nvoid init(){\n  REP(i,256){\n    uf[i]=-1;\n  }\n}\n\nint root(int i){\n  if(uf[i] < 0) return i;\n  return uf[i] = root(uf[i]);\n}\n\nvoid join(int i,int j){\n  int ri=root(i);\n  uf[ri]=j;\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n)break;\n    init();\n    vector<int> x(m);\n    vector<int> y(m);\n    vector<int> t(m);\n    vector<string> sl(m);\n    vector<bool> is_port(n);\n    REP(i,m){\n      cin>>x[i]>>y[i]>>t[i]>>sl[i];\n      --x[i];--y[i];\n      if(sl[i]==\"L\"){\n        join(x[i],y[i]);\n      }else{\n        is_port[x[i]] = true;\n        is_port[y[i]] = true;\n      }\n    }\n    map<int,pair<int,int>> isl;\n    REP(i,n){\n      auto p = isl[root(i)];\n      if (is_port[i])\n        ++p.first;\n      ++p.second;\n      isl[root(i)] = p;\n    }\n    int isl_n = isl.size();\n    map<int,int> beg_index;\n    int old=-1;\n    for(auto p:isl){\n      auto q=p.second;\n      beg_index[p.first] = q.first * q.second;\n      if(old >= 0)\n        beg_index[p.first] += beg_index[old];\n      old = p.first;\n    }\n    Graph g(beg_index.back());\n    Array d(beg_index.back());\n    REP(i,m){\n      int rx = root(x[i]);\n      int ry = root(y[i]);\n      int beg = beg_index[rx] - isl[rx].first * isl[rx].second;\n      int ed = beg_index[ry] - isl[ry].first * isl[ry].second;\n      if (sl[i] == \"L\") {\n        REP(j,isl[rx].first) {\n          int bix = beg + j*isl[rx].second + x[i];\n          int eix = ed + j*isl[ry].second + y[i];\n          g[bix].push_back({bix,eix,t[i]}); \n          g[eix].push_back({eix,bix,t[i]}); \n        }\n      } else {\n        REP(j,isl[rx].first)REP(k,isl[ry].first) {\n          int bix = beg + j*isl[rx].second + x[i];\n          int eix = ed + k*isl[ry].second + y[i];\n          g[bix].push_back({bix,eix,t[i]});\n          g[eix].push_back({eix,bix,t[i]});\n        }\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>  \n#include<cstring>  \n#include<algorithm>  \nusing namespace std;  \ntypedef long long ll;  \nconst ll inf=0x1f1f1f1f1f1f1f1f;.   \nconst ll maxn=205;  \nll land[maxn][maxn],sea[maxn][maxn],num[maxn*5],cost[maxn*5][maxn];  \nvoid init(int n)  \n{  \n    memset(land,inf,sizeof(land));  \n    memset(sea,inf,sizeof(sea));  \n    memset(cost,inf,sizeof(cost));  \n    for(ll i=1;i<=n;++i)  \n    {  \n        sea[i][i]=land[i][i]=0;  \n    }  \n}  \nll slove(ll n,ll m,ll w)  \n{  \n    for(ll k=1;k<=n;++k) \n    {  \n        for(ll i=1;i<=n;++i)  \n        {  \n            for(ll j=1;j<=n;++j)  \n            {  \n                sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);  \n                land[i][j]=min(land[i][j],land[i][k]+land[k][j]);  \n            }  \n        }  \n    }  \n    cost[1][num[1]]=0;  \n    for(ll i=1;i<=w;++i) \n    {  \n        for(ll j=1;j<=n;++j)  \n        {  \n            cost[i][j]=min(cost[i][j],cost[i-1][j]+land[num[i-1]][num[i]]);  \n            for(ll k=1;k<=n;++k)\n            {  \n                cost[i][k]=min(cost[i][k],  \n                cost[i-1][j]+land[num[i-1]][j]+sea[j][k]+land[k][num[i]]);  \n            }  \n        }  \n    }  \n    ll ans=inf;  \n    for(ll i=1;i<=n;++i) \n    {  \n        ans=min(ans,cost[w][i]);  \n    }  \n    return ans;  \n}  \nint main()  \n{  \n    ll n,m;  \n    while(scanf(\"%lld%lld\",&n,&m),n|m)  \n    {  \n        init(n);  \n        for(ll i=0;i<m;++i)  \n        {  \n            ll a,b,c;char ch[10];  \n            scanf(\"%lld%lld%lld%s\",&a,&b,&c,ch);  \n            if(ch[0]=='S')  \n            {  \n                sea[a][b]=sea[b][a]=min(sea[a][b],c);  \n            }  \n            else  \n            {  \n                land[a][b]=land[b][a]=min(land[a][b],c);  \n            }  \n        }  \n        ll w;  \n        scanf(\"%lld\",&w);  \n        for(ll i=1;i<=w;++i)  \n        {  \n            scanf(\"%lld\",&num[i]);\n        }  \n        printf(\"%lld\\n\",slove(n,m,w));  \n    }  \n    return 0;  \n} "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n    }\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> prev(n, INF);\n    prev[route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      vector<int> d(n*n, INF);\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n) if(prev[j]!=INF){\n        int idx = route[i]*n + j;\n        pq.push(mp(prev[j], idx));\n        d[idx] = prev[j];\n      }\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n      rep(j,n) prev[j] = d[route[i+1]*n + j];\n    }\n    cout << *min_element(all(prev)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nlong long dis1[210][210];\nlong long dis2[210][210];\nlong long dp[2][210];\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    rep (i, n) rep (j, n) dis1[i][j] = 1e18;\n    rep (i, n) rep (j, n) dis2[i][j] = 1e18;\n    rep (i, n) dis1[i][i] = 0;\n    rep (i, n) dis2[i][i] = 0;\n    rep (i, m) {\n      long long x, y, t;\n      string sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if (sl == \"L\") dis1[x][y] = dis1[y][x] = min(dis1[y][x], t);\n      else dis2[x][y] = dis2[y][x] = min(dis2[y][x], t);\n    }\n    rep (k, n) rep (i, n) rep (j, n) dis1[i][j] = min(dis1[i][j], dis1[i][k] + dis1[k][j]);\n    rep (k, n) rep (i, n) rep (j, n) dis2[i][j] = min(dis2[i][j], dis2[i][k] + dis2[k][j]);\n    int r, p;\n    cin >> r >> p;\n    --p;\n    rep (i, 2) rep (j, n) dp[i][j] = 1e18;\n    dp[0][p] = 0;\n    rep (_, r - 1) {\n      int q;\n      cin >> q;\n      --q;\n      rep (i, n) rep (j, n) dp[1][j] = min(dp[1][j], dp[0][i] + dis1[p][i] + dis2[i][j] + dis1[j][q]);\n      rep (i, n) dp[1][i] = min(dp[1][i], dp[0][i] + dis1[p][q]);\n      rep (i, n) dp[0][i] = dp[1][i];\n      rep (i, n) dp[1][i] = 1e18;\n      p = q;\n    }\n    long long res = 1e18;\n    rep (i, n) res = min(res, dp[0][i]);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf  1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nll l[201][201];\nll s[201][201];\nll dp[1001][201];\n\n\nint main(){\n\tint n,m,r;\n\twhile(cin >> n >> m && n!=0){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tfor(int j=0;j<200;j++){\n\t\t\t\tl[i][j] = inf;\n\t\t\t\ts[i][j] = inf;\n\t\t\t\tif(i==j){\n\t\t\t\t\tl[i][j] = 0;\n\t\t\t\t\ts[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x,y;\n\t\t\tll t;\n\t\t\tchar c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(c=='L'){\n\t\t\t\tl[x][y] = min(l[x][y],t);\n\t\t\t\tl[y][x] = min(l[x][y],t);\n\t\t\t}else{\n\t\t\t\ts[x][y] = min(s[x][y],t);\n\t\t\t\ts[y][x] = min(s[x][y],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tl[i][j] = min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j] = min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdp[i][j] = inf;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=1;i<r;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(j==k) dp[i][j] = min(dp[i][j],dp[i-1][k] + l[z[i-1]][z[i]]);\n\t\t\t\t\telse dp[i][j] = min(dp[i][j],dp[i-1][k]+l[z[i-1]][k]+s[k][j]+l[j][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = inf;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tans = min(ans,dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := テゥツ崢?ゥツ?催・ツ??\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      if(dp[i][j] == inf)continue;\n\n\t      //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t      dp[i+1][j] = min(dp[i+1][j],\n\t\t\t       dp[i][j]+LG[v[i]][v[i+1]]);\n\t      //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl; \n\t      rep(k,N)\n\t\t{\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t\t   dp[i][j] + SG[j][k] + LG[v[i]][j] + LG[k][v[i+1]]);\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t      \n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long int lnt;\ntypedef pair<lnt,lnt> P;\nconst lnt INF = 0xffffffffffff;\nlnt n,m,x,y,z,s;\nlnt dl[200][200];\nlnt ds[200][200];\nlnt vis[1000];\nlnt ans[200][1000];\nchar str[10];\nint main()\n{while(1){\n\tcin>>n>>m;\n\tif(!n&&!m) return 0;\n\t//for(int i=0;i<200;i++) {\n\t//\tfor(int j=0;j<1000;j++) {\n\t//\t\tif(j<200){\n\t//\t\t\tdl[i][j]=INF;\n\t//\t\t\tds[i][j]=INF;\n\t//\t\t}\n\t//\t\tans[i][j]=INF;\n\t//\t}\n\t//}\n\tfill(dl[0],dl[200]+200,INF);\n\tfill(ds[0],ds[200]+200,INF);\n\tfill(ans[0],ans[200]+1000,INF);\n\tfor(int i=0;i<n;i++) dl[i][i]=ds[i][i]=0;\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%lld%lld%lld%s\",&x,&y,&z,str);\n\t\tx--; y--;\n\t\tif(*str=='L') dl[x][y]=dl[y][x]=z;\n\t\telse ds[x][y]=ds[y][x]=z;\n\t}\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdl[i][j]=min(dl[i][j],dl[i][k]+dl[k][j]);\n\t\t\t\tds[i][j]=min(ds[i][j],ds[i][k]+ds[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcin>>s;\n\tfor(lnt i=0;i<s;i++){\n\t\tcin>>vis[i];\n\t\tvis[i]--;\n\t}\n\tans[vis[0]][0]=0;\n\tfor(int i=1;i<s;i++){\n\t\tif(i==1){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tans[j][1]=ds[vis[0]][j]+dl[j][vis[1]];\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int j=0;j<n;j++){//vis[i-1]????????????j????????????k ?????? vis[i]\n\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\tif(j==k) ans[k][i]=min(ans[k][i],ans[j][i-1]+dl[vis[i-1]][vis[i]]);\n\t\t\t\t\telse ans[k][i]=min(ans[k][i],ans[j][i-1]+dl[vis[i-1]][j]+ds[j][k]+dl[k][vis[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlnt res=INF;\n\tfor(int i=0;i<n;i++) res=min(res,ans[i][s-1]);\n\tcout<<res<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n \n#define INF 1e8\n#define MAX_V 256\n#define MAX_R 1024\nint dl[MAX_V][MAX_V];  //  d[u][v]表示&#36793;e=(u,v)的&#26435;&#20540;，不存在的&#26102;候等于无&#31351;大或者d[i][i] = 0\nint ds[MAX_V][MAX_V];\nint z[MAX_R];\nint dp[MAX_R][MAX_V];  // dp[i][j] := 已&#32463;去了第i个&#38215;子后，船停在第j个&#38215;子里\nint N;                 //  &#39030;点数\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\n    int M;\n    while (cin >> N >> M , N || M)\n    {\n//         memset(dl, 0x3f, sizeof(dl));\n//         memset(ds, 0x3f, sizeof(ds));\n        for (int i = 0; i < N; ++i)\n        {\n            for (int j = 0; j < N; ++j)\n            {\n                if (i == j)\n                {\n                    dl[i][j] = ds[i][j] = 0;\n                }\n                else\n                {\n                    dl[i][j] = ds[i][j] = INF;\n                }\n            }\n        }\n \n        for (int i = 0; i < M; ++i)\n        {\n            int x, y, t;\n            char s;\n            cin >> x >> y >> t >> s;\n            --x; --y;\n            if (s == 'L')\n            {\n                dl[x][y] = min(dl[x][y], t);\n                dl[y][x] = dl[x][y];\n            }\n            else\n            {\n                ds[x][y] = min(ds[x][y], t);\n                ds[y][x] = ds[x][y];\n            }\n        }\n         \n        int R;\n        cin >> R;\n        for (int i = 0; i < R; ++i)\n        {\n            cin >> z[i];\n            --z[i];\n        }\n \n        // warshall_floyd\n        for (int k = 0; k < N; ++k)\n        {\n            for (int i = 0; i < N; ++i)\n            {\n                for (int j = 0; j < N; ++j)\n                {\n                    dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n                    ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n        // end of warshall_floyd\n \n        // dp\n        // 尼&#29595;3个0x3f3f3f3f加起来溢出了\n        //memset(dp, 0x3f, sizeof(dp));\n        for (int i = 0; i < R; ++i)\n        {\n            for (int j = 0; j < N; ++j)\n            {\n                dp[i][j] = INF;\n            }\n        }\n        for (int i = 0; i < N; ++i)\n        {\n            // 去了首个&#38215;子后，船放在第i个&#38215;子里\n                        // 坐船去  // 坐11路&#36710;回来\n            dp[0][i] = ds[z[0]][i] + dl[i][z[0]];\n        }\n        for (int i = 1; i < R; ++i)\n        {\n            for (int j = 0; j < N; ++j)\n            {\n                for (int k = 0; k < N; ++k)\n                {\n                    if (j != k)\n                    {\n                        //                          i-1站     + 从i-1站走旱路去j+ 从j走水路去k+从k走旱路去i\n                        dp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[z[i - 1]][j] + ds[j][k] + dl[k][z[i]]);\n                    }\n                    else\n                    {\n                        // j == k                   i-1站     + 从i-1站走旱路去i\n                        dp[i][j] = min(dp[i][j], dp[i - 1][j] + dl[z[i - 1]][z[i]]);\n                    }\n                }\n            }\n        }\n \n        cout << *min_element(dp[R - 1], dp[R - 1] + N) << endl;\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P; //to, cost\n\nconst int N = 200;\nconst int INF = 100000000;\n\nclass State{\npublic:\n  int p, t, sp;\n  State(){}\n  State(int p, int t, int sp) : p(p), t(t), sp(sp) {}\n  bool operator < (const State& s) const { return t > s.t; }\n};\n\nvector<P> G[2][N];\nint vis[N][N];//pos, ship\nint n, m, r, pos;\n\nvoid dijkstra(int s){\n  priority_queue<State> que;\n  State u, v;\n  for(int i=0;i<n;i++) que.push(State(s, vis[s][i], i));\n  while(!que.empty()){\n    u = que.top();\n    que.pop();\n    if(vis[u.p][u.sp] < u.t) continue;\n    for(int i=0;i<G[0][u.p].size();i++){\n      int np = G[0][u.p][i].first;\n      int nc = G[0][u.p][i].second + u.t;\n      if(vis[np][u.sp] > nc){\n        vis[np][u.sp] = nc;\n        que.push(State(np, nc, u.sp));\n      }\n    }\n    if(u.p == u.sp){\n      for(int i=0;i<G[1][u.p].size();i++){\n        int np = G[1][u.p][i].first;\n        int nc = G[1][u.p][i].second + u.t;\n        if(vis[np][np] > nc){\n          vis[np][np] = nc;\n          que.push(State(np, nc, np));\n        }\n      }\n    }\n  }\n}\n\nmain(){\n  while(cin >> n >> m && (n|m)){\n    for(int i=0;i<N;i++){\n      G[0][i].clear();\n      G[1][i].clear();\n    }\n    for(int i=0;i<m;i++){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      x--; y--;\n      if(sl == 'L'){\n        G[0][x].push_back(P(y, t));\n        G[0][y].push_back(P(x, t));\n      }else{\n        G[1][x].push_back(P(y, t));\n        G[1][y].push_back(P(x, t));\n      }\n    }\n    fill(vis[0], vis[N], INF);\n    cin >> r;\n    cin >> pos;\n    pos--;\n    vis[pos][pos] = 0;\n    dijkstra(pos);\n    for(int i=1;i<r;i++){\n      cin >> pos;\n      pos--;\n      if(i+1 >= r) break;\n      for(int j=0;j<n;j++){\n        if(pos == j) continue;\n        for(int k=0;k<n;k++) vis[j][k] = INF;\n      }\n      dijkstra(pos);\n    }\n    int ans = INF;\n    for(int j=0;j<n;j++) ans = min(ans, vis[pos][j]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[201];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n   \n    dp[1][1]=0;\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef TIII state;\nint INF;\nint distS[222][222];\nint distL[222][222];\nint z[1111];\nint DP[2][222];\n\nint main(){\n\tINF = 500000000;\n\twhile(1){\n\t\tint n,m,r;\n\t\tcin>>n>>m;\n\t\tif(n==0)return 0;\n\t\tREP(i,n)REP(j,n)distS[i][j] = INF;\n\t\tREP(i,n)REP(j,n)distL[i][j] = INF;\n\t\tREP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--, y--;\n\t\t\tif(sl=='L')distL[y][x] = distL[x][y] = min(distL[x][y], t);\n\t\t\telse distS[y][x] = distS[x][y] = min(distS[x][y], t);\n\t\t}\n\t\tREP(i,n)distL[i][i] = 0;\n\t\tREP(i,n)distS[i][i] = 0;\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,i){\n\t\t\t\t\tdistL[i][j] = distL[j][i] = min(distL[i][j], distL[i][k] + distL[k][j]);\n\t\t\t\t\tdistS[i][j] = distS[j][i] = min(distS[i][j], distS[i][k] + distS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>r;\n\t\tREP(i,r){\n\t\t\tscanf(\"%d\", &z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\tREP(i,n)DP[0][i] = INF;\n\t\tDP[0][z[0]]=0;\n\t\tFOR(i,1,r){\n\t\t\tREP(j,n)DP[i%2][j]=INF;\n\t\t\tREP(j,n){\n\t\t\t\tREP(k,n){\n\t\t\t\t\tif(j==k)DP[i%2][k] = min(DP[i%2][k], DP[(i+1)%2][j]+distL[z[i-1]][z[i]]);\n\t\t\t\t\telse DP[i%2][k] = min(DP[i%2][k], DP[(i+1)%2][j]+distL[z[i-1]][j]+distS[j][k]+distL[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=INF;\n\t\tREP(i,n)ret = min(ret, DP[(r+1)%2][i]);\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define inf (int)1e8\nusing namespace std;\n\nint n, m, r;\nint dis[205][205][2] = {0}, dp[1005][205];\nvector<int> z;\n\nint solve();\n\nint main() {\n  while(1) {\n    cin >> n >> m;\n    if(n + m == 0) break;\n    for(int t = 0; t < 2; ++t)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j) dis[i][j][t] = inf;\n    for(int t = 0; t < 2; ++t)\n      for(int i = 0; i < n; ++i) dis[i][i][t] = 0;\n    for(int i = 0; i < m; ++i) {\n      int x, y, t;\n      string s;\n      cin >> x >> y >> t >> s;\n      --x, --y;\n      dis[x][y][s == \"L\"] = min(dis[x][y][s == \"L\"], t);\n      dis[y][x][s == \"L\"] = min(dis[y][x][s == \"L\"], t);\n    }\n    cin >> r;\n    z.resize(r);\n    for(int i = 0; i < r; ++i) {\n      cin >> z[i];\n      --z[i];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}\n\nint solve() {\n  if(r == 1) return 0;\n  int ans = inf;\n  // WF\n  for(int t = 0; t < 2; ++t)\n    for(int k = 0; k < n; ++k)\n      for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n          dis[i][j][t] = min(dis[i][j][t],\n                             dis[i][k][t] + dis[k][j][t]);\n  for(int i = 0; i < r; ++i)\n    for(int j = 0; j < n; ++j) dp[i][j] = inf;\n  for(int i = 0; i < n; ++i) dp[0][i] = dis[z[0]][i][0];\n  for(int i = 1; i < r; ++i)\n    for(int j = 0; j < n; ++j) {\n      dp[i][j] = min(dp[i][j],\n                     dp[i - 1][j] + dis[z[i - 1]][z[i]][1]);\n      for(int k = 0; k < n; ++k) {\n        dp[i][j] = min(dp[i][j],\n                       dp[i - 1][k] + dis[z[i - 1]][k][1] +\n                           dis[k][j][0] + dis[j][z[i]][1]);\n        if(i == r - 1) ans = min(ans, dp[i][j]);\n      }\n    }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define inf 1e8\n\nusing namespace std;\n\nint n, m, s[202][202], h[202][202], dp[202][202], l[202];\n\nint main()\n{\n\tint i, j, k, x, y, z;\n\tchar c[2];\n\twhile (scanf(\"%d%d\", &n, &m) && (n || m))\n\t{\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tfill(h[i], h[i] + n + 1, inf);\n\t\t\tfill(s[i], s[i] + n + 1, inf);\n\t\t\tfill(dp[i], dp[i] + n + 1, inf);\n\t\t\th[i][i] = s[i][i] = 0;\n\t\t}\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%s\", &x, &y, &z, c);\n\t\t\tif (c[0] == 'L')\n\t\t\t{\n\t\t\t\th[y][x] = min(h[y][x], z);\n\t\t\t\th[x][y] = h[y][x];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[y][x] = min(s[y][x], z);\n\t\t\t\ts[x][y] = s[y][x];\n\t\t\t}\n\t\t}\n\t\tfor (k = 1; k <= n; k++)\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t\t{\n\t\t\t\t\th[i][j] = min(h[i][j], h[i][k] + h[k][j]);\n\t\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++)\n\t\t\tscanf(\"%d\", &l[i]);\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tdp[0][j] = s[l[0]][j] + h[j][l[0]];\n\t\tfor (i = 1; i < m; i++)\n\t\t{\n\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tfor (k = 1; k <= n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + h[l[i-1]][j] + s[j][k] + h[k][l[i]]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][k] + h[l[i-1]][l[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *min_element(dp[m-1] + 1, dp[m-1] + n + 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 220\n#define MAX_R 1020\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q2;\nvector<tuple<long long, long long, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N], DIST2[MAX_N];\nlong long COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nlong long PATH[MAX_N][MAX_N][MAX_N];\nlong long DP[MAX_R][MAX_N];\nlong long cnt;\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n\tcnt = 0;\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = min(PATH[i][j][k], DIST[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tlong long start = travel[i];\n\t\t\t\tlong long goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1001,1001,INF);\n        rep(i,n){\n            if(i == 0){\n                rep(k,r)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define inf 1e8\n\nusing namespace std;\n\nint n, m, s[202][202], h[202][202], dp[1024][202], l[1024];\n\nint main()\n{\n\tint i, j, k, x, y, z;\n\tchar c[2];\n\twhile (scanf(\"%d%d\", &n, &m) && (n || m))\n\t{\n\t\tfor (i = 1; i <= n; i++)\n\t\t{\n\t\t\tfill(h[i], h[i] + n + 1, inf);\n\t\t\tfill(s[i], s[i] + n + 1, inf);\n\t\t\tfill(dp[i], dp[i] + n + 1, inf);\n\t\t\th[i][i] = s[i][i] = 0;\n\t\t}\n\t\tfor (i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%s\", &x, &y, &z, c);\n\t\t\tif (c[0] == 'L')\n\t\t\t{\n\t\t\t\th[y][x] = min(h[y][x], z);\n\t\t\t\th[x][y] = h[y][x];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\ts[y][x] = min(s[y][x], z);\n\t\t\t\ts[x][y] = s[y][x];\n\t\t\t}\n\t\t}\n\t\tfor (k = 1; k <= n; k++)\n\t\t\tfor (i = 1; i <= n; i++)\n\t\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t\t{\n\t\t\t\t\th[i][j] = min(h[i][j], h[i][k] + h[k][j]);\n\t\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++)\n\t\t\tscanf(\"%d\", &l[i]);\n\t\tfor (j = 1; j <= n; j++)\n\t\t\tdp[0][j] = s[l[0]][j] + h[j][l[0]];\n\t\tfor (i = n; i <= m; i++)\n\t\t\tfill(dp[i], dp[i] + n + 1, inf);\n\t\tfor (i = 1; i < m; i++)\n\t\t{\n\t\t\tfor (j = 1; j <= n; j++)\n\t\t\t{\n\t\t\t\tfor (k = 1; k <= n; k++)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j] + h[l[i-1]][j] + s[j][k] + h[k][l[i]]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][k] + h[l[i-1]][l[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", *min_element(dp[m-1] + 1, dp[m-1] + n + 1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nconst int INF  = 10000 * 10000;\nconst int MAXN = 210;\n\nint l_dist[MAXN][MAXN];\nint s_dist[MAXN][MAXN];\nint dp[MAXN][MAXN];\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, R;\n\n  while (cin >> N >> M && N + M){\n    fill(&l_dist[0][0], &l_dist[0][0] + MAXN * MAXN, INF);\n    fill(&s_dist[0][0], &s_dist[0][0] + MAXN * MAXN, INF);\n    fill(&dp[0][0], &dp[0][0] + MAXN * MAXN, INF);\n\n    REP(i, N){\n      l_dist[i][i] = 0;\n      s_dist[i][i] = 0;\n    }\n\n    REP(i, M){\n      int x, y, t;\n      string sl;\n      \n      cin >> x >> y >> t >> sl; x--, y--;\n      if (sl == \"L\"){\n        l_dist[x][y] = l_dist[y][x] = min(l_dist[x][y], t);\n      } else {\n        s_dist[x][y] = s_dist[y][x] = min(s_dist[x][y], t);\n      }\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      l_dist[i][j] = min(l_dist[i][j], l_dist[i][k] + l_dist[k][j]);\n      s_dist[i][j] = min(s_dist[i][j], s_dist[i][k] + s_dist[k][j]);\n    }\n\n    cin >> R;\n    vector<int> zs(R);\n    REP(i, R){\n      cin >> zs[i]; zs[i]--;\n    }\n\n    dp[0][zs[0]] = 0;\n    \n    REP2(i, 1, R) REP(u, N) if (dp[i - 1][u] < INF){\n      // cout << i - 1 << \" \" << u << endl;\n      int cz = zs[i - 1];\n      int nz = zs[i];\n\n      dp[i][u] = min(dp[i][u], dp[i - 1][u] + l_dist[cz][nz]);\n      \n      REP(v, N){\n        dp[i][v] = min(dp[i][v], dp[i - 1][u] + l_dist[cz][u] + s_dist[u][v] + l_dist[v][nz]);\n      }\n    }\n    \n    int res = INF;\n    REP(i, N){\n      res = min(res, dp[R - 1][i]);\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define il inline\n#define RG register\n#define ll long long\n#define db double\n#define M 10010\n#define N 210\nusing namespace std;\nll disl[N][N],diss[N][N];int n,m;\nvoid link1(int u,int v,ll c){\n  disl[v][u]=disl[u][v]=min(disl[u][v],c);\n}\nvoid link2(int u,int v,ll c){\n  diss[v][u]=diss[u][v]=min(diss[u][v],c);\n}\nchar C[3];\nll dp[1010][N];int cnt,st[1010];\nint main(){\n  while(scanf(\"%d%d\",&n,&m)){\n    for(int i=1;i<=1000;++i)for(int j=1;j<=n;++j)dp[i][j]=(1<<30),dp[i][j]*=10;\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)disl[i][j]=diss[i][j]=(1<<30),disl[i][j]*=10,diss[i][j]*=10;\n    if(n==0&&m==0)break;\n    for(int i=1;i<=n;++i)disl[i][i]=diss[i][i]=0;\n    for(int i=1;i<=m;++i){\n      int u,v;ll c;scanf(\"%d%d%lld\",&u,&v,&c);\n      scanf(\"%s\",C+1);if(C[1]=='L')link1(v,u,c);\n      else link2(u,v,c);\n    }\n    for(int k=1;k<=n;++k)\n      for(int i=1;i<=n;++i)if(i!=k){\n\t  for(int j=1;j<=n;++j)if(i!=j&&j!=k){\n\t      diss[i][j]=min(diss[i][k]+diss[k][j],diss[i][j]);\n\t      disl[i][j]=min(disl[i][k]+disl[k][j],disl[i][j]);\n\t    }\n      }\n    scanf(\"%d\",&cnt);\n    for(int i=1;i<=cnt;++i)scanf(\"%d\",&st[i]);\n    st[0]=1;dp[0][1]=0;\n    for(int i=1;i<=cnt;++i){\n      for(int j=1;j<=n;++j){\n\tfor(int k=1;k<=n;++k){\n\t  dp[i][j]=min(dp[i-1][k]+disl[st[i-1]][k]+diss[k][j]+disl[j][st[i]],\n\t\t       dp[i][j]);\n\t}\n      }\n    }ll Ans(1<<30);Ans*=10;\n    for(int i=1;i<=n;++i)Ans=min(Ans,dp[cnt][i]);\n    cout<<Ans<<\"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<map>\n\n#define reps(i,f,n) for(int i = f; i <= n; ++i)\n#define rep(i,n) reps(i,0,n-1)\n#define X first\n#define Y second\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> PII;\ntypedef pair<int,PII> PIP;\n\nint N,M;\nint R;\n\nint G[256][256];\nint H[256][256];\nint z[1024];\nint g[1024][256];\n//pos, ship\n\nconst int INF = 1e8;\n\nvoid init(){\n\trep(i,1024)rep(j,256) g[i][j] = INF;\n\trep(i,256)rep(j,256)G[i][j] = H[i][j] = INF;\n\trep(i,256) G[i][i] = H[i][i] = 0;\n\trep(i,1024) z[i] = 0;\n}\n\nint main(void){\n\twhile(1){\n\t\tinit();\n\t\tint x,y,t;\n\t\tstring s;\n\t\tcin >> N >> M;\n\t\tif( N+M == 0)break;\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--;y--;\n\t\t\tif(s[0] == 'L'){\n\t\t\t\tG[x][y] = t;\n\t\t\t\tG[y][x] = t;\n\t\t\t} else {\n\t\t\t\tH[x][y] = t;\n\t\t\t\tH[y][x] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(k,N){\n\t\t\trep(i,N){\n\t\t\t\trep(j,N){\n\t\t\t\t\tG[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n\t\t\t\t\tH[i][j] = min(H[i][j], H[i][k] + H[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> R;\n\t\trep(i,R) cin >> z[i];\n\t\trep(i,R) z[i]--;\n\n\n\t\tg[0][z[0]] = 0;\n\t\trep(i,R-1){\n\t\t\trep(j,N){\n\t\t\t\tint cost = g[i][j];\n\t\t\t\t//cout << cost << \":\" << i << \":\" << j << endl;\n\t\t\t\tint cc = cost + G[z[i]][z[i+1]];\n\t\t\t\t\n\t\t\t\tif( g[i+1][j]  > cc){\n\t\t\t\t\tg[i+1][j] = cc;\n\t\t\t\t}\n\n\t\t\t\tcc = cost + G[z[i]][j] + H[j][z[i+1]];\n\t\t\t\tif(g[i+1][z[i+1]] > cc ){\n\t\t\t\t\tg[i+1][z[i+1]] = cc;\n\t\t\t\t}\n\n\t\t\t\trep(k,N){\n\t\t\t\t\tcc = G[z[i]][j] + H[j][k] + G[k][z[i+1]]+cost;\n\t\t\t\t\tif(g[i+1][k] > cc){\n\t\t\t\t\t\tg[i+1][k]  = cc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\t\n\t\trep(i,256){\n\t\t\tans = min(ans, g[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#define MAXN 220\n#define ll long long\nusing namespace std;\nint n,m,r;\nll mp[320][320][2],dis[320][320][2],dp[2010][320],inf;\nint id[3010];\n\nvoid pre(){\n\tmemset(dis,127/3,sizeof(dis));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) dis[i][j][0]=mp[i][j][0],dis[i][j][1]=mp[i][j][1];\n\tfor(int i=1;i<=n;i++) dis[i][i][0]=dis[i][i][1]=0;\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(i==j||j==k||k==i) continue;\n\t\t\t\tdis[i][j][0]=min(dis[i][j][0],dis[i][k][0]+dis[k][j][0]);\n\t\t\t\tdis[i][j][1]=min(dis[i][j][1],dis[i][k][1]+dis[k][j][1]);\n\t\t\t}\n}\n\nvoid DP(){\n\tmemset(dp,127/3,sizeof(dp));inf=dp[0][0];\n\tdp[1][1]=0;\n\tfor(int i=2;i<=r;i++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tint x=id[i-1],y=id[i];\n\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][k]+dis[x][y][0]);\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(dp[i-1][j]==inf) continue;\n\t\t\t\tif(x==y) dp[i][k]=dp[i-1][k];\n\t\t\t\telse dp[i][k]=min(dp[i][k],dp[i-1][j]+dis[x][j][0]+dis[j][k][1]+dis[k][y][0]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tmemset(mp,127/3,sizeof(mp));\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(!n&&!m) break;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y,z;char c;\n\t\t\tscanf(\"%d%d%d%c%c\",&x,&y,&z,&c,&c);\n\t\t\tif(c=='L') mp[x][y][0]=min(mp[x][y][0],(ll)z),mp[y][x][0]=min(mp[y][x][0],(ll)z);\n\t\t\telse mp[x][y][1]=min(mp[x][y][1],(ll)z),mp[y][x][1]=min(mp[y][x][1],(ll)z);\n\t\t}\n\t\tpre();\n\t\tscanf(\"%d\",&r);\n\t\tmemset(id,0,sizeof(id));\n\t\tfor(int i=1;i<=r;i++) scanf(\"%d\",&id[i]);\n\t\tDP();\n\t\tll ans=inf;\n\t\tfor(int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ------ Includes ------ //\n\n#include <string>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n\n// ------ Variable Definition ------ //\n\n#define INF (1 << 26)\n\n#define MAX_N 200\n#define MAX_R 1000\n\nint N, M, R, X, Y, T; char SL;\n\nint S[MAX_N][MAX_N], L[MAX_N][MAX_N]; // Graph\n\nint Short_S[MAX_N][MAX_N], Short_L[MAX_N][MAX_N]; // Shortest_Path\n\nint Z[MAX_R + 1], dp[MAX_R + 1][MAX_N]; // dp[i][j] --> i = town, j = ship\n\n\n// ------ Shortest Path Function ------ //\n\nvoid Shortest(int start, string mode)\n{\n\tint D[MAX_N]; for (int i = 0; i < MAX_N; i++) { D[i] = INF; }\n\n\tbool P[MAX_N]; for (int i = 0; i < MAX_N; i++) { P[i] = false; }\n\n\tD[start] = 0;\n\n\twhile (true)\n\t{\n\t\tint v = -1;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (P[i] == false)\n\t\t\t{\n\t\t\t\tif (v == -1)\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t\telse if (D[i] < D[v])\n\t\t\t\t{\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (v == -1) { break; }\n\n\t\tP[v] = true;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tif (mode == \"Land\")\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + L[v][i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tD[i] = min(D[i], D[v] + S[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tif (mode == \"Sea\")\n\t\t{\n\t\t\tShort_S[start][i] = D[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tShort_L[start][i] = D[i];\n\t\t}\n\t}\n}\n\n\nint main()\n{\n\t// ------ Input, Graph Construction ------ //\n\n\twhile(true)\n\t{\n\t\tcin >> N >> M;\n\n\t\tif (N == 0 && M == 0) { break; }\n\n\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t{\n\t\t\t\tS[i][j] = INF;\n\t\t\t\tL[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tShort_L[i][j] = 0;\n\t\t\t\tShort_S[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++)\n\t\t{\n\t\t\tcin >> X >> Y >> T >> SL;\n\n\t\t\tswitch (SL)\n\t\t\t{\n\t\t\tcase 'S': S[X - 1][Y - 1] = T; S[Y - 1][X - 1] = T; break;\n\t\t\tcase 'L': L[X - 1][Y - 1] = T; L[Y - 1][X - 1] = T; break;\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tcin >> Z[i]; Z[i] -= 1; // 0 - indexed\n\t\t}\n\t\t\n\t\tZ[0] = Z[1];\n\n\t\t// ------ Shortest Path ------ //\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tShortest(i, \"Land\");\n\t\t\tShortest(i, \"Sea\");\n\t\t}\n\n\t\tfor (int i = 0; i <= R; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tdp[0][Z[0]] = 0;\n\n\t\tfor (int i = 1; i <= R; i++)\n\t\t{\n\t\t\tint Land_Only = Short_L[Z[i - 1]][Z[i]];\n\n\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t{\n\t\t\t\tdp[i][k] = min(dp[i - 1][k] + Land_Only, dp[i][k]);\n\t\t\t}\n\n\t\t\tfor (int j = 0; j < N; j++)\n\t\t\t{\n\t\t\t\tif (dp[i - 1][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tint Land_1 = Short_L[Z[i - 1]][j];\n\n\t\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint Sea = Short_S[j][k];\n\n\t\t\t\t\t\tint Land_2 = Short_L[k][Z[i]];\n\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + Land_1 + Sea + Land_2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Answer = INF;\n\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tAnswer = min(Answer, dp[R][i]);\n\t\t}\n\n\t\tcout << Answer << endl;\n\t}\n\n\treturn 0;\n}\n\n// Time : O ( R * N ^ 2 + N ^ 3 )"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nconst int N = 222;\nconst int R = 1111;\n\nclass E{\n\tpublic:\n\tint to;\n\tint cost;\n\tstring kind;\n\tE(int to,int cost,string kind):to(to),cost(cost),kind(kind){}\n};\n\nint n,m;\nvector<E> edge[N];\nvector<int> move;\n\n\nbool init(){\n\tcin>>n>>m;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i].clear();\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring s;\n\t\tcin>>a>>b>>c>>s;\n\t\tedge[a].push_back(E(b,c,s));\n\t\tedge[b].push_back(E(a,c,s));\n\t}\n\t\n\tint r;\n\tcin>>r;\n\t\n\tmove.clear();\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\treturn true;\n}\n\nclass Q{\n\tpublic:\n\tint val;\n\tint pos,num,fune;\n\tQ(int pos,int num,int fune,int val):\n\t\tpos(pos),num(num),fune(fune),val(val){}\n\tbool operator<(const Q& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\nint visit[N][N];\n\nint dijk(){\n\t\n\trep(i,n+1)rep(k,n+1)visit[i][k]=0;\n\t\n\tpriority_queue<Q> que;\n\tque.push(Q(move[0],1,1,0));\n\t\n\twhile(!que.empty()){\n\t\tQ u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.pos][u.fune]>=u.num)continue;\n\t\tvisit[u.pos][u.fune]=u.num;\n\t\t\n\t\t//printf(\"**%d %d %d %d\\n\",u.pos,u.num,u.fune,u.val);\n\t\t\n\t\tint next = u.num;\n\t\tif(u.pos==move[u.num]){\n\t\t\tnext++;\n\t\t}\n\t\t\n\t\tif(next==n){\n\t\t\treturn u.val;\n\t\t}\n\t\t\n\t\tif(u.pos==u.fune){\n\t\t\trep(i,edge[u.pos].size()){\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.kind!=\"S\")continue;\n\t\t\t\tif(visit[e.to][e.to]<next)\n\t\t\t\tque.push(Q(e.to, next, e.to, u.val+e.cost));\n\t\t\t}\n\t\t}\n\t\trep(i,edge[u.pos].size()){\n\t\t\tE e = edge[u.pos][i];\n\t\t\tif(e.kind!=\"L\")continue;\n\t\t\tif(visit[e.to][u.fune]<next)\n\t\t\tque.push(Q(e.to, next, u.fune, u.val+e.cost));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint solve(){\n\treturn dijk();\n}\n\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 205\n#define maxr 1005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nint fl[maxn][maxn],fs[maxn][maxn],dp[maxr][maxn],n,m,r,a[maxn];\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m) && (n+m)>0){\n\tmemset(fl,0x3f,sizeof(fl));\n\tmemset(fs,0x3f,sizeof(fs));\n\tfor(int i=1;i<=n;i++) fs[i][i] = fl[i][i] = 0;\n\tfor(int i=1;i<=m;i++){\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tchar c;\n\t\twhile(scanf(\"%c\",&c) && (c!='S'&&c!='L'));\n\t\tif(c == 'S') fs[u][v] = fs[v][u] = min(fs[u][v],w);\n\t\telse fl[u][v] = fl[v][u] = min(fl[u][v],w);\n\t}\n\tscanf(\"%d\",&r);\n\tfor(int i=1;i<=r;i++) scanf(\"%d\",&a[i]);\n\tfor(int k=1;k<=n;k++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfl[i][j] = min(fl[i][j],fl[i][k] + fl[k][j]);\n\t\t\t\tfs[i][j] = min(fs[i][j],fs[i][k] + fs[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(dp,0x3f,sizeof(dp));\n\ta[0] = 1;\n\tfor(int i=1;i<=n;i++) dp[0][i] = fs[1][i] + fl[i][1];\n\tfor(int i=1;i<=r;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tll res;\n\t\t\t\tif(j==k) res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][a[i]];\n\t\t\t\telse res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][k] + (ll)fs[k][j] + (ll)fl[j][a[i]];\n\t\t\t\tdp[i][j] = min((ll)dp[i][j],res);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = inf;\n\tfor(int i=1;i<=n;i++){\n\t\tans = min(ans,dp[r][i]);\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\nconst ll  INF  = 1LL << 50;\nconst int MAXN = 210;\nconst int MAXR = 1010;\n\nll l_dist[MAXN][MAXN];\nll s_dist[MAXN][MAXN];\nll dp[MAXR][MAXN];\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N, M, R;\n\n  while (cin >> N >> M && N + M){\n    fill(&l_dist[0][0], &l_dist[0][0] + MAXN * MAXN, INF);\n    fill(&s_dist[0][0], &s_dist[0][0] + MAXN * MAXN, INF);\n    fill(&dp[0][0], &dp[0][0] + MAXR * MAXN, INF);\n\n    REP(i, N){\n      l_dist[i][i] = 0;\n      s_dist[i][i] = 0;\n    }\n\n    REP(i, M){\n      int x, y, t;\n      string sl;\n      \n      cin >> x >> y >> t >> sl; x--, y--;\n      if (sl == \"L\"){\n        l_dist[x][y] = l_dist[y][x] = min(l_dist[x][y], (ll)t);\n      } else {\n        s_dist[x][y] = s_dist[y][x] = min(s_dist[x][y], (ll)t);\n      }\n    }\n\n    REP(k, N) REP(i, N) REP(j, N){\n      l_dist[i][j] = min(l_dist[i][j], l_dist[i][k] + l_dist[k][j]);\n      s_dist[i][j] = min(s_dist[i][j], s_dist[i][k] + s_dist[k][j]);\n    }\n\n    cin >> R;\n    vector<int> zs(R);\n    REP(i, R){\n      cin >> zs[i]; zs[i]--;\n    }\n\n    dp[0][zs[0]] = 0;\n    \n    REP2(i, 1, R) REP(u, N) if (dp[i - 1][u] < INF){\n      // cout << i - 1 << \" \" << u << endl;\n      int cz = zs[i - 1];\n      int nz = zs[i];\n\n      dp[i][u] = min(dp[i][u], dp[i - 1][u] + l_dist[cz][nz]);\n      \n      REP(v, N){\n        dp[i][v] = min(dp[i][v], dp[i - 1][u] + l_dist[cz][u] + s_dist[u][v] + l_dist[v][nz]);\n      }\n    }\n    \n    ll res = INF;\n    REP(i, N){\n      res = min(res, dp[R - 1][i]);\n    }\n    cout << res << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#define RG register\n#define IL inline\n#define pi acos(-1.0)\n\n#define inf 1e8\nusing namespace std;\n\nint n,m,R;\nint land[300][300],water[300][300],dp[1005][300];\nint a[1005];\n\nvoid pre(){\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++){\n          land[i][j]=land[j][i]=inf;\n          water[i][j]=water[j][i]=inf;\n        }\n    for(int i=1;i<=n;i++)\n         land[i][i]=0,water[i][i]=0;\n}\n\nvoid floyd(){\n    for(int k=1;k<=n;k++)\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=n;j++){\n                if(k==i||k==j||i==j) continue;\n                water[i][j]=min(water[i][j],water[i][k]+water[k][j]);\n                land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            }\n}\n\nint main(){\n    while(scanf(\"%d%d\",&n,&m)==2){\n     \n     if(n==0&&m==0) break;\n     pre();\n     for(int i=1;i<=m;i++){\n         int l,r; char str[10];\n         int w;\n         scanf(\"%d%d%d\",&l,&r,&w);\n         scanf(\"%s\",str);\n         if(str[0]=='L') land[l][r]=land[r][l]=min(land[r][l],w);\n         else water[l][r]=water[r][l]=min(water[r][l],w);\n    }\n    floyd();\n    scanf(\"%d\",&R);\n    for(int i=1;i<=R;i++)\n        for(int j=1;j<=n;j++)\n          dp[i][j]=inf;\n    for(int i=1;i<=R;i++)\n        scanf(\"%d\",&a[i]);\n    for(int i=1;i<=n;i++)\n      dp[1][i]=water[a[1]][i]+land[i][a[1]];//第一次出发可以将船停到任意处再坐船回到当前目标点\n   \n   for(int i=1;i<=R;++i){\n   \t\tfor(int j=1;j<=n;++j){\n   \t\t\tif(dp[i][j]!=inf){\n   \t\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+land[a[i]][a[i+1]]);\n   \t\t\t\tfor(int k=1;k<=n;++k){\n   \t\t\t\t\tdp[i+1][k]=min(dp[i+1][k],\n\t\t\t\t\tdp[i][j]+land[a[i]][j]+water[j][k]+land[a[i+1]][k]\n\t\t\t\t\t   );\n\t\t\t\t   }\n\t\t\t   }\n\t\t   }\n   }\n     int minn=inf;\n     for(int i=1;i<=n;i++)\n        minn=min(minn,dp[R][i]);\n     printf(\"%d\\n\",minn);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n,m,r,dr[200][200],ds[200][200],inf=4*1e8;\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\trep(i,n) rep(j,n) if(i!=j) dr[i][j]=inf,ds[i][j]=inf;\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tx--,y--;\n\t\t\tif(s=='L'){\n\t\t\t\tdr[x][y]=min(dr[x][y],t);\n\t\t\t\tdr[y][x]=min(dr[y][x],t);\n\t\t\t}else{\n\t\t\t\tds[x][y]=min(ds[x][y],t);\n\t\t\t\tds[y][x]=min(ds[y][x],t);\n\t\t\t}\n\t\t}\n\t\trep(i,n) rep(j,n) rep(k,n) dr[j][k]=min(dr[j][k],dr[j][i]+dr[i][k]);\n\t\trep(i,n) rep(j,n) rep(k,n) ds[j][k]=min(ds[j][k],ds[j][i]+ds[i][k]);\n\t\tcin>>r;\n\t\tint ans[200],nans[200];\n\t\trep(i,n) ans[i]=inf,nans[i]=inf;\n\t\tint v,p;\n\t\tcin>>p;\n\t\tp--;\n\t\tans[p]=0;\n\t\trep(i,r-1){\n\t\t\tcin >> v;\n\t\t\tv--;\n\t\t\trep(j,n) rep(k,n){\n\t\t\t\tif(j==k) nans[k]=min(nans[k],ans[j]+dr[p][v]);\n\t\t\t\telse nans[k]=min(nans[k],ans[j]+dr[p][j]+ds[j][k]+dr[k][v]);\n\t\t\t}\n\t\t\tp=v;\n\t\t\trep(j,n) ans[j]=nans[j],nans[j]=inf;\n\t\t}\n\t\tint aans=inf;\n\t\trep(i,n) aans=min(aans,ans[i]);\n\t\tcout << aans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 0x3f3f3f3f;\nint n, m, r;\nll dl[220][220], dw[220][220];\nll dp[1100][220];\nint a[1100];\n\nll rec(int s, int j) {\n\t// 从起点的时候，可能会提前把船开到某个地方\n\tif (s == 0) {\n\t\tdp[s][j] = dw[a[0]][j] + dl[j][a[0]];\n\t\treturn dp[s][j];\n\t}\n\tif (dp[s][j] != -1) return dp[s][j];\n\t// 直接从上一个点走陆地过来\n\tll res = dl[a[s - 1]][a[s]] + rec(s - 1, j);\n \t//也可能是到达了s - 1点后，把船开到了某个地方，然后从s - 1点走过来。\n \tfor (int k = 1; k <= n; k++) {\n \t\tres = min(res, rec(s - 1, k) + dl[a[s - 1]][k] + dw[k][j] + dl[j][a[s]]);\n \t}\n \tdp[s][j] = res;\n\treturn res;\n}\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m) != -1) {\n        if (n == 0 && m == 0) break;\n        for (int i = 1; i <= n; i++) { \n            for (int j = 1; j <= n; j++) {\n                dl[i][j] = dl[j][i] = INF;\n                dw[i][j] = dw[j][i] = INF;\n            }\n        }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdl[i][i] = 0;\n\t\t\tdw[i][i] = 0;\n\t\t}\n        \n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c; char s[20];\n\t\t\tscanf(\"%d%d%d%s\", &a, &b, &c, s);\n\t\t\tif (s[0] == 'L') \n\t\t\t\tdl[a][b] = dl[b][a] = c;\n\t\t\telse \n\t\t\t\tdw[a][b] = dw[b][a] = c;\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 0; i < r; i++) \n\t\t\tscanf(\"%d\", a + i);\n        \n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdw[i][j] = min(dw[i][j], dw[i][k] + dw[k][j]);\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll res = INF;\n        for (int i = 0; i <= r; i++) \n            for (int j = 0; j <= n; j++) \n                dp[i][j] = -1;\n        \n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tres = min(res, rec(r - 1, i));\n       \n\t\tprintf(\"%lld\\n\", res);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconst int M = 1000000007;\nconst int LM = 500000007;\n\nvoid warshallfloyd(vector<vector<int>>& d)\n{\n    int n = d.size();\n    for (int i = 0; i < n; ++i)\n        for (int j = 0; j < n; ++j)\n            for (int k = 0; k < n; ++k)\n                d[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n}\n\n\n\nint main() {\n    while (1) {\n        int n, m;\n        cin >> n >> m;\n        if (!n) return 0;\n\n        vector<vector<int>> led(n, vector<int>(n, LM));\n        vector<vector<int>> sed(n, vector<int>(n, LM));\n        for (int i = 0; i < n; ++i) {\n            led[i][i] = 0;\n            sed[i][i] = 0;\n        }\n        for (int i = 0; i < m; ++i) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            --x;\n            --y;\n            if (sl == 'L') {\n                led[x][y] = min(led[x][y], t);\n                led[y][x] = min(led[y][x], t);\n            }\n            else {\n                sed[x][y] = min(sed[x][y], t);\n                sed[y][x] = min(sed[y][x], t);\n            }\n        }\n        warshallfloyd(sed);\n        warshallfloyd(led);\n        int r;\n        cin >> r;\n        vector<int> dp(n, LM);\n        int prev;\n        cin >> prev;\n        --prev;\n        dp[prev] = 0;\n        for (int i = 0; i < r - 1; ++i) {\n            int z;\n            cin >> z;\n            --z;\n            vector<int> next(n, LM);\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < n; ++k) {\n                    next[j] = min(next[j], dp[k] + led[prev][k] + sed[k][j] + led[j][z]);\n                }\n            }\n            prev = z;\n            dp = next;\n        }\n        int ans = LM;\n        for (int i : dp) {\n            ans = min(ans, i);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#define MAXN 220\n#define ll long long\nusing namespace std;\nint n,m,r;\nll mp[320][320][2],dis[320][320][2],dp[2010][320],inf;\nint id[3010];\n\nvoid pre(){\n\tmemset(dis,127/3,sizeof(dis));\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++) dis[i][j][0]=mp[i][j][0],dis[i][j][1]=mp[i][j][1];\n\tfor(int i=1;i<=n;i++) dis[i][i][0]=dis[i][i][1]=0;\n\tfor(int k=1;k<=n;k++)\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(i==j||j==k||k==i) continue;\n\t\t\t\tdis[i][j][0]=min(dis[i][j][0],dis[i][k][0]+dis[k][j][0]);\n\t\t\t\tdis[i][j][1]=min(dis[i][j][1],dis[i][k][1]+dis[k][j][1]);\n\t\t\t}\n}\n\nvoid DP(){\n\tmemset(dp,127/3,sizeof(dp));inf=dp[0][0];\n\tdp[0][1]=0;\n\tfor(int i=1;i<=r;i++){\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tint x=id[i-1],y=id[i];\n\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][k]+dis[x][y][0]);\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tif(dp[i-1][j]==inf) continue;\n\t\t\t\tif(x==y) dp[i][k]=dp[i-1][k];\n\t\t\t\telse dp[i][k]=min(dp[i][k],dp[i-1][j]+dis[x][j][0]+dis[j][k][1]+dis[k][y][0]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile(1){\n\t\tmemset(mp,127/3,sizeof(mp));\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(!n&&!m) break;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint x,y,z;char c;\n\t\t\tscanf(\"%d%d%d%c%c\",&x,&y,&z,&c,&c);\n\t\t\tif(c=='L') mp[x][y][0]=min(mp[x][y][0],(ll)z),mp[y][x][0]=min(mp[y][x][0],(ll)z);\n\t\t\telse mp[x][y][1]=min(mp[x][y][1],(ll)z),mp[y][x][1]=min(mp[y][x][1],(ll)z);\n\t\t}\n\t\tpre();\n\t\tscanf(\"%d\",&r);\n\t\tmemset(id,0,sizeof(id));\n\t\tid[0]=1;\n\t\tfor(int i=1;i<=r;i++) scanf(\"%d\",&id[i]);\n\t\tDP();\n\t\tll ans=inf;\n\t\tfor(int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n\t\tif(ans==inf) ans=-1;\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/5\n\nint n,m,r;\nint dl[222][222];\nint ds[222][222];\nint dp[1111][222];\nint rs[1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,222)rep(j,222){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n    }\n    rep(i,1111)rep(j,222)dp[i][j]=INF;\n    rep(i,m){\n      int x,y,t; string sl;\n      cin>>x>>y>>t>>sl; x--; y--;\n      if(sl==\"L\"){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    cin>>r;\n    rep(i,r){\n      cin>>rs[i];\n      rs[i]--;\n    }\n    dp[0][rs[0]]=0;\n    rep(i,r-1){\n      int crt=rs[i],nxt=rs[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        if(crt==j){\n          rep(k,n)minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n        }\n        rep(k,n)minch(dp[i+1][k],dp[i][j]+dl[crt][j]+ds[j][k]+dl[k][nxt]);\n      }\n    }\n    int res=INF;\n    rep(j,n)minch(res,dp[r-1][j]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <queue>\n#define oo 0x3f3f3f3f\nusing namespace std;\nstruct ad\n{\n    int to, next, v, water;\n} edge[22000];\nstruct node\n{\n    int people_pos, ship_pos, cnt, water, cost;\n    bool operator < (const node t)const\n    {\n        return t.cost < cost;\n    }\n};\nint head[330], edge_num, vis[300][1100][2], k, End[1100], dist[300][1100][2], n;\nvoid Add(int x, int y, int z, int op)\n{\n    edge[edge_num].to = y;\n    edge[edge_num].v = z;\n    edge[edge_num].next = head[x];\n    edge[edge_num].water = op;\n    head[x] = edge_num++;\n}\nint spfa()\n{\n    priority_queue<node>Q;\n    node now, next;\n    now.people_pos = End[1];\n    now.ship_pos = End[1];\n    now.cnt = 1;\n    now.water = 0;\n    Q.push(now);\n\n    for(int i=1; i<=n; i++)\n        for(int j=1; j<=k; j++)\n        {\n            dist[i][j][0] = dist[i][j][1] = oo;\n            vis[i][j][0] = vis[i][j][1] = 0;\n        }\n\n    now.cost = 0;\n    dist[End[1]][1][0] = dist[End[1]][1][1] = 0;\n    vis[End[1]][1][0] = 1;\n    while(!Q.empty())\n    {\n        now = Q.top();\n        Q.pop();\n\n        for(int i=head[now.people_pos]; ~i; i=edge[i].next)\n        {\n            int v = edge[i].to;\n            int new_cnt = now.cnt;\n            if(v == End[now.cnt+1])\n                new_cnt++;\n            if(!edge[i].water)\n            {\n                if(dist[v][new_cnt][edge[i].water]>now.cost+edge[i].v)\n                {\n                    dist[v][new_cnt][edge[i].water] = now.cost+edge[i].v;\n                    if(!vis[v][new_cnt][edge[i].water])\n                    {\n                        vis[v][new_cnt][edge[i].water] = 1;\n                        next.people_pos = v;\n                        next.water = 0;\n                        next.cost = dist[v][new_cnt][edge[i].water];\n                        next.ship_pos = now.ship_pos;\n                        next.cnt = new_cnt;\n                        Q.push(next);\n                    }\n\n                }\n            }\n            else if(now.ship_pos == now.people_pos)\n            {\n                if(dist[v][new_cnt][edge[i].water]>now.cost+edge[i].v)\n                {\n                    dist[v][new_cnt][edge[i].water] = now.cost+edge[i].v;\n                    if(!vis[v][new_cnt][edge[i].water])\n                    {\n                        vis[v][new_cnt][edge[i].water] = 1;\n                        next.cost = dist[v][new_cnt][edge[i].water];\n                        next.people_pos = v;\n                        next.ship_pos = v;\n                        next.cnt = new_cnt;\n                        next.water = 1;\n                        Q.push(next);\n                    }\n\n                }\n            }\n        }\n    }\n\n    return min(dist[End[k]][k][0], dist[End[k]][k][1]);\n}\nint main()\n{\n    int m;\n    while(scanf(\"%d %d\", &n, &m), n+m)\n    {\n        memset(head, -1, sizeof(head));\n        memset(End, 0, sizeof(End));\n        edge_num = 0;\n        int u, v, w;\n        char way[5];\n        for(int i=1; i<=m; i++)\n        {\n            scanf(\"%d %d %d %s\", &u, &v, &w, way);\n            Add(u, v, w, way[0]=='S');\n            Add(v, u, w, way[0]=='S');\n        }\n\n        scanf(\"%d\", &k);\n\n        for(int i=1; i<=k; i++)\n            scanf(\"%d\", &End[i]);\n\n        printf(\"%d\\n\", spfa());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N, M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      if(G1[i][i] == INF){\n        G1[i][i] = 0;\n      }\n      if(G2[i][i] == INF){\n        G2[i][i] = 0;\n      }\n    }\n    \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        if(i != next){\n          dp[r][next] = min(dp[r][next], dp[r-1][i] + G2[i][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m,i,j,k,r,a[205],ans,map[205][205][2],dp[205][205];//map:0?????????1?°´???,dp[i][j]??¨?????°i??????????????¨j?????¶???????°???±?´?\nint main()\n{\n\twhile(~scanf(\"%d %d\",&n,&m)&&n)\n\t{\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tmap[i][j][0]=2147483647;\n\t\t\t\tmap[i][j][1]=2147483647;\n\t\t\t}\n\t\t\tmap[i][i][0]=0;\n\t\t\tmap[i][i][1]=0;\n\t\t}\n\t\tint x,y,t,o;\n\t\tchar s;\n\t\tfor(i=1;i<=m;i++)\n\t\t{\n\t\t\tscanf(\"\\n%d %d %d %c\",&x,&y,&t,&s);\n\t\t\tif(s=='L')\n\t\t\t\to=0;\n\t\t\tif(s=='S')\n\t\t\t\to=1;\n\t\t\tmap[x][y][o]=t;\n\t\t\tmap[y][x][o]=t;\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(i=1;i<=r;i++)\n\t\t\tscanf(\"%d\",&a[i]);\n\t\ta[0]=1;\n\t\t\n\t\tfor(k=1;k<=n;k++)\n\t\t{\n\t\t\tfor(i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\t{\n\t\t\t\t\tif(map[i][k][0]<2147483647&&map[k][j][0]<2147483647)\n\t\t\t\t\t\tmap[i][j][0]=min(map[i][j][0],map[i][k][0]+map[k][j][0]);\n\t\t\t\t\tif(map[i][k][1]<2147483647&&map[k][j][1]<2147483647)\n\t\t\t\t\t\tmap[i][j][1]=min(map[i][j][1],map[i][k][1]+map[k][j][1]);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=r;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t\tdp[i][j]=2147483647;\n\t\t}\n\t\tdp[0][1]=0;\n\t\tfor(i=1;i<=r;i++)\n\t\t{\n\t\t\tfor(j=1;j<=n;j++)\n\t\t\t{\n\t\t\t\tfor(k=1;k<=n;k++)\n\t\t\t\t{\n\t\t\t\t\tif(dp[i-1][k]<2147483647&&map[a[i-1]][k][0]<2147483647&&map[k][j][1]<2147483647&&map[j][a[i]][0]<2147483647)\n\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+map[a[i-1]][k][0]+map[k][j][1]+map[j][a[i]][0]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=2147483647;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tans=min(ans,dp[r][i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <list>\n#include<stack>\n#include<queue>\n#include <vector>\n#include <set>\n#include<algorithm>\n#include<math.h>\n#include<stdlib.h>\n#include<string>\n#include <functional>\n#include<fstream>\n#include<iomanip>\n#include<array>\n\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define REP(i,n) FOR((i),0,(n))\n#define LL long long\n#define CLR(a) memset((a),0,sizeof(a))\n#define SZ(x) (int((x).size()))\n#define WAITING(str) int str;std::cin>>str;\n#define DEBUGING(str) cout<<str<<endl\nusing namespace std;\n\nconst LL MOD = 1000000007;// 10^9+7\nconstexpr int INF = (1 << 25);\nconstexpr int siz = 200;\n\n\n//名前の通り。　N個の独立した要素を併合するときに使用\nclass UnionFind {\npublic:\n\tvector<int>rank, parent;\n\t//初期化\n\tUnionFind(int size) {\n\t\trank.resize(size, 0);\n\t\tparent.resize(size, 0);\n\t\tREP(i, size)parent[i] = i;\n\t}\n\t//木の根を求める\n\tint find(int x) {\n\t\tif (parent[x] == x)return x;\n\t\telse return parent[x] = find(parent[x]);\n\t}\n\t//xとyの属する集合を併合\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])\n\t\t\tparent[x] = y;\n\t\telse {\n\t\t\tparent[y] = x;\n\t\t\tif (rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t//xとyが同じ集合に属するか否か\n\tbool same(int x, int y) {\n\t\treturn (find(x) == find(y));\n\t}\n\t//parentの内容を出力\n\tvoid debug() {\n\t\tfor (auto num : parent) {\n\t\t\tcout << num << \" \";\n\t\t}\n\t\tcout << \"more:\" << endl;\n\t\tREP(i, parent.size()) {\n\t\t\tcout << find(i) << \" \";\n\n\t\t}\n\t\tcout << endl << \"more:\" << endl;\n\t\tfor (auto num : parent) {\n\t\t\tcout << num << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nstruct Stage{\n\tStage(){\n\t\tcin >> N >> M;\n\t\tif (!N)return;\n\n\t\tint x, y, t;\n\t\tstring sl;\n\t\tfor (auto& v : load)fill(v.begin(), v.end(), INF);\n\t\tfor (auto& v : sea)fill(v.begin(), v.end(), INF);\n\t\tfill(havePort.begin(), havePort.end(), false);\n\t\tREP(i, N)load[i][i] = sea[i][i] = 0;\n\t\tREP(i, M)\n\t\t{\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif (sl == \"L\") {\n\t\t\t\tload[x][y] = load[y][x] = t;\n\t\t\t\tuf.unite(x, y);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t\thavePort[x] = havePort[y] = true;\n\t\t\t}\n\t\t}\n\n\t\tint R;cin >> R;\n\t\tREP(i, R)\n\t\t{\n\t\t\tcin >> t;\n\t\t\tt--;\n\t\t\tz.push_back(t);\n\t\t}\n\t}\n\t\n\tbool is_end(){\n\t\treturn N == 0;\n\t}\n\t\n\tvoid action()\n\t{\n\t\twarshall_floyd(load);\n\t\twarshall_floyd(sea);\n\t\t\n\t\tvector<vector<int>> dp(z.size(), vector<int>(N, INF));\n\t\tdp[0][z[0]] = 0;\n\t\tFOR(i, 1, z.size()){\n\t\t\t//陸路\n\t\t\tREP(j, N)\n\t\t\t{\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + load[z[i]][z[i - 1]]);\n\t\t\t}\n\n\t\t\t//海路\n\t\t\tREP(j, N) if (havePort[j] && uf.same(j, z[i]))\n\t\t\t\tREP(k, N) if (havePort[k] && uf.same(k, z[i - 1]))\n\t\t\t{\n\t\t\t\tint fromL = z[i - 1];\n\t\t\t\tint fromS = k;\n\t\t\t\tint toS = j;\n\t\t\t\tint toL = z[i];\n\n\t\t\t\tint befTime = dp[i - 1][k];\n\t\t\t\tint timeLS = load[fromL][fromS];\n\t\t\t\tint timeSS = sea[fromS][toS];\n\t\t\t\tint timeSL = load[toS][toL];\n\n\t\t\t\tif (max(max(befTime, timeLS), max(timeSS, timeSL)) == INF)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[i][j] = min(dp[i][j], befTime + timeLS + timeSS + timeSL);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tcout << *min_element(dp.back().begin(), dp.back().end()) << endl;\n\n\t\t/*\n\t\tint bef = 0;\n\t\tint now = 0;\n\t\tfill(time.begin(), time.end(), INF);\n\t\ttime[z[0]] = 0;\n\n\t\twarshall_floyd(load);\n\t\twarshall_floyd(sea);\n\n\t\twhile (now < z.size()) {\n\t\t\tvector<int> route;\n\t\t\twhile (now < z.size() && uf.same(bef, now)) {\n\t\t\t\troute.push_back(now);\n\t\t\t\tnow++;\n\t\t\t}\n\t\t\tbef = now;\n\t\t\tupdate(route);\n\t\t}\n\t\t\n\t\tint res = INF;\n\t\tREP(i, N)if (uf.same(i, z.back()))\n\t\t{\n\t\t\tres = min(res, time[i] - load[i][z.back()]);\n\t\t}\n\t\tcout << res << endl;\n\t\t*/\n\t}\n\t\nprivate:\n\tint N, M;\n\tUnionFind uf = UnionFind(siz);//陸のセット作成\n\tarray<int, siz> time;\n\tarray<bool, siz> havePort;\n\tarray<array<int, siz>, siz> load, sea;\t\n\tvector<int> z;\n\t\n\tvoid warshall_floyd(array<array<int, siz>,siz>& edge)\n\t{\n\t\tREP(k, siz)REP(i, siz)REP(j, siz)\n\t\t\tif (edge[i][k] != INF && edge[j][k] != INF)\n\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k] + edge[k][j]);\n\t}\n\n\tvoid update(vector<int> route)\n\t{\n\t\tarray<int, siz> besttime;\n\t\tfill(besttime.begin(), besttime.end(), INF);\n\t\tREP(port, N)\n\t\t\tif (havePort[port] && uf.same(route.back(),port)) \n\t\t\t{\n\t\t\t\tbesttime[port] = act_route(port, route);\n\t\t\t}\n\t\ttime = besttime;\n\t}\n\n\tint act_route(\n\t\tconst int& port, \n\t\tconst vector<int>& route)\n\t{\n\t\tint best = INF;\n\t\tREP(i, N)if (time[i] != INF)\n\t\t{\n\t\t\tint sum = time[i];\n\t\t\tsum += sea[i][port];\n\t\t\tREP(j, route.size() - 1)\n\t\t\t{\n\t\t\t\tsum += load[route[i]][route[i + 1]];\n\t\t\t}\n\t\t\tsum += load[route.back()][port];\n\t\t\tbest = min(best, sum);\n\t\t}\n\t\treturn best;\n\t}\n};\n\n//デバッグ\nvoid debug()\n{\n\tint N;\n\tcin>>N;\n}\n\n\n//メイン関数\nint main()\n{\n\twhile(true){\n\t\tStage stage;\n\t\tif(stage.is_end())break;\n\t\tstage.action();\n\t}\n\tdebug();\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define ll long long\nusing namespace std;\n\nconst int N = 210;\nconst int M = 10010;\n\nint n,m,e_num,s,ans;\nint nxt[M*2],to[M*2],w[M*2],c[M*2],h[N],p[1010],dis[N][N][1010];\nbool in[N][N][1010];\n\nstruct Node {int x,y,k;};\n\nqueue<Node> q;\n \nint gi() {\n  int x=0,o=1; char ch=getchar();\n  while(ch!='-' && (ch<'0' || ch>'9')) ch=getchar();\n  if(ch=='-') o=-1,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return o*x;\n}\n\nvoid add(int x, int y, int z, int f) {\n  nxt[++e_num]=h[x],to[e_num]=y,w[e_num]=z,c[e_num]=f,h[x]=e_num;\n} \n\nvoid spfa() {\n  memset(dis,63,sizeof(dis));\n  dis[1][1][p[1]==1]=0,in[1][1][p[1]==1]=1,q.push((Node){1,1,p[1]==1});\n  while(!q.empty()) {\n    Node u=q.front();\n    int x=u.x,y=u.y,k=u.k;\n    in[x][y][k]=0,q.pop();\n    for(int i=h[x]; i; i=nxt[i]) {\n      int v=to[i];\n      if(c[i]==0) {\n\tif(v==p[k+1]) {\n\t  if(dis[x][y][k]+w[i]<dis[v][y][k+1]) {\n\t    dis[v][y][k+1]=dis[x][y][k]+w[i];\n\t    if(!in[v][y][k+1] && k+1!=s) in[v][y][k+1]=1,q.push((Node){v,y,k+1});\n\t  }\n\t}\n\telse {\n\t  if(dis[x][y][k]+w[i]<dis[v][y][k]) {\n\t    dis[v][y][k]=dis[x][y][k]+w[i];\n\t    if(!in[v][y][k] && k!=s) in[v][y][k]=1,q.push((Node){v,y,k});\n\t  }\n\t}\n      }\n      else if(x==y) {\n\tif(v==p[k+1]) {\n\t  if(dis[x][y][k]+w[i]<dis[v][v][k+1]) {\n\t    dis[v][v][k+1]=dis[x][y][k]+w[i];\n\t    if(!in[v][v][k+1] && k+1!=s) in[v][v][k+1]=1,q.push((Node){v,v,k+1}); \n\t  }\n\t}\n\telse {\n\t  if(dis[x][y][k]+w[i]<dis[v][v][k]) {\n\t    dis[v][v][k]=dis[x][y][k]+w[i];\n\t    if(!in[v][v][k] && k!=s) in[v][v][k]=1,q.push((Node){v,v,k});\n\t  }\n\t}\n      }\n    }\n  }\n}\n\nvoid init() {\n  e_num=0;\n  memset(h,0,sizeof(h));\n  memset(p,0,sizeof(p));\n}\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) && n+m) {\n    init();\n    for(int i=1; i<=m; i++) {\n      int x=gi(),y=gi(),z=gi(); char ch;\n      scanf(\"%c\", &ch);\n      if(ch=='L') add(x,y,z,0),add(y,x,z,0);\n      else add(x,y,z,1),add(y,x,z,1);\n    }\n    s=gi(),ans=1<<30;\n    for(int i=1; i<=s; i++) p[i]=gi(); \n    spfa();\n    for(int i=1; i<=n; i++) {\n      ans=min(ans,dis[p[s]][i][s]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FI first\n#define SE second\n#define mp make_pair\n#define pb push_back\n#define fin(x) freopen(x,\"r\",stdin)\n#define fout(x) freopen(x,\"w\",stdout)\n#define mem(a,b) memset(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> pii;\nconst ll INF=0x003f3f3f3f3f3f3f;\nconst double pi=acos(-1);\nconst ll MAX=205;\nll Land[MAX][MAX];\nll Sail[MAX][MAX];\nll N,M;\nll Min(ll &x,ll v)\n{x=min(x,v);}\nll dp[2][MAX];\nint main()\n{\n\twhile(scanf(\"%lld%lld\",&N,&M)&&(N|M))\n\t{\t\t\n\t\tll i,j,k;\n\t\tfor(i=1;i<=N;i++)\n\t\t{\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{Land[i][j]=Sail[i][j]=INF;}\n\t\t\tdp[0][i]=dp[1][i]=INF;\n\t\t\tLand[i][i]=Sail[i][i]=0;\n\t\t}\n\t\twhile(M--)\n\t\t{\n\t\t\tll u,v,len;\n\t\t\tchar ch[3];\n\t\t\tscanf(\"%lld%lld%lld%s\",&u,&v,&len,ch);\n\t\t\tif(ch[0]=='L')\n\t\t\t{\n\t\t\t\tMin(Land[u][v],len);\n\t\t\t\tMin(Land[v][u],len);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tMin(Sail[u][v],len);\n\t\t\t\tMin(Sail[v][u],len);\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=N;i++)\n\t\t{\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{\n\t\t\t\tfor(k=1;k<=N;k++)\n\t\t\t\t{\n\t\t\t\t\tMin(Land[i][j],Land[i][k]+Land[k][j]);\n\t\t\t\t\tMin(Sail[i][j],Sail[i][k]+Sail[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll R;\n\t\tscanf(\"%lld\",&R);\n\t\tll start;\n\t\tscanf(\"%lld\",&start);\n\t\tdp[0][start]=0;\n\t\tfor(i=1;i<R;i++)\n\t\t{\n\t\t\tll x;\n\t\t\tscanf(\"%lld\",&x);\n\t\t\tll now=i&1;\n\t\t\tll last=now^1;\n\t\t\tfor(j=1;j<=N;j++) dp[now][j]=INF;\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{\n\t\t\t\tMin(dp[now][j],dp[last][j]+Land[x][start]);\n\t\t\t}\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t{\n\t\t\t\tfor(k=1;k<=N;k++)\n\t\t\t\t{\n\t\t\t\t\tMin(dp[now][k],dp[last][j]+Sail[j][k]+Land[x][k]+Land[start][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstart=x;\n\t\t}\n\t\tll ans=INF;\n\t\tll tool=(R&1)^1;\n\t\tfor(i=1;i<=N;i++)Min(ans,dp[tool][i]);\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * AOJ 2200: Mr. Rito Post Office\n * ?¢?????????????????????´?????\\????°´????????????????°´?????¬???????????¶????°±?????¨??£????????????????????¬?°´??????????????£????§?????±??????????????????????????????????????????????????????¶??´???\n * ?±????????????????+DP\n * ??????????????¨Floyd?¢???????????????¬??°?°´???s?????????l??????????????´???????????????d[i][j]??¨?????°???????¬¬i?????¶????????¨j?????¶?????¬?§??????????a??°b?????????c??°d?????\\?????¨??????l[a,c]+s[c,d]+l[d,b]?????\\????????¨???????????????l[a][b]???\n */\n\n\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint s[210][210];\nint l[210][210];\nint d[1010][210];\nint b[1010];\n\nconst int INF = 0x3f3f3f3f;\n\nvoid Floyd(int n) {\n  for (int k = 1; k <= n; ++k) {\n    for (int i = 1; i <= n; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n        l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n      }\n    }\n  }\n}\n\nint main() {\n  int n, m, r;\n  int u, v, c;\n  char tp[3];\n\n  while (scanf(\"%d%d\", &n, &m) != EOF && n) {\n    memset(s, 0x3f, sizeof(s));\n    memset(l, 0x3f, sizeof(l));\n    memset(d, 0x3f, sizeof(d));\n\n    while (m--) {\n      scanf(\"%d%d%d%s\", &u, &v, &c, tp);\n      if (tp[0] == 'L') {\n        l[u][v] = min(l[u][v], c);\n        l[v][u] = min(l[v][u], c);\n      } else {\n        s[u][v] = min(s[u][v], c);\n        s[v][u] = min(s[v][u], c);\n      }\n    }\n\n    for (int i = 1; i <= n; ++i) {\n      l[i][i] = 0;\n      s[i][i] = 0;\n    }\n\n    scanf(\"%d\", &r);\n\n    for (int i = 1; i <= r; ++i) {\n      scanf(\"%d\", &b[i]);\n    }\n\n    Floyd(n);\n\n    d[0][b[1]] = 0;\n//    for (int i = 1; i <= n; ++i) {\n//      d[1][i] = min(d[1][i], s[b[1]][i] + l[i][b[1]]);\n//    }\n\n    for (int i = 1; i <= r; ++i) {\n      for (int j = 1; j <= n; ++j) {\n        if (l[j][b[i]] >= INF) continue;\n        for (int k = 1; k <= n; ++k) {\n          if (d[i - 1][k] >= INF) continue;\n          if (j == k) {\n            if (l[b[i - 1]][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][b[i]]);\n            }\n          } else {\n            if (l[b[i - 1]][k] < INF && s[k][j] < INF && l[j][b[i]] < INF) {\n              d[i][j] = min(d[i][j], d[i - 1][k] + l[b[i - 1]][k] + s[k][j] + l[j][b[i]]);\n            }\n          }\n        }\n      }\n    }\n\n    int ans = INF;\n    for (int j = 1; j <= n; ++j) {\n      ans = min(ans, d[r][j]);\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint n, m, r;\n\nint g[2][201][201];\nint dp[1001][201];\nmain(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> n >> m, n){\n\t\tREP(i, n)REP(j, n) g[0][i][j] = g[1][i][j] = i==j ? 0 : INF;\n\t\tREP(i, m){\n\t\t\tint u,v,t;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> t >> c;u--;v--;\n\t\t\tchmin(g[c=='S'][u][v], t);\n\t\t\tchmin(g[c=='S'][v][u], t);\n\t\t}\n\t\tREP(l, 2)REP(k, n)REP(i, n)REP(j, n) g[l][i][j] = min(g[l][i][j], g[l][i][k] + g[l][k][j]);\n\t\tmemset(dp, 63, sizeof(dp));\n\t\tcin >> r;\n\t\tint p;\n\t\tcin >> p;p--;\n\t\tdp[0][p] = 0;\n\t\tREP(i, r-1){\n\t\t\tint x;\n\t\t\tcin >> x; x--;\n\t\t\tREP(j, n){\n\t\t\t\t// p->x\n\t\t\t\tchmin(dp[i+1][j], dp[i][j]+g[0][p][x]);\n\t\t\t\tREP(k, n){\t// p->j->k->x\n\t\t\t\t\tchmin(dp[i+1][k], dp[i][j]+g[0][p][j]+g[1][j][k]+g[0][k][x]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tp = x;\n\t\t}\n\t\tcout << *min_element(&dp[r-1][0], &dp[r][0]) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e12;\n\nll land[210][210];\nll sea[210][210];\nint N, M;\nint R;\nvector<int> z;\n\n// even/odd, ship\nll cost[2][210];\n\nint main() {\n\twhile(cin >> N >> M, N || M) {\n\t\t// init\n\t\tfor(int i = 0; i < 210; i++) {\n\t\t\tfor(int j = 0; j < 210; j++) {\n\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\tcost[0][i] = cost[1][i] = INF;\n\t\t}\n\t\tz.clear();\n\n\t\t// input\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tll x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == \"L\")\n\t\t\t\tland[x][y] = land[y][x] = min(land[x][y], t);\n\t\t\telse if(sl == \"S\")\n\t\t\t\tsea[x][y] = sea[y][x] = min(sea[x][y], t);\n\t\t\telse\n\t\t\t\tassert(1);\n\t\t}\n\t\tcin >> R;\n\t\tz.resize(R);\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tland[j][k] = min(land[j][k], land[j][i] + land[i][k]);\n\t\t\t\t\tsea[j][k] = min(sea[j][k], sea[j][i] + sea[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcost[0][z[0]] = 0;\n\t\tfor(int i = 1; i < z.size(); i++) {\n\t\t\tfor(int j = 0; j < 210; j++)\n\t\t\t\tcost[i%2][j] = INF;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tfor(int k = 0; k < N; k++) {\n\t\t\t\t\tcost[i%2][j] = min(cost[i%2][j],\n\t\t\t\t\t\t\tland[z[i-1]][k] + sea[k][j] + land[j][z[i]] + cost[(i-1)%2][k]);\n\t\t\t\t}\n\t\t\t\tcost[i%2][j] = min(cost[i%2][j], land[z[i-1]][z[i]] + cost[(i-1)%2][j]);\n\t\t\t}\n\t\t}\n\t\tll res = INF;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tres = min(res, cost[(R-1)%2][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nconst long long INF = 1000000000000;\n//&#146;&#172;,&#145;&#186;&#130;&#204;&#144;&#148;\nint n;\n//&#147;&#185;&#130;&#204;&#144;&#148;\nint m;\n//&#143;W&#148;z&#144;&#230;&#130;&#204;&#144;&#148;\nint R;\n\n//&#143;W&#148;z&#143;&#135;&#143;&#152;\nint z[1003];\n\ntypedef pair<long long,long long> P;\ntypedef pair<pair<long long,long long>,pair<long long,long long> > PP;\n\nstruct edge\n{\n\tint to;\n\t//&#151;&#164;&#130;&#200;&#130;&#231;1\n\tint mode;\n\tlong long cost;\n\tedge(int to,int mode,long long cost) {\n\t\tthis->to = to;\n\t\tthis->mode = mode;\n\t\tthis->cost = cost;\n\t}\n\n};\n\nvector<edge> G[207];\n// &#140;&#187;&#141;&#221;&#130;&#204;&#146;&#184;&#147;_,&#145;D&#130;&#204;&#130;&#160;&#130;&#233;&#146;&#184;&#147;_,&#130;&#199;&#130;賊&#130;&#220;&#130;&#197;&#143;W&#148;z&#130;&#181;&#130;&#189;&#130;&#169;\nlong long dist[203][203][1003];\n\nlong long dijkstra() {\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tfor (int j = 0; j < 203; j++)\n\t\t{\n\t\t\tfill(dist[i][j],dist[i][j]+1003,INF);\n\t\t}\n\t}\n\tpriority_queue<PP,vector<PP>, greater<PP> > que;\n\n\tdist[0][0][0]=0;\n\n\tque.push(PP(P(0,0),P(0,0)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\n\t\tlong long cost = pp.first.first;\n\t\tlong long v=pp.first.second;\n\t\tlong long u=pp.second.first;\n\t\tlong long index = pp.second.second;\n\t\t\n\n\t\tif(z[index] == v) {\n\t\t\tdist[v][u][index+1]=dist[v][u][index];\n\t\t\tindex++;\n\t\t}\n\n\t\tif(index == R) {\n\t\t\t//dist[v][u][index+1]=dist[v][u][index];\n\t\t\tbreak;\n\t\t}\n\n\t\tif(dist[v][u][index] < cost) {\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t//printf(\"[debug] %d %d %d %d\\n\",cost,v,u,index);\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\t//printf(\"        %d %d %d\\n\",e.to,e.mode,e.cost);\n\n\t\t\t//&#145;D&#130;&#240;&#142;g&#130;&#164;\n\t\t\tif(u==v && e.mode == 0) {\n\t\t\t\t//printf(\"%d,%d\\n\",dist[e.to][e.to][index],dist[v][u][index]);\n\t\t\t\tif(dist[e.to][e.to][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][e.to][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][e.to][index],e.to),P(e.to,index)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.mode == 1) {\n\t\t\t\tif(dist[e.to][u][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][u][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][u][index],e.to),P(u,index)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tlong long ans=INF;\n\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tans=min(ans,dist[z[R-1]][i][R-1]);\n\t} \n\n\treturn ans;\n\n\n}\n\n\nvoid solve() {\n    map<pair<P,char>,int> input;\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tlong x,y,t;\n\t\tchar c;\n\t\t//x-y &#130;&#205;&#131;R&#131;X&#131;g t &#130;&#197; c &#130;&#201;&#130;&#230;&#130;&#193;&#130;&#196;&#140;&#139;&#130;&#206;&#130;&#234;&#130;&#196;&#130;&#162;&#130;&#233;\n\t\t\n\t\tcin>>x>>y>>t>>c;\n\t\tx--;\n\t\ty--;\n        if(y<x) swap(x,y);\n        \n        pair<P,char> tmp = pair<P,char>(P(x,y),c);\n\n        if(input.find(tmp) == input.end()) {\n            input[tmp]=t;\n        }\n        else {\n            if(input[tmp] > t) {\n                input.erase(tmp);\n                input[tmp]=t;\n            }\n        }\n        \n\t}\n    map<pair<P,char>,int>::iterator it = input.begin();\n    while(it!=input.end()) {\n        long long x,y,t;\n        char c;\n        x = it->first.first.first;\n        y = it->first.first.second;\n        c = it->first.second;\n        t = it->second;\n        //printf(\"[debug] %d %d %d %c\\n\",x,y,t,c);\n        G[x].push_back(edge(y,c=='L',t));\n        G[y].push_back(edge(x,c=='L',t));\n\n        ++it;\n    }\n\n\tcin>>R;\n\n\tfor (int i = 0; i < R; i++)\n\t{\n\t\tcin>>z[i];\n\t\tz[i]--;\n\t}\n\n\tcout<<dijkstra()<<endl;\n\t\n\tfor (int i = 0; i < 207; i++)\n\t{\n\t\tG[i].clear();\n\t}\n}\n\nint main() {\n\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint main() {\n\tint x, y, t, r, z, rz;\n\tchar s;\n\twhile (cin >> n >> m && n>=1) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tfor (int i = 1; i <= 200; i++)for (int j = 0; j < r; j++)dp[j][i] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tint ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint v1[203][203],v2[203][203],a1,a2,a3,n,m;\nint dp[2][203][203],t,x,pre;\nchar c;\nint main(){\n  while(cin>>n>>m,n){\n    int ans=1e8;\n    r(i,2)r(j,203)r(k,203)dp[i][j][k]=1e8;\n    r(i,203)r(j,203)v1[i][j]=v2[j][i]=(i==j?0:1e8);\n    r(i,m){\n      cin>>a1>>a2>>a3>>c;\n      a1--,a2--;\n      if(c=='L')v1[a1][a2]=v1[a2][a1]=a3;\n      else v2[a1][a2]=v2[a2][a1]=a3;\n    }\n    r(k,n)r(i,n)r(j,n){\n      v1[i][j]=min(v1[i][j],v1[i][k]+v1[k][j]);\n      v2[i][j]=min(v2[i][j],v2[i][k]+v2[k][j]);\n    }\n    cin>>t>>pre;pre--;\n    dp[0][pre][pre]=0;\n    for(int k=0;k<t-1;k++){\n      cin>>x;x--;\n      for(int i=0;i<n;i++){\n        dp[(k+1)%2][x][i]=min(dp[(k+1)%2][x][i],dp[k%2][pre][i]+v1[pre][x]);\n        for(int j=0;j<n;j++){\n          dp[(k+1)%2][x][j]=min(dp[(k+1)%2][x][j],dp[k%2][pre][i]+v1[pre][i]+v2[i][j]+v1[j][x]);\n        }\n      }\n      r(i,203)r(j,203)dp[k%2][i][j]=1e8;\n      pre=x;\n    }\n    r(i,203)ans=min(ans,dp[(t-1)%2][pre][i]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX/5;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return weight<e.weight;}\n\tbool operator>(const Edge& e)const{return weight>e.weight;}\n};\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tvvi gl(n,vi(n,INFTY)),gs(n,vi(n,INFTY)); // 陸路，海路\n\t\trep(i,n) gl[i][i]=gs[i][i]=0;\n\t\trep(i,m){\n\t\t\tint s,d,w; char sl; cin>>s>>d>>w>>sl; s--,d--;\n\t\t\tif(sl=='L' && gl[s][d]>w) gl[s][d]=gl[d][s]=w;\n\t\t\tif(sl=='S' && gs[s][d]>w) gs[s][d]=gs[d][s]=w;\n\t\t}\n\t\tint r; cin>>r;\n\t\tvi route(r);\n\t\trep(i,r) cin>>route[i],route[i]--;\n\t\t\n\t\t// warshall-floyd\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tgl[i][j]=min(gl[i][j],gl[i][k]+gl[k][j]);\n\t\t\tgs[i][j]=min(gs[i][j],gs[i][k]+gs[k][j]);\n\t\t}\n\t\t\n\t\tvvi dp(r,vi(n,INFTY)); // [集配先][船の位置]\n\t\tdp[0][0]=0;\n\t\trepi(i,1,r){\n\t\t\trep(j,n)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+gl[route[i-1]][route[i]]);\n\t\t\trep(j,n) rep(k,n)\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+gl[route[i-1]][j]+gs[j][k]+gl[k][route[i]]);\n\t\t}\n\t\tcout<<*min_element(all(dp[r-1]))<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",*min_element(dp[r-1].begin(),dp[r-1].end()));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\tif(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",res);\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    if (par[x] == x)\n    {\n      return x;\n    }\n    else\n    {\n      return par[x] = root(par[x]);\n    }\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x != y)\n    {\n      par[y] = x;\n    }\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  if (n == 0)\n    return 1;\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 200010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\nconst ll mod2 = 998244353;\nconst ll mod3 = 1777777777;\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (ll i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n    //cout << fac[i] << \" \" << inv[i] << \" \" << finv[i] << endl;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] % MOD * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\ntemplate <class TYPE>\nstruct Fenwick\n{\n  int N;\n  vector<ll> bit;\n\n  Fenwick() : N(0) {}\n  Fenwick(int n) : N(n), bit(n + 1, 0) {}\n\n  void add(int i, ll x)\n  {\n    //0-indexedを避けるために加算\n    while (i <= N)\n    {\n      bit[i] += x;\n      i += (i & -i);\n    }\n  }\n\n  ll sum(int i)\n  {\n    ll res = 0;\n    while (i > 0)\n    {\n      res += bit[i];\n      i -= (i & -i);\n    }\n    return res;\n  }\n\n  ll range(int i, int j)\n  {\n    return sum(j) - sum(i);\n  }\n\n  ll get(int i)\n  {\n    return sum(i) - sum(i - 1);\n  }\n\n  ll getKth(ll k)\n  {\n    ++k;\n    int res = 0;\n    int n = 1;\n    while (n < bit.size())\n      n *= 2;\n\n    for (int i = n / 2; i > 0; i /= 2)\n    {\n      if (res + i < bit.size() && bit[res + i] < k)\n      {\n        k = k - bit[res + i];\n        res = res + i;\n      }\n    }\n    return res + 1;\n  }\n\n  // bitは1-indexedで実装しているのでバグった時は初めに確認すること\n};\n\nll d1[210][210];\nll d2[210][210];\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(4);\n\n  int N, M;\n  while (cin >> N >> M)\n  {\n    if (N == 0 && M == 0)\n      break;\n\n    REP(i, N)\n    {\n      REP(j, N)\n      {\n        d1[i][j] = d2[i][j] = (1LL << 60);\n      }\n    }\n    REP(i, M)\n    {\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      x--;\n      y--;\n\n      if (sl == 'L')\n      {\n\n        d1[x][y] = min(d1[x][y], (ll)t);\n        d1[y][x] = d1[x][y];\n      }\n      else if (sl == 'S')\n      {\n\n        d2[x][y] = min(d2[x][y], (ll)t);\n        d2[y][x] = d2[x][y];\n      }\n    }\n    int R;\n    cin >> R;\n    vector<int> pos(R);\n    REP(i, R)\n    {\n      cin >> pos[i];\n      pos[i]--;\n    }\n\n    REP(k, N)\n    {\n      REP(i, N)\n      {\n        REP(j, N)\n        {\n          d1[i][j] = min(d1[i][j], d1[i][k] + d1[k][j]);\n          d2[i][j] = min(d2[i][j], d2[i][k] + d2[k][j]);\n        }\n      }\n    }\n\n    vector<vector<ll>> dp(R + 1, vector<ll>(N, (1LL << 60)));\n    dp[0][pos[0]] = 0;\n\n    //初期地点はpos[0];\n\n    for (int i = 0; i < R - 1; i++)\n    {\n      int s = pos[i];\n      int t = pos[i + 1];\n\n      //徒歩で直接向かう\n      for (int j = 0; j < N; j++)\n      {\n        dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + d1[s][t]);\n      }\n\n      //徒歩->船->(徒歩)\n      for (int j = 0; j < N; j++)\n      {\n        for (int k = 0; k < N; k++)\n        {\n          if (s == j && k == t)\n          {\n            dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + d2[j][k]);\n          }\n          else if (s == j)\n          {\n            dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + d2[j][k] + d1[k][t]);\n          }\n          else if (k == t)\n          {\n            dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + d1[s][j] + d2[j][k]);\n          }\n          else\n          {\n            dp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + d1[s][j] + d2[j][k] + d1[k][t]);\n          }\n        }\n      }\n    }\n\n    ll ans = (1LL << 60);\n\n    for (int i = 0; i < N; i++)\n    {\n      ans = min(ans, dp[R - 1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = 1e9;\n\nint main() {\n    int N, M;\n    while (cin >> N >> M, N+M) {\n        ll d[2][N][N];\n        for (int from = 0; from < N; from++) for (int to = 0; to < N; to++) {\n            d[0][from][to] = (from == to ? 0 : INF);\n            d[1][from][to] = (from == to ? 0 : INF);\n        }\n        for (int i = 0; i < M; i++) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            x--, y--;\n            d[sl == 'S'][x][y] = d[sl == 'S'][y][x] = min(d[sl == 'S'][x][y], (ll)t);\n        }\n        for (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n            d[0][i][j] = min(d[0][i][j], d[0][i][k] + d[0][k][j]);\n            d[1][i][j] = min(d[1][i][j], d[1][i][k] + d[1][k][j]);\n        }\n\n        int R; cin >> R;\n        vector<int> route(R);\n        for (int i = 0; i < R; i++) {\n            cin >> route[i];\n            route[i]--;\n        }\n\n        ll dp[R][N]; // (# of done, ship_pos)\n        for (int i = 0; i < R; i++)\n            for (int j = 0; j < N; j++) dp[i][j] = INF;\n        dp[0][route[0]] = 0;\n        for (int n_done = 0; n_done < R - 1; n_done++) {\n            int from = route[n_done], to = route[n_done + 1];\n            for (int ship = 0; ship < N; ship++) {\n                dp[n_done + 1][ship] = min(dp[n_done + 1][ship], dp[n_done][ship] + d[0][from][to]);\n                for (int pos = 0; pos < N; pos++) {\n                    ll move_cost = d[0][from][ship] + d[1][ship][pos] + d[0][pos][to];\n                    dp[n_done + 1][pos] = min(dp[n_done + 1][pos], dp[n_done][ship] + move_cost);\n                }\n            }\n        }\n\n        ll ans = INF;\n        for (int ship = 0; ship < N; ship++) ans = min(ans, dp[R-1][ship]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst ll INF = (1ll << 32);\nconst int MAX_V = 201;\nconst int MAX_R = 1001;\nint N, M, R;\nint z[MAX_R];\nll sea[MAX_V][MAX_V];\nll land[MAX_V][MAX_V];\nll dp[MAX_R][MAX_V];\n\nll solve(){\n\t// warshall-floyd\n\tfor(int k=0 ; k < N ; k++ ){\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tfor(int j=0 ; j < N ; j++ ){\n\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// initialize\n\tfor(int i=0 ; i < MAX_R ; i++ ){\n\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n\t\n\t// dynamic programming\n\tdp[0][z[0]] = 0;\n\tfor(int i = 1 ; i < R ; i++ ) {\n\t\tfor(int j = 0 ; j < N ; j++ ) {\n\t\t\t// テゥツ卍クティツキツッテ」ツ?ョテ」ツ?ソテ」ツ?ョテァツァツサテ・ツ仰?\n\t\t\t// dp[i][j] := テゥツ崢?ァツゥツ催ァツ閉ェテ・ツ渉キ i, ティツ按ケテ」ツ?ョテ、ツスツ催ァツスツョ j テ」ツ?ョテ」ツ?ィテ」ツ?催」ツ?ョテ」ツつウテ」ツつケテ」ツδ?\n\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + land[z[i-1]][z[i]]);\n\t\t\t\n\t\t\t// テヲツオツキティツキツッテ」ツつ津ァツ板ィテ」ツ??」ツ?淌ァツァツサテ・ツ仰?\n\t\t\tfor(int k = 0 ; k < N ; k++ ) {\n\t\t\t\tll cost = dp[i-1][j] + land[z[i-1]][j]+ sea[j][k] + land[k][z[i]];\n\t\t\t\tdp[i][k] = min(dp[i][k], cost);\n\t\t\t}\n\t\t}\n\t}\n\tll res = INF;\n\tfor(int i=0 ; i < N ; i++ ){\n\t\tres = min(res, dp[R-1][i]);\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile( cin >> N >> M , N || M ){\n\t\t// initialize\n\t\tfor(int i=0 ; i < MAX_V ; i++ ){\n\t\t\tfor(int j=0 ; j < MAX_V ; j++ ){\n\t\t\t\tland[i][j] = (i == j)? 0 : INF;\n\t\t\t\tsea[i][j] = (i == j)? 0 : INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0 ; i < M ; i++ ){\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\t\n\t\t\tif( sl == 'S' ){\n\t\t\t\tsea[x][y] = sea[y][x] = min(sea[x][y], t);\n\t\t\t}else{\n\t\t\t\tland[x][y] = land[y][x] = min(land[x][y], t);\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor(int i=0 ; i < R ; i++ ){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nconst ll INF = 1LL << 50;\nll land[200][200];\nll sea[200][200];\nll dp[1010][200];\nint z[1000];\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N, M, R;\n\twhile(cin >> N >> M, N) {\n\t\tfill((ll*)begin(land), (ll*)end(land), INF);\n\t\tfill((ll*)begin(sea), (ll*)end(sea), INF);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t}\n\n\t\tfor(int i = 0; i < M; i++) {\n\t\t\tint x, y;\n\t\t\tll t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--, y--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tt = min(t, land[x][y]);\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tt = min(t, sea[x][y]);\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < N; k++) {\n\t\t\tfor(int i = 0; i < N; i++) {\n\t\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tfor(int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tfill((ll*)begin(dp), (ll*)end(dp), INF);\n\t\tdp[z[0]][z[0]] = 0;\n\t\tfor(int i = 0; i < R - 1; i++) {\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif(dp[i][j] == INF) continue;\n\t\t\t\tint A = z[i], B = z[i + 1];\n\t\t\t\tdp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + land[A][B]);\n\n\t\t\t\tfor(int u = 0; u < N; u++) {\n\t\t\t\t\tll cost = land[A][j] + sea[j][u] + land[u][B];\n\t\t\t\t\tif(cost < INF) {\n\t\t\t\t\t\tdp[i + 1][u] = min(dp[i + 1][u], dp[i][j] + cost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tfor(int j = 0; j < N; j++) {\n\t\t\tans = min(ans, dp[R - 1][j]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvoid mainmain(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvint land;\n\t\tvvint sea;\n\t\tinitvv(land,n,n,INF);\n\t\tinitvv(sea,n,n,INF);\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin>>a>>b>>c>>t;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tif(t=='L') land[a][b]=mins(land[b][a],c);\n\t\t\telse sea[a][b]=mins(sea[b][a],c);\n\t\t}\n\t\trep(i,2) rep(j,n) land[j][j]=sea[j][j]=0;\n\t\trep(k,n) rep(i,n) rep(j,n) mins(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n) rep(i,n) rep(j,n) mins(sea[i][j],sea[i][k]+sea[k][j]);\n\t\tint r;\n\t\tcin>>r;\n\t\tvint v(r);\n\t\trep(i,r){\n\t\t\tcin>>v[i],v[i]--;\n\t\t}\n\t\tvll pre(n,INFL);\n\t\tpre[v[0]]=0;\n\t\trep(i,r-1){\n\t\t\tvll dp(n,INFL);\n\t\t\trep(k,n){\n\t\t\t\trep(l,n){\n\t\t\t\t\tmins(dp[l],pre[k]+land[v[i]][k]+sea[k][l]+land[l][v[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(dp,pre);\n\t\t}\n\t\tcout<< *min_element(ALL(pre))<<endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n    cin.tie(0);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct st{\n  int d,v,b;\n  st(){}\n  st(int d,int v,int b):d(d),v(v),b(b){}\n};\nstruct edge{\n  int to,cost,s;\n  edge(){}\n  edge(int to,int cost,int s):to(to),cost(cost),s(s){}\n};\nint dp[2][222][222];\nvector<edge> G[222];\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    for(int i=0;i<222;i++) G[i].clear();\n    int x[m],y[m],t[m];\n    char sl[m];\n    for(int i=0;i<m;i++) cin>>x[i]>>y[i]>>t[i]>>sl[i];\n    int r;\n    cin>>r;\n    int z[r];\n    for(int i=0;i<r;i++) cin>>z[i];\n    for(int i=0;i<m;i++){\n      x[i]--;y[i]--;\n      G[x[i]].emplace_back(y[i],t[i],sl[i]=='S');\n      G[y[i]].emplace_back(x[i],t[i],sl[i]=='S');\n    }\n    for(int i=0;i<r;i++) z[i]--;\n    memset(dp,-1,sizeof(dp));\n    deque<st> q;\n    q.emplace_back(1,z[0],z[0]);\n    dp[1][z[0]][z[0]]=0;\n    int pre=1;\n    int ans=1LL<<55LL;\n    while(!q.empty()){\n      st p=q.front();q.pop_front();\n      int d=p.d,v=p.v,b=p.b;\n      if(d==r){\n\tans=min(ans,dp[d%2][v][b]);\n\tcontinue;\n      }\n      //cout<<d<<\" \"<<v<<\" \"<<b<<\":\"<<dp[d%2][v][b]<<endl;\n      if(pre!=p.d)\n\tfor(int i=0;i<n;i++)\n\t  for(int j=0;j<n;j++)\n\t    dp[!(d%2)][i][j]=-1;\n      pre=d;\n      for(edge& e:G[v]){\n\tint nv=e.to,nb=b,nd=d;\n\tif(e.s){\n\t  if(v==b) nb=nv;\n\t  else continue;\n\t}\n\tif(nv==z[d]){\n\t  nd++;\n\t  if(dp[nd%2][nv][nb]<0||dp[nd%2][nv][nb]>dp[d%2][v][b]+e.cost){\n\t    //cout<<e.s<<\":\"<<nd<<\" \"<<nv<<\" \"<<nb<<endl;\n\t    dp[nd%2][nv][nb]=dp[d%2][v][b]+e.cost;\n\t    q.emplace_back(nd,nv,nb);\n\t  }\n\t}else{\n\t  if(dp[nd%2][nv][nb]<0||dp[nd%2][nv][nb]>dp[d%2][v][b]+e.cost){\n\t    dp[nd%2][nv][nb]=dp[d%2][v][b]+e.cost;\n\t    q.emplace_front(nd,nv,nb);\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[1010],W[N][N],L[N][N];\nll dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        for (int i=1;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                dp[i][j]=1e18;\n            }\n        }\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=1e18) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    ll dis1=L[z[i-1]][k];\n                    ll dis2=W[k][j];\n                    ll dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=1e18) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        ll ans=1e18;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n    int d[N];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n    int d[N];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<n;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n          //printf(\"k=%d dp[%d][%d]=%d\\n\",k,i,j,dp[i][j]);\n          //printf(\"dp[%d][%d]+land[%d][%d]+sea[%d][%d]+land[%d][%d] = %d\\n\",i-1,k,z[i-1],k,k,j,j,z[i],dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<vector>\n#include<utility>\nusing namespace std;\n//#define min(a,b)((a)<(b)?(a):(b))\n#define inf 0x01010101\nstruct State{\n\tint cost,rito,boat;\n\tState(int cost,int rito,int boat):cost(cost),rito(rito),boat(boat){}\n\tbool operator<(const State& r)const{return cost>r.cost;}\n};\nint N;//¬ºÌ\nvector<pair<int,int> >Edge[2][201];//[¤H0,CH1][¬º]:=(¬º,Ô)\nint Cost[201][201];//[¡³ñÌÊu][DÌÊu]:=ÅZÚ®Ô\nvoid Dijkstra(int*C,int start,int dest){\n\tint boat,rito,boatmin,ritomin,c,cmin,i;\n\tvector<pair<int,int> >*pEdge;\n\tstd::priority_queue<State> que;\n\tmemset(Cost,1,sizeof(Cost));//inf\n\tmemcpy(Cost+start,C,sizeof(int)*201);//startÊuÅÌóÔ\n\tfor(boat=1;boat<=N;boat++){\n\t\tif(C[boat]<inf){\n\t\t\tque.push(State(C[boat],start,boat));\n\t\t\t//printf(\"push (%d,%d)=%d\\n\",start,boat,C[boat]);\n\t\t}\n\t}\n\tfor(;!que.empty();){\n\t\t//¢èÌóÔÌàAÅZÌàÌðIð\n\t\tritomin=que.top().rito;\n\t\tboatmin=que.top().boat;\n\t\tcmin=que.top().cost;\n\t\tque.pop();\n\t\t//printf(\"determine (%d,%d)=%d\\n\",ritomin,boatmin,cmin);\n\t\t//×ÚóÔðXV\n\t\tpEdge=&Edge[0][ritomin];\n\t\tfor(i=0;i<pEdge->size();i++){\n\t\t\trito=(*pEdge)[i].first;\n\t\t\tc=Cost[ritomin][boatmin]+(*pEdge)[i].second;\n\t\t\tif(c<Cost[rito][boatmin]){\n\t\t\t\tCost[rito][boatmin]=c;\n\t\t\t\tque.push(State(c,rito,boatmin));\n\t\t\t\t//printf(\"push (%d,%d)=%d\\n\",rito,boatmin,c);\n\t\t\t}\n\t\t}\n\t\t//»±ÉDª êÎCH\n\t\tif(ritomin==boatmin){\n\t\t\tpEdge=&Edge[1][ritomin];\n\t\t\tfor(i=0;i<pEdge->size();i++){\n\t\t\t\trito=(*pEdge)[i].first;\n\t\t\t\tc=Cost[ritomin][boatmin]+(*pEdge)[i].second;\n\t\t\t\tif(c<Cost[rito][rito]){\n\t\t\t\t\tCost[rito][rito]=c;\n\t\t\t\t\tque.push(State(c,rito,rito));\n\t\t\t\t\t//printf(\"push (%d,%d)=%d\\n\",rito,rito,c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(C,Cost+dest,sizeof(int)*201);//destÊuÅÌóÔ\n}\nint main(){\n\tint M,R,z;\n\tint C[201];//[DÌÊu]:=ÅZÚ®Ô\n\tfor(;scanf(\"%d%d\",&N,&M)*N;){\n\t\tfor(;M--;){\n\t\t\tint x,y,t,s;\n\t\t\tchar sl[2];\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,sl);\n\t\t\ts=sl[0]=='L'?0:1;\n\t\t\tEdge[s][x].push_back(make_pair(y,t));\n\t\t\tEdge[s][y].push_back(make_pair(x,t));\n\t\t}\n\t\tscanf(\"%d%d\",&R,&z);\n\t\tmemset(C,1,sizeof(C));//inf\n\t\tC[z]=0;\n\t\tfor(;--R;){\n\t\t\tint Z;\n\t\t\tscanf(\"%d\",&Z);\n\t\t\t//printf(\"dijkstra(%d,%d)\\n\",z,Z);\n\t\t\tDijkstra(C,z,Z);\n\t\t\tz=Z;\n\t\t}\n\t\t{\n\t\t\tint c=1e9;\n\t\t\tfor(z=1;z<=N;z++)\n\t\t\t\tc=min(c,C[z]);\n\t\t\tprintf(\"%d \\n\",c);\n\t\t}\n\t\tfor(z=0;z<201;z++){\n\t\t\tEdge[0][z].clear();\n\t\t\tEdge[1][z].clear();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nlong long int dp[10001][200];\n\nint main() {\n\t/*int N; cin >> N;\n\twhile (N--) {\n\t\tstring ast, bst; cin >> ast >> bst;\n\t\treverse(ast.begin(), ast.end());\n\t\tfor (char c : ast) {\n\t\t\tswitch (c) {\n\t\t\tcase 'A': {\n\t\t\t\treverse(bst.begin(), bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'C': {\n\t\t\t\trotate(bst.begin(), bst.begin() + 1, bst.end());\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'J':{\n\t\t\t\t\t\t  rotate(bst.begin(), bst.end() - 1, bst.end());\n\t\t\t\t\t  }\n\t\t\t\t\t break;\n\t\t\tcase 'E': {\n\t\t\t\tbst = string(bst.begin() + (bst.size() + 1) / 2, bst.end()) + string(bst.begin() + bst.size() / 2, bst.begin()+(bst.size()+1)/2) + string(bst.begin(), bst.begin() + bst.size() / 2);\n\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'M': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '9')return '0';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c + 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tcase 'P': {\n\t\t\t\ttransform(bst.begin(), bst.end(), bst.begin(), [](const char c) {\n\t\t\t\t\tif (c == '0')return '9';\n\t\t\t\t\telse if (c >= '0'&&c <= '9')return char(c - 1);\n\t\t\t\t\telse return c;\n\t\t\t\t});\n\t\t\t}\n\t\t\t\t\t  break;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t}\n\t\t\t\n\t\t\n\t\tcout << bst << endl;\n\t}*/\n\n\twhile (1) {\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tfor (int i = 0; i < 10001; ++i) {\n\t\t\tfor (int j = 0; j < 200; ++j) {\n\t\t\t\tdp[i][j] = 999999999999;\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long int>>stimes(N, vector<long long int>(N, 999999999999)),ltimes(N, vector<long long int>(N,999999999999));\n\n\t\t\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; long long int  t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tx--; y--;\n\t\t\tif (c == 'L') {\n\t\t\t\tltimes[x][y] = min(ltimes[x][y], t);\n\t\t\t\tltimes[y][x] = min(ltimes[y][x], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstimes[x][y] = min(stimes[x][y], t);\n\t\t\t\tstimes[y][x] = min(stimes[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tltimes[i][i] = 0;\n\t\t\tstimes[i][i] = 0;\n\t\t}\n\t\tfor (int k = 0; k < N; ++k) {\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tltimes[i][j] = min(ltimes[i][j], ltimes[i][k] + ltimes[k][j]);\n\t\t\t\t\tstimes[i][j] = min(stimes[i][j], stimes[i][k] + stimes[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R; cin >> R;\n\t\tvector<int>vs(R);\n\t\tfor (int i = 0; i < R; ++i) {\n\t\t\tcin >> vs[i];\n\t\t\tvs[i]--;\n\t\t}\n\t\tdp[0][vs[0]] = 0;\n\t\tfor (int time = 0; time< R-1; ++time) {\n\t\t\tfor (int f= 0; f < N; ++f) {\n\t\t\t\tfor (int t = 0; t < N; ++t) {\n\t\t\t\t\tdp[time + 1][t] = min(dp[time + 1][t], dp[time][f] + ltimes[vs[time]][f] + stimes[f][t] + ltimes[t][vs[time + 1]]);\n\t\t\t\t}\n\n\t\t\t\tdp[time + 1][f] = min(dp[time + 1][f], dp[time][f] + ltimes[vs[time]][vs[time+1]]);\n\t\t\t}\n\t\t}\n\t\tlong long int ans = 999999999999;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\ntypedef long long ll;typedef unsigned long long ull;\ntemplate <typename T>struct iindex {T data;iindex() = default;iindex(long long i) : data(i) {}iindex(int       i) : data(i) {}iindex(size_t    i) : data(i) {}operator T &       () { return data; }operator long long () { return data; }operator int       () { return data; }operator size_t    () { return data; }typedef T value_type;};template <typename T>std::istream & operator >> (std::istream & input, iindex<T> & i) { input >> i.data; i.data -= 1; return input; }template <typename T>std::ostream & operator << (std::ostream & output, iindex<T> const & i) { return output << i.data+1; }typedef iindex<long long> index;\ntemplate <typename T>class irange {public:class iterator {public:iterator(T value) : value(value), step(1) {}iterator(T value, T step) : value(value), step(step) {}bool operator != (const iterator & other) const {return value != other.value;}T const & operator * () const {return value;}iterator & operator ++ () {value += step;return *this;}private:T value;T step;};public:irange(T last) : first(0), last(last), step(1) {}irange(T first, T last) : first(first), last(last), step(1) {}irange(T first, T last, T step) : first(first), last(last), step(step) {}iterator begin() const {return iterator(first, step);}iterator end() const {if (step == 0) return iterator(last, step);if (0 < step and last < first) return iterator(first, step);if (step < 0 and first < last) return iterator(first, step);return iterator(first + ((last - first + (0 < step ? -1 : 1)) / step + 1) * step, step);}typedef T value_type;private:T const first;T const last;T const step;};typedef irange<long long> lrange;inline lrange range(lrange::value_type last) { return lrange(last); }inline lrange range(lrange::value_type first, lrange::value_type last) { return lrange(first, last); }inline lrange range(lrange::value_type first, lrange::value_type last, lrange::value_type step) { return lrange(first, last, step); }template <typename T> lrange index_of(const T & a) { return range(a.size()); }inline lrange range(std::istream & input) { lrange::value_type i; input >> i; return range(i); }inline lrange reverse_range(lrange::value_type last) { return range(last-1,-1,-1); }inline lrange reverse_range(lrange::value_type first, lrange::value_type last) { return range(last-1,first-1,-1); }inline lrange inclusive_range(lrange::value_type last) { return range(last+1); }inline lrange inclusive_range(lrange::value_type first, lrange::value_type last) { return range(first,last+1); }template <typename T> lrange reverse_index_of(const T & a) { return range(a.size()-1,-1,-1); }\ntemplate <typename T>std::istream & operator >> (std::istream & input, std::vector<T> & a) {for (int i = 0; i < a.size(); ++i) {input >> a[i];}return input;}template <typename T>std::ostream & operator << (std::ostream & output, const std::vector<T> & a) {for (int i = 0; i < a.size(); ++i) {if (i != 0) output << ' ';output << a[i];}return output;}\nusing namespace std;\nconst int inf = 1<<26;\nint main() {\n    ios_base::sync_with_stdio(false);\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0 and m == 0) break;\n        vector<vector<int> > e[2];\n        for (int sl : {0,1}) e[sl].resize(n, vector<int>(n, inf));\n        for (int query : range(m)) {\n            index x, y; int t; char c; cin >> x >> y >> t; cin.ignore(); cin >> c;\n            assert (c == 'S' or c == 'L');\n            int sl = c == 'L' ? 0 : 1;\n            e[sl][x][y] = min(e[sl][x][y], t);\n            e[sl][y][x] = min(e[sl][y][x], t);\n        }\n        int r; cin >> r;\n        vector<index> z(r); cin >> z;\n        // warshall floyd\n        for (int sl : {0,1}) for (int i : range(n)) e[sl][i][i] = 0;\n        for (int sl : {0,1}) for (int k : range(n)) for (int i : range(n)) for (int j : range(n)) {\n            e[sl][i][j] = min(e[sl][i][j], e[sl][i][k] + e[sl][k][j]);\n        }\n        vector<int> dp[2];\n        for (int i : {0,1}) dp[i].resize(n, inf);\n        vector<int> & cur = dp[0];\n        vector<int> & prv = dp[1];\n        prv[z[0]] = 0;\n        for (int i : range(1,r)) {\n            for (int j : range(n)) {\n                cur[j] = inf;\n                cur[j] = min(cur[j], prv[j] + e[0][z[i-1]][z[i]]);\n                for (int k : range(n)) {\n                    cur[j] = min(cur[j], prv[k] + e[0][z[i-1]][k] + e[1][k][j] + e[0][j][z[i]]);\n                }\n            }\n            swap(cur,prv);\n        }\n        cout << *min_element(prv.begin(), prv.end()) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define int long long\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n//mplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntypedef ll Cost;\nstruct Edge{int to,cap,rev;Cost cost;};\ntypedef vector<Edge> Edges;\ntypedef vector<vector<Edge> > Graph;\ntypedef pair<Cost,int> Que;\n\nvoid add_edge(Graph &g,int from,int to,int cap,Cost cost=0){\n  //cout<<from<<\",\"<<to<<\":\"<<cost<<endl;\n  g[from].pb((Edge){to,cap,(int)g[to].size(),cost});\n  g[to].pb((Edge){from,cap,(int)g[from].size()-1,cost});\n}\nCost INF=5e15;\n//dij\nint n,m,r; \nCost dij(Graph &g,Graph &h,int s,vector<Cost> &d){\n  priority_queue<Que,vector<Que>,greater<Que> > que;\n  int V=g.size();\n  d.resize(V);\n  fill(all(d),INF);\n  d[s]=0;\n  que.push(Que(0,s));\n  while(!que.empty()){\n    Que p=que.top();que.pop();\n    int v=p.Y;\n    //cout<<p;\n    if(v/n/n==r)return p.X;\n    if(d[v]<p.X)continue;\n    for(int i=0;i<g[v].size();i++){\n      Edge e=g[v][i];\n      if(d[e.to]>d[v]+e.cost){\n        d[e.to]=d[v]+e.cost;\n        que.push(Que(d[e.to],e.to));\n      }\n    }\n  }\n  return -1;\n}\nint fun(int p,int b,int r_){\n  return p*n+b+r_*n*n;\n}\nmain(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  while(cin>>n>>m,n){\n    cout<<n<<\",\"<<m<<endl;\n    vector<int> a(m),b(m),c(m);\n    vector<char> ch(m);\n    rep(i,m){\n      cin>>a[i]>>b[i]>>c[i]>>ch[i];\n      --a[i]; --b[i];\n    }\n    cin>>r;\n    cout<<r<<endl;\n    vector<int> pos(r);\n    rep(i,r){\n      cin>>pos[i]; --pos[i];\n      cout<<i<<endl;\n    }\n    cout<<n*n*(r+1)<<endl;\n    Graph g(n*n*(r+1)),h(n*(r+1));\n    /*   rep(j,n)rep(k,r)\n      add_edge(g,fun(pos[k],j,k),fun(pos[k],j,k+1),1,0);\n    cout<<\"!\"<<endl;\n    rep(i,m){\n      if(ch[i]=='L'){\n\t;\n\t/*\trep(j,n)rep(k,r)\n\t\tadd_edge(g,fun(a[i],j,k),fun(b[i],j,k),1,c[i]);\n      }else{\n\tif(ch[i]!='S')assert(0);\n\trep(k,r)\n\t  add_edge(g,fun(a[i],a[i],k),fun(b[i],b[i],k),1,c[i]);\n      }\n    }\n    cout<<a<<b<<c<<ch<<pos;\n    vector<Cost> dist(n*n*(r+1));\n    cout<<\"g.size()\"<<g.size()<<endl;*/\n    //cout<<dij(g,h,fun(pos[0],pos[0],0),dist)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n   \n    dp[1][1]=0;\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <string>\n#include <functional>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAX_N = 200, MAX_M = 10000, MAX_R = 1000;\nconst int INF = 1000000;\nint w[MAX_N + 1][MAX_N + 1][2], rs[MAX_R];\nint dp[MAX_R][MAX_N + 1];\n\nint main()\n{\n    int N, M, R;\n    while(cin >> N >> M && N && M) {\n        for(int i = 1; i <= N; i++) \n            for(int j = 1; j <= N; j++) \n                for(int k = 0; k < 2; k++)\n                    w[i][j][k] = (i == j) ? 0 : INF;\n            \n        int x, y, t;\n        char sl;\n        for(int i = 0; i < M; i++) {\n            cin >> x >> y >> t >> sl;\n            if(sl == 'L') \n                w[x][y][0] = w[y][x][0] = t;\n            else \n                w[x][y][1] = w[y][x][1] = t;\n        }\n\n        cin >> R;\n        for(int i = 0; i < R; i++) \n            cin >> rs[i];\n\n        for(int t = 0; t < 2; t++) \n            for(int k = 1; k <= N; k++)\n                for(int i = 1; i <= N; i++)\n                    for(int j = 1; j <= N; j++)\n                        w[i][j][t] = min(w[i][j][t], w[i][k][t] + w[k][j][t]);\n        \n        for(int i = 0; i < R; i++)\n            for(int j = 1; j <= N; j++)\n                dp[i][j] = INF;\n        \n        dp[0][rs[0]] = 0;\n        for(int i = 1; i < R; i++) {\n            int to = rs[i], from = rs[i - 1];\n            for(int j = 1; j <= N; j++) {\n                //Land Only\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + w[from][to][0]);\n                //With Sea\n                for(int k = 1; k <= N; k++) {\n                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + w[from][k][0] + w[k][j][1] + w[j][to][0]);\n                }\n            }\n        }\n        \n        \n        int res = INF;\n        for(int j = 1; j <= N; j++)\n            res = min(res, dp[R - 1][j]);\n\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 210;\nconst int MAX_R = 1010;\nconst int INF = 1e8;\n\nint main(){\n  int N, M;\n  while(cin >>N >>M && N){\n    int L[MAX_N][MAX_N], S[MAX_N][MAX_N], dp[MAX_R][MAX_N], v[MAX_R];\n    REP(i, MAX_N) REP(j, MAX_N) L[i][j] = S[i][j] = (i == j ? 0 : INF);\n    REP(i, MAX_R) REP(j, MAX_N) dp[i][j] = INF;\n    REP(i, M){\n      int a, b, c; char t; cin >>a >>b >>c >>t;\n      --a; --b;\n      if(t == 'S') S[a][b] = S[b][a] = c;\n      else L[a][b] = L[b][a] = c;\n    }\n    REP(k, N) REP(i, N) REP(j, N) L[i][j] = min(L[i][j], L[i][k] + L[k][j]);\n    REP(k, N) REP(i, N) REP(j, N) S[i][j] = min(S[i][j], S[i][k] + S[k][j]);\n    int R; cin >>R;\n    REP(i, R){ cin >>v[i]; --v[i]; }\n    REP(j, MAX_N) dp[0][j] = min(INF, S[v[0]][j] + L[j][v[0]]);\n    FOR(i, 1, R){\n      REP(j, N){\n        REP(k, N){\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] + L[v[i - 1]][k] + S[k][j] + L[j][v[i]]);\n          if(k == j) dp[i][j] = min(dp[i][j], dp[i - 1][j] + L[v[i - 1]][v[i]]);\n        }}}\n    int ans = INF;\n    REP(i, N) ans = min(ans, dp[R - 1][i]);\n    cout <<ans <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\nconst int MAX_N = 210;\nconst int MAX_T = 1005;\nconst int INF = 2*MAX_N*MAX_T;\nint N,M,R;\nint sea[MAX_N][MAX_N];\nint land[MAX_N][MAX_N];\nconst int MAX_R = 1005;\nint O[MAX_R];\nint dp[MAX_R][MAX_N];\nvoid show(char s) {\n    printf(\"\\n\");\n    if (s == 'L') {\n        printf(\"Land\\n\");\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                int n = land[i][j];\n                if (n == INF) printf(\"INF \");\n                else printf(\"%d \", n);\n            }\n            printf(\"\\n\");\n        }\n    } else if (s == 'S') {\n        printf(\"Sea\\n\");\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                int n = sea[i][j];\n                if (n == INF) printf(\"INF \");\n                else printf(\"%d \", n);\n            }\n            printf(\"\\n\");\n        }\n    }\n}\n\nint main(int argc, const char * argv[])\n{\n    while (true) {\n        scanf(\"%d %d\", &N, &M);  //町の番号は1~Nにする\n        if (N == 0 && M == 0) break;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 1; j <= N; j++) {\n                if (i == j) {\n                    sea[i][j] = land[i][j] = 0;\n                } else {\n                    sea[i][j] = land[i][j] = INF;\n                }\n            }\n        }\n        for (int i = 0; i < M; i++) {\n            int x,y,t;\n            char s;\n            scanf(\"%d %d %d %c\", &x, &y, &t, &s);\n            if (s == 'L') {\n                land[x][y] = land[y][x] = t;\n            } else if (s == 'S'){\n                sea[x][y] = sea[y][x] = t;\n            }\n        }\n        scanf(\"%d\", &R);\n        \n        for (int i = 0; i < R; i++) {\n            scanf(\"%d\", &O[i]);\n        }\n        \n        for (int k = 1; k <= N; k++) {\n            for (int i = 1; i <= N; i++) {\n                for (int j = 1; j <= N; j++) {\n                    land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n                    sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n                }\n            }\n        }\n        //確認\n        //show('L');\n        //show('S');\n        for (int i = 1; i <= N; i++) dp[0][i] = INF;\n        dp[0][O[0]] = 0;\n        \n        \n        for (int i = 1; i < R; i++) {\n            for (int j = 1; j <= N; j++) {\n                int minD = INF;\n                for (int k = 1; k <= N; k++) {\n                    if (j == k) {\n                        minD = min(minD, dp[i-1][j] + land[O[i-1]][O[i]]);\n                    } else {\n                        minD = min(minD, dp[i-1][k] + land[O[i-1]][k] + sea[k][j] + land[j][O[i]]);\n                    }\n                    //printf(\"minD=%d\\n\",minD);\n                }\n                dp[i][j] = minD;\n            }\n        }\n        int ret = INF;\n        for (int i = 1; i <= N; i++) ret = min(ret, dp[R-1][i]);\n        printf(\"%d\\n\", ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint result[101][101][10001];\n\nint dijk(vector<vector<pair<int, pair<int, bool> > > >& adjlist, vector<int>& z){\n  int n = adjlist.size();\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < z.size(); k++){\n        result[i][j][k] = INF;\n      }\n    }\n  }\n\n  \n  //vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<int, pair<int, int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  vector<vector<pair<int, pair<int, bool> > > > adjlist(201);\n  \n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    for(int i = 0; i <= n; i++){\n      adjlist[i].resize(0);\n    }\n    \n    int x, y, t;\n    string sl;\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(adjlist, z);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define INF (1<<24)\n\nint n,m,a,b,c,R;\nint r[1001];\nchar ch;\nint t[201][201];\nint u[201][201];\nint dp[201][1001];\n \nvoid init();\nint solve();\n  \nint main(){\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>ch;\n      a--;b--;\n      if(ch=='L'){\n\tt[a][b]=min(t[a][b],c);\n\tt[b][a]=min(t[b][a],c);\n      }else {\n\tu[a][b]=min(u[a][b],c);\n\tu[b][a]=min(u[b][a],c);\n      }\n    }\n    cin>>R;\n    for(int i=0;i<R;i++){\n      cin>>r[i];\n      r[i]--;\n    }\n \n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  u[i][j]=min(u[i][j],u[i][k]+u[k][j]);\n\t  t[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n\t}\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n  \nint solve(){\n  dp[r[0]][0]=0;\n  for(int i=0;i<R-1;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tdp[k][i+1]=min(dp[k][i+1],dp[j][i]+t[r[i]][j]+u[j][k]+t[k][r[i+1]]);\n      }\n      dp[j][i+1]=min(dp[j][i+1],dp[j][i]+t[r[i]][r[i+1]]);\n    }\n  }\n  int res=INF;\n  for(int i=0;i<n;i++)res=min(res,dp[i][R-1]);\n  return res;\n}\n  \nvoid init(){\n  for(int i=0;i<201;i++){\n    for(int j=0;j<201;j++){\n      if(i==j)u[i][j]=0;\n      else u[i][j]=INF;\n      t[i][j]=u[i][j];\n    }\n    for(int j=0;j<1001;j++)dp[i][j]=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mem(a) memset(a,2,sizeof(a))\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int mn=205;\n\nint n,m,r;\nint l[mn][mn];\nint s[mn][mn];//sea\nint c[1005];\nll d[1005][mn];\n\nll dp(int k,int t){\n    if (k==r) return 0;\n    ll &ans=d[k][t];\n    if (ans!=-1) return ans;\n    ans=1e15;\n    for(int i=1;i<=n;i++){//next boat position\n\t\tif (s[i][t]>3e7) continue;\n        ll u;\n        if (t==i) {\n\t\t\tif (l[c[k]][c[k+1]]>3e7) continue;\n\t\t\tu=l[c[k]][c[k+1]]+dp(k+1,i);\n        }\n        else {\n\t\t\tif (l[c[k]][t]>3e7||l[i][c[k+1]]>3e7) continue;\n\t\t\tu=l[c[k]][t]+l[i][c[k+1]]+s[i][t]+dp(k+1,i);\n        }\n       // printf(\"%d %d %d %lld\\n\",k,t,i,u);\n        ans=min(u,ans);\n    }\n    //printf(\"%d %d %lld\\n\",k,t,ans);\n    return ans;\n\n}\n\nchar S[6];\n\nint main() {\n\twhile(~scanf(\"%d%d\",&n,&m)&&n){\n        mem(l);mem(s);\n        for(int i=1;i<=n;i++) l[i][i]=s[i][i]=0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u,v,w;\n\t\t\tscanf(\"%d%d%d%s\",&u,&v,&w,S);\n\t\t\tif (S[0]=='L') l[u][v]=l[v][u]=min(w,l[u][v]);\n\t\t\telse s[u][v]=s[v][u]=min(w,s[u][v]);\n\t\t}\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n                    l[i][j]=min(l[i][k]+l[k][j],l[i][j]);\n\t\t\t\t\ts[i][j]=min(s[i][k]+s[k][j],s[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=1;i<=r;i++){\n\t\t\tscanf(\"%d\",&c[i]);\n\t\t}\n\t\tmemset(d,-1,sizeof d);\n\t\tprintf(\"%lld\\n\",dp(c[1],c[1]));\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    int land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<n;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      int b;cin>>b;b--;\n      a[i]=b;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(sea[i][k]!=inf && sea[k][j]!=inf)sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          if(land[i][k]!=inf && land[k][j]!=inf)land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    int dp[1001][201];\n    for(int i=0;i<r;i++)for(int j=0;j<n;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          if(land[a[i]][j]==inf)continue;\n          if(sea[j][k]==inf)continue;\n          if(land[k][a[i+1]]==inf)continue;\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n        }\n      }\n    }\n    int ans=inf;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  // for(int i = 1; i < r; i++){\n  // \tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n  // \t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n  // \t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n  // \t\telse dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][root[i]] );\n  // \t  }\n  // \t}\n  // }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tdp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t  }\n\t  dp[i][j] = min( dp[i][j], dp[i-1][j] + l[root[i-1]][root[i]] );\n\t}\n  }\n\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\tfor(int i = 0; i < n; i++) l[i].resize(n);\n\ts.resize(n);\n\tfor(int i = 0; i < n; i++) s[i].resize(n);\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t    if(i == j){\n\t\t  l[i][j] = 0;\n\t\t  s[i][j] = 0;\n\t\t}\n\t\telse{\n\t\t  l[i][j] = INF;\n\t\t  s[i][j] = INF;\n\t\t}\n\t  }\n\t}\n\n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ntypedef pair<int, int> P;\n\nconst int INF = 100000000;\n\nint dl[201][201], ds[201][201], n, m, dp[1000][201];\n\nint main(){\n\tint x, y, t, r, z, rz;\n\tchar sl;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n == 0) return 0;\n\t\t\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tdl[i][j] = INF;\n\t\t\t\tds[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){ dl[i][i] = 0; ds[i][i] = 0;}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n\t\t\t\n\t\t\tif(sl == 'L'){\n\t\t\t\tdl[x][y] = t;\n\t\t\t\tdl[y][x] = t;\n\t\t\t} else {\n\t\t\t\tds[x][y] = t;\n\t\t\t\tds[y][x] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k = 1; k <= n; k++){\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tscanf(\"%d%d\",&r,&rz);\n\t\t\n\t\tfor(int i = 1; i <= 200; i++){\n\t\t\tfor(int j = 0; j < r; j++){\n\t\t\t\tdp[j][i] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][rz] = 0;\n\t\t\n\t\t\n\t\tfor(int k = 1; k < r; k++){\n\t\t\tscanf(\"%d\",&z);\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k-1][j] + dl[rz][j] + ds[j][i] + dl[i][z]);\n\t\t\t\t\tif(i == j) dp[k][i] = min(dp[k][i], dp[k-1][j] + dl[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\trz = z;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor(int i = 1; i <= n; i++) ans = min(ans, dp[r-1][i]);\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200];\nint dp[1001][200];\n \nint main(){\n \n \n\twhile(scanf(\"%d %d\",&n,&m),n){\n\t\t\n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t\t\n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t\t\n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t   \n\t   int now,z;\n\t   scanf(\"%d\",&r);\n\t   scanf(\"%d\",&now); now--;\n\n\t   fill(&dp[0][0],&dp[1001][0],INF);\n\t   dp[0][now]=0;\n\t\t\n\t   for(int i=0;i<r-1;i++){\n\t\t   scanf(\"%d\",&z); z--;\n\t\t   \n\t\t   for(int j=0;j<n;j++){\n\t\t\t   dp[i+1][j]=min(dp[i+1][j],dp[i][j]+d[1][now][z]);\n\t\t\t   for(int k=0;k<n;k++){\n\t\t\t\t   // \n\t\t\t\t   dp[i+1][k]=min(dp[i+1][k],dp[i][j]+d[1][now][j]+d[0][j][k]+d[1][k][z]);\n\t\t\t   }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   now=z;\n\t   }\n\n\n/*\n\t   //int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t\t\n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t\t//if(i==r-1 && res>dp[i][k]) res=dp[i][k];\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t\t //if(i==r-1 && res>dp[i][j]) res=dp[i][j];\n\t\t  }\n\t   }\n*/\n\t   printf(\"%d\\n\",*min_element(dp[r-1],dp[r]));\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000000\t\n\nint land[200][200] , ship[200][200] ;\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m , n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tstring l;\n\t\t\tint a,b,c; cin >> a >> b >> c >> l;\n\t\t\ta--,b--;\n\t\t\tif(l==\"L\")land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tint r; cin >> r;\n\t\tint R[1000];\n\t\trep(i,r){\n\t\t\tcin >> R[i] , R[i]--;\n\t\t}\n\t\tint dp[2][200][200];\n\t\trep(i,2)rep(j,200)rep(k,200)dp[i][j][k] = INF;\n\t\tdp[0][R[0]][R[0]] = 0;\n\t\trep(bit,r-1){\n\t\t\trep(cur,200){\n\t\t\t\tif(dp[bit%2][R[bit]][cur] != INF){\n\t\t\t\t\trep(next,200){\n\t\t\t\t\t\tint newCost = dp[bit%2][R[bit]][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\t\tdp[(bit+1)%2][R[bit+1]][next] = \n\t\t\t\t\t\tmin( dp[(bit+1)%2][R[bit+1]][next],newCost);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,200)rep(j,200)dp[bit%2][i][j] = INF;\n\t\t}\n\t\tint ret = INF;\n\t\trep(i,200){\n\t\t\tret = min(dp[(r-1)%2][R[r-1]][i],ret);\n\t\t}\n\t\tcout << ret << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint main(){\n    int n, m, x, y, r;\n    ll t;\n    char sl;\n    while(scanf(\"%d%d\", &n, &m) &&  n!=0){\n        vector< vector<ll> > st(n, vector<ll>(n, LLONG_MAX)), lt(n, vector<ll>(n, LLONG_MAX));\n        rep(n){\n            st[i][i] = 0LL;\n            lt[i][i] = 0LL;\n        }\n        rep(m){\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'S'){\n                st[x][y] = min(st[x][y], t);\n                st[y][x] = min(st[y][x], t);\n            }else{\n                lt[x][y] = min(lt[x][y], t);\n                lt[y][x] = min(lt[y][x], t);\n            }\n        }\n\n        repp(k, n){\n            repp(i, n){\n                repp(j, n){\n                    if(st[i][k] != LLONG_MAX && st[k][j] != LLONG_MAX)\n                        st[i][j] = min(st[i][j], st[i][k] + st[k][j]);\n                    if(lt[i][k] != LLONG_MAX && lt[k][j] != LLONG_MAX)\n                        lt[i][j] = min(lt[i][j], lt[i][k] + lt[k][j]);\n                }\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(r){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // dp[i][j]: z[i]にいる，お船はjにあるときの最短時間\n        ll dp[r][n];\n        fill(dp[0], dp[r], LLONG_MAX);\n        dp[0][0] = 0LL;\n        rep(r-1){\n            repp(j, n){\n                if(dp[i][j] == LLONG_MAX) continue;\n                // z[i]からkまで徒歩，kからlまで船，lからz[i+1]まで徒歩\n                repp(k, n){\n                    repp(l, n){\n                        if(st[z[i]][k] != LLONG_MAX && lt[k][l] != LLONG_MAX && st[l][z[i+1]] != LLONG_MAX){\n                            dp[i+1][l] = min(dp[i+1][k], dp[i][j]+st[z[i]][k]+lt[k][l]+st[l][z[i+1]]);\n                        }\n                    }\n                }\n                // 徒歩だけで行く\n                if(lt[z[i]][z[i+1]] != LLONG_MAX){\n                    dp[i+1][j] = min(dp[i+1][j], dp[i][j] + lt[z[i]][z[i+1]]);\n                }\n            }\n        }\n\n        // rep(r){\n        //     repp(j, n){\n        //         printf(\"%5lld\", (dp[i][j] == LLONG_MAX?-1:dp[i][j]));\n        //     }\n        //     printf(\"\\n\");\n        // }\n\n        ll ans = LLONG_MAX;\n        repp(j, n){\n            ans = min(ans, dp[r-1][j]);\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int INF = INT_MAX / 4;\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n, m;\n\t\tcin >> n >> m;\n\n\t\tif ( !( n | m ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tVVI Gl( n, VI( n, INF ) ), Gs = Gl;\n\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tGl[i][i] = Gs[i][i] = 0;\n\t\t}\n\n\t\tREP( i, 0, m )\n\t\t{\n\t\t\tint v, u, c;\n\t\t\tchar t;\n\n\t\t\tcin >> v >> u >> c >> t;\n\n\t\t\tv--;\n\t\t\tu--;\n\n\t\t\tswitch ( t )\n\t\t\t{\n\t\t\t\tcase 'L':\n\t\t\t\t\tGl[v][u] = Gl[u][v] = c;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'S':\n\t\t\t\t\tGs[v][u] = Gs[u][v] = c;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tREP( k, 0, n )\n\t\t{\n\t\t\tREP( i, 0, n )\n\t\t\t{\n\t\t\t\tREP( j, 0, n )\n\t\t\t\t{\n\t\t\t\t\tGl[i][j] = min( Gl[i][j], Gl[i][k] + Gl[k][j] );\n\t\t\t\t\tGs[i][j] = min( Gs[i][j], Gs[i][k] + Gs[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint r;\n\t\tcin >> r;\n\n\t\tVI zs( r );\n\n\t\tEACH( z, zs )\n\t\t{\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t}\n\n\t\tVVI dp( r, VI( n, INF ) );\n\t\tdp[0][ zs[0] ] = 0;\n\n\t\tREP( i, 0, dp.size() - 1 )\n\t\t{\n\t\t\tREP( j, 0, dp[i].size() )\n\t\t\t{\n\t\t\t\tif ( dp[i][j] == INF )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tdp[ i + 1 ][j] = min( dp[ i + 1 ][j], dp[i][j] + Gl[ zs[i] ][ zs[ i + 1 ] ] );\n\n\t\t\t\tREP( k, 0, n )\n\t\t\t\t{\n\t\t\t\t\tint &next = dp[ i + 1 ][k];\n\n\t\t\t\t\tnext = min( next, dp[i][j] + Gl[ zs[i] ][j] + Gs[j][k] + Gl[k][ zs[ i + 1 ] ] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << *min_element( ALL( dp.back() ) ) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define INF (1e15)\n#define M 1005\n#define N 205\nusing namespace std;\ntypedef long long ll;\n\nll n,m,r,z[M],sld[2][N][N];\n\nvoid init(){\n  rep(i,2)\n    rep(j,n)\n      rep(k,n)\n        sld[i][j][k]=INF;  \n}\n\nvoid add_edge(ll sl,ll x,ll y,ll t){\n  sld[sl][x][y]=sld[sl][y][x]=min(sld[sl][x][y],t);\n}\n\nvoid warshall_floyd(){\n  rep(sl,2) rep(k,n) rep(i,n) rep(j,n)\n    sld[sl][i][j]=min(sld[sl][i][j],sld[sl][i][k]+sld[sl][k][j]);\n  rep(sl,2)\n    rep(i,n)sld[sl][i][i]=0;\n}\n\nll dp[M][N];\n\nvoid solve(){\n  rep(i,r)\n    rep(j,n)dp[i][j]=INF;\n  dp[0][0]=0;\n  \n  rep(i,r-1)\n    rep(j,n){\n      if(dp[i][j]==INF)continue;\n      ll cost=dp[i][j]+sld[0][z[i]][z[i+1]];\n      dp[i+1][j]=min(dp[i+1][j],cost);\n      rep(k,n){\n\tll cost2=dp[i][j]+sld[0][z[i]][j];\n\tcost2+=sld[1][j][k]+sld[0][k][z[i+1]];\n\tdp[i+1][k]=min(dp[i+1][k],cost2);\n      }\n    }\n  ll ans=INF;\n  rep(i,n)ans=min(ans,dp[r-1][i]);\n  cout<<ans<<endl;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    ll x,y,t;\n    char sl;\n    \n    init();\n    \n    rep(i,m){\n      cin>>x>>y>>t>>sl;\n      x--,y--;\n      if(sl=='L')add_edge(0,x,y,t);\n      else add_edge(1,x,y,t);\n    }\n    \n    warshall_floyd();\n \n    cin>>r;\n    rep(i,r)cin>>z[i],z[i]--;\n    \n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nconst int MAX_V = 205;\nconst int MAX_R = 1005;\nint gl[MAX_V][MAX_V], gs[MAX_V][MAX_V];\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M, N||M){\n\t\tinit(gl);\n\t\tinit(gs);\n\t\trep(i,N){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tgl[x][y] = gl[y][x] = min(t, gl[x][y]);\n\t\t\t}else{\n\t\t\t\tgs[x][y] = gs[y][x] = min(t, gs[x][y]);\n\t\t\t}\n\t\t}\n\t\twarshallFloyd(gl,N);\n\t\twarshallFloyd(gs,N);\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> z(R);\n\t\trep(i,R){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tint dp[MAX_R][MAX_V];\n\t\trep(i,MAX_V) rep(j,MAX_V) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\n\t\trep(i,R - 1){\n\t\t\tint cur = z[i];\n\t\t\tint next = z[i + 1];\n\t\t\t//rep(j,N) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][next]);\n\t\t\trep(j,N){\n\t\t\t\trep(k,N){\n\t\t\t\t\tassert(i + 1 < R);\n\t\t\t\t\tassert(cur < N);\n\t\t\t\t\tassert(next < N);\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\t\t\t//show(dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,R){\n\t\t//\trep(j,N){\n\t\t//\t\tif(dp[i][j] >= INF) cout << \"_\";\n\t\t//\t\telse cout << dp[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint mini = INT_MAX;\n\t\trep(i,N){\n\t\t\tmini = min(mini, dp[R - 1][i]);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define INF 1e8\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint N,M,R,z[1000],L[200][200],S[200][200],dp[1000][200];\n\nint main(){\n\twhile(cin>>N>>M&&N){\n\t\trep(i,N){\n\t\t\tfill(L[i],L[i]+N,INF);\n\t\t\tfill(S[i],S[i]+N,INF);\n\t\t}\n\t\trep(i,N){\n\t\t\tL[i][i]=0;\n\t\t\tS[i][i]=0;\n\t\t}\n\t\tint x,y,t;\n\t\tchar c;\n\t\trep(i,M){\n\t\t\tcin>>x>>y>>t>>c;\n\t\t\tx--;y--;\n\t\t\tif(c=='L')L[x][y]=(L[y][x]=min(L[x][y],t));\n\t\t\telse S[x][y]=(S[y][x]=min(S[x][y],t));\n\t\t}\n\t\tcin>>R;\n\t\trep(i,R)fill(dp[i],dp[i]+N,INF);\n\t\trep(i,R){\n\t\t\tcin>>z[i];z[i]--;\n\t\t\tif(!i)dp[i][z[i]]=0;\n\t\t}\n\t\trep(i,N)rep(j,N)rep(k,N){\n\t\t\tL[j][k]=min(L[j][k],L[j][i]+L[i][k]);\n\t\t\tS[j][k]=min(S[j][k],S[j][i]+S[i][k]);\n\t\t}\n\t\tfor(int i=1;i<R;i++)rep(j,N){\n\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+L[z[i-1]][z[i]]);\n\t\t\trep(k,N)dp[i][k]=min(dp[i][k],dp[i-1][j]+L[z[i-1]][j]+S[j][k]+L[k][z[i]]);\n\t\t}\n\t\tint ans=INF;\n\t\trep(i,N)ans=min(ans,dp[R-1][i]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n#include <complex>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\ntypedef TIII state;\nint INF;\nint dist[222][222];\nmap<int, int> S[222];\nint z[1111];\n\nint main(){\n\tINF = 1000000000;\n\tREP(i,222)REP(j,222)dist[i][j] = INF;\n\twhile(1){\n\t\tint n,m,r;\n\t\tcin>>n>>m;\n\t\tREP(i,222)S[i].clear();\n\t\tif(n==0)return 0;\n\t\tREP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--, y--;\n\t\t\tif(sl=='L')dist[y][x] = dist[x][y] = t;\n\t\t\telse{\n\t\t\t\tif(EXIST(S[x], y))S[y][x] = S[x][y] = min(S[x][y], t);\n\t\t\t\telse S[y][x] = S[x][y] = t;\n\t\t\t}\t\t\t\n\t\t}\n\t\tREP(i,n)dist[i][i] = 0;\n\t\tREP(k,n){\n\t\t\tREP(i,n){\n\t\t\t\tREP(j,i){\n\t\t\t\t\tdist[i][j] = dist[j][i] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>r;\n\t\tREP(i,r){\n\t\t\tscanf(\"%d\", &z[i]);\n\t\t\tz[i]--;\n\t\t}\n\t\tstate st = MT(0, 0, z[0]);\n\t\tpriority_queue<state, vector<state>, greater<state> > q;\n\t\tq.push(st);\n\t\twhile(!q.empty()){\n\t\t\tstate tst = q.top();\n\t\t\tq.pop();\n\t\t\tif(tst.T2 == r-1){\n\t\t\t\tcout << tst.T1 << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(dist[z[tst.T2]][z[tst.T2+1]]<INF){\n\t\t\t\tstate rst = MT(dist[z[tst.T2]][z[tst.T2+1]]+tst.T1, tst.T2+1, tst.T3);\n\t\t\t\tq.push(rst);\n\t\t\t}\n\t\t\tint D = dist[z[tst.T2]][tst.T3] + tst.T1;\n\t\t\tfor(map<int, int>::iterator it = S[tst.T3].begin(); it!=S[tst.T3].end(); it++){\n\t\t\t\tif(dist[it->first][z[tst.T2+1]]<INF){\n\t\t\t\t\tq.push(MT(D+it->second+dist[it->first][z[tst.T2+1]], tst.T2+1, it->first));\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\tlong long cnt = INF;\n\twhile (!Q.empty()) {\n\t\tif (cnt == 0) { return; }\n\t\tcnt = 0;\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (!Q.empty()) { Q.pop(); }\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 210;\nconst int MAX_R = 1010;\nconst int INF = 1e9 + 7;\n\nclass C{\n  public:\n    int t, n, s, c;\n    C(int _t, int _n, int _s, int _c) { t = _t; n = _n; s = _s; c = _c; }\n    bool operator > (const C &_) const { return t != _.t ? t > _.t : c < _.c; }\n};\n\nint closed[MAX_N][MAX_N][MAX_R];\n\nint solve(int G[MAX_N][MAX_N][2], vector<int> &v, int N, int R){\n  priority_queue<C, vector<C>, greater<C> > open;\n  open.push(C(0, 0, 0, 1));\n  REP(i, MAX_N) REP(j, MAX_N) REP(k, MAX_R) closed[i][j][k] = INF;\n  closed[v[0]][v[0]][0] = 0;\n  while(!open.empty()){\n    C tmp = open.top(); open.pop();\n    int n = tmp.n, t = tmp.t, s = tmp.s, c = tmp.c;\n\n    REP(next, N){\n      REP(f, 2){\n        int cost = G[n][next][f];\n        if(cost == INF) continue;\n        int nc = (v[c] == next ? c + 1 : c), nt = t + cost, ns = (f ? next : s);\n        if((f && s != n) || closed[next][ns][nc] <= nt) continue;\n        closed[next][ns][nc] = nt;\n        if(nc < v.size()) open.push(C(nt, next, ns, nc));\n        open.push(C(nt, next, ns, nc));\n      }\n    }\n  }\n  int ans = INF;\n  REP(i, N) ans = min(ans, closed[v[N - 1]][i][R]);\n  return ans;\n}\n\nint main() {\n  int N, M;\n  while(cin >>N >>M && N){\n    int G[MAX_N][MAX_N][2];\n    REP(i, MAX_N) REP(j, MAX_N) REP(k, 2) G[i][j][k] = INF;\n    REP(i, M){\n      int f, t, c; char a;\n      cin >>f >>t >>c >>a;\n      --f; --t;\n      int b = a == 'L' ? 0 : 1;\n      G[f][t][b] = min(G[f][t][b], c);\n      G[t][f][b] = min(G[t][f][b], c);\n    }\n    int R; cin >>R;\n    vector<int> v(R);\n    REP(i, R) { cin >>v[i]; --v[i]; }\n    cout <<solve(G, v, N, R) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nÁ·Ï°Ìâ£ºMr.Rito Post Office_AOJ 2200 \n\tÏÈµ¥¶À¿¼ÂÇÖ»×ßË®Â·»òºµÂ·µÄÇé¿ö£¬ÓÃwarshall_floydÇó³öÈÎÒâÁ½µã¼äµÄ×î¶ÌÂ·¡£\n\tÈ»ºó¶¨Òå dp[i][k] := ÒÑ¾­È¥ÁËµÚi¸öÕò×Óºó£¬´¬Í£ÔÚµÚk¸öÕò×ÓÀïµÄ×´Ì¬ÏÂµÄ×î¶ÌÂ·¡£\n\tÈ»ºóijkÈýÖØÑ­»·¸üÐÂdp£¬ÆäÖÐµÝÍÆ¹«Ê½Ë¼Â·£º\n\tÔÚÍÆµ¼ikµÄÊ±ºò£¬¶¨ÒåÒ»¸öÖÐ¼ä×´Ì¬j±íÊ¾ÏÈ´Ói-1×ßºµÂ·µ½j£¬\n\tÈ»ºó´Ój×ßË®Â·È¥k£¬×îºó´Ók×ßºµÂ·È¥i£¬ÓÚÊÇ¾Í°Ñ´¬ÈÓÔÚÁËk¡£\n\tÈç¹ûj==kµÄÊ±ºò¾Í²»ÐèÒªÈÆÈ¦×ÓÁË¡£\n*/\n\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n \n#define INF 1e8\n#define MAX_V 256\n#define MAX_R 1024\nint dl[MAX_V][MAX_V];\t//\td[u][v]±íÊ¾±ße=(u,v)µÄÈ¨Öµ£¬²»´æÔÚµÄÊ±ºòµÈÓÚÎÞÇî´ó»òÕßd[i][i] = 0\nint ds[MAX_V][MAX_V];\nint z[MAX_R];\nint dp[MAX_R][MAX_V];\t// dp[i][j] := ÒÑ¾­È¥ÁËµÚi¸öÕò×Óºó£¬´¬Í£ÔÚµÚj¸öÕò×ÓÀï\nint N;\t\t\t\t\t//\t¶¥µãÊý\n \n///////////////////////////SubMain//////////////////////////////////\nint main(int argc, char *argv[])\n{\n \n\tint M;\n\twhile (cin >> N >> M , N || M)\n\t{\n// \t\tmemset(dl, 0x3f, sizeof(dl));\n// \t\tmemset(ds, 0x3f, sizeof(ds));\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif (i == j)\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = ds[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = ds[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tfor (int i = 0; i < M; ++i)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t--x; --y;\n\t\t\tif (s == 'L')\n\t\t\t{\n\t\t\t\tdl[x][y] = min(dl[x][y], t);\n\t\t\t\tdl[y][x] = dl[x][y];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tds[x][y] = min(ds[x][y], t);\n\t\t\t\tds[y][x] = ds[x][y];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint R;\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; ++i)\n\t\t{\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n \n\t\t// warshall_floyd\n\t\tfor (int k = 0; k < N; ++k)\n\t\t{\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t\t{\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// end of warshall_floyd\n \n\t\t// dp\n\t\t// ÄáÂê3¸ö0x3f3f3f3f¼ÓÆðÀ´Òç³öÁË\n\t\t//memset(dp, 0x3f, sizeof(dp));\n\t\tfor (int i = 0; i < R; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\t// È¥ÁËÊ×¸öÕò×Óºó£¬´¬·ÅÔÚµÚi¸öÕò×ÓÀï\n\t\t\t\t\t\t// ×ø´¬È¥\t // ×ø11Â·³µ»ØÀ´\n\t\t\tdp[0][i] = ds[z[0]][i] + dl[i][z[0]];\n\t\t}\n\t\tfor (int i = 1; i < R; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < N; ++k)\n\t\t\t\t{\n\t\t\t\t\tif (j != k)\n\t\t\t\t\t{\n\t\t\t\t\t\t//                          i-1Õ¾     + ´Ói-1Õ¾×ßºµÂ·È¥j+ ´Ój×ßË®Â·È¥k+´Ók×ßºµÂ·È¥i\n\t\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[z[i - 1]][j] + ds[j][k] + dl[k][z[i]]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// j == k                   i-1Õ¾     + ´Ói-1Õ¾×ßºµÂ·È¥i\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + dl[z[i - 1]][z[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n\t\tcout << *min_element(dp[R - 1], dp[R - 1] + N) << endl;\n\t}\n \n\treturn 0;\n}\n///////////////////////////End Sub//////////////////////////////////\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<climits>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n\nint land[202][202];\nint sea[202][202];\n\nconst int inf = INT_MAX / 4;\n\nint main() {\n  for(int N, M; cin >> N >> M, (N || M); ) {\n    REP(i, N) REP(j, N) land[i][j] = inf;\n    REP(i, N) REP(j, N) sea[i][j] = inf;\n\n    REP(i, M) {\n      int a, b, c;\n      char ch;\n      scanf(\"%d%d%d %c\", &a, &b, &c, &ch);\n      a--, b--;\n      if( ch == 'L' )\n        land[a][b] = land[b][a] = c;\n      else\n        sea[a][b] = sea[b][a] = c;\n    }\n\n    int R;\n    static int Z[1024];\n    scanf(\"%d\", &R);\n    REP(r, R) scanf(\"%d\", &Z[r]);\n    REP(r, R) Z[r]--;\n\n    REP(i, N) land[i][i] = sea[i][i] = 0;\n    REP(k, N) REP(i, N) REP(j, N) land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n    REP(k, N) REP(i, N) REP(j, N) sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\n    static int dp[202][1024];\n    REP(i, 202) REP(j, 1024) dp[i][j] = inf;\n    dp[Z[0]][0] = 0;\n    REP(r, R - 1) REP(ship, N) {\n      int next = dp[ship][r + 1];\n      next = min(next, dp[ship][r] + land[Z[r]][Z[r + 1]]);\n      REP(mship, N)\n        next = min(next, dp[mship][r] + land[Z[r]][mship] + sea[mship][ship] + land[ship][Z[r + 1]]);\n      dp[ship][r+1] = next;\n    }\n\n    int best = inf;\n    REP(ship, N)\n      best = min(best, dp[ship][R - 1]);\n    cout << best << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N, M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n    \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int j = 0 ; j < N ; j++){\n        for(int i = 0 ; i < N ; i++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n\tdp[r][j]=min(dp[r][j], dp[r-1][j] + G1[now][next] );\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[1010],W[N][N],L[N][N];\nll dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        for (int i=1;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                dp[i][j]=1e18;\n            }\n        }\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i]+L[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=1e18) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    ll dis1=L[z[i-1]][k];\n                    ll dis2=W[k][j];\n                    ll dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=1e18) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        ll ans=1e18;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef long double ld;\nconst ll INF = mod * mod/3;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef complex<ld> Point;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\n#define fr first\n#define sc second\n\nvoid solve() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tvector<vector<ll>> dl(n), ds(n);\n\t\trep(i, n) {\n\t\t\tdl[i].resize(n, INF);\n\t\t\tds[i].resize(n, INF);\n\t\t\tdl[i][i] = ds[i][i] = 0;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y;ll t; char s; cin >> x >> y >> t >> s; x--; y--;\n\t\t\tif (s == 'L') {\n\t\t\t\tdl[x][y] = dl[y][x] = min(dl[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tds[x][y] = ds[y][x] = min(ds[x][y], t);\n\t\t\t}\n\t\t}\n\t\t//WF\n\t\trep(k, n) {\n\t\t\trep(i, n) {\n\t\t\t\trep(j, n) {\n\t\t\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint r; cin >> r; vector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i]; z[i]--;\n\t\t}\n\t\tvector<ll> dp(n, INF);\n\t\tdp[z[0]] = 0;\n\t\trep1(i, r - 1) {\n\t\t\tvector<ll> cop(n, INF);\n\t\t\trep(j, n) {\n\t\t\t\trep(k, n) {\n\t\t\t\t\tll sum;\n\t\t\t\t\tif (j != k) {\n\t\t\t\t\t\tsum = dl[z[i - 1]][j] + ds[j][k] + dl[k][z[i]];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tsum = dl[z[i - 1]][z[i]];\n\t\t\t\t\t}\n\t\t\t\t\tcop[k] = min(cop[k], sum + dp[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, n) {\n\t\t\t\tdp[j] = cop[j];\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\trep(i, n) {\n\t\t\tans = min(ans, dp[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = INT_MAX/3;\nint riku[210][210];\nint umi[210][210];\nint dp[1010][210]; // [ツ妥ョツ配][ツ船ツづ個暗環置]\n\nint main(){\n  int n,m;\n  int taku[1010];\n\n  while(scanf(\"%d%d\",&n,&m),n|m){\n    //init\n    //rep(i,210)rep(j,210)riku[i][j]=umi[i][j]=inf;\n    rep(i,210){\n      fill(riku[i], riku[i]+210, inf);\n      fill(umi[i], umi[i]+210, inf);\n    }\n    rep(i,210)riku[i][i]=umi[i][i]=0;\n    //rep(i,1010)rep(j,210)dp[i][j]=inf;\n    rep(i,1010) fill(dp[i], dp[i]+210, inf);\n\n    rep(i,m){\n      int a,b,c; char l;\n      scanf(\" %d %d %d %c \",&a,&b,&c,&l);\n      a--, b--;\n      if( l=='S' ){\n\tint d = min(umi[a][b],c);\n\tumi[a][b] = umi[b][a] = d;\n      }else{\n\tint d = min(riku[a][b],c);\n\triku[a][b] = riku[b][a] = d;\n      }\n    }\n    int R; cin>>R;\n    rep(i,R){\n      int r; scanf(\"%d\",&r); r--;\n      taku[i] = r;\n    }\n\n    // worshal\n    rep(k,n)rep(i,n)rep(j,n){\n      if( riku[i][k]!=inf && riku[k][j]!=inf ){\n\triku[i][j] = min(riku[i][j], riku[i][k]+riku[k][j]);\n      }\n      if( umi[i][k]!=inf && umi[k][j]!=inf ){\n\tumi[i][j] = min(umi[i][j], umi[i][k]+umi[k][j]);\n      }\n    }\n\n    dp[1][taku[0]] = 0;\n    REP(r,1,R){\n      int v = taku[r-1];\n      int u = taku[r];\n      rep(j,n){\n\tif( riku[v][u]!=inf ) dp[r+1][j] = min(dp[r+1][j], dp[r][j]+riku[v][u]);\n\tif( riku[v][j]==inf ) continue;\n\trep(i,n){\n\t  if( umi[j][i]==inf || riku[i][u]==inf )continue;\n\t  dp[r+1][i] = min(dp[r+1][i], dp[r][j]+riku[v][j]+umi[j][i]+riku[i][u]);\n\t}\n      }\n    }\n    int ans = inf;\n    rep(i,n)ans=min(ans,dp[R][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n#define M 1000000000\n#define ll long long\nint m, n, r, x, y, t;\nchar c;\nint a[1005];\nint s[201][201];\nint l[201][201];\nll dp[1005][205];\nint main() {\n    while ((~scanf(\"%d %d\", &n, &m)) && m && n) {\n        for (int i = 1; i <= n; ++i)\n            for (int j = 1; j <= n; ++j)\n                if (i == j) s[i][j] = l[i][j] = 0;\n                else s[i][j] = l[i][j] = M;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d %d %c\", &x, &y, &t, &c);\n            if (c == 'L') l[x][y] = l[y][x] = min(l[x][y], t);\n            else s[x][y] = s[y][x] = min(s[x][y], t);\n        }\n        for (int k = 1; k <= n; ++k)\n            for (int i = 1; i <= n; ++i)\n                for (int j = 1; j <= n; ++j) {\n                    s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n                    l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                }\n        scanf(\"%d\", &r);\n        for (int i = 0; i < r; ++i) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < r; ++i) for (int j = 1; j <= n; ++j) dp[i][j] = M;\n        for (int i = 1; i <= n; ++i) dp[0][i] = s[i][a[0]] + l[i][a[0]];\n        for (int i = 1; i < r; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                for (int k = 1; k <= n; ++k) {\n                    if (j != k) dp[i][k] = min(dp[i][k], dp[i - 1][j] + l[a[i - 1]][j] + s[j][k] + l[k][a[i]]);\n                    else dp[i][j] = min(dp[i][j], dp[i - 1][j] + l[a[i - 1]][a[i]]);\n                }\n                //printf(\"%d \",dp[i][j]);\n            }//printf(\"\\n\");\n        }\n        ll ans = M;\n        for (int i = 1; i <= n; ++i) ans = min(ans, dp[r - 1][i]);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 1000000000000LL\ntypedef long long ll;\nll d[200][200];\nll se[200][200];\nll dp[2][200];\nint z[1000];\nll min(ll a,ll b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\td[i][j]=INF;\n\t\tse[i][j]=INF;\n\t\tif(i==j){\n\t\t\td[i][j]=0;\n\t\t\tse[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b;\n\t\tll c;\n\t\tchar p;\n\t\tscanf(\"%d %d %lld %c\",&a,&b,&c,&p);\n\t\ta--;b--;\n\t\tif(p=='L'){\n\t\t\td[a][b]=min(d[a][b],c);\n\t\t\td[b][a]=min(d[b][a],c);\n\t\t}\n\t\tif(p=='S'){\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++){\n\t\tscanf(\"%d\",&z[i]);\n\t\tz[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][z[0]]=0;\n\tfor(i=1;i<p;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i%2][j]=INF;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][k]+d[z[i-1]][k]+se[k][j]+d[j][z[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+d[z[i-1]][z[i]]);\n\t\t}\n\t}\n\tll ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(p+1)%2][i]);\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int inf=1<<28;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint n,m;\n\nint lcost[210][210];\nint scost[210][210];\nint dp[1010][210];\n\nint r;\nint z[1010];\n\nint main(void){\n\t\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,210)rep(j,210) lcost[i][j]=scost[i][j]=(i==j)?0:inf;\n\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;y--;\n\t\t\tif(sl=='S'){\n\t\t\t\tscost[x][y]=min(scost[x][y],t);\n\t\t\t\tscost[y][x]=min(scost[y][x],t);\n\t\t\t}else{\n\t\t\t\tlcost[x][y]=min(lcost[x][y],t);\n\t\t\t\tlcost[y][x]=min(lcost[y][x],t);\n\t\t\t}\n\t\t}\n\n\t\tcin >> r;\n\t\trep(i,r){cin >> z[i];z[i]--;}\n\n\t\trep(k,n)rep(i,n)rep(j,n) scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n) lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n\n\t\trep(i,1010)rep(j,210) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n)rep(k,n) dp[i+1][k]=min(dp[i+1][k],dp[i][j]+lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]]);\n\t\tint ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl; \n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(300+1,300+1,INF);\n        cout << __LINE__ << endl;\n        rep(i,n-1){\n            if(i == 0){\n                rep(k,n)dp[0][k] = Ld[v[i]][k] + Sd[v[i]][k] + Ld[k][v[i]];\n            }\n            rep(j,n){\n                rep(k,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[n-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll long long\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,x;\n#define N 210\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nint dpl[N][N];\nint dps[N][N];\nint des[1010];\nint dp[N][N];\nvoid Init(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(i == j) dpl[i][j] = dps[i][j] = 0;\n\t\t\telse\n\t\t\t\tdpl[i][j] = dps[i][j] = 100000000;\n\t\t}\n\t}\n}\nvoid Floyd(){\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdpl[i][j] = Min(dpl[i][j],dpl[i][k]+dpl[k][j]);\n\t\t\t\tdps[i][j] = Min(dps[i][j],dps[i][k]+dps[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n    while(scanf(\"%d%d\",&n,&m)!=EOF && n+m){\n    \tint u,v,c;\n    \tchar ch[5];\n    \tInit();\n    \tfor(int i=0;i<m;i++){\n    \t\tscanf(\"%d%d%d%s\",&u,&v,&c,ch);\n    \t\tu--,v--;\n    \t\tif(ch[0] == 'L'){\n    \t\t\tdpl[u][v] = dpl[v][u] = Min(dpl[u][v],c);\n    \t\t}else{\n    \t\t\tdps[u][v] = dps[v][u] = Min(dps[u][v],c);\n    \t\t}\n    \t}\n    \tint d;\n    \tsf(d);\n    \tfor(int i=0;i<d;i++){\n    \t\tsf(u);\n    \t\tu--;\n    \t\tdes[i] = u;\n    \t}\n    \tFloyd();\n    \tfor(int i=0;i<n;i++)\n    \t\tfor(int j=0;j<n;j++)\n    \t\t\tdp[i][j] = 100000000;\n\n    \tfor(int i=0;i<n;i++)\n    \t\tdp[0][i] = dps[des[0]][i]+dpl[i][des[0]];\n    \tfor(int i=1;i<d;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tfor(int k=0;k<n;k++){\n    \t\t\t\tif(j != k)\n    \t\t\t\tdp[i][k] = Min(dp[i][k],dp[i-1][j]+dpl[des[i-1]][j]+dps[j][k]+dpl[k][des[i]]);\n    \t\t\t\telse\n    \t\t\t\t\tdp[i][j] = Min(dp[i][j],dp[i-1][j]+dpl[des[i-1]][des[i]]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint ans = INF;\n    \tfor(int i=0;i<n;i++)\n    \t\tans = Min(ans,dp[d-1][i]);\n    \tprintf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define mp\tmake_pair\n#define mt \tmake_tuple\n#define pb \tpush_back\nconst int inf=1e9;\n\nint dp[210][210];\nvector<pii> edgel[210],edges[210];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n>0){\n\t\trep(i,n){\n\t\t\tedgel[i].clear();\n\t\t\tedges[i].clear();\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,t;\tchar sl;\tcin>>x>>y>>t>>sl;\n\t\t\tx--;\ty--;\n\t\t\tif(sl=='L'){\n\t\t\t\tedgel[x].pb(mp(y,t));\n\t\t\t\tedgel[y].pb(mp(x,t));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tedges[x].pb(mp(y,t));\n\t\t\t\tedges[y].pb(mp(x,t));\n\t\t\t}\n\t\t}\n\t\tint r;\tcin>>r;\n\t\tvint z(r);\n\t\trep(i,r){\n\t\t\tcin>>z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,n)\trep(j,n)\tdp[i][j]=inf;\n\t\tdp[z[0]][z[0]]=0;\n\t\tsrep(i,1,r){\n\t\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\t\trep(j,n){\n\t\t\t\tif(z[i-1]==j){\n\t\t\t\t\trep(k,n)\tif(dp[j][k]!=inf)\tpq.push(mt(-dp[j][k],j,k));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trep(k,n)\tdp[j][k]=inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edgel[pos].size()){\n\t\t\t\t\tint to=edgel[pos][j].first,add=edgel[pos][j].second;\n\t\t\t\t\tif(dp[to][f]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][f]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][f],to,f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n)\tif(dp[j][j]!=inf)\tpq.push(mt(-dp[j][j],j,j));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edges[pos].size()){\n\t\t\t\t\tint to=edges[pos][j].first,add=edges[pos][j].second;\n\t\t\t\t\tif(dp[to][to]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][to]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][to],to,to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j,n)\trep(k,n)\tif(dp[j][k]!=inf)\tpq.push(mt(-dp[j][k],j,k));\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edgel[pos].size()){\n\t\t\t\t\tint to=edgel[pos][j].first,add=edgel[pos][j].second;\n\t\t\t\t\tif(dp[to][f]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][f]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][f],to,f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=inf;\n\t\trep(i,n)\tret=min(ret,dp[z[r-1]][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX;\n\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M, N) {\n\t\tvvl ldist(N, vl(N, INF));\n\t\tvvl sdist(N, vl(N, INF));\n\t\tll x, y, t;\n\t\tchar sl;\n\t\tREP(i, M) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;\n\t\t\ty--;\n\t\t\tif(sl == 'L') {\n\t\t\t\tldist[x][y] = min(ldist[x][y], t);\n\t\t\t\tldist[y][x] = min(ldist[y][x], t);\n\t\t\t} else {\n\t\t\t\tsdist[x][y] = min(sdist[x][y], t);\n\t\t\t\tsdist[y][x] = min(sdist[y][x], t);\n\t\t\t}\n\t\t}\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvi z(R);\n\t\tint tmp;\n\t\tREP(i, R) {\n\t\t\tcin >> tmp;\n\t\t\tz[i] = tmp-1;\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tldist[j][k] = min(ldist[j][k], ldist[j][i]+ldist[i][k]);\n\t\t\t\t\tsdist[j][k] = min(sdist[j][k], sdist[j][i]+sdist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tldist[i][i] = sdist[i][i] = 0;\n\t\t}\n\n\t\tvvl dp(R, vl(N, INF));\n\t\tdp[0][z[0]] = 0;\n\t\tREP(i, R-1) {\n\t\t\tint from = z[i], to = z[i+1];\n\t\t\tREP(before, N) {\n\t\t\t\tif(dp[i][before] == INF) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tREP(after, N) {\n\t\t\t\t\tll cost = INF;\n\t\t\t\t\tcost = min(cost, ldist[from][before] + sdist[before][after] + ldist[after][to]);\n\t\t\t\t\tdp[i+1][after] = min(dp[i+1][after], dp[i][before]+cost);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n//  AOJ 2200 Mr. Rito Post Office\n//\n//  Created by TaoSama on 2015-03-20\n//  Copyright (c) 2015 TaoSama. All rights reserved.\n//\n#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <set>\n#include <vector>\n#define CLR(x,y) memset(x, y, sizeof(x))\n\nusing namespace std;\nconst int INF = 0x3f3f3f3f;\nconst int MOD = 1e9 + 7;\nconst int N = 1e5 + 10;\n\nint sea[205][205], land[205][205], dp[205][205];\nint n, m, r, a[1005];\n\nint main() {\n#ifdef LOCAL\n    freopen(\"in.txt\", \"r\", stdin);\n//\tfreopen(\"out.txt\",\"w\",stdout);\n#endif\n    ios_base::sync_with_stdio(0);\n\n    while(cin >> n >> m && (n + m)) {\n        for(int i = 1; i <= n; ++i)\n            for(int j = 1; j <= n; ++j)\n                sea[i][j] = land[i][j] = i == j ? 0 : INF;\n\n        for(int i = 1; i <= m; ++i) {\n            int x, y, t; char c;\n            cin >> x >> y >> t >> c;\n            if(c == 'S') sea[x][y] = sea[y][x] = min(sea[x][y], t);\n            else land[x][y] = land[y][x] = min(land[x][y], t);\n        }\n\n        cin >> r;\n        for(int i = 1; i <= r; ++i)  cin >> a[i];\n\n        //Floyd\n        for(int k = 1; k <= n; ++k) {\n            for(int i = 1; i <= n; ++i) {\n                for(int j = 1; j <= n; ++j) {\n                    sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n                    land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n                }\n            }\n        }\n\n        /*dp[i][j]:= 蛻ー霎セi髟?ュ?闊ケ蛛懷惠j髟?ュ千噪譛?ー乗慮髣エ */\n        memset(dp, 0x3f, sizeof dp);\n        dp[1][a[1]] = 0;\n        for(int i = 1; i <= r; ++i) {\n            for(int j = 1; j <= n; ++j) {\n                /*荳?ョ壼庄莉・襍ー髯?キッ*/\n                dp[i][j] = min(dp[i][j], dp[i - 1][j] + dp[a[i - 1]][a[i]]);\n                for(int k = 1; k <= n; ++k) /*//譫壻クセ豌エ霍ッ闊ケ蛛懃噪菴咲スョ */\n                   /*//莉司-1髟?ュ仙屓蛻ー闊ケ蝨ィ逧?  蠑?飴蛻ーk髟?ュ占飴荳「蝨ィ驍」驥? 髯?キッ莉嗣蛻ーi髟?ュ?                    //荳我クェINF 蜿ッ閭ス蜉??縲ゅ?縲ゅ?縲?/\n                    dp[i][k] = min((long long)dp[i][k], (long long)dp[i - 1][j] +\n                                   land[a[i - 1]][j] + sea[j][k] + land[k][a[i]]);\n            }\n        }\n        cout << *min_element(dp[r], dp[r] + n + 1) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<math.h>\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\n#define inf (1<<28)\n#define ll long long\n#define db double\n#define c233 cout<<\"233\"<<endl\n#define mem(s) memset(s,0,sizeof(s))\n#define max(a,b) (a>b?a:b)\n#define min(a,b) (a<b?a:b)\nconst int N=205;\nconst int M=1050;\nusing namespace std;\n\nint l[N][N],s[N][N],dp[M][N],way[M];\nint n,m,r,ans;\n\nvoid fre(){\n  freopen(\"in\",\"r\",stdin);\n  freopen(\"out\",\"w\",stdout);\n}\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=(x<<1)+(x<<3)+ch-48,ch=getchar();\n  return x*res;\n}\n\nvoid init(){\n  for(int i=1;i<=n;i++)\n    for(int j=1;j<=n;j++)\n      l[i][j]=s[i][j]=inf;\n  for(int i=1;i<=n;i++)\n    l[i][i]=s[i][i]=0;\n  for(int i=1;i<=m;i++){\n    int a,b,c;\n    char d;\n    scanf(\"%d%d%d %c\",&a,&b,&c,&d);\n    if(d=='L')l[a][b]=l[b][a]=min(l[a][b],c);\n    if(d=='S')s[a][b]=s[b][a]=min(s[a][b],c);\n  }\n  r=gi();\n  for(int i=1;i<=r;i++)\n    way[i]=gi();\n}\n\nvoid pre(){\n  for(int k=1;k<=n;k++)\n    for(int i=1;i<=n;i++)\n      for(int j=1;j<=n;j++){\n\tl[i][j]=min(l[i][j],l[i][k]+l[k][j]);\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n      }\n  for(int i=1;i<=r;i++)\n    for(int j=1;j<=n;j++)\n      dp[i][j]=inf;\n  ans=inf;\n}\n\nvoid work(){\n  dp[1][way[1]]=0;\n  for(int i=2;i<=r;i++)\n    for(int j=1;j<=n;j++){\n      dp[i][j]=min(dp[i][j],dp[i-1][j]+l[way[i-1]][way[i]]);\n      for(int k=1;k<=n;k++)\n\tdp[i][j]=min(dp[i][j],dp[i-1][k]+l[way[i-1]][k]+s[k][j]+l[j][way[i]]);\n    }\n  for(int i=1;i<=n;i++)\n    ans=min(ans,dp[r][i]);\n  printf(\"%d\\n\",ans);\n}\n\nint main(){\n  //fre();\n  while(1){\n    n=gi();m=gi();\n    if(n==0&&m==0)break;\n    init();\n    pre();\n    work();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := 集配先\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      if(dp[i][j] == inf)continue;\n\n\t      //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t      dp[i+1][j] = min(dp[i+1][j],\n\t\t\t       dp[i][j]+LG[v[i]][v[i+1]]);\n\t      //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl; \n\t      rep(k,N)\n\t\t{\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t\t   dp[i][j] + SG[j][k] + LG[v[i]][j] + LG[k][v[i+1]]);\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t      \n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\nusing namespace std;\n\n#define INF 1e9\n\nint result[101][101][10001];\n\nint dijk(vector<vector<pair<int, pair<int, bool> > > >& adjlist, vector<int>& z){\n  int n = adjlist.size();\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      for(int k = 0; k < z.size(); k++){\n        result[i][j][k] = INF;\n      }\n    }\n  }\n\n  \n  //vector<vector<vector<int> > > result(n, vector<vector<int> >(n, vector<int>(z.size(), INF)));\n  priority_queue<pair<int, pair<int, pair<int, int> > > > wait;\n  result[z[0]][z[0]][0] = 0;\n  wait.push(make_pair(0, make_pair(z[0], make_pair(z[0], 0))));\n  \n  int ans = -1;\n  while(!wait.empty()){\n    int nowcost = -wait.top().first;\n    int nowpoint = wait.top().second.first;\n    int nowship = wait.top().second.second.first;\n    int nowachv = wait.top().second.second.second;\n    wait.pop();\n    \n    // ??????????????????????????¨??¨???????????£?????´???\n    if(nowachv >= ((int)z.size() - 1)){\n      ans = nowcost;\n      break;\n    }\n    \n    // ???????????????????????????????°?????????´???\n    if(nowcost > result[nowpoint][nowship][nowachv]){ continue; }\n    \n    for(int i = 0; i < (int)adjlist[nowpoint].size(); i++){\n      int nextcost = nowcost + adjlist[nowpoint][i].first;\n      int nextpoint = adjlist[nowpoint][i].second.first;\n      int nextship = nowship;\n      // ???????????£?????´????????????????????¨????????????\n      if(!adjlist[nowpoint][i].second.second){\n        if(nowpoint != nowship){ continue; }\n        nextship = nextpoint;\n      }      \n      int nextachv = nowachv + (nextpoint == z[nowachv + 1] ? 1 : 0);\n      \n      // ?????????????????\\\n      if(result[nextpoint][nextship][nextachv] > nextcost){\n        wait.push(make_pair(-nextcost, make_pair(nextpoint, make_pair(nextship, nextachv))));\n        result[nextpoint][nextship][nextachv] = nextcost;\n      }\n    }    \n  }\n\n  return ans;\n}\n\n\n\nint main(void){\n  vector<vector<pair<int, pair<int, bool> > > > adjlist(101);\n  \n  while(true){\n    int n, m;\n    cin >> n >> m;\n    if(n == 0 && m == 0){ break; }\n\n    for(int i = 0; i <= n; i++){\n      adjlist[i].resize(0);\n    }\n    \n    int x, y, t;\n    string sl;\n    for(int i = 0; i < m; i++){\n      cin >> x >> y >> t >> sl;\n      adjlist[x].push_back(make_pair(t, make_pair(y, sl == \"L\")));\n      adjlist[y].push_back(make_pair(t, make_pair(x, sl == \"L\")));\n    }\n\n    int r;\n    cin >> r;\n    vector<int> z(r);\n    for(int i = 0; i < r; i++){ cin >> z[i]; }\n\n    int ans = dijk(adjlist, z);\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n\tint N,M;\n\twhile(cin>>N>>M,N){\n\t\tvector<vector<int>>L(N,vector<int>(N));\n\t\tvector<vector<int>>S(N,vector<int>(N));\n\t\tfor(int i=0;i<N;++i){\n\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\tif(i==j){\n\t\t\t\t\tL[i][j]=0;\n\t\t\t\t\tS[i][j]=0;\n\t\t\t\t}else{\n\t\t\t\t\tL[i][j]=1e8;\n\t\t\t\t\tS[i][j]=1e8;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<M;++i){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tif(sl=='L'){\n\t\t\t\tL[x][y]=t;\n\t\t\t\tL[y][x]=t;\n\t\t\t}else{\n\t\t\t\tS[x][y]=t;\n\t\t\t\tS[y][x]=t;\n\t\t\t}\n\t\t}\n\t\tint R;\n\t\tcin>>R;\n\t\tvector<int>z(R);\n\t\tfor(int i=0;i<R;++i){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tz[i]=--a;\n\t\t}\n\t\tfor(int k=0;k<N;++k){\n\t\t\tfor(int i=0;i<N;++i){\n\t\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<vector<long long>>dp(N,vector<long long>(R,1e10));\n\t\tdp[0][z[0]]=0;\n\t\tlong long ans=1e18;\n\t\tfor(int i=1;i<R;++i){\n\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\tdp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n\t\t\t\tfor(int k=0;k<N;++k){\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][k]+L[z[i-1]][k]+S[k][j]+L[j][z[i]]);\n\t\t\t\t}\n\t\t\t\tif(i==R-1){\n\t\t\t\t\tans=min(ans,dp[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_R 1001\n#define MAX_N 201\n#define inf (1<<29)\nusing namespace std;\nstruct P\n{\n  int to,cost;\n  char c;\n  P(int to=0,int cost=0,char c='x'):to(to),cost(cost),c(c){}\n};\ntypedef vector<P> VP;\ntypedef vector<VP> VVP;\nint N,M,R;\nint LG[MAX_N][MAX_N];\nint SG[MAX_N][MAX_N];\nint dp[MAX_R][MAX_N];//dp[i][j] := 集配先\n\nint main()\n{\n  while(cin >> N >> M,N|M)\n    {\n      rep(i,MAX_N)rep(j,MAX_N)LG[i][j] = SG[j][i] = (i==j?0:inf);\n      rep(i,MAX_R)rep(j,MAX_N)dp[i][j] = inf;\n      VVP G(N);\n      rep(i,M)\n\t{\n\t  int x,y,t;\n\t  char c;\n\t  cin >> x >> y >> t >> c;\n\t  x--,y--;\n\t  G[x].push_back(P(y,t,c));\n\t  G[y].push_back(P(x,t,c));\n\t  if(c == 'L')LG[y][x] = LG[x][y] = min(LG[y][x],t);\n\t  if(c == 'S')SG[y][x] = SG[x][y] = min(SG[x][y],t);\n\t}\n\n      cin >> R;\n      vector<int> v(R);\n      rep(i,R)\n\t{\n\t  cin >> v[i];\n\t  v[i]--;\n\t}\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)LG[i][j] = min(LG[i][j],LG[i][k]+LG[k][j]),SG[i][j] = min(SG[i][j],SG[i][k]+SG[k][j]);\n      dp[0][v[0]] = 0;\n\n      /*\n      cout << \"-----------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)cout << SG[i][j] << \" \";\n\t  cout << endl;\n\t}\n      */\n      rep(i,R-1)\n\t{\n\t  rep(j,N)\n\t    {\n\t      if(dp[i][j] == inf)continue;\n\t      //cout << \"dp[\"<<i<<\"][\"<<j<<\"] ------- \"<< dp[i][j] << endl;\n\t      dp[i+1][j] = min(dp[i+1][j],\n\t\t\t       dp[i][j]+LG[v[i]][v[i+1]]);\n\t      //cout << \"dp[\"<<i+1<<\"][\"<<j<<\"] = \" << dp[i+1][j]  << \" | \" << dp[i][j] << \"+\" << LG[v[i]][v[i+1]]<< endl; \n\t      rep(k,N)\n\t\t{\n\t\t  if(SG[v[i]][k] != inf)\n\t\t    {\n\t\t      dp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t       dp[i][v[i]] + SG[v[i]][k] + LG[k][v[i+1]]);\n\t\t      //cout << v[i] << \" dp[\"<<i+1<<\"][\"<<k<<\"] = \" << dp[i+1][k] << \" | \" << dp[i][j] << \"+\" << SG[v[i]][k] << \"+\" << LG[k][v[i+1]] << endl;\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n      int minCost = (1<<29);\n      rep(i,N)minCost = min(minCost,dp[R-1][i]);\n      cout << minCost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF (1<<24)\n\nint n,m,a,b,c,R;\nint r[1001];\nchar ch;\nint t[201][201];\nint u[201][201];\nint dp[201][1001];\n \nvoid init();\nint solve();\n  \nint main(){\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>ch;\n      a--;b--;\n      if(ch=='L'){\n\tt[a][b]=min(t[a][b],c);\n\tt[b][a]=min(t[b][a],c);\n      }else {\n\tu[a][b]=min(u[a][b],c);\n\tu[b][a]=min(u[b][a],c);\n      }\n    }\n    cin>>R;\n    for(int i=0;i<R;i++){\n      cin>>r[i];\n      r[i]--;\n    }\n \n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  u[i][j]=min(u[i][j],u[i][k]+u[k][j]);\n\t  t[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n\t}\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n  \nint solve(){\n  dp[r[0]][0]=0;\n  for(int i=0;i<R-1;i++){\n    for(int j=0;j<n;j++){\n      for(int k=0;k<n;k++){\n\tdp[k][i+1]=min(dp[k][i+1],dp[j][i]+t[r[i]][j]+u[j][k]+t[k][r[i+1]]);\n      }\n    }\n  }\n  int res=INF;\n  for(int i=0;i<n;i++)res=min(res,dp[i][R-1]);\n  return res;\n}\n  \nvoid init(){\n  for(int i=0;i<201;i++){\n    for(int j=0;j<201;j++){\n      if(i==j)u[i][j]=0;\n      else u[i][j]=INF;\n      t[i][j]=u[i][j];\n    }\n    for(int j=0;j<1001;j++)dp[i][j]=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nconst int inf=1<<28;\n\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n\nint n,m;\n\nint lcost[210][210];\nint scost[210][210];\nint dp[1010][210];\n\nint r;\nint z[1010];\n\nint main(void){\n\t\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,210)rep(j,210) lcost[i][j]=scost[i][j]=(i==j)?0:inf;\n\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--;y--;\n\t\t\tif(sl=='S')\n\t\t\t\tscost[x][y]=scost[y][x]=t;\n\t\t\telse\n\t\t\t\tlcost[x][y]=lcost[y][x]=t;\n\t\t}\n\n\t\tcin >> r;\n\t\trep(i,r){cin >> z[i];z[i]--;}\n\n\t\trep(k,n)rep(i,n)rep(j,n) scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n) lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n\n\t\trep(i,1010)rep(j,210) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n)rep(k,n) dp[i+1][k]=min(dp[i+1][k],dp[i][j]+lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]]);\n\t\tint ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl; \n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <string>\n#include <set>\n#include <map>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <string.h>\nusing namespace std;\nconst int INF = 1 << 26;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define rep(i,start,end) for(int i=(start);i<(end);++i)\n#define pint(i) printf(\"%d\\n\",(i))\n#define pint2(i,j) printf(\"%d %d\",(i),(j))\n#define pint3(i,j,k) printf(\"%d %d %d\",(i),(j),(k))\n#define gint(i) scanf(\"%d\",&(i))\n#define gint2(i,j) scanf(\"%d %d\",&(i),&(j))\n#define gint3(i,j,k) scanf(\"%d %d %d\",&(i),&(j),&(k))\n#define init(tar,val) memset((tar),(val),sizeof((tar)))\n#define show(tar,len) for(int i=0;i<(len);++i) \\\n\tcout<<tar[i]<<' ';\\\n\tcout<<endl;\n\n\n\n\nclass bignum{\npublic:\n\tbignum(int size = 4) :len(size){\n\t}\n\t~bignum(){\n\t}\n\tint size()const{\n\t\treturn len;\n\t}\n\t//int get(int id)const{\n\t//\treturn num[id];\n\t//}\n\tfriend ostream &operator<<(ostream &output, const bignum &b){\n\t\tbool stu = false;\n\t\tfor (int i = int(b.len - 1); i >= 0; --i){\n\t\t\tif (stu)\n\t\t\t\tprintf(\"%09d\", b.num[i]);\n\t\t\telse if (b.num[i] > 0){\n\t\t\t\tprintf(\"%d\", b.num[i]);\n\t\t\t\tstu = true;\n\t\t\t}\n\t\t}\n\t\tif (stu == false)\n\t\t\tprintf(\"0\");\n\t\treturn output;\n\t}\n\tconst bignum& operator+=(const bignum&right){\n\t\tint add = 0;\n\t\tfor (int i = 0; i < len; ++i){\n\t\t\tint tmp = 0;\n\t\t\tif (i < right.size()){\n\t\t\t\ttmp = right.num[i] + num[i] + add;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = num[i] + add;\n\t\t\t}\n\t\t\tnum[i] = tmp%gap;\n\t\t\tadd = tmp / gap;\n\t\t}\n\t\treturn *this;\n\t}\n\tconst bignum& operator=(const bignum&right){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = right.num[i];\n\t\t}\n\t\treturn *this;\n\t}\n\tvoid set(int a){\n\t\tfor (int i = 0; i <len; ++i){\n\t\t\tnum[i] = a%gap;\n\t\t\ta /= gap;\n\t\t}\n\t}\nprivate:\n\tint  num[4];\n\tint len;\n\tstatic const int gap = 1000000000;\n};\n\n\n//inline int id(int i){\n//\treturn i & 1;\n//}\n//\n//inline int last(int i){\n//\treturn (i - 1) & 1;\n//}\n//\n//void myshow(int i){\n//\trep(j, 0, ){\n//\t\tcout << dp[id(i)][j] << ' ';\n//\t}\n//\tcout << endl;\n//}\n\n\n#define my_debu\nconst int MAX_N = 205;\nconst int MAX_M = 10005;\nint n, m;\n\nint sea[MAX_N][MAX_N];\nint land[MAX_N][MAX_N];\nconst int MAX_R = 1005;\nint r;\nint dir[MAX_R];\n\nint dp[MAX_N][MAX_N];\n\nvoid myinit(){\n\trep(i, 0, MAX_N){\n\t\trep(j, 0, MAX_N){\n\t\t\tsea[i][j] = land[i][j] = i == j ? 0 : INF;\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n}\n\nvoid floy_land(){\n\trep(k, 1, n + 1){\n\t\trep(i, 1, n + 1){\n\t\t\trep(j, 1, n + 1){\n\t\t\t\tland[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid floy_sea(){\n\trep(k, 1, n + 1){\n\t\trep(i, 1, n + 1){\n\t\t\trep(j, 1, n + 1){\n\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid myshow(){\n\trep(i, 1, n + 1){\n\t\trep(j, 1, n + 1){\n\t\t\tcout << dp[i][j] <<' ';\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvoid solve(){\n\tfloy_land();\n\tfloy_sea();\n\tint out =INF;\n\tdp[dir[0]][dir[0]] = 0;\n\trep(i, 1, r){\n\t\t//int tmp = INF;\n\t\tout = INF;\n\t\trep(j, 1, n + 1){\n\t\t\tdp[dir[i]][j] = INF;\n\t\t\trep(k, 1, n + 1){\n\t\t\t\tif (j == k){\n\t\t\t\t\tdp[dir[i]][j] = min(dp[dir[i]][j], dp[dir[i - 1]][k] + land[dir[i]][dir[i - 1]]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[dir[i]][j] = min(dp[dir[i]][j], dp[dir[i - 1]][k] + land[dir[i - 1]][k] + sea[k][j] + land[j][dir[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout = min(out, dp[dir[i]][j]);\n\t\t\t//cout << i << \":\" << j << endl;\n\t\t\t//myshow();\n\t\t}\n\t\t//out += tmp;\n\t\t//cout << \"out:\" << out << endl;\n\t}\n\tpint(out);\n}\n\nint main(){\n#ifdef my_debug\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\twhile (gint2(n,m) != EOF){\n\t\tif (n + m == 0)\n\t\t\tbreak;\n\t\tmyinit();\n\t\tint a, b,c;\n\t\tchar d;\n\t\trep(i, 0, m){\n\t\t\tgint3(a, b, c);\n\t\t\tscanf(\"%c\", &d);\n\t\t\tscanf(\"%c\", &d);\n\t\t\tif (d == 'L'){\n\t\t\t\tland[a][b] = land[b][a] = c;\n\t\t\t}\n\t\t\tif (d == 'S'){\n\t\t\t\tsea[a][b] = sea[b][a] = c;\n\t\t\t}\n\t\t}\n\t\tgint(r);\n\t\trep(i, 0, r)\n\t\t\tgint(dir[i]);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define INF 10000000000000\n\ntypedef long long LL;\n\nint main(){\n  int n,m;\n  while(1){\n    cin >> n >> m;\n    if(n==0) return 0;\n    vector<vector<LL>> riku(n,vector<LL>(n,INF));\n    vector<vector<LL>> kai(n,vector<LL>(n,INF));\n    for(int i=0;i<n;i++){\n      riku[i][i]=kai[i][i]=0;\n    }\n    LL x,y,t;\n    char c;\n    for(int i=0;i<m;i++){\n      cin >> x >> y >> t >> c;\n      x--;\n      y--;\n      if(c=='L'){\n        riku[x][y]=min(riku[x][y],t);\n        riku[y][x]=min(riku[y][x],t);\n      }else{\n        kai[x][y]=min(kai[x][y],t);\n        kai[y][x]=min(kai[y][x],t);\n      }\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(riku[i][j]>riku[i][k]+riku[k][j]) riku[i][j]=riku[i][k]+riku[k][j];\n          if(kai[i][j]>kai[i][k]+kai[k][j]) kai[i][j]=kai[i][k]+kai[k][j];\n        }\n      }\n    }\n    int r;\n    cin >> r;\n    vector<LL> z(r+1);\n    z[0]=0;\n    for(int i=1;i<=r;i++){\n      cin >> z[i];\n      z[i]--;\n    }\n    vector<vector<LL>> dp(r+1,vector<LL>(n,INF));\n    dp[0][0]=0;\n    for(int i=1;i<=r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j]=dp[i-1][j]+riku[z[i-1]][z[i]];\n        for(int k=0;k<n;k++){\n          dp[i][j]=min(dp[i][j],dp[i-1][k]+riku[z[i-1]][k]+kai[k][j]+riku[j][z[i]]);\n        }\n        if(dp[i][j]>INF) dp[i][j]=INF;\n      }\n    }\n    LL ans=INF;\n    for(int i=0;i<n;i++) ans=min(ans,dp[r][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    ll land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<201;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y;ll t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>a[i];a[i]--;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    ll dp[1001][201];\n    for(int i=0;i<r;i++)for(int j=0;j<n;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n          if(j==k){\n            dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][a[i+1]]);\n          }\n        }\n      }\n    }\n    /*for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        cout<<dp[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;*/\n    ll ans=inf;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint test[200][200][10000];\n\nint main(){\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define REP2(i,m,n) for (int i=m;i<(n);i++)\n\nconst ll INF = 1LL << 60;\n\nint solve() {\n    int N, M; cin >> N >> M;\n    if (N == 0) return 0;\n    \n    vector<vector<ll>> dist_l(N, vector<ll>(N, INF));\n    vector<vector<ll>> dist_s(N, vector<ll>(N, INF));\n    REP(i, N) dist_l[i][i] = 0;\n    REP(i, N) dist_s[i][i] = 0;\n    REP(_, M) {\n        int x, y; ll t; char sl; cin >> x >> y >> t >> sl;\n        if (sl == 'S') {\n            dist_s[x - 1][y - 1] = min(dist_s[x - 1][y - 1], t);\n            dist_s[y - 1][x - 1] = min(dist_s[y - 1][x - 1], t);\n        } else {\n            dist_l[x - 1][y - 1] = min(dist_l[x - 1][y - 1], t);\n            dist_l[y - 1][x - 1] = min(dist_l[y - 1][x - 1], t);\n        }\n    }\n\n\n    REP(i, N) REP(j, N) REP(k, N)\n        dist_s[j][k] = min(dist_s[j][k], dist_s[j][i] + dist_s[i][k]);\n    REP(i, N) REP(j, N) REP(k, N)\n        dist_l[j][k] = min(dist_l[j][k], dist_l[j][i] + dist_l[i][k]);\n\n\n    int R; cin >> R;\n    vector<int> dests;\n    REP(_, R) {\n        int r; cin >> r;\n        dests.push_back(r - 1);\n    }\n\n\n    vector<vector<ll>> dp(R, vector<ll>(N, INF));\n    dp[0][dests[0]] = 0;\n\n    REP2(i, 1, R) REP(j, N) REP(k, N) {\n        dp[i][j] = min(dp[i][j], dp[i-1][k] + dist_l[dests[i-1]][k] + dist_s[k][j] + dist_l[j][dests[i]]);\n    }\n\n    ll ans = INF;\n    REP(i, N) ans = min(ans, dp[R-1][i]);\n    cout << ans << endl;\n\n    return 1;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n \nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n \nconst double eps = 1e-10;\n \ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n \n//vector<vector<int64>> ds, dl; // ds: 海のみでi~j，dl: 陸のみでi~j\n//vector<vector<PLL>> GL, GS;\nint32 N, M, R;\nvector<int32> r;\nint64 dl[210][210], ds[210][210];\n \nvoid dijkstra(int64 s, vector<int64>& d, const vector<vector<PLL>>& G){\n    d[s] = 0;\n    priority_queue<PLL, vector<PLL>, greater<PLL>> pq;\n    pq.push({0, s});\n    while(pq.size()){  \n        int64 dd, v;\n        tie(dd, v) = pq.top(); pq.pop();\n        if(d[v] < dd) continue;\n        REP(i, G[v].size()){\n            if(dd+G[v][i].fs < d[G[v][i].sc]){\n                d[G[v][i].sc] = dd+G[v][i].fs;\n                pq.push({d[G[v][i].sc], G[v][i].sc});\n            }\n        }\n    }\n}\n \nint main(void){\n    while(cin >> N >> M && N+M){\n        /*\n        ds.clear(); dl.clear();\n        GL.clear(); GS.clear();\n        ds.resize(N, vector<int64>(N, INF_LL));\n        dl.resize(N, vector<int64>(N, INF_LL));\n        GL.resize(N); GS.resize(N);\n        */\n        REP(i, 210){\n            REP(j, 210){\n                ds[i][j] = dl[i][j] = INF_LL;\n            }\n            ds[i][i] = dl[i][i] = 0;\n        }\n        REP(i, M){  \n            int64 u, v, d; char c;\n            cin >> u >> v >> d >> c; u--; v--;\n            if(c == 'L'){\n                chmin(dl[u][v], d); chmin(dl[v][u], d);\n            }else{\n                chmin(ds[u][v], d); chmin(ds[v][u], d);\n            }\n        }\n        cin >> R;\n        r.resize(R);\n        REP(i, R){ cin >> r[i]; r[i]--;}\n        /*\n        REP(i, N){\n            dijkstra(i, ds[i], GS);\n            dijkstra(i, dl[i], GL);\n        }\n        */\n        REP(k, N){\n            REP(i, N){\n                REP(j, N){\n                    chmin(dl[i][j], dl[i][k]+dl[k][j]);\n                    chmin(ds[i][j], ds[i][k]+ds[k][j]);\n                }\n            }\n        }\n \n        vector<vector<int64>> dp(R+1, vector<int64>(N, INF_LL));\n        dp[0][r[0]] = 0;\n        REP(i, R-1){\n            REP(j, N){\n                REP(k, N){\n                    chmin(dp[i+1][k], dp[i][j]+dl[r[i]][j]+ds[j][k]+dl[k][r[i+1]]);\nchmin(dp[i+1][j], dp[i][j]+dl[r[i]][r[i+1]]);\n                }\n            }\n        }\n        cout << *min_element(all(dp[R-1])) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define maxn 205\n#define maxr 1005\n#define inf 0x3f3f3f3f\nusing namespace std;\ntypedef long long ll;\nint fl[maxn][maxn],fs[maxn][maxn],dp[maxr][maxn],n,m,r,a[maxr];\nint main(){\n\twhile(~scanf(\"%d%d\",&n,&m) && (n+m)>0){\n\t\tmemset(fl,0x3f,sizeof(fl));\n\t\tmemset(fs,0x3f,sizeof(fs));\n\t\tfor(int i=1;i<=n;i++) fs[i][i] = fl[i][i] = 0;\n\t\tfor(int i=1;i<=m;i++){\n\t\t\tint u,v,w;\n\t\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\t\tchar c;\n\t\t\twhile(scanf(\"%c\",&c) && (c!='S'&&c!='L'));\n\t\t\tif(c == 'S') fs[u][v] = fs[v][u] = min(fs[u][v],w);\n\t\t\telse fl[u][v] = fl[v][u] = min(fl[u][v],w);\n\t\t}\n\t\tscanf(\"%d\",&r);\n\t\tfor(int i=1;i<=r;i++) scanf(\"%d\",&a[i]);\n\t\tfor(int k=1;k<=n;k++){\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\t\tfl[i][j] = min(fl[i][j],fl[i][k] + fl[k][j]);\n\t\t\t\t\tfs[i][j] = min(fs[i][j],fs[i][k] + fs[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemset(dp,0x3f,sizeof(dp));\n//\t\ta[0] = 1;\n\t\tfor(int i=1;i<=n;i++) dp[1][i] = fs[a[1]][i] + fl[i][a[1]];\n\t\tfor(int i=2;i<=r;i++){\n\t\t\tfor(int j=1;j<=n;j++){\n\t\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\t\tll res;\n\t\t\t\t\tif(j==k) res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][a[i]];\n\t\t\t\t\telse res = (ll)dp[i-1][k] + (ll)fl[a[i-1]][k] + (ll)fs[k][j] + (ll)fl[j][a[i]];\n\t\t\t\t\tdp[i][j] = min((ll)dp[i][j],res);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = inf;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tans = min(ans,dp[r][i]);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF 0x334334334334\n\ntypedef long long int LLI;\n\nint n;\nint m;\nint R;\nint z[1419];\nLLI dp[1145][1419];\nLLI mindL[1145][1419];\nLLI mindS[1145][1419];\n\nint main() {\n  while (1) {\n    scanf(\"%d%d\", &n, &m);\n    if (n == 0 && m == 0) return 0;\n\n    fill(mindL[0], mindL[n+1], INF);\n    fill(mindS[0], mindS[n+1], INF);\n    for (int i=1; i<=n; i++) {\n      mindL[i][i] = 0;\n      mindS[i][i] = 0;\n    }\n\n    for (int i=0; i<m; i++) {\n      char sl;\n      int x, y;\n      LLI t;\n      scanf(\"%d%d%lld %c\", &x, &y, &t, &sl);\n      if (sl == 'L') {\n        mindL[x][y] = min(mindL[x][y], t);\n        mindL[y][x] = min(mindL[y][x], t);\n      } else if (sl == 'S') {\n        mindS[x][y] = min(mindS[x][y], t);\n        mindS[y][x] = min(mindS[y][x], t);\n      } else assert(0);\n    }\n\n    for (int k=1; k<=n; k++) {\n      for (int i=1; i<=n; i++) {\n        for (int j=1; j<=n; j++) {\n          mindL[i][j] = min(mindL[i][j], mindL[i][k] + mindL[k][j]);\n          mindL[j][i] = min(mindL[j][i], mindL[j][k] + mindL[k][i]);\n          mindS[i][j] = min(mindS[i][j], mindS[i][k] + mindS[k][j]);\n          mindS[j][i] = min(mindS[j][i], mindS[j][k] + mindS[k][i]);\n        }\n      }\n    }\n\n    scanf(\"%d\", &R);\n    fill(dp[0], dp[R+1], INF);\n\n    scanf(\"%d\", &z[0]);\n    dp[0][z[0]] = 0;\n    for (int i=1; i<R; i++) {\n      scanf(\"%d\", &z[i]);\n      for (int j=1; j<=n; j++) {\n        for (int k=1; k<=n; k++) {\n          LLI t = dp[i-1][j] + mindL[z[i-1]][j] + mindS[j][k] + mindL[k][z[i]];\n          dp[i][k] = min(dp[i][k], t);\n          if (j == k) {\n            t = dp[i-1][j] + mindL[z[i-1]][z[i]];\n            dp[i][k] = min(dp[i][k], t);\n          }\n        }\n      }\n    }\n\n    LLI ans = INF;\n    for (int i=1; i<=n; i++) ans = min(ans, dp[R-1][i]);\n    printf(\"%lld\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<24;\nconst int MAX_N = 201;\nconst int MAX_R = 1001;\n\nstruct Edge {\n  int to, cost;\n};\n\nint N, M;\nint G[2][MAX_N][MAX_N];\nint R;\nint Z[MAX_R];\nvector<Edge> E[2][MAX_N];\n\nstruct State {\n  int p, sp, t, c;\n  bool operator < (const State &s) const {\n    if(c != s.c) return c > s.c;\n    if(t != s.t) return t > s.t;\n    if(p != s.p) return p > s.p;\n    if(sp != s.sp) return sp > s.sp;\n  }\n};\nint cost[MAX_N][MAX_N][MAX_R];\n\nint solve() {\n  State s;\n  s.p = s.sp = Z[0];\n  s.c = s.t = 0;\n\n  priority_queue<State> que;\n  que.push(s);\n\n  for(int i = 0; i < N; ++i)\n    for(int j = 0; j < N; ++j)\n      fill(cost[i][j], cost[i][j]+R, INF);\n\n  while(!que.empty()) {\n    s = que.top(); que.pop();\n    if(cost[s.p][s.sp][s.t] != INF) continue;\n\n    cost[s.p][s.sp][s.t] = s.c;\n    if(Z[s.t] == s.p) {\n      ++s.t;\n      cost[s.p][s.sp][s.t] = s.c;\n      if(s.t == R) {\n\treturn s.c;\n      }\n    }\n\n    State t;\n    for(int i = 0; i < E[0][s.p].size(); ++i) {\n      t.p = E[0][s.p][i].to;\n      t.sp = s.sp;\n      t.c = s.c + E[0][s.p][i].cost;\n      t.t = s.t;\n      if(cost[t.p][t.sp][t.t] == INF) {\n\tque.push(t);\n      }\n    }\n    if(s.sp == s.p) {\n      for(int i = 0; i < E[1][s.p].size(); ++i) {\n\tt.p = t.sp = E[1][s.p][i].to;\n\tt.c = s.c + E[1][s.p][i].cost;\n\tt.t = s.t;\n\tif(cost[t.p][t.sp][t.t] == INF) {\n\t  que.push(t);\n\t}\n      }\n    }\n  }\n  return INF;\n}\n\nint main() {\n  while(cin >> N >> M && (N || M)) {\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < 2; ++j) {\n\tfill(G[j][i], G[j][i]+N, INF);\n      }\n    }\n    for(int i = 0; i < M; ++i) {\n      int a, b, t, ind;\n      char c;\n      cin >> a >> b >> t >> c;\n      --a; --b;\n      ind = (c == 'L') ? 0 : 1;\n      G[ind][a][b] = min(G[ind][a][b], t);\n      G[ind][b][a] = min(G[ind][b][a], t);\n    }\n\n    for(int i = 0; i < 2; ++i) {\n      for(int j = 0; j < N; ++j) {\n\tE[i][j].clear();\n      }\n    }\n\n    for(int k = 0; k < 2; ++k) {\n      for(int i = 0; i < N; ++i) {\n\tfor(int j = 0; j < N; ++j) {\n\t  if(G[k][i][j] != INF)\n\t    E[k][i].push_back((Edge){j, G[k][i][j]});\n\t}\n      }\n    }\n\n    cin >> R;\n    for(int i = 0; i < R; ++i) {\n      cin >> Z[i];\n      --Z[i];\n    }\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\ntypedef vector<int> vint;\ntypedef pair<int,int> pii;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define mp\tmake_pair\n#define mt \tmake_tuple\n#define pb \tpush_back\nconst int inf=1e9;\n\nint dp[210][210];\nvector<pii> edgel[210],edges[210];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n>0){\n\t\trep(i,n){\n\t\t\tedgel[i].clear();\n\t\t\tedges[i].clear();\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,t;\tchar sl;\tcin>>x>>y>>t>>sl;\n\t\t\tx--;\ty--;\n\t\t\tif(sl=='L'){\n\t\t\t\tedgel[x].pb(mp(y,t));\n\t\t\t\tedgel[y].pb(mp(x,t));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tedges[x].pb(mp(y,t));\n\t\t\t\tedges[y].pb(mp(x,t));\n\t\t\t}\n\t\t}\n\t\tint r;\tcin>>r;\n\t\tvint z(r);\n\t\trep(i,r){\n\t\t\tcin>>z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,n)\trep(j,n)\tdp[i][j]=inf;\n\t\tdp[z[0]][z[0]]=0;\n\t\tsrep(i,1,r){\n\t\t\tpriority_queue<tuple<int,int,int>> pq;\n\t\t\trep(j,n){\n\t\t\t\tif(z[i-1]==j){\n\t\t\t\t\trep(k,n){\n\t\t\t\t\t\tif(dp[j][k]!=inf)\tpq.push(mt(-dp[j][k],j,k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\trep(k,n)\tdp[j][k]=inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!pq.empty()){\n\t\t\t\tauto it=pq.top();\tpq.pop();\n\t\t\t\tint d,pos,f;\ttie(d,pos,f)=it;\n\t\t\t\td*=-1;\n\t\t\t\tif(d>dp[pos][f])\tcontinue;\n\t\t\t\trep(j,edgel[pos].size()){\n\t\t\t\t\tint to=edgel[pos][j].first,add=edgel[pos][j].second;\n\t\t\t\t\tif(dp[to][f]>dp[pos][f]+add){\n\t\t\t\t\t\tdp[to][f]=dp[pos][f]+add;\n\t\t\t\t\t\tpq.push(mt(-dp[to][f],to,f));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(pos==f){\n\t\t\t\t\trep(j,edges[pos].size()){\n\t\t\t\t\t\tint to=edges[pos][j].first,add=edges[pos][j].second;\n\t\t\t\t\t\tif(dp[to][to]>dp[pos][f]+add){\n\t\t\t\t\t\t\tdp[to][to]=dp[pos][f]+add;\n\t\t\t\t\t\t\tpq.push(mt(-dp[to][to],to,to));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret=inf;\n\t\trep(i,n)\tret=min(ret,dp[z[r-1]][i]);\n\t\tcout<<ret<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nconst int INF = 1e8;\nusing namespace std;\n\n\nconst int MAX_V = 205;\nconst int MAX_R = 1005;\nint gl[MAX_V][MAX_V], gs[MAX_V][MAX_V];\n\nvoid init(int m[MAX_V][MAX_V]){\n\trep(i,MAX_V) rep(j,MAX_V) m[i][j] = INF;\n\trep(i,MAX_V) m[i][i] = 0;\n}\n\nvoid warshallFloyd(int m[MAX_V][MAX_V], int n){\n\trep(k,n){\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tm[i][j] = min(m[i][j], m[i][k] + m[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint N, M;\n\twhile(cin >> N >> M, N||M){\n\t\tinit(gl);\n\t\tinit(gs);\n\t\trep(i,M){\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tgl[x][y] = gl[y][x] = min(t, gl[x][y]);\n\t\t\t}else{\n\t\t\t\tgs[x][y] = gs[y][x] = min(t, gs[x][y]);\n\t\t\t}\n\t\t}\n\t\twarshallFloyd(gl,N);\n\t\twarshallFloyd(gs,N);\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> z(R);\n\t\trep(i,R){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tint dp[MAX_R][MAX_V];\n\t\trep(i,MAX_R) rep(j,MAX_V) dp[i][j] = INF;\n\t\tdp[0][z[0]] = 0;\n\n\t\trep(i,R - 1){\n\t\t\tint cur = z[i];\n\t\t\tint next = z[i + 1];\n\t\t\t//rep(j,N) dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + gl[cur][next]);\n\t\t\trep(j,N){\n\t\t\t\trep(k,N){\n\t\t\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t\t//cout << i << ' ' << j << ' ' << k << endl;\n\t\t\t\t\t\t\t//show(dp[i][j] + gl[cur][j] + gs[j][k] + gl[k][next]);\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\t//rep(i,R){\n\t\t//\trep(j,N){\n\t\t//\t\tif(dp[i][j] >= INF) cout << \"_\";\n\t\t//\t\telse cout << dp[i][j] << ' ';\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\n\t\tint mini = INT_MAX;\n\t\trep(i,N){\n\t\t\tmini = min(mini, dp[R - 1][i]);\n\t\t}\n\t\tcout << mini << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        //floyd(L);\n        //floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                //if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                //    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                //}\n                assert(z[i]<5*N);\n                if (dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 220\n#define MAX_R 1020\n#define INF 876543210\n\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> Q;\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> Q2;\nvector<tuple<long long, long long, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nint A1, A2, A3;\nint travel[MAX_R];\nint DIST[MAX_N][MAX_N], DIST2[MAX_N];\nint COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nint PATH[MAX_N][MAX_N][MAX_N];\nint DP[MAX_R][MAX_N];\nint cnt;\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<int, int, int>tup = Q.top();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint a4 = get<0>(X[a2][i]);\n\t\t\tint a5 = get<1>(X[a2][i]);\n\t\t\tint a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tint a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tint a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n\tcnt = 0;\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (M >= 10000) { return 0; }\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = DIST[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tlong long start = travel[i];\n\t\t\t\tlong long goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<ll> vl;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M , N) {\n\t\tvvi ldist(N, vi(N, INF));\n\t\tvvi sdist(N, vi(N, INF));\n\t\tint x, y, t;\n\t\tchar sl;\n\t\tREP(i, M) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif(sl == 'L') {\n\t\t\t\tldist[x-1][y-1] = min(ldist[x-1][y-1], t);\n\t\t\t\tldist[y-1][x-1] = min(ldist[y-1][x-1], t);\n\t\t\t}\n\t\t\tif(sl == 'S') {\n\t\t\t\tsdist[x-1][y-1] = min(sdist[x-1][y-1], t);\n\t\t\t\tsdist[y-1][x-1] = min(sdist[y-1][x-1], t);\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tldist[j][k] = min(ldist[j][k], ldist[j][i] + ldist[i][k]);\n\t\t\t\t\tsdist[j][k] = min(sdist[j][k], sdist[j][i] + sdist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tldist[i][i] = sdist[i][i] = 0;\n\t\t}\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvi z(R);\n\t\tREP(i, R) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tvector<vl> cost(R, vl(N, INF));\n\t\tREP(i, R) {\n\t\t\tif(i == 0) {\n\t\t\t\tcost[0][z[0]] = 0;\n\t\t\t} else {\n\t\t\t\tint fr = z[i-1];\n\t\t\t\tint to = z[i];\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tcost[i][k] = min(cost[i][k], cost[i-1][j]+ldist[fr][j]+sdist[j][k]+ldist[k][to]);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][j]+ldist[fr][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, cost[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n    }\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(pos==route[i+1] && e.type=='S') continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    int res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define inc(i, l, r) for (int i = l; i <= r; i++)\n\nconst int inf = 2e8;\n\nint n, m, r;\nint d1[205][205], d2[205][205];\nint path[1005], dp[1005][205];\n\nvoid init(int p[][205]) {\n    inc(i, 1, n) inc(j, 1, n) p[i][j] = inf;\n    inc(i, 1, n) p[i][i] = 0;\n}\n\nvoid floyd(int p[][205]) {\n    inc(k, 1, n) inc(i, 1, n) inc(j, 1, n) p[i][j] =\n        min(p[i][j], p[i][k] + p[k][j]);\n}\n\nint x, y, z;\nchar c;\n\nint main() {\n    while (scanf(\"%d %d\", &n, &m) != EOF && n) {\n        init(d1), init(d2);\n        inc(i, 1, m) {\n            scanf(\"%d %d %d %c\", &x, &y, &z, &c);\n            if (c == 'L')\n                d1[x][y] = d1[y][x] = min(d1[x][y], z);\n            else\n                d2[x][y] = d2[y][x] = min(d2[x][y], z);\n        }\n        floyd(d1), floyd(d2);\n\n        scanf(\"%d\", &r);\n        inc(i, 1, r) scanf(\"%d\", &path[i]);\n\n        inc(i, 1, n) dp[1][i] = inf;\n        dp[1][path[1]] = 0;\n\n        inc(i, 2, r) {\n            inc(j, 1, n) {\n                dp[i][j] = inf;\n                inc(k, 1, n) {\n                    dp[i][j] = min(dp[i][j], dp[i - 1][k] + d1[path[i - 1]][k] +\n                                                 d2[k][j] + d1[j][path[i]]);\n                    if (k == j)\n                        dp[i][j] = min(dp[i][j],\n                                       dp[i - 1][k] + d1[path[i - 1]][path[i]]);\n                }\n            }\n        }\n\n        int res = inf;\n        inc(i, 1, n) res = min(res, dp[r][i]);\n        printf(\"%d\\n\", res);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[200],INF);\n   fill(dS[0],dS[200],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=v;  dL[t][s]=v;\n     }else{\n     dS[s][t]=v;  dS[t][s]=v;\n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n        }\n       }\n      } \n\n   fill(dp[0],dp[200],INF);\n   \n    dp[1][z[1]]=0;\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nint v1[203][203],v2[203][203],a1,a2,a3,n,m;\nint dp[2][203][203],t,x,pre;\nchar c;\nint main(){\n  while(cin>>n>>m,n){\n    int ans=1e8;\n    r(i,2)r(j,203)r(k,203)dp[i][j][k]=1e8;\n    r(i,203)r(j,203)v1[i][j]=v2[j][i]=(i==j?0:1e8);\n    r(i,n){\n      cin>>a1>>a2>>a3>>c;\n      a1--,a2--;\n      if(c=='L')v1[a1][a2]=v1[a2][a1]=a3;\n      else v2[a1][a2]=v2[a2][a1]=a3;\n    }\n    r(k,n)r(i,n)r(j,n){\n      v1[i][j]=min(v1[i][j],v1[i][k]+v1[k][j]);\n      v2[i][j]=min(v2[i][j],v2[i][k]+v2[k][j]);\n    }\n    cin>>t>>pre;pre--;\n    dp[0][pre][pre]=0;\n    for(int k=0;k<t-1;k++){\n      cin>>x;x--;\n      for(int i=0;i<n;i++){\n        dp[(k+1)%2][x][i]=min(dp[(k+1)%2][x][i],dp[k%2][pre][i]+v1[pre][x]);\n        for(int j=0;j<n;j++){\n          dp[(k+1)%2][x][j]=min(dp[(k+1)%2][x][j],dp[k%2][pre][i]+v1[pre][i]+v2[i][j]+v1[j][x]);\n        }\n      }\n      r(i,203)r(j,203)dp[k%2][i][j]=1e8;\n      pre=x;\n    }\n    r(i,203)ans=min(ans,dp[(t-1)%2][pre][i]);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<26\nusing namespace std;\n\nint n,m,r;\nint s[201][201],t[201][201],z[1001],dp[1001][201];\n\nvoid init(){\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      if(i==j)s[i][j]=0;\n      else s[i][j]=inf;\n      if(i==j)t[i][j]=0;\n      else t[i][j]=inf;\n    }\n    for(int j=0;j<1001;j++)dp[i][j]=inf;\n  }\n}\n\nvoid wf(){\n  for(int k=0;k<n;k++){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\ts[i][j]=min(s[i][j],s[i][k]+s[k][j]);\n\tt[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n      }\n    }\n  }\n}\n\nint main()\n{\n  int a,b,d;\n  char c;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>d>>c;\n      a--;b--;\n      if(c=='L'){\n\tt[a][b]=d;\n\tt[b][a]=d;\n      }\n      else {\n\ts[a][b]=d;\n\ts[b][a]=d;\n      }\n    }\n    cin>>r;\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n      z[i]--;\n    }\n\n    wf();\n    int ans=inf;\n    for(int i=0;i<n;i++)dp[0][i]=s[z[0]][i];\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][k]+t[z[i-1]][k]+s[k][j]+t[z[i]][j]);\n\t  if(i==r-1)ans=min(ans,dp[i][j]);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=INT_MAX/5;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return weight<e.weight;}\n\tbool operator>(const Edge& e)const{return weight>e.weight;}\n};\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n|m;){\n\t\tvvi gl(n,vi(n,INFTY)),gs(n,vi(n,INFTY)); // 陸路，海路\n\t\trep(i,n) gl[i][i]=gs[i][i]=0;\n\t\trep(i,m){\n\t\t\tint s,d,w; char sl; cin>>s>>d>>w>>sl; s--,d--;\n\t\t\tif(sl=='L' && gl[s][d]>w) gl[s][d]=gl[d][s]=w;\n\t\t\tif(sl=='S' && gs[s][d]>w) gs[s][d]=gs[d][s]=w;\n\t\t}\n\t\tint r; cin>>r;\n\t\tvi route(r);\n\t\trep(i,r) cin>>route[i],route[i]--;\n\t\t\n\t\t// warshall-floyd\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tgl[i][j]=min(gl[i][j],gl[i][k]+gl[k][j]);\n\t\t\tgs[i][j]=min(gs[i][j],gs[i][k]+gs[k][j]);\n\t\t}\n\t\t\n\t\tvvi dp(r,vi(n,INFTY)); // [集配先][船の位置]\n\t\tdp[0][route[0]]=0;\n\t\trepi(i,1,r){\n\t\t\trep(j,n)\n\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+gl[route[i-1]][route[i]]);\n\t\t\trep(j,n) rep(k,n)\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+gl[route[i-1]][j]+gs[j][k]+gl[k][route[i]]);\n\t\t}\n\t\tcout<<*min_element(all(dp[r-1]))<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\n\nstruct Edge {\n    int from;\n    int to;\n    int cost;\n};\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to, const int cost)\n    {\n        edge[from].push_back(Edge{from, to, cost});\n        edge[to].push_back(Edge{to, from, cost});\n    }\n    vector<vector<Edge>> edge;\n};\n\nint main()\n{\n    while (true) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 and M == 0) {\n            break;\n        }\n\n        Graph load(N);\n        Graph sea(N);\n\n        for (int i = 0; i < M; i++) {\n            int x, y, t;\n            char sl;\n            cin >> x >> y >> t >> sl;\n            x--;\n            y--;\n            if (sl == 'L') {\n                load.addEdge(x, y, t);\n            } else {\n                sea.addEdge(x, y, t);\n            }\n        }\n        constexpr int INF = (1 << 28);\n        vector<vector<int>> load_dist(N, vector<int>(N, INF));\n        vector<vector<int>> sea_dist(N, vector<int>(N, INF));\n        for (int i = 0; i < N; i++) {\n            load_dist[i][i] = 0;\n            sea_dist[i][i] = 0;\n        }\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : load.edge[i]) {\n                load_dist[i][e.to] = min(load_dist[i][e.to], e.cost);\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (const auto& e : sea.edge[i]) {\n                sea_dist[i][e.to] = min(sea_dist[i][e.to], e.cost);\n            }\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    load_dist[i][j] = min(load_dist[i][j], load_dist[i][k] + load_dist[k][j]);\n                    sea_dist[i][j] = min(sea_dist[i][j], sea_dist[i][k] + sea_dist[k][j]);\n                }\n            }\n        }\n\n        int R;\n        cin >> R;\n        vector<int> pos(R + 1, 0);\n        for (int i = 0; i < R; i++) {\n            cin >> pos[i + 1];\n            pos[i + 1]--;\n        }\n        vector<vector<int>> dp(R + 1, vector<int>(N, INF));  // i-th query; Ship @j-th town\n        dp[0][0] = 0;\n\n        for (int i = 0; i < R; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int k = 0; k < N; k++) {\n                    if (dp[i][k] == INF) {\n                        continue;\n                    }\n                    const int toship = load_dist[pos[i]][k];\n                    const int seacost = sea_dist[k][j];\n                    const int totown = load_dist[j][pos[i + 1]];\n                    dp[i + 1][j] = min(dp[i + 1][j], dp[i][k] + toship + seacost + totown);\n                }\n            }\n        }\n        int mini = INF;\n        for (int i = 0; i < N; i++) {\n            mini = min(mini, dp[R][i]);\n        }\n        cout << mini << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\tif(r == 1){\n\t\t\tcout << \"0\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\tif(z[i-1] == z[i]){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][j]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < r; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[r-1], dp[r-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < (int)n; i++)\n#define MAX 200\n#define INFTY (1<<21)\n\nint N, M, R, L[MAX][MAX], S[MAX][MAX];\nvector<int> O;\n\nvoid floyd(int D[MAX][MAX], int n){\n    rep(k, n) rep(i, n){\n\tif ( D[i][k] == INFTY ) continue;\n\trep(j, n){\n\t    if ( D[k][j] == INFTY ) continue;\n\t    D[i][j] = min(D[i][j], D[i][k] + D[k][j]);\n\t}\n    }\n}\n\nint compute(){\n    floyd(L, N);\n    floyd(S, N);\n    int T[1000][MAX];\n    rep(i, O.size()) rep(j, N) T[i][j] = INFTY;\n    \n    T[0][O[0]] = 0;\n\n    for ( int i = 1; i < R; i++ ){\n\tfor ( int j = 0; j < N; j++ ){\n\t    T[i][j] = min(T[i][j], T[i-1][j] + L[O[i-1]][O[i]]);\n\t    //T[i][j] =  T[i-1][j] + L[O[i-1]][O[i]];\n\t    for ( int k = 0; k < N; k++ ){\n\t\tT[i][k] = min(T[i][k], T[i-1][j] + L[O[i-1]][j] + S[j][k] + L[k][O[i]]);\n\t    }\n\n\t}\n    }\n\n    int minv = INFTY;\n    rep(i, N) minv = min(minv, T[O.size()-1][i]);\n    return minv;\n\n}\n\nmain(){\n    int s, t, c;\n    char ch;\n    while(cin >> N >> M && N ){\n\tO.clear();\n\trep(i, N) rep(j, N) L[i][j] = S[i][j] = INFTY;\n\trep(i, N) L[i][i] = S[i][i] = 0;\n\trep(i, M){\n\t    cin >> s >> t >> c >> ch;\n\t    s--; t--;\n\t    if ( ch == 'L' ) L[s][t] = L[t][s] = min(L[s][t], c);\n\t    else S[s][t] = S[t][s] = min(S[s][t], c);\n\t}\n\tcin >> R;\n\trep(i, R){\n\t    cin >> s; s--;\n\t    O.push_back(s);\n\t}\n\tcout << compute() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\nconst int N = 222;\nconst int M = N*2;\nconst int R = 1111;\n\nint n,m;\nvector<pii> sea[N];\nvector<pii> land[N];\n\nvector<int> move;\n\nvoid clear(){\n\tmove.clear();\n\trep(i,N){\n\t\tsea[i].clear();\n\t\tland[i].clear();\n\t}\n}\nbool init(){\n\tclear();\n\tcin>>n>>m;\n\tif(n==0)return false;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(d==\"L\"){\n\t\t\tland[a].push_back(pii(b,c));\n\t\t\tland[b].push_back(pii(a,c));\n\t\t}\n\t\tif(d==\"S\"){\n\t\t\tsea[a].push_back(pii(b,c));\n\t\t\tsea[b].push_back(pii(a,c));\n\t\t}\n\t}\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\treturn true;\n}\n\n\nconst int INF = 100000000;\n\nint edge[M][M];\n\nvoid setEdgeSelf(){\n\trep(i,N){\n\t\tedge[i*2][i*2]=0;\n\t\tedge[i*2+1][i*2+1]=0;\n\t\t//edge[i*2][i*2+1]=0;\n\t}\n}\nvoid setEdgeSeaLand(){\n\trep(i,n){\n\t\trep(j,sea[i].size()){\n\t\t\tpii e = sea[i][j];\n\t\t\tint a = e.first*2;\n\t\t\tint b = i*2;\n\t\t\tedge[a][b] = min(edge[a][b], e.second);\n\t\t\tedge[b][a] = min(edge[b][a], e.second);\n\t\t}\n\t\trep(j,land[i].size()){\n\t\t\tpii e = land[i][j];\n\t\t\tint a = e.first*2+1;\n\t\t\tint b = i*2+1;\n\t\t\tedge[a][b] = min(edge[a][b], e.second);\n\t\t\tedge[b][a] = min(edge[b][a], e.second);\n\t\t}\n\t}\n}\n\nvoid setEdge(){\n\trep(i,M)rep(j,M)edge[i][j] = INF;\n\t\n\tsetEdgeSelf();\n\tsetEdgeSeaLand();\n}\n\nvoid printEdge(){\n\treps(i,2,n*2+2){\n\t\treps(j,2,n*2+2){\n\t\t\tint e = edge[i][j];\n\t\t\tif(e==INF)printf(\"oo  \");\n\t\t\telse printf(\"%3d \",e);\n\t\t}puts(\"\");\n\t}puts(\"\");\n}\n\nvoid wf(){\n\trep(k,n*2+2){\n\t\trep(i,n*2+2){\n\t\t\trep(j,n*2+2){\n\t\t\t\tedge[i][j] = min(edge[i][j], edge[i][k]+edge[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint solvedp(){\n\tint dp[R][N];\n\trep(i,R)rep(j,N)dp[i][j]=INF;\n\t\n\tdp[0][move[0]]=0;\n\treps(i,1,move.size()){\n\t\tint prev = move[i-1];\n\t\tint now = move[i];\n\t\t\n\t\trep(j,n+1){\n\t\t\trep(k,n+1){\n\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+edge[prev*2+1][j*2+1]+edge[j*2][k*2]+edge[k*2+1][now*2+1]);\n\t\t\t}\n\t\t}\n\t}\n\tint ans = INF;\n\trep(i,n+1)ans = min(ans, dp[move.size()-1][i]);\n\t\n\tif(ans==INF)return -1;\n\treturn ans;\n}\n\nint solve(){\n\tsetEdge();\n\twf();\n\t\n\t//printEdge();\n\t\n\treturn solvedp();\n}\n\nint main(){\n\twhile(init())printf(\"%d\\n\",solve());\n}\n\n\n/*\n3 3\n1 2 5 L\n1 2 7 S\n2 3 11 S\n3\n1 2 3\n0 0\n\n5 5\n1 2 15 L\n2 3 10 L\n4 5 7 L\n1 3 30 S\n3 4 100 S\n5\n1 3 5 4 1\n0 0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stdio.h>\n#include<cstring>\n#define rep(i,n) for(int i=1;i<=n;i++)\nusing namespace std;\ntypedef long long LL;\nconst int INF = 0x3f3f3f3f;\nint n, m, q, x, y, z, d[1010];\nchar c;\nint dl[210][210], ds[210][210], dp[1010][210];\nint main() {\n\twhile (~scanf(\"%d%d\",&n,&m),n+m)\n\t{\n\t\trep(i, n) rep(j, n) ds[i][j] = dl[i][j] = i == j ? 0 : INF;\n\t\trep(i, m) {\n\t\t\tscanf(\"%d%d%d %c\", &x, &y, &z, &c);\n\t\t\tif (c == 'S') ds[x][y] = ds[y][x] = min(ds[x][y], z);\n\t\t\telse dl[x][y] = dl[y][x] = min(dl[x][y], z);\n\t\t}scanf(\"%d\", &q);\n\t\trep(i, q) scanf(\"%d\", d + i);\n\t\trep(k, n) rep(i, n) rep(j, n) {\n\t\t\tds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n\t\t\tdl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n\t\t}memset(dp, INF, sizeof(dp));\n\t\tdp[1][d[1]] = 0;\n\t\trep(i, q) rep(j, n) {\n\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + dl[d[i - 1]][d[i]]);\n\t\t\trep(k, n) dp[i][k] = min((LL)dp[i][k], (LL)dp[i - 1][j] + dl[d[i - 1]][j] + ds[j][k] + dl[k][d[i]]);\n\t\t}printf(\"%d\\n\", *min_element(dp[q], dp[q] + n + 1));\n\t}return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <sstream>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <complex>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <utility>\n#define rep(i,a,b) for(int i=(a); i<(b); i++)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define ll long long\n#define pb(a) push_back(a)\n#define fi first\n#define se second\nusing namespace std;\n\ntemplate<class T>inline string toString(T x){\n        ostringstream sout; sout<<x; return sout.str();\n}\nconst ll MOD=1e9+7;\nconst int inf=(ll)1e9;\nconst double PI=acos(-1.0);\n\n\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.precision(10);\n    cout<<fixed;\n    int n,m;\n    while(cin>>n>>m,n){\n    \tint ldp[201][201];\n    \tint sdp[201][201];\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tldp[i][j]=inf;\n    \t\t\tsdp[i][j]=inf;\n    \t\t}\n    \t}\n    \tfor(int i=0;i<n;i++){\n    \t\tldp[i][i]=0;\n    \t\tsdp[i][i]=0;\n    \t}\n    \tfor(int i=0;i<m;i++){\n    \t\tint a,b,c;\n    \t\tchar d;\n    \t\tcin>>a>>b>>c>>d;\n    \t\ta--;b--;\n    \t\tif(d=='L'){\n    \t\t\tldp[a][b]=c;\n    \t\t\tldp[b][a]=c;\n    \t\t}else{\n    \t\t\tsdp[a][b]=c;\n    \t\t\tsdp[b][a]=c;\n    \t\t}\n    \t}\n    \tfor(int k=0;k<n;k++){\n    \t\tfor(int i=0;i<n;i++){\n    \t\t\tfor(int j=0;j<n;j++){\n    \t\t\t\tldp[i][j]=min(ldp[i][k]+ldp[k][j],ldp[i][j]);\n    \t\t\t\tsdp[i][j]=min(sdp[i][k]+sdp[k][j],sdp[i][j]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint r;cin>>r;\n    \tint a[1002];\n    \tfor(int i=0;i<r;i++){\n    \t\tcin>>a[i];\n    \t\ta[i]--;\n    \t}\n    \tint dp[1001][201];\n    \tfor(int i=0;i<1001;i++)for(int j=0;j<201;j++)dp[i][j]=inf;\n    \tdp[0][a[0]]=0;\n    \tfor(int i=0;i<r-1;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tif(dp[i][j]==inf)continue;\n    \t\t\tfor(int k=0;k<n;k++){\n\t    \t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][j]+sdp[j][k]+ldp[k][a[i+1]]);\n\t    \t\t\tif(j==k)dp[i+1][k]=min(dp[i+1][k],dp[i][j]+ldp[a[i]][a[i+1]]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \t/*for(int i=0;i<r;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tcerr<<dp[i][j]<<\" \";\n    \t\t}\n    \t\tcerr<<\"\\n\";\n    \t}*/\n    \tint ans=inf;\n    \tfor(int i=0;i<201;i++){\n    \t\tans=min(ans,dp[r-1][i]);\n    \t}\n    \tcout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-10L)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair((a),(b))\n#define list3(a,b,c) mp((a),mp((b),(c)))\n#define list4(a,b,c,d) mp((a),list3((b),(c),(d)))\n#define pb(a) push_back(a)\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\n\nint n,m;\nll scost[200][200];\nll lcost[200][200];\nint z[1000];\nll cost[1000][200];\n\nvoid solve(){\n  rep(i,n)rep(j,n) scost[i][j]=lcost[i][j]=1LL<<30LL;\n  rep(i,n) scost[i][i]=lcost[i][i]=0;\n  rep(i,m){\n    ll x,y,t;\n    char s;\n    cin >> x >> y >> t >> s;\n    --x,--y;\n    if(s=='S') scost[x][y]=scost[y][x]=min(scost[x][y],t);\n    else lcost[x][y]=lcost[y][x]=min(lcost[x][y],t);    \n  }\n  rep(k,n)rep(i,n)rep(j,n){\n    scost[i][j]=min(scost[i][j],scost[i][k]+scost[k][j]);\n    lcost[i][j]=min(lcost[i][j],lcost[i][k]+lcost[k][j]);\n  }\n\n  int r;\n  cin >> r;\n  rep(i,r){ cin >> z[i];--z[i];}\n  rep(i,r+1)rep(j,n) cost[i][j]=1LL<<50LL;\n  cost[0][z[0]]=0;\n  ll ans=1LL<<60LL;\n  rep(i,r-1)rep(j,n){\n    rep(k,n){\n      ll nc=cost[i][j];\n      if(k==j)  nc += lcost[z[i]][z[i+1]];\n      else nc += lcost[z[i]][j]+scost[j][k]+lcost[k][z[i+1]];\n      cost[i+1][k]=min(cost[i+1][k],nc);\n      if(i+1==r-1) ans=min(ans,cost[i+1][k]);\n    }\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> n >> m && n) solve();\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////\n///   template   ///\n////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-10\n#define INF 100000000\n#define MOD 1000000007\n\n#define PREDIACTE(t,a) [](const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) [](const t & a, const t & b) -> bool\n\n//// algorithm ////\n\n// compare\ntemplate <class InIt1, class InIt2>\nint partial_compare(InIt1 first1, InIt1 last1, InIt2 first2, InIt2 last2)\n{\n\treturn lexicographical_compare(first1, last1, first2, last2) ? -1\n\t\t: lexicographical_compare(first2, last2, first1, last1) ? 1\n\t\t: 0;\n}\n\n// index_of\ntemplate <class InIt, class T>\ninline int index_of(InIt first1, InIt last1, const T &val)\n{\n\tInIt f = find(first1, last1, val);\n\treturn f != last1 ? distance(f, first1) : -1;\n}\n\n// C# BinarySearch風のindex_of\ntemplate <class InIt, class T>\ninline int bindex_of(InIt first1, InIt last1, const T &val)\n{\n\tauto it = lower_bound(first1, last1, val);\n\tif (it == last1) { return ~distance(it, first1); }\n\telse if (*it == val) { return distance(it, first1); }\n\telse return ~distance(it, first1);\n}\n\n// vector iota iterator\nvector<int> iotav(int begin, int end)\n{\n\tvector<int> r(end - begin);\n\tiota(allof(r), begin);\n\treturn r;\n}\n\nstruct iotait\n{\n\tint n;\n\tiotait(int n = 0) : n(n) { }\n\tiotait &operator ++() { ++n; return *this; }\n\tint operator *() { return n; }\n};\n\n\n// 最大公約数\nlong gcd(long a, long b) { return b ? gcd(b, a%b) : a; }\n\n// 最小公倍数\nlong lcm(long a, long b) { return a / gcd(a, b) * b; }\n\n// 拡張ユークリッド互除法\nvoid exgcd(long a, long b, long& x, long& y) {\n\tif (b != 0) { exgcd(b, a%b, y, x); y -= a / b*x; }\n\telse { x = 1; y = 0; }\n}\n\n//// data structure ////\n\n/// 2分セグメント木。RMQとかが解ける。\ntemplate<class T = int, class TParentFunc = const T& (*)(const T&, const T&)>\nstruct SegTree\n{\n\tint count;\n\tvector<T> tree;\n\tTParentFunc parent;\n\n\tSegTree(int size, TParentFunc parentBuilder = std::min, T initialFill = INF)\n\t\t: count((size | size - 1) + 1)\n\t\t, tree(count * 2)\n\t\t, parent(parentBuilder)\n\t{\n\t\tfill(partof(tree, count, count), initialFill);\n\t\trebuild();\n\t}\n\n\t// []を使うと更新されないのでrebuildすること。数が少なければupdateの方がよい。\n\tT& operator[](int i) { return tree[i + count]; }\n\tvoid rebuild() { RREP(i, count) { tree[i] = parent(tree[i * 2], tree[i * 2 + 1]); } }\n\n\tvoid update(int index, T value)\n\t{\n\t\ttree[index + count] = value;\n\t\tfor (int i = (index + count) / 2; i > 0; i /= 2)\n\t\t\ttree[i] = parent(tree[i * 2], tree[i * 2 + 1]);\n\t}\n\n\tT query(int s, int e, int i, int l, int r, T value)\n\t{\n\t\tif (r <= s || e <= l) return value;\n\t\tif (s <= l && r <= e) return parent(value, tree[i]);\n\t\tvalue = query(s, e, i * 2, l, (l + r) / 2, value);\n\t\tvalue = query(s, e, i * 2 + 1, (l + r) / 2, r, value);\n\t\treturn value;\n\t}\n\n\tT query(int start, int count, T initialValue)\n\t{\n\t\treturn query(start, start + count, 1, 0, count, initialValue);\n\t}\n};\n\n\n//// prime ////\nvector<unsigned char> isPrime;\nvector<int> primes;\nvoid initPrimes(int n)\n{\n\tisPrime = vector<unsigned char>(n + 1, true);\n\tisPrime[0] = isPrime[1] = false;\n\tFOR(i, 2, n + 1)\n\t{\n\t\tif (!isPrime[i]) continue;\n\t\tprimes.push_back(i);\n\t\tfor (int j = i * 2; j <= n; j += i)\n\t\t\tisPrime[j] = false;\n\t}\n}\n\n//// Probability ////\n\n// パスカルの三角形(二項定理) 2種類の並べ替えにつかう。\nvector<vector<double>> makePascalTriangle(int n, bool probability = false)\n{\n\ttypedef vector<double> VD;\n\tvector<VD> t;\n\tif (!t.size()) { t.push_back(VD(1, 1)); }\n\tFOR(i, t.size(), n + 1)\n\t{\n\t\tt.push_back(VD(i + 1));\n\t\tREP(j, i)\n\t\t{\n\t\t\tdouble x = t[i - 1][j] * (probability ? 0.5 : 1);\n\t\t\tt[i][j] += x;\n\t\t\tt[i][j + 1] += x;\n\t\t}\n\t}\n\treturn t;\n}\n\n\n\n//// geo ////\n\n/// 3次元\nstruct P3\n{\n\tdouble x, y, z;\n\tP3(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) { }\n\tP3 operator +() const { return *this; }\n\tP3 operator +(const P3 &_) const { return P3(x + _.x, y + _.y, z + _.z); }\n\tP3 operator -() const { return P3(-x, -y, -z); }\n\tP3 operator -(const P3 &_) const { return *this + -_; }\n\tP3 operator *(double _) const { return P3(x*_, y*_, z*_); }\n\tP3 operator /(double _) const { return P3(x / _, y / _, z / _); }\n\tdouble dot(const P3 &_) const { return x*_.x + y*_.y + z*_.z; } // 内積\n\tP3 cross(const P3 &_) const { return P3(y*_.z - z*_.y, z*_.x - x*_.z, x*_.y - y*_.x); } // 外積\n\tdouble sqlength() const { return x*x + y*y + z*z; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP3 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P3 & p) { in >> p.x >> p.y >> p.z; return in; }\ninline double abs(P3 p) { return p.length(); }\n\nstruct Sphere\n{\n\tP3 c;\n\tdouble r;\n\tSphere(double x, double y, double z, double r) : c(x, y, z), r(r) { }\n\tSphere(P3 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Sphere &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Sphere & c) { in >> c.c >> c.r; return in; }\n\n/// 2次元\nstruct P2\n{\n\tdouble x, y;\n\tP2(double x = 0, double y = 0) : x(x), y(y) { }\n\tP2(complex<double> c) : x(c.real()), y(c.imag()) { }\n\tP2 operator +() const { return *this; }\n\tP2 operator +(const P2 &_) const { return P2(x + _.x, y + _.y); }\n\tP2 operator -() const { return P2(-x, -y); }\n\tP2 operator -(const P2 &_) const { return *this + -_; }\n\tP2 operator *(double _) const { return P2(x*_, y*_); }\n\tP2 operator /(double _) const { return P2(x / _, y / _); }\n\tdouble dot(const P2 &_) const { return x*_.x + y*_.y; } // 内積\n\tdouble cross(const P2 &_) const { return x*_.y - y*_.x; } // 外積\n\tdouble sqlength() const { return x*x + y*y; } // 二乗長さ\n\tdouble length() const { return sqrt(sqlength()); } // 長さ\n\tP2 orthogonal() const { return P2(y, -x); }\n\tP2 direction() const { return *this / length(); } // 方向ベクトル\n};\ninline istream & operator>>(istream & in, P2 & p) { in >> p.x >> p.y; return in; }\ninline double abs(P2 p2) { return p2.length(); }\ninline P2 orthogonal(P2 p) { return p.orthogonal(); }\ninline complex<double> orthogonal(complex<double> c) { return  c * complex<double>(0, 1); }\n\n// a,b から ちょうど d だけ離れた点。aとbを円周に持つ円の半径。\ninline pair<P2, P2> get_same_distance_points(P2 a, P2 b, double d)\n{\n\tassert(abs(a - b) <= 2 * d + EPS);\n\tauto v = (a + b) / 2.0 - a; // a から aとbの中点\n\tauto vl = abs(v);\n\tauto wl = sqrt(d*d - vl*vl); // 直行Vの大きさ\n\tauto w = orthogonal(v) * (wl / vl); // 直行V\n\treturn make_pair(a + v + w, a + v - w);\n}\n\nstruct Circle\n{\n\tP2 c;\n\tdouble r;\n\tCircle(double x, double y, double r) : c(x, y), r(r) { }\n\tCircle(P2 c, double r) : c(c), r(r) { }\n\tbool IntersectWith(const Circle &rhs) const { return abs(c - rhs.c) - (r + rhs.r) < EPS; } // 接してても真。\n\tbool Contains(const P2 &p) const { return abs(p - c) - r < EPS; } // 接してても真。\n};\ninline istream & operator>>(istream & in, Circle & c) { in >> c.c >> c.r; return in; }\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int next_bit_permutation(int x)\n{\n\tint t = x | (x - 1);\n\treturn (t + 1) | (unsigned)((~t & -~t) - 1) >> (__builtin_ctz(x) + 1);\n}\n\n// x の p1からlen bitと p2 から len bit を入れ替える\ntemplate<class T>\nint bit_swap(T x, size_t p1, size_t p2, size_t len)\n{\n\tT mask = (1ul << len) - 1;\n\tT ope = (x >> p1 ^ x >> p2) & mask; // 入れ替える場所のxorを求める\n\treturn x ^ (ope << p1 | ope << p2); // 入れ替える場所をxor。\n}\n\n//// graph ////\ntypedef int COST;\nstruct Path\n{\n\tint from;\n\tint to;\n\tCOST cost;\n\tCOST capacity;\n\tPath(int from = 0, int to = 0, COST cost = 0, COST capacity = -1)\n\t\t: from(from), to(to), cost(cost), capacity(capacity) { }\n\tbool operator < (const Path &rhs) const { return cost < rhs.cost; }\n\tbool operator >(const Path &rhs) const { return cost > rhs.cost; }\n};\n\n// prim //\npair<COST, vector<int>> prim(const vector<vector<COST>> &costTable)\n{\n\tint N = costTable.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(0, 0, 0));\n\n\tvector<int> parent(N, -1);\n\tCOST totalCost = 0;\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (parent[i] != -1) continue;\n\t\tparent[i] = cur.from;\n\t\ttotalCost += cur.cost;\n\t\tREP(j, N) if (parent[j] == -1) q.push(Path(i, j, costTable[i][j]));\n\t}\n\treturn make_pair(totalCost, parent);\n}\n\n// dijkstra //\npair<vector<COST>, vector<int>> dijkstra(const vector<vector<Path>> &routes, int start = 0, int goal = -1)\n{\n\tint N = routes.size();\n\tpriority_queue<Path, vector<Path>, greater<Path>> q;\n\tq.push(Path(start, start, 0));\n\n\tvector<int> prev(N, -1);\n\tvector<COST> cost(N, INF);\n\twhile (!q.empty())\n\t{\n\t\tPath cur = q.top(); q.pop();\n\t\tint i = cur.to;\n\t\tif (prev[i] != -1) continue;\n\t\tprev[i] = cur.from;\n\t\tcost[i] = cur.cost;\n\t\tif (i == goal) { break; }\n\t\tREP(j, routes[i].size())\n\t\t{\n\t\t\tPath next = Path(i, routes[i][j].to, cur.cost + routes[i][j].cost);\n\t\t\tif (prev[next.to] == -1)\n\t\t\t\tq.push(next);\n\t\t}\n\t}\n\treturn make_pair(cost, prev);\n}\n\nvoid warshall_floyd(vector<vector<COST>> &cost)\n{\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\n\n//// dice ////\n\n// さいころ\ntemplate<class T>\nstruct Die\n{\n\t/* v as 天一地六東五西二南三北四\n\t|3|\n\t|1|0|4|5|\n\t|2|\n\t*/\n\tT v[6];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 4, 5, 1); }\n\tvoid rotateRight() { rt(1, 5, 4, 0); }\n\tvoid rotateDown() { rt(0, 3, 5, 2); }\n\tvoid rotateUp() { rt(2, 5, 3, 0); }\n\tvoid rotateCw() { rt(3, 1, 2, 4); }\n\tvoid rotateCcw() { rt(4, 2, 1, 3); }\n\tbool operator < (const Die &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Die &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Die &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n// 8面体\ntemplate<class T>\nstruct Octahedra\n{\n\t/* v as\n\t/0\\/1\\/2\\/3\\\n\t\\4/\\5/\\6/\\7/\n\t*/\n\tT v[8];\n\n\tvoid rt(int x, int y, int z, int w) { swap(v[x], v[y]); swap(v[x], v[z]); swap(v[x], v[w]); }\n\tvoid rotateLeft() { rt(0, 1, 2, 3); rt(4, 5, 6, 7); }\n\tvoid rotateRight() { rt(3, 2, 1, 0); rt(7, 6, 5, 4); }\n\tvoid rotateDown() { rt(0, 4, 7, 3); rt(1, 5, 6, 2); }\n\tvoid rotateUp() { rt(3, 7, 4, 0); rt(2, 6, 5, 2); }\n\tvoid rotateCw() { rt(0, 1, 5, 4); rt(3, 2, 6, 7); }\n\tvoid rotateCcw() { rt(4, 5, 1, 0); rt(7, 6, 1, 3); }\n\tbool operator < (const Octahedra &rhs) const { return lexicographical_compare(aallof(v), aallof(rhs.v)); }\n\tbool operator == (const Octahedra &rhs) const { return equal(aallof(v), rhs.v); }\n\tbool operator != (const Octahedra &rhs) const { return !equal(aallof(v), rhs.v); }\n};\n\n\n\n//// i/o ////\ntemplate <class T>\nclass vevector : public vector<vector<T>>\n{\npublic:\n\tvevector(int n = 0, int m = 0) : vector<vector<T>>(n, vector<T>(m)) { };\n\tvevector(int n, int m, const T &initial) : vector<vector<T>>(n, vector<T>(m, initial)) { };\n};\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(read<T>(read<int>())); return v; }\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n\ntemplate <class T> void write(const T &t) { cout << t << endl; }\ntemplate <class T, class T2> void write(const T &t, const T2 &t2) { cout << t << ' ' << t2 << endl; }\ntemplate <class T> void write(const vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tcout << s.substr(0, s.length() - 1) << endl;\n}\n\n\n//// start up ////\nvoid solve();\nint main()\n{\n\t// freopen(\"A.in\", \"r\", stdin);\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nvoid solve()\n{\n\tauto testcases = INF; // read<int>();\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, n, m);\n\t\tif (!(n | m)){ break; }\n\n\t\t// read\n\t\tvevector<int> landMap(n, n, INF), seaMap(n, n, INF);\n\n\t\tREP(_, n) { landMap[_][_] = seaMap[_][_] = 0; }\n\t\tREP(_, m)\n\t\t{\n\t\t\tREAD(int, x, y, t); READ(char, sl); x--; y--;\n\t\t\tif (sl == 'S') { seaMap[x][y] = seaMap[y][x] = min(seaMap[x][y], t); }\n\t\t\telse { landMap[x][y] = landMap[y][x] = min(landMap[x][y], t); }\n\t\t}\n\n\t\twarshall_floyd(landMap); // 陸路のみマップ\n\t\twarshall_floyd(seaMap); // 海路のみマップ\n\n\t\tREAD(int, R);\n\t\tvector<int> r = read<int>(R);\n\n\t\t\n\t\tvevector<int> dp(R, n, INF); // dp[i][j] 船をjにおいてi番目の町にいるよ。\n\t\tdp[0][r[0] - 1] = 0;\n\n\t\tFOR(i, 1, R) // 最後の町まで行く\n\t\t{\n\t\t\tint cur = r[i - 1] - 1, next = r[i] - 1;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\t// 船をjにおいたまま。\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + landMap[cur][next]); // 陸路のみ\n\n\t\t\t\t// 船をkに移動してから行く。\n\t\t\t\tREP(k, n)\n\t\t\t\t{\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i - 1][j] + landMap[cur][j] + seaMap[j][k] + landMap[k][next]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result = *min_element(allof(dp[R - 1]));\n\t\twrite(result);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                //if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=INF) {\n                //    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                //}\n                assert(z[i]<N);\n                if (dp[i-1][j]!=INF) {\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define INF 1e6\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX];\n      for(int i = 0 ; i < MAX ; i++){\n        for(int j = 0 ; j < MAX ; j++){\n          dp[i][j] = INF;\n        }\n      }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        dp[r][now] = min(dp[r][now], dp[r-1][now] + G1[now][next]);\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            rep(j,n){\n                cmin(dp[i+1][j],dp[i][j]+Ld[v[i]][v[i+1]]);\n                rep(k,n){\n                    cmin(dp[i+1][k],dp[i][j] + Ld[v[i]][j] + Sd[j][k] + Ld[k][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int INF = (int)1e8;\n\nstruct Edge {\n  // type = 0 -> land\n  // type = 1 -> sea\n  int from, to, cost, type;\n  Edge(int from_, int to_, int cost_, int type_) : from(from_), to(to_), cost(cost_), type(type_) { }\n};\n\nint main() {\n  while(true) {\n    int N, M; cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    vector<Edge> G;\n    for(int i = 0; i < M; ++i) {\n      int x,y,t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x; --y;\n      G.emplace_back(x,y,t,sl=='S');\n    }\n    int R; cin >> R;\n    vector<int> Z;\n    for(int i = 0; i < R; ++i) {\n      int z; cin >> z;\n      --z;\n      Z.push_back(z);\n    }\n    int dl[N][N];\n    int ds[N][N];\n    for(int i = 0; i < N; ++i) {\n      for(int j = 0; j < N; ++j) {\n        dl[i][j] = INF;\n        ds[i][j] = INF;\n      }\n      dl[i][i] = 0;\n      ds[i][i] = 0;\n    }\n    for(int i = 0; i < M; ++i) {\n      if(G[i].type == 0) {\n        dl[G[i].from][G[i].to] = min(dl[G[i].from][G[i].to], G[i].cost);\n        dl[G[i].to][G[i].from] = min(dl[G[i].to][G[i].from], G[i].cost);\n      }\n      else {\n        ds[G[i].from][G[i].to] = min(ds[G[i].from][G[i].to], G[i].cost);\n        ds[G[i].to][G[i].from] = min(ds[G[i].to][G[i].from], G[i].cost);\n      }\n    }\n    for(int k = 0; k < N; ++k) {\n      for(int i = 0; i < N; ++i) {\n        for(int j = 0; j < N; ++j) {\n          dl[i][j] = min(dl[i][j], dl[i][k] + dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k] + ds[k][j]);\n        }\n      }\n    }\n    int d[R][N];\n    for(int i = 0; i < R; ++i)\n      for(int j = 0; j < N; ++j)\n        d[i][j] = INF;\n    d[0][Z[0]] = 0;\n    for(int r = 0; r < R - 1; ++r) {\n      for(int i = 0; i < N; ++i) {\n        d[r+1][i] = min(d[r+1][i], d[r][i] + dl[Z[r]][Z[r+1]]);\n        for(int j = 0; j < N; ++j) {\n          d[r+1][j] = min(d[r+1][j], d[r][i] + dl[Z[r]][i] + ds[i][j] + dl[j][Z[r+1]]);\n        }\n      }\n    }\n    int ans = INF;\n    for(int i = 0; i < N; ++i) {\n      ans = min(ans, d[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &st) const { return d > st.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  for(int l=0;l<2;l++){\n\t    if(l == 0){\n\t      if(L[i][k] >= INF || L[k][j] >= INF) continue;\n\t      L[i][j] = min(L[i][j],L[i][k]+L[k][j]);\n\t    }\n\t    else{\n\t      if(S[i][k] >= INF || S[k][j] >= INF) continue;\n\t      S[i][j] = min(S[i][j],S[i][k]+S[k][j]);\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > ans(2,vector<int>(n,INF));\n    ans[0][dest[0]] = 0;\n    int ans2;\n\n    for(int i=1;i<n2;i++){    \n      ans2 = INF;\n      for(int j=0;j<n;j++){\n\tif(ans[0][j] >= INF) continue;\t\n\n\tpriority_queue<State> Q;\n\tvector<vector<State2> > d(n,vector<State2>(n));\n\tState u(ans[0][j],dest[i-1],j);\n\td[dest[i-1]][j].d = ans[0][j];\n\tQ.push(u);\n\n\twhile(!Q.empty()){\n\t  u = Q.top();\n\t  Q.pop();\n\n\t  if(d[u.n][u.s].f) continue;\n\t  d[u.n][u.s].f = true;\n\t  if(u.n == dest[i]){\n\t    ans[1][u.s] = min(ans[1][u.s],u.d);\n\t    ans2 = min(ans2,ans[1][u.s]);\n\t    continue;\n\t  }\n\n\t  for(int k=0;k<n;k++){\n\t    if(!d[k][u.s].f && d[u.n][u.s].d + L[u.n][k] < d[k][u.s].d){\n\t      State v = u;\n\t      v.d = d[k][u.s].d = d[u.n][u.s].d + L[u.n][k];\n\t      v.n = k;\n\t      Q.push(v);\n\t    }\n\t    if(u.s == u.n){\n\t      if(!d[k][k].f && d[u.n][u.s].d + S[u.n][k] < d[k][k].d){\n\t\tState v2 = u;\n\t\tv2.d = d[k][k].d = d[u.n][u.s].d + S[u.n][k];\n\t\tv2.s = v2.n = k;\n\t\tQ.push(v2);\n\t      }\n\t    }\n\t  }\n\t}\n      }\n      ans[0].assign(ans[1].begin(),ans[1].end());\n      ans[1].assign(n,INF);\n    }\n\n    cout << ans2 << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define INF (1000*1000*200)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\nint dp[1001][200];\nint land[200][200],sea[200][200];\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n||m){\n\t\tfill_n((int*)dp,1001*200,INF);\n\t\tfill_n((int*)land,200*200,INF);\n\t\tfill_n((int*)sea,200*200,INF);\n\t\trep(i,n){\n\t\t\tland[i][i]=sea[i][i]=0;\n\t\t}\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tx--;y--;\n\t\t\tif(sl=='L'){\n\t\t\t\tland[x][y]=land[y][x]=min(land[x][y],t);\n\t\t\t}else{\n\t\t\t\tsea[x][y]=sea[y][x]=min(sea[x][y],t);\n\t\t\t}\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tland[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n\t\t\tsea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tint r,z[1000];\n\t\tcin>>r;\n\t\trep(i,r)cin>>z[i],z[i]--;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1){\n\t\t\trep(j,n){\n\t\t\t\tdp[i+1][j]=min(dp[i+1][j], dp[i][j]+land[z[i]][z[i+1]]);\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i+1][k]=min(dp[i+1][k],\n\t\t\t\t\t\tdp[i][j]+land[z[i]][j]+sea[j][k]+land[k][z[i+1]] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<*min_element(dp[r-1],dp[r-1]+n)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[N],W[N][N],L[N][N],dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        memset(dp,INF,sizeof(dp));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        dp[1][1]=0;\n        for (int i=2;i<=n;i++) dp[1][i]=W[1][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n\n\n            }\n        }\n        int ans=INF;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <queue>\n#include <vector>\n#include <iostream> \n#include <algorithm>\n#include <math.h>\n#include <map>  \n#include <string.h> \n\nusing namespace std;\n\nconst int INF=100000000;\n                             \nint dS[201][201],dL[201][201],dp[1001][201],z[1001];\n\nint main() {\n  \n  while(1){\n    \n   int N,M;\n    \n   cin>>N>>M;\n   \n   if(N==0) break;\n   \n   fill(dL[0],dL[201],INF);\n   fill(dS[0],dS[201],INF);\n   \n   for(int i=0; i<M; i++){\n     \n     int s,t,v; char u;\n     \n     cin>>s>>t>>v>>u;\n     \n     if(u=='L'){\n     dL[s][t]=min(dL[s][t],v);  \n     dL[t][s]=min(dL[t][s],v);  \n     }else{\n     dS[s][t]=min(dS[s][t],v);  \n     dS[t][s]=min(dS[t][s],v); \n     }\n    \n    }\n    \n    int R; cin>>R;\n    \n    for(int i=1; i<=R; i++){\n      cin>>z[i];\n      }\n     \n     \n    for(int k=1; k<=N; k++){\n     for(int i=1; i<=N; i++){\n       for(int j=1; j<=N; j++){ \n       if(i==j) {dL[i][j]=0; dS[i][j]=0;}\n       dL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n       dS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n        }\n       }\n      } \n\n   fill(dp[0],dp[1001],INF);\n    \n    for(int i=1; i<=N; i++){\n      dp[1][i]=dS[i][z[1]]+dL[z[1]][i];\n      }\n   \n     for(int i=2; i<=R; i++){\n       for(int j=1; j<=N; j++){\n         for(int k=1; k<=N; k++){\n           if(j!=k) dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[z[i-1]][j]+dS[j][k]+dL[k][z[i]]);\n           else dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[z[i-1]][z[i]]);\n             }\n           }\n         }\n         \n         int ans=INF;\n         \n         for(int i=1; i<=N; i++){\n           if(ans>dp[R][i]) ans=dp[R][i];\n           }\n           \n           cout<<ans<<endl;\n     \n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(n) for(int i=0;i<n;i++)\n#define repp(j, n) for(int j=0;j<n;j++)\n#define reppp(i, m, n) for(int i=m;i<n;i++)\n#define all(c) c.begin(), c.end()\n#define rall(c) c.rbegin(), c.rend()\n#define debug(x) cerr << #x << \": \" << x << endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> Pll;\ntypedef pair<int, int> Pii;\nstruct Edge{int from, to; ll cost;};\n\nconst ll MOD = 1000000007;\nconst long double EPS = 10e-10;\n\nint main(){\n    int n, m, x, y, r;\n    ll t;\n    char sl;\n    while(scanf(\"%d%d\", &n, &m) &&  n!=0){\n        vector< vector<ll> > st(n, vector<ll>(n, LLONG_MAX)), lt(n, vector<ll>(n, LLONG_MAX));\n        rep(n){\n            st[i][i] = 0LL;\n            lt[i][i] = 0LL;\n        }\n        rep(m){\n            cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == 'S'){\n                st[x][y] = min(st[x][y], t);\n                st[y][x] = min(st[y][x], t);\n            }else{\n                lt[x][y] = min(lt[x][y], t);\n                lt[y][x] = min(lt[y][x], t);\n            }\n        }\n\n        repp(k, n){\n            repp(i, n){\n                repp(j, n){\n                    if(st[i][k] != LLONG_MAX && st[k][j] != LLONG_MAX)\n                        st[i][j] = min(st[i][j], st[i][k] + st[k][j]);\n                    if(lt[i][k] != LLONG_MAX && lt[k][j] != LLONG_MAX)\n                        lt[i][j] = min(lt[i][j], lt[i][k] + lt[k][j]);\n                }\n            }\n        }\n\n        cin >> r;\n        vector<int> z(r);\n        rep(r){\n            cin >> z[i];\n            z[i]--;\n        }\n\n        // dp[i][j]: z[i]にいる，お船はjにあるときの最短時間\n        ll dp[r][n];\n        fill(dp[0], dp[r], LLONG_MAX);\n        dp[0][0] = 0LL;\n        rep(r-1){\n            repp(j, n){\n                if(dp[i][j] == LLONG_MAX) continue;\n                // z[i]からkまで徒歩，kからlまで船，lからz[i+1]まで徒歩\n                repp(k, n){\n                    if(lt[z[i]][k] == LLONG_MAX) continue;\n                    repp(l, n){\n                        if(dp[i][k] != LLONG_MAX && st[k][l] != LLONG_MAX && lt[l][z[i+1]] != LLONG_MAX){\n                            dp[i+1][l] = min(dp[i+1][l], dp[i][k]+lt[z[i]][k]+st[k][l]+lt[l][z[i+1]]);\n                        }\n                    }\n                }\n                // 徒歩だけで行く\n                if(lt[z[i]][z[i+1]] != LLONG_MAX){\n                    dp[i+1][j] = min(dp[i+1][j], dp[i][j] + lt[z[i]][z[i+1]]);\n                }\n            }\n            // repp(j, n) printf(\"%5lld\", dp[z[i+1]][j] == LLONG_MAX ? -1 : dp[z[i+1]][j]);\n            // printf(\"\\n\");\n        }\n\n        ll ans = LLONG_MAX;\n        rep(n) ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int INF = 1<<30;\n\nint cost[2][201][201];\nbool used[201][201][1001];\n\nstruct t_node {\n\tint pos;\n\tint ship;\n\tint time;\n\tint delindex;\n\tbool visit[201];\n\tt_node(int p, int s, int t, int d) {\n\t\tpos = p;\n\t\tship = s;\n\t\ttime = t;\n\t\tdelindex = d;\n\t}\n};\nbool operator<( const t_node& lhs, const t_node &rhs ) {\n\treturn lhs.time > rhs.time;\n}\n\nint main() {\n\tint n, m;\n\twhile( cin >> n >> m, n||m ) {\n\t\tmemset( used, 0, sizeof(used) );\n\t\trep(i,2) rep(j,201) rep(k,201) cost[i][j][k] = INF;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tint s = (sl=='L' ? 0 : 1);\n\t\t\tcost[s][x][y] = cost[s][y][x] = t;\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> deliver(r);\n\t\trep(i, r) {\n\t\t\tcin >> deliver[i];\n\t\t}\n\t\tpriority_queue<t_node> que;\n\t\tque.push( t_node(1, 1, 0, 0) );\n\t\twhile( !que.empty() ) {\n\t\t\tt_node tn = que.top();\n\t\t\tque.pop();\n\t\t\tif( used[tn.pos][tn.ship][tn.delindex] ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused[tn.pos][tn.ship][tn.delindex] = true;\n\t\t\tif( deliver[tn.delindex] == tn.pos ) {\n\t\t\t\ttn.delindex++;\n\t\t\t\tif( tn.delindex == r ) {\n\t\t\t\t\tcout << tn.time << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, (tn.pos==tn.ship ? 2 : 1)) {\n\t\t\t\trep(i, n+1) {\n\t\t\t\t\tif( cost[j][tn.pos][i] < INF ) {\n//\t\t\t\t\t\tcout << \"push \" << tn.pos << \" -> \" << i << \" by \" << j << endl;\n\t\t\t\t\t\tque.push( t_node( i, (j==1 ? i : tn.ship), tn.time+cost[j][tn.pos][i], tn.delindex ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#include <algorithm>\nusing namespace std;\n\nint N, M, R;\n\nstruct Edge {\n  int x, y, t;\n  char type;  // S or L\n} edges[10000];\n\nint visitOrder[1000];\n\n// dpWater[i][j] is the min time to move from i to j by water.\nint dpWater[200][200];\n\n// dpLand[i][j] is the min time to move from i to j by land.\nint dpLand[200][200];\n\nvoid calculateDp() {\n  memset(dpWater, -1, sizeof(dpWater));\n  for (int i = 0; i < N; ++i) {\n    dpWater[i][i] = 0;\n  }\n  memset(dpLand, -1, sizeof(dpLand));\n  for (int i = 0; i < N; ++i) {\n    dpLand[i][i] = 0;\n  }\n  for (int i = 0; i < M; ++i) {\n    int a = edges[i].x;\n    int b = edges[i].y;\n    if (edges[i].type == 'L') {\n      if (dpLand[a][b] == -1 || dpLand[a][b] > edges[i].t) {\n        dpLand[a][b] = dpLand[b][a] = edges[i].t;\n        //printf(\"dpLand[%d][%d] = %d\\n\", a, b, dpLand[a][b]);\n      }\n    } else {\n      if (dpWater[a][b] == -1 || dpWater[a][b] > edges[i].t) {\n        dpWater[a][b] = dpWater[b][a] = edges[i].t;\n        //printf(\"dpWater[%d][%d] = %d\\n\", a, b, dpWater[a][b]);\n      }\n    }\n  }\n  // Flood.\n  for (int k = 0; k < N; ++k) {\n    for (int i = 0; i < N; ++i) {\n      for (int j = i + 1; j < N; ++j) {\n        if (k == i || k == j) {\n          continue;\n        }\n        if (dpLand[i][k] != -1 && dpLand[k][j] != -1) {\n          int t = dpLand[i][k] + dpLand[k][j];\n          if (dpLand[i][j] == -1 || dpLand[i][j] > t) {\n            dpLand[i][j] = dpLand[j][i] = t;\n          }\n        }\n        if (dpWater[i][k] != -1 && dpWater[k][j] != -1) {\n          int t = dpWater[i][k] + dpWater[k][j];\n          if (dpWater[i][j] == -1 || dpWater[i][j] > t) {\n            dpWater[i][j] = dpWater[j][i] = t;\n          }\n        }\n      }\n    }\n  }\n  /*\n  for (int i = 0; i < N; ++i) {\n    for (int j = i; j < N; ++j) {\n      printf(\"dpLand[%d][%d] = %d\\n\", i, j, dpLand[i][j]);\n    }\n  }\n  for (int i = 0; i < N; ++i) {\n    for (int j = i; j < N; ++j) {\n      printf(\"dpWater[%d][%d] = %d\\n\", i, j, dpWater[i][j]);\n    }\n  }\n  */\n}\n\nint getMinTime() {\n  calculateDp();\n  int dp[2][200];\n  memset(dp, -1, sizeof(dp));\n  dp[0][visitOrder[0]] = 0;\n  int *prev = dp[0];\n  int *cur = dp[1];\n  int source = visitOrder[0];\n  for (int i = 1; i < R; ++i) {\n    //printf(\"i = %d\\n\", i);\n    int target = visitOrder[i];\n    if (source == target) {\n      continue;\n    }\n    memset(cur, -1, sizeof(dp[0]));\n    for (int targetWater = 0; targetWater < N; ++targetWater) {\n      for (int sourceWater = 0; sourceWater < N; ++sourceWater) {\n        //printf(\"i = %d, source = %d, target = %d, sourceWater = %d, targetWater = %d\\n\",\n        //        i, source, target, sourceWater, targetWater);\n        if (prev[sourceWater] == -1) {\n          continue;\n        }\n        if (prev[sourceWater] == -1 || dpLand[source][sourceWater] == -1 ||\n            dpWater[sourceWater][targetWater] == -1 || dpLand[targetWater][target] == -1) {\n          continue;\n        }\n        int t = prev[sourceWater] + dpLand[source][sourceWater] +\n                dpWater[sourceWater][targetWater] + dpLand[targetWater][target];\n        if (cur[targetWater] == -1 || cur[targetWater] > t) {\n          cur[targetWater] = t;\n          //printf(\"cur[%d] = %d\\n\", targetWater, t);\n        }\n      }\n    }\n    swap(prev, cur);\n    source = target;\n  }\n  int result = -1;\n  for (int i = 0; i < N; ++i) {\n    if (prev[i] != -1 && (result == -1 || result > prev[i])) {\n      result = prev[i];\n    }\n  }\n  return result;\n}\n\nint main() {\n  //freopen(\"MrRitoPostOffice.in\", \"r\", stdin);\n  //freopen(\"2200-input.txt\", \"r\", stdin);\n  while (scanf(\"%d%d\", &N, &M) == 2 && !(N == 0 && M == 0)) {\n    for (int i = 0; i < M; ++i) {\n      char buf[10];\n      scanf(\"%d%d%d%s\", &edges[i].x, &edges[i].y, &edges[i].t, buf);\n      edges[i].x--;\n      edges[i].y--;\n      edges[i].type = buf[0];\n      //printf(\"edge %d, x %d, y %d, t %d, type %c\\n\", i, edges[i].x, edges[i].y, edges[i].t, edges[i].type);\n    }\n    scanf(\"%d\", &R);\n    for (int i = 0; i < R; ++i) {\n      scanf(\"%d\", &visitOrder[i]);\n      visitOrder[i]--;\n    }\n    int result = getMinTime();\n    printf(\"%d\\n\", result);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 214748360012345\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to;\n  long cost;\n  char type;\n};\n\ntypedef pair<long, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(d=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<long> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(e.type=='L' && !(uf.same(nxtp, route[i+1]) || uf.same(nxtp, route[i]))) continue;\n          long nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    long res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i, a, b) for (int i = (a); i < int(b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\nusing Weight = int;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n};\nusing Graph = vector<vector<Edge>>;\n\nvoid add_bidirectional_edge(Graph& graph, int src, int dst, int weight) {\n    graph[src].push_back((Edge){src, dst, weight});\n    graph[dst].push_back((Edge){dst, src, weight});\n}\n\n// Verified: AOJ 2251 (Merry Christmas)\nvector<vector<Weight>> warshall_floyd(Graph graph) {\n    static const Weight inf = numeric_limits<Weight>::max() / 20;\n    vector<vector<Weight>> dist(graph.size(), vector<Weight>(graph.size(), inf));\n    REP(u, graph.size()) dist[u][u] = 0;\n    REP(u, graph.size()) for (auto& e : graph[u]) dist[e.src][e.dst] = e.weight;\n    REP(w, graph.size()) REP(u, graph.size()) REP(v, graph.size())\n        dist[u][v] = min(dist[u][v], dist[u][w] + dist[w][v]);\n    return dist;\n}\n\nint main() {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n\n    int N, M;\n    while (cin>>N>>M, N|M) {\n        Graph land(N), sea(N);\n        REP(i, M) {\n            int x, y, t; char sl;\n            cin >> x >> y >> t >> sl;\n            --x; --y;\n            if (sl == 'L')\n                add_bidirectional_edge(land, x, y, t);\n            else\n                add_bidirectional_edge(sea, x, y, t);\n        }\n        int R; cin >> R;\n        vector<int> order(R);\n        REP(i, R) {\n            cin >> order[i];\n            --order[i];\n        }\n\n        if (R == 1) {\n            cout << \"0\\n\";\n            continue;\n        }\n\n        auto dist_land = warshall_floyd(land);\n        auto dist_sea  = warshall_floyd(sea);\n\n        vector<vector<int>> dp(2, vector<int>(N, 1e8));\n        dp[1][0] = 0;\n        REP(i, R-1) {\n            int curr = i%2, prev = 1-i%2;\n            int u = order[i], v = order[i+1];\n            REP(q, N) {\n                int value = 1e8;\n                REP(p, N) {\n                    if (p == q)\n                        value = min(value, dp[prev][p] + dist_land[u][v]);\n                    else\n                        value = min(value, dp[prev][p] + dist_land[u][p] + dist_sea[p][q] + dist_land[q][v]);\n                }\n                dp[curr][q] = value;\n            }\n        }\n        cout << *min_element(dp[(R-2)%2].begin(), dp[(R-2)%2].end()) << '\\n';\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 240\n#define MAX_R 1200\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_N];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nint main() {\n\twhile (true) {\n\t\tcin >> N >> M;\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A2, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nenum\n{\n    MAX_V = 300 + 10, MAX_Z = 2000 + 50\n};\n\nconst int INF = 2000000000;\nint dp[MAX_Z][MAX_V], SG[MAX_V][MAX_V], LG[MAX_V][MAX_V];\nint rt[MAX_Z], rtl;\nint n, m;\n\nvoid floyd()\n{\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = min(SG[i][j], SG[i][k] + SG[k][j]);\n    for(int k = 1; k <= n; k++)\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                LG[i][j] = min(LG[i][j], LG[i][k] + LG[k][j]);\n    for(int i = 1; i <= n; i++)\n        LG[i][i] = SG[i][i] = 0;\n}\n\nint main()\n{\n    while(~scanf(\"%d%d\", &n, &m), n+m)\n    {\n        for(int i = 1; i <= n; i++)\n            for(int j = 1; j <= n; j++)\n                SG[i][j] = LG[i][j] = INF;\n        for(int i = 0; i < m; i++)\n        {\n            int x, y, cs;\n            char tp;\n            scanf(\"%d %d %d %c\", &x, &y, &cs, &tp);\n            if(tp == 'S')\n            {\n                SG[x][y] = min(SG[x][y], cs);\n                SG[y][x] = min(SG[y][x], cs);\n            }\n            else\n            {\n                LG[x][y] = min(LG[x][y], cs);\n                LG[y][x] = min(LG[y][x], cs);\n            }\n        }\n        scanf(\"%d\", &rtl);\n        for(int i = 1; i <= rtl; i++)\n            scanf(\"%d\", &rt[i]);\n\n        floyd();\n        for(int i = 1; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                dp[i][j] = INF;\n\n        dp[1][rt[1]] = 0;\n        for(int i = 2; i <= rtl; i++)\n            for(int j = 1; j <= n; j++)\n                for(int k = 1; k <= n; k++)\n                {\n                    if(j != k)\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[k][rt[i - 1]] + SG[k][j] + LG[j][rt[i]]);\n                    else\n                        dp[i][j] = min(dp[i][j], dp[i - 1][k] + LG[rt[i-1]][rt[i]]);\n                }\n\n        long long ans = *min_element(dp[rtl] + 1, dp[rtl] + n + 1);\n        if(ans == INF);\n        else printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e6\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <string.h>\nusing namespace std;\n#define N 200\n#define M 10000\n#define R 1000\n#define INF 1000000\n\nint main(){\n  while(1){\n    int n,m,r;\n    int sea[N][N];\n    int land[N][N];\n    int dp[R][N];\n    int z[R];\n\n    scanf(\"%d%d\",&n,&m);\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        if(i==j){\n          sea[i][j] = 0;\n          land[i][j] = 0;\n        }else{\n          sea[i][j] = INF;\n          land[i][j] = INF;\n        }\n      }\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char s;\n      scanf(\"%d %d %d %c\",&x,&y,&t,&s);\n      if(s=='S'){\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }else{\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      }\n    }\n    scanf(\"%d\",&r);\n    for(int i=0;i<r;i++){\n      scanf(\"%d\",&z[i]);\n      z[i]--;\n    }\n\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          sea[i][j] = min(sea[i][j],sea[i][k]+sea[k][j]);\n          land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n\n    for(int i=0;i<r;i++){\n      for(int j=0;j<n;j++){\n        dp[i][j] = INF;\n      }\n    }\n    dp[0][z[0]] = 0;\n/*\n    for(int i=0;i<n;i++){\n      dp[0][i] = sea[z[0]][i] + land[i][z[0]];\n      for(int j=1;j<r;j++){\n        dp[j][i] = INF;\n      }\n    }\n    */\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n        for(int k=0;k<n;k++){\n          dp[i][j] = min(\n            dp[i][j],\n            dp[i-1][k]+land[z[i-1]][k]+sea[k][j]+land[j][z[i]] );\n        }\n      }\n    }\n    int ans = INF;\n    for(int i=0;i<n;i++){\n      ans = min(ans,dp[r-1][i]);\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \"<<a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n#define fr first\n#define sc second\n \ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\n \ntypedef long long int64;\nconst int INF = 1 << 28;\n\nvoid Floyd_Warshall(vector< vector< int > >& graph){\n  for(int k = 0; k < graph.size(); k++){\n    for(int i = 0; i < graph.size(); i++){\n      for(int j = 0; j < graph.size(); j++){\n        graph[i][j] = min( graph[i][j], graph[i][k] + graph[k][j]);\n      }\n    }\n  }\n  return ;\n}\n\nint main(){\n  int N, M, R, z[1001];\n  vector< vector< int > > Road_graph, Sea_graph;\n  int dp[1001][200];\n\n  while(cin >> N >> M, N){\n    \n    Road_graph = vector< vector< int > >( N, vector< int >( N, INF));\n    Sea_graph  = vector< vector< int > >( N, vector< int >( N, INF));\n    for(int i = 0; i < N; i++){\n      Road_graph[i][i] = Sea_graph[i][i] = 0;\n    }\n\n    for(int i = 0; i < M; i++){\n      int x, y, t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      --x, --y;\n      if(sl == 'L') Road_graph[x][y] = Road_graph[y][x] = t;\n      else          Sea_graph [x][y] = Sea_graph [y][x] = t;\n    }\n    cin >> R;\n    z[0] = 0;\n    for(int i = 1; i <= R; i++){\n      cin >> z[i];\n      z[i]--;\n    }\n\n    Floyd_Warshall(Road_graph);\n    Floyd_Warshall( Sea_graph);\n\n    //dp[idx][船の場所]\n    fill_n( *dp, 1001 * 200, INF);\n    dp[z[0]][0] = 0;\n    for(int i = 0; i < R; i++){\n      for(int j = 0; j < N; j++){ //船の場所\n        if(dp[i][j] == INF) continue;\n        dp[i + 1][j] = min( dp[i + 1][j], dp[i][j] + Road_graph[z[i]][z[i + 1]]);\n        for(int k = 0; k < N; k++){\n          int Cost = Road_graph[z[i]][j] + Sea_graph[j][k] + Road_graph[k][z[i + 1]];\n          if(Cost > INF) continue;\n          dp[i + 1][k] = min( dp[i + 1][k], dp[i][j] + Cost);\n        }\n      }\n    }\n    int ret = INF;\n    for(int i = 0; i < N; i++){\n      ret = min( ret, dp[R][i]);\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint const MAX_R = 1010;\nint const MAX_N = 210;\nint const INF = 1<<29;\n\nint dl[MAX_N][MAX_N];\nint ds[MAX_N][MAX_N];\nlong long dp[MAX_R][MAX_N];\nint z[MAX_R];\nint N, M, R;\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      for(int j=i+1; j<N; j++) {\n        dl[i][j] = dl[j][i] = INF;\n        ds[i][j] = ds[j][i] = INF;\n      }\n      dl[i][i] = dl[i][i] = ds[i][i] = ds[i][i] = 0;\n    }\n    for(int i=0; i<M; i++) {\n      int x, y, t; char sl;\n      cin >> x >> y >> t >> sl; x--, y--;\n      if(sl == 'L') {\n        dl[x][y] = dl[y][x] = t;\n      }\n      else {\n        ds[x][y] = ds[y][x] = t;\n      }\n    }\n    \n    for(int k=0; k<N; k++)\n      for(int i=0; i<N; i++)\n        for(int j=0; j<N; j++) {\n          dl[i][j] = min(dl[i][j], dl[i][k]+dl[k][j]);\n          ds[i][j] = min(ds[i][j], ds[i][k]+ds[k][j]);\n        }\n    \n    cin >> R;\n    for(int i=0; i<R; i++) { cin >> z[i]; z[i]--; }\n    \n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    \n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++) {\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s]+dl[z[i-1]][s]+ds[s][t]+dl[t][z[i]]);\n        }\n      }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define i_i pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< i_i >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nint n, m;\nint walk[200][200], swim[200][200];\nint dp[1000][200];\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    cin >> n >> m;\n    while (n || m) {\n        rep(i, 200) rep(j, 200) walk[i][j] = swim[i][j] = INF;\n        rep(i, m) {\n            int3(x, y, t);\n            string st;\n            cin >> st;\n            if (st[0] == 'L') {\n                walk[y-1][x-1] = walk[x-1][y-1] = min(walk[x-1][y-1], t);\n            } else {\n                swim[y-1][x-1] = swim[x-1][y-1] = min(swim[x-1][y-1], t);\n            }\n        }\n        Int(r);\n        vector<int> data(r);\n        for (int i = 0; i < r; i++) {\n            cin >> data[i];\n            data[i]--;\n        }\n\n        rep(i, n) { walk[i][i] = 0; swim[i][i] = 0; }\n        rep(k, n) rep(i, n) rep(j, n) {\n            walk[i][j] = min(walk[i][j], walk[i][k] + walk[k][j]);\n            swim[i][j] = min(swim[i][j], swim[i][k] + swim[k][j]);\n        }\n/*\n        rep(i, n) { \n            rep(j, n) { \n                if (walk[i][j] == INF) cout << -1 << \" \";\n                else cout << walk[i][j] << \" \";\n            }\n            cout << endl;\n        }\n\n        rep(i, n) { \n            rep(j, n) { \n                if (walk[i][j] == INF) cout << -1 << \" \";\n                else cout << walk[i][j] << \" \";\n            }\n            cout << endl;\n        }\n*/\n        rep(i, 1000) rep(j, 200) dp[i][j] = INF;\n        dp[0][data[0]] = 0;\n\n        rep(i, r-1) rep(j, n) rep(k, n) {\n            dp[i+1][k] = min(dp[i+1][k], dp[i][j] + walk[data[i]][j]\n                    + swim[j][k] + walk[k][data[i+1]]);\n        }\n\n        int ans = INF;\n        rep(i, 200) ans = min(ans, dp[r-1][i]);\n        cout << ans << endl;\n        cin >> n >> m;\n    }\n    return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nstruct WarshallFloyd {\n\tconst int V;\n\t// オーバーフロー注意\n    const T INF = numeric_limits<T>::max() / 3;\n    vector<vector<T>> d;\n\tWarshallFloyd(const int V) :\n\t\tV(V),\n\t\td(vector<vector<T>>(V, vector<T>(V, INF)))\n\t\t{}\n\tbool addEdge(int from, int to, T cost) {\n\t\tif(cost >= d[from][to]) return false;\n\t\td[from][to] = cost;\n\t\treturn true;\n\t}\n\tvoid build() {\n\t\tfor(int i=0; i < V; ++i) {               // 経由点 i\n\t\t\tfor(int j = 0; j < V; ++j) {         // 始点 j\n\t\t\t\tfor(int k = 0; k < V; ++k) {     // 終点 k\n\t\t\t\t\td[j][k] = min(d[j][k], d[j][i] + d[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tT dist(int from, int to) {\n\t\tif(d[from][to] >= INF) return INF;\n\t\treturn d[from][to];\n\t}\n\tvoid debug() {\n\t\tfor(int i = 0; i < V; ++i) {\n\t\t\tfor(int j = 0; j < V; ++j) {\n\t\t\t\tcout << d[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t}\n};\n\nvoid solve(int N, WarshallFloyd<int64_t> &wfL, WarshallFloyd<int64_t> &wfS, vector<int> &town) {\n\tconst int64_t INVALID = 1e15;\n\tint tn = town.size();\n\tvector<vector<int64_t>> dp(tn, vector<int64_t>(N, INVALID));\n\tdp[0][town[0]] = 0;\n\tfor(int i = 1; i < tn; ++i) {\n\t\tfor(int j = 0; j < N; ++j) {\n\t\t\tif(wfL.dist(town[i - 1], town[i]) < INVALID) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][j] + wfL.dist(town[i - 1], town[i]));\n\t\t\t}\n\t\t\tfor(int k = 0; k < N; ++k) {\n\t\t\t\tif(dp[i - 1][k] >= INVALID) continue;\n\t\t\t\tif(wfL.dist(town[i - 1], k) >= INVALID) continue;\n\t\t\t\tif(wfS.dist(k, j) >= INVALID) continue;\n\t\t\t\tif(wfL.dist(j, town[i]) >= INVALID) continue;\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i - 1][k] + wfL.dist(town[i - 1], k) + wfS.dist(k, j) + wfL.dist(j, town[i]));\n\t\t\t}\n\t\t}\n\t}\n\tint64_t ans = 1e15;\n\tfor(int i = 0; i < N; ++i) {\n\t\tif(dp[tn - 1][i] >= INVALID) continue;\n\t\tans = min(ans, dp[tn - 1][i]);\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M and N > 0) {\n\t\tWarshallFloyd<int64_t> wfL(N), wfS(N);\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\twfL.addEdge(i, i, 0);\n\t\t\twfS.addEdge(i, i, 0);\n\t\t}\n\t\twhile(M--) {\n\t\t\tint x, y, t; cin >> x >> y >> t;\n\t\t\tx--; y--;\n\t\t\tchar sl; cin >> sl;\n\t\t\tif(sl == 'L') {\n\t\t\t\twfL.addEdge(x, y, t);\n\t\t\t\twfL.addEdge(y, x, t);\n\t\t\t}\n\t\t\tif(sl == 'S') {\n\t\t\t\twfS.addEdge(x, y, t);\n\t\t\t\twfS.addEdge(y, x, t);\n\t\t\t}\n\t\t}\n\t\tint R; cin >> R;\n\t\tvector<int> z(R);\n\t\tfor(int i = 0; i < R; ++i) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\twfL.build();\n\t\twfS.build();\n\t\tsolve(N, wfL, wfS, z);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <queue>\n\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define rrep(i,n) for(int i=(n)-1; i>=0; i--)\n#define all(X) (X).begin(),(X).end()\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\ntemplate<class A, size_t N, class T> void Fill(A (&a)[N], const T &v){ fill( (T*)a, (T*)(a+N), v ); }\n\nconst int INF = 0x3fffffff;\n\nstruct ST{\n\tint d, z, b, n;\n\t// priority_queue??¨  const???????????????\n\tbool operator< (const ST& a) const {\n\t\treturn (d > a.d);\n\t}\n};\n\nint N, M, R;\nvector<P> v[2][205];\nint Z[1005];\nint dp[205][205];\t\t// boat, n\nint ans[205];  // boat\n\nint solve(){\n\tpriority_queue<ST> que;\n\tint d, z, b, n;\n\t//dp[ Z[0] ][ Z[0] ] = 0;\n\tans[ Z[0] ] = 0;\n\trep(i,R-1){\n\t\trep(b,N) if( ans[b] < INF ){\n\t\t\tque.push( ST{ans[b], i, b, Z[i]} );\n\t\t}\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\twhile( !que.empty() ){\n\t\t\tST st = que.top();\n\t\t\tque.pop();\n\t\t\td = st.d;\n\t\t\tz = st.z;\n\t\t\tb = st.b;\n\t\t\tn = st.n;\n\t\t\tif( dp[b][n] < d ) continue;\n\t\t\tdp[b][n] = d;\n\t\t\t//cout << \"hit \" << d << \" \" << z << \" \" << b << \" \" << n << endl;\n\t\t\trep(k, 2) if( !k || b == n ){\n\t\t\t\tfor(auto _v: v[k][n]){\n\t\t\t\t\tint to = _v.first;\n\t\t\t\t\tint cost = _v.second;\n\t\t\t\t\tint nz = z, nb = b;\n\t\t\t\t\tif( to == Z[z+1] ) nz++;\n\t\t\t\t\tif( k ) nb = to;\n\t\t\t\t\tif( chmin( dp[nb][to], dp[b][n] + cost) ){\n\t\t\t\t\t\tif( nz == z ){\n\t\t\t\t\t\t\tque.push( ST{ dp[nb][to], nz, nb, to } );\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tchmin( ans[nb], dp[nb][to] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint ret = INF;\n\trep(b,N){\n\t\tchmin( ret, ans[b] );\n\t}\n\treturn ret;\n}\n\nint main(){\n\tint x, y, t;\n\tchar sl;\n\n\twhile(cin >> N >> M, N|M){\n\t\trep(i,2) rep(j,205) v[i][j].clear();\n\t\tFill( dp, INF );\n\t\tFill( ans, INF );\n\t\trep(i,M){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif( sl == 'L' ){\n\t\t\t\tv[0][x].emplace_back( y, t );\n\t\t\t\tv[0][y].emplace_back( x, t );\n\t\t\t}else{\n\t\t\t\tv[1][x].emplace_back( y, t );\n\t\t\t\tv[1][y].emplace_back( x, t );\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\trep(i,R){\n\t\t\tcin >> Z[i];\n\t\t\tZ[i]--;\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <iomanip>\n#include <bitset>\nusing namespace std;\n#define INF\t1000000000000\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define sz(x) ((int)(x).size())\n#define SORT(x) sort((x).begin(), (x).end())\n#define RSORT(x) sort((x).begin(), (x).end(), greater<int>() )\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n, m, r;\nll land[200][200], sea[200][200], dp[1000][200];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\twhile(cin >> n >> m){\n\t\tif(n == 0 && m == 0) break;\n\t\tint x,y,t; char sl;\n\t\trep(i,n) rep(j,n){ land[i][j] = INF; sea[i][j] = INF; }\n\t\trep(i,n){ land[i][i] = 0; sea[i][i] = 0;}\n\t\trep(i,m){\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif(sl == 'L'){\n\t\t\t\tif(land[x][y] > t){ land[x][y] = t; land[y][x] = t; }\n\t\t\t} else{\n\t\t\t\tif(sea[x][y] > t){ sea[x][y] = t; sea[y][x] = t; }\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tVi z(r);\n\t\trep(i,r){\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\trep(i,r) rep(j,n) dp[i][j] = INF;\n\t\t\n\t\trep(k,n) rep(i,n) rep(j,n){\n\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t}\n\t\t\n\t\tdp[1][z[0]] = land[z[0]][z[1]];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tif(i == j) continue;\n\t\t\t\t//cout << i << \" \" << j << \" \" << land[z[0]][i]+sea[i][j]+land[j][z[1]] << endl;\n\t\t\t\tdp[1][j] = min(dp[1][j],land[z[0]][i]+sea[i][j]+land[j][z[1]]);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 2; i < r; i++){\n\t\t\trep(j,n) dp[i][j] = min(dp[i][j],dp[i-1][z[i-1]]+land[z[i-1]][z[i]]);\n\t\t\trep(j,n){\n\t\t\t\trep(k,n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k], dp[i-1][j]+land[z[i-1]][j]+sea[j][k]+land[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i < n; i++){\n\t\t\trep(j,n){\n\t\t\t\tcout << dp[i][j] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\tcout << *min_element(dp[n-1], dp[n-1]+n) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define INF 0x3f3f3f3f \nll a1[205][205],a2[205][205];\nll dp[1005][205];\nint t[1005];\n\nvoid init(int n){\n\tfor(int i=0;i<=n;++i){\n\t\tfor(int j=0;j<=n;++j){\n\t\t\ta1[i][j] = (i==j? 0 : INF);\n\t\t\ta2[i][j] = a1[i][j];\n\t\t\tdp[i][j] = INF;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n,m;\n\twhile(cin>>n>>m && (n||m)){\n\t\tinit(n);\n\t\tint u,v,d;\n\t\tchar f[2];\n\t\tfor(int i=1;i<=m;++i){\n\t\t\tscanf(\"%d%d%d%s\",&u,&v,&d,f);\n\t\t\tif(f[0]=='L'){\n\t\t\t\ta1[u][v] = min(a1[u][v],1LL*d);\n\t\t\t\ta1[v][u] = min(a1[v][u],1LL*d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta2[u][v] = min(a2[u][v],1LL*d);\n\t\t\t\ta2[v][u] = min(a2[v][u],1LL*d);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 1;k<=n;k++){\n        for(int i = 1;i<=n;i++){\n            for(int j = 1;j<=n;j++){\n                a1[i][j] = min(a1[i][j],a1[i][k] + a1[k][j]);\n            }}}\n\t\tfor(int k = 1;k<=n;k++){\n        for(int i = 1;i<=n;i++){\n            for(int j = 1;j<=n;j++){\n                a2[i][j] = min(a2[i][j],a2[i][k] + a2[k][j]);\n            }}}\n            \n        dp[1][1]=0;\n        int r;\n        cin>>r;\n        for(int i=1;i<=r;++i)scanf(\"%d\",&t[i]);\n        for(int i=1;i<=r;++i){\n        \tfor(int j=1;j<=n;++j){\n        \t\tdp[i][j] = min(dp[i][j],dp[i-1][j]+a1[t[i-1]][t[i]]);\n        \t\tfor(int k=1;k<=n;++k){\n        \t\t\tdp[i][k] = min(dp[i][k],dp[i-1][j]+a1[t[i-1]][j]+a2[j][k]+a1[k][t[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tll ans = INF;\n\t\tfor(int i=1;i<=n;++i)ans = min(ans,dp[r][i]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <cstring>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reps(i,s,n) for(int i=s; i<n; i++)\n#define all(x) x.begin(), x.end()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\nconst int INF = 1<<30;\n\nint cost[3][210][210];\nbool used[210][210][1010];\n\nstruct t_node {\n\tint pos;\n\tint ship;\n\tint time;\n\tint delindex;\n\tt_node(int p, int s, int t, int d) {\n\t\tpos = p;\n\t\tship = s;\n\t\ttime = t;\n\t\tdelindex = d;\n\t}\n};\nbool operator<( const t_node& lhs, const t_node &rhs ) {\n\treturn lhs.time > rhs.time;\n}\n\nint main() {\n\tint n, m;\n\twhile( cin >> n >> m, n||m ) {\n\t\tmemset( used, 0, sizeof(used) );\n\t\trep(i,2) rep(j,201) rep(k,201) cost[i][j][k] = INF;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tint s = (sl=='L' ? 0 : 1);\n\t\t\tcost[s][x][y] = cost[s][y][x] = t;\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> deliver(r);\n\t\trep(i, r) {\n\t\t\tcin >> deliver[i];\n\t\t}\n\t\tpriority_queue<t_node> que;\n\t\tque.push( t_node(1, 1, 0, 0) );\n\t\twhile( !que.empty() ) {\n\t\t\tt_node tn = que.top();\n\t\t\tque.pop();\n\t\t\tif( used[tn.pos][tn.ship][tn.delindex] ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused[tn.pos][tn.ship][tn.delindex] = true;\n\t\t\tif( deliver[tn.delindex] == tn.pos ) {\n\t\t\t\ttn.delindex++;\n\t\t\t\tif( tn.delindex == r ) {\n\t\t\t\t\tcout << tn.time << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(j, (tn.pos==tn.ship ? 2 : 1)) {\n\t\t\t\trep(i, n+1) {\n\t\t\t\t\tif( cost[j][tn.pos][i] < INF ) {\n\t\t\t\t\t\tque.push( t_node( i, (j==1 ? i : tn.ship), tn.time+cost[j][tn.pos][i], tn.delindex ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nLL dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\n\twhile (cin >> n >> m&&n&&m) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tREP(i, 201)REP(j, 201)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tLL ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <string.h>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint main(){\n\t\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tlong long int CL[300][300], CS[300][300];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tCL[i][j] = INF;\n\t\t\t\tCS[i][j] = INF;\n\t\t\t}\n\t\t\tCL[i][i] = 0;\n\t\t\tCS[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u, v, cost;\n\t\t\tcin >> u >> v >> cost;\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tif(str == \"L\"){\n\t\t\t\tCL[u][v] = cost;\n\t\t\t\tCL[v][u] = cost;\n\t\t\t}else{\n\t\t\t\tCS[u][v] = cost;\n\t\t\t\tCS[v][u] = cost;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = 0; j < n; j++)\n\t\tfor(int k = 0; k < n; k++){\n\t\t\tCL[i][j] = min(CL[i][j], CL[i][k] + CL[k][j]);\n\t\t\tCS[i][j] = min(CS[i][j], CS[i][k] + CS[k][j]);\n\t\t}\n\t\t\n\t\tint R, pre, num;\n\t\tcin >> R;\n\t\tcin >> pre;\n\t\tpre--;\n\t\t\n\t\tlong long int ans = INF, DP1[300] = {}, DP2[300];\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tDP1[i] = INF;\n\t\t}\n\t\tfor(int i = 1; i < R; i++){\n\t\t\tcin >> num;\n\t\t\tnum--;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tDP2[j] = DP1[j] + CL[pre][num];\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tDP2[j] = min(DP2[j], CL[pre][k] + DP1[k] + CS[k][j] + CL[j][num]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(DP1, DP2);\n\t\t\tpre = num;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans = min(ans, DP1[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 1000000000000LL\ntypedef long long ll;\nll d[200][200];\nll se[200][200];\nll dp[2][200];\nint z[1000];\nll min(ll a,ll b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++)for(j=0;j<n;j++){\n\t\td[i][j]=INF;\n\t\tse[i][j]=INF;\n\t\tif(i==j){\n\t\t\td[i][j]=0;\n\t\t\tse[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b;\n\t\tll c;\n\t\tchar p;\n\t\tscanf(\"%d %d %lld %c\",&a,&b,&c,&p);\n\t\ta--;b--;\n\t\tif(p=='L'){\n\t\t\td[a][b]=min(d[a][b],c);\n\t\t\td[b][a]=min(d[b][a],c);\n\t\t}\n\t\tif(p=='S'){\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\td[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\t\tse[i][j]=min(se[i][j],se[i][k]+se[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tint p;\n\tscanf(\"%d\",&p);\n\tfor(i=0;i<p;i++){\n\t\tscanf(\"%d\",&z[i]);\n\t\tz[i]--;\n\t}\n\tfor(i=0;i<n;i++)dp[0][i]=INF;\n\tdp[0][z[0]]=0;\n\tfor(i=1;i<p;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tdp[i%2][j]=INF;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][k]+d[z[i-1]][k]+se[k][j]+d[j][z[i]]);\n\t\t\t}\n\t\t}\n\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+d[z[i-1]][z[i]]);\n\t}\n\tll ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(p+1)%2][i]);\n\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <iterator>\n#include <queue>\n#include <utility>\n\nusing namespace std;\n\n#define MN 200\n#define MR 1000\n#define INF 0x7F7F7F7F\n#define FILL_INF(xs) memset(xs, 0x7F, sizeof(xs))\n\nint N, M, R;\nint L[MN][MN];\nint S[MN][MN];\nint Z[MR];\n\nbool input() {\n    cin >> N >> M;\n    if (N == 0 && M == 0) return false;\n    FILL_INF(L);\n    FILL_INF(S);\n    for (int i = 0; i < M; i++) {\n        int x, y, t; char sl;\n        cin >> x >> y >> t >> sl;\n        x--; y--;\n        if (sl == 'L') L[x][y] = L[y][x] = t;\n        else           S[x][y] = S[y][x] = t;\n    }\n    cin >> R;\n    for (int i = 0; i < R; i++) {\n        cin >> Z[i];\n        Z[i]--;\n    }\n    return true;\n}\n\n\nvoid WarshallFloyd(int G[MN][MN]) {\n    for (int i = 0; i < N; i++) G[i][i] = 0;\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (G[i][k] == INF || G[k][j] == INF) continue;\n                G[i][j] = min(G[i][j], G[i][k] + G[k][j]);\n            }\n        }\n    }\n}\n\nint Cache[MR][MN];\nint dfs(int zindex, int ship) {\n    if (zindex == R) return 0;\n    if (Cache[zindex][ship] >= 0) return Cache[zindex][ship];\n    int next = Z[zindex];\n    int prev = Z[zindex - 1];\n    int Ans = INF;\n    if (L[prev][next] != INF)\n        Ans = min(Ans, L[prev][next] + dfs(zindex + 1, ship));\n    for (int i = 0; i < N; i++) {\n        if (L[prev][ship] == INF || S[ship][i] == INF || L[i][next] == INF) continue;\n        Ans = min(Ans, L[prev][ship] + S[ship][i] + L[i][next] + dfs(zindex + 1, i));\n    }\n    return Cache[zindex][ship] = Ans;\n}\n\nint main() {\n    while (input()) {\n        WarshallFloyd(L);\n        WarshallFloyd(S);\n        memset(Cache, -1, sizeof(Cache));\n        cout << dfs(1, Z[0]) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2200 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2200)\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<limits>\n#define rep(i,a) for(int i=0;i<(a);++i)\n\nconst int MAX_N = 200, MAX_R = 1000, INF = std::numeric_limits<int>::max()>>4;\n\nint N, M, R;\nint land[MAX_N][MAX_N], sea[MAX_N][MAX_N];\nint dp[MAX_R+1][MAX_N];\nint z[MAX_N];\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &N, &M ), N|M )\n\t{\n\t\trep( i, N ) rep( j, N )\n\t\t\tland[i][j] = sea[i][j] = i==j?0:INF;\n\n\t\trep( i, M )\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl[2];\n\n\t\t\tscanf( \"%d%d%d%s\", &x, &y, &t, sl );\n\t\t\t--x; --y;\n\n\t\t\tauto mat = *sl=='L'?land:sea;\n\t\t\tmat[x][y] = mat[y][x] = std::min( mat[x][y], t );\n\t\t}\n\n\t\tscanf( \"%d\", &R );\n\t\trep( i, R )\n\t\t\tscanf( \"%d\", z+i ), --z[i];\n\n\t\trep( k, N ) rep( i, N ) rep( j, N )\n\t\t{\n\t\t\tland[i][j] = std::min( land[i][j], land[i][k]+land[k][j] );\n\t\t\tsea[i][j] = std::min( sea[i][j], sea[i][k]+sea[k][j] );\n\t\t}\n\n\t\trep( i, R+1 ) rep( j, N+1 )\n\t\t\tdp[i][j] = INF;\n\t\t\n\t\tdp[0][z[0]] = 0;\n\t\trep( i, R-1 ) rep( j, N ) rep( k, N )\n\t\t{\n\t\t\tif( j != k )\n\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][k]+land[z[i]][k]+sea[k][j]+land[j][z[i+1]] );\n\t\t\telse\n\t\t\t\tdp[i+1][j] = std::min( dp[i+1][j], dp[i][j]+land[z[i]][z[i+1]] );\n\t\t}\n\n\t\tprintf( \"%d\\n\", *std::min_element( dp[R-1], dp[R-1]+N ) );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll sd[222][222];\nll ld[222][222];\nll dp[1111][222];\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n|m){\n\t\t\n\t\tREP(i,222){\n\t\t\tREP(j,222){\n\t\t\t\tsd[i][j] = LLINF;\n\t\t\t\tld[i][j] = LLINF;\n\t\t\t}\n\t\t\tREP(j,1111)dp[j][i] = LLINF;\n\t\t}\n\t\t\n\t\tREP(i,222){\n\t\t\tsd[i][i] = 0;\n\t\t\tld[i][i] = 0;\n\t\t}\n\t\t\n\t\tREP(i,m){\n\t\t\tll a,b,c;char d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;b--;\n\t\t\tif(d == 'S'){\n\t\t\t\tsd[a][b] = min(sd[a][b],c);\n\t\t\t\tsd[b][a] = min(sd[b][a],c);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld[a][b] = min(ld[a][b],c);\n\t\t\t\tld[b][a] = min(ld[b][a],c);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll r;cin >> r;\n\t\tvector<ll> v(r);REP(i,r)cin >> v[i],v[i]--;\n\t\t\n\t\tREP(k,222)REP(i,222)REP(j,222){\n\t\t\tsd[i][j] = min(sd[i][j],sd[i][k]+sd[k][j]);\n\t\t\tld[i][j] = min(ld[i][j],ld[i][k]+ld[k][j]);\n\t\t}\n\t\t\n\t\tdp[0][0] = 0;\n\t\t\n\t\tREP(i,r-1){\n\t\t\tREP(j,n){\n\t\t\t\tif(dp[i][j] != LLINF){\n\t\t\t\t\tdp[i+1][j] = min(dp[i+1][j],dp[i][j]+ld[v[i]][v[i+1]]);\n\t\t\t\t\tREP(k,n){\n\t\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k],dp[i][j]+ld[v[i]][j]+sd[j][k]+ld[k][v[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ans = LLINF;\n\t\tREP(i,n)ans = min(ans,dp[r-1][i]);\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdint.h>\n#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<functional>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nconst int INF = 100000000;\n//町,村の数\nint n;\n//道の数\nint m;\n//集配先の数\nint R;\n\n//集配順序\nint z[1003];\n\ntypedef pair<int,int> P;\ntypedef pair<pair<int,int>,pair<int,int> > PP;\n\nstruct edge\n{\n\tint to;\n\t//陸なら1\n\tint mode;\n\tint cost;\n\tedge(int to,int mode,int cost) {\n\t\tthis->to = to;\n\t\tthis->mode = mode;\n\t\tthis->cost = cost;\n\t}\n\n};\n\nvector<edge> G[207];\nint dist[203][203][1003];\n\nint dijkstra() {\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tfor (int j = 0; j < 203; j++)\n\t\t{\n\t\t\tfill(dist[i][j],dist[i][j]+1003,INF);\n\t\t}\n\t}\n\tpriority_queue<PP,vector<PP>, greater<PP> > que;\n\n\tdist[0][0][0]=0;\n\n\tque.push(PP(P(0,0),P(0,0)));\n\n\twhile (!que.empty())\n\t{\n\t\tPP pp = que.top(); que.pop();\n\n\t\tint cost = pp.first.first;\n\t\tint v=pp.first.second;\n\t\tint u=pp.second.first;\n\t\tint index = pp.second.second;\n\t\t\n\t\tif(index == R) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif(z[index] == v) {\n\t\t\tdist[v][u][index+1]=dist[v][u][index];\n\t\t\tindex++;\n\t\t}\n\n\t\t//printf(\"[debug] %d %d %d %d\\n\",cost,v,u,index);\n\t\tfor (int i = 0; i < G[v].size(); i++)\n\t\t{\n\t\t\tedge e = G[v][i];\n\t\t\t//printf(\"        %d %d %d\\n\",e.to,e.mode,e.cost);\n\n\t\t\t//船を使う\n\t\t\tif(u==v && e.mode == 0) {\n\t\t\t\t//printf(\"%d,%d\\n\",dist[e.to][e.to][index],dist[v][u][index]);\n\t\t\t\tif(dist[e.to][e.to][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][e.to][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][e.to][index],e.to),P(e.to,index)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(e.mode == 1) {\n\t\t\t\tif(dist[e.to][u][index] > dist[v][u][index] + e.cost) {\n\t\t\t\t\tdist[e.to][u][index] = dist[v][u][index] + e.cost;\n\t\t\t\t\tque.push(PP(P(dist[e.to][u][index],e.to),P(u,index)));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\n\tint ans=INF;\n\n\tfor (int i = 0; i < 203; i++)\n\t{\n\t\tans=min(ans,dist[z[R-1]][i][R-1]);\n\t} \n\n\treturn ans;\n\n\n}\n\n\nvoid solve() {\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tint x,y,t;\n\t\tchar c;\n\t\t//x-y はコスト t で c によって結ばれている\n\t\t\n\t\tcin>>x>>y>>t>>c;\n\t\tx--;\n\t\ty--;\n\t\t\n\t\tG[x].push_back(edge(y,c=='L',t));\n\t\tG[y].push_back(edge(x,c=='L',t));\n\t}\n\n\tcin>>R;\n\n\tfor (int i = 0; i < R; i++)\n\t{\n\t\tcin>>z[i];\n\t\tz[i]--;\n\t}\n\n\tcout<<dijkstra()<<endl;\n\n}\n\nint main() {\n\n\twhile (cin>>n>>m)\n\t{\n\t\tif(n+m==0) return 0;\n\t\tsolve();\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits\\stdc++.h\"\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PI;\nint distL[200][200];\nint distS[200][200];\nint dp[2][200];\nint z[1000];\nint main() {\n\tint N, M;\n\twhile (cin >> N >> M, N) {\n\t\tfill((int*)distL, (int*)(distL + 200), 1 << 25);\n\t\tfill((int*)distS, (int*)(distS + 200), 1 << 25);\n\t\tfor (int i = 0; i < N; i++) distL[i][i] = distS[i][i] = 0;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar sl[2];\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tx--; y--;\n\t\t\tif (sl[0] == 'L') {\n\t\t\t\tdistL[x][y] = distL[y][x] = min(distL[x][y], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdistS[x][y] = distS[y][x] = min(distS[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tdistL[i][j] = min(distL[i][j], distL[i][k] + distL[k][j]);\n\t\t\t\t\tdistS[i][j] = min(distS[i][j], distS[i][k] + distS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tfill((int*)dp, (int*)(dp + 2), 1 << 25);\n\t\tdp[0][z[0]] = 0;\n\t\tfor (int i = 1; i < R; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tif (j == k) dp[i % 2][k] = min(dp[i % 2][k], dp[(i - 1) % 2][j] + distL[z[i - 1]][z[i]]);\n\t\t\t\t\telse dp[i % 2][k] = min(dp[i % 2][k], dp[(i - 1) % 2][j] + distL[z[i - 1]][j] + distS[j][k] + distL[k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0; j < N; j++) dp[(i - 1) % 2][j] = 1 << 25;\n\t\t}\n\t\tint ans = 1 << 25;\n\t\tfor (int i = 0; i < N; i++) ans = min(ans, dp[(R - 1) % 2][i]);\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s); sin>>v; return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\n\nstruct node{\n    int index,boat,next,cost;\n    node(int index,int boat,int next,int cost):index(index),boat(boat),next(next),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\nstruct edge{\n\tint lcost,scost;\n\tedge(int lcost,int scost):lcost(lcost),scost(scost){}\n\tedge(){}\n};\nconst int MAX=INT_MAX/10;\nconst int NONE=-1;\n\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\ntypedef vector<vvi> vvvi;\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n|m){\n\t\tstatic edge graph[200][200];\n\t\tREP(i,n)REP(j,n){\n\t\t\tif(i==j){\n\t\t\t\tgraph[i][j]=edge(0,0);\n\t\t\t}else{\n\t\t\t\tgraph[i][j]=edge(MAX,MAX);\n\t\t\t}\n\t\t}\n        REP(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar sl;\n\t\t\tcin>>x>>y>>t>>sl;\n\t\t\tswitch(sl){\n\t\t\tcase 'S':\n\t\t\t\tgraph[x-1][y-1].scost=min(graph[x-1][y-1].scost,t);\n\t\t\t\tgraph[y-1][x-1].scost=min(graph[y-1][x-1].scost,t);\n\t\t\t\tbreak;\n\t\t\tcase 'L':\n\t\t\t\tgraph[x-1][y-1].lcost=min(graph[x-1][y-1].lcost,t);\n\t\t\t\tgraph[y-1][x-1].lcost=min(graph[y-1][x-1].lcost,t);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t\tbreak;\n\t\t\t}\n        }\n\t\tint r;\n\t\tcin>>r;\n\t\tvi order(r);\n\t\tREP(i,r){\n\t\t\tcin>>order[i];\n\t\t\torder[i]--;\n\t\t}\n\t\tREP(k,n)REP(i,n)REP(j,n){\n\t\t\tgraph[i][j].lcost=min(graph[i][j].lcost,graph[i][k].lcost+graph[k][j].lcost);\n\t\t\tgraph[i][j].scost=min(graph[i][j].scost,graph[i][k].scost+graph[k][j].scost);\n\t\t}\n\n\t\tstatic int dp[1001][200];\n\t\tREP(i,r+1){\n\t\t\tREP(j,n){\n\t\t\t\tdp[i][j]=MAX;\n\t\t\t}\n\t\t}\n\t\tdp[0][0]=0;\n\t\tfor(int post=-1;post<r-1;post++){\n\t\t\tREP(boat,n){\n\t\t\t\tif(post==-1){\n\t\t\t\t\tdp[post+1][0]=min(dp[post+1][0],graph[0][order[post+1]].lcost);\n\t\t\t\t\tREP(vial,n){\n\t\t\t\t\t\tREP(vias,n){\n\t\t\t\t\t\t\tif(vial==vias)continue;\n\t\t\t\t\t\t\tdp[post+1][vias]=min(dp[post+1][vias],graph[0][vial].lcost+graph[vial][vias].scost+graph[vias][order[post+1]].lcost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tdp[post+1][boat]=min(dp[post+1][boat],dp[post][boat]+graph[order[post]][order[post+1]].lcost);\n\t\t\t\t\tREP(vial,n){\n\t\t\t\t\t\tREP(vias,n){\n\t\t\t\t\t\t\tif(vial==vias)continue;\n\t\t\t\t\t\t\tdp[post+1][vias]=min(dp[post+1][vias],dp[post][vial]+graph[order[post]][vial].lcost+graph[vial][vias].scost+graph[vias][order[post+1]].lcost);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        \n\t\tint ans=MAX;\n\t\tREP(i,n){\n\t\t\tans=min(ans,dp[r-1][i]);\n\t\t}\n        cout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\"\\n\");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        //#define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nvoid solve(int N, int M) {\n    vector<vector<int>> gl(N, vector<int>(N, INF));\n    vector<vector<int>> gs(N, vector<int>(N, INF));\n    REP(i, M) {\n        int x, y, t;\n        char ls;\n        cin >> x >> y >> t >> ls;\n        x--, y--;\n        if (ls == 'L') {\n            gl[x][y] = gl[y][x] = t;\n        } else {\n            gs[x][y] = gs[y][x] = t;\n        }\n    }\n\n    REP(i, N) gl[i][i] = gs[i][i] = 0;\n    REP(i, N) REP(j, N) REP(k, N) chmin(gl[j][k], gl[j][i] + gl[i][k]);\n    REP(i, N) REP(j, N) REP(k, N) chmin(gs[j][k], gs[j][i] + gs[i][k]);\n\n    int R;\n    cin >> R;\n    vector<int> z(R);\n    REP(i, R) {\n        cin >> z[i];\n        z[i]--;\n    }\n\n    vector<vector<int>> dp(R, vector<int>(N, INF));\n    function<int(int,int)> rec = [&](int i, int s) {\n        auto& DP = dp[i][s];\n        if (DP != INF) return DP;\n        if (i == R - 1) return DP = 0LL;\n        \n        int ret = INF;\n        int land = gl[z[i]][z[i + 1]] + rec(i + 1, s);\n        chmin(ret, land);\n        REP(v, N) {\n            int sea = gl[z[i]][s] + gs[s][v] + gl[v][z[i + 1]];\n            //if (sea >= INF) continue;\n            sea += rec(i + 1, v);\n            chmin(ret, sea);\n        }\n        return DP = ret;\n    };\n    cout << rec(0, z[0]) << endl;\n}\nsigned main() {\n    while (1) {\n        int N, M;\n        cin >> N >> M;\n        if (N == 0 && M == 0) break;\n        solve(N, M);\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n,m,r,dr[200][200],ds[200][200],inf=4*1e8;\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\trep(i,n) rep(j,n) if(i!=j) dr[i][j]=inf,ds[i][j]=inf;\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tx--,y--;\n\t\t\tif(s=='L'){\n\t\t\t\tdr[x][y]=min(dr[x][y],t);\n\t\t\t\tdr[y][x]=min(dr[y][x],t);\n\t\t\t}else{\n\t\t\t\tds[x][y]=min(ds[x][y],t);\n\t\t\t\tds[y][x]=min(ds[y][x],t);\n\t\t\t}\n\t\t}\n\t\trep(i,n) rep(j,n) rep(k,n) dr[j][k]=min(dr[j][k],dr[j][i]+dr[i][k]);\n\t\trep(i,n) rep(j,n) rep(k,n) ds[j][k]=min(ds[j][k],ds[j][i]+ds[i][k]);\n\t\tcin>>r;\n\t\tint ans[200],nans[200];\n\t\trep(i,n) ans[i]=inf,nans[i]=inf;\n\t\tint v,p;\n\t\tcin>>p;\n\t\tp--;\n\t\tans[p]=0;\n\t\trep(i,r-1){\n\t\t\tcin >> v;\n\t\t\tv--;\n\t\t\trep(j,n) rep(k,n){\n\t\t\t\tnans[k]=min(nans[k],ans[j]+dr[p][j]+ds[j][k]+dr[k][v]);\n\t\t\t}\n\t\t\tp=v;\n\t\t\trep(j,n) ans[j]=nans[j],nans[j]=inf;\n\t\t}\n\t\tint aans=inf;\n\t\trep(i,n) aans=min(aans,ans[i]);\n\t\tcout << aans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int INF = 1000000000;\nstatic int land_mat[200][200];\nstatic int sea_mat[200][200];\n\nint main(){\n\tios_base::sync_with_stdio(false);;\n\twhile(true){\n\t\tint n, m;\n\t\tcin >> n >> m;\n\t\tif(n == 0 && m == 0){ break; }\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tland_mat[i][j] = sea_mat[i][j] = INF;\n\t\t\t}\n\t\t\tland_mat[i][i] = sea_mat[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint a, b, c;\n\t\t\tstring t;\n\t\t\tcin >> a >> b >> c >> t;\n\t\t\t--a; --b;\n\t\t\tif(t[0] == 'S'){\n\t\t\t\tsea_mat[a][b] = min(sea_mat[a][b], c);\n\t\t\t\tsea_mat[b][a] = min(sea_mat[b][a], c);\n\t\t\t}else{\n\t\t\t\tland_mat[a][b] = min(land_mat[a][b], c);\n\t\t\t\tland_mat[b][a] = min(land_mat[b][a], c);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k < n; ++k){\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tland_mat[i][j] = min(\n\t\t\t\t\t\tland_mat[i][j], land_mat[i][k] + land_mat[k][j]);\n\t\t\t\t\tsea_mat[i][j] = min(\n\t\t\t\t\t\tsea_mat[i][j], sea_mat[i][k] + sea_mat[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\tfor(int i = 0; i < r; ++i){\n\t\t\tcin >> z[i];\n\t\t\t--z[i];\n\t\t}\n\t\tint answer = 0;\n\t\tvector<int> cur(n, INF);\n\t\tcur[z[0]] = 0;\n\t\tfor(int i = 1; i < r; ++i){\n\t\t\tconst int u = z[i - 1], v = z[i];\n\t\t\tvector<int> from_dist(n, INF);\n\t\t\tvector<int> to_dist(n, INF);\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tfrom_dist[j] = land_mat[u][j];\n\t\t\t\tto_dist[j] = land_mat[j][v];\n\t\t\t}\n\t\t\tvector<int> next(n, INF);\n\t\t\tif(land_mat[u][v] < INF){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tnext[j] = cur[j] + land_mat[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(cur[j] >= INF){ continue; }\n\t\t\t\tif(from_dist[j] >= INF){ continue; }\n\t\t\t\tfor(int k = 0; k < n; ++k){\n\t\t\t\t\tif(to_dist[k] >= INF){ continue; }\n\t\t\t\t\tconst int sea_dist = sea_mat[j][k];\n\t\t\t\t\tif(sea_dist >= INF){ continue; }\n\t\t\t\t\tnext[k] = min(next[k], cur[j] + from_dist[j] + to_dist[k] + sea_dist);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcur.swap(next);\n\t\t}\n\t\tcout << *min_element(cur.begin(), cur.end());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#define ll long long\nusing namespace std;\n\nconst int N = 210;\n\nint n,m,cnt,p[1010];\nll ans=1ll<<60,dis[N][N][2],dp[1010][N];\n\nint gi() {\n  int x=0,o=1; char ch=getchar();\n  while(ch!='-' && (ch<'0' || ch>'9')) ch=getchar();\n  if(ch=='-') o=-1,ch=getchar();\n  while(ch>='0' && ch<='9') x=x*10+ch-'0',ch=getchar();\n  return o*x;\n}\n\nvoid init() {\n  ans=1<<30;\n  for(int i=0; i<=n; i++)\n    for(int j=0; j<=n; j++)\n      for(int k=0; k<2; k++)\n\tdis[i][j][k]=1ll<<30;\n}\n\nvoid floyed() {\n  for(int t=0; t<2; t++)\n    for(int k=1; k<=n; k++) \n      for(int i=1; i<=n; i++)\n\tfor(int j=1; j<=n; j++)\n\t  dis[i][j][t]=min(dis[i][j][t],dis[i][k][t]+dis[k][j][t]);\n}\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) && n+m) {\n    init();\n    for(int i=1; i<=m; i++) {\n      int x=gi(),y=gi(),z=gi(); char ch;\n      scanf(\"%c\", &ch);\n      if(ch=='L') dis[x][y][0]=dis[y][x][0]=z;\n      else dis[x][y][1]=dis[y][x][1]=z;\n    }\n    cnt=gi();\n    for(int i=1; i<=cnt; i++) p[i]=gi();\n    for(int i=1; i<=n; i++) dis[i][i][0]=dis[i][i][1]=0;\n    floyed();\n    for(int i=0; i<=cnt; i++)\n      for(int j=0; j<=n; j++)\n\tdp[i][j]=1<<30;\n    dp[0][1]=0,dis[0][1][0]=dis[0][1][1]=0;\n    for(int i=1; i<=cnt; i++)\n      for(int j=1; j<=n; j++) {\n\tdp[i][p[i]]=min(dp[i][p[i]],dp[i-1][j]+dis[p[i-1]][j][0]+dis[j][p[i]][1]);\n\tdp[i][j]=min(dp[i][j],min(dp[i-1][p[i-1]]+dis[p[i-1]][j][1]+dis[j][p[i]][0],min(dis[p[i-1]][j][1]+dis[j][p[i]][0],dis[p[i-1]][p[i]][0])+dp[i-1][j]));\n      }\n    for(int i=1; i<=n; i++) ans=min(ans,dp[n][i]);\n    printf(\"%lld\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <queue>\n\nusing namespace std;\n\n#define all(i) i.begin(), i.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n\ntypedef pair<int, int> p;\nconst int INF = 1e9;\n\nint dp[201][201];\n\nint ld[201][201];\nint sd[201][201];\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m && n) {\n\t\trep(i, 201)rep(j, 201) {\n\t\t\tld[i][j] = sd[i][j] = dp[i][j] = INF;\n\t\t}\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\tx--; y--;\n\t\t\tif (s == 'S') {\n\t\t\t\tsd[y][x] = sd[x][y] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tld[y][x] = ld[x][y] = t;\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> z(r);\n\t\trep(i, r) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\trep(i, r-1) {\n\t\t\trep(s, n) {\n\t\t\t\t//z[i]テ」ツ?凝」ツつ越[i+1]テ」ツ?ク\n\t\t\t\t//ティツ按ケテ」ツ?ョテ、ツスツ催ァツスツョテ」ツ?茎\n\t\t\t\ttypedef pair<int, int> p;\n\t\t\t\tint me[201][201];\n\t\t\t\trep(i, 201)rep(j, 201) {\n\t\t\t\t\tme[i][j] = INF;\n\t\t\t\t}\n\t\t\t\tqueue<p> q;\n\t\t\t\tq.push(p(z[i], s));\n\t\t\t\tme[z[i]][s] = dp[i][s];\n\t\t\t\twhile (q.size()) {\n\t\t\t\t\tint nw = q.front().first;\n\t\t\t\t\tint sh = q.front().second;\n\t\t\t\t\tq.pop();\n\t\t\t\t\trep(j, n) {\n\t\t\t\t\t\tif (me[j][sh] > ld[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\tme[j][sh] = ld[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\tq.push(p(j, sh));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (sh == nw) {\n\t\t\t\t\t\t\tif (me[j][j] > sd[nw][j] + me[nw][sh]) {\n\t\t\t\t\t\t\t\tme[j][j] = sd[nw][j] + me[nw][sh];\n\t\t\t\t\t\t\t\tq.push(p(j, j));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(sh, n) {\n\t\t\t\t\tdp[i + 1][sh] = min(dp[i + 1][sh], me[z[i + 1]][sh]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\trep(s, n) {\n\t\t\tans = min(ans, dp[r - 1][s]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\n\nconst int MAX_V=210;\nll dL[MAX_V][MAX_V];\nll dS[MAX_V][MAX_V];\nint V;\nvoid warshall_floyd(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdL[i][j]=min(dL[i][j],dL[i][k]+dL[k][j]);\n  return;\n}\nvoid warshall_floyd2(){\n\n  for(int k=0;k<V;k++)\n    for(int i=0;i<V;i++)\n      for(int j=0;j<V;j++)\n\tdS[i][j]=min(dS[i][j],dS[i][k]+dS[k][j]);\n  return;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m,n){\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdL[i][j]=0;\n      else\n\tdL[i][j]=llINF;\n    }\n  for(int i=0;i<MAX_V;i++)\n    for(int j=0;j<MAX_V;j++){\n      if(i==j)\n\tdS[i][j]=0;\n      else\n\tdS[i][j]=llINF;\n    }\n    V=n;\n    for(int i=0;i<m;i++){\n      ll x,y,t;\n      char s;\n      cin>>x>>y>>t;\n      cin>>s;\n      x--;y--;\n      if(s=='L'){\n\tdL[x][y]=t;\n\tdL[y][x]=t;\n      }else{\n\tdS[x][y]=t;\n\tdS[y][x]=t;\n      }\n    }\n    warshall_floyd();\n    warshall_floyd2();\n    int r;cin>>r;\n    ll dp[r+10][n+10];\n    for(int i=0;i<r+10;i++)\n      for(int j=0;j<n+10;j++)\n\t  dp[i][j]=llINF;\n    int fffff;cin>>fffff;\n    dp[0][fffff-1]=0;\n    int v[r+10];\n    v[0]=fffff-1;\n    for(int i=1;i<r;i++){\n      cin>>v[i];\n      v[i]--;\n    }\n    for(int i=1;i<r;i++){\n      for(int j=0;j<n;j++){\n\tif(dp[i-1][j]!=llINF){\n\t  dp[i][j]=min(dp[i][j],dp[i-1][j]+dL[v[i-1]][v[i]]);\n\t  for(int k=0;k<n;k++){\n\t    dp[i][k]=min(dp[i][k],dp[i-1][j]+dL[v[i-1]][j]+dS[j][k]+dL[k][v[i]]);\n\t  }\n\t}\n      }\n    }\n    ll ans=llINF;\n    for(int j=0;j<n;j++){\n      // cout<<dp[i][j]<<\" \";\n      ans=min(ans,dp[r-1][j]);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl;\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\nconst int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship;\n\tint job, cost;\n\tP(int now, int ship, int job, int cost) :now(now), ship(ship), job(job), cost(cost) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\n\nint flag[201][201][1000];\npriority_queue< P, vector<P>, greater<P> >que;\nvector<pii> a[300][2];\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tFOR(i, 300)FOR(j, 2)\n\t\t{\n\t\t\tvector<pii> empty;\n\t\t\tswap(a[i][j], empty);\n\t\t}\n\t\tvi b;\n\t\tINT(n); INT(m);\n\t\tif ( !n )break;\n\t\tFOR(i, m)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\ta[x][sl == 'L'].emplace_back(y, t);\n\t\t\ta[y][sl == 'L'].emplace_back(x, t);\n\t\t}\n\t\tINT(r);\n\t\tFOR(i, r)\n\t\t{\n\t\t\tINT(z);\n\t\t\tb.push_back(z);\n\t\t}\n\t\tmemset(flag, -1, sizeof flag);\n\t\tflag[b[0]][b[0]][1] = 0;\n\t\tpriority_queue< P, vector<P>, greater<P> > empty;\n\t\tswap(que, empty);\n\t\tque.emplace(b[0], b[0], 1, 0);\n\t\twhile ( !que.empty() )\n\t\t{\n\t\t\tP now = que.top(); que.pop();\n\t\t\tif ( now.job == b.size() )\n\t\t\t{\n\t\t\t\tcout << now.cost << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( now.now == now.ship )\n\t\t\t{\n\t\t\t\tFOR(i, a[now.now][0].size())\n\t\t\t\t{\n\t\t\t\t\tP next = now;\n\t\t\t\t\tnext.now = next.ship = a[now.now][0][i].first;\n\t\t\t\t\tnext.cost += a[now.now][0][i].second;\n\t\t\t\t\tif ( next.now == b[next.job] )next.job++;\n\t\t\t\t\tint flg = flag[next.now][next.ship][next.job];\n\t\t\t\t\tif ( flg == -1 || flg > next.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\tque.push(next);\n\t\t\t\t\t\tflag[next.now][next.ship][next.job] = next.cost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tFOR(i, a[now.now][1].size())\n\t\t\t{\n\t\t\t\tP next = now;\n\t\t\t\tnext.now = a[now.now][1][i].first;\n\t\t\t\tnext.cost += a[now.now][1][i].second;\n\t\t\t\tif ( next.now == b[next.job] )next.job++;\n\t\t\t\tint flg = flag[next.now][next.ship][next.job];\n\t\t\t\tif ( flg == -1 || flg > next.cost )\n\t\t\t\t{\n\t\t\t\t\tque.push(next);\n\t\t\t\t\tflag[next.now][next.ship][next.job] = next.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long int ll;\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\nconst ll INF = 1LL << 50;\n\nint N, M, R;\nll z[1010];\nll dl[210][210], ds[210][210], dist[1010][210];\n\nint main() {\n    while(cin >> N >> M, N || M) {\n        for(int i=0; i<N; i++) {\n            for(int j=0; j<N; j++) {\n                if(i == j) continue;\n                dl[i][j] = ds[i][j] = INF;\n            }\n        }\n        for(int i=0; i<M; i++) {\n            ll x, y, t; string sl; cin >> x >> y >> t >> sl;\n            x--; y--;\n            if(sl == \"L\") {\n                chmin(dl[x][y], t);\n                chmin(dl[y][x], t);\n            }\n            else {\n                chmin(ds[x][y], t);\n                chmin(ds[y][x], t);\n            }\n        }\n\n        cin >> R;\n        for(int i=0; i<R; i++) cin >> z[i], z[i]--;\n        for(int i=0; i<R; i++) {\n            for(int j=0; j<N; j++) {\n                dist[i][j] = INF;\n            }\n        }\n\n        for(int k=0; k<N; k++) {\n            for(int i=0; i<N; i++) {\n                for(int j=0; j<N; j++) {\n                    chmin(dl[i][j], dl[i][k] + dl[k][j]);\n                    chmin(ds[i][j], ds[i][k] + ds[k][j]);\n                }\n            }\n        }\n\n        dist[0][z[0]] = 0;\n        for(int i=0; i<R-1; i++) {\n            int cur = z[i], to = z[i+1];\n            for(int j=0; j<N; j++) {\n                if(dist[i][j] == INF) continue;\n\n                // land only\n                chmin(dist[i+1][j], dist[i][j] + dl[cur][to]);\n\n                // sea\n                for(int k=0; k<N; k++) {\n                    chmin(dist[i+1][k], dist[i][j] + dl[cur][j] + ds[j][k] + dl[k][to]);\n                }\n            }\n        }\n\n        ll ans = INF;\n        for(int i=0; i<N; i++) chmin(ans, dist[R-1][i]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nint riku[200][200];//陸のワーシャルフロイド\nint umi[200][200];//海のワーシャルフロイド\nll dp[1001][200];//i番目のクエリまでこなしたときの船がjにあるときの最短ルート\nint z[1001];\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n,m;\n\t\tcin>>n>>m;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfill(riku[0],riku[200],1e8-1);\n\t\tfill(umi[0],umi[200],1e8-1);\n\t\tfill(dp[0],dp[1001],1e14-1);\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y,t;\n\t\t\tchar s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tx--;y--;\n\t\t\tif(s=='L')\n\t\t\t{\n\t\t\t\triku[x][y]=t;\n\t\t\t\triku[y][x]=t;\n\t\t\t}else{\n\t\t\t\tumi[x][y]=t;\n\t\t\t\tumi[y][x]=t;\n\t\t\t}\n\t\t}\n\t\tint r;\n\t\tcin>>r;\n\t\tz[0]=0;\n\t\tfor(int i=0;i<r;i++)\n\t\t{\n\t\t\tint f;\n\t\t\tcin>>f;\n\t\t\tf--;\n\t\t\tz[i+1]=f;\n\t\t}\n\t\t//ワーシャルフロイド\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\triku[i][i]=0;\n\t\t\tumi[i][i]=0;\n\t\t}\n\t\tfor(int k=0;k<n;k++)\n\t\t{\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t{\n\t\t\t\t\triku[i][j]=min(riku[i][j],riku[i][k]+riku[k][j]);\n\t\t\t\t\tumi[i][j]=min(umi[i][j],umi[i][k]+umi[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//到達不能な場所は-1に直す\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(riku[i][j]==1e8-1)\n\t\t\t\t\triku[i][j]=-1;\n\t\t\t\tif(umi[i][j]==1e8-1)\n\t\t\t\t\tumi[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\t//start dp\n\t\tdp[1][z[1]]=0;\n\t\tfor(int i=2;i<r+1;i++)\n\t\t{\n\t\t\t//船の置いてある場所\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(dp[i-1][j]!=-1)\n\t\t\t\t{\n\t\t\t\t\tint s=z[i-1];\n\t\t\t\t\tint t=z[i];\n\t\t\t\t\t//陸路だけの場合を調べる\n\t\t\t\t\tif(riku[s][t]!=-1)\n\t\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i-1][j]+(ll)riku[s][t]);\n\t\t\t\t\t//船を置く場所を全探索\n\t\t\t\t\tfor(int k=0;k<n;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(riku[s][j]==-1 || umi[j][k]==-1 || riku[k][t]==-1)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+(ll)(riku[s][j]+umi[j][k]+riku[k][t]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//end dp\n\t\tll ans=1e14-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tans=min(ans,dp[r][i]);\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e6\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n\n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n\n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        dp[r][now] = min(dp[r][now], dp[r-1][now] + G1[now][next]);\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\ntypedef vector<ll> vl;\n\nint main() {\n\tint N, M;\n\twhile(cin >> N >> M , N) {\n\t\tvvi ldist(N, vi(N, INF));\n\t\tvvi sdist(N, vi(N, INF));\n\t\tint x, y, t;\n\t\tchar sl;\n\t\tREP(i, M) {\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif(sl == 'L') {\n\t\t\t\tldist[x-1][y-1] = min(ldist[x-1][y-1], t);\n\t\t\t\tldist[y-1][x-1] = min(ldist[y-1][x-1], t);\n\t\t\t}\n\t\t\tif(sl == 'S') {\n\t\t\t\tsdist[x-1][y-1] = min(sdist[x-1][y-1], t);\n\t\t\t\tsdist[y-1][x-1] = min(sdist[y-1][x-1], t);\n\t\t\t}\n\t\t}\n\t\tREP(i, N) {\n\t\t\tldist[i][i] = sdist[i][i] = 0;\n\t\t}\n\n\t\tREP(i, N) {\n\t\t\tREP(j, N) {\n\t\t\t\tREP(k, N) {\n\t\t\t\t\tldist[j][k] = min(ldist[j][k], ldist[j][i] + ldist[i][k]);\n\t\t\t\t\tsdist[j][k] = min(sdist[j][k], sdist[j][i] + sdist[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint R;\n\t\tcin >> R;\n\t\tvi z(R);\n\t\tREP(i, R) {\n\t\t\tcin >> z[i];\n\t\t\tz[i]--;\n\t\t}\n\n\t\tvector<vl> cost(R, vl(N, INF));\n\t\tREP(i, R) {\n\t\t\tif(i == 0) {\n\t\t\t\tcost[0][z[0]] = 0;\n\t\t\t} else {\n\t\t\t\tint fr = z[i-1];\n\t\t\t\tint to = z[i];\n\t\t\t\tREP(j, N) {\n\t\t\t\t\tREP(k, N) {\n\t\t\t\t\t\tcost[i][k] = min(cost[i][k], cost[i-1][j]+ldist[fr][j]+sdist[j][k]+ldist[k][to]);\n\t\t\t\t\t}\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][j]+ldist[fr][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tll ans = INF;\n\t\tREP(i, N) {\n\t\t\tans = min(ans, cost[R-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n??\nusing namespace std;\n??\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n??\n//container util\n//------------------------------------------\n#define ALL(a)?? (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n??\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)?? FOR(i,0,n)\n??\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI?? = acos(-1.0);\nconst LL INF = 1e14;\n??\nLL dist_L[201][201];\nLL dist_S[201][201];\nLL dp[1001][201];\nint main(){\n????cin.tie(0);\n????ios_base::sync_with_stdio(false);\n??\n????int N, M, R;\n????while(cin >> N >> M, N){\n????????fill((LL*)dist_L, (LL*)dist_L+201*201, INF);\n????????fill((LL*)dist_S, (LL*)dist_S+201*201, INF);\n??\n????????REP(i,N) dist_L[i][i] = dist_S[i][i] = 0;\n????????REP(i,M){\n????????????LL x, y, t; char c;\n????????????cin >> x >> y >> t >> c;\n????????????--x, --y;\n????????????if(c == 'L')\n????????????????dist_L[x][y] = dist_L[y][x] = min(dist_L[x][y], t);\n????????????else\n????????????????dist_S[x][y] = dist_S[y][x] = min(dist_S[x][y], t);\n????????}\n??????????\n????????REP(k,N) REP(i,N) REP(j,N){\n????????????dist_L[i][j] = dist_L[j][i] = min(dist_L[i][j], dist_L[i][k]+dist_L[k][j]);\n????????????dist_S[i][j] = dist_S[j][i] = min(dist_S[i][j], dist_S[i][k]+dist_S[k][j]);\n????????}\n??\n????????cin >> R;\n????????VI RS(R);\n????????REP(i,R){\n????????????cin >> RS[i];\n????????????--RS[i];\n????????}\n??\n????????// dp[i][j] :<=> i????????????§??¨????????????????£??????????????????j??????¨???????????°??????????\n????????fill((LL*)dp, (LL*)dp+1001*201, INF);\n????????dp[0][RS[0]] = 0;\n????????REP(i,R-1){\n????????????REP(u,N){\n????????????????REP(v,N){\n????????????????????dp[i+1][v] = min(dp[i+1][v],\n??????????????????????????????????????????????????????// Rs[i] -> u?????????§???u -> v?????????§???v->RS[i+1]?????????§??§????\n??????????????????????????????????????????????????????dp[i][u]+dist_L[RS[i]][u] + dist_S[u][v]+dist_L[v][RS[i+1]]\n??????????????????????????????????????????????????????);\n????????????????}\n????????????????//?????????\n????????????????dp[i+1][u] = min(dp[i+1][u], dp[i][u]+dist_L[RS[i]][RS[i+1]]);\n????????????}\n????????}\n??\n????????LL ans = INF;\n????????REP(u,N) ans = min(ans, dp[R-1][u]);\n????????cout << ans << endl;\n????}?? \n??????\n????return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\ntypedef pair<int,int> pii;\n\nconst int N = 222;\nconst int R = 1111;\nconst int INF = 500000000;\nint n,m;\n\nvector<pii> sea[N];\nvector<pii> land[N];\nvector<int> move;\n\nint wsea[N][N];\nint wland[N][N];\n\nvoid init(){\n\trep(i,N)sea[i].clear();\n\trep(i,N)land[i].clear();\n\tmove.clear();\n\t\n\trep(i,N)rep(j,N)wsea[i][j]=wland[i][j]=INF;\n}\n\nbool input(){\n\tcin>>n>>m;\n\tif(n==0)return false;\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring d;\n\t\tcin>>a>>b>>c>>d;\n\t\tif(d==\"L\"){\n\t\t\tland[a].push_back(pii(b,c));\n\t\t\tland[b].push_back(pii(a,c));\n\t\t}\n\t\tif(d==\"S\"){\n\t\t\tsea[a].push_back(pii(b,c));\n\t\t\tsea[b].push_back(pii(a,c));\n\t\t}\n\t}\n\tint r;\n\tcin>>r;\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\t\n\treturn true;\n}\n\nvoid solve_wf_edge(int memo[N][N], vector<pii> edge[N]){\n\trep(i,N)rep(j,N)memo[i][j]=INF;\n\treps(i,1,n+1)memo[i][i]=0;\n\trep(i,n+1){\n\t\trep(j,edge[i].size()){\n\t\t\tpii e = edge[i][j];\n\t\t\tmemo[i][e.first] = e.second;\n\t\t\tmemo[e.first][i] = e.second;\n\t\t}\n\t}\n\t\n\trep(k,n){\n\t\treps(i,1,n+1){\n\t\t\treps(j,1,n+1){\n\t\t\t\tmemo[i][j] = min(memo[i][j], memo[i][k]+memo[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve_wf(){\n\tsolve_wf_edge(wsea, sea);\n\tsolve_wf_edge(wland, land);\n}\n\nint solve_dp(){\n\tint dp[R][N];\n\trep(i,R)rep(j,N)dp[i][j]=INF;\n\t\n\tdp[0][move[0]]=0;\n\t\n\treps(i,1,move.size()){\n\t\tint prev = move[i-1];\n\t\tint now = move[i];\n\t\treps(j,1,n+1){\n\t\t\treps(k,1,n+1){\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k]+wland[prev][k]+wsea[k][j]+wland[j][now]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ret = INF;\n\treps(i,1,n+1)ret = min(ret, dp[move.size()-1][i]);\n\treturn ret;\n}\n\nint solve(){\n\tsolve_wf();\n\treturn solve_dp();\n}\n\nint main(){\n\twhile(init(),input()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n3 3\n1 2 5 L\n1 2 7 S\n2 3 11 S\n3\n1 2 3\n0 0\n\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\n#define INF INT_MAX/3\n#define EPS 1e-14\n\n#define LAND dist[0]\n#define SEA dist[1]\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\ntypedef tuple<int,int,int> Triple;\n\nconst int NMAX = 216, RMAX = 1024;\nint dist[2][NMAX][NMAX]; // land, sea;\nint dp[RMAX][NMAX][NMAX];\nlli N,M,R;\nvector<int> z_;\n\nint main() {\n  while (cin >> N >> M and N) {\n    REP(sl,2) REP(i,N) REP(j,N) { dist[sl][i][j] = (i == j ? 0:INF); }\n    REP(i,M) {\n      int x,y,t;\n      char sl;\n      cin >> x >> y >> t >> sl;\n      x--; y--;\n      dist[(sl == 'L'? 0:1)][x][y] = dist[(sl == 'L'? 0:1)][y][x] = INF;\n    }\n    REP(sl,2) REP(k,N) REP(i,N) REP(j,N) {\n      dist[sl][i][j] = min(dist[sl][i][k] + dist[sl][k][j], dist[sl][i][j]);\n    }\n    cin >> R;\n    REP(r,R) REP(i,N) REP(j,N) { dp[r][i][j] = INF; }\n    REP(i,N) REP(j,N) { dp[R][i][j] = 0; }\n    z_.resize(R);\n    REP(i, R) { cin >> z_[i]; z_[i]--; }\n    RREP(r,R) REP(man,N) REP(ship,N) {\n      int v = z_[r];\n      dp[r][man][ship] = min(\n          (man == ship ? 0:LAND[man][ship]) + SEA[man][v] + dp[r + 1][v][v], // use ship\n          LAND[man][v] + dp[r + 1][v][ship]); // use no ship\n      // printf(\"dp[%d][%d][%d] = %d\\n\", r,man,ship,dp[r][man][ship]);\n    }\n    cout << dp[0][z_[0]][z_[0]] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 28;\n\nint n,m,r;\n\nint L[210][210];\nint S[210][210];\nint z[1010];\n\nint dp[1010][210];\n\nint main(void){\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,n)rep(j,n) L[i][j]=S[i][j]=(i==j)?0:inf;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar type;\n\t\t\tcin >> a >> b >> c >> type;\n\t\t\ta--,b--;\n\t\t\tif(type=='L')\n\t\t\t\tL[a][b]=L[b][a]=min(L[a][b],c);\n\t\t\telse\n\t\t\t\tS[a][b]=S[b][a]=min(S[a][b],c);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n) S[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\n\t\tcin >> r;\n\t\trep(i,r) cin >> z[i],z[i]--;\n\t\trep(i,r)rep(j,n) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[z[i]][z[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tint cost=L[z[i]][j]+S[j][k]+L[k][z[i+1]];\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+cost);\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nconst int inf = 10000000;\nint land[200][200];\nint sea[200][200];\nint dp[1000][200];\n\nint main() {\n    int N,M,R,x,y,i,j,k,t;\n  string s;\n  while(cin>>N>>M, N|M) {\n\n    rep(i,200) {\n      rep(j,200) land[i][j] = sea[i][j] = inf;\n      land[i][i] = sea[i][i] = 0;\n    }\n\n    rep(i,M) {\n      cin>>x>>y>>t>>s;\n      x--,y--;\n      if(s == \"S\") {\n\tsea[x][y] = min(t, sea[x][y]);\n\tsea[y][x] = sea[x][y];\n      }else{\n\tland[x][y] = min(t, land[x][y]);\n\tland[y][x] = land[x][y];\n      }\n    }\n\n    rep(k,N) {\n      rep(i,N) {\n\trep(j,N) {\n\t  sea[i][j] = min(sea[i][k]+sea[k][j], sea[i][j]);\n\t  land[i][j] = min(land[i][k]+land[k][j], land[i][j]);\n\t}\n      }\n    }\n\n    cin>>R;\n    vector<int> path;\n    rep(i,1000) rep(j,200) dp[i][j] = inf;\n    rep(i, R) {\n      int kt;\n      cin>>kt;\n      kt--;\n      path.push_back(kt);\n    }\n\n    dp[0][path[0]] = 0;\n    for(i=1; i<R; ++i) {\n      for(j=0; j<N; ++j) {\n\tdp[i][j] = min(dp[i-1][j]+land[path[i-1]][path[i]],dp[i][j]);\n\n\tfor(k=0; k<N; ++k) {\n\t  int t = dp[i-1][j]+land[path[i-1]][j]+sea[j][k]+land[k][path[i]];\n\t  dp[i][k] = min(dp[i][k], t);\n\t}\n\t//cout<<i<<\": \"<<j<<\" \"<<dp[i][j]<<endl;\n      }\n    }\n\n    int ans = inf;\n    rep(i,N) {\n      ans = min(ans, dp[R-1][i]);\n      //cout<<i<<\" : \"<<dp[R-1][i]<<endl;\n    }\n\n    cout<<ans<<endl;\n\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nint n, m, r;\nlong long sd[200][200];\nlong long ld[200][200];\nint z[1000];\nlong long dp[200][1000];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d\", &n, &m);\n\t\tif(n == 0 && m == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, n){\n\t\t\tfill(sd[i], sd[i] + n, 2e10);\n\t\t\tfill(ld[i], ld[i] + n, 2e10);\n\t\t\tsd[i][i] = 0;\n\t\t\tld[i][i] = 0;\n\t\t}\n\n\t\trep(i, m){\n\t\t\tint x, y, t;\n\t\t\tchar c;\n\t\t\tscanf(\"%d%d%d %c\", &x, &y, &t, &c);\n\t\t\t--x;\n\t\t\t--y;\n\t\t\tif(c == 'S'){\n\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\trep(k, n){\n\t\t\trep(i, n){\n\t\t\t\trep(j, n){\n\t\t\t\t\tsd[i][j] = min(sd[i][j], sd[i][k] + sd[k][j]);\n\t\t\t\t\tld[i][j] = min(ld[i][j], ld[i][k] + ld[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &r);\n\t\trep(i, r){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\t--z[i];\n\t\t}\n\n\t\trep(j, r){\n\t\t\trep(i, n){\n\t\t\t\tif(j == 0){\n\t\t\t\t\tdp[i][j] = (i == z[j] ? 0 : 2e10);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i][j - 1] + ld[z[j - 1]][z[j]];\n\t\t\t\t\trep(k, n){\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[k][j - 1] + ld[z[j-1]][k] + sd[k][i] + ld[i][z[j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong long result = 2e10;\n\t\trep(i, n){\n\t\t\tresult = min(result, dp[i][r - 1]);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, ll> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstruct edge{\n\tint v,pass,time;\n\tll cost;\n\tbool operator<(const edge &rhs) const {\n\t\treturn cost < rhs.cost;\n\t}\n\tbool operator>(const edge &rhs) const {\n\t\treturn cost > rhs.cost;\n\t}\n};\n\nll dist[2][225][225],dp[1111][225];\nint z[1111];\n\nint main(void){\n\tint n,m,i,j,k,u,v,r;\n\tll t,ans;\n\tchar w;\n\twhile(true){\n\t\tfill(dist[0][0],dist[2][0],INFLL);\n\t\tfill(dp[0],dp[1111],INFLL);\n\t\tans = INFLL;\n\t\tcin >> n >> m;\n\t\tif(!n){\n\t\t\tbreak;\n\t\t}\n\t\tfor(i=0; i<n; ++i){\n\t\t\tdist[0][i][i] = 0ll;\n\t\t\tdist[1][i][i] = 0ll;\n\t\t}\n\t\tfor(i=0; i<m; ++i){\n\t\t\tcin >> u >> v >> t >> w;\n\t\t\t--u; --v; k = ((w=='S')?1:0);\n\t\t\tdist[k][u][v] = min(dist[k][u][v],t);\n\t\t\tdist[k][v][u] = min(dist[k][v][u],t);\n\t\t}\n\t\tfor(k=0; k<n; ++k){\n\t\t\tfor(i=0; i<n; ++i){\n\t\t\t\tfor(j=0; j<n; ++j){\n\t\t\t\t\tdist[0][i][j] = min(dist[0][i][j],dist[0][i][k]+dist[0][k][j]);\n\t\t\t\t\tdist[1][i][j] = min(dist[1][i][j],dist[1][i][k]+dist[1][k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(i=0; i<r; ++i){\n\t\t\tcin >> z[i]; --z[i];\n\t\t}\n\t\tdp[0][z[0]] = 0ll;\n\t\tfor(i=1; i<r; ++i){\n\t\t\tfor(j=0; j<n; ++j){\n\t\t\t\tdp[i][j] = min(dp[i][j],dp[i-1][j]+dist[0][z[i-1]][z[i]]);\n\t\t\t\tfor(k=0; k<n; ++k){\n\t\t\t\t\tdp[i][k] = min(dp[i][k],dp[i-1][j]+dist[0][z[i-1]][j]+dist[1][j][k]+dist[0][k][z[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=0; i<n; ++i){\n\t\t\tans = min(ans,dp[r-1][i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define INF (1<<24)\n\nint n,m,a,b,c,R;\nint r[1001];\nchar ch;\nint t[201][201];\nint u[201][201];\nint dp[201][1001];\n \nvoid init();\nint solve();\n  \nint main(){\n  while(cin>>n>>m){\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      cin>>a>>b>>c>>ch;\n      a--;b--;\n      if(ch=='L'){\n\tt[a][b]=min(t[a][b],c);\n\tt[b][a]=min(t[b][a],c);\n      }else {\n\tu[a][b]=min(u[a][b],c);\n\tu[b][a]=min(u[b][a],c);\n      }\n    }\n    cin>>R;\n    for(int i=0;i<R;i++){\n      cin>>r[i];\n      r[i]--;\n    }\n \n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  u[i][j]=min(u[i][j],u[i][k]+u[k][j]);\n\t  t[i][j]=min(t[i][j],t[i][k]+t[k][j]);\n\t}\n      }\n    }\n    cout<<solve()<<endl;\n  }\n  return 0;\n}\n  \nint solve(){\n  dp[r[0]][0]=0;\n  for(int i=0;i<R-1;i++){\n    for(int j=0;j<n;j++){\n      if(dp[j][i]==INF)continue;\n\n      for(int k=0;k<n;k++){\n\tdp[k][i+1]=min(dp[k][i+1],dp[j][i]+t[r[i]][j]+u[j][k]+t[k][r[i+1]]);\n      }\n      \n      dp[j][i+1]=min(dp[j][i+1],dp[j][i]+t[r[i]][r[i+1]]);\n      \n      dp[r[i+1]][i+1]=min(dp[r[i+1]][i+1],dp[j][i]+t[r[i]][j]+u[j][r[i+1]]);\n\n    }\n  }\n  int res=INF;\n  for(int i=0;i<n;i++)res=min(res,dp[i][R-1]);\n  return res;\n}\n  \nvoid init(){\n  for(int i=0;i<201;i++){\n    for(int j=0;j<201;j++){\n      if(i==j)u[i][j]=0;\n      else u[i][j]=INF;\n      t[i][j]=u[i][j];\n    }\n    for(int j=0;j<1001;j++)dp[i][j]=INF;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 220\n#define MAX_R 1020\n#define INF 123456789\n\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> Q;\npriority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> Q2;\nvector<tuple<int, int, int>>X[MAX_N];\nstring A4;\nint N, M, R;\nint A1, A2, A3;\nint travel[MAX_R];\nint DIST[MAX_N][MAX_N], DIST2[MAX_N];\nint COLOR[MAX_N][MAX_N], COLOR2[MAX_N];\nint PATH[MAX_N][MAX_N][MAX_N];\nint DP[MAX_R][MAX_N];\nint cnt;\n\nvoid dijkstra(int st) {\n\twhile (!Q.empty()) {\n\t\tcnt++;\n\t\ttuple<int, int, int>tup = Q.top();\n\t\tint a1 = get<0>(tup);\n\t\tint a2 = get<1>(tup);\n\t\tint a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tint a4 = get<0>(X[a2][i]);\n\t\t\tint a5 = get<1>(X[a2][i]);\n\t\t\tint a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tint a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tint a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tcnt++;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ2.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\twhile (!Q2.empty()) {\n\t\t\tQ.push(Q2.top());\n\t\t\tQ2.pop();\n\t\t}\n\t}\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tDIST2[i] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t\tCOLOR2[i] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\tPATH[i][j][k] = INF;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n\twhile (!Q2.empty()) {\n\t\tQ2.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (M >= 10000) { return 0; }\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\t\tfor (int k = 0; k < MAX_N; k++) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDIST[i][i] = 0;\n\t\t\tCOLOR[i][i] = GRAY;\n\t\t\tQ.push(make_tuple(0, i, i));\n\t\t\tdijkstra(i);\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tPATH[i][j][k] = DIST[j][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tDP[0][travel[0]] = 0;\n\t\tfor (int i = 0; i < R - 1; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tint start = travel[i];\n\t\t\t\tint goal = travel[i + 1];\n\t\t\t\tif (start == j) {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\t\tDP[i + 1][j] = min(DP[i + 1][j], DP[i][j] + PATH[start][goal][j]);\n\t\t\t\t\t\tDP[i + 1][k] = min(DP[i + 1][k], DP[i][j] + PATH[start][j][start] + PATH[j][goal][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tres = min(res, DP[R - 1][i]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint test[200][200][1000];\n\nint main(){\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1 << 26;\ninline void chmin(int &a, int b){a = min(a, b);}\n\nstruct Edge {\n\tint to, cost;\n\tEdge(int to, int cost): to(to), cost(cost){}\n};\n\nint n, m;\nvector<Edge> lg[200];\nvector<Edge> sg[200];\nint r, z[1001];\n\nint solve()\n{\n\tstatic int ldist[200][200];\n\tstatic int sdist[200][200];\n\tstatic int dp[1001][200];\n\t\n\tfill_n(*ldist, 40000, INF);\n\tfill_n(*sdist, 40000, INF);\n\tfor (int i = 0; i < n; i++) ldist[i][i] = sdist[i][i] = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : lg[i]) chmin(ldist[i][e.to], e.cost);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (auto &e : sg[i]) chmin(sdist[i][e.to], e.cost);\n\t}\n\tfor (int k = 0; k < n; k++){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tfor (int j = 0; j < n; j++){\n\t\t\t\tchmin(ldist[i][j], ldist[i][k] + ldist[k][j]);\n\t\t\t\tchmin(sdist[i][j], sdist[i][k] + sdist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfill_n(*dp, 1001 * 200, INF);\n\tdp[0][0] = 0;\n\tfor (int i = 0; i < r; i++){\n\t\tint src = z[i], dst = z[i + 1];\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (dp[i][j] == INF) continue;\n\t\t\tfor (int k = 0; k < n; k++){\n\t\t\t\tint cost = ldist[src][j] + sdist[j][k] + ldist[k][dst];\n\t\t\t\tchmin(dp[i + 1][k], dp[i][j] + cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn *min_element(dp[r], dp[r + 1]);\n}\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tfor (int i = 0; i < 200; i++){\n\t\t\tlg[i].clear();\n\t\t\tsg[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint x, y, t;\n\t\t\tstring sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tauto &G = (sl[0] == 'L') ? (lg) : (sg);\n\t\t\tx--; y--;\n\t\t\tG[x].push_back(Edge(y, t));\n\t\t\tG[y].push_back(Edge(x, t));\n\t\t}\n\t\tscanf(\"%d\", &r);\n\t\tfor (int i = 1; i <= r; i++){\n\t\t\tscanf(\"%d\", z + i);\n\t\t\tz[i]--;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF=1001001001001001LL;\nint N,M;\nint A[200][200],B[200][200];\nint dp[2][200];\nsigned main(){\n    while(cin>>N>>M,N||M){\n        fill_n(*A,200*200,INF);\n        fill_n(*B,200*200,INF);\n        for(int i=0;i<N;i++){\n            A[i][i]=0;\n            B[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L')A[a][b]=A[b][a]=c;\n            else B[a][b]=B[b][a]=c;\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n\n        int R;cin>>R;\n        int prev;cin>>prev;prev--;\n        fill_n(*dp,2*200,INF);\n        dp[1][prev]=0;\n\n        for(int i=1;i<R;i++){\n            int cur;cin>>cur;cur--;\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if(A[prev][k]==INF||B[k][j]==INF||A[j][cur]==INF)continue;\n                    dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+A[prev][k]+B[k][j]+A[j][cur]);\n                }\n            }\n            for(int j=0;j<N;j++)dp[i&1][j]=INF;\n            prev=cur;\n        }\n\n        int mi=INF;\n        for(int i=0;i<N;i++)mi=min(mi,dp[R&1][i]);\n\n        cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int INF = 1 << 28;\n\nint main() {\n\tint n, m;\n\t\n\twhile ( cin >> n >> m, n | m ) {\n\t\tVVI L( n, VI( n, INF ) ),\n\t\t\tS( n, VI( n, INF ) );\n\t\t\n\t\tfor ( int i = 0; i < m; ++i ) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t\n\t\t\tswitch ( s ) {\n\t\t\tcase 'L':\n\t\t\t\tL[x - 1][y - 1] = L[y - 1][x - 1] = min( t, L[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tS[x - 1][y - 1] = S[y - 1][x - 1] = min( t, S[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\t\n\t\tVI Z( r, 0 );\n\t\t\n\t\tfor ( int i = 0; i < r; ++i ) {\n\t\t\tcin >> Z[i];\n\t\t\t--Z[i];\n\t\t}\n\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tL[i][i] = S[i][i] = 0;\n\t\t}\n\n\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\t\tL[i][j] = min( L[i][j], L[i][k] + L[k][j] );\n\t\t\t\t\tS[i][j] = min( S[i][j], S[i][k] + S[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVVI d( r, VI( n, INF ) );\n\t\td[0][Z[0]] = 0;\n\t\tfor ( int i = 0; i + 1 < r; ++i ) {\n\t\t\tint from = Z[i], to = Z[i + 1];\n\t\t\t//d[i + 1][to] = min( d[i + 1][to], d[i][from] + S[from][to] );\n\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\t//d[i + 1][to] = min( d[i + 1][to], d[i][j] + L[from][j] + S[j][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][j] + L[from][to] );\n\t\t\t\t//d[i + 1][j] = min( d[i + 1][j], d[i][from] + S[from][j] + L[j][to] );\n\t\t\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\t\t\td[i + 1][k] = min( d[i + 1][k], d[i][j] + L[from][j] + S[j][k] + L[k][to] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tans = min( ans, d[r - 1][i] );\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define INF 100000\n\nusing namespace std;\n\nint solve2(int n, int r, vector<int> root, vector< vector<int> > &l, vector< vector<int> > &s){\n  \n  //DP????????????dp[i][j][k]\n  //0????????????i???????????????????????????i?????????????????????????????£?????¨????????????j???????????????0??????i???????????§??????????????¢\n  vector< vector<int> > dp;\n  dp.resize(r);\n  for(int i = 0; i < r; i++) dp[i].resize(n);\n\n  for(int i = 0; i < r; i++){\n\tfor(int j = 0; j < n; j++){\n\t  if( i == 0  && j == root[0]) dp[i][j] = 0;\n\t  else dp[i][j] = INF;\n\t}\n  }\n\n  for(int i = 1; i < r; i++){\n\tfor(int j = 0; j < n; j++){//i???????????§???????????????????????¨??????????????????\n\t  for(int k = 0; k < n; k++){//k : i-1???????????§???????????????????????¨??????????????????\n\t\tif(j != k) dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][k] + s[k][j] + l[j][root[i]] );\n\t\telse dp[i][j] = min( dp[i][j], dp[i-1][k] + l[root[i-1]][root[i]] );\n\t  }\n\t}\n  }\n  int ans = INF;\n  for(int i = 0; i < n; i++){\n\tans = min( ans, dp[r-1][i] );\n  }\n  return ans;\n}\n\nvoid solve1(int n, vector< vector<int> > &l, vector< vector<int> > &s){\n\n //??????????????¨??????????????????????????¢????????????????±???????\n  for(int i = 0; i < n; i++){\n\tfor(int j = 0; j < n; j++){\n\t  for(int k = 0; k < n; k++){\n\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t  }\n\t}\n  }\n\n}\n\nint main(){\n\n  while(1){\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tif(n == 0 && m == 0) return 0;\n\n\tvector< vector<int> > l, s;\n\tl.resize(n);\n\ts.resize(n);\n \n\tint x, y, t;\n\tchar sl;\n\n\tfor(int i = 0; i < n; i++){\n\t  for(int j = 0; j < n; j++){\n\t\tl[i].push_back(INF);\n\t\ts[i].push_back(INF);\n\t  }\n\t}\n\n\tfor(int i = 0; i < n; i++){\n\t  l[i][i] = 0;\n\t  s[i][i] = 0;\n\t}\n\n\tfor(int i = 0; i < m; i++){\n\t  cin >> x >> y >> t >> sl;\n\t  if(sl == 'L'){\n\t\tl[x-1][y-1] = t;\n\t\tl[y-1][x-1] = t;\n\t  }\n\t  else{\n\t\ts[x-1][y-1] = t;\n\t\ts[y-1][x-1] = t;\n\t  }\n\t}\n\n\tsolve1(n, l, s); //??????????????¨??????????????????????????¢????????????????±???????\n\n\tint r;\n\tcin >> r;\n\n\tvector<int> root;\n\tfor(int i = 0; i < r; i++){\n\t  int area;\n\t  cin >> area;\n\t  root.push_back(area-1);\n\t} \n\n\tcout << solve2(n, r, root, l, s) << endl; //????????¨??????????????????????????¢????±???????\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=205;\nint n,m,x,y,t,r,z[1010],W[N][N],L[N][N];\nll dp[1010][N];\nchar op[4];\n\nvoid floyd(int (*dp)[N]) {\n    for (int k=1;k<=n;k++) {\n        dp[k][k]=0;\n        for (int i=1;i<=n;i++) {\n            for (int j=1;j<=n;j++) {\n                if (k!=i&&k!=j&&i!=j) {\n                    if (dp[i][k]!=INF&&dp[k][j]!=INF) {\n                        dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&n,&m);\n        if (n==0&&m==0) break;\n        memset(W,INF,sizeof(W));\n        memset(L,INF,sizeof(L));\n        for (int i=1;i<=m;i++) {\n            scanf(\"%d%d%d%s\",&x,&y,&t,op);\n            if (op[0]=='L') {\n                L[x][y]=min(L[x][y],t);\n                L[y][x]=L[x][y];\n            } else {\n                W[x][y]=min(W[x][y],t);\n                W[y][x]=W[x][y];\n            }\n        }\n        scanf(\"%d\",&r);\n        for (int i=1;i<=r;i++) scanf(\"%d\",z+i);\n        floyd(L);\n        floyd(W);\n        for (int i=1;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                dp[i][j]=1e18;\n            }\n        }\n        for (int i=1;i<=n;i++) dp[1][i]=W[z[1]][i]+L[z[1]][i];\n        for (int i=2;i<=r;i++) {\n            for (int j=1;j<=n;j++) {\n                if (L[z[i-1]][z[i]]!=INF&&dp[i-1][j]!=1e18) {\n                    dp[i][j]=dp[i-1][j]+L[z[i-1]][z[i]];\n                }\n                for (int k=1;k<=n;k++) {\n                    ll dis1=L[z[i-1]][k];\n                    ll dis2=W[k][j];\n                    ll dis3=L[j][z[i]];\n                    if (dis1!=INF&&dis2!=INF&&dis3!=INF&&dp[i-1][k]!=1e18) {\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+dis1+dis2+dis3);\n                    }\n                }\n            }\n        }\n        ll ans=1e18;\n        for (int i=1;i<=n;i++) ans=min(ans,dp[r][i]);\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n\nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n\nint main(){\n  int N,M;\n\n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n\n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = min(G1[y][x], t);\n      }else{\n        G2[x][y] = G2[y][x] = min(G2[y][x], t);\n      }\n    }\n    \n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n    \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n\n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n\n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n\n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          dp[r][i] = min(dp[r][i], dp[r-1][j] + G1[now][j] + G2[j][i] + G1[i][next]);\n        }\n        if(i != next){\n          dp[r][next] = min(dp[r][next], dp[r-1][i] + G2[i][next]);\n        }\n      }\n      now = next; \n    }\n\n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\nconst int inf=(int)1e9;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  int n,m;\n  while(cin>>n>>m,n){\n    int land[201][201],sea[201][201];\n    int a[1001];\n    for(int i=0;i<201;i++){\n      for(int j=0;j<201;j++){\n        land[i][j]=inf;\n        sea[i][j]=inf;\n      }\n    }\n    for(int i=0;i<n;i++){\n      land[i][i]=0;\n      sea[i][i]=0;\n    }\n    for(int i=0;i<m;i++){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      x--;y--;\n      if(sl=='S'){\n        sea[x][y]=t;\n        sea[y][x]=t;\n      }else{\n        land[x][y]=t;\n        land[y][x]=t;\n      }\n    }\n    int r;cin>>r;\n    for(int i=0;i<r;i++){\n      int b;cin>>b;b--;\n      a[i]=b;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n        for(int j=0;j<n;j++){\n          if(sea[i][k]!=inf && sea[k][j]!=inf)sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          if(land[i][k]!=inf && land[k][j]!=inf)land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n        }\n      }\n    }\n    int dp[1001][201];\n    for(int i=0;i<r;i++)for(int j=0;j<n;j++)dp[i][j]=inf;\n    dp[0][a[0]]=0;\n    for(int i=0;i<r-1;i++){\n      for(int j=0;j<n;j++){\n        if(dp[i][j]==inf)continue;\n        for(int k=0;k<n;k++){\n          if(land[a[i]][j]==inf)continue;\n          if(sea[j][k]==inf)continue;\n          if(land[k][a[i+1]]==inf)continue;\n          dp[i+1][k]=min(dp[i+1][k],dp[i][j]+land[a[i]][j]+sea[j][k]+land[k][a[i+1]]);\n        }\n      }\n    }\n    int ans=inf;\n    for(int i=0;i<n;i++){\n      ans=min(ans,dp[r-1][i]);\n    }\n    cout<<ans<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl;\nint n,m,r,dr[200][200],ds[200][200],inf=1e8;\nint main(){\n\twhile(true){\n\t\tcin>>n>>m;\n\t\tif(n==0) break;\n\t\trep(i,n) rep(j,n) if(i!=j) dr[i][j]=inf,ds[i][j]=inf;\n\t\trep(i,m){\n\t\t\tint x,y,t;\n\t\t\tchar s;\n\t\t\tcin>>x>>y>>t>>s;\n\t\t\tx--,y--;\n\t\t\tif(s=='L'){\n\t\t\t\tdr[x][y]=min(dr[x][y],t);\n\t\t\t\tdr[y][x]=min(dr[y][x],t);\n\t\t\t}else{\n\t\t\t\tds[x][y]=min(ds[x][y],t);\n\t\t\t\tds[y][x]=min(ds[y][x],t);\n\t\t\t}\n\t\t}\n\t\trep(i,n) rep(j,n) rep(k,n) dr[j][k]=min(dr[j][k],dr[j][i]+dr[i][k]);\n\t\trep(i,n) rep(j,n) rep(k,n) ds[j][k]=min(ds[j][k],ds[j][i]+ds[i][k]);\n\t\tcin>>r;\n\t\tint ans[200],nans[200];\n\t\trep(i,n) ans[i]=inf,nans[i]=inf;\n\t\tint v,p;\n\t\tcin>>p;\n\t\tp--;\n\t\tans[p]=0;\n\t\trep(i,r-1){\n\t\t\tcin >> v;\n\t\t\tv--;\n\t\t\trep(j,n) rep(k,n){\n\t\t\t\tnans[k]=min(nans[k],ans[j]+dr[p][j]+ds[j][k]+dr[k][v]);\n\t\t\t}\n\t\t\tp=v;\n\t\t\trep(j,n) ans[j]=nans[j],nans[j]=inf;\n\t\t}\n\t\tint aans=inf*10;\n\t\trep(i,n) aans=min(aans,ans[i]);\n\t\tcout << aans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nvector<vector<vector<int> > > dp;\nvector<vector<int> > g;\nvector<vector<int> > ti;\nvector<vector<char> > sl;\n\nstruct State{\n\tint pos;\n\tint hune;\n\tint r;\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (true) {\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N == 0)break;\n\t\tg.resize(N);\n\t\tti.resize(N);\n\t\tsl.resize(N);\n\t\t\n\t\tint res = 0;\n\t\tint a, b, c;\n\t\tchar d;\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t\tti[a].push_back(c);\n\t\t\tti[b].push_back(c);\n\t\t\tsl[a].push_back(d);\n\t\t\tsl[b].push_back(d);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tvector<int> A(R);\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> A[i];\n\t\t\tA[i]--;\n\t\t}\n\t\tdp.clear();\n\t\tdp.resize(N, vector < vector<int> >(N, vector<int>(R + 1, (int)1 << 60)));\n\t\tdp[A[0]][A[0]][1] = 0;\n\t\tqueue<State> qu;\n\t\tqu.push(State{ A[0], A[0],1 });\n\t\tState t;\n\t\twhile ((int)qu.size() > 0) {\n\t\t\tState st = qu.front(); qu.pop();\n\t\t\t//cerr << st.pos << \" \" << st.hune << \" \" << st.r << endl;\n\t\t\tif (st.r == R)continue;\n\t\t\tfor (int i = 0; i < g[st.pos].size(); i++) {\n\t\t\t\tif (st.pos == st.hune || sl[st.pos][i] == 'L') {\n\t\t\t\t\tt.pos = g[st.pos][i];\n\t\t\t\t\tif (sl[st.pos][i] == 'S') {\n\t\t\t\t\t\tt.hune = g[st.pos][i];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tt.hune = st.hune;\n\t\t\t\t\t}\n\t\t\t\t\tt.r = st.r;\n\t\t\t\t\tif (A[st.r] == g[st.pos][i]) {\n\t\t\t\t\t\tt.r++;\n\t\t\t\t\t}\n\t\t\t\t\tif (dp[t.pos][t.hune][t.r] > dp[st.pos][st.hune][st.r] + ti[st.pos][i]) {\n\t\t\t\t\t\tdp[t.pos][t.hune][t.r] = dp[st.pos][st.hune][st.r] + ti[st.pos][i];\n\t\t\t\t\t\tqu.push(t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tres = (int)1 << 60;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tres = min(res, dp[A[R - 1]][i][R]);\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nLL dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\n\twhile (cin >> n >> m&&n&&m) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tREP(i, 201)REP(j, 201)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tLL ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <map>\n#include <vector>\n#include <queue>\n#define PII pair<int, int>\nusing namespace std;\nconst int MAXV = 200;\nconst int MAXN = 1000;\nconst int INF = 1e9;\n\nint V, E, N, village[MAXN+5];\nint dp[MAXN+5][MAXV+5], dist1[MAXV+5][MAXV+5], dist2[MAXV+5][MAXV+5];\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    while (cin >> V >> E) {\n        if (V == 0 && E == 0) break;\n        for (int i = 1; i <= V; i++) {\n            for (int j = 1; j <= V; j++) {\n                dist1[i][j] = dist2[i][j] = (i == j ? 0 : INF);\n            }\n        }\n\n        for (int i = 0; i < E; i++) {\n            char c;\n            int u, v, w;\n            cin >> u >> v >> w >> c;\n            if (c == 'L') {\n                w = min(dist1[u][v], w);\n                dist1[u][v] = dist1[v][u] = w;\n            }\n            else {\n                w = min(dist2[u][v], w);\n                dist2[u][v] = dist2[v][u] = w;\n            }\n        }\n\n        for (int k = 1; k <= V; k++) {\n            for (int i = 1; i <= V; i++) {\n                for (int j = 1; j <= V; j++) {\n                    dist1[i][j] = min(dist1[i][j], dist1[i][k] + dist1[k][j]);\n                    dist2[i][j] = min(dist2[i][j], dist2[i][k] + dist2[k][j]);\n                }\n            }\n        }\n\n        // for (int i = 1; i <= V; i++) for (int j = 1; j <= V; j++) cout << dist1[i][j] << (j == V ? \"\\n\" : \" \");\n        // for (int i = 1; i <= V; i++) for (int j = 1; j <= V; j++) cout << dist2[i][j] << (j == V ? \"\\n\" : \" \");\n\n        cin >> N;\n        for (int i = 1; i <= N; i++) cin >> village[i];\n\n        for (int i = 1; i <= V; i++) dp[N][i] = 0;\n        for (int i = N - 1; i >= 1; i--) {\n            for (int ship = 1; ship <= V; ship++) {\n                int cur = village[i], tar = village[i + 1];\n                dp[i][ship] = min(INF, dist1[cur][tar] + dp[i + 1][ship]);\n                for (int mid = 1; mid <= V; mid++) {\n                    if (dist1[cur][ship] == INF) continue;\n                    if (dist2[ship][mid] == INF) continue;\n                    if (dist1[mid][tar] == INF) continue;\n                    if (dp[i + 1][mid] == INF) continue;\n                    int relax = dist1[cur][ship] + dist2[ship][mid] + dist1[mid][tar] + dp[i + 1][mid];\n                    dp[i][ship] = min(dp[i][ship], relax);\n                }\n                // cout << dp[i][ship] << (ship == V ? \"\\n\" : \" \");\n            }\n        }\n\n        cout << dp[1][village[1]] << \"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <set>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a,S&&b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a,S&&b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nconst ll mod = 1000000007;\n#ifndef INT_MAX\nconst int INT_MAX = numeric_limits<signed>().max();\n#endif\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0>\n\t{\n\t\tstatic void apply(size_t& seed, Tuple const& tuple)\n\t\t{\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>>\n\t{\n\t\tsize_t\n\t\t\toperator()(std::tuple<TT...> const& tt) const\n\t\t{\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\n\t};\n}\null pow(ull base, ull i, ull mod) {\n\tull a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//????????§??????????????¢???????????????????????????rank???????????????size?????????\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a%b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\nint popcnt(unsigned long long a) {\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n}\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset;\n\t\tl += offset, r += offset;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (r);\n\t}\n\tvoid update(int k, T &a) {\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater_ = Func()) :obj(bufsize(n), e), e(e), updater(updater_) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\ttypename vector<T>::reference operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T>\nclass matrix {\n\tvector<vector<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, vector<T>(m == -1 ? n : m, e)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)\n\t\t\t\tfor (int k = 0; k < p.s.second; k++)ret[i][k] += obj[i][j] * p.obj[j][k];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tif (m < 0)\n\t\t\tfor (auto &a : obj)\n\t\t\t\tfor (auto &b : a)b = (b ? 1 : 0);\n\t\telse for (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\ttypename vector<vector<T>>::reference operator[](int t) {\n\t\treturn obj[t];\n\t}\n};\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned exp, T m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nclass Flow {\n\tint V;\n\tstruct edge { int to, cap, rev, cost; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tFlow(int size) :G(size + 1), V(size + 1) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost });\n\t}\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint max_flow(int s, int t) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tint flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, numeric_limits<int>::max()))>0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\tint res = 0;\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d*h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\n// Suffix Array\t?????????O(|S|log^2|S|), ????´¢O(|T|log|S|), ?????????????§????O(|S|)\nclass StringSearch {\n\tconst int n;\n\tstring S;\npublic:\n\tvector<int> sa, rank;\n\tStringSearch(const string &S_)\n\t\t: n(S_.size()), S(S_), sa(n + 1), rank(n + 1)\n\t{\n\t\tfor (int i = 0; i <= n; i++) {\n\t\t\tsa[i] = i;\n\t\t\trank[i] = i < n ? S[i] : -1;\n\t\t}\n\n\t\tvector<int> tmp(n + 1);\n\t\tfor (int k = 1; k <= n; k *= 2) {\n\t\t\tauto Compare_SA = [=](int i, int j) {\n\t\t\t\tif (this->rank[i] != this->rank[j]) return this->rank[i] < this->rank[j];\n\n\t\t\t\tint ri = i + k <= n ? this->rank[i + k] : -1;\n\t\t\t\tint rj = j + k <= n ? this->rank[j + k] : -1;\n\t\t\t\treturn ri < rj;\n\t\t\t};\n\t\t\tsort(sa.begin(), sa.end(), Compare_SA);\n\n\t\t\ttmp[sa[0]] = 0;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\ttmp[sa[i]] = tmp[sa[i - 1]] + (Compare_SA(sa[i - 1], sa[i]) ? 1 : 0);\n\t\t\t}\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tthis->rank[i] = tmp[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool Contain(const string &T) {\n\t\tint a = 0, b = n;\n\t\twhile (b - a > 1) {\n\t\t\tint c = (a + b) / 2;\n\t\t\tif (S.compare(sa[c], T.length(), T) < 0) a = c;\n\t\t\telse b = c;\n\t\t}\n\t\treturn S.compare(sa[b], T.length(), T) == 0;\n\t}\n\n\tvector<int> LCPArray() {\n\t\tfor (int i = 0; i <= n; i++) rank[sa[i]] = i;\n\n\t\tint h = 0;\n\t\tvector<int> lcp(n + 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint j = sa[rank[i] - 1];\n\n\t\t\tif (h > 0) h--;\n\t\t\tfor (; j + h < n && i + h < n; h++) {\n\t\t\t\tif (S[j + h] != S[i + h]) break;\n\t\t\t}\n\t\t\tlcp[rank[i] - 1] = h;\n\t\t}\n\t\treturn lcp;\n\t}\n};\nvi p;\nusing t = vector<pair<int, void*>>;\nvpii ki;\nt* c(int i) {\n\tif (ki.size() == i)return nullptr;\n\tt* a=new t(ki[i].second + 1);\n\trep(j, ki[i].second + 1) {\n\t\t(*a)[j].second = c(i + 1);\n\t}\n\treturn a;\n}\nvoid add(int k, int i, t* a) {\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second+0);\n\t(*a)[s].first++;\n\tif (i == ki.size() - 1) {\n\t\treturn;\n\t}\n\tadd(k, i + 1, (t*)((*a)[s].second));\n}\nll cnt(int k, int i, t*a) {\n\tll c = 0;\n\tint s = 0;\n\twhile (k%ki[i].first == 0)k /= ki[i].first, s++;\n\tcmin(s, ki[i].second + 0);\n\tif (i == ki.size() - 1) {\n\t\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += (*a)[j].first;\n\t\treturn c;\n\t}\n\tfor (int j = ki[i].second - s; j <= ki[i].second; j++)c += cnt(k, i + 1, (t*)((*a)[j].second));\n\treturn c;\n}\nint lw[200][200], sw[200][200];\nint dp[2][200];\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tfill(lw[0], lw[200], numeric_limits<int>::max() / 8);\n\t\tfill(sw[0], sw[200], numeric_limits<int>::max() / 8);\n\t\trep(i, n)lw[i][i] = 0;\n\t\trep(i, n)sw[i][i] = 0;\n\t\trep(i, m) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif (sl == 'L') {\n\t\t\t\tcmin(lw[x - 1][y - 1], t);\n\t\t\t\tcmin(lw[y - 1][x - 1], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcmin(sw[x - 1][y - 1], t);\n\t\t\t\tcmin(sw[y - 1][x - 1], t);\n\t\t\t}\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(lw[i][j], lw[i][k] + lw[k][j]);\n\t\t}\n\t\trep(k, n)rep(i, n)rep(j, n) {\n\t\t\tcmin(sw[i][j], sw[i][k] + sw[k][j]);\n\t\t}\n\t\tfill(dp[0], dp[1], numeric_limits<int>::max() / 8);\n\t\tint r;\n\t\tcin >> r;\n\t\tvi z(r);\n\t\trep(i, r)cin >> z[i];\n\t\tint prev = z[0] - 1;\n\t\tdp[0][z[0] - 1] = 0;\n\t\trep(i, r) {\n\t\t\tfill(dp[i & 1^1], dp[(i&1^1) + 1], numeric_limits<int>::max() / 8);\n\t\t\trep(j, n)rep(k, n) {\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][j] + sw[j][k] + lw[k][z[i] - 1]);\n\t\t\t\tcmin(dp[i & 1 ^ 1][k], dp[i & 1][j] + lw[prev][z[i] - 1]);\n\t\t\t}\n\t\t\tprev = z[i] - 1;\n\t\t}\n\t\tint ans = numeric_limits<int>::max() / 8;\n\t\trep(i, n)cmin(ans, dp[r & 1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\n\nconst int INF = 1e9;\n\nint solve(int N, VVI& land, VVI& sea, VI& z) {\n  // bellman-ford\n  REP(k, N) REP(i, N) REP(j, N) {\n    land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n    sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n  }\n\n  // dp[i][j]: i個目の配達を終えた時に船が町jにあるときの最短時間\n  VVI dp(z.size(), VI(N, INF));\n  dp[0][z[0]-1] = 0;\n  REP(i, z.size()-1) {\n    int from = z[i]-1;\n    int to = z[i+1]-1;\n    REP(j, N) {\n      REP(k, N) {\n        // z[i]からz[i+1]までの移動中に、船をjからkまで移動させる\n        if (land[from][j] != INF && sea[j][k] != INF && land[k][to] != INF) {\n          dp[i+1][k] = min(dp[i+1][k], \n              dp[i][j] + land[from][j] + sea[j][k] + land[k][to]);\n        }\n      }\n      // 陸路のみで、港に立ち寄らない場合\n      dp[i+1][j] = min(dp[i+1][j], dp[i][j] + land[from][to]);\n    }\n  }\n\n  return *min_element(dp[z.size()-1].begin(), dp[z.size()-1].end());\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while (true) {\n    int N, M; cin >> N >> M;\n    if (N == 0 && M == 0) break;\n\n    VVI land(N, VI(N, INF)), sea(N, VI(N, INF));\n    REP(i, N) {\n      land[i][i] = 0;\n      sea[i][i] = 0;\n    }\n    REP(i, M) {\n      int x, y, t; string sl;\n      cin >> x >> y >> t >> sl;\n      if (sl == \"L\") {\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      } else {\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }\n    }\n    int R; cin >> R;\n    vector<int> z(R);\n    REP(i, R) cin >> z[i];\n\n    int ans = solve(N, land, sea, z);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//C++14 (Clang 3.8.0)\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <string>\nusing namespace std;\ntypedef pair<int,int> P;\n\nconst int MAX_V=201;\nconst int inf=1e9;\nstruct edge{int to,cost;};\nclass maps{\n    public:\n    int land[MAX_V][MAX_V];\n    int sea[MAX_V][MAX_V];\n    int all[MAX_V][MAX_V];\n    int route[MAX_V];\n    bool x[MAX_V];\n    bool y[MAX_V];\n    int layship[MAX_V];\n    vector<int> port; \n    vector<int> isl; \n    void a(){\n        for(int k=0;k<MAX_V;k++){\n            for(int i=0;i<MAX_V;i++){\n                for(int j=0;j<MAX_V;j++)\n                    if(land[i][k]!=inf and land[k][j]!=inf) land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            }\n        }\n    }\n    void b(){\n        for(int k=0;k<MAX_V;k++){\n            for(int i=0;i<MAX_V;i++){\n                for(int j=0;j<MAX_V;j++)\n                    if(sea[i][k]!=inf and sea[k][j]!=inf) sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n            }\n        }\n    }\n\n    \n};\n\nint main(){\n    while(1){\n        int a,b;\n        cin>>a>>b;\n        if(a==0 and b==0) break;\n        maps map;\n        int dist[MAX_V][MAX_V][2];\n        for(int i=0;i<MAX_V;i++){\n            for(int j=0;j<MAX_V;j++){\n                if(i==j){map.sea[i][j]=0;map.land[i][j]=0;}\n                else {\n                    map.sea[i][j]=inf;map.sea[j][i]=inf;\n                    map.land[i][j]=inf;map.land[j][i]=inf;}\n\n                dist[i][j][0]=inf;\n                dist[i][j][1]=inf;\n\n            }\n        }\n\n        for(int i=0;i<b;i++){\n            int c,d,e;\n            char f;\n            cin>>c>>d>>e>>f;\n            c--;\n            d--;\n            \n            if(f=='L') {map.x[c]=true;map.x[d]=true;if(map.land[c][d]>e){map.land[c][d]=e;map.land[d][c]=e;}}\n            else {map.y[c]=true;map.y[d]=true;if(map.sea[c][d]>e){map.sea[c][d]=e;map.sea[d][c]=e;}}\n\n        }\n        \n        map.a();\n        map.b();\n        \n        for(int i=0;i<a;i++){\n            //if(map.x[i])isl.push_back(i);\n            if(map.y[i])map.port.push_back(i);\n            //cout<<\"sea\"<<i<<endl;\n\n        }\n\n        int r;\n        cin>>r;\n        for(int i=0;i<r;i++) {cin>>map.route[i];map.route[i]--;}\n        \n\n        dist[0][0][0]=0;\n        dist[0][0][1]=0;\n        for(int i=1;i<r-1;i++){\n            for(int j=0;j<map.port.size();j++){\n                //bool lfrom=map.x[route[i-1]],lto=map.x[route[i]],sfrom=map.y[route[i-1]],sto=map.y[route[i]];\n                int from=map.route[i-1],to=map.route[i],port2=map.port[j];\n\n                \n                for(int k=0;k<map.port.size();k++){\n                    int port1=map.port[k];\n                    //cout<<\"a\"<<port1<<to<<port2<<\" \"<<dist[i-1][port1][0]<<\" \"<<map.sea[port1][to]<<\" \"<<map.sea[to][port2]<<endl;\n                    if(dist[i-1][port1][0]!=inf and map.sea[port1][to]!= inf and  map.sea[to][port2] != inf){\n                        //cout<<\"a\"<<port1<<to<<port2<<endl;\n                        dist[i][port2][0] = min(dist[i][port2][0], dist[i-1][port1][0] + map.sea[port1][to] + map.sea[to][port2]);}\n\n                    if(dist[i-1][port1][0]!=inf and map.land[port1][to] != inf and  map.sea[port1][port2] != inf){\n                        //cout<<\"b\"<<endl;\n                        dist[i][port2][0] = min(dist[i][port2][0], dist[i-1][port1][0] + map.land[port1][to] * 2  + map.sea[port1][port2]);}\n\n                    if(dist[i-1][port1][1]!=inf and map.land[from][to] != inf and  map.land[to][port1] != inf and map.sea[port1][port2] != inf  ){\n                        //cout<<\"c\"<<endl;\n                        dist[i][port2][0] = min(dist[i][port2][0], dist[i-1][port1][1] + map.land[from][to] +map.land[to][port1]  + map.sea[port1][port2]);}\n\n                    if(dist[i][port1][0]!=inf and map.sea[port1][port2] != inf and  map.land[port2][to] != inf ){\n                        //cout<<\"d\"<<endl;\n                        dist[i][port2][1] = min(dist[i][port2][1], dist[i][port1][0] + map.sea[port1][port2] + map.land[port2][to]);}\n\n                    //cout<<i<<\" \"<<j<<\":\"<<dist[i][port2][0]<<\" \"<<dist[i][port2][1]<<\" \";\n\n                }\n                //cout<<to<<\" \"<<port2<<\":\"<<dist[i][port2][0]<<\" \"<<dist[i][port2][1]<<\" \";\n                //cout<<endl;\n            }\n        }\n        int i=r-1,ans=inf;\n        for(int j=0;j<map.port.size();j++){\n            int from=map.route[i-1],to=map.route[i],port2=map.port[j];\n            for(int k=0;k<map.port.size();k++){\n                int port1=map.port[k];\n                if(dist[i-1][port1][0]!=inf and map.sea[port1][to]!= inf){\n    \n                    ans = min(ans, dist[i-1][port1][0] + map.sea[port1][to]);\n                }\n    \n                if(dist[i-1][port1][0]!=inf and map.land[port1][to] != inf){\n    \n                    ans = min(ans, dist[i-1][port1][0] + map.land[port1][to]);\n                }\n    \n                if(dist[i-1][port1][1]!=inf and map.land[from][to] ){\n    \n                    ans = min(ans, dist[i-1][port1][1] + map.land[from][to]) ;\n                }\n                            \n                if(dist[i][port1][0]!=inf and map.sea[port1][port2] != inf and  map.land[port2][to] != inf ){\n                    ans = min(ans, dist[i][port1][0] + map.sea[port1][port2] + map.land[port2][to]);\n                }\n            }\n        }\n        cout<<ans<<endl;\n\n\n\n\n\n    }\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst int INF = (1<<21);\n\nclass State{\npublic:\n  int d,n,s;\n  State(int d = 0,int n = 0,int s = 0):d(d),n(n),s(s){}\n  bool operator < (const State &s) const { return d > s.d;}\n};\n\nclass State2{\npublic:\n  int d;\n  bool f;\n  State2(int d = INF,bool f = false):d(d),f(f){}\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m && n && m){\n    vector<vector<int> > L(n,vector<int>(n,INF)), S(n,vector<int>(n,INF));\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      char d;\n      cin >> a >> b >> c >> d;\n      a--;\n      b--;\n      if(d == 'L') L[a][b] = L[b][a] = c;\n      else S[a][b] = S[b][a] = c;\n    }\n    int n2;\n    cin >> n2;\n    vector<int> dest(n2);\n    for(int i=0;i<n2;i++){\n      cin >> dest[i];\n      dest[i]--;\n    }\n\n    vector<vector<int> > ans(2,vector<int>(n,INF));\n    ans[0][dest[0]] = 0;\n\n    for(int i=1;i<n2;i++){    \n      for(int j=0;j<n;j++){\n\tif(ans[0][j] >= INF) continue;\t\n\n\tpriority_queue<State> Q;\n\tState u(ans[0][j],dest[i-1],j), v;\n\tvector<vector<State2> > d(n,vector<State2>(n));\n\td[dest[i-1]][j] = ans[0][j];\n\tQ.push(u);\n\twhile(!Q.empty()){\n\t  u = Q.top();\n\t  Q.pop();\n\n\t  if(d[u.n][u.s].f) continue;\n\t  d[u.n][u.s].f = true;\n\n\t  for(int k=0;k<n;k++){\n\t    if(!d[k][u.s].f && d[u.n][u.s].d + L[u.n][k] < d[k][u.s].d){\n\t      v = u;\n\t      v.d = d[k][u.s].d = d[u.n][u.s].d + L[u.n][k];\n\t      v.n = k;\n\t      Q.push(v);\n\t    }\n\t    if(u.s == u.n){\n\t      if(!d[k][k].f && d[u.n][u.s].d + S[u.n][k] < d[k][k].d){\n\t\tv = u;\n\t\tv.d = d[k][k].d = d[u.n][u.s].d + S[u.n][k];\n\t\tv.s = v.n = k;\n\t\tQ.push(v);\n\t      }\n\t    }\n\t  }\n\t}\n\tfor(int k=0;k<n;k++) ans[1][k] = min(ans[1][k],d[dest[i]][k].d);\n      }\n      ans[0].assign(ans[1].begin(),ans[1].end());\n      //for(int j=0;j<n;j++) if(ans[0][j] != INF) cout << ans[0][j] << \" \";\n      ans[1].assign(n,INF);\n    }\n\n    int ans2 = INF;\n    for(int i=0;i<n;i++) ans2 = min(ans2,ans[0][i]);\n    cout << ans2 << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 250\n#define MAX_R 1050\n#define INF 1e8\n \nint G1[MAX][MAX], G2[MAX][MAX];\nint dp[MAX_R][MAX];\n \nint main(){\n  int N, M;\n \n  while(cin >> N >> M ,(N | M)){\n    fill(G1[0], G1[MAX], INF);\n    fill(G2[0], G2[MAX], INF);\n \n    int x, y, t;\n    char ch;\n    for(int i = 0 ; i < M ; i++){\n      cin >> x >> y >> t >> ch;\n      x--, y--;\n      if(ch == 'L'){\n        G1[x][y] = G1[y][x] = t;\n      }else{\n        G2[x][y] = G2[y][x] = t;\n      }\n    }\n     \n    for(int i = 0 ; i < N ; i++){\n      G1[i][i] = G2[i][i] = 0;\n    }\n     \n    for(int k = 0 ; k < N ; k++){\n      for(int i = 0 ; i < N ; i++){\n        for(int j = 0 ; j < N ; j++){\n          G1[i][j] = min(G1[i][j], G1[i][k]+G1[k][j]);\n          G2[i][j] = min(G2[i][j], G2[i][k]+G2[k][j]);\n        }\n      }\n    }\n \n    int R, z[MAX_R];\n    for(int i = 0 ; i < MAX_R ; i++){\n      for(int j = 0 ; j < MAX ; j++){\n        dp[i][j] = INF;\n      }\n    }\n \n    cin >> R;\n    for(int i = 0 ; i < R ; i++){\n      cin >> z[i]; z[i]--;\n    }\n \n    int now = z[0];\n    dp[0][now] = 0;\n    for(int r = 1 ; r < R ; r++){\n      int next = z[r];\n      for(int j = 0 ; j < N ; j++){\n        for(int i = 0 ; i < N ; i++){\n          dp[r][j] = min(dp[r][j], dp[r-1][i] + G1[now][i] + G2[i][j] + G1[j][next]);\n        }\n        dp[r][j]=min(dp[r][j], dp[r-1][j] + G1[now][next]);\n      }\n      now = next;\n    }\n \n    int ans = INF;\n    for(int i = 0 ; i < N ; i++){\n      ans = min(ans, dp[R-1][i]);\n    }\n    cout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nll dl[200][200], ds[200][200], dp[200], _dp[200];\n\nint main() {\n\tfor (;;) {\n\t\tint N, M; scanf(\"%d%d\", &N, &M);\n\t\tif (N == 0 && M == 0) break;\n\t\tfor (int u = 0; u < N; u++)\n\t\t\tfor (int v = 0; v < N; v++)\n\t\t\t\tdl[u][v] = ds[u][v] = (u == v) ? 0 : INT_MAX;\n\t\tfor (; M > 0; M--) {\n\t\t\tint x, y, t; char c; scanf(\"%d%d%d%*c%c\", &x, &y, &t, &c);\n\t\t\tif (c == 'L') {\n\t\t\t\tdl[x - 1][y - 1] = min(dl[x - 1][y - 1], (ll)t);\n\t\t\t\tdl[y - 1][x - 1] = min(dl[y - 1][x - 1], (ll)t);\n\t\t\t}\n\t\t\tif (c == 'S') {\n\t\t\t\tds[x - 1][y - 1] = min(ds[x - 1][y - 1], (ll)t);\n\t\t\t\tds[y - 1][x - 1] = min(ds[y - 1][x - 1], (ll)t);\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++)\n\t\t\tfor (int u = 0; u < N; u++)\n\t\t\t\tfor (int v = 0; v < N; v++) {\n\t\t\t\t\tdl[u][v] = min(dl[u][v], dl[u][k] + dl[k][v]);\n\t\t\t\t\tds[u][v] = min(ds[u][v], ds[u][k] + ds[k][v]);\n\t\t\t\t}\n\t\tint R; scanf(\"%d\", &R); R--;\n\t\tint _z; scanf(\"%d\", &_z); _z--;\n\t\tfill(dp, dp + N, INT_MAX); dp[_z] = 0;\n\t\tfor (; R > 0; R--) {\n\t\t\tswap(dp, _dp);\n\t\t\tint z; scanf(\"%d\", &z); z--;\n\t\t\tfor (int u = 0; u < N; u++) {\n\t\t\t\tdp[u] = min((ll)INT_MAX, _dp[u] + dl[_z][z]);\n\t\t\t\tfor (int _u = 0; _u < N; _u++)\n\t\t\t\t\tdp[u] = min(dp[u], _dp[_u] + dl[_z][_u] + ds[_u][u] + dl[u][z]);\n\t\t\t}\n\t\t\t_z = z;\n\t\t}\n\t\tll ans = INT_MAX;\n\t\tfor (int u = 0; u < N; u++)\n\t\t\tans = min(ans, dp[u]);\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# define _USE_MATH_DEFINES\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <unordered_set>\n# include <unordered_map>\n# include <climits>\n# include <complex>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <forward_list>\n# include <map>\n# include <stack>\nusing namespace std;\n# define MP make_pair\n# define INF ((int)(1<<25))\n# define REP(i,n) for(int i=0;i<(int)n;i++)\n# define FOR(i,n) REP(i,n)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define TORAD 2.0*M_PI/360.0\n# define INT(x) int x;cin>>x;\n# define STRING(x) string x;cin>>x;\n# define STR(x) STRING(x);\n# define DOUBLE(x) double x;cin>>x;\n# define DBL(x) DOUBLE(x); \n# define ALL(x) begin(x),end(x)\n# define RALL(x) (x).rbegin(),(x).rend()\n# define DEBUG(x) cout<<#x<<\":\"<<x<<endl\n# define INIT(a) memset(a,-1,sizeof a)\n# define CLR(a) memset(a,0,sizeof a)\n# define EPS 1e-12\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#endif\ntypedef long long lint;\ntypedef vector<bool> vb;\ntypedef vector<char> vc;\ntypedef vector<int> vi;\ntypedef vector<lint> vl;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\n//const int dx[4] = { 0,1,0,-1 }, dy[4] = { -1,0,1,0 };\n//const int M = 1000000007;\ntemplate<class T> void debug(T a) { for ( auto i : a )cout << i << endl; }\n\nstruct P\n{\n\tint now, ship, cost;\n\tP(int now, int ship, int cost) :now(now), ship(ship), cost(cost) {}\n\tbool operator<(const P &other)const { return cost < other.cost; }\n\tbool operator>(const P &other)const { return cost > other.cost; }\n};\n\nsigned main()\n{\n\twhile ( true )\n\t{\n\t\tint N, M;\n\t\tint SeaRoutes[201][201];\n\t\tint LandRoutes[201][201];\n\t\tint R;\n\t\tvi Destinations;\n\n\t\tcin >> N >> M;\n\t\tif ( N == 0 && M == 0 )break;\n\t\tFOR(i, 201)FOR(j, 201)SeaRoutes[i][j] = LandRoutes[i][j] = INF;\n\t\tFOR(i, M)\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tcin >> x >> y >> t >> sl;\n\t\t\tif ( sl == 'S' )\n\t\t\t{\n\t\t\t\tSeaRoutes[x][y] = min(SeaRoutes[x][y], t);\n\t\t\t\tSeaRoutes[y][x] = min(SeaRoutes[y][x], t);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLandRoutes[x][y] = min(LandRoutes[x][y], t);\n\t\t\t\tLandRoutes[y][x] = min(LandRoutes[y][x], t);\n\t\t\t}\n\t\t}\n\n\t\tcin >> R;\n\t\tFOR(i, R)\n\t\t{\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tDestinations.push_back(z);\n\t\t}\n\t\tFOR(k, 201)FOR(i, 201)FOR(j, 201)\n\t\t{\n\t\t\tSeaRoutes[i][j] = min(SeaRoutes[i][j], SeaRoutes[i][k] + SeaRoutes[k][j]);\n\t\t\tLandRoutes[i][j] = min(LandRoutes[i][j], LandRoutes[i][k] + LandRoutes[k][j]);\n\t\t}\n\n\t\tint Flags[201][201];\n\t\tvector<P> StartPoints(1, P(Destinations[0], Destinations[0], 0));\n\t\tint Score;\n\t\tFORI(r, 1, R)\n\t\t{\n\t\t\tINIT(Flags);\n\t\t\tpriority_queue< P, vector<P>, greater<P> > Queue(ALL(StartPoints));\n\t\t\tfor ( P StartPoint : StartPoints )\n\t\t\t\tFlags[StartPoint.now][StartPoint.ship] = StartPoint.cost;\n\t\t\tvector<P> Empty;\n\t\t\tswap(StartPoints, Empty);\n\t\t\tScore = INT_MAX;\n\t\t\twhile ( !Queue.empty() )\n\t\t\t{\n\t\t\t\tP CurrentPoint = Queue.top();\n\t\t\t\tQueue.pop();\n\t\t\t\tif ( CurrentPoint.now == Destinations[r] )\n\t\t\t\t{\n\t\t\t\t\tScore = min(Score, CurrentPoint.cost);\n\t\t\t\t\tStartPoints.push_back(CurrentPoint);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( CurrentPoint.now == CurrentPoint.ship )\n\t\t\t\t{\n\t\t\t\t\tFOR(i, N+1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif ( SeaRoutes[CurrentPoint.now][i] == INF )continue;\n\t\t\t\t\t\tP NextPoint = CurrentPoint;\n\t\t\t\t\t\tNextPoint.now = NextPoint.ship = i;\n\t\t\t\t\t\tNextPoint.cost += SeaRoutes[CurrentPoint.now][i];\n\t\t\t\t\t\tint* Flag = &Flags[NextPoint.now][NextPoint.ship];\n\t\t\t\t\t\tif ( *Flag == -1 || *Flag > NextPoint.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t*Flag = NextPoint.cost;\n\t\t\t\t\t\t\tQueue.push(NextPoint);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tFOR(i, N + 1)\n\t\t\t\t{\n\t\t\t\t\tif ( LandRoutes[CurrentPoint.now][i] == INF )continue;\n\t\t\t\t\tP NextPoint = CurrentPoint;\n\t\t\t\t\tNextPoint.now = i;\n\t\t\t\t\tNextPoint.cost += LandRoutes[CurrentPoint.now][i];\n\t\t\t\t\tint* Flag = &Flags[NextPoint.now][NextPoint.ship];\n\t\t\t\t\tif ( *Flag == -1 || *Flag > NextPoint.cost )\n\t\t\t\t\t{\n\t\t\t\t\t\t*Flag = NextPoint.cost;\n\t\t\t\t\t\tQueue.push(NextPoint);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Score << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/5\n\nint n,m,r;\nint dl[222][222];\nint ds[222][222];\nint dp[1111][222];\nint rs[1111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    rep(i,222)rep(j,222){\n      dl[i][j]=i==j?0:INF;\n      ds[i][j]=i==j?0:INF;\n    }\n    rep(i,1111)rep(j,222)dp[i][j]=INF;\n    rep(i,m){\n      int x,y,t; string sl;\n      cin>>x>>y>>t>>sl; x--; y--;\n      if(sl==\"L\"){\n        dl[x][y]=dl[y][x]=t;\n      }else{\n        ds[x][y]=ds[y][x]=t;\n      }\n    }\n    rep(k,n)rep(i,n)rep(j,n){\n      minch(dl[i][j],dl[i][k]+dl[k][j]);\n      minch(ds[i][j],ds[i][k]+ds[k][j]);\n    }\n    cin>>r;\n    rep(i,r){\n      cin>>rs[i];\n      rs[i]--;\n    }\n    dp[0][rs[0]]=0;\n    rep(i,r-1){\n      int crt=rs[i],nxt=rs[i+1];\n      rep(j,n){\n        minch(dp[i+1][j],dp[i][j]+dl[crt][nxt]);\n        if(crt==j){\n          rep(k,n)minch(dp[i+1][k],dp[i][j]+ds[crt][k]+dl[k][nxt]);\n        }\n        rep(k,n)minch(dp[i+1][k],dp[i][j]+dl[crt][j]+ds[j][k]+dl[k][nxt]);\n      }\n    }\n    int res=INF;\n    rep(j,n)minch(res,dp[r-1][j]);\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n){\n\t\tvector<vector<int>> dl(n,vector<int>(n,1e9));\n\t\tvector<vector<int>> ds(n, vector<int>(n,1e9));\n\t\tREP(i, n){\n\t\t\tdl[i][i] = 0;\n\t\t\tds[i][i] = 0;\n\t\t}\n\t\tREP(i, m){\n\t\t\tint u, v, t;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> t >> c;\n\t\t\tu--; v--;\n\t\t\tif (c == 'L'){\n\t\t\t\tdl[u][v] = t;\n\t\t\t\tdl[v][u] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tds[u][v] = t;\n\t\t\t\tds[v][u] = t;\n\t\t\t}\n\t\t}\n\t\tREP(i,n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n){\n\t\t\tdl[j][k] = min(dl[j][k], dl[j][i] + dl[i][k]);\n\t\t\tds[j][k] = min(ds[j][k], ds[j][i] + ds[i][k]);\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> goal(r);\n\t\tREP(i,r){\n\t\t\tcin >> goal[i];\n\t\t\tgoal[i]--;\n\t\t}\n\t\tvector<vector<int>> dp(r, vector<int>(n, 1e9));\n\t\tdp[0][goal[0]] = 0;\n\t\tFOR(i,1, r){\n\t\t\tREP(j, n){\n\t\t\t\tREP(k, n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k],dp[i - 1][j] + dl[goal[i - 1]][j] + ds[j][k] + dl[k][goal[i]]);\n\t\t\t\t\tif (j == k)dp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[goal[i - 1]][goal[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e9;\n\t\tREP(i, n)\n\t\t\tans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n  \nconst int INF=100000000;\n \nint main(){\n    while(1){\n        int n,m;\n        static int ld[202][202]; rep(i,202)rep(j,202){ if(i==j)ld[i][j]=0; else ld[i][j]=INF; }\n        static int sd[202][202]; rep(i,202)rep(j,202){ if(i==j)sd[i][j]=0; else sd[i][j]=INF; }\n          \n        scanf(\"%d%d\",&n,&m); if(n==0&&m==0)return 0;\n        rep(i,m){\n            int x,y,t; char sl;\n            scanf(\"%d%d%d %c\",&x,&y,&t,&sl);\n            if(sl=='L'){\n                ld[x][y]=t;\n                ld[y][x]=t;\n            }\n            else {\n                sd[x][y]=t;\n                sd[y][x]=t;\n            }\n        }\n          \n        rep1(k,n)rep1(i,n)rep1(j,n)ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n        rep1(k,n)rep1(i,n)rep1(j,n)sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n          \n        /*rep1(i,n){\n            rep1(j,n){\n                cout<<sd[i][j]<<\" \";\n            }\n            cout<<endl;\n        }*/\n          \n        int r,z[1002];\n        static int dp[1002][202]; rep(i,1002)rep(j,202)dp[i][j]=INF;\n          \n        scanf(\"%d\",&r);\n    \trep(i,r)scanf(\"%d\",&z[i]);\n        dp[0][z[0]]=0;\n          \n        rep1(i,r-1){\n            rep1(j,n){\n            \tdp[i][j]=min(dp[i][j],dp[i-1][j]+ld[z[i-1]][z[i]]);\n                if(ld[j][z[i]]!=INF){\n                    rep1(k,n){\n                        dp[i][j]=min(dp[i][j],dp[i-1][k]+ld[z[i-1]][k]+sd[k][j]+ld[j][z[i]]);\n                    }\n                }\n            }\n        }\n    \t\n    \tint ret=1000000000;\n    \trep1(i,n){\n    \t\tret=min(ret,dp[r-1][i]);\n    \t}\n          \n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e8;\nconst int maxq = 1024;\nconst int maxn = 255;\n\nint dp[maxq][maxn], l[maxn][maxn], s[maxn][maxn];\nint a[maxq];\nint n, m, q;\n\nvoid init() {\n    for(int k = 0; k < n; k ++) {\n        for(int i = 0; i < n; i ++) {\n            for(int j = 0; j < n; j ++) {\n                l[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n                s[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n            }\n        }\n    }\n}\n\nvoid solve() {\n    init();\n    for(int i = 0; i < q; i ++)\n        for(int j = 0; j < n; j ++)\n            dp[i][j] = INF;\n    for(int i = 0; i < n; i ++) \n        dp[0][i] = min(dp[0][i], s[a[0]][i] + l[i][a[0]]);\n    for(int i = 1; i < q; i ++) {\n        for(int j = 0; j < n; j ++) {\n            for(int k = 0; k < n; k ++) {\n                dp[i][j] = min(dp[i][j], dp[i-1][k] + l[a[i-1]][k] + s[k][j] + l[j][a[i]]);\n            }\n        }\n    }\n    int ans = INF;\n    for(int i = 0; i < n; i ++)\n        ans = min(ans, dp[q-1][i]);\n    printf(\"%d\\n\", ans);\n}\nint main() {\n    while(~scanf(\"%d%d\", &n, &m)) {\n        if(n==0 && m==0) break;\n        for(int i = 0; i < n; i ++) \n            for(int j = 0; j < n; j ++) \n                l[i][j] = s[i][j] = (i==j)?0:INF;\n        while(m --) {\n            int u, v, w; char o[2];\n            scanf(\"%d%d%d%s\", &u, &v, &w, o); u--, v--;\n            if(o[0] == 'L') l[u][v] = l[v][u] = min(l[u][v], w);\n            else s[u][v] = s[v][u] = min(s[u][v], w);\n        }   scanf(\"%d\", &q);\n        for(int i = 0; i < q; i ++) {\n            scanf(\"%d\" ,a+i);\n            a[i] --;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<functional>\nusing namespace std;\n\nstruct edge{\n\tint t,c;\n\tedge(int t,int c): t(t),c(c){}\n};\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\ntypedef pair<int,PP> PPP;\nconst int INF=1000000000;\nint ans;\nint n,m;\nint r;\nint cost[1000][200][200];\nvector<edge> l[200];\nvector<edge> s[200];\nint rt[1001];\n\nint dijk(){\n\tint res=INF;\n\tfor(int i=0;i<1000;i++){\n\t\tfor(int j=0;j<200;j++){\n\t\t\tfor(int k=0;k<200;k++){\n\t\t\t\tcost[i][j][k]=INF;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue< PPP , vector<PPP> , greater<PPP> > que;\n\tque.push(PPP(0,PP(0,P(0,0))));\n\twhile(que.size()){\n\t\tPPP p=que.top();que.pop();\n\t\t//nc=コスト、np=目的地、now=現在地、ns=現船位置\n\t\tint nc=p.first,np=p.second.first;\n\t\tint now=p.second.second.first,ns=p.second.second.second;\n\t\tif(now==rt[np] && np+1==r){\n\t\t\tres=min(res,nc);\n\t\t\tcontinue;\n\t\t}\n\t\tif(now==rt[np])np++;\n\t\tif(cost[np][now][ns]<nc)continue;\n\t\tfor(int i=0;i<l[now].size();i++){\n\t\t\tedge e=l[now][i];\n\t\t\tif(nc+e.c<cost[np][e.t][ns]){\n\t\t\t\tcost[np][e.t][ns]=nc+e.c;\n\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,ns))));\n\t\t\t}\n\t\t}\n\t\tif(ns==now){\n\t\t\tfor(int i=0;i<s[now].size();i++){\n\t\t\t\tedge e=s[now][i];\n\t\t\t\tif(nc+e.c<cost[np][e.t][e.t]){\n\t\t\t\t\tcost[np][e.t][e.t]=nc+e.c;\n\t\t\t\t\tque.push(PPP(nc+e.c,PP(np,P(e.t,e.t))));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(1){\n\t\tfor(int i=0;i<200;i++){\n\t\t\tl[i].clear();\n\t\t\ts[i].clear();\n\t\t}\n\t\tcin >> n >> m;\n\t\tif(n==0 && m==0)break;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,ti;\n\t\t\tstring ls;\n\t\t\tcin >> a >> b >> ti >> ls;\n\t\t\tif(ls==\"L\"){\n\t\t\t\tl[a-1].push_back(edge(b-1,ti));\n\t\t\t\tl[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t\tif(ls==\"S\"){\n\t\t\t\ts[a-1].push_back(edge(b-1,ti));\n\t\t\t\ts[b-1].push_back(edge(a-1,ti));\n\t\t\t}\n\t\t}\n\t\tcin >> r;\n\t\tfor(int i=0;i<r;i++){\n\t\t\tcin >> rt[i];\n\t\t\trt[i]--;\n\t\t}\n\t\tcout << dijk() << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int INF=1001001001001001LL;\nint N,M;\nint A[200][200],B[200][200];\nint dp[2][200];\nsigned main(){\n    while(cin>>N>>M,N||M){\n        fill_n(*A,200*200,INF);\n        fill_n(*B,200*200,INF);\n        for(int i=0;i<N;i++){\n            A[i][i]=0;\n            B[i][i]=0;\n        }\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            char d;\n            cin>>a>>b>>c>>d;\n            a--;b--;\n            if(d=='L')A[a][b]=A[b][a]=min(A[a][b],c);\n            else B[a][b]=B[b][a]=min(B[a][b],c);\n        }\n\n        for(int k=0;k<N;k++){\n            for(int i=0;i<N;i++){\n                for(int j=0;j<N;j++){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n\n        int R;cin>>R;\n        int prev;cin>>prev;prev--;\n        fill_n(*dp,2*200,INF);\n        dp[1][prev]=0;\n\n        for(int i=1;i<R;i++){\n            int cur;cin>>cur;cur--;\n            for(int j=0;j<N;j++){\n                for(int k=0;k<N;k++){\n                    if(A[prev][k]==INF||B[k][j]==INF||A[j][cur]==INF||dp[i&1][k]==INF)continue;\n                    dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+A[prev][k]+B[k][j]+A[j][cur]);\n                }\n            }\n            for(int j=0;j<N;j++)dp[i&1][j]=INF;\n            prev=cur;\n        }\n\n        int mi=INF;\n        for(int i=0;i<N;i++)mi=min(mi,dp[R&1][i]);\n\n        cout<<mi<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<iomanip>\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\ntypedef long long ll;\ntypedef ll Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<string> vs;\nDef inf = sizeof(Def) == sizeof(ll) ? 2e15:1e9+10;\n\n#include<complex>\ntypedef complex<double> P;\ntypedef vector<P> G;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\n\nstruct L: public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);push_back(b);\n\t}\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\nnamespace std{\n\tbool operator < (const P &a, const P &b){\n\t\treturn real(a) != real(b) ? real(a)<real(b) :imag(a)<imag(b);\n\t}\n\tbool operator == (const P &a, const P &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\n\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\n\nP projection(L a, P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\n\ndouble distanceLP(const L &l, const P &p){\n\treturn abs(p-projection(l,p));\n}\n\n\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\n\nvector<L> tangentCC(C a, C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L> l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\t\n\tif(abs(a.r-b.r)<d-EPS){\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\t\n\t}else if(abs(a.r-b.r)<d+EPS){\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\n\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n){\n\t\tvvi L(n,vi(n,inf));\n\t\tvvi S(n,vi(n,inf));\n\t\trep(i,n)L[i][i]=S[i][i]=0;\n\t\trep(i,m){\n\t\t\tint a,b,c;char d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\ta--;b--;\n\t\t\tif(d=='L')L[a][b]=L[b][a]=c;\n\t\t\tif(d=='S')S[a][b]=S[b][a]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t}\n\t\tint R;cin>>R;\n\t\tvi r(R);\n\t\trep(i,R)cin>>r[i];\n\t\trep(i,R)r[i]--;\n\t\tvvi dp(R,vi(n,inf));\n\t\tdp[0][0]=0;\n\t\trep(i,R-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[r[i]][r[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+L[r[i]][j]+S[j][k]+L[k][r[i+1]]);\n\t\t\t}\n\t\t}\n//\t\trep(i,R){rep(j,n)cout<<\" \"<<dp[i][j];cout<<endl;}\n\t\tll out=inf;\n\t\trep(i,n)out=min(out,dp[R-1][i]);\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n//#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 500000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\n/*struct edge{\n    int to,time;\n    bool land;\n    edge(int to,int ti,int l): to(to), time(ti), land(l) {}\n};*/\n\nint N,M,dL[210][210],dS[210][210],R,z[1010],dp[1010][1010];\n//vector<edge> G[210];\n\nint main(){\n\twhile(cin>>N>>M && N){\n        //rep(i,N)G[i].clear();\n        rep(i,N)rep(j,N) dL[i][j] = dS[i][j] = (i==j ? 0 : INF);\n    \n        rep(i,M){\n            int x,y,t;\n            char sl;\n            cin>>x>>y>>t>>sl;\n            x--; y--;\n            //G[x].pb(edge(y,t,sl=='L'));\n            //G[y].pb(edge(x,t,sl=='L'));\n            if(sl=='L') dL[x][y] = dL[y][x] = min(dL[x][y], t);\n            else dS[x][y] = dS[y][x] = min(dS[x][y], t);\n        }\n    \n        rep(k,N)rep(i,N)rep(j,N){\n            dL[i][j] = min(dL[i][j], dL[i][k] + dL[k][j]);\n            dS[i][j] = min(dS[i][j], dS[i][k] + dS[k][j]);\n        }\n    \n        cin>>R;\n        rep(i,R)cin>>z[i], z[i]--;\n    \n        rep(i,R)rep(j,N) dp[i][j]=INF;\n        dp[0][z[0]] = 0;\n    \n        rep2(i,1,R)rep(j,N)rep(k,N){\n            dp[i][k] = min(dp[i][k], dp[i-1][j] + dL[z[i-1]][j] + dS[j][k] + dL[k][z[i]]);\n        }\n    \n        int ans=INF;\n        rep(i,N)ans=min(ans,dp[R-1][i]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n//const long long int MOD = 1000003;\n//const int MOD = 998244353;\n//const long long int MOD = 998244353;\n\n//long long int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\twhile (cin >> N >> M, N) {\n\t\tvector<vector<long long int>>Ldis(N, vector<long long int>(N, MOD));\n\t\tvector<vector<long long int>>Sdis(N, vector<long long int>(N, MOD));\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tLdis[i][i] = Sdis[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> L >> R >> K;\n\t\t\tL--;\n\t\t\tR--;\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'L') {\n\t\t\t\tLdis[L][R] = K;\n\t\t\t\tLdis[R][L] = K;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSdis[L][R] = K;\n\t\t\t\tSdis[R][L] = K;\n\t\t\t}\n\t\t}\n\t\tfor (int k = 0; k < N; k++) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tLdis[i][j] = min(Ldis[i][j], Ldis[i][k] + Ldis[k][j]);\n\t\t\t\t\tSdis[i][j] = min(Sdis[i][j], Sdis[i][k] + Sdis[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> K;\n\t\tvector<int>v(K);\n\t\tfor (auto &i : v) {\n\t\t\tcin >> i;\n\t\t\ti--;\n\t\t}\n\t\tvector<vector<long long int>>dis(K, vector<long long int>(N, MOD*MOD));\n\t\tdis[0][v[0]] = 0;\n\t\tfor (int i = 1; i < K; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\tdis[i][k] = min(dis[i][k], dis[i - 1][j] + Ldis[v[i - 1]][j] + Sdis[j][k] + Ldis[k][v[i]]);\n\t\t\t\t}\n\t\t\t\tdis[i][j] = min(dis[i][j], dis[i - 1][j] + Ldis[v[i - 1]][v[i]]);\n\t\t\t}\n\t\t}\n\t\tlong long int ans = MOD * MOD;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tans = min(ans, dis.back()[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\n#define MP make_pair\n#define INF (sizeof(int) == 4 ? 1e9:1e18)\n#define EPS 0.0000000001\nusing namespace std;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\ntemplate<class T> void join(T a){int b=0;for(auto itr :a){if(b++!=0)cout << \" \"; cout << itr;} }\nusing ll  = long long;\nusing ld  = long double;\nusing pii = pair<int,int>;\nusing piii = pair<int,pii>;\nint W,H;\nint dx[]={0,0,1,-1}, dy[]={1,-1,0,0};\nbool valid(int x,int y){return (0<=x&&x<W)&&(0<=y&&y<H);}\n#define int ll\nsigned main(){\n    int n,m;\n    while(cin >> n >> m, n+m){\n        auto Ld = vectors(301,301,INF);\n        auto Sd = vectors(301,301,INF);\n        rep(i,n)Ld[i][i] = Sd[i][i] = 0;\n        rep(i,m){\n            int a,b,c; char s;\n            cin >> a >> b >> c >> s;\n            --a,--b;\n            if(s == 'L'){\n                cmin(Ld[a][b],c);\n                Ld[b][a] = Ld[a][b];\n            }else{\n                cmin(Sd[a][b], c);\n                Sd[b][a] = Sd[a][b];\n            }\n        }\n        rep(k,n)rep(i,n)rep(j,n){\n            cmin(Sd[i][j],Sd[i][k] + Sd[k][j]);\n            cmin(Ld[i][j],Ld[i][k] + Ld[k][j] );\n        }\n        int r; cin >> r;\n        vector<int>v;\n        rep(i,r){\n            int t; cin >> t;\n            v.push_back(--t);\n        }\n        auto dp = vectors(1000+1,300+1,INF);\n        dp[0][v[0]]=0;\n        rep(i,r-1){\n            rep(k,n){\n                cmin(dp[i+1][k],dp[i][k]+Ld[v[i]][v[i+1]]);\n                rep(j,n){\n                    cmin(dp[i+1][j],dp[i][k] + Ld[v[i]][k] + Sd[k][j] + Ld[j][v[i+1]]);\n                }\n            }\n        }\n        int ans = INF;\n        rep(i,n)cmin(ans,dp[r-1][i]);\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n\nconst int INF = 1 << 28;\n\nint main() {\n\tint n, m;\n\t\n\twhile ( cin >> n >> m, n | m ) {\n\t\tVVI L( n, VI( n, INF ) ),\n\t\t\tS( n, VI( n, INF ) );\n\t\t\n\t\tfor ( int i = 0; i < m; ++i ) {\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tcin >> x >> y >> t >> s;\n\t\t\t\n\t\t\tswitch ( s ) {\n\t\t\tcase 'L':\n\t\t\t\tL[x - 1][y - 1] = L[y - 1][x - 1] = min( t, L[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\tcase 'S':\n\t\t\t\tS[x - 1][y - 1] = S[y - 1][x - 1] = min( t, S[x - 1][y - 1] );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint r;\n\t\tcin >> r;\n\t\t\n\t\tVI Z( r, 0 );\n\t\t\n\t\tfor ( int i = 0; i < r; ++i ) {\n\t\t\tcin >> Z[i];\n\t\t\t--Z[i];\n\t\t}\n\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tL[i][i] = S[i][i] = 0;\n\t\t}\n\n\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\t\tL[i][j] = min( L[i][j], L[i][k] + L[k][j] );\n\t\t\t\t\tS[i][j] = min( S[i][j], S[i][k] + S[k][j] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tVVI d( r, VI( n, INF ) );\n\t\td[0][Z[0]] = 0;\n\t\tfor ( int i = 0; i + 1 < r; ++i ) {\n\t\t\tint from = Z[i], to = Z[i + 1];\n\t\t\t//d[i + 1][to] = min( d[i + 1][to], d[i][from] + S[from][to] );\n\t\t\tfor ( int j = 0; j < n; ++j ) {\n\t\t\t\td[i + 1][to] = min( d[i + 1][to], d[i][j] + L[from][j] + S[j][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][j] + L[from][to] );\n\t\t\t\td[i + 1][j] = min( d[i + 1][j], d[i][from] + S[from][j] + L[j][to] );\n\t\t\t\tfor ( int k = 0; k < n; ++k ) {\n\t\t\t\t\td[i + 1][k] = min( d[i + 1][k], d[i][k] + L[from][j] + S[j][k] + L[k][to] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = INF;\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tans = min( ans, d[r - 1][i] );\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\n\nint main(){\n  int n, m;\n  long long int INF = 1e14;\n  while(cin >> n >> m, n){\n    vector< vector<long long int> > L(n, vector<long long int>(n, INF)), S = L;\n    int x, y, t;\n    char s;\n    for(int i = 0; i < m; ++i){\n      cin >> x >> y >> t >> s;\n      --x;--y;\n      if(s == 'L'){\n        L[x][y] = t;\n        L[y][x] = t;\n      }else{\n        S[x][y] = t;\n        S[y][x] = t;\n      }\n    }\n    for(int i = 0; i < n; ++i){\n      S[i][i] = 0;\n      L[i][i] = 0;\n    }\n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n        for(int j = 0; j < n; ++j){\n          L[i][j] = min(L[i][j], L[i][k] + L[k][j]);\n          S[i][j] = min(S[i][j], S[i][k] + S[k][j]);\n        }\n      }\n    }\n    /*\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", L[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", S[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n    int r;\n    cin >> r;\n    vector<int> Z(r);\n    for(int i = 0; i < r; ++i){\n      cin >> Z[i];\n      --Z[i];\n    }\n    vector< vector<long long int> > DP(r, vector<long long int>(n,INF));\n    DP[0][Z[0]] = 0;\n    for(int i = 1; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        for(int k = 0; k < n; ++k){\n          DP[i][k] = min(DP[i][k], DP[i-1][j] + L[Z[i-1]][j] + S[j][k] + L[k][Z[i]]);\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < r; ++i){\n      for(int j = 0; j < n; ++j){\n        printf(\"%09d \", DP[i][j]);\n      }cout << endl;\n    }\n    cout << \"-------------------------------------\" << endl;\n    */\n\n    long long int ans = INF;\n    for(int i = 0; i < n; ++i) ans = min(ans, DP[r-1][i]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint dland[201][201], dsea[201][201], n, m, dp[1000][201];\n\nint x, y, t, r, z, rz;\nchar s;\n\nint main() {\n\n\twhile (cin>>n>>m&&n&&m) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tdland[i][j] = HINF;\n\t\t\t\tdsea[i][j] = HINF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdland[i][i] = 0; dsea[i][i] = 0;\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x >> y >> t >> s;\n\n\t\t\tif (s == 'L') {\n\t\t\t\tdland[x][y] = t;\n\t\t\t\tdland[y][x] = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsea[x][y] = t;\n\t\t\t\tdsea[y][x] = t;\n\t\t\t}\n\t\t}\n\n\t\tfor (int k = 1; k <= n; k++) {\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdland[i][j] = min(dland[i][j], dland[i][k] + dland[k][j]);\n\t\t\t\t\tdsea[i][j] = min(dsea[i][j], dsea[i][k] + dsea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tcin >> r >> rz;\n\n\t\tREP(i, 201)REP(j, 201)dp[i][j] = HINF;\n\t\tdp[0][rz] = 0;\n\n\n\t\tfor (int k = 1; k < r; k++) {\n\t\t\tcin >> z;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tdp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][j] + dsea[j][i] + dland[i][z]);\n\t\t\t\t\tif (i == j) dp[k][i] = min(dp[k][i], dp[k - 1][j] + dland[rz][z]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trz = z;\n\t\t}\n\n\t\tint ans = HINF;\n\t\tfor (int i = 1; i <= n; i++) ans = min(ans, dp[r - 1][i]);\n\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <numeric>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<((x))<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\n\nclass UnionFind {\npublic:\n  vector<int> par, rank; // parent(negative := its root and abs-value is its size), depth\n  UnionFind(int sz) : par(sz, -1), rank(sz, 0){}\n  int find(int x){\n    if(par[x]<0) return x;\n    else return par[x] = find(par[x]);\n  }\n  void unite(int x, int y){\n    x=find(x); y=find(y);\n    if(x==y) return;  // already belong to same tree\n    if(rank[x] < rank[y]){  // y becomes parent node\n      par[y] += par[x];\n      par[x] = y;\n    } else {  // x becomes parent node\n      par[x] += par[y];\n      par[y] = x;\n      if(rank[x]==rank[y]) rank[x]++;\n    }\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int size(int x){ return -par[find(x)]; }\n}; // END class UnionFind\n\nstruct edge{\n  int to, cost;\n  char type;\n};\n\ntypedef pair<int, int> P;\n\nint main(){\n  int n,m;\n  while(cin>>n>>m, n|m){\n    vector<vector<edge> > vec(n);\n    UnionFind uf(n);\n    rep(i,m){\n      int a,b,c; char d;\n      scanf(\"%d %d %d %c\", &a, &b, &c, &d);\n      a--; b--;\n      vec[a].pb((edge{b,c,d}));\n      vec[b].pb((edge{a,c,d}));\n      if(c=='L') uf.unite(a,b);\n    }\n\n    int r; cin>>r;\n    vector<int> route(r);\n    rep(i,r) scanf(\"%d\", &route[i]);\n    rep(i,r) route[i]--;\n\n    vector<int> d(n*n, INF);\n    d[route[0]*n+route[0]] = 0;\n    rep(i, r-1){\n      // route[i] -> route[i+1]\n      // ????????´???*N + ????????´??? ??§??????????????????\n      priority_queue<P, vector<P> ,greater<P>> pq;\n      rep(j,n){\n        int idx = route[i]*n + j;\n        if(d[idx]!=INF){\n          pq.push(mp(d[idx], idx));\n        }\n      }\n      rep(j,n)if(j!=route[i]) rep(k,n) d[j*n+k]=INF;\n      // <cost, pos*n + ship>\n      while(!pq.empty()){\n        P p = pq.top(); pq.pop();\n        if(p.fi > d[p.se]) continue;\n        int pos = p.se/n;\n        int ship= p.se%n;\n        for(auto e : vec[pos]){\n          int nxtp = e.to;\n          if(pos!=ship && e.type=='S') continue;\n          if(i!=r-2 && e.type=='L' && !uf.same(nxtp, route[i+1])) continue;\n          int nxtc = e.cost + p.fi;\n          int nxti = nxtp*n;\n          if(e.type=='S') nxti += e.to;\n          else nxti += ship;\n          if(nxtc < d[nxti]){\n            d[nxti] = nxtc;\n            pq.push(mp(nxtc, nxti));\n          }\n        }\n      }\n    }\n    int res = INF;\n    for(int i=route[r-1]*n; i<route[r-1]*n+n; i++) res = min(res,d[i]);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <queue>\n#include <cctype>\n#include <climits>\n#include <stack>\nusing namespace std;\n \nint n,m,r;\nconst int INF=1e7;\nint d[2][200][200],z[1000];\ntypedef pair<int,int> P;\n \nint main(){\n \n \n    while(scanf(\"%d %d\",&n,&m),n){\n\t    \n\t   for(int i=0;i<n;i++){\n\t\t  for(int j=0;j<n;j++) d[0][i][j]=d[1][i][j]=INF;\n\t\t  d[0][i][i]=d[1][i][i]=0;\n\t   }\n\t    \n\t   for(int i=0;i<m;i++){\n\t\t  int x,y,t;\n\t\t  char c;\n\t\t  scanf(\"%d %d %d %c\",&x,&y,&t,&c);\n\t\t  x--; y--;\n\t\t  \n\t\t  d[c=='L'][x][y]=min(d[c=='L'][x][y],t);\n\t\t  d[c=='L'][y][x]=min(d[c=='L'][y][x],t);\n\t   }\n\t    \n\t   for(int k=0;k<n;k++){\n\t\t  for(int i=0;i<n;i++){\n\t\t\t for(int j=0;j<n;j++){\n\t\t\t\td[0][i][j]=min(d[0][i][j],d[0][i][k]+d[0][k][j]);\n\t\t\t\td[1][i][j]=min(d[1][i][j],d[1][i][k]+d[1][k][j]);\n\t\t\t }\n\t\t  }\n\t   }\n\t    \n\t   scanf(\"%d\",&r);\n\t   for(int i=0;i<r;i++){\n\t\t  scanf(\"%d\",&z[i]);\n\t\t  z[i]--;\n\t   }\n\t    \n\t   vector<vector<int> > dp(1000,vector<int>(200,INF));\n\t   dp[0][z[0]]=0;\n \n\t   int res=INF;\n\t   for(int i=1;i<r;i++){\n\t\t  for(int j=0;j<n;j++){\n\t\t\t\t\t\t    \n\t\t\t for(int k=0;k<n;k++){\n\t\t\t\tdp[i][k]=min(dp[i][k],dp[i-1][j]+d[1][z[i-1]][j]+d[0][j][k]+d[1][k][z[i]]);\n\t\t\t }\n\t\t\t dp[i][j]=min(dp[i][j],dp[i-1][j]+d[1][z[i-1]][z[i]]);\n\t\t  }\n\t   }\n \n\t   printf(\"%d\\n\",*min_element(dp[r-1].begin(),dp[r-1].end()));\n\t    \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<tuple>\n#include<queue>\n#include<functional>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define MAX_N 202\n#define MAX_R 1002\n#define INF 131211109876543210LL\n\npriority_queue<tuple<long long, long long, long long>, vector<tuple<long long, long long, long long>>, greater<tuple<long long, long long, long long>>> Q;\nvector<tuple<long long, long long, int>> X[MAX_N];\nstring A4;\nint N, M, R;\nlong long A1, A2, A3;\nlong long travel[MAX_R];\nlong long DIST[MAX_N][MAX_N];\nlong long COLOR[MAX_N][MAX_N];\n\nvoid dijkstra(long long st) {\n\twhile (!Q.empty()) {\n\t\ttuple<long long, long long, long long>tup = Q.top();\n\t\tlong long a1 = get<0>(tup);\n\t\tlong long a2 = get<1>(tup);\n\t\tlong long a3 = get<2>(tup);\n\t\tCOLOR[a2][a3] = BLACK;\n\t\tQ.pop();\n\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long a4 = get<0>(X[a2][i]);\n\t\t\tlong long a5 = get<1>(X[a2][i]);\n\t\t\tlong long a6 = get<2>(X[a2][i]);\n\n\t\t\tif (a6 == 0) {\n\t\t\t\tlong long a7 = a1 + a5;\n\t\t\t\tif (DIST[a4][a3] > a7 && COLOR[a4][a3] != BLACK) {\n\t\t\t\t\tDIST[a4][a3] = a7;\n\t\t\t\t\tCOLOR[a4][a3] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a3], a4, a3));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a6 == 1 && a2 == a3) {\n\t\t\t\tlong long a8 = a1 + a5;\n\t\t\t\tif (DIST[a4][a4] > a8 && COLOR[a4][a4] != BLACK) {\n\t\t\t\t\tDIST[a4][a4] = a8;\n\t\t\t\t\tCOLOR[a4][a4] = GRAY;\n\t\t\t\t\tQ.push(make_tuple(DIST[a4][a4], a4, a4));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n}\n\nlong long dijkstra1() {\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = INF;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tDIST[travel[0]][travel[0]] = 0;\n\tCOLOR[travel[0]][travel[0]] = 0;\n\tfor (int i = 0; i < R - 1; i++) {\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\tif (j != travel[i]) {\n\t\t\t\t\tDIST[j][k] = INF;\n\t\t\t\t\tCOLOR[j][k] = WHITE;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tCOLOR[j][k] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int j = 1; j <= N; j++) {\n\t\t\tQ.push(make_tuple(DIST[travel[i]][j], travel[i], j));\n\t\t}\n\n\t\tdijkstra(travel[i]);\n\t}\n\tlong long RES = INF;\n\tfor (int i = 1; i <= N; i++) {\n\t\tRES = min(RES, DIST[travel[R - 1]][i]);\n\t}\n\treturn RES;\n}\n\nvoid _memset() {\n\tN = 0; M = 0; R = 0; A1 = 0; A2 = 0; A3 = 0; A4 = \"\";\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tfor (int j = 0; j < MAX_N; j++) {\n\t\t\tDIST[i][j] = 0;\n\t\t\tCOLOR[i][j] = WHITE;\n\t\t}\n\t}\n\tfor (int i = 0; i < MAX_R; i++) {\n\t\ttravel[i] = 0;\n\t}\n\tfor (int i = 0; i < MAX_N; i++) {\n\t\tX[i].clear();\n\t}\n\twhile (!Q.empty()) {\n\t\tQ.pop();\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\t_memset();\n\t\tcin >> N >> M;\n\t\tif (M >= 10000) { return 0; }\n\t\tif (N == 0 && M == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tcin >> A1 >> A2 >> A3 >> A4;\n\t\t\tif (A4 == \"L\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 0));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 0));\n\t\t\t}\n\t\t\tif (A4 == \"S\") {\n\t\t\t\tX[A1].push_back(make_tuple(A2, A3, 1));\n\t\t\t\tX[A2].push_back(make_tuple(A1, A3, 1));\n\t\t\t}\n\t\t}\n\t\tcin >> R;\n\t\tfor (int i = 0; i < R; i++) {\n\t\t\tcin >> travel[i];\n\t\t}\n\t\tcout << dijkstra1() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\nconst LL INF = (LL)1e9 + 7;\nint main(){\n\twhile (1){\n\t\tint N, M;\n\t\tcin >> N >> M;\n\t\tif (N + M == 0)return 0;\n\t\tVVLL umi(N + 1, VLL(N + 1, INF)), riku(N + 1, VLL(N + 1, INF));\n\t\tfor (int i = 1; i < N+1; i++){\n\t\t\tumi[i][i] = riku[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; i++){\n\t\t\tLL x, y, t; char c;\n\t\t\tcin >> x >> y >> t >> c;\n\t\t\tif (c == 'L')riku[x][y] = riku[y][x] = min(riku[x][y], t);\n\t\t\telse umi[x][y] = umi[y][x] = min(umi[x][y], t);\n\t\t}\n\t\tfor (int k = 1; k < N + 1; k++)for (int i = 1; i < N + 1; i++)for (int j = 1; j < N + 1; j++){\n\t\t\triku[i][j] = min(riku[i][j], riku[i][k] + riku[k][j]);\n\t\t\tumi[i][j] = min(umi[i][j], umi[i][k] + umi[k][j]);\n\t\t}\n\t\tint R;\n\t\tcin >> R;\n\t\tVLL pos(R + 1);\n\t\tfor (int i = 1; i < R+1; i++){\n\t\t\tcin >> pos[i];\n\t\t}\n\t\tVVLL dp(R + 1, VLL(N + 1, INF));\n\t\tdp[1][pos[1]] = 0;\n\t\tfor (int i = 2; i < R+1; i++){\n\t\t\tfor (int x = 1; x < N+1; x++){\n\t\t\t\tdp[i][x] = dp[i - 1][x] + riku[pos[i - 1]][pos[i]];\n\t\t\t\tfor (int y = 1; y < N+1; y++){\n\t\t\t\t\tdp[i][x] = min(dp[i][x],dp[i-1][y] + riku[pos[i-1]][y] + umi[y][x] + riku[x][pos[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tLL res = INF;\n\t\tfor (int i = 1; i < N + 1; i++)\n\t\t\tres = min(dp[R][i], res);\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nconst int INF=123456789;\n\nint n,m;\nint R;\nint z[1001];\n\nint ld[200][200],sd[200][200];\n\nvector<int> island[200];\nint island_idx;\nint island_id[200];\n\nll dp[1001][200];\n\nvoid init()\n{\n    fill(ld[0],ld[200],INF);\n    fill(sd[0],sd[200],INF);\n    rep(i,200) island[i].clear();\n    island_idx=0;\n    fill(island_id,island_id+200,-1);\n    fill(dp[0],dp[1001],10000LL*INF);\n}\n\n\nint main()\n{\n    while(scanf(\" %d %d\",&n,&m),n)\n    {\n        init();\n\n        // input\n        rep(i,m)\n        {\n            int x,y,t;\n            char sl;\n            scanf(\" %d %d %d %c\",&x,&y,&t,&sl);\n            --x;\n            --y;\n            if(sl=='L') ld[x][y]=ld[y][x]=min(ld[x][y],t);\n            else sd[x][y]=sd[y][x]=min(sd[x][y],t);\n        }\n        scanf(\" %d\",&R);\n        rep(i,R)\n        {\n            scanf(\" %d\",&z[i]);\n            --z[i];\n        }\n\n        // Warshall-Floyd\n        rep(i,n)\n        {\n            ld[i][i]=0;\n            sd[i][i]=0;\n        }\n        rep(k,n)rep(i,n)rep(j,n)\n        {\n            ld[i][j]=min(ld[i][j],ld[i][k]+ld[k][j]);\n            sd[i][j]=min(sd[i][j],sd[i][k]+sd[k][j]);\n        }\n\n        // determine the island i-th town belongs\n        rep(i,n)\n        {\n            if(island_id[i]!=-1) continue;\n\n            island_id[i]=island_idx;\n            rep(j,n) if(ld[i][j]<INF) island_id[j]=island_idx;\n\n            ++island_idx;\n        }\n        rep(i,n) island[island_id[i]].pb(i);\n\n        // calc ans\n        dp[0][z[0]]=0;\n        for(int i=1; i<R; ++i)\n        {\n            int p_id=island_id[z[i-1]], c_id=island_id[z[i]];\n            if(p_id==c_id)\n            {\n                rep(j,island[p_id].size())\n                {\n                    int boat=island[p_id][j];\n                    dp[i][boat] = min(dp[i][boat], dp[i-1][boat]+ld[z[i-1]][z[i]]);\n                }\n            }\n            rep(j,island[p_id].size())rep(k,island[c_id].size())\n            {\n                int now_b=island[p_id][j], nx_b=island[c_id][k];\n                dp[i][nx_b] = min(dp[i][nx_b], dp[i-1][now_b]+ld[z[i-1]][now_b]+sd[now_b][nx_b]+ld[nx_b][z[i]]);\n            }\n        }\n\n        ll ans=10000LL*INF;\n        rep(i,n) ans=min(ans,dp[R-1][i]);\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define REP(i,n) for(ll i = 0; i < (n); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,e) for (ll i = s; i < (ll)e; i++)\n#define TEN(x) ((ll)1e##x)\n\ntemplate <class COST>\nvoid warshall_floyd(vector<vector<COST>> &cost) { // cost[n][n]\n\tint n = cost.size();\n\tREP(k, n) REP(i, n) REP(j, n) cost[i][j] = min(cost[i][j], cost[i][k] + cost[k][j]);\n}\n\nint main() {\n#ifdef _WIN32\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0); // cin??¨cout?????£????????????\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\twhile (true) {\n\t\tll n, m; cin >> n >> m;\n\t\tif (n == 0) break;\n\t\tconst ll MAX = 200000000ll;\n\t\tvvl path_l(n, vl(n, MAX));\n\t\tvvl path_s(n, vl(n, MAX));\n\t\tREP(i, m) {\n\t\t\tll x, y, t; char sl;\n\t\t\tcin >> x >> y >> t >> sl; x--; y--;\n\t\t\t(sl == 'L' ? path_l : path_s)[x][y] = t;\n\t\t\t(sl == 'L' ? path_l : path_s)[y][x] = t;\n\t\t}\n\t\tREP(i, n) {\n\t\t\tpath_l[i][i] = 0;\n\t\t\tpath_s[i][i] = 0;\n\t\t}\n\t\twarshall_floyd(path_l);\n\t\twarshall_floyd(path_s);\n\n\t\tll r; cin >> r;\n\t\tvl z(r); REP(i, r) { cin >> z[i]; z[i]--; }\n\n\t\tvvl dp(r, vl(n, MAX)); dp[0][z[0]] = 0;\n\t\tREP(i, r - 1) REP(j, n) REP(k, n) {\n\t\t\tll dist = (j == k ? path_l[z[i]][z[i + 1]] : path_l[z[i]][j] + path_s[j][k] + path_l[k][z[i + 1]]);\n\t\t\tdp[i + 1][k] = min(dp[i + 1][k], dp[i][j] + dist);\n\t\t}\n\n\t\tll ans = MAX;\n\t\tREP(i, n) ans = min(ans, dp[r - 1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nint main() {\n\tint n, m;\n\tstd::cin >> n >> m;\n\twhile (n != 0 && m != 0) {\n\t\tstd::vector<std::vector<int>> on_land(n, std::vector<int>(n, 1000 * n));\n\t\tstd::vector<std::vector<int>> on_ship(n, std::vector<int>(n, 1000 * n));\n\t\t{\n\t\t\tint x, y, t;\n\t\t\tchar s;\n\t\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\t\ton_land[i][i] = on_ship[i][i] = 0;\n\t\t\t}\n\t\t\tfor (auto i = 0; i < m; ++i) {\n\t\t\t\tstd::cin >> x >> y >> t >> s;\n\t\t\t\tswitch (s) {\n\t\t\t\tcase 'L': \n\t\t\t\t\tif (on_land[x - 1][y - 1] > t) {\n\t\t\t\t\t\ton_land[x - 1][y - 1] = on_land[y - 1][x - 1] = t;\n\t\t\t\t\t}\n\t\t\t\t\t\t  break;\n\t\t\t\tdefault:\n\t\t\t\t\tif (on_ship[x - 1][y - 1] > t) {\n\t\t\t\t\t\ton_ship[x - 1][y - 1] = on_ship[y - 1][x - 1] = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto mid = 0; mid < n; ++mid) for (auto from = 0; from < n; ++from) for (auto to = from + 1; to < n; ++to) {\n\t\t\t\tif (on_land[from][mid] + on_land[mid][to] < on_land[from][to])\n\t\t\t\t\ton_land[from][to] = on_land[to][from] = on_land[from][mid] + on_land[mid][to];\n\t\t\t\tif (on_ship[from][mid] + on_ship[mid][to] < on_ship[from][to])\n\t\t\t\t\ton_ship[from][to] = on_ship[to][from] = on_ship[from][mid] + on_ship[mid][to];\n\t\t\t}\n\t\t}\n\t\tstd::vector<int> vec_a(n, 1000 * n);\n\t\tstd::vector<int> vec_b(n, 1000 * n);\n\t\tint r, from, to;\n\t\tstd::cin >> r;\n\t\tauto *from_vec = &vec_a;\n\t\tauto *to_vec = &vec_b;\n\t\tstd::cin >> from;\n\t\tvec_a[from - 1] = 0;\n\t\tfor (auto i = 1; i < r; ++i) {\n\t\t\tstd::cin >> to;\n\t\t\tfor (auto ship_from = 0; ship_from < n; ++ship_from) {\n\t\t\t\tif ((*to_vec)[ship_from] > (*from_vec)[ship_from] + on_land[from - 1][to - 1])\n\t\t\t\t\t(*to_vec)[ship_from] = (*from_vec)[ship_from] + on_land[from - 1][to - 1];\n\t\t\t\tfor (auto ship_to = 0; ship_to < n; ++ship_to) {\n\t\t\t\t\tif ((*to_vec)[ship_to] > (*from_vec)[ship_from] + on_land[from - 1][ship_from] + on_ship[ship_from][ship_to] + on_land[ship_to][to - 1])\n\t\t\t\t\t\t(*to_vec)[ship_to] = (*from_vec)[ship_from] + on_land[from - 1][ship_from] + on_ship[ship_from][ship_to] + on_land[ship_to][to - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\tauto temp = to_vec;\n\t\t\tto_vec = from_vec; from_vec = temp;\n\t\t\tfor (auto &vec : (*to_vec)) vec = 1000 * n;\n\t\t\tfrom = to;\n\t\t}\n\t\tint min = 1000 * n;\n\t\tfor (const auto v : (*from_vec)) {\n\t\t\tif (min > v) min = v;\n\t\t}\n\t\tstd::cout << min << std::endl;\n\t\tstd::cin >> n >> m;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<map>\n\nusing namespace std;\n\nconst int INF=100000000;\n\n\nclass Node{\npublic:\n\tint now_mission,ship,sum;\n\tNode(int now_mission,int ship,int sum):now_mission(now_mission),ship(ship),sum(sum){};\n};\n\nbool operator < (Node a,Node b){\n\treturn a.sum>b.sum;\n}\n\n\nint main()\n{\n\tint N,M;\n\twhile(cin>>N>>M && N!=0){\n\t\tvector<vector<int> > dist_ground(N,vector<int>(N,INF));\n\t\tvector<vector<int> > dist_sea(N,vector<int>(N,INF));\n\n\t\tfor(int i=0;i<M;i++){\n\t\t\tint x,y,t; char c;\n\t\t\tcin>>x>>y>>t>>c;\n\t\t\tx--;y--;\n\t\t\tif(c=='L'){\n\t\t\t\tdist_ground[x][y]=min(dist_ground[x][y],t);\n\t\t\t\tdist_ground[y][x]=min(dist_ground[y][x],t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdist_sea[x][y]=min(dist_sea[x][y],t);\n\t\t\t\tdist_sea[y][x]=min(dist_sea[y][x],t);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tdist_sea[i][i]=dist_ground[i][i]=0;\n\t\t}\n\t\tint R;cin>>R;\n\t\tvector<int> mission(R);\n\t\tfor(int i=0;i<R;i++){cin>>mission[i];mission[i]--;}\n\n\t\tvector<vector<int> > cost_sea(N,vector<int>(N,INF));\n\t\tvector<vector<int> > cost_ground(N,vector<int>(N,INF));\n\t\t\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfor(int z=0;z<N;z++){\n\t\t\t\t\tcost_sea[i][z]=min(cost_sea[i][z],dist_sea[i][j]+dist_sea[j][z]);\n\t\t\t\t\tcost_ground[i][z]=min(cost_ground[i][z],dist_ground[i][j]+dist_ground[j][z]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\n\n\t\tpriority_queue<Node> que;\n\t\tvector<vector<int> > memo(R,vector<int>(N,INF));\n\t\tque.push(Node(0,mission[0],0));\n\t\twhile(!que.empty()){\n\t\t\tNode info=que.top(); que.pop();\n\t\t\tif(info.sum>=memo[info.now_mission][info.ship]) continue;\n//\t\t\tcout<<\"now \"<<info.now_mission<<\" \"<<info.ship<<\" \"<<info.sum<<endl;\n\t\t\tmemo[info.now_mission][info.ship]=info.sum;\n\n\t\t\tif(info.now_mission==R-1){cout<<info.sum<<endl;break;}\n\t\t\tint target=mission[info.now_mission+1];\n\n\t\t\tfor(int relay=0;relay<N;relay++){\n\t\t\t\tint now_area=mission[info.now_mission];\n\t\t\t\tint next_cost=cost_ground[now_area][info.ship]+cost_sea[info.ship][relay]+cost_ground[relay][target];\n\t\t\t\tque.push(Node(info.now_mission+1,relay,info.sum+next_cost));\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include    <iostream>\n#include    <cstdio>\n#include    <cstdlib>\n#include    <algorithm>\n#include    <vector>\n#include    <cstring>\n#include    <queue>\n#include    <complex>\n#include    <stack>\n#define LL long long\n#define dob double\nusing namespace std;\n\nconst int N = 210;\nconst int R = 1010;\nconst int Inf = 1<<28;\nint n,m,Q,land[N][N],sea[N][N],f[R][N],Cit[R],Ans;\n\ninline int gi(){\n  int x=0,res=1;char ch=getchar();\n  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}\n  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n  return x*res;\n}\n\nmain()\n{\n  /*freopen(\"Mr._Rito_Post_Office .in\",\"r\",stdin);\n    freopen(\"Mr._Rito_Post_Office .out\",\"w\",stdout);*/\n  while(1){\n    n=gi();m=gi();\n    if(n+m==0)break;\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)\n        land[i][j]=sea[i][j]=Inf;\n    for(int i=1;i<=n;++i)\n      land[i][i]=sea[i][i]=0;\n    for(int i=1;i<=m;++i){\n      int u=gi(),v=gi(),c=gi();\n      char type;scanf(\"%c\",&type);\n      if(type=='L')\n        land[u][v]=land[v][u]=min(land[u][v],c);\n      else sea[u][v]=sea[v][u]=min(sea[u][v],c);\n    }\n    for(int i=1;i<=n;++i)\n      for(int j=1;j<=n;++j)\n        for(int k=1;k<=n;++k)\n          /*if(i!=j && i!=k && j!=k)*/{\n            land[i][j]=min(land[i][j],land[i][k]+land[k][j]);\n            sea[i][j]=min(sea[i][j],sea[i][k]+sea[k][j]);\n          }\n    Q=gi();\n    for(int i=0;i<=Q;++i)\n      for(int j=0;j<=n;++j)\n        f[i][j]=Inf;Ans=Inf;\n    for(int i=1;i<=Q;++i)Cit[i]=gi();\n    f[1][Cit[1]]=0;\n    for(int i=2;i<=Q;++i)\n      for(int j=1;j<=n;++j){\n        f[i][j]=min(f[i][j],f[i-1][j]+land[Cit[i-1]][Cit[i]]);\n        for(int k=1;k<=n;++k)\n          f[i][j]=min(f[i][j],f[i-1][k]+land[Cit[i-1]][k]+sea[j][k]+land[j][Cit[i]]);\n      }\n    for(int i=1;i<=n;++i)\n      Ans=min(Ans,f[Q][i]);\n    printf(\"%d\\n\",Ans);\n  }\n  \n  /*fclose(stdin);\n    fclose(stdout);*/\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF (1LL<<50)\n#define s second\n#define f first\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll>P;\ntypedef pair<ll,P> PP;\nll G[200][200][2];\nint n,m,r,z[1000];\n\nvoid WF(){\n  for(int k=0;k<n;k++)\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++){\n\tG[i][j][0]=min(G[i][j][0],G[i][k][0]+G[k][j][0]);\n\tG[i][j][1]=min(G[i][j][1],G[i][k][1]+G[k][j][1]);\n      }\n}\n\n\nll dijkstra(){\n  vector<vector<ll> > D(n,vector<ll>(r,INF));\n  vector<vector<int> > used(n,vector<int>(r,0));\n  priority_queue<PP,vector<PP>,greater<PP> > Q;\n  Q.push(PP(0,P(z[0],0)));\n  D[z[0]][0] = 0;\n\n  while(!Q.empty()){\n    PP t=Q.top();Q.pop();\n    ll cost=t.f,ship=t.s.f,idx=t.s.s,pos=z[idx];\n    if(cost>INT_MAX)assert(0);\n    if(idx==r-1)return cost;\n    if(used[ship][idx]++) continue;\n    \n    int npos=z[idx+1];\n    ll ncost=cost+G[pos][npos][0];\n    if(D[ship][idx+1]>ncost)Q.push(PP(ncost,P(ship,idx+1)));\n    if(pos==ship)\n      for(int i=0;i<n;i++){\n\tncost=cost+G[pos][i][1]+G[i][npos][0];\n\tif(D[i][idx+1]>ncost)Q.push(PP(ncost,P(i,idx+1)));\n      }\n  }\n\n} \n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++) \n      for(int j=0;j<n;j++) G[i][j][0]=G[i][j][1]=INF*(i!=j);\n    \n    for(int i=0,x,y,c,idx;i<m;i++){\n      char ch;\n      cin>>x>>y>>c>>ch;x--,y--;\n      idx=(ch=='S');\n      G[x][y][idx]=G[y][x][idx]=min(G[x][y][idx],(ll)c);\n    }\n    cin>>r;\n    for(int i=0;i<r;i++)cin>>z[i],z[i]--;\n    WF();\n    cout <<dijkstra()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing vs=vector<string>;\n#define rep(i,n) range(i,0,n)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define LINF    \t((ll)1ll<60)\n#define INF     \t((int)1<<30)\n#define EPS     \t(1e-9)\n#define MOD     \t(1000000007)\n#define fcout(a)\tcout<<setprecision(a)<<fixed\n#define fs \t\t\tfirst\n#define sc\t\t\tsecond\n#define PI\t\t\t3.141592653589793\n\ntemplate<class S,class T>ostream& operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s; a=0;} return os;}\n\nint n,m,r;\nvi route;\nvvi L,S;\n\nint solve(){\n    vvi dp(r,vi(n,INF));\n    dp[0][route[0]]=0;\n        //i番目の集配が終了した時点で、頂点jに船を乗り捨てているときの累計コスト\n    rep(p,r-1){\n        int s=route[p],t=route[p+1];\n        rep(i,n)rep(j,n){\n            //cout<<s<<\"->\"<<i<<\"->\"<<j<<\"->\"<<t<<endl;\n            //cout<<vi{dp[p][i],L[s][i],S[i][j],L[j][t]}<<endl;\n            if(dp[p][i]!=INF and L[s][i]!=INF and S[i][j]!=INF and L[j][t]!=INF){\n                dp[p+1][j]=min(dp[p+1][j],dp[p][i]+L[s][i]+S[i][j]+L[j][t]);\n            }\n        }\n        //cout<<p+1<<\":\"<<dp[p+1]<<endl;\n    }\n    return *min_element(all(dp[r-1]));\n}\n\nint main(){\n\tcin.tie(0);\n   \tios::sync_with_stdio(false);\n\t\n\twhile(cin>>n>>m,n){\n\t    L=vvi(n,vi(n,INF));\n\t    S=vvi(n,vi(n,INF));\n\t    rep(_,m){\n\t        int x,y,t; char c;\n\t        cin>>x>>y>>t>>c;\n\t        x--;y--;\n\t        (c=='L'?L:S)[x][y]=(c=='L'?L:S)[y][x]=t;\n\t    }\n\t    rep(k,n)rep(i,n)rep(j,n)if(i!=j){\n\t        if(L[i][k]!=INF&&L[k][j]!=INF)\n\t            L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t        if(S[i][k]!=INF&&S[k][j]!=INF)\n\t            S[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t    }else L[i][j]=S[i][j]=0;\n\t    cin>>r;\n\t    route.resize(r);\n\t    rep(i,r){\n\t        cin>>route[i];\n\t        route[i]--;\n\t    }\n\t    cout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<numeric>\n#include<algorithm>\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=(k);i++)\n#define INF ((int)1.e8)\n#define mk(i,j) make_pair(i,j)\n\n#define N 200\n#define M 10000\n#define R 1000\nint sdst[N][N];\nint ldst[N][N];\nint dp[R+1][N];\n\nusing namespace std;\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m){\n\t\tif(!n)break;\n//\t\tfill(&sdst[0][0],&sdst[0][0] + sizeof(sdst),INF);\n//\t\tfill(*ldst, *ldst + sizeof(ldst), INF);\n//\t\tfill(**shp,sizeof(shp)+**shp,-1);\n\t\trep(i,n)rep(j,n){\n\t\t\tsdst[i][j] = ldst[i][j] = i==j?0:INF;\n\t\t}\n\t\trep(i,n){\n\t\t\tint x,y,t;\n\t\t\tstring s;\n\t\t\tcin >> x >> y >> t;\n\t\t\tx--;y--;\n\t\t\tcin >> s;\n\t\t\tif(s[0]=='L'){\n\t\t\t\tldst[x][y] = ldst[y][x] = min(ldst[x][y],t);\n\t\t\t}else{\n\t\t\t\tsdst[x][y] = sdst[y][x] = min(sdst[x][y],t);\n\t\t\t}\n\t\t\t//cout << x << \" \" << y << \" \" << t << \" \" << s << endl;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n){\n\t\t\tldst[i][j] = min(ldst[i][j],ldst[i][k] + ldst[k][j]);\n\t\t\tsdst[i][j] = min(sdst[i][j],sdst[i][k] + sdst[k][j]);\n\t\t}\n\t\tint r,zp;\n\t\tcin >> r;\n\t\trep(i,r)rep(j,n)dp[i][j]=INF;\n\t\tcin >> zp;\n\t\tzp--;\n\t\tdp[0][zp]=0;\n\t\trep(i,r-1){\n\t\t\tint z;\n\t\t\tcin >> z;\n\t\t\tz--;\n\t\t\trep(j,n)rep(k,n){\n\t\t\t\tdp[i+1][k] = min(dp[i+1][k],\n\t\t\t\t dp[i][j] + (j==k?ldst[zp][z]:ldst[zp][j] + sdst[j][k] + ldst[k][z]));\n\t\t\t}\n\t\t\tzp = z;\n\t\t}\n\t\tint ans = INF;\n\t\trep(i,n)ans = min(dp[r-1][i],ans);\n\n\t\tcout << ans << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 28;\n\nint n,m,r;\n\nint L[210][210];\nint S[210][210];\nint z[1010];\n\nint dp[1010][210];\n\nint main(void){\n\twhile(cin >> n >> m,n|m){\n\t\trep(i,n)rep(j,n) L[i][j]=S[i][j]=(i==j)?0:inf;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar type;\n\t\t\tcin >> a >> b >> c >> type;\n\t\t\ta--,b--;\n\t\t\tif(type=='L')\n\t\t\t\tL[a][b]=L[b][a]=c;\n\t\t\telse\n\t\t\t\tS[a][b]=S[b][a]=c;\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n) L[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\tcin >> r;\n\t\trep(i,r) cin >> z[i],z[i]--;\n\t\trep(i,r)rep(j,n) dp[i][j]=inf;\n\t\tdp[0][z[0]]=0;\n\t\trep(i,r-1)rep(j,n){\n\t\t\tdp[i+1][j]=min(dp[i+1][j],dp[i][j]+L[z[i]][z[i+1]]);\n\t\t\trep(k,n){\n\t\t\t\tint cost=L[z[i]][j]+S[j][k]+L[k][z[i+1]];\n\t\t\t\tdp[i+1][k]=min(dp[i+1][k],dp[i][j]+cost);\n\t\t\t}\n\t\t}\n\t\tint ans=inf;\n\t\trep(i,n) ans=min(ans,dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//58\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct E{\n  int d,t;\n  bool s;\n};\n\nstruct S{\n  int t,x,p,b;\n  bool operator<(S a)const{\n    return t>a.t;\n  }\n};\n\nint main(){\n  for(int n,m;cin>>n>>m,n|m;){\n    vector<E> e[201];\n    int d[201][201];\n    fill(d[0],d[201],1<<29);\n    while(m--){\n      int x,y,t;\n      char sl;\n      cin>>x>>y>>t>>sl;\n      E a={y,t,sl=='S'};\n      e[x].push_back(a);\n      E b={x,t,sl=='S'};\n      e[y].push_back(b);\n      if(sl=='L'){\n\td[x][y]=d[y][x]=min(d[y][x],t);\n      }\n    }\n    for(int i=1;i<=n;i++){\n      for(int j=1;j<=n;j++){\n\tfor(int k=1;k<=n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    int r;\n    cin>>r;\n    int z[1000];\n    for(int i=0;i<r;i++){\n      cin>>z[i];\n    }\n    priority_queue<S> que;\n    S is={0,0,z[0],z[0]};\n    que.push(is);\n    int p[201][201]={{}};\n    fill(p[0],p[201],false);\n    for(;;){\n      S c=que.top();\n      if(c.x==r-1)break;\n      que.pop();\n      if(p[c.p][c.b]>=c.x+1)continue;\n      p[c.p][c.b]=c.x+1;\n      if(c.p!=c.b&&d[c.p][z[c.x]+1]==1<<30){\n\tS n={c.t+d[c.p][c.b],c.x,c.b,c.b};\n\tque.push(n);\n      }else{\n\tfor(int i=0;i<e[c.p].size();i++){\n\t  E ce=e[c.p][i];\n\t  if(!ce.s||c.b==c.p){\n\t    S n={c.t+ce.t,c.x+(ce.d==z[c.x+1]),ce.d,ce.s?ce.d:c.b};\n\t    if(p[n.p][n.b]<n.x+1){\n\t      que.push(n);\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<que.top().t<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define INF 1e+15\n#define int long long\nusing namespace std;\n\nsigned main(){\n\tint n,m;\n\twhile(scanf(\"%lld %lld\",&n,&m),n){\n\t\tint riku[200][200],kai[200][200],r,z[1000],dp[1001][200];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\triku[i][j] = INF;\n\t\t\t\tkai[i][j] = INF;\n\t\t\t}\n\t\t\triku[i][i] = 0;\n\t\t\tkai[i][i] = 0;\n\t\t}\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint x,y,t;\n\t\t\tchar s;\n\t\t\tscanf(\"%lld %lld %lld %c\",&x,&y,&t,&s); x--;y--;\n\t\t\tif(s == 'L'){\n\t\t\t\triku[x][y] = min(riku[x][y],t);\n\t\t\t\triku[y][x] = min(riku[y][x],t);\n\t\t\t}else{\n\t\t\t\tkai[x][y] = min(kai[x][y],t);\n\t\t\t\tkai[y][x] = min(kai[y][x],t);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0;k < n;k++){\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\triku[i][j] = min(riku[i][j],riku[i][k] + riku[k][j]);\n\t\t\t\t\tkai[i][j] = min(kai[i][j],kai[i][k] + kai[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%lld\",&r);\n\t\tfor(int i = 0;i < r;i++){\n\t\t\tscanf(\"%lld\",&z[i]); z[i]--;\n\t\t\tfor(int j = 0;j < n;j++) dp[i][j] = INF;\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 1;i < r;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tfor(int k = 0;k < n;k++){\n\t\t\t\t\tdp[i][k] = min(dp[i][k],dp[i - 1][j] + riku[z[i - 1]][j] + kai[j][k] + riku[k][z[i]]);\n\t\t\t\t}\n\t\t\t\tdp[i][j] = min(dp[i][j],dp[i - 1][j] + riku[z[i - 1]][z[i]]);\n\t\t\t}\n\t\t}\n\t\tint mi = INF;\n\t\tfor(int i = 0;i < n;i++) mi = min(mi,dp[r - 1][i]);\n\t\tcout << mi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nint const MAX_N = 210;\nint const MAX_R = 1010;\nint const INF = 1<<29;\nll dpl[MAX_N][MAX_N];\nll dps[MAX_N][MAX_N];\nll dp[MAX_R][MAX_N];\nll N, M, R;\nint z[MAX_R];\n\nint main() {\n  \n  while(cin >> N >> M && (N|M)) {\n    for(int i=0; i<N; i++) {\n      dpl[i][i] = dps[i][i] = 0;\n      for(int j=i+1; j<N; j++) {\n        dpl[i][j] = dpl[j][i] = INF;\n        dps[i][j] = dps[j][i] = INF;\n      }\n    }\n    \n    for(int i=0; i<M; i++) {\n      int x, y, c; char ls;\n      cin >> x >> y >> c >> ls; x--, y--;\n      if(ls == 'L') {\n        dpl[x][y] = dpl[y][x] = c;\n      }\n      else {\n        dps[x][y] = dps[y][x] = c;\n      }\n    }\n    \n    int r; cin >> r;\n    for(int i=0; i<r; i++) {\n      cin >> z[i]; z[i] --;\n    }\n    \n    for(int k=0; k<N; k++) {\n      for(int i=0; i<N; i++) {\n        for(int j=0; j<N; j++) {\n          dpl[i][j] = min(dpl[i][j], dpl[i][k]+dpl[k][j]);\n          dps[i][j] = min(dps[i][j], dps[i][k]+dps[k][j]);\n        }\n      }\n    }\n\n    fill(dp[0], dp[0]+MAX_R*MAX_N, INF);\n    dp[0][z[0]] = 0;\n    for(int i=1; i<R; i++) {\n      for(int s=0; s<N; s++)\n        for(int t=0; t<N; t++) {\n          dp[i][t] = min(dp[i][t], dp[i-1][s] + dpl[z[i-1]][s] + dps[s][t] + dpl[t][z[i]]);\n          dp[i][t] = min(dp[i][t], dp[i-1][t] + dpl[z[i-1]][z[i]]);\n        }\n    }\n    \n    cout << *min_element(dp[R-1], dp[R]) << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\n\nint main() {\n\tint n, m;\n\twhile (cin >> n >> m, n){\n\t\tvector<vector<int>> dl(n,vector<int>(n,1e9));\n\t\tvector<vector<int>> ds(n, vector<int>(n,1e9));\n\t\tREP(i, n){\n\t\t\tdl[i][i] = 0;\n\t\t\tds[i][i] = 0;\n\t\t}\n\t\tREP(i, m){\n\t\t\tint u, v, t;\n\t\t\tchar c;\n\t\t\tcin >> u >> v >> t >> c;\n\t\t\tu--; v--;\n\t\t\tif (c == 'L'){\n\t\t\t\tdl[u][v] = t;\n\t\t\t\tdl[v][u] = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tds[u][v] = t;\n\t\t\t\tds[v][u] = t;\n\t\t\t}\n\t\t}\n\t\tREP(i,n)\n\t\t\tREP(j, n)\n\t\t\t\tREP(k, n){\n\t\t\tdl[j][k] = min(dl[j][k], dl[j][i] + dl[i][k]);\n\t\t\tds[j][k] = min(ds[j][k], ds[j][i] + ds[i][k]);\n\t\t}\n\t\tint r;\n\t\tcin >> r;\n\t\tvector<int> goal(r);\n\t\tREP(i,r){\n\t\t\tcin >> goal[i];\n\t\t\tgoal[i]--;\n\t\t}\n\t\tvector<vector<int>> dp(r, vector<int>(n, 1e8));\n\t\tdp[0][goal[0]] = 0;\n\t\tFOR(i,1, r){\n\t\t\tREP(j, n){\n\t\t\t\tREP(k, n){\n\t\t\t\t\tdp[i][k] = min(dp[i][k],dp[i - 1][j] + dl[goal[i - 1]][j] + ds[j][k] + dl[k][goal[i]]);\n\t\t\t\t\tif (j == k)dp[i][k] = min(dp[i][k], dp[i - 1][j] + dl[goal[i - 1]][goal[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 1e9;\n\t\tREP(i, n)\n\t\t\tans = min(ans, dp[r-1][i]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<28)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dp[1024][256];\nint dist[2][256][256];\nint N,M,R;\nint z[1024];\n\nvoid wf(){\n  rep(k,N) rep(i,N) rep(j,N){\n    rep(l,2){\n      if(i==j) dist[l][i][j] = 0;\n      dist[l][i][j] = min(dist[l][i][j], dist[l][i][k] + dist[l][k][j]);\n    }\n  }\n}\n\nvoid solve(){\n  wf();\n  rep(i,1024) rep(j,256) dp[i][j] = INF;\n  rep(i,N) dp[0][i] = dist[0][z[0]][i] + dist[1][i][z[0]];\n  for(int i=1;i<R;i++){\n    rep(j,N) rep(k,N){\n      if(j==k) dp[i][j] = min(dp[i][j], dp[i-1][j] + dist[0][z[i-1]][z[i]]);\n      else dp[i][k] = min(dp[i][k], dp[i-1][j] + dist[0][z[i-1]][j] + dist[1][j][k] + dist[0][k][z[i]]);\n    }\n  }\n  int res = INF;\n  rep(i, N) res = min(res, dp[R-1][i]);\n  printf(\"%d\\n\", res);\n}\n\nint main(){\n  while(scanf(\"%d%d\",&N,&M) && N||M){\n    rep(k,2) rep(i,256) rep(j,256) dist[k][i][j] = INF;\n    rep(i,M){\n      int x,y,t; char sl;\n      scanf(\"%d%d%d %c\", &x,&y,&t,&sl); x--; y--;\n      if(dist[sl=='S'][x][y] > t) dist[sl=='S'][x][y] = t;\n      if(dist[sl=='S'][y][x] > t) dist[sl=='S'][y][x] = t;\n    }\n\n    scanf(\"%d\", &R);\n    rep(i,R){ scanf(\"%d\",z+i); z[i]--; }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\n\nconst int INF = 1e9;\n\nint solve(int N, VVI& land, VVI& sea, VI& z) {\n  // bellman-ford\n  REP(k, N) REP(i, N) REP(j, N) {\n    land[i][j] = min(land[i][j], land[i][k] + land[k][j]);\n    sea[i][j] = min(sea[i][j], sea[i][k] + sea[k][j]);\n  }\n\n  // dp[i][j]: i個目の配達を終えた時に船が町jにあるときの最短時間\n  VVI dp(z.size(), VI(N, INF));\n  dp[0][z[0]-1] = 0;\n  REP(i, z.size()-1) {\n    REP(j, N) {\n      REP(k, N) {\n        // z[i]からz[i+1]までの移動中に、船をjからkまで移動させる\n        int from = z[i]-1;\n        int to = z[i+1]-1;\n        if (land[from][j] != INF && sea[j][k] != INF && land[k][to] != INF) {\n          dp[i+1][k] = min(dp[i+1][k], \n              dp[i][j] + land[from][j] + sea[j][k] + land[k][to]);\n        }\n      }\n    }\n  }\n\n  return *min_element(dp[z.size()-1].begin(), dp[z.size()-1].end());\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while (true) {\n    int N, M; cin >> N >> M;\n    if (N == 0 && M == 0) break;\n\n    VVI land(N, VI(N, INF)), sea(N, VI(N, INF));\n    REP(i, N) {\n      land[i][i] = 0;\n      sea[i][i] = 0;\n    }\n    REP(i, M) {\n      int x, y, t; string sl;\n      cin >> x >> y >> t >> sl;\n      if (sl == \"L\") {\n        land[x-1][y-1] = t;\n        land[y-1][x-1] = t;\n      } else {\n        sea[x-1][y-1] = t;\n        sea[y-1][x-1] = t;\n      }\n    }\n    int R; cin >> R;\n    vector<int> z(R);\n    REP(i, R) cin >> z[i];\n\n    int ans = solve(N, land, sea, z);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<queue>\n#include<set>\n#include<map>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n\nconst int N = 222;\nconst int R = 1111;\n\nclass E{\n\tpublic:\n\tint to;\n\tint cost;\n\tstring kind;\n\tE(int to,int cost,string kind):to(to),cost(cost),kind(kind){}\n};\n\nint n,m;\nvector<E> edge[N];\nvector<int> move;\n\n\nbool init(){\n\tcin>>n>>m;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i].clear();\n\trep(i,m){\n\t\tint a,b,c;\n\t\tstring s;\n\t\tcin>>a>>b>>c>>s;\n\t\tedge[a].push_back(E(b,c,s));\n\t\tedge[b].push_back(E(a,c,s));\n\t}\n\t\n\tint r;\n\tcin>>r;\n\t\n\tmove.clear();\n\trep(i,r){\n\t\tint a;\n\t\tcin>>a;\n\t\tmove.push_back(a);\n\t}\n\treturn true;\n}\n\nclass Q{\n\tpublic:\n\tint val;\n\tint pos,num,fune;\n\tQ(int pos,int num,int fune,int val):\n\t\tpos(pos),num(num),fune(fune),val(val){}\n\tbool operator<(const Q& a)const{\n\t\treturn val>a.val;\n\t}\n};\n\nint visit[N][N];\n\nint dijk(){\n\t\n\trep(i,n+1)rep(k,n+1)visit[i][k]=0;\n\t\n\tpriority_queue<Q> que;\n\tque.push(Q(move[0],1,1,0));\n\t\n\twhile(!que.empty()){\n\t\tQ u = que.top();\n\t\tque.pop();\n\t\t\n\t\tif(visit[u.pos][u.fune]>=u.num)continue;\n\t\tvisit[u.pos][u.fune]=u.num;\n\t\t\n\t\t//printf(\"**%d %d %d %d\\n\",u.pos,u.num,u.fune,u.val);\n\t\t\n\t\tint next = u.num;\n\t\tif(u.pos==move[u.num]){\n\t\t\tnext++;\n\t\t}\n\t\t\n\t\tif(next==n){\n\t\t\treturn u.val;\n\t\t}\n\t\t\n\t\tif(u.pos==u.fune){\n\t\t\trep(i,edge[u.pos].size()){\n\t\t\t\tE e = edge[u.pos][i];\n\t\t\t\tif(e.kind!=\"S\")continue;\n\t\t\t\tque.push(Q(e.to, next, e.to, u.val+e.cost));\n\t\t\t}\n\t\t}\n\t\trep(i,edge[u.pos].size()){\n\t\t\tE e = edge[u.pos][i];\n\t\t\tif(e.kind!=\"L\")continue;\n\t\t\tque.push(Q(e.to, next, u.fune, u.val+e.cost));\n\t\t}\n\t}\n\t\n\treturn -1;\n}\n\nint solve(){\n\treturn dijk();\n}\n\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define INF 100000000\nint le[200][200];\nint se[200][200];\nint dp[2][200];\nint q[1000];\nint min(int a,int b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\tint i,j,k;\n\twhile(1){\n\tscanf(\"%d %d\",&n,&m);\n\tif(n==0)return 0;\n\tfor(i=0;i<200;i++){\n\t\tfor(j=0;j<200;j++){\n\t\t\tle[i][j]=INF;\n\t\t\tse[i][j]=INF;\n\t\t}\n\t\tle[i][i]=0;\n\t\tse[i][i]=0;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar t;\n\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\ta--;b--;\n\t\tif(t=='L'){\n\t\t\tle[a][b]=min(le[a][b],c);\n\t\t\tle[b][a]=min(le[b][a],c);\n\t\t}\n\t\telse{\n\t\t\tse[a][b]=min(se[a][b],c);\n\t\t\tse[b][a]=min(se[b][a],c);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tle[j][k]=min(le[j][k],le[j][i]+le[i][k]);\n\t\t\t\tse[j][k]=min(se[j][k],se[j][i]+se[i][k]);\n\t\t\t}\n\t\t}\n\t}\n\tint nq;\n\tscanf(\"%d\",&nq);\n\tfor(i=0;i<nq;i++){\n\t\tscanf(\"%d\",&q[i]);\n\t\tq[i]--;\n\t}\n\tfor(i=0;i<200;i++)dp[0][i]=INF;\n\tdp[0][q[0]]=0;\n\tfor(i=1;i<nq;i++){\n\t\tfor(j=0;j<200;j++)dp[i%2][j]=INF;\n\t\tfor(j=0;j<n;j++){\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tdp[i%2][k]=min(dp[i%2][k],dp[(i+1)%2][j]+le[q[i-1]][j]+se[j][k]+le[k][q[i]]);\n\t\t\t}\n\t\t\tdp[i%2][j]=min(dp[i%2][j],dp[(i+1)%2][j]+le[q[i-1]][q[i]]);\n\t\t}\n\t}\n\tint ans=INF;\n\tfor(i=0;i<n;i++)ans=min(ans,dp[(nq+1)%2][i]);\n\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#define min(a,b)((a)<(b)?(a):(b))\nN;\nC[2][201][201];\nDP[1000][201];\nWF(int c[201][201]){\n\tint i,j,k;\n\tfor(k=1;k<=N;k++)\n\t\tfor(i=1;i<=N;i++)\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t\tc[i][j]=min(c[i][j],c[i][k]+c[k][j]);\n\tfor(i=1;i<=N;i++)\n\t\tc[i][i]=0;\n}\nmain(){\n\tint M,R,s,d,i,boat,k,c;\n\tfor(;scanf(\"%d%d\",&N,&M)*N;){\n\t\tmemset(C,1,sizeof(C));//inf\n\t\tfor(;M--;){\n\t\t\tint x,y,t,s;\n\t\t\tchar sl[2];\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,sl);\n\t\t\ts=sl[0]=='L'?0:1;\n\t\t\tC[s][x][y]=C[s][y][x]=min(C[s][x][y],t);\n\t\t}\n\t\tWF(C[0]);\n\t\tWF(C[1]);\n\t\tmemset(DP,1,sizeof(*DP));//inf\n\t\tscanf(\"%d%d\",&R,&s);\n\t\tDP[0][s]=0;\n\t\tfor(i=1;i<R;i++){\n\t\t\tscanf(\"%d\",&d);\n\t\t\tfor(boat=1;boat<=N;boat++){\n\t\t\t\t//¤HÅÚ®\n\t\t\t\tDP[i][boat]=DP[i-1][boat]+C[0][s][d];\n\t\t\t\t//CHðgÁÄÚ®iDÍÅkÉ éÆ·éj\n\t\t\t\tfor(k=1;k<=N;k++){\n\t\t\t\t\tDP[i][boat]=min(DP[i][boat],\n\t\t\t\t\t\tDP[i-1][k]+C[0][s][k]+C[1][k][boat]+C[0][boat][d]);\n\t\t\t\t}\n\t\t\t\t//printf(\"DP[%d][boat=%d]=%d\\n\",i,boat,DP[i][boat]);\n\t\t\t}\n\t\t\ts=d;\n\t\t}\n\t\tc=1e9;\n\t\tfor(boat=1;boat<=N;boat++){\n\t\t\tc=min(c,DP[i-1][boat]);\n\t\t}\n\t\tprintf(\"%d \\n\",c);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MN 205\n#define INF 1<<25\n#define init(a) memset(a,0x0f,sizeof(a))\n#define min(a,b) (a<b?a:b)\nint N,M,R,de[1005],S[MN][MN],L[MN][MN],i,j,k,x,y,s;\nint dp[1005][205];\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tinit(S);init(L);init(dp);\n\t\tfor(i=0;i<N;i++)L[i][i]=S[i][i]=0;\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tchar t;\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&s,&t);\n\t\t\tx--;y--;\n\t\t\tif(t=='L')L[x][y]=L[y][x]=s;\n\t\t\telse S[x][y]=S[y][x]=s;\n\t\t}\n\t\tfor(scanf(\"%d\",&R),i=0;i<R;de[i++]--)scanf(\"%d\",&de[i]);\n\t\tfor(k=0;k<N;k++)\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t}\n\t\tdp[0][de[0]]=0;\n\t\tfor(k=0;k<R-1;k++)\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tdp[k+1][i] = min(dp[k+1][i],dp[k][j]+L[de[k]][j]+S[j][i]+L[i][de[k+1]]);\n\t\t\t\t\tif(i == j) dp[k+1][i] = min(dp[k+1][i], dp[k][j] + L[de[k]][de[k+1]]);\n\t\t\t\t}\n\t\tfor(i=0,s=INF;i<N;i++)s=min(s,dp[R-1][i]);\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret,f;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[2][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\tf = 0;\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[f][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[f^1][next] = min( dp[f^1][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[f^1][cur] = min(dp[f^1][cur],dp[f][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,200)dp[f][j] = INF;\n\t\t\tf^=1;\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[f][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[1000][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,1000)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[bit][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[bit+1][next] = min( dp[bit+1][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[bit+1][cur] = min(dp[bit+1][cur],dp[bit][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[r-1][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[2][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,n)rep(j,n)land[i][j] = ship[i][j] = INF;\n\t\trep(i,n)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,2)rep(k,n)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[(bit+1)%2][cur] = min(dp[(bit+1)%2][cur],dp[bit%2][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,n)dp[bit%2][j] = INF;\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[(r-1)%2][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint main(void)\n{\n\tint i,j,k,c,min;\n\tint n,m;\n\tint x,y,t;\n\tchar s;\n\tint r;\n\tint z[1000];\n\tint dpl[200][200],dps[200][200],**dp;\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d %d \",&n,&m);\n\t\tif(n==0 && m==0)break;\n\t\t\n\t\tfor(i=0;i<200;i++){\n\t\t\tfor(j=0;j<200;j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tdpl[i][j] = 0;\n\t\t\t\t\tdps[i][j] = 0;\n\t\t\t\t}else{\n\t\t\t\t\tdpl[i][j] = 1000001;\n\t\t\t\t\tdps[i][j] = 1000001;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d %d %d %c \",&x,&y,&t,&s);\n\t\t\tif(s=='L'){\n\t\t\t\tif(dpl[x-1][y-1]>t)dpl[x-1][y-1] = t;\n\t\t\t\tif(dpl[y-1][x-1]>t)dpl[y-1][x-1] = t;\n\t\t\t}else{\n\t\t\t\tif(dps[x-1][y-1]>t)dps[x-1][y-1] = t;\n\t\t\t\tif(dps[y-1][x-1]>t)dps[y-1][x-1] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tc=1;\n\t\twhile(c)\n\t\t{\n\t\t\tc=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=i;j<n;j++){\n\t\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\t\tif(dpl[i][j] > dpl[i][k] + dpl[k][j]){\n\t\t\t\t\t\t\tdpl[i][j] = dpl[i][k] + dpl[k][j];\n\t\t\t\t\t\t\tdpl[j][i] = dpl[i][j];\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tc=1;\n\t\twhile(c)\n\t\t{\n\t\t\tc=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tfor(j=i;j<n;j++){\n\t\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\t\tif(dps[i][j] > dps[i][k] + dps[k][j]){\n\t\t\t\t\t\t\tdps[i][j] = dps[i][k] + dps[k][j];\n\t\t\t\t\t\t\tdps[j][i] = dps[i][j];\n\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d \",&r);\n\t\tfor(i=0;i<r;i++){\n\t\t\tscanf(\"%d \",&z[i]);\n\t\t}\n\t\t\n\t\tdp = (int **)malloc(sizeof(int)*r);\n\t\tfor(i=0;i<r;i++){\n\t\t\tdp[i] = (int *)malloc(sizeof(int)*n);\n\t\t}\n\t\t\n\t\tfor(i=0;i<r;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tdp[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tdp[0][z[0]-1] = 0;\n\t\t\n\t\tfor(i=1;i<r;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(dp[i-1][j] >= 0){\n\t\t\t\t\tfor(k=0;k<n;k++){\n\t\t\t\t\t\tif(dpl[z[i-1]-1][j] < 1000001 && dps[j][k] < 1000001 && dpl[k][z[i]-1] < 1000001){\n\t\t\t\t\t\t\tif(dp[i][k] < 0 || dp[i][k] > dpl[z[i-1]-1][j] + dps[j][k] + dpl[k][z[i]-1] + dp[i-1][j])\n\t\t\t\t\t\t\tdp[i][k] = dpl[z[i-1]-1][j] + dps[j][k] + dpl[k][z[i]-1] + dp[i-1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(dpl[z[i-1]-1][z[i]-1] < 1000001 && ( dp[i][j] < 0 || dp[i][j] > dpl[z[i-1]-1][z[i]-1] + dp[i-1][j]) ){\n\t\t\t\t\t\tdp[i][j] = dpl[z[i-1]-1][z[i]-1] + dp[i-1][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tmin = 1000001;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(dp[r-1][i] >=0 && min > dp[r-1][i])min=dp[r-1][i];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",min);\n\t}\n\treturn 0;\n}\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\n\t\t\n\t\t"
  },
  {
    "language": "C",
    "code": "/*\n * hujx.cpp\n *\n *  Created on: 2015年5月21日\n *      Author: dell\n */\n#include<stdio.h>\n#include<iostream>\n#include<string>\n#include<string.h>\n#include<algorithm>\n#include<iomanip>\n#include<vector>\n#include<time.h>\n#include<queue>\n#include<stack>\n#include<iterator>\n#include<math.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<map>\n#include<set>\n#include<bitset>\n//#define ONLINE_JUDGE\n#define eps 1e-5\n#define INF 0x7fffffff\n#define FOR(i,a) for((i)=0;i<(a);(i)++)\n#define MEM(a) (memset((a),0,sizeof(a)))\n#define sfs(a) scanf(\"%s\",a)\n#define sf(a) scanf(\"%d\",&a)\n#define sfI(a) scanf(\"%I64d\",&a)\n#define pf(a) printf(\"%d\\n\",a)\n#define pfI(a) printf(\"%I64d\\n\",a)\n#define pfs(a) printf(\"%s\\n\",a)\n#define sfd(a,b) scanf(\"%d%d\",&a,&b)\n#define sft(a,b,num) scanf(\"%d%d%d\",&a,&b,&num)\n#define for1(i,a,b) for(int i=(a);i<b;i++)\n#define for2(i,a,b) for(int i=(a);i<=b;i++)\n#define for3(i,a,b)for(int i=(b);i>=a;i--)\n#define MEM1(a) memset(a,0,sizeof(a))\n#define MEM2(a) memset(a,-1,sizeof(a))\n#define ll long long\nconst double PI=acos(-1.0);\ntemplate<class T> T gcd(T a,T b){return b?gcd(b,a%b):a;}\ntemplate<class T> T lcm(T a,T b){return a/gcd(a,b)*b;}\ntemplate<class T> inline T Min(T a,T b){return a<b?a:b;}\ntemplate<class T> inline T Max(T a,T b){return a>b?a:b;}\nusing namespace std;\n//#pragma comment(linker,\"/STACK:1024000000,1024000000\")\nint n,m,x;\n#define N 210\n#define M 100010\n#define Mod 1000000000\n#define p(x,y) make_pair(x,y)\nconst int MAX_len=550;\nint dpl[N][N];\nint dps[N][N];\nint des[1010];\nint dp[N][N];\nvoid Init(){\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=m;j++){\n\t\t\tif(i == j) dpl[i][j] = dps[i][j] = 0;\n\t\t\telse\n\t\t\t\tdpl[i][j] = dps[i][j] = 100000000;\n\t\t}\n\t}\n}\nvoid Floyd(){\n\tfor(int k=0;k<n;k++){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tdpl[i][j] = Min(dpl[i][j],dpl[i][k]+dpl[k][j]);\n\t\t\t\tdps[i][j] = Min(dps[i][j],dps[i][k]+dps[k][j]);\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n    while(scanf(\"%d%d\",&n,&m)!=EOF && n+m){\n    \tint u,v,c;\n    \tchar ch[5];\n    \tInit();\n    \tfor(int i=0;i<m;i++){\n    \t\tscanf(\"%d%d%d%s\",&u,&v,&c,ch);\n    \t\tu--,v--;\n    \t\tif(ch[0] == 'L'){\n    \t\t\tdpl[u][v] = dpl[v][u] = Min(dpl[u][v],c);\n    \t\t}else{\n    \t\t\tdps[u][v] = dps[v][u] = Min(dps[u][v],c);\n    \t\t}\n    \t}\n    \tint d;\n    \tsf(d);\n    \tfor(int i=0;i<d;i++){\n    \t\tsf(u);\n    \t\tu--;\n    \t\tdes[i] = u;\n    \t}\n    \tFloyd();\n    \tfor(int i=0;i<n;i++)\n    \t\tfor(int j=0;j<n;j++)\n    \t\t\tdp[i][j] = 100000000;\n\n    \tfor(int i=0;i<n;i++)\n    \t\tdp[0][i] = dps[des[0]][i]+dpl[i][des[0]];\n    \tfor(int i=1;i<d;i++){\n    \t\tfor(int j=0;j<n;j++){\n    \t\t\tfor(int k=0;k<n;k++){\n    \t\t\t\tif(j != k)\n    \t\t\t\tdp[i][k] = Min(dp[i][k],dp[i-1][j]+dpl[des[i-1]][j]+dps[j][k]+dpl[k][des[i]]);\n    \t\t\t\telse\n    \t\t\t\t\tdp[i][j] = Min(dp[i][j],dp[i-1][j]+dpl[des[i-1]][des[i]]);\n    \t\t\t}\n    \t\t}\n    \t}\n    \tint ans = INF;\n    \tfor(int i=0;i<n;i++)\n    \t\tans = Min(ans,dp[d-1][i]);\n    \tprintf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2200: Mr. Rito Post Office\n// 2017.12.9\n\n#include <stdio.h>\n#include <string.h>\n\nint land[202][202], sea[202][202];\nint dp[1002][202];\nint z[1002];\n\nchar buf[4000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, r, x, y, i, j, k, t;\n\n    while (fgets(p=buf, 15, stdin) && *p != '0') {\n\t\tn = getint(), m = getint();\n\t\tmemset(land, 0x07, sizeof(land));\n\t\tmemset(sea,  0x07, sizeof(sea));\n\t\tfor (i = 0; i < n; i++) land[i][i] = sea[i][i] = 0;\n\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 30, stdin);\n\t\t\tx = getint()-1, y = getint()-1, t = getint();\n\t\t\tif (*p == 'L') { if (t < land[x][y]) land[x][y] = land[y][x] = t; }\n\t\t\telse           { if (t < sea [x][y]) sea [x][y] = sea [y][x] = t; }\n\t\t}\n\t\tfgets(p=buf, 10, stdin), r = getint()-1;\n\t\tfgets(p=buf, 4000, stdin);\n\t\tfor (i = 0; i <= r; i++) z[i] = getint()-1;\n\n\t\tfor (k = 0; k < n; k++) for (i = 0; i < n; i++) for (j = 0; j < n; j++) {\n\t\t\tt = land[i][k] + land[k][j];\n\t\t\tif (t < land[i][j]) land[i][j] = t;\n\t\t\tt = sea[i][k] + sea[k][j];\n\t\t\tif (t < sea[i][j]) sea[i][j] = t;\n\t\t}\n\n\t\tmemset(dp, 0x07, sizeof(dp));\n\t\tdp[0][z[0]] = 0;\n\n\t\tfor (k = 1; k <= r; k++) {\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tif (i == j) t = dp[k-1][j] + land[z[k-1]][z[k]];\n\t\t\t\t\telse \t\tt = dp[k-1][j] + land[z[k-1]][j] + sea[j][i] + land[i][z[k]];\n\t\t\t\t\tif (t < dp[k][i]) dp[k][i] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tt = 0x7ffffff;\n\t\tfor (i = 0; i < n; i++) if (dp[r][i] < t) t = dp[r][i];\n\t\tprintf(\"%d\\n\", t);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,p[1010],d[1010][1010],w[2][310][310];\n  int a,b,c,i,j,k,l,t,M=100000000;\n  char r;\n  while(scanf(\"%d %d\",&n,&m),n+m){\n    for(i=0;i<n*n;i++)w[0][i/n][i%n]=w[1][i/n][i%n]=M;\n    for(i=0;i<1010;i++){\n      for(j=0;j<1010;j++)d[i][j]=M;\n    }\n    for(i=0;i<n;i++)w[0][i][i]=w[1][i][i]=0;\n    while(m--){\n      scanf(\"%d %d %d %c\",&a,&b,&c,&r);\n      t=(r=='L')?0:1;\n      w[t][a-1][b-1]=w[t][b-1][a-1]=c;\n    }\n    for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  for(l=0;l<n;l++)w[i][k][l]=MIN(w[i][k][l],w[i][k][j]+w[i][j][l]);\n\t}\n      }\n    }\n    /*for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++)printf(\"%10d \",w[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&l);\n    for(i=0;i<l;i++)scanf(\"%d\",&p[i]);\n    for(i=0;i<l;i++)p[i]--;\n    d[p[0]][p[0]]=0;\n    for(i=0;i<l-1;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==M)continue;\n\td[i+1][j]=MIN(d[i+1][j],d[i][j]+w[0][p[i]][p[i+1]]);\n\tfor(k=0;k<n;k++){\n\t  d[i+1][k]=MIN(d[i+1][k],d[i][j]+w[0][p[i]][j]+w[1][j][k]+w[0][k][p[i+1]]);\n\t}\n      }\n    }\n    for(i=0;i<n;i++)d[l-1][0]=MIN(d[l-1][0],d[l-1][i]);\n    printf(\"%d\\n\",d[l-1][0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[1000][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,2)rep(k,1000)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[bit][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[bit+1][next] = min( dp[bit+1][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[bit+1][cur] = min(dp[bit+1][cur],dp[bit][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[r-1][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[2][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,n)rep(j,n)land[i][j] = ship[i][j] = INF;\n\t\trep(i,n)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,2)rep(k,n)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[bit&1][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[!(bit&1)][next] = min( dp[!(bit&1)][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[!(bit&1)\t][cur] = min(dp[!(bit&1)][cur],dp[bit&1][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,n)dp[bit&1][j] = INF;\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[(r-1)&1][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,p[1000],d[1000][1000],w[2][310][310];\n  int a,b,c,i,j,k,l,t,M=100000000;\n  char r;\n  while(scanf(\"%d %d\",&n,&m),n+m){\n    for(i=0;i<n*n;i++)w[0][i/n][i%n]=w[1][i/n][i%n]=M;\n    for(i=0;i<1000;i++){\n      for(j=0;j<1000;j++)d[i][j]=M;\n    }\n    for(i=0;i<n;i++)w[0][i][i]=w[1][i][i]=0;\n    while(m--){\n      scanf(\"%d %d %d %c\",&a,&b,&c,&r);\n      t=(r=='L')?0:1;\n      w[t][a-1][b-1]=w[t][b-1][a-1]=c;\n    }\n    for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  for(l=0;l<n;l++)w[i][k][l]=MIN(w[i][k][l],w[i][k][j]+w[i][j][l]);\n\t}\n      }\n    }\n    for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++)printf(\"%10d \",w[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n    }\n    scanf(\"%d\",&l);\n    for(i=0;i<l;i++)scanf(\"%d\",&p[i]);\n    for(i=0;i<l;i++)p[i]--;\n    d[p[0]][p[0]]=0;\n    for(i=0;i<l-1;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==M)continue;\n\td[i+1][j]=MIN(d[i+1][j],d[i][j]+w[0][p[i]][p[i+1]]);\n\tfor(k=0;k<n;k++){\n\t  d[i+1][k]=MIN(d[i+1][k],d[i][j]+w[0][p[i]][j]+w[1][j][k]+w[0][k][p[i+1]]);\n\t}\n      }\n    }\n    for(i=0;i<n;i++)d[l-1][0]=MIN(d[l-1][0],d[l-1][i]);\n    printf(\"%d\\n\",d[l-1][0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "\n#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[2][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[(bit+1)%2][cur] = min(dp[(bit+1)%2][cur],dp[bit%2][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,200)dp[bit%2][j] = INF;\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[(r-1)%2][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\n#define min(x,y) ((x)<(y)?(x):(y))\n#define INF 100000000\nint n,m;\nint A[200][200],B[200][200];\nint dp[2][200];\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&n,&m);\n        if(n+m==0) break;\n        rep(i,n) {\n            rep(j,n){\n                if(i==j) A[i][j]=B[i][j]=0;\n                else A[i][j]=B[i][j]=INF;\n            }\n        }\n        rep(i,m){\n            int a,b,c; char d[3];\n            scanf(\"%d%d%d%s\",&a,&b,&c,d); //printf(\"%s\\n\",d);\n            a--; b--;\n            if(d[0]=='L') A[a][b]=A[b][a]=min(A[a][b],c);\n            else B[a][b]=B[b][a]=min(B[a][b],c);\n        }\n        rep(k,n){\n            rep(i,n){\n                rep(j,n){\n                    A[i][j]=min(A[i][j],A[i][k]+A[k][j]);\n                    B[i][j]=min(B[i][j],B[i][k]+B[k][j]);\n                }\n            }\n        }\n        int R;\n        scanf(\"%d\",&R);\n        int prev; scanf(\"%d\",&prev); prev--;\n        rep(i,2) rep(j,n) dp[i][j]=INF;\n        dp[1][prev]=0;\n        for(int i=1;i<R;i++){\n            int cur; scanf(\"%d\",&cur); cur--;\n            rep(j,n){\n                rep(k,n){\n                    if(j!=k)\n                        dp[(i+1)&1][j]=min(dp[(i+1)&1][j],dp[i&1][k]+\n                                           A[prev][k]+B[k][j]+A[j][cur]);\n                    else dp[(i+1)&1][j]=min(dp[(i+1)&1][j],\n                                            dp[i&1][j]+A[prev][cur]);\n                }\n            }\n            rep(j,n) dp[i&1][j]=INF;\n            prev=cur;\n        }\n        int mi=INF;\n        rep(i,n) mi=min(mi,dp[R&1][i]);\n        printf(\"%d\\n\",mi);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2200: Mr. Rito Post Office\n// 2017.12.9\n\n#include <stdio.h>\n#include <string.h>\n\nint ll[202][202], ss[202][202];\nint dp[1002][202];\nint z[1002];\n\nchar buf[4000], *p;\nint getint()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, r, x, y, t, i, j, k, ans;\n\n    while (fgets(p=buf, 15, stdin) && *p != '0') {\n\t\tn = getint(), m = getint();\n\n\t\tmemset(ll, 0x11, sizeof(ll));\n\t\tmemset(ss, 0x11, sizeof(ss));\n\t\tfor (i = 0; i < n; i++) ll[i][i] = ss[i][i] = 0;\n\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 30, stdin);\n\t\t\tx = getint()-1, y = getint()-1, t = getint();\n\t\t\tif (*p == 'L') ll[x][y] = ll[y][x] = t;\n\t\t\telse           ss[x][y] = ss[y][x] = t;\n\t\t}\n\t\tfgets(p=buf, 10, stdin), r = getint();\n\t\tfgets(p=buf, 4000, stdin);\n\t\tfor (i = 0; i < r; i++) z[i] = getint()-1;\n\n\t\tfor (k = 0; k < n; k++) for (i = 0; i < n; i++) for (j = 0; j < n; j++) {\n\t\t\tt = ll[i][k] + ll[k][j];\n\t\t\tif (t < ll[i][j]) ll[i][j] = t;\n\t\t\tt = ss[i][k] + ss[k][j];\n\t\t\tif (t < ss[i][j]) ss[i][j] = t;\n\t\t}\n\n\t\tmemset(dp, 0x11, sizeof(dp));\n\t\tdp[0][z[0]] = 0;\n\n\t\tfor (k = 1; k < r; k++) {\n\t\t\tfor (i = 0; i < n; i++) {\n\t\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\t\tif (i == j) t = dp[k-1][j] + ll[z[k-1]][z[k]];\n\t\t\t\t\telse \t\tt = dp[k-1][j] + ll[z[k-1]][j] + ss[j][i] + ll[i][z[k]];\n\t\t\t\t\tif (t < dp[k][i]) dp[k][i] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0x7ffffff;\n\t\tfor (i = 0; i < n; i++) if (dp[r-1][i] < ans) ans = dp[r-1][i];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "N;\nC[2][201][201];\nDP[1000][201];\nWF(int c[201][201]){\n\tint i,j,k;\n\tfor(k=1;k<=N;k++)\n\t\tfor(i=1;i<=N;i++)\n\t\t\tfor(j=1;j<=N;j++)\n\t\t\t\tc[i][j]=fmin(c[i][j],c[i][k]+c[k][j]);\n\tfor(i=1;i<=N;i++)\n\t\tc[i][i]=0;\n}\nmain(){\n\tint M,R,s,d,i,boat,k,c;\n\tfor(;scanf(\"%d%d\",&N,&M)*N;){\n\t\tmemset(C,1,sizeof(C));//inf\n\t\tfor(;M--;){\n\t\t\tint x,y,t,s;\n\t\t\tchar sl[2];\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,sl);\n\t\t\ts=sl[0]=='L'?0:1;\n\t\t\tC[s][x][y]=C[s][y][x]=fmin(C[s][x][y],t);\n\t\t}\n\t\tWF(C[0]);\n\t\tWF(C[1]);\n\t\tmemset(DP,1,sizeof(*DP));//inf\n\t\tscanf(\"%d%d\",&R,&s);\n\t\tDP[0][s]=0;\n\t\tfor(i=1;i<R;i++){\n\t\t\tscanf(\"%d\",&d);\n\t\t\tfor(boat=1;boat<=N;boat++){\n\t\t\t\tDP[i][boat]=DP[i-1][boat]+C[0][s][d];\n\t\t\t\tfor(k=1;k<=N;k++){\n\t\t\t\t\tDP[i][boat]=fmin(DP[i][boat],\n\t\t\t\t\t\tDP[i-1][k]+C[0][s][k]+C[1][k][boat]+C[0][boat][d]);\n\t\t\t\t}\n\t\t\t}\n\t\t\ts=d;\n\t\t}\n\t\tc=1e9;\n\t\tfor(boat=1;boat<=N;boat++){\n\t\t\tc=fmin(c,DP[i-1][boat]);\n\t\t}\n\t\tprintf(\"%d \\n\",c);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define rep(i,n) for(i=0;i<n;i++)\n#define INF 100000000\n#define min(a,b) (a<b?a:b)\nint main(){\n\tint i,j,k,n,m,bit,next,cur,r,newCost,ret;\n\tint land[200][200] , ship[200][200] , R[1000] ,dp[2][200];\n\twhile(scanf(\"%d%d\",&n,&m) && n){\n\t\trep(i,200)rep(j,200)land[i][j] = ship[i][j] = INF;\n\t\trep(i,200)land[i][i] = ship[i][i] = 0;\n\t\t\n\t\trep(i,m){\n\t\t\tchar t;\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d %d %d %c\\n\",&a,&b,&c,&t);\n\t\t\ta--,b--;\n\t\t\tif(t=='L')land[a][b] = land[b][a] = min(c,land[a][b]);\n\t\t\telse  ship[a][b] = ship[b][a] = min(c,ship[a][b]);\n\t\t}\n\t\trep(k,n)rep(i,n)rep(j,n)land[i][j] = min(land[i][j],land[i][k]+land[k][j]);\n\t\trep(k,n)rep(i,n)rep(j,n)ship[i][j] = min(ship[i][j],ship[i][k]+ship[k][j]);\n\t\t\n\t\tscanf(\"%d\",&r);\t\n\t\trep(i,r)scanf(\"%d\",&R[i]) , R[i]--;\n\t\t\n\t\trep(j,2)rep(k,200)dp[j][k] = INF;\n\t\tdp[0][R[0]] = 0;\n\t\t\n\t\t\n\t\trep(bit,r-1){\n\t\t\trep(cur,n){\n\t\t\t\trep(next,n){\n\t\t\t\t\tnewCost = dp[bit%2][cur] + land[R[bit]][cur] + ship[cur][next] + land[next][R[bit+1]];\n\t\t\t\t\tdp[(bit+1)%2][next] = min( dp[(bit+1)%2][next],newCost);\n\t\t\t\t}\n\t\t\t\tdp[(bit+1)%2][cur] = min(dp[(bit+1)%2][cur],dp[bit%2][cur]+land[R[bit]][R[bit+1]]);\n\t\t\t}\n\t\t\trep(j,200)dp[bit%2][j] = INF;\n\t\t}\n\t\tret = INF;\n\t\trep(i,n)ret = min(dp[(r-1)%2][i],ret);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MN 205\n#define init(a) memset(a,0x0f,sizeof(a))\n#define min(a,b) (a<b?a:b)\nint N,M,R,de[1000],S[MN][MN],L[MN][MN],i,j,k,x,y,s;\nint dp[1005][205];\n\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tinit(S);init(L);init(dp);\n\t\tfor(i=0;i<N;i++)L[i][i]=S[i][i]=0;\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tchar t;\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&s,&t);\n\t\t\tx--;y--;\n\t\t\tif(t=='L')L[x][y]=L[y][x]=s;\n\t\t\telse S[x][y]=S[y][x]=s;\n\t\t}\n\t\tfor(scanf(\"%d\",&R),i=0;i<R;de[i++]--)scanf(\"%d\",&de[i]);\n\t\tfor(k=0;k<N;k++)\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t}\n\t\tdp[0][de[i]]=0;\n\t\tfor(k=0;k<R-1;k++)\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tdp[k+1][i] = min(dp[k+1][i],dp[k][j]+L[de[k]][j]+S[j][i]+L[i][de[k+1]]);\n\t\t\t\t\tif(i==j) dp[k+1][i] = min(dp[k+1][i], dp[k][j] + L[de[k]][de[k+1]]);\n\t\t\t\t}\n\t\tfor(i=0,s=1<<25;i<N;i++)s=min(s,dp[R-1][i]);\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,p[1000],d[1000][1000],w[2][310][310];\n  int a,b,c,i,j,k,l,t,M=100000000;\n  char r;\n  while(scanf(\"%d %d\",&n,&m),n+m){\n    for(i=0;i<n*n;i++)w[0][i/n][i%n]=w[1][i/n][i%n]=M;\n    for(i=0;i<1000;i++){\n      for(j=0;j<1000;j++)d[i][j]=M;\n    }\n    for(i=0;i<n;i++)w[0][i][i]=w[1][i][i]=0;\n    while(m--){\n      scanf(\"%d %d %d %c\",&a,&b,&c,&r);\n      t=(r=='L')?0:1;\n      w[t][a-1][b-1]=w[t][b-1][a-1]=c;\n    }\n    for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  for(l=0;l<n;l++)w[i][k][l]=MIN(w[i][k][l],w[i][k][j]+w[i][j][l]);\n\t}\n      }\n    }\n    /*for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++)printf(\"%10d \",w[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&l);\n    for(i=0;i<l;i++)scanf(\"%d\",&p[i]);\n    for(i=0;i<l;i++)p[i]--;\n    d[p[0]][p[0]]=0;\n    for(i=0;i<l-1;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==M)continue;\n\td[i+1][j]=MIN(d[i+1][j],d[i][j]+w[0][p[i]][p[i+1]]);\n\tfor(k=0;k<n;k++){\n\t  d[i+1][k]=MIN(d[i+1][k],d[i][j]+w[0][p[i]][j]+w[1][j][k]+w[0][k][p[i+1]]);\n\t}\n      }\n    }\n    for(i=0;i<n;i++)d[l-1][0]=MIN(d[l-1][0],d[l-1][i]);\n    printf(\"%d\\n\",d[l-1][0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#define L(a,b)((a)<(b)?(a):(b))\nN,C[498][201],D[1000][201],i,j,k;W(int c[][201]){for(k=N;k;c[k][k]=0,k--)for(i=N;i;i--)for(j=N;j;j--)c[i][j]=L(c[i][j],c[i][k]+c[k][j]);}x,y,t,s;main(M){for(;scanf(\"%d%d\",&N,&M)*N;printf(\"%d\\n\",s)){for(memset(C,1,4e5);M--;C[s+x][y]=C[s+y][x]=L(C[s+x][y],t))scanf(\"%d%d%d%s\",&x,&y,&t,&s),s=s%2*N;W(C);W(C+N);memset(D,1,1e3);scanf(\"%d%d\",&M,&x);D[0][x]=0;for(i=1;i<M;i++,x=y)for(scanf(\"%d\",&y),s=1e9,j=N;j;s=L(s,t),D[i][j--]=t)for(t=D[i-1][j]+C[x][y],k=N;k;k--)t=L(t,D[i-1][k]+C[x][k]+C[N+k][j]+C[j][y]);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MIN(int a,int b){return a<b?a:b;}\nint main(){\n  int n,m,p[1010],d[1010][1010],w[2][310][310];\n  int a,b,c,i,j,k,l,t,M=100000000;\n  char r;\n  while(scanf(\"%d %d\",&n,&m),n+m){\n    for(i=0;i<n*n;i++)w[0][i/n][i%n]=w[1][i/n][i%n]=M;\n    for(i=0;i<1010;i++){\n      for(j=0;j<1010;j++)d[i][j]=M;\n    }\n    for(i=0;i<n;i++)w[0][i][i]=w[1][i][i]=0;\n    while(m--){\n      scanf(\"%d %d %d %c\",&a,&b,&c,&r);\n      t=(r=='L')?0:1;\n      w[t][a-1][b-1]=w[t][b-1][a-1]=c;\n    }\n    for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++){\n\t  for(l=0;l<n;l++)w[i][k][l]=MIN(w[i][k][l],w[i][k][j]+w[i][j][l]);\n\t}\n      }\n    }\n    /*for(i=0;i<2;i++){\n      for(j=0;j<n;j++){\n\tfor(k=0;k<n;k++)printf(\"%10d \",w[i][j][k]);printf(\"\\n\");\n      }printf(\"\\n\");\n      }//*/\n    scanf(\"%d\",&l);\n    for(i=0;i<l;i++)scanf(\"%d\",&p[i]);\n    for(i=0;i<l;i++)p[i]--;\n    d[0][p[0]]=0;\n    for(i=0;i<l-1;i++){\n      for(j=0;j<n;j++){\n\tif(d[i][j]==M)continue;\n\td[i+1][j]=MIN(d[i+1][j],d[i][j]+w[0][p[i]][p[i+1]]);\n\tfor(k=0;k<n;k++){\n\t  d[i+1][k]=MIN(d[i+1][k],d[i][j]+w[0][p[i]][j]+w[1][j][k]+w[0][k][p[i+1]]);\n\t}\n      }\n    }\n    for(i=0;i<n;i++)d[l-1][0]=MIN(d[l-1][0],d[l-1][i]);\n    printf(\"%d\\n\",d[l-1][0]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#define MN 205\n#define INF 100000000\n#define init(a) memset(a,0x0f,sizeof(a))\n#define min(a,b) (a<b?a:b)\nint N,M,R,de[1005],S[MN][MN],L[MN][MN],i,j,k,x,y,s;\nint dp[1005][205];\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&N,&M),N;)\n\t{\n\t\tinit(S);init(L);init(dp);\n\t\tfor(i=0;i<N;i++)L[i][i]=S[i][i]=0;\n\t\tfor(i=0;i<M;i++)\n\t\t{\n\t\t\tchar t;\n\t\t\tscanf(\"%d%d%d %c\",&x,&y,&s,&t);\n\t\t\tx--;y--;\n\t\t\tif(t=='L')L[x][y]=L[y][x]=s;\n\t\t\telse S[x][y]=S[y][x]=s;\n\t\t}\n\t\tfor(scanf(\"%d\",&R),i=0;i<R;de[i++]--)scanf(\"%d\",&de[i]);\n\t\tfor(k=0;k<N;k++)\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tS[i][j]=min(S[i][j],S[i][k]+S[k][j]);\n\t\t\t\t\tL[i][j]=min(L[i][j],L[i][k]+L[k][j]);\n\t\t\t\t}\n\t\tdp[0][de[0]]=0;\n\t\tfor(k=0;k<R-1;k++)\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t\tfor(j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tdp[k+1][i] = min(dp[k+1][i],dp[k][j]+L[de[k]][j]+S[j][i]+L[i][de[k+1]]);\n\t\t\t\t\tif(i == j) dp[k+1][i] = min(dp[k+1][i], dp[k][j] + L[de[k]][de[k+1]]);\n\t\t\t\t}\n\t\tfor(i=0,s=INF;i<N;i++)s=min(s,dp[R-1][i]);\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define min(a,b)((a)<(b)?(a):(b))\n#define inf 0x01010101\nN;//¬ºÌ\nEdge[2][201][201];//[¤H0,CH1][¬º][¬º]\nCost[201][201];//[¡³ñÌÊu][DÌÊu]:=ÅZÚ®Ô\nDone[201][201];//[¡³ñÌÊu][DÌÊu]:=ètO\nDijkstra(int*C,int start,int dest){\n\tint boat,rito,boatmin,ritomin,c,cmin;\n\tmemset(Done,0,sizeof(Done));\n\tmemset(Cost,1,sizeof(Cost));//inf\n\tmemcpy(Cost+start,C,sizeof(int)*201);//startÊuÅÌóÔ\n\tfor(;;){\n\t\t//¢èÌóÔÌàAÅZÌàÌðIð\n\t\tcmin=inf;\n\t\tfor(rito=1;rito<=N;rito++){\n\t\t\tfor(boat=1;boat<=N;boat++){\n\t\t\t\tif(!Done[rito][boat]&&Cost[rito][boat]<cmin){\n\t\t\t\t\tritomin=rito;\n\t\t\t\t\tboatmin=boat;\n\t\t\t\t\tcmin=Cost[rito][boat];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cmin==inf)\n\t\t\tbreak;\n\t\t//»êðèÆ·é\n\t\tDone[ritomin][boatmin]=1;\n\t\t//×ÚóÔðXV\n\t\tfor(rito=1;rito<=N;rito++){\n\t\t\t//¤H\n\t\t\tc=Cost[ritomin][boatmin]+Edge[0][ritomin][rito];\n\t\t\tif(c<Cost[rito][boatmin]){\n\t\t\t\tCost[rito][boatmin]=c;\n\t\t\t}\n\t\t\t//»±ÉDª êÎCH\n\t\t\tif(ritomin==boatmin){\n\t\t\t\tc=Cost[ritomin][boatmin]+Edge[1][ritomin][rito];\n\t\t\t\tif(c<Cost[rito][rito]){\n\t\t\t\t\tCost[rito][rito]=c;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tmemcpy(C,Cost+dest,sizeof(int)*201);//destÊuÅÌóÔ\n}\nmain(){\n\tint M,R,z;\n\tint C[201];//[DÌÊu]:=ÅZÚ®Ô\n\tfor(;scanf(\"%d%d\",&N,&M)*N;){\n\t\tmemset(Edge,1,sizeof(Edge));//inf\n\t\tfor(;M--;){\n\t\t\tint x,y,t,s;\n\t\t\tchar sl[2];\n\t\t\tscanf(\"%d%d%d%s\",&x,&y,&t,sl);\n\t\t\ts=sl[0]=='L'?0:1;\n\t\t\tEdge[s][x][y]=min(Edge[s][x][y],t);\n\t\t\tEdge[s][y][x]=min(Edge[s][y][x],t);\n\t\t}\n\t\tscanf(\"%d%d\",&R,&z);\n\t\tmemset(C,1,sizeof(C));//inf\n\t\tC[z]=0;\n\t\tfor(;--R;){\n\t\t\tint Z;\n\t\t\tscanf(\"%d\",&Z);\n\t\t\tDijkstra(C,z,Z);\n\t\t\tz=Z;\n\t\t}\n\t\t{\n\t\t\tint c=1<<20;\n\t\t\tfor(z=1;z<=N;z++)\n\t\t\t\tc=min(c,C[z]);\n\t\t\tprintf(\"%d \\n\",c);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    ArrayList[] cost;\n    int n, m, r;\n    int[] z;\n    int INF = 1000000000;\n    int[][][] rikumi;\n    int[][] rikuOnly;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            cost = new ArrayList[n];\n            for(int i=0; i<n; i++) cost[i] = new ArrayList<Integer>();\n\n            rikumi = new int[n][n][2];//cost, riku or umi\n            rikuOnly = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(rikuOnly[i], INF);\n            for(int i=0; i<n; i++) rikuOnly[i][i] = 0;\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, tt = sc.nextInt();\n                String s = sc.next();\n                int ss = 0;\n\n                if(s.equals(\"S\")) ss = 1;\n                cost[x].add(new Integer(y));\n                cost[y].add(new Integer(x));\n                rikumi[x][y][0] = tt;\n                rikumi[x][y][1] = ss;\n                rikumi[y][x][0] = tt;\n                rikumi[y][x][1] = ss;\n                if(ss==0){\n                    rikuOnly[x][y] = tt;\n                    rikuOnly[y][x] = tt; \n                }\n            }\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++) rikuOnly[i][j] = Math.min(rikuOnly[i][j], rikuOnly[i][k] + rikuOnly[k][j]);\n                }\n            }\n\n            r = sc.nextInt();\n            z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int ans = dijkstra();\n            System.out.println(ans);\n        }\n    }\n\n    int dijkstra(){\n        //pos, time, next, fune\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[1] - b[1];\n                }\n            });\n        if(z[0]==0) q.add(new int[]{0,0,1,0,0});\n        else q.add(new int[]{0,0,0,0,0});\n\n\n        int[][][] v = new int[n][r][n];\n        for(int i=0; i<n; i++){\n            for(int j=0; j<r; j++){\n                for(int k=0; k<n; k++){\n                    v[i][j][k] = INF;\n                }\n            }\n        }\n         \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], time = qq[1], next = qq[2], fune = qq[3];\n\n            if(next==r){\n                return time;\n            }\n            if(v[pos][next][fune]<=time) continue;\n            v[pos][next][fune] = time;\n\n            for(int i=0; i<cost[pos].size(); i++){\n                int t1 = (int)(cost[pos].get(i));\n                int t2 = rikumi[pos][t1][0];\n                int t3 = rikumi[pos][t1][1];\n                if(t3==1){//umi\n                    if(rikuOnly[fune][pos]==INF) continue;\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next+1, t1});\n                    else q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next, t1});\n                }else{//riku\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2, next+1, fune});\n                    else q.add(new int[]{t1, time+t2, next, fune});\n                }\n                \n            }\n        }\n        return INF;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main\n{\n    private static final int INF = (int) 1e8;\n    public static void floyd(int[][] dl, int[][] ds)\n    {\n        int n = dl.length;\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                    ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt(), m = in.nextInt();\n            if (n == 0 && m == n)\n            {\n                break;\n            }\n            int[][] dp = new int[1024][n];\n            int[][] dl = new int[n][n];\n            int[][] ds = new int[n][n];\n\n            for (int i = 0; i < n; i++)\n            {\n                Arrays.fill(dp[i], INF);\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                ds[i][i] = 0;\n                dl[i][i] = 0;\n            }\n            for (int i = 0; i < m; i++)\n            {\n                int v = in.nextInt(), w = in.nextInt(), t = in.nextInt();\n                String c = in.next();\n                v--;w--;\n                if (c.equals(\"L\"))\n                {\n                    dl[v][w] = Math.min(dl[v][w], t);\n                    dl[w][v] = dl[v][w];\n                }\n                else\n                {\n                    ds[v][w] = Math.min(ds[v][w], t);\n                    ds[w][v] = ds[v][w];\n                }\n            }\n            floyd(dl, ds);\n            int r = in.nextInt();\n            int[] nums = new int[r];\n            for (int i = 0; i < r; i++)\n            {\n                nums[i] = in.nextInt();\n                nums[i]--;\n            }\n            for (int i = 0; i < n; i++)\n            {\n                dp[0][i] = ds[nums[0]][i] + dl[i][nums[0]];\n            }\n\n            for (int i = 1; i < r; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    for (int k = 0; k < n; k++)\n                    {\n                        if (j != k)\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + dl[nums[i-1]][j] + ds[j][k] + dl[k][nums[i]]);\n                        }\n                        else\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j]+dl[nums[i-1]][nums[i]]);\n                        }\n                    }\n                }\n            }\n\n            int cost = INF;\n            for (int i = 0; i < n; i++)\n            {\n                cost = Math.min(dp[r-1][i], cost);\n            }\n\n            System.out.println(cost);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M, R;\n\tstatic int[] x, y, z, r;\n\tstatic long[] l;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tfinal int INF = 1 << 28;\n\t\tint[][] dl = new int[N][N];\n\t\tint[][] ds = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdl[i][j] = ds[i][j] = INF;\n\t\t\t}\n\t\t\tdl[i][i] = ds[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint X = Integer.parseInt(sc.next()) - 1;\n\t\t\tint Y = Integer.parseInt(sc.next()) - 1;\n\t\t\tint T = Integer.parseInt(sc.next());\n\t\t\tboolean land = sc.next().charAt(0) == 'L';\n\t\t\tif (land) {\n\t\t\t\tdl[X][Y] = dl[Y][X] = Math.min(dl[X][Y], T);\n\t\t\t} else {\n\t\t\t\tds[X][Y] = ds[Y][X] = Math.min(ds[X][Y], T);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tdl[j][k] = Math.min(dl[j][k], dl[j][i] + dl[i][k]);\n\t\t\t\t\tds[j][k] = Math.min(ds[j][k], ds[j][i] + ds[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tR = sc.nextInt();\n\t\tint PZ = sc.nextInt() - 1;\n\t\tint[][] dp = new int[2][N];\n\t\tArrays.fill(dp[0], INF);\n\t\tArrays.fill(dp[1], INF);\n\t\tdp[0][PZ] = 0;\n\t\tint t = 1;\n\t\tfor (int i = 1; i < R; ++i) {\n\t\t\tint Z = sc.nextInt() - 1;\n\t\t\tArrays.fill(dp[t], INF);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (dp[t ^ 1][j] == INF) continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tdp[t][k] = Math.min(dp[t][k], dp[t ^ 1][j] + dl[PZ][j] + ds[j][k] + dl[k][Z]);\n\t\t\t\t}\n\t\t\t\tdp[t][j] = Math.min(dp[t][j], dp[t ^ 1][j] + dl[PZ][Z]);\n\t\t\t}\n\t\t\tt ^= 1;\n\t\t\tPZ = Z;\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = Math.min(ans, dp[t ^ 1][i]);\n\t\t}\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();//the number of cities\n\t\t\tint m=sc.nextInt();//the number of paths\n\t\t\tif(n==0&&m==0)break;\n\t\t\tint INF=Integer.MAX_VALUE/4;\n\t\t\tint[][] ldis=new int[n][n];\n\t\t\tint[][] sdis=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tldis[i][j]=INF;\n\t\t\t\t\tsdis[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"L\")){\n\t\t\t\t\tldis[x][y]=t;\n\t\t\t\t\tldis[y][x]=t;\n\t\t\t\t}else if(str.equals(\"S\")){\n\t\t\t\t\tsdis[x][y]=t;\n\t\t\t\t\tsdis[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tldis[i][j]=Math.min(ldis[i][j],ldis[i][k]+ldis[k][j]);\n\t\t\t\t\t\tsdis[i][j]=Math.min(sdis[i][j],sdis[i][k]+sdis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=sc.nextInt();\n\t\t\tint[] destination=new int[r];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tdestination[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tint[][] dp=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][0]=0;//dp[i][j]???i???????????§?¨?????????????j????????????????????´???????????????\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==j){\n\t\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][destination[i-1]]+dp[i-1][j]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][j]+sdis[j][k]+ldis[k][destination[i-1]]+dp[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min=9999999;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmin=Math.min(dp[r-1][i],min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint[][] sea;\n\tint[][] land;\n\tstatic final int INF = 1<<28;\n\tint N, R;\n\tint[] tar;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tint M = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tsea = new int[N][N];\n\t\t\tland = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = land[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint x = in.nextInt()-1,\n\t\t\t\t\ty = in.nextInt()-1,\n\t\t\t\t\tt = in.nextInt();\n\t\t\t\tString wh = in.next();\n\t\t\t\tif(wh.equals(\"S\")){\n\t\t\t\t\tsea[x][y] = min(sea[x][y], t);\n\t\t\t\t\tsea[y][x] = sea[x][y];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tland[x][y] = min(land[x][y], t);\n\t\t\t\t\tland[y][x] = land[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tR = in.nextInt();\n\t\t\ttar = new int[R];\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\ttar[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tfor(int i=0; i<N; i++){\n\t\t\tsea[i][i] = land[i][i] = 0;\n\t\t}\n\t\tfor(int k=0; k<N; k++){\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[R][N];\n\t\tfor(int i=0; i<R; i++){\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[tar[0]][tar[0]] = 0;\n\t\tfor(int k=0; k<R-1; k++){\n\t\t\tfor(int i=0; i<N; i++)if(dp[k][i] != INF){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tdp[k+1][j] = min(dp[k+1][j], dp[k][i]+land[tar[k]][i]+sea[i][j]+land[j][tar[k+1]]);\n\t\t\t\t}\n\t\t\t\tdp[k+1][i] = min(dp[k+1][i], dp[k][i] + land[tar[k]][tar[k+1]]);\n\t\t\t}\n\t\t}\n\t\tint ret = INF;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tret = min(ret, dp[R-1][i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M, R;\n\tstatic int[] x, y, z, r;\n\tstatic long[] l;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tM = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tstatic int solve() {\n\t\tfinal int INF = 1 << 28;\n\t\tint[][] dl = new int[N][N];\n\t\tint[][] ds = new int[N][N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tdl[i][j] = ds[i][j] = INF;\n\t\t\t}\n\t\t\tdl[i][i] = ds[i][i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint X = sc.nextInt() - 1;\n\t\t\tint Y = sc.nextInt() - 1;\n\t\t\tint T = sc.nextInt();\n\t\t\tboolean land = sc.next().charAt(0) == 'L';\n\t\t\tif (land) {\n\t\t\t\tdl[X][Y] = dl[Y][X] = Math.min(dl[X][Y], T);\n\t\t\t} else {\n\t\t\t\tds[X][Y] = ds[Y][X] = Math.min(ds[X][Y], T);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tdl[j][k] = Math.min(dl[j][k], dl[j][i] + dl[i][k]);\n\t\t\t\t\tds[j][k] = Math.min(ds[j][k], ds[j][i] + ds[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tR = sc.nextInt();\n\t\tint PZ = sc.nextInt() - 1;\n\t\tint[][] dp = new int[2][N];\n\t\tArrays.fill(dp[0], INF);\n\t\tArrays.fill(dp[1], INF);\n\t\tdp[0][PZ] = 0;\n\t\tint t = 1;\n\t\tfor (int i = 1; i < R; ++i) {\n\t\t\tint Z = sc.nextInt() - 1;\n\t\t\tArrays.fill(dp[t], INF);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tif (dp[t ^ 1][j] == INF) continue;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tdp[t][k] = Math.min(dp[t][k], dp[t ^ 1][j] + dl[PZ][j] + ds[j][k] + dl[k][Z]);\n\t\t\t\t}\n\t\t\t\tdp[t][j] = Math.min(dp[t][j], dp[t ^ 1][j] + dl[PZ][Z]);\n\t\t\t}\n\t\t\tt ^= 1;\n\t\t\tPZ = Z;\n\t\t}\n\t\tint ans = INF;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans = Math.min(ans, dp[t ^ 1][i]);\n\t\t}\n\t\treturn ans;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint purpos;\n\t\tint cur_place;\n\t\tint cur_boat;\n\t\tint time;\n\t\t\n\t\tpublic Walk(int purpos, int cur_place, int cur_boat, int time) {\n\t\t\tsuper();\n\t\t\tthis.purpos = purpos;\n\t\t\tthis.cur_place = cur_place;\n\t\t\tthis.cur_boat = cur_boat;\n\t\t\tthis.time = time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.time - arg0.time;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] land_adj = new int[n][n];\n\t\t\tint[][] sea_adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(land_adj[i], Integer.MAX_VALUE);\n\t\t\t\tArrays.fill(sea_adj[i], Integer.MAX_VALUE);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\tfinal String str = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"L\".equals(str)){\n\t\t\t\t\tland_adj[x][y] = land_adj[y][x] = Math.min(land_adj[x][y], cost);\n\t\t\t\t}else{\n\t\t\t\t\tsea_adj[x][y] = sea_adj[y][x] = Math.min(sea_adj[x][y], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tint[] purpos_place = new int[r];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tpurpos_place[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][][] is_visited = new boolean[r][n][n];\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(0, purpos_place[0], purpos_place[0], 0));\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.purpos + \"[\" + purpos_place[walk.purpos] +  \"]\" + \" \" + walk.cur_place + \" \" + walk.cur_boat + \" \" + walk.time);\n\t\t\t\t\n\t\t\t\tif(walk.purpos == n){\n\t\t\t\t\tSystem.out.println(walk.time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.purpos][walk.cur_place][walk.cur_boat]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[walk.purpos][walk.cur_place][walk.cur_boat] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(purpos_place[walk.purpos] == walk.cur_place){\n\t\t\t\t\tqueue.add(new Walk(walk.purpos + 1, walk.cur_place, walk.cur_boat, walk.time));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int to = 0; to < n; to++){\n\t\t\t\t\tif(walk.cur_place == to){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(land_adj[walk.cur_place][to] != Integer.MAX_VALUE && !is_visited[walk.purpos][to][walk.cur_boat]){\n\t\t\t\t\t\tqueue.add(new Walk(walk.purpos, to, walk.cur_boat, walk.time + land_adj[walk.cur_place][to]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(walk.cur_boat == walk.cur_place){\n\t\t\t\t\t\tif(sea_adj[walk.cur_place][to] != Integer.MAX_VALUE && !is_visited[walk.purpos][to][to]){\n\t\t\t\t\t\t\tqueue.add(new Walk(walk.purpos, to, to, walk.time + sea_adj[walk.cur_place][to]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tint INF = 1<<28;\n\tint N = 220;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif( (n|m) == 0) break;\n\t\t\t\n\t\t\tint[][] l = new int[N][N]; for(int[] a: l) fill(a, INF);\n\t\t\tint[][] s = new int[N][N]; for(int[] b: s) fill(b, INF);\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tl[i][i] = s[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif(sl.charAt(0) == 'L') l[x][y] = l[y][x] = min(l[x][y], t);\n\t\t\t\telse s[x][y] = s[y][x] = min(s[x][y], t);\n\t\t\t}\n\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tint R = sc.nextInt();\n\t\t\tint r[] = new int[R];\n\t\t\tfor(int i=0;i<n;i++) r[i] = sc.nextInt()-1;\n\t\t\t\n\t\t\tint[][] dp = new int[R][N]; for(int[] a: dp) fill(a, INF);\n\t\t\tdp[0][r[0]] = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<R-1;i++) for(int j=0;j<n;j++) { //ship now\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + l[r[i]][r[i+1]]);\n\t\t\t\tfor(int k=0;k<n;k++) { //ship next\n\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j] + l[r[i]][j] + s[j][k] + l[k][r[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int[] a: l)debug(a);\n//\t\t\tfor(int[] a: s)debug(a);\n//\t\t\tfor(int[] a: dp)debug(a);\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0;i<n;i++) ans = min(ans, dp[R-1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t} \n\t}\n\t\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args ) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Mr. Rito Post Office\npublic class Main{\n\n\tclass E{\n\t\tint t, d;\n\t\tchar c;\n\t\tpublic E(int t, int d, char c) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tint INF = 1<<29;\n\tint[][] dist;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tList<E>[] adj = new List[n+1];\n\t\t\tfor(int i=0;i<=n;i++)adj[i]=new ArrayList<E>();\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tadj[s].add(new E(t, d, c)); adj[t].add(new E(s, d, c));\n\t\t\t}\n\t\t\tint R = sc.nextInt();\n\t\t\tint[] v = new int[R];\n\t\t\tfor(int i=0;i<R;i++)v[i]=sc.nextInt();\n\t\t\tint[][] pre = new int[n+1][n+1];\n\t\t\tfor(int[]a:pre)Arrays.fill(a, INF);\n\t\t\tpre[v[0]][v[0]] = 0;\n\t\t\tfor(int k=1;k<R;k++){\n\t\t\t\tdist = new int[n+1][n+1];\n\t\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>() {\n\t\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\t\treturn dist[o1[0]][o1[1]]-dist[o2[0]][o2[1]];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tdist[v[k-1]][i] = pre[v[k-1]][i]; q.add(new int[]{v[k-1], i});\n\t\t\t\t}\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[] P = q.poll();\n\t\t\t\t\tint p = P[0], s = P[1];\n\t\t\t\t\tif(p==v[k])continue;\n\t\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\t\tif(e.c=='L'){\n\t\t\t\t\t\t\tint w = dist[p][s]+e.d;\n\t\t\t\t\t\t\tif(w<dist[e.t][s]){\n\t\t\t\t\t\t\t\tdist[e.t][s] = w; q.add(new int[]{e.t, s});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(p==s){\n\t\t\t\t\t\t\tint w = dist[p][s]+e.d;\n\t\t\t\t\t\t\tif(w<dist[e.t][e.t]){\n\t\t\t\t\t\t\t\tdist[e.t][e.t] = w; q.add(new int[]{e.t, e.t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpre = dist;\n\t\t\t}\n\t\t\tint res = INF;\n\t\t\tfor(int i=1;i<=n;i++)res = Math.min(res, pre[v[R-1]][i]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic IO io = new IO();\n\tstatic int INF = 1 << 29;\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tpublic static boolean solve() {\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tif (n == 0) return false;\n\t\t\n\t\tint[][] distLand = new int[n][n];\n\t\tint[][] distSea  = new int[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif (i != j) distLand[i][j] = distSea[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint x = io.nextInt() - 1;\n\t\t\tint y = io.nextInt() - 1;\n\t\t\tint t = io.nextInt();\n\t\t\tchar sl = io.nextChar();\n\t\t\tif (sl == 'L') {\n\t\t\t\tdistLand[x][y] = Math.min(distLand[x][y], t);\n\t\t\t\tdistLand[y][x] = Math.min(distLand[y][x], t);\n\t\t\t}else{\n\t\t\t\tdistSea[x][y] = Math.min(distSea[x][y], t);\n\t\t\t\tdistSea[y][x] = Math.min(distSea[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tdistLand[i][j] = Math.min(distLand[i][j], distLand[i][k] + distLand[k][j]);\n\t\t\t\t\tdistSea[i][j] = Math.min(distSea[i][j], distSea[i][k] + distSea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r = io.nextInt();\n\t\tint[] z = new int[r];\n\t\tfor(int i=0;i<r;i++) {\n\t\t\tz[i] = io.nextInt() - 1;\n\t\t}\n\t\tint[][] dp = new int[r][n];\n\t\tfor(int i=0;i<r;i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=0;i<r-1;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif (dp[i][j] == INF) continue;\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tif (j == k) {\n//\t\t\t\t\t\tSystem.out.println(i + \":\" + j + \"->\" + k + \":\" + (distLand[z[i]][z[i+1]]));\n\t\t\t\t\t\tdp[i+1][k] = Math.min(dp[i+1][k], dp[i][j] + distLand[z[i]][z[i+1]]);\n\t\t\t\t\t}else{\n//\t\t\t\t\t\tSystem.out.println(i + \":\" + j + \"->\" + k + \":\" + (distLand[z[i]][j] + distSea[j][k] + distLand[k][z[i+1]]));\n\t\t\t\t\t\tdp[i+1][k] = Math.min(dp[i+1][k], dp[i][j] + distLand[z[i]][j] + distSea[j][k] + distLand[k][z[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans = Math.min(ans, dp[r-1][i]);\n\t\t}\n\t\tio.println(ans);\n\t\t\n\t\treturn true;\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint purpos;\n\t\tint cur_place;\n\t\tint cur_boat;\n\t\tint time;\n\t\t\n\t\tpublic Walk(int purpos, int cur_place, int cur_boat, int time) {\n\t\t\tsuper();\n\t\t\tthis.purpos = purpos;\n\t\t\tthis.cur_place = cur_place;\n\t\t\tthis.cur_boat = cur_boat;\n\t\t\tthis.time = time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.time - arg0.time;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] land_adj = new int[n][n];\n\t\t\tint[][] sea_adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(land_adj[i], Integer.MAX_VALUE);\n\t\t\t\tArrays.fill(sea_adj[i], Integer.MAX_VALUE);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\tfinal String str = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"L\".equals(str)){\n\t\t\t\t\tland_adj[x][y] = land_adj[y][x] = Math.min(land_adj[x][y], cost);\n\t\t\t\t}else{\n\t\t\t\t\tsea_adj[x][y] = sea_adj[y][x] = Math.min(sea_adj[x][y], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tint[] purpos_place = new int[r];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tpurpos_place[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][][] is_visited = new boolean[r][n][n];\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(0, purpos_place[0], purpos_place[0], 0));\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\t//System.out.println(walk.purpos + \"[\" + purpos_place[walk.purpos] +  \"]\" + \" \" + walk.cur_place + \" \" + walk.cur_boat + \" \" + walk.time);\n\t\t\t\t\n\t\t\t\tif(walk.purpos == r){\n\t\t\t\t\tSystem.out.println(walk.time);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.purpos][walk.cur_place][walk.cur_boat]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[walk.purpos][walk.cur_place][walk.cur_boat] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(purpos_place[walk.purpos] == walk.cur_place){\n\t\t\t\t\tqueue.add(new Walk(walk.purpos + 1, walk.cur_place, walk.cur_boat, walk.time));\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int to = 0; to < n; to++){\n\t\t\t\t\tif(walk.cur_place == to){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(land_adj[walk.cur_place][to] != Integer.MAX_VALUE && !is_visited[walk.purpos][to][walk.cur_boat]){\n\t\t\t\t\t\tqueue.add(new Walk(walk.purpos, to, walk.cur_boat, walk.time + land_adj[walk.cur_place][to]));\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t//if can use boat?\n\t\t\t\t\tif(walk.cur_boat == walk.cur_place){\n\t\t\t\t\t\tif(sea_adj[walk.cur_place][to] != Integer.MAX_VALUE && !is_visited[walk.purpos][to][to]){\n\t\t\t\t\t\t\tqueue.add(new Walk(walk.purpos, to, to, walk.time + sea_adj[walk.cur_place][to]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tint[][] dp;\n\tint INF = 1 << 20;\n\n\tint dp(int k, int s) {\n\t\tif (k == r - 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp[k][s]) {\n\t\t\treturn dp[k][s];\n\t\t}\n\n\t\tint res = INF;\n\n\t\tint pos = perm[k];\n\t\tint npos = perm[k + 1];\n\n\t\tif (pos == s) {\n\t\t\tres = Math.min(res, ld[pos][npos] + dp(k + 1, s));\n\t\t\tres = Math.min(res, sd[pos][npos] + dp(k + 1, npos));\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, sd[pos][i] + ld[i][npos] + dp(k + 1, i));\n\t\t\t}\n\t\t} else {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, ld[pos][s] + sd[s][npos] + dp(k + 1, npos));\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, ld[pos][s] + sd[s][i] + ld[i][npos] + dp(k + 1, i));\n\t\t\t}\n\t\t}\n\n\t\treturn dp[k][s] = res;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(ld[i], INF);\n\t\t\t\tArrays.fill(sd[i], INF);\n\t\t\t\tld[i][i] = sd[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tld[i][j] = Math.min(ld[i][j], ld[i][k] + ld[k][j]);\n\t\t\t\t\t\tsd[i][j] = Math.min(sd[i][j], sd[i][k] + sd[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new int[r][n];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tint ans = dp(0, perm[0]);\n\t\t\tSystem.out.println(ans);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Mr. Rito Post Office\npublic class Main{\n\n\tclass E{\n\t\tint t, d;\n\t\tchar c;\n\t\tpublic E(int t, int d, char c) {\n\t\t\tthis.t = t;\n\t\t\tthis.d = d;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\n\tint INF = 1<<29;\n\tint[][] dist;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tList<E>[] adj = new List[n+1];\n\t\t\tfor(int i=0;i<=n;i++)adj[i]=new ArrayList<E>();\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), d = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tadj[s].add(new E(t, d, c)); adj[t].add(new E(s, d, c));\n\t\t\t}\n\t\t\tint R = sc.nextInt();\n\t\t\tint[] v = new int[R];\n\t\t\tfor(int i=0;i<R;i++)v[i]=sc.nextInt();\n\t\t\tint[][] pre = new int[n+1][n+1];\n\t\t\tfor(int[]a:pre)Arrays.fill(a, INF);\n\t\t\tpre[v[0]][v[0]] = 0;\n\t\t\tfor(int k=1;k<R;k++){\n\t\t\t\tdist = new int[n+1][n+1];\n\t\t\t\tfor(int[]a:dist)Arrays.fill(a, INF);\n\t\t\t\tPriorityQueue<int[]> q = new PriorityQueue<int[]>(n, new Comparator<int[]>() {\n\t\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\t\treturn dist[o1[0]][o1[1]]-dist[o2[0]][o2[1]];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\t\tdist[v[k-1]][i] = pre[v[k-1]][i]; q.add(new int[]{v[k-1], i});\n\t\t\t\t}\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint[] P = q.poll();\n\t\t\t\t\tint p = P[0], s = P[1];\n\t\t\t\t\tfor(E e:adj[p]){\n\t\t\t\t\t\tif(e.c=='L'){\n\t\t\t\t\t\t\tint w = dist[p][s]+e.d;\n\t\t\t\t\t\t\tif(w<dist[e.t][s]){\n\t\t\t\t\t\t\t\tdist[e.t][s] = w; q.add(new int[]{e.t, s});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(p==s){\n\t\t\t\t\t\t\tint w = dist[p][s]+e.d;\n\t\t\t\t\t\t\tif(w<dist[e.t][e.t]){\n\t\t\t\t\t\t\t\tdist[e.t][e.t] = w; q.add(new int[]{e.t, e.t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpre = dist;\n\t\t\t}\n\t\t\tint res = INF;\n\t\t\tfor(int i=1;i<=n;i++)res = Math.min(res, pre[v[R-1]][i]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong INF = 1 << 60;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tlong land[][] = new long[n + 1][n + 1];\n\t\t\tlong sea[][] = new long[n + 1][n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif (sl.equals(\"L\")) {\n\t\t\t\t\tland[x][y] = land[y][x] = Math.min(t, land[x][y]);\n\t\t\t\t} else {\n\t\t\t\t\tsea[x][y] = sea[y][x] = Math.min(t, sea[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]\n\t\t\t\t\t\t\t\t+ land[k][j]);\n\t\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] zs = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tzs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tlong[][] dp = new long[r][n + 1]; // dp[i][j]\n\t\t\t\t\t\t\t\t\t\t\t\t// i番目までの配達を終え、船がjにあるときの最短時間。\n\t\t\tlong LINF = 1 << 60;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], LINF);\n\t\t\t}\n\t\t\tdp[0][zs[0]] = 0;\n\t\t\tfor (int i = 1; i < r; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k]\n\t\t\t\t\t\t\t\t+ land[zs[i - 1]][k] + sea[k][j]\n\t\t\t\t\t\t\t\t+ land[j][zs[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = LINF;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tans = Math.min(dp[r - 1][i], ans);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static IO io = new IO();\n    private static int dl[][] = new int[201][201];  // ???i,j??????????????????????????¢\n    private static int ds[][] = new int[201][201];  // ???i,j??????????????????????????¢\n    private static int dp[][] = new int[1001][201];  // i????????????????????????????????????j???????????´??????????°??????????\n    private static int rs[] = new int[1001]; // i??????????????????\n    private static int INF = 114514194;\n    public static void main(String[] args) {\n        while (true) {\n\n            int n = io.nextInt();\n            int m = io.nextInt();\n            if (n==0 && m==0) break;\n\n            // ?????????\n            for (int i=0; i<=n; i++) {\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n                Arrays.fill(dp[i], INF);\n                dl[i][i] = ds[i][i] = 0;\n            }\n\n            // ??\\???\n            for (int i = 0; i < m; i++) {\n                int x = io.nextInt();\n                int y = io.nextInt();\n                int t = io.nextInt();\n                char s = io.nextChar();\n                if (s=='L') {\n                    dl[x][y] = dl[y][x] = t;\n                } else {\n                    ds[x][y] = ds[y][x] = t;\n                }\n            }\n            int r = io.nextInt();\n            for (int i = 1; i <= r; i++) rs[i] = io.nextInt();\n            dp[1][rs[1]] = 0;\n\n            // ???????????£????????????????????§??????????????????/????????????????????¢????????????????±???????\n            for (int i = 1; i <= n; i++) {\n                for (int j = 1; j <= n; j++) {\n                    for (int k = 1; k <= n; k++) {\n                        dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                        ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                    }\n                }\n            }\n\n            // dp?????§??????????¨????\n            for (int i = 1; i < r; i++) {\n                int pos = rs[i+1];\n                int pre = rs[i];\n                for (int j = 1; j <= n; j++) {\n                    for (int k = 1; k <= n; k++) {\n                        if (j==k) dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j] + dl[pre][pos]);\n                        else dp[i+1][j] = Math.min(dp[i+1][j], dp[i][k] + dl[pre][k] + ds[k][j] + dl[j][pos]);\n                    }\n                }\n            }\n\n            int ans = INF;\n            for (int i = 1; i <= n; i++) ans = Math.min(ans, dp[r][i]);\n            System.out.println(ans);\n\n        }\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean isNewLine(int c) {\n            return c == '\\n' || c == '\\r';\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        void skipNewLine() {\n            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        boolean hasNextLine() {\n            skipNewLine();\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        char[] nextCharArray(int len) {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                if (i == len) {\n                    throw new InputMismatchException();\n                }\n                s[i++] = (char) b;\n                b = readByte();\n            }\n            return s;\n        }\n\n        String nextLine() {\n            if (!hasNextLine()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isNewLine(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] arrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] arrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        double[] arrayDouble(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        void arrayInt(int[]... a) {\n            for (int i = 0; i < a[0].length; i++) for (int j = 0; j < a.length; j++) a[j][i] = nextInt();\n        }\n\n        int[][] matrixInt(int n, int m) {\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) a[i] = arrayInt(m);\n            return a;\n        }\n\n        char[][] charMap(int n, int m) {\n            char[][] a = new char[n][];\n            for (int i = 0; i < n; i++) a[i] = nextCharArray(m);\n            return a;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint[][] sea;\n\tint[][] land;\n\tstatic final int INF = 1<<28;\n\tint N, R;\n\tint[] tar;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tint M = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tsea = new int[N][N];\n\t\t\tland = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = land[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint x = in.nextInt()-1,\n\t\t\t\t\ty = in.nextInt()-1,\n\t\t\t\t\tt = in.nextInt();\n\t\t\t\tString wh = in.next();\n\t\t\t\tif(wh.equals(\"S\")){\n\t\t\t\t\tsea[x][y] = min(sea[x][y], t);\n\t\t\t\t\tsea[y][x] = sea[x][y];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tland[x][y] = min(land[x][y], t);\n\t\t\t\t\tland[y][x] = land[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tR = in.nextInt();\n\t\t\ttar = new int[R];\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\ttar[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tfor(int i=0; i<N; i++){\n\t\t\tsea[i][i] = land[i][i] = 0;\n\t\t}\n\t\tfor(int k=0; k<N; k++){\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[R][N];\n\t\tfor(int i=0; i<R; i++){\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<N; i++){\n\t\t\tdp[0][i] = min(dp[0][i], sea[0][i] + land[i][tar[0]]);\n\t\t}\n\t\tfor(int k=0; k<R-1; k++){\n\t\t\tfor(int i=0; i<N; i++)if(dp[k][i] != INF){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tdp[k+1][j] = min(dp[k+1][j], dp[k][i]+land[tar[k]][i]+sea[i][j]+land[j][tar[k+1]]);\n\t\t\t\t}\n\t\t\t\tdp[k+1][i] = min(dp[k+1][i], dp[k][i] + land[tar[k]][tar[k+1]]);\n\t\t\t}\n\t\t}\n\t\tint ret = INF;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tret = min(ret, dp[R-1][i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N, M, R;\n\tstatic int[] Z = new int[1000];\n\tstatic int[][] WL = new int[201][201], WS = new int[201][201];\n\tstatic final int INF = 1 << 29;\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tif (N == 0 && M == 0) return false;\n\t\t\n\t\tfor (int i = 0; i < 201; i++) {\n\t\t\tfill(WL[i], INF); \n\t\t\tfill(WS[i], INF);\n\t\t\tWL[i][i] = WS[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tt = sc.nextInt();\n\t\t\tsl = sc.next().charAt(0);\n\t\t\tif (sl == 'S') {\n\t\t\t\tWS[x][y] = WS[y][x] = t;\n\t\t\t} else {\n\t\t\t\tWL[x][y] = WL[y][x] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tR = sc.nextInt();\n\t\tfor (int i = 0; i < R; i++) Z[i] = sc.nextInt();\n\t\treturn true;\n\t}\n\n\tstatic void solve() {\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.offer(new State(0, Z[0], 0));\n\t\tint ans = INF;\n\t\tfor (int k = 1; k < 201; k++) {\n\t\t\tfor (int i = 1; i < 201; i++) { \n\t\t\t\tfor (int j = 1; j < 201; j++) {\n\t\t\t\t\tWL[i][j] = min(WL[i][j], WL[i][k] + WL[k][j]);\n\t\t\t\t\tWS[i][j] = min(WS[i][j], WS[i][k] + WS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\n\t\t\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\t\t\tif (s.cur == R - 1) {\n\t\t\t\tans = s.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint cur = s.cur, from = Z[s.cur], to = Z[s.cur + 1], cost = s.cost, ship = s.ship;\n\t\t\t// ツ猟、ツ路ツづーツ使ツつ、\n\t\t\tque.offer(new State(s.cur + 1, ship, cost + WL[from][to]));\n\t\t\t\n\t\t\t// ツ海ツ路ツづーツ使ツつ、\n\t\t\tfor (int k = 1; k < 201; k++) {\n\t\t\t\tint ncost = cost + WL[from][ship] + WS[ship][k] + WL[k][to], nship = k;\n\t\t\t\tque.offer(new State(s.cur + 1, nship, ncost));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\t\n}\n\nclass State implements Comparable<State> {\n\tint cur, ship, cost;\n\tState (int cur, int ship, int cost) {\n\t\tthis.cur = cur;\n\t\tthis.ship = ship;\n\t\tthis.cost = cost;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.cost - s.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\tfinal static int INF = 10000000;\n\tboolean solve(){\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tPos.n = n;\n\t\tif(n ==0) return false;\n\t\tint[][] land = new int[n][n];\n\t\tint[][] sea = new int[n][n];\n\t\tNode[] node = new Node[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tland[i][j] = INF;\n\t\t\t\tsea[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x = in.nextInt()-1;\n\t\t\tint y = in.nextInt()-1;\n\t\t\tint t = in.nextInt();\n\t\t\tchar sl = in.next().charAt(0);\n\t\t\tnode[x].createEdge(node[y]);\n\t\t\tnode[y].createEdge(node[x]);\n\t\t\tif(sl == 'L'){\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}else{\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\t\tint r = in.nextInt();\n\t\tint[] z = new int[r];\n\t\tfor(int i=0; i<r; i++) z[i] = in.nextInt()-1;\n\t\tfor(int k=0; k<n; k++)\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t}\n\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n\t\tqu.add(new Pos(0, z[0], 0));\n\t\tBitSet used = new BitSet(n*n);\n\t\tint res = -1;\n\t\twhile(!qu.isEmpty()){\n\t\t\tPos p = qu.poll();\n\t\t\tif(used.get(p.id)) continue;\n\t\t\tif(p.z == r-1){\n\t\t\t\tres = p.dist;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused.set(p.id);\n\t\t\tif(land[z[p.z]][z[p.z+1]] < INF){\n\t\t\t\tqu.add(new Pos(p.z+1, p.boat, p.dist+land[z[p.z]][z[p.z+1]]));\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tif(land[z[p.z]][p.boat] == INF\n\t\t\t\t\t\t|| sea[p.boat][i] == INF\n\t\t\t\t\t\t|| land[i][z[p.z+1]] == INF) continue;\n\t\t\t\tqu.add(new Pos(p.z+1, i\n\t\t\t\t\t\t, p.dist+land[z[p.z]][p.boat]+sea[p.boat][i]+land[i][z[p.z+1]]));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\treturn true;\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint z;\n\tint boat;\n\tint dist;\n\tint id;\n\tstatic int n;\n\tPos(int z, int boat, int dist){\n\t\tthis.z = z;\n\t\tthis.boat = boat;\n\t\tthis.dist = dist;\n\t\tid = z*n + boat;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn dist - o.dist;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tNode(int id){\n\t\tthis.id = id;\n\t}\n\tvoid createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\t//public static Random rand=new Random();\n\n\tstatic final int INF =1<<28;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint from,to;\n\t\tint cost;\n\t\tEdge(int _from,int _to,int _cost){\n\t\t\tfrom=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"->\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tint prev,pos;\n\t\tint cost;\n\t\tTask(int _prev,int _pos,int _cost){\n\t\t\tprev=_prev;pos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost>T.cost?1:cost<T.cost?-1:0;\n\t\t}\n\t}\n\n\tpublic int[] dijkstra(Node[] graph,int s,int[] prev){\n\t\tfinal int V=graph.length;\n\t\tint[] d=new int[V];Arrays.fill(d,INF);d[s]=0;\n\t\tArrays.fill(prev,-2);\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(-1,s,0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\tif(prev[task.pos]!=-2)continue;\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tprev[task.pos]=task.prev;\n\t\t\tfor(Edge e:graph[task.pos].link){\n\t\t\t\t//if(decV(task.prev)==decV(e.to))continue;\n\t\t\t\tif(d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\tque.add(new Task(e.from,e.to,d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic int enc(int v,int prev,int l){\n\t\treturn N*(L+1)*v+prev*(L+1)+l;\n\t}\n\tpublic int decL(int id){\n\t\treturn id%(L+1);\n\t}\n\tpublic int decV(int id){\n\t\treturn id/(L+1);\n\t}\n\tvoid warshall_floyd(int[][] d){\n\t\tfinal int V=d.length;\n\t\tint[][] prev=new int[V][V];\n\t    for(int k=0;k<V;k++)\n\t    \tfor(int i=0;i<V;i++)for(int j=0;j<V;j++)\n\t    \t\tif(d[i][j]>d[i][k] + d[k][j]){\n\t    \t\t\td[i][j]=d[i][k] + d[k][j];\n\t    \t\t\tprev[i][j]=k;\n\t    \t\t}\n\t}\n\n\tint N,M,L;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();M=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tint[][] ld=new int[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\t\tld[i][j]=INF;\n\t\t\tfor(int i=0;i<N;i++)ld[i][i]=0;\n\t\t\tint[][] sd=new int[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\t\tsd[i][j]=INF;\n\t\t\tfor(int i=0;i<N;i++)sd[i][i]=0;\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint x=sc.nextInt()-1,y=sc.nextInt()-1,t=sc.nextInt();\n\t\t\t\tchar sl=sc.next().charAt(0);\n\t\t\t\tif(sl=='L'){\n\t\t\t\t\tld[x][y]=ld[y][x]=t;\n\t\t\t\t}else{\n\t\t\t\t\tsd[x][y]=sd[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\twarshall_floyd(ld);\n\t\t\twarshall_floyd(sd);\n\n\n\t\t\tint R=sc.nextInt();\n\t\t\tint[] zs=new int[R];\n\t\t\tfor(int i=0;i<R;i++)zs[i]=sc.nextInt()-1;\n\n\t\t\tint[] dp=new int[N];//sip pos\n\t\t\tArrays.fill(dp,INF);\n\t\t\tdp[zs[0]]=0;\n\t\t\tfor(int i=1;i<R;i++){\n\t\t\t\tint[] tmp=new int[N];\n\t\t\t\tArrays.fill(tmp,INF);\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\ttmp[j]=min(tmp[j],dp[j]+ld[zs[i-1]][zs[i]]);\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\t\ttmp[j]=min(tmp[j],dp[k]+ld[zs[i-1]][k]+sd[k][j]+ld[j][zs[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp=tmp;\n\t\t\t\t//ln(str(dp));\n\t\t\t}\n\t\t\tint mv=INF;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tmv=min(mv,dp[i]);\n\n\t\t\tln(mv);\n\t\t}\n\t}\n\n\tpublic String strPath(List<Integer> path){\n\t\tString res=\"\";\n\t\tfor(Integer v:path){\n\t\t\tres+=\"(\"+decV(v)+\",\"+decL(v)+\")--\";\n\t\t}\n\t\treturn res;\n\t}\n\t//パスの出力\n\tpublic static List<Integer> path(int[] prev,int e){\n\t\tList<Integer> path=new ArrayList<Integer>();\n\t\tfor (int u = e; u >= 0; u = prev[u])\n\t\t\tpath.add(u);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int INF = 1000000000;\n\tfinal int MAX_N = 200;\n\tfinal int MAX_R = 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\treturn;\n\n\t\t\tint[][] land = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tint[][] sea  = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tfor (int i = 0; i <= MAX_N; i++) {\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= MAX_N; i++)\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tint t = scan.nextInt();\n\t\t\t\tchar sl = scan.next().charAt(0);\n\t\t\t\tif (sl == 'L')\n\t\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t\telse\n\t\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\t\t\n\t\t\tfor (int k = 1; k <= MAX_N; k++) for (int i = 1; i <= MAX_N; i++) for (int j = 1; j <= MAX_N; j++) {\n\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\tsea[i][j]  = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"land\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((land[i][j] == INF ? \"X\" : land[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t\tSystem.out.println(\"sea\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((sea[i][j] == INF ? \"X\" : sea[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint[][] dp = new int[MAX_R][MAX_N + 1];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\n\t\t\tdp[0][1] = 0;\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (land[z[i]][z[i + 1]] != INF)\n\t\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + land[z[i]][j] + sea[j][k] + land[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"dp\");\n\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((dp[i][j] == INF ? \"X\" : dp[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[][] l, s;\n\tint[][][] ls;\n\tint[] z;\n\tint r, n, m;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt(); m = sc.nextInt();\n\t\t\tif( (n|m) == 0 ) break;\n\t\t\tl = new int[n][n];\n\t\t\ts = new int[n][n];\n\t\t\tfor(int[] a: l) fill(a, INF);\n\t\t\tfor(int[] a: s) fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++) l[i][i] = s[i][i] = 0;\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint a = sc.nextInt()-1, b = sc.nextInt() - 1, d = sc.nextInt();\n\t\t\t\tif( sc.next().equals(\"S\") ) s[a][b] = s[b][a] = min(s[a][b], d);\n\t\t\t\telse l[a][b] = l[b][a] = min(l[a][b], d);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k]+s[j][k]);\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k]+l[j][k]);\n\t\t\t}\n//\t\t\tdebug(s);\n//\t\t\tdebug(l);\n\t\t\tr = sc.nextInt();\n\t\t\tz = new int[r];\n\t\t\tfor(int i=0;i<r;i++) z[i] = sc.nextInt()-1;\n\t\t\tSystem.out.println(dp());\n\t\t}\n\t}\n\t\n\tint dp() {\n\t\tint dp[][] = new int[r][n];\n\t\tfor(int[] a: dp) fill(a, INF);\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int k=0;k<r-1;k++) for(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) dp[k+1][j] = min(dp[k+1][j], dp[k][i] + l[z[k]][i] + s[i][j] + l[j][z[k+1]]);\n\t\t\tdp[k+1][i] = min(dp[k+1][i], dp[k][i] + l[z[k]][z[k+1]]);\n\t\t}\n\t\t\n\t\tint min = INF;\n\t\tfor(int i=0;i<n;i++) min = min(min, dp[r-1][i]);\n\t\treturn min;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.PriorityQueue;\n\nimport org.omg.PortableServer.POAManagerPackage.State;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tint INF = 100000000;\n\t\n\tpublic void run() {\n\t\twhile (true) {\n\t\t\tint N = in.nextInt(), M = in.nextInt();\n\t\t\tif (N == 0 && M == 0) break;\n\t\t\t\n\t\t\tint[][][] edge = new int[2][N][N];\n\n\t\t\tfor (int i = 0; i < 2; i++) for (int j = 0; j < N; j++)\n\t\t\t\tArrays.fill(edge[i][j], INF);\n\t\t\t\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tedge[0][i][i] = edge[1][i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tint x = in.nextInt() - 1, y = in.nextInt() - 1, t = in.nextInt();\n\t\t\t\tint sl = in.next().matches(\"L\") ? 0 : 1;\n\t\t\t\tedge[sl][x][y] = edge[sl][y][x] = Math.min(edge[sl][x][y], t);\n\t\t\t}\n\t\t\t\n\t\t\tint R = in.nextInt();\n\t\t\tint[] z = new int[R];\n\t\t\tfor (int i = 0; i < R; i++)\n\t\t\t\tz[i] = in.nextInt() - 1;\n\t\t\t\n\t\t\t\n\t\t\tfor (int k = 0; k < N; k++) for (int i = 0; i < N; i++) for (int j = 0; j < N; j++) {\n\t\t\t\tedge[0][i][j] = Math.min(edge[0][i][j], edge[0][i][k] + edge[0][k][j]);\n\t\t\t\tedge[1][i][j] = Math.min(edge[1][i][j], edge[1][i][k] + edge[1][k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tint[][] dp = new int[R][N];\n\t\t\tfor (int i = 0; i < R; i++) Arrays.fill(dp[i], INF);\n\t\t\t\n\t\t\tdp[0][z[0]] = 0;\n\t\t\tfor (int i = 1; i < R; i++) for (int j = 0; j < N; j++) {\n\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i-1][j] + edge[0][z[i-1]][z[i]]);\n\t\t\t\tfor (int k = 0; k < N; k++)\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i-1][k] + edge[0][z[i-1]][k] + edge[1][k][j] + edge[0][j][z[i]]);\n\t\t\t}\n\t\t\t\n\t\t\tint res = INF;\n\t\t\tfor (int i = 0; i < N; i++) \n\t\t\t\tres = Math.min(res, dp[R-1][i]);\n\t\t\t\n\t\t\tSystem.out.println(res);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint [][] land = new int[n][n];\n\t\t\tint [][] sea = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = 0;\n\t\t\t\tsea[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() -1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tString mark = sc.next();\n\t\t\t\tif(mark.equals(\"L\")){\n\t\t\t\t\tland[from][to] = dis;\n\t\t\t\t\tland[to][from] = dis;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tsea[from][to] = dis;\n\t\t\t\t\tsea[to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint [] route = new int[r];\n\t\t\tfor(int i=0; i < r; i++){\n\t\t\t\troute[i] = sc.nextInt() -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tland[i][k] = Math.min(land[i][k], land[i][j] + land[j][k]);\n\t\t\t\t\t\tsea[i][k] = Math.min(sea[i][k], sea[i][j] + sea[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][]dp = new int[n][r];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[route[0]][0] = 0;\n\t\t\tfor(int i=0; i < r-1; i++){\n\t\t\t\tint from = route[i];\n\t\t\t\tint to = route[i+1];\n\t\t\t\tfor(int untilL = 0; untilL  < n; untilL++){\n\t\t\t\t\tfor(int untilS = 0; untilS < n; untilS++){\n\t\t\t\t\t\tint currentDis;\n\t\t\t\t\t\tif(untilL == untilS){\n\t\t\t\t\t\t\tcurrentDis = land[from][to];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tcurrentDis = land[from][untilL] + sea[untilL][untilS] + land[untilS][to];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[untilS][i+1] = Math.min(dp[untilS][i+1], dp[untilL][i] + currentDis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int i = 0; i < n;i ++){\n//\t\t\t\tfor(int j = 0; j < r; j++ ){\n//\t\t\t\t\tif(dp[i][j] == INF){\n//\t\t\t\t\t\tSystem.out.print(\"INF \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n//\t\t\t\t\t}\n//\t\t\t\t\t\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tans = Math.min(ans, dp[i][r-1]);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N, M, R;\n\tstatic int[] Z = new int[1000];\n\tstatic int[][] WL = new int[201][201], WS = new int[201][201];\n\tstatic final int INF = 1 << 29;\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tif (N == 0 && M == 0) return false;\n\t\t\n\t\tfor (int i = 0; i < 201; i++) {\n\t\t\tfill(WL[i], INF); \n\t\t\tfill(WS[i], INF);\n\t\t\tWL[i][i] = WS[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tt = sc.nextInt();\n\t\t\tsl = sc.next().charAt(0);\n\t\t\tif (sl == 'S') {\n\t\t\t\tWS[x][y] = WS[y][x] = t;\n\t\t\t} else {\n\t\t\t\tWL[x][y] = WL[y][x] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tR = sc.nextInt();\n\t\tfor (int i = 0; i < R; i++) Z[i] = sc.nextInt();\n\t\treturn true;\n\t}\n\n\tstatic int[][] dist = new int[1000][201];\n\tstatic void solve() {\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.offer(new State(0, Z[0], 0));\n\t\tint ans = INF;\n\t\tfor (int k = 1; k < 201; k++) {\n\t\t\tfor (int i = 1; i < 201; i++) { \n\t\t\t\tfor (int j = 1; j < 201; j++) {\n\t\t\t\t\tWL[i][j] = min(WL[i][j], WL[i][k] + WL[k][j]);\n\t\t\t\t\tWS[i][j] = min(WS[i][j], WS[i][k] + WS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\n\t\t\n\t\tfor (int i = 0; i < 1000; i++) fill(dist[i], -1);\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\t\t\tif (dist[s.cur][s.ship] != -1) continue;\n\t\t\t\n\t\t\tdist[s.cur][s.ship] = s.cost;\n\t\t\t\n\t\t\tif (s.cur == R - 1) {\n\t\t\t\tans = s.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint cur = s.cur, from = Z[s.cur], to = Z[s.cur + 1], cost = s.cost, ship = s.ship;\n\t\t\t// ツ猟、ツ路ツづーツ使ツつ、\n\t\t\t\n\t\t\tint ncost = cost + WL[from][to], nship = ship;\n\t\t\tif (dist[s.cur + 1][nship] == -1 && ncost < INF) \n\t\t\t\tque.offer(new State(s.cur + 1, ship, cost + WL[from][to]));\n\t\t\t\n\t\t\t// ツ海ツ路ツづーツ使ツつ、\n\t\t\tfor (int k = 1; k < 201; k++) {\n\t\t\t\tncost = cost + WL[from][ship] + WS[ship][k] + WL[k][to];\n\t\t\t\tnship = k;\n\t\t\t\tif (dist[s.cur + 1][nship] == -1 && ncost < INF)\n\t\t\t\t\tque.offer(new State(s.cur + 1, nship, ncost));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\t\n}\n\nclass State implements Comparable<State> {\n\tint cur, ship, cost;\n\tState (int cur, int ship, int cost) {\n\t\tthis.cur = cur;\n\t\tthis.ship = ship;\n\t\tthis.cost = cost;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.cost - s.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();//the number of cities\n\t\t\tint m=sc.nextInt();//the number of paths\n\t\t\tif(n==0&&m==0)break;\n\t\t\tint INF=Integer.MAX_VALUE/4;\n\t\t\tint[][] ldis=new int[n][n];\n\t\t\tint[][] sdis=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tldis[i][j]=INF;\n\t\t\t\t\tsdis[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"L\")){\n\t\t\t\t\tldis[x][y]=t;\n\t\t\t\t\tldis[y][x]=t;\n\t\t\t\t}else if(str.equals(\"S\")){\n\t\t\t\t\tsdis[x][y]=t;\n\t\t\t\t\tsdis[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tldis[i][j]=Math.min(ldis[i][j],ldis[i][k]+ldis[k][j]);\n\t\t\t\t\t\tsdis[i][j]=Math.min(sdis[i][j],sdis[i][k]+sdis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=sc.nextInt();\n\t\t\tint[] destination=new int[r];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tdestination[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tint[][] dp=new int[r][n];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][destination[0]]=0;//dp[i][j]???i???????????§?¨?????????????j????????????????????´???????????????\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==j){\n\t\t\t\t\t\t\tdp[i][j]=\n\t\t\t\t\t\t\t\t\tMath.min(dp[i][j],\n\t\t\t\t\t\t\t\t\t\t\tldis[destination[i]][destination[i-1]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+dp[i-1][j]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][j]+sdis[j][k]+ldis[k][destination[i-1]]+dp[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min=9999999;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmin=Math.min(dp[r-1][i],min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tList<Integer>[] le, se;\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint shp;\n\t\tint idx;\n\t\tint min;\n\n\t\tpublic D(int pos, int shp, int idx, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.shp = shp;\n\t\t\tthis.idx = idx;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.pos != o.pos) {\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}\n\t\t\tif (this.shp != o.shp) {\n\t\t\t\treturn this.shp - o.shp;\n\t\t\t}\n\t\t\tif (this.idx != o.idx) {\n\t\t\t\treturn this.idx - o.idx;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + pos + \", \" + shp + \", \" + idx + \", \" + min + \")\";\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tboolean[][][] vis = new boolean[n][n][r];\n\n\t\tint id = 0;\n\t\twhile (perm[0] == perm[id]) {\n\t\t\tid++;\n\t\t}\n\t\tqueue.add(new D(perm[0], perm[0], id, 0));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint shp = d.shp;\n\t\t\tint idx = d.idx;\n\t\t\tint min = d.min;\n\n\t\t\tif (idx == r) {\n\t\t\t\treturn min;\n\t\t\t}\n\t\t\tif (vis[pos][shp][idx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos][shp][idx] = true;\n\n\t\t\tfor (Integer to : le[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nshp = shp;\n\t\t\t\tint nidx = idx;\n\t\t\t\tint nmin = min + ld[pos][npos];\n\t\t\t\twhile (nidx < r && perm[nidx] == npos) {\n\t\t\t\t\tnidx++;\n\t\t\t\t}\n\t\t\t\tqueue.add(new D(npos, nshp, nidx, nmin));\n\t\t\t}\n\t\t\tfor (Integer to : se[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nshp = shp;\n\t\t\t\tint nidx = idx;\n\t\t\t\tint nmin = min + sd[pos][npos];\n\t\t\t\tif (shp != pos) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (nidx < r && perm[nidx] == npos) {\n\t\t\t\t\tnidx++;\n\t\t\t\t}\n\t\t\t\tnshp = npos;\n\t\t\t\tqueue.add(new D(npos, nshp, nidx, nmin));\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tle = new LinkedList[n];\n\t\t\tse = new LinkedList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tle[i] = new LinkedList<Integer>();\n\t\t\t\tse[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tle[x].add(y);\n\t\t\t\t\tle[y].add(x);\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tse[x].add(y);\n\t\t\t\t\tse[y].add(x);\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE / 3;\n\tfinal int MAX_N = 200 + 1;\n\tfinal int MAX_M = 100000 + 1;\n\tfinal int MAX_R = 1000 + 1;\n\n\tvoid test() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] land = new int[MAX_N][MAX_N];\n\t\t\tint[][] sea = new int[MAX_N][MAX_N];\n\n\t\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint from = scan.nextInt();\n\t\t\t\tint to = scan.nextInt();\n\t\t\t\tint dist = scan.nextInt();\n\t\t\t\tchar ls = scan.next().charAt(0);\n\t\t\t\tif (ls == 'L')\n\t\t\t\t\tland[from][to] = land[to][from] = dist;\n\t\t\t\telse\n\t\t\t\t\tsea[from][to] = sea[to][from] = dist;\n\t\t\t}\n\t\t\t\n\t\t\t// WashallFroyd\n\t\t\tfor (int k = 1; k <= n; k++) for(int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n//\t\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((land[i][j] != INF ? land[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((sea[i][j] != INF ? sea[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t// dp\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\t\t\t\n\t\t\tint[][] dp = new int[MAX_R][MAX_N];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\t\t\t\n\t\t\tdp[0][z[0]] = 0;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (dp[i][j] == INF) continue;\n\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + land[z[i]][j] + sea[j][k] + land[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tfor (int i = 0; i < r; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((dp[i][j] != INF ? dp[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] l = new int[MAX_N][MAX_N];\n\t\t\tint[][] s = new int[MAX_N][MAX_N];\n\n\t\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t\t\tl[i][j] = s[i][j] = INF;\n\t\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t\t\tl[i][i] = s[i][i] = 0;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint to = scan.nextInt();\n\t\t\t\tint from = scan.nextInt();\n\t\t\t\tint dist = scan.nextInt();\n\t\t\t\tchar sl = scan.next().charAt(0);\n//\t\t\t\tSystem.out.println(to + \" \" + from + \" \" + dist + \" \" + (sl == 'S'));\n\t\t\t\tif (sl == 'S')\n\t\t\t\t\ts[to][from] = s[from][to] = dist;\n\t\t\t\telse\n\t\t\t\t\tl[to][from] = l[from][to] = dist;\n\t\t\t}\n\n\t\t\t// WarshallFloyd\n\t\t\tfor (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\t\t\tl[i][j] = Math.min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t\ts[i][j] = Math.min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n//\t\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((s[i][j] != INF ? s[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((l[i][j] != INF ? l[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\n\t\t\t// dp\n\t\t\tint[][] dp = new int[MAX_R][MAX_N];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\n\t\t\tdp[0][z[0]] = 0;\n\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (dp[i][j] == INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + l[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n\t\t\t\t}\n//\t\t\t\tfor (int j = 0; j < r; j++) {\n//\t\t\t\t\tfor (int k = 1; k <= n; k++)\n//\t\t\t\t\t\tSystem.out.print((dp[j][k] != INF ? dp[j][k] : \"x\") + \" \");\n//\t\t\t\t\tSystem.out.println();\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n//\t\tnew Main().run();\n\t\tnew Main().test();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();//the number of cities\n\t\t\tint m=sc.nextInt();//the number of paths\n\t\t\tif(n==0&&m==0)break;\n\t\t\tint INF=Integer.MAX_VALUE/4;\n\t\t\tint[][] ldis=new int[n][n];\n\t\t\tint[][] sdis=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tldis[i][j]=INF;\n\t\t\t\t\tsdis[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"L\")){\n\t\t\t\t\tldis[x][y]=t;\n\t\t\t\t\tldis[y][x]=t;\n\t\t\t\t}else if(str.equals(\"S\")){\n\t\t\t\t\tsdis[x][y]=t;\n\t\t\t\t\tsdis[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\t\tldis[i][j]=Math.min(ldis[i][j],ldis[i][k]+ldis[k][j]);\n\t\t\t\t\t\tsdis[i][j]=Math.min(sdis[i][j],sdis[i][k]+sdis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=sc.nextInt();\n\t\t\tint[] destination=new int[r];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tdestination[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tint[][] dp=new int[r][n];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][destination[0]]=0;//dp[i][j]???i???????????§?¨?????????????j????????????????????´???????????????\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==j){\n\t\t\t\t\t\t\tdp[i][j]=\n\t\t\t\t\t\t\t\t\tMath.min(dp[i][j],\n\t\t\t\t\t\t\t\t\t\t\tldis[destination[i]][destination[i-1]]\n\t\t\t\t\t\t\t\t\t\t\t\t\t+dp[i-1][j]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][j]+sdis[j][k]+ldis[k][destination[i-1]]+dp[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min=9999999;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmin=Math.min(dp[r-1][i],min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\t//int INF = 1 << 28;\n\tlong INF = 1L << 60;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\t//input\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\t\t\t\n\t\t\tlong[][] s = new long[n][n], l = new long[n][n];\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tfill(s[i], INF);\n\t\t\t\tfill(l[i], INF);\n\t\t\t\ts[i][i] = l[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n\t\t\t\tchar sl = sc.next().charAt(0);\n\t\t\t\tif (sl == 'S')\ts[x][y] = s[y][x] = min(s[x][y], t);\n\t\t\t\telse \t\t\tl[x][y] = l[y][x] = min(l[x][y], t);\n\t\t\t}\n\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] ps = new int[r];\n\t\t\tfor (int i=0;i<r;i++) ps[i] = sc.nextInt()-1;\n\t\t\t\n\t\t\t// WF\n\t\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t}\n\n\t\t\tlong[][] dp = new long[r][n];\n\t\t\tfor (long[] a : dp) fill(a, INF); dp[0][ps[0]] = 0;\n\t\t\t\n\t\t\tfor (int i=1;i<r;i++) for (int j=0;j<n;j++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + l[ps[i-1]][ps[i]]);\n\t\t\t\tfor (int k=0;k<n;k++) \n\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + l[ps[i-1]][k] + s[k][j] + l[j][ps[i]]);\n\t\t\t}\n\n\t\t\tlong ans = INF;\n\t\t\tfor (int i=0;i<n;i++) ans = min(ans, dp[r-1][i]);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static IO io = new IO();\n    private static int dl[][] = new int[201][201];  // ???i,j??????????????????????????¢\n    private static int ds[][] = new int[201][201];  // ???i,j??????????????????????????¢\n    private static int dp[][] = new int[1001][201];  // i????????????????????????????????????j???????????´??????????°??????????\n    private static int rs[] = new int[1001]; // i??????????????????\n    private static int INF = 114514;\n    public static void main(String[] args) {\n        while (true) {\n\n            int n = io.nextInt();\n            int m = io.nextInt();\n            if (n==0 && m==0) break;\n\n            // ?????????\n            for (int i=1; i<=n; i++) {\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n                Arrays.fill(dp[i], INF);\n                dl[i][i] = ds[i][i] = 0;\n            }\n\n            // ??\\???\n            for (int i = 0; i < m; i++) {\n                int x = io.nextInt();\n                int y = io.nextInt();\n                int t = io.nextInt();\n                char s = io.nextChar();\n                if (s=='L') {\n                    dl[x][y] = dl[y][x] = Math.min(dl[x][y], t);\n                } else {\n                    ds[x][y] = ds[y][x] = Math.min(ds[x][y], t);\n                }\n            }\n            int r = io.nextInt();\n            for (int i = 1; i <= r; i++) rs[i] = io.nextInt();\n            dp[1][rs[1]] = 0;\n\n            // ???????????£????????????????????§??????????????????/????????????????????¢????????????????±???????\n            for (int k = 1; k <= n; k++) {\n                for (int i = 1; i <= n; i++) {\n                    for (int j = 1; j <= n; j++) {\n                        dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                        ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                    }\n                }\n            }\n\n            // dp?????§??????????¨????\n            for (int i = 1; i < r; i++) {\n                int pos = rs[i+1];\n                int pre = rs[i];\n                for (int j = 1; j <= n; j++) {\n                    for (int k = 1; k <= n; k++) {\n                        if (j==k) dp[i+1][j] = Math.min(dp[i+1][j], dp[i][j] + dl[pre][pos]);\n                        else dp[i+1][j] = Math.min(dp[i+1][j], dp[i][k] + dl[pre][k] + ds[k][j] + dl[j][pos]);\n                    }\n                }\n            }\n\n            int ans = INF;\n            for (int i = 1; i <= n; i++) ans = Math.min(ans, dp[r][i]);\n            System.out.println(ans);\n\n        }\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean isNewLine(int c) {\n            return c == '\\n' || c == '\\r';\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        void skipNewLine() {\n            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        boolean hasNextLine() {\n            skipNewLine();\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        char[] nextCharArray(int len) {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                if (i == len) {\n                    throw new InputMismatchException();\n                }\n                s[i++] = (char) b;\n                b = readByte();\n            }\n            return s;\n        }\n\n        String nextLine() {\n            if (!hasNextLine()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isNewLine(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] arrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] arrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        double[] arrayDouble(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        void arrayInt(int[]... a) {\n            for (int i = 0; i < a[0].length; i++) for (int j = 0; j < a.length; j++) a[j][i] = nextInt();\n        }\n\n        int[][] matrixInt(int n, int m) {\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) a[i] = arrayInt(m);\n            return a;\n        }\n\n        char[][] charMap(int n, int m) {\n            char[][] a = new char[n][];\n            for (int i = 0; i < n; i++) a[i] = nextCharArray(m);\n            return a;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Mr. Rito Post Office\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<28;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tint[][] wf1 = new int[n][n], wf2 = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\twf1[i][j] = wf2[i][j] = INF;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)wf1[i][i] = wf2[i][i] = 0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, cost = sc.nextInt();\n\t\t\t\tString str = sc.next();\n\t\t\t\tif(\"L\".equals(str))wf1[s][t] = wf1[t][s] = Math.min(wf1[s][t], cost);\n\t\t\t\telse wf2[s][t] = wf2[t][s] = Math.min(wf2[s][t], cost);\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\twf1[i][j] = Math.min(wf1[i][j], wf1[i][k]+wf1[k][j]);\n\t\t\t\twf2[i][j] = Math.min(wf2[i][j], wf2[i][k]+wf2[k][j]);\n\t\t\t}\n\t\t\tint R = sc.nextInt();\n\t\t\tint[][] dp = new int[2][n];\n\t\t\tArrays.fill(dp[0], INF);\n\t\t\tint X = 1;\n\t\t\tint pre = sc.nextInt()-1;\n\t\t\tdp[0][pre] = 0;\n\t\t\tfor(;--R!=0;X=1-X){\n\t\t\t\tint k = sc.nextInt()-1;\n\t\t\t\tArrays.fill(dp[X], INF);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\t\tif(i!=j)\n\t\t\t\t\t\tdp[X][i] = Math.min(dp[X][i], dp[1-X][j]+wf1[pre][j]+wf2[j][i]+wf1[i][k]);\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[X][i] = Math.min(dp[X][i], dp[1-X][j]+wf1[pre][k]);\n\t\t\t\t}\n\t\t\t\tpre = k;\n\t\t\t}\n\t\t\tint res = INF;\n\t\t\tfor(int i=0;i<n;i++)res = Math.min(res, dp[1-X][i]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Lin\n * @version 1.0\n * @date 2020/8/3 15:56\n */\npublic class Main\n{\n\tstatic long INF = 123245452356732L;\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tString next = Reader.nextLine();\n\t\tStringBuffer stringBuffer = new StringBuffer();\n\t\twhile (!\"0 0\".equals(next))\n\t\t{\n\t\t\tint n = Integer.parseInt(next.split(\" \")[0]);\n\t\t\tint m = Integer.parseInt(next.split(\" \")[1]);\n\t\t\tlong ans = INF;\n\t\t\tlong[][] dis_1 = new long[n][n];\n\t\t\tlong[][] dis_2 = new long[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tArrays.fill(dis_1[i], INF);\n\t\t\t\tArrays.fill(dis_2[i], INF);\n\t\t\t\tdis_1[i][i] = 0;\n\t\t\t\tdis_2[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++)\n\t\t\t{\n\t\t\t\tString[] line = Reader.nextLine().split(\" \");\n\t\t\t\tint u = Integer.parseInt(line[0]) - 1;\n\t\t\t\tint v = Integer.parseInt(line[1]) - 1;\n\t\t\t\tint cost = Integer.parseInt(line[2]);\n\t\t\t\tif (\"L\".equals(line[3]))\n\t\t\t\t{\n\t\t\t\t\tdis_1[u][v] = cost;\n\t\t\t\t\tdis_1[v][u] = cost;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tdis_2[u][v] = cost;\n\t\t\t\t\tdis_2[v][u] = cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfloyd(dis_1, n);\n\t\t\tfloyd(dis_2, n);\n\t\t\tint len = Reader.nextInt();\n\t\t\tint[] linked = new int[len];\n\t\t\tfor (int i = 0; i < len; i++)\n\t\t\t{\n\t\t\t\tlinked[i] = Reader.nextInt() - 1;\n\t\t\t}\n\t\t\tlong[][] dp = new long[len][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tdp[0][i] = dis_2[linked[0]][i];\n\t\t\t}\n\t\t\tfor (int i = 1; i < len; i++)\n\t\t\t{\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tdp[i][j] = (dp[i - 1][j] + dis_1[linked[i - 1]][linked[i]]);\n\n\t\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], (dp[i - 1][k] + dis_1[linked[i-1]][k]+dis_2[k][j] + dis_1[j][linked[i]]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tans = Math.min(ans, dp[len - 1][i]);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tnext = Reader.nextLine();\n\t\t}\n\t\n\t}\n\n\tprivate static void floyd(long[][] dis, int n)\n\t{\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\t{\n\t\t\t\t\tdis[j][k] = Math.min(dis[j][i] + dis[i][k], dis[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Reader\n\t{\n\t\tstatic BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tstatic StringTokenizer tokenizer = new StringTokenizer(\"\");\n\n\t\tstatic String nextLine() throws IOException\n\t\t{// 读取下一行字符串\n\t\t\treturn reader.readLine();\n\t\t}\n\n\t\tstatic String next() throws IOException\n\t\t{// 读取下一个字符串\n\t\t\twhile (!tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tstatic int nextInt() throws IOException\n\t\t{// 读取下一个int型数值\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tstatic long nextLong() throws IOException\n\t\t{// 读取下一个int型数值\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tstatic double nextDouble() throws IOException\n\t\t{// 读取下一个double型数值\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    ArrayList[] cost;\n    int n, m, r;\n    int[] z;\n    int INF = 1000000000;\n    int[][][] rikumi;\n    int[][] rikuOnly;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            cost = new ArrayList[n];\n            for(int i=0; i<n; i++) cost[i] = new ArrayList<Integer>();\n\n            rikumi = new int[n][n][2];//cost, riku or umi\n            rikuOnly = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(rikuOnly[i], INF);\n            for(int i=0; i<n; i++) rikuOnly[i][i] = 0;\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, tt = sc.nextInt();\n                String s = sc.next();\n                int ss = 0;\n\n                if(s.equals(\"S\")) ss = 1;\n                cost[x].add(new Integer(y));\n                cost[y].add(new Integer(x));\n                rikumi[x][y][0] = tt;\n                rikumi[x][y][1] = ss;\n                rikumi[y][x][0] = tt;\n                rikumi[y][x][1] = ss;\n                if(ss==0){\n                    rikuOnly[x][y] = tt;\n                    rikuOnly[y][x] = tt; \n                }\n            }\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++) rikuOnly[i][j] = Math.min(rikuOnly[i][j], rikuOnly[i][k] + rikuOnly[k][j]);\n                }\n            }\n\n            r = sc.nextInt();\n            z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int ans = dijkstra();\n            System.out.println(ans);\n        }\n    }\n\n    int dijkstra(){\n        //pos, time, next, fune\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[1] - b[1];\n                }\n            });\n        if(z[0]==0) q.add(new int[]{0,0,1,0,0});\n        else q.add(new int[]{0,0,0,0,0});\n\n\n        int[][][] v = new int[n][r][n];\n        for(int i=0; i<n; i++){\n            for(int j=0; j<r; j++){\n                for(int k=0; k<n; k++){\n                    v[i][j][k] = INF;\n                }\n            }\n        }\n         \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], time = qq[1], next = qq[2], fune = qq[3];\n\n            if(next==r){\n                return time;\n            }\n            if(v[pos][next][fune]<=time) continue;\n            v[pos][next][fune] = time;\n\n            for(int i=0; i<cost[pos].size(); i++){\n                int t1 = (Integer)(cost[pos].get(i));\n                int t2 = rikumi[pos][t1][0];\n                int t3 = rikumi[pos][t1][1];\n                if(t3==1){//umi\n                    if(rikuOnly[fune][pos]==INF) continue;\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next+1, t1});\n                    else q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next, t1});\n                }else{//riku\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2, next+1, fune});\n                    else q.add(new int[]{t1, time+t2, next, fune});\n                }\n                \n            }\n        }\n        return INF;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint[][] sea;\n\tint[][] land;\n\tstatic final int INF = 1<<28;\n\tint N, R;\n\tint[] tar;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tint M = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tsea = new int[N][N];\n\t\t\tland = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = land[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tint x = in.nextInt()-1,\n\t\t\t\t\ty = in.nextInt()-1,\n\t\t\t\t\tt = in.nextInt();\n\t\t\t\tString wh = in.next();\n\t\t\t\tif(wh.equals(\"S\")){\n\t\t\t\t\tsea[x][y] = min(sea[x][y], t);\n\t\t\t\t\tsea[y][x] = sea[x][y];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tland[x][y] = min(land[x][y], t);\n\t\t\t\t\tland[y][x] = land[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tR = in.nextInt();\n\t\t\ttar = new int[R];\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\ttar[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tfor(int i=0; i<N; i++){\n\t\t\tsea[i][i] = land[i][i] = 0;\n\t\t}\n\t\tfor(int k=0; k<N; k++){\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[R][N];\n\t\tfor(int i=0; i<R; i++){\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<N; i++){\n\t\t\tdp[0][i] = min(dp[0][i], sea[0][i] + land[i][tar[0]]);\n\t\t}\n\t\tfor(int k=0; k<R-1; k++){\n\t\t\tfor(int i=0; i<N; i++)if(dp[k][i] != INF){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tdp[k+1][j] = min(dp[k+1][j], dp[k][i] +land[tar[k]][i] + sea[i][j] + land[j][tar[k+1]]);\n\t\t\t\t}\n\t\t\t\tdp[k+1][i] = min(dp[k+1][i], dp[k][i] + land[tar[k]][tar[k+1]]);\n\t\t\t}\n\t\t}\n\t\tint ret = INF;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tret = min(ret, dp[R-1][i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1 << 28;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint land[][] = new int[n + 1][n + 1];\n\t\t\tint sea[][] = new int[n + 1][n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif (sl.equals(\"L\")) {\n\t\t\t\t\tland[x][y] = land[y][x] = Math.min(t, land[x][y]);\n\t\t\t\t} else {\n\t\t\t\t\tsea[x][y] = sea[y][x] = Math.min(t, sea[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]\n\t\t\t\t\t\t\t\t+ land[k][j]);\n\t\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] zs = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tzs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dp = new int[r][n + 1]; // dp[i][j]\n\t\t\t\t\t\t\t\t\t\t\t// i番目までの配達を終え、船がjにあるときの最短時間。\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][zs[0]] = 0;\n\t\t\tfor (int i = 1; i < r; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k]\n\t\t\t\t\t\t\t\t+ land[zs[i - 1]][k] + sea[k][j]\n\t\t\t\t\t\t\t\t+ land[j][zs[i]]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][j]\n\t\t\t\t\t\t\t+ land[zs[i - 1]][zs[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tans = Math.min(dp[r - 1][i], ans);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "//package com.daimens.algorithm.june;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * \n * @author DemonSong\n * \n *         2220.Mr.Rito Post Office\n * \n *         Problem D: Mr. Rito Post Office\n *         ??????????????¢??¶??????????±?????????????????????°????????§?????????????????????????????§????????°??????????????°?????¶???????????????????????¶??????????????\\???????????????????????????????????????????????????????????????????????????????????????????????¶????????\\?????¶???????????????????????????????????????????????°??????????????????????????¶???????????????????????????????????????????????????????????¨???????????????????????¨????????????\n * \n *         ?????´???????????????????±?????°???¶???????????£??????????????????????????????????????????????????????????????´????????¨??????????????????????????¢??¶??????????±??????????????????§????????????????????¨??????????????????????????????????????????????????¨?????£???????????£???????????????????±???????????????????????????°??????????????????????????????????????§????????????????????§??????????\\???§?????????????????§??????????????????????????°????????????????????????????????????????????????????????????????????????????±????????????????\n * \n *         ??????????????????????????????????????????????????????????????????????????????????????????????????¨???????????????????????????????±???????????????°????????????????????¨??§?????????\n * \n *         ???????????????????±??????????????????????????????\\?????§???????\\??????????????????¨?????§???????????????????????????????????????????????\\????????????????§??????????????????????????????????????????±???????§???????????????¨????¨±???????????????????????????????????????????????¶?????????????????????????????????????????£????????????\n * \n *         ????????°??????A??????B??????C??¨??????????????????????????????????????´?????????A?????????B?????????????????????????????????????????±???????????????????????????????????¨?????????C????????±??????????§?????????????????????????????????????????????????????????????B????????£???????????????????????£????????????????????????C????¨???????????????????????????????????????°???????????????????????????A?????????????????¨?????????B??????????????????B?????????????????¨?????????C???????????£?????´???????????????B?????????????????????????????????????????£???????¬???????????????????????????´?????????B???????????????????????????\n * \n *         ???????????????????????????????????°??????????????????????????°??????????????´????????????????????¨?????°??????A??????B??????C??????B??¨?????????????????????????????????????????????????????????????????¨?????????A?????????B?????????????????????C???????????£?????´????????????C??§??????????????????????????????????????¨?????§????????????????????????B??§????????????????????£????????????????????§????????????C??§??????????????????????????§???B????¨????????????????????????????????????????B????????????????????????????????¨?????????????????????\n * \n *         ????????????????????????????????????????????????????????¨??¨????????????????????????????????????????????§????????????????§????????????\\????????????????\\??????????????????????????????????????????????????????????????????????????????§??????????\\????????????????????????§??????????????????????????§????????????????????¨????????????????????????????±??????°????????§???????????????????????????????????????\n * \n *         Input ??\\???????????°????????????????????????????§??????????????????????????????????????????¢???????¬????????????¨????????§?????????\n * \n *         N M x1 y1 t1 sl1 x2 y2 t2 sl2 ... xM yM tM slM R z1 z2 ... zR\n *         ?????????????????????????????\\???????????????????????????????????´??°??§????????????????????\\?????????????????????????????? 1 ?????§?????????\n * \n *         ?????????????????????????????????????¶??????§????????????????????????\n * \n *         N (2 ??? N ??? 200) ??????????????????????????°??§????????? ???????????????????????????????????????1 ?????? N ?????§??????????????????????????????????????? M\n *         (1 ??? M ??? 10000) ??????????????¨?????????????¨???¬??°??§?????????\n * \n *         2 ???????????? 1 + M ?????????????????????????????????????¨???°??§????????? xi ??¨ yi (1 ??? xi, yi ??? N)\n *         ?????????????????????????????????????????¨?????? ti (1 ??? ti ??? 1000) ??????????????????????????????????§???????????????¨?????? sli ??? ???L??? ?????????\n *         ???S??? ?????????????????§?????????L???????????????S??????????????????????????¨??????\n * \n *         ??????2????????????????????´??\\?????¶????????????????????????2??¬??\\????????¨???????????¨????????????\n *         ??????????????????????????????????????????????????§??????????????????????????????????????????????§??????§?????????\n * \n *         M + 2 ????????? R (1 ??? R ??? 1000)???????????????????????????????????????????????°?????¨?????? M + 3 ?????????????????????????????????????????????\n *         zi (1 ??? zi ??? N) ??????????????? R ???????????§?????????\n * \n *         ????????¶?????§?????????????????¨????????¨???????????? z1 ????????¨????????? ????????¶?????????????????????????????????????????????????????????????????§?§???????????????¨?????§?????????\n * \n *         ??\\?????????????????????????????§???????????????2??????0?????????1?????§???????????????\n * \n *         Output ??\\???????????????????????????????????????????????????????????????????????§????????????????????¨???????????????????????????????????????????§??????????????±???????1?????????????????????\n * \n *         Sample Input 3 3 1 2 5 L 1 2 7 S 2 3 11 S 3 1 2 3 5 5 1 2 15 L 2 3 10\n *         L 4 5 7 L 1 3 30 S 3 4 100 S 5 1 3 5 4 1 0 0 Output for the Sample\n *         Input 18 269\n *\n */\npublic class Main{\n\t\n\tstatic int[][] water;\n\tstatic int[][] land;\n\tstatic int N;\n\tstatic int INF = 1 << 28;\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(System.in);\n\t\twhile (true){\n\t\t\tN = in.nextInt();\n\t\t\tint M = in.nextInt();\n\t\t\tif (N == 0 && M == 0) break;\n\t\t\t\n\t\t\twater = new int[N][N];\n\t\t\tland = new int[N][N];\n\t\t\t\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tArrays.fill(water[i], INF);\n\t\t\t\tArrays.fill(land[i],INF);\n\t\t\t\twater[i][i] = 0;\n\t\t\t\tland[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < M; ++i){\n\t\t\t\tint from = in.nextInt();\n\t\t\t\tint to = in.nextInt();\n\t\t\t\tfrom--;\n\t\t\t\tto--;\n\t\t\t\t\n\t\t\t\tint cost = in.nextInt();\n\t\t\t\tString mark = in.next();\n\t\t\t\tif (mark.equals(\"S\")){\n\t\t\t\t\twater[from][to] = water[to][from] = cost;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tland[from][to] = land[to][from] = cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint C = in.nextInt();\n\t\t\tint[] city = new int[C];\n\t\t\tfor (int i = 0; i < C; ++i){\n\t\t\t\tcity[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\twarshallFloyd();\n\t\t\t\n\t\t\tint[][] dp = new int[C][N];\n\t\t\tfor (int i = 0; i < C; ++i) Arrays.fill(dp[i], INF);\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tdp[0][i] = land[city[0]][i] + water[i][city[0]];\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i < C; ++i){\n\t\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\t\t\tif (j != k){\n\t\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i-1][j] + land[city[i-1]][j] + water[j][k] + land[k][city[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i-1][j] + land[city[i-1]][city[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint min = INF;\n\t\t\tfor (int i = 0; i < N; ++i){\n\t\t\t\tmin = Math.min(min, dp[C-1][i]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\t\n\tprivate static void warshallFloyd(){ \n\t\tfor (int i = 0; i < N; ++i){\n\t\t\tfor (int j = 0; j < N; ++j){\n\t\t\t\tfor (int k = 0; k < N; ++k){\n\t\t\t\t\twater[j][k] = Math.min(water[j][k], water[j][i] + water[i][k]);\n\t\t\t\t\tland[j][k] = Math.min(land[j][k], land[j][i] + land[i][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Scanner {\n\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) throws IOException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t\tgetLine();\n\t\t}\n\n\t\tprivate void getLine() throws IOException {\n\t\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn tok.nextToken();\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn tok.nextToken();\n\t\t\t}\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Integer.parseInt(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Long.parseLong(tok.nextToken());\n\t\t\t}\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\tif (hasNext()) {\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t} else {\n\t\t\t\tgetLine();\n\t\t\t\treturn Double.parseDouble(tok.nextToken());\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tList<Integer>[] le, se;\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint shp;\n\t\tint idx;\n\t\tint min;\n\n\t\tpublic D(int pos, int shp, int idx, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.shp = shp;\n\t\t\tthis.idx = idx;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.pos != o.pos) {\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}\n\t\t\tif (this.shp != o.shp) {\n\t\t\t\treturn this.shp - o.shp;\n\t\t\t}\n\t\t\tif (this.idx != o.idx) {\n\t\t\t\treturn this.idx - o.idx;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + pos + \", \" + shp + \", \" + idx + \", \" + min + \")\";\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tboolean[][][] vis = new boolean[n][n][r];\n\n\t\tint id = 0;\n\t\twhile (perm[0] == perm[id]) {\n\t\t\tid++;\n\t\t}\n\t\tqueue.add(new D(perm[0], perm[0], id, 0));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint shp = d.shp;\n\t\t\tint idx = d.idx;\n\t\t\tint min = d.min;\n\n\t\t\tif (idx == r) {\n\t\t\t\treturn min;\n\t\t\t}\n\t\t\tif (vis[pos][shp][idx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos][shp][idx] = true;\n\n\t\t\tfor (Integer to : le[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nshp = shp;\n\t\t\t\tint nidx = idx;\n\t\t\t\tint nmin = min + ld[pos][npos];\n\t\t\t\twhile (nidx < r && perm[nidx] == npos) {\n\t\t\t\t\tnidx++;\n\t\t\t\t}\n\t\t\t\tif (!vis[npos][nshp][nidx]) {\n\t\t\t\t\tqueue.add(new D(npos, nshp, nidx, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Integer to : se[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nshp = shp;\n\t\t\t\tint nidx = idx;\n\t\t\t\tint nmin = min + sd[pos][npos];\n\t\t\t\tif (shp != pos) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (nidx < r && perm[nidx] == npos) {\n\t\t\t\t\tnidx++;\n\t\t\t\t}\n\t\t\t\tnshp = npos;\n\t\t\t\tif (!vis[npos][nshp][nidx]) {\n\t\t\t\t\tqueue.add(new D(npos, nshp, nidx, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tle = new LinkedList[n];\n\t\t\tse = new LinkedList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tle[i] = new LinkedList<Integer>();\n\t\t\t\tse[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tle[x].add(y);\n\t\t\t\t\tle[y].add(x);\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tse[x].add(y);\n\t\t\t\t\tse[y].add(x);\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor (;;) {\n\t\t\t//input\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif ((n|m) == 0) break;\n\t\t\t\n\t\t\tint[][] s = new int[n][n], l = new int[n][n];\n\t\t\tfor (int i=0;i<n;i++) {\n\t\t\t\tfill(s[i], INF);\n\t\t\t\tfill(l[i], INF);\n\t\t\t\ts[i][i] = l[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n\t\t\t\tchar sl = sc.next().charAt(0);\n\t\t\t\tif (sl == 'S')\ts[x][y] = s[y][x] = min(s[x][y], t);\n\t\t\t\telse \t\t\tl[x][y] = l[y][x] = min(l[x][y], t);\n\t\t\t}\n\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] ps = new int[r];\n\t\t\tfor (int i=0;i<r;i++) ps[i] = sc.nextInt()-1;\n\t\t\t\n\t\t\t// WF\n\t\t\tfor (int k=0;k<n;k++) for (int i=0;i<n;i++) for (int j=0;j<n;j++) {\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t}\n\n\t\t\tint[][] dp = new int[r][n];\n\t\t\tfor (int[] a : dp) fill(a, INF); dp[0][ps[0]] = 0;\n\t\t\t\n\t\t\tfor (int i=1;i<r;i++) for (int j=0;j<n;j++) for (int k=0;k<n;k++) {\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + l[ps[i-1]][k] + s[k][j] + l[j][ps[i]]);\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i=0;i<n;i++) ans = min(ans, dp[r-1][i]);\n\t\t\t\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\tfinal static int INF = 10000000;\n\tboolean solve(){\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n//\t\tPos.n = n;\n\t\tif(n == 0) return false;\n\t\tint[][] land = new int[n][n];\n\t\tint[][] sea = new int[n][n];\n//\t\tNode[] node = new Node[n];\n//\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tland[i][j] = INF;\n\t\t\t\tsea[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x = in.nextInt()-1;\n\t\t\tint y = in.nextInt()-1;\n\t\t\tint t = in.nextInt();\n\t\t\tchar sl = in.next().charAt(0);\n//\t\t\tnode[x].createEdge(node[y]);\n//\t\t\tnode[y].createEdge(node[x]);\n\t\t\tif(sl == 'L'){\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}else{\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\t\tint r = in.nextInt();\n\t\tint[] z = new int[r];\n\t\tfor(int i=0; i<r; i++) z[i] = in.nextInt()-1;\n\t\tfor(int k=0; k<n; k++)\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t}\n\t\t\n\t\tint[][] dp = new int[r][n];\n\t\tfor(int i=0; i<r; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=0; i<r-1; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(land[z[i]][z[i+1]] < INF)\n\t\t\t\t\tdp[i+1][j] = Math.min(dp[i+1][j], dp[i][j]+land[z[i]][z[i+1]]);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(land[z[i]][j] == INF\n\t\t\t\t\t\t\t|| sea[j][k] == INF\n\t\t\t\t\t\t\t|| land[k][z[i+1]] == INF) continue;\n\t\t\t\t\tdp[i+1][k] = Math.min(dp[i+1][k]\n\t\t\t\t\t\t\t, dp[i][j]+land[z[i]][j]+sea[j][k]+land[k][z[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tres = Math.min(res, dp[r-1][i]);\n\t\t}\n\t\t\n//\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n//\t\tqu.add(new Pos(0, z[0], 0));\n//\t\tBitSet used = new BitSet(n*n);\n//\t\tint res = -1;\n//\t\twhile(!qu.isEmpty()){\n//\t\t\tPos p = qu.poll();\n//\t\t\tif(used.get(p.id)) continue;\n//\t\t\tif(p.z == r-1){\n//\t\t\t\tres = p.dist;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tused.set(p.id);\n//\t\t\tif(land[z[p.z]][z[p.z+1]] < INF){\n//\t\t\t\tqu.add(new Pos(p.z+1, p.boat, p.dist+land[z[p.z]][z[p.z+1]]));\n//\t\t\t}\n//\t\t\tfor(int i=0; i<n; i++){\n//\t\t\t\tif(land[z[p.z]][p.boat] == INF\n//\t\t\t\t\t\t|| sea[p.boat][i] == INF\n//\t\t\t\t\t\t|| land[i][z[p.z+1]] == INF) continue;\n//\t\t\t\tqu.add(new Pos(p.z+1, i\n//\t\t\t\t\t\t, p.dist+land[z[p.z]][p.boat]+sea[p.boat][i]+land[i][z[p.z+1]]));\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(res);\n\t\treturn true;\n\t}\n}\n//\n//class Pos implements Comparable<Pos>{\n//\tint z;\n//\tint boat;\n//\tint dist;\n//\tint id;\n//\tstatic int n;\n//\tPos(int z, int boat, int dist){\n//\t\tthis.z = z;\n//\t\tthis.boat = boat;\n//\t\tthis.dist = dist;\n//\t\tid = z*n + boat;\n//\t}\n//\t\n//\t@Override\n//\tpublic int compareTo(Pos o) {\n//\t\treturn dist - o.dist;\n//\t}\n//}\n//\n//class Node{\n//\tint id;\n//\tArrayList<Node> edge = new ArrayList<Node>();\n//\tNode(int id){\n//\t\tthis.id = id;\n//\t}\n//\tvoid createEdge(Node nd){\n//\t\tedge.add(nd);\n//\t}\n//}\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tint INF = 1<<28;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif( (n|m) == 0) break;\n\t\t\t\n\t\t\tint[][] l = new int[n][n]; for(int[] a: l) fill(a, INF);\n\t\t\tint[][] s = new int[n][n]; for(int[] b: s) fill(b, INF);\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tl[i][i] = s[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif(sl.charAt(0) == 'L') l[x][y] = l[y][x] = min(l[x][y], t);\n\t\t\t\telse s[x][y] = s[y][x] = min(s[x][y], t);\n\t\t\t}\n\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tint R = sc.nextInt();\n\t\t\tint r[] = new int[R];\n\t\t\tfor(int i=0;i<n;i++) r[i] = sc.nextInt()-1;\n\t\t\t\n\t\t\tint[][] dp = new int[R][n]; for(int[] a: dp) fill(a, INF);\n\t\t\tdp[0][r[0]] = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<R-1;i++) for(int j=0;j<n;j++) { //ship now\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + l[r[i]][r[i+1]]);\n\t\t\t\tfor(int k=0;k<n;k++) { //ship next\n\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j] + l[r[i]][j] + s[j][k] + l[k][r[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int[] a: l)debug(a);\n//\t\t\tfor(int[] a: s)debug(a);\n//\t\t\tfor(int[] a: dp)debug(a);\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0;i<n;i++) ans = min(ans, dp[R-1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t} \n\t}\n\t\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args ) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\t\n\tMyScanner sc;\n\tPrintWriter writer;\n\n\tpublic void solve() {\n\t\tfinal int INF = 10000 * 1000 + 1;\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] land = new int[n][n];\n\t\t\tint[][] sea = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = 0;\n\t\t\t\tsea[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tif (sc.nextChar() == 'L') {\n\t\t\t\t\tland[x][y] = land[y][x] = Math.min(land[x][y], t);\n\t\t\t\t} else {\n\t\t\t\t\tsea[x][y] = sea[y][x] = Math.min(sea[x][y], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] route = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\troute[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if the ship is at \"j\" when he reaches \"r[i]\", the total distance is dp[i][j].\n\t\t\tint[][] dp = new int[r][n];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][route[0]] = 0;\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (dp[i][j] == INF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], \n\t\t\t\t\t\t\t\t\t\t\t\tdp[i][j] + land[route[i]][j] + sea[j][k] + land[k][route[i + 1]]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[route[i]][route[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tans = Math.min(dp[r - 1][i], ans);\n\t\t\t}\n\t\t\twriter.println(ans);\n\t\t}\n\t}\n\n\tpublic Main() {\n\t\tsc = new MyScanner(System.in);\n\t\twriter = new PrintWriter(System.out);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.solve();\n\t\tm.writer.flush();\n\t}\n\n\tclass MyScanner {\n\t\tInputStream is;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int bufferPointer = 0;\n\t\tprivate int bufferLength = 0;\n\n\t\tMyScanner(InputStream is) {\n\t\t\tthis.is = is;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (bufferLength == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (bufferPointer >= bufferLength) {\n\t\t\t\tbufferPointer = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbufferLength = is.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (bufferLength <= -1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (isChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\tint b = skip();\n\t\t\treturn (char) b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0;\n\t\t\tint b;\n\t\t\tboolean negative = false;\n\t\t\twhile ((b = readByte()) != -1 && !isDigit(b) && b != '-')\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn negative ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int length) {\n\t\t\tint[] array = new int[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tarray[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean negative = false;\n\t\t\twhile ((b = readByte()) != -1 && !isDigit(b) && b != '-')\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn negative ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\t// from '!' to '~'\n\t\tprivate boolean isChar(int b) {\n\t\t\treturn b >= 33 && b <= 126;\n\t\t}\n\n\t\tprivate boolean isDigit(int b) {\n\t\t\treturn b >= '0' && b <= '9';\n\t\t}\n\n\t\tprivate int skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && !isChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint N=sc.nextInt(), M=sc.nextInt();\n\t\t\tif(N==0 && M==0) break;\n\n\t\t\tint[][] tl = new int[N+1][N+1];\n\t\t\tint[][] ts = new int[N+1][N+1];\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tString s = sc.next();\n\n\t\t\t\tif(s.equals(\"S\")){\n\t\t\t\t\tif(ts[x][y] == 0) ts[x][y] = ts[y][x] = t;\n\t\t\t\t\telse ts[x][y] = ts[y][x] = Math.min(ts[x][y],t);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif(tl[x][y] == 0) tl[x][y] = tl[y][x] = t;\n\t\t\t\t\telse tl[x][y] = tl[y][x] = Math.min(tl[x][y],t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint R = sc.nextInt();\n\t\t\tint[] z = new int[R];\n\t\t\tfor(int i=0;i<R;i++) z[i] = sc.nextInt();\n\n\t\t\tint[][] land = floyd(tl);\n\t\t\tint[][] sea = floyd(ts);\n\t\t\tint[][] dp = new int[R+1][N+1];\n\n\t\t\tfor(int[] tmp : dp){\n\t\t\t\tArrays.fill(tmp,Integer.MAX_VALUE);\n\t\t\t}\n\n\t\t\tdp[0][z[0]] = 0;\n\n\t\t\tfor(int i=1;i<R;i++){\n\t\t\t\tfor(int j=1;j<=N;j++){\n\t\t\t\t\tif(dp[i-1][j] == Integer.MAX_VALUE) continue;\n\t\t\t\t\tif(land[z[i-1]][z[i]] != 0){\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j],dp[i-1][j] + land[z[i-1]][z[i]]);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int k=1;k<=N;k++){\n\t\t\t\t\t\tif(j != k && sea[j][k] != 0 &&\n\t\t\t\t\t\t\t (z[i-1] == j || land[z[i-1]][j] != 0) &&\n\t\t\t\t\t\t\t (k == z[i] || land[k][z[i]] != 0) ){\n\t\t\t\t\t\t\tdp[i][k] = Math.min(dp[i][k], dp[i-1][j] + land[z[i-1]][j] + sea[j][k] + land[k][z[i]]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int x : dp[R-1])\n\t\t\t\tmin = Math.min(min, x);\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\n\tprivate static int[][] floyd(int[][] map){\n\t\tint n = map.length;\n\t\tint[][] c = new int[n][n];\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tc[i][j] = map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int k=0;k<n;k++){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i == j || c[i][k] == 0 || c[k][j] == 0) continue;\n\t\t\t\t\telse if(c[i][j] == 0 || c[i][j] > c[i][k] + c[k][j]){\n\t\t\t\t\t\tc[i][j] = c[i][k] + c[k][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn c;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tint INF = 1<<28;\n\tint N = 220;\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif( (n|m) == 0) break;\n\t\t\t\n\t\t\tint[][] l = new int[N][N]; for(int[] a: l) fill(a, INF);\n\t\t\tint[][] s = new int[N][N]; for(int[] b: s) fill(b, INF);\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tl[i][i] = s[i][i] = 0;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tint x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif(sl.charAt(0) == 'L') l[x][y] = l[y][x] = min(l[x][y], t);\n\t\t\t\telse s[x][y] = s[y][x] = min(s[x][y], t);\n\t\t\t}\n\n\t\t\tfor(int k=0;k<n;k++) for(int i=0;i<n;i++) for(int j=0;j<n;j++) {\n\t\t\t\tl[i][j] = min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t\ts[i][j] = min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n\t\t\t\n\t\t\tint R = sc.nextInt();\n\t\t\tint r[] = new int[R];\n\t\t\tfor(int i=0;i<R;i++) r[i] = sc.nextInt()-1;\n\t\t\t\n\t\t\tint[][] dp = new int[R][N]; for(int[] a: dp) fill(a, INF);\n\t\t\tdp[0][r[0]] = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<R-1;i++) for(int j=0;j<n;j++) { //ship now\n\t\t\t\tdp[i+1][j] = min(dp[i+1][j], dp[i][j] + l[r[i]][r[i+1]]);\n\t\t\t\tfor(int k=0;k<n;k++) { //ship next\n\t\t\t\t\tdp[i+1][k] = min(dp[i+1][k], dp[i][j] + l[r[i]][j] + s[j][k] + l[k][r[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int[] a: l)debug(a);\n//\t\t\tfor(int[] a: s)debug(a);\n//\t\t\tfor(int[] a: dp)debug(a);\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i=0;i<n;i++) ans = min(ans, dp[R-1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t} \n\t}\n\t\n\tvoid debug(Object...os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\t\n\tpublic static void main(String[] args ) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal int INF = Integer.MAX_VALUE / 3;\n\tfinal int MAX_N = 200 + 1;\n\tfinal int MAX_M = 100000 + 1;\n\tfinal int MAX_R = 1000 + 1;\n\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] l = new int[MAX_N][MAX_N];\n\t\t\tint[][] s = new int[MAX_N][MAX_N];\n\n\t\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t\t\tl[i][j] = s[i][j] = INF;\n\t\t\tfor (int i = 0; i < MAX_N; i++)\n\t\t\t\tl[i][i] = s[i][i] = 0;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint to = scan.nextInt();\n\t\t\t\tint from = scan.nextInt();\n\t\t\t\tint dist = scan.nextInt();\n\t\t\t\tchar sl = scan.next().charAt(0);\n//\t\t\t\tSystem.out.println(to + \" \" + from + \" \" + dist + \" \" + (sl == 'S'));\n\t\t\t\tif (sl == 'S')\n\t\t\t\t\ts[to][from] = s[from][to] = dist;\n\t\t\t\telse\n\t\t\t\t\tl[to][from] = l[from][to] = dist;\n\t\t\t}\n\n\t\t\t// WarshallFloyd\n\t\t\tfor (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n\t\t\t\tl[i][j] = Math.min(l[i][j], l[i][k] + l[k][j]);\n\t\t\t\ts[i][j] = Math.min(s[i][j], s[i][k] + s[k][j]);\n\t\t\t}\n//\t\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((s[i][j] != INF ? s[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\tfor (int i = 1; i <= n; i++) {\n//\t\t\t\tfor (int j = 1; j <= n; j++)\n//\t\t\t\t\tSystem.out.print((l[i][j] != INF ? l[i][j] : \"x\") + \" \");\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\n\t\t\t// dp\n\t\t\tint[][] dp = new int[MAX_R][MAX_N];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j < MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\n\t\t\tdp[0][z[0]] = 0;\n\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (dp[i][j] == INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + l[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + l[z[i]][j] + s[j][k] + l[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();//the number of cities\n\t\t\tint m=sc.nextInt();//the number of paths\n\t\t\tif(n==0&&m==0)break;\n\t\t\tint INF=Integer.MAX_VALUE/4;\n\t\t\tint[][] ldis=new int[n][n];\n\t\t\tint[][] sdis=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tldis[i][j]=INF;\n\t\t\t\t\tsdis[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"L\")){\n\t\t\t\t\tldis[x][y]=t;\n\t\t\t\t\tldis[y][x]=t;\n\t\t\t\t}else if(str.equals(\"S\")){\n\t\t\t\t\tsdis[x][y]=t;\n\t\t\t\t\tsdis[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tldis[i][j]=Math.min(ldis[i][j],ldis[i][k]+ldis[k][j]);\n\t\t\t\t\t\tsdis[i][j]=Math.min(sdis[i][j],sdis[i][k]+sdis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=sc.nextInt();\n\t\t\tint[] destination=new int[r];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tdestination[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tint[][] dp=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][0]=0;//dp[i][j]???i???????????§?¨?????????????j????????????????????´???????????????\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==j){\n\t\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][destination[i-1]]+dp[i-1][j]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][j]+sdis[j][k]+ldis[k][destination[i-1]]+dp[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min=9999999;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmin=Math.min(dp[r-1][i],min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1 << 28;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint land[][] = new int[n + 1][n + 1];\n\t\t\tint sea[][] = new int[n + 1][n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif (sl.equals(\"L\")) {\n\t\t\t\t\tland[x][y] = land[y][x] = Math.min(t, land[x][y]);\n\t\t\t\t} else {\n\t\t\t\t\tsea[x][y] = sea[y][x] = Math.min(t, sea[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]\n\t\t\t\t\t\t\t\t+ land[k][j]);\n\t\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] zs = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tzs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint[][] dp = new int[r][n + 1]; // dp[i][j]\n\t\t\t\t\t\t\t\t\t\t\t// i番目までの配達を終え、船がjにあるときの最短時間。\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][zs[0]] = 0;\n\t\t\tfor (int i = 1; i < r; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k]\n\t\t\t\t\t\t\t\t+ land[zs[i - 1]][k] + sea[k][j]\n\t\t\t\t\t\t\t\t+ land[j][zs[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tans = Math.min(dp[r - 1][i], ans);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int INF = Integer.MAX_VALUE/10;\n\n        while(true){\n            int n = sc.nextInt(), m =sc.nextInt();\n            if(n==0 && m==0) break;\n\n            int[][] aruki = new int[n][n];\n            int[][] fune = new int[n][n];\n            for(int i=0; i<n; i++){\n                Arrays.fill(aruki[i], INF);\n                Arrays.fill(fune[i], INF);\n                aruki[i][i] = 0; fune[i][i] = 0;\n            }\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n                char s = sc.next().charAt(0);\n                if(s=='L'){\n                    aruki[x][y] = t; aruki[y][x] = t;\n                }else{\n                    fune[x][y] = t; fune[y][x] = t;\n                }\n            }\n\n            for(int k=0; k<n; k++)\n                for(int i=0; i<n; i++)\n                    for(int j=0; j<n; j++){\n                        aruki[i][j] = Math.min(aruki[i][j], aruki[i][k]+aruki[k][j]);\n                        fune[i][j] = Math.min(fune[i][j], fune[i][k]+fune[k][j]);\n                    }\n            \n            int r = sc.nextInt();\n            int[] z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int[][] dp = new int[r][n];\n            for(int i=0; i<r; i++) Arrays.fill(dp[i], INF);\n            dp[0][z[0]] = 0;\n            for(int i=1; i<r; i++){\n                for(int j=0; j<n; j++){\n                    if(dp[i-1][j]==INF) continue;\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + aruki[z[i-1]][z[i]]);\n                    if(aruki[z[i-1]][j]==INF) continue;\n                    for(int k=0; k<n; k++)\n                        dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + aruki[z[i-1]][j] + \n                                            fune[j][k] + aruki[k][z[i]]);\n                    \n                }\n            }\n\n            int min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[r-1][i]);\n            System.out.println(min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint[][] sea;\n\tint[][] land;\n\tstatic final int INF = 1<<27;\n\tint N, R;\n\tint[] tar;\n\n\tvoid run(){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = in.nextInt();\n\t\t\tint M = in.nextInt();\n\t\t\tif(N==0) return ;\n\t\t\tsea = new int[N][N];\n\t\t\tland = new int[N][N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = INF;\n\t\t\t\t\tland[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint x = in.nextInt()-1,\n\t\t\t\t\ty = in.nextInt()-1,\n\t\t\t\t\tt = in.nextInt();\n\t\t\t\tString wh = in.next();\n\t\t\t\tif(wh.equals(\"S\")){\n\t\t\t\t\tsea[x][y] = min(sea[x][y], t);\n\t\t\t\t\tsea[y][x] = sea[x][y];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tland[x][y] = min(land[x][y], t);\n\t\t\t\t\tland[y][x] = land[x][y];\n\t\t\t\t}\n\t\t\t}\n\t\t\tR = in.nextInt();\n\t\t\ttar = new int[R];\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\ttar[i] = in.nextInt() - 1;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tint solve(){\n\t\tfor(int i=0; i<N; i++){\n\t\t\tsea[i][i] = land[i][i] = 0;\n\t\t}\n\t\tfor(int k=0; k<N; k++){\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tsea[i][j] = min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t\tland[i][j] = min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] dp = new int[R][N];\n\t\tfor(int i=0; i<R; i++){\n\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][tar[0]] = 0;\n\t\tfor(int k=0; k<R-1; k++){\n\t\t\tfor(int i=0; i<N; i++)if(dp[k][i] != INF){\n\t\t\t\tfor(int j=0; j<N; j++){\n\t\t\t\t\tdp[k+1][j] = min(dp[k+1][j], dp[k][i]+land[tar[k]][i]+sea[i][j]+land[j][tar[k+1]]);\n\t\t\t\t}\n\t\t\t\tdp[k+1][i] = min(dp[k+1][i], dp[k][i] + land[tar[k]][tar[k+1]]);\n\t\t\t}\n\t\t}\n\t\tint ret = INF;\n\t\tfor(int i=0; i<N; i++){\n\t\t\tret = min(ret, dp[R-1][i]);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tpublic static void main(String args[]){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args)throws Exception{\n\t\tnew Main().solve();\n\t}\n\tvoid solve(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();//the number of cities\n\t\t\tint m=sc.nextInt();//the number of paths\n\t\t\tif(n==0&&m==0)break;\n\t\t\tint INF=Integer.MAX_VALUE/4;\n\t\t\tint[][] ldis=new int[n][n];\n\t\t\tint[][] sdis=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tldis[i][j]=INF;\n\t\t\t\t\tsdis[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint x=sc.nextInt()-1;\n\t\t\t\tint y=sc.nextInt()-1;\n\t\t\t\tint t=sc.nextInt();\n\t\t\t\tString str=sc.next();\n\t\t\t\tif(str.equals(\"L\")){\n\t\t\t\t\tldis[x][y]=t;\n\t\t\t\t\tldis[y][x]=t;\n\t\t\t\t}else if(str.equals(\"S\")){\n\t\t\t\t\tsdis[x][y]=t;\n\t\t\t\t\tsdis[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tldis[i][j]=Math.min(ldis[i][j],ldis[i][k]+ldis[k][j]);\n\t\t\t\t\t\tsdis[i][j]=Math.min(sdis[i][j],sdis[i][k]+sdis[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r=sc.nextInt();\n\t\t\tint[] destination=new int[r];\n\t\t\tfor(int i=0;i<r;i++){\n\t\t\t\tdestination[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tint[][] dp=new int[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tdp[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[0][destination[0]]=0;//dp[i][j]???i???????????§?¨?????????????j????????????????????´???????????????\n\t\t\tfor(int i=1;i<r;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(k==j){\n\t\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][destination[i-1]]+dp[i-1][j]);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[i][j]=Math.min(dp[i][j],ldis[destination[i]][j]+sdis[j][k]+ldis[k][destination[i-1]]+dp[i-1][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min=9999999;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmin=Math.min(dp[r-1][i],min);\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tvoid tr(Object...o){System.out.println(Arrays.deepToString(o));}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] land_adj = new int[n][n];\n\t\t\tint[][] sea_adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tland_adj[i][j] = land_adj[j][i] = INF;\n\t\t\t\t\tsea_adj[i][j] = sea_adj[j][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\tfinal String str = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"L\".equals(str)){\n\t\t\t\t\tland_adj[x][y] = land_adj[y][x] = Math.min(land_adj[x][y], cost);\n\t\t\t\t}else{\n\t\t\t\t\tsea_adj[x][y] = sea_adj[y][x] = Math.min(sea_adj[x][y], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tland_adj[i][j] = Math.min(land_adj[i][j], land_adj[i][k] + land_adj[k][j] >= INF ? INF : (land_adj[i][k] + land_adj[k][j]));\n\t\t\t\t\t\tsea_adj[i][j] = Math.min(sea_adj[i][j], sea_adj[i][k] + sea_adj[k][j] >= INF ? INF : (sea_adj[i][k] + sea_adj[k][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tint[] purpos_place = new int[r];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tpurpos_place[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] time_dp  = new int[r][n];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\ttime_dp[i][j] = Integer.MAX_VALUE;;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttime_dp[0][purpos_place[0]] = 0;\n\t\t\t\n\t\t\tfor(int pur = 1; pur < r; pur++){\n\t\t\t\tfor(int boat_place = 0; boat_place < n; boat_place++){\n\t\t\t\t\tif(time_dp[pur-1][boat_place] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int next_boat = 0; next_boat < n; next_boat++){\n\t\t\t\t\t\tfinal int move_to_boat = land_adj[purpos_place[pur-1]][boat_place];\n\t\t\t\t\t\tfinal int ride_boat = sea_adj[boat_place][next_boat];\n\t\t\t\t\t\tfinal int move_to_next = land_adj[next_boat][purpos_place[pur]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ride_boat >= INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(move_to_next >= INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttime_dp[pur][next_boat] = Math.min(time_dp[pur][next_boat],\n\t\t\t\t\t\t\t\ttime_dp[pur-1][boat_place] + move_to_boat + ride_boat + move_to_next);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tSystem.out.println(Arrays.toString(time_dp[i]));\n\t\t\t}\n\t\t\t*/\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmin = Math.min(min, time_dp[r-1][i]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] land_adj = new int[n][n];\n\t\t\tint[][] sea_adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tland_adj[i][j] = land_adj[j][i] = INF;\n\t\t\t\t\tsea_adj[i][j] = sea_adj[j][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\tfinal String str = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"L\".equals(str)){\n\t\t\t\t\tland_adj[x][y] = land_adj[y][x] = Math.min(land_adj[x][y], cost);\n\t\t\t\t}else{\n\t\t\t\t\tsea_adj[x][y] = sea_adj[y][x] = Math.min(sea_adj[x][y], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tland_adj[i][j] = Math.min(land_adj[i][j], land_adj[i][k] + land_adj[k][j] >= INF ? INF : (land_adj[i][k] + land_adj[k][j]));\n\t\t\t\t\t\tsea_adj[i][j] = Math.min(sea_adj[i][j], sea_adj[i][k] + sea_adj[k][j] >= INF ? INF : (sea_adj[i][k] + sea_adj[k][j]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tint[] purpos_place = new int[r];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tpurpos_place[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] time_dp  = new int[r][n];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\ttime_dp[i][j] = Integer.MAX_VALUE;;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttime_dp[0][purpos_place[0]] = 0;\n\t\t\t\n\t\t\tfor(int pur = 1; pur < r; pur++){\n\t\t\t\tfor(int boat_place = 0; boat_place < n; boat_place++){\n\t\t\t\t\tif(time_dp[pur-1][boat_place] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int next_boat = 0; next_boat < n; next_boat++){\n\t\t\t\t\t\tfinal int move_to_boat = land_adj[purpos_place[pur-1]][boat_place];\n\t\t\t\t\t\tfinal int ride_boat = sea_adj[boat_place][next_boat];\n\t\t\t\t\t\tfinal int move_to_next = land_adj[next_boat][purpos_place[pur]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ride_boat >= INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(move_to_next >= INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t//System.out.println(pur + \" \" + boat_place + \" \" + next_boat + \" \" + (time_dp[pur-1][boat_place] + move_to_boat + ride_boat + move_to_next));\n\t\t\t\t\t\t\n\t\t\t\t\t\ttime_dp[pur][next_boat] = Math.min(time_dp[pur][next_boat],\n\t\t\t\t\t\t\t\ttime_dp[pur-1][boat_place] + move_to_boat + ride_boat + move_to_next);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(land_adj[purpos_place[pur-1]][purpos_place[pur]] < INF){\n\t\t\t\t\t\ttime_dp[pur][boat_place] = Math.min(time_dp[pur][boat_place],\n\t\t\t\t\t\t\t\ttime_dp[pur-1][boat_place] + land_adj[purpos_place[pur-1]][purpos_place[pur]]);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//for(int i = 0; i < r; i++){\n\t\t\t//\tSystem.out.println(Arrays.toString(time_dp[i]));\n\t\t\t//}\n\t\t\t\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmin = Math.min(min, time_dp[r-1][i]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tint m = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint[][] le = new int[n][n];\n\t\t\tint[][] se = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tle[i][j] = se[i][j] = INF;\n\t\t\t\t}\n\t\t\t\tle[i][i] = se[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint a = scanner.nextInt() - 1;\n\t\t\t\tint b = scanner.nextInt() - 1;\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tchar t = scanner.next().charAt(0);\n\t\t\t\tif (t == 'L') {\n\t\t\t\t\tle[a][b] = le[b][a] = Math.min(le[a][b], c);\n\t\t\t\t} else\n\t\t\t\t\tse[a][b] = se[b][a] = Math.min(se[a][b], c);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tle[j][k] = Math.min(le[j][k], le[j][i] + le[i][k]);\n\t\t\t\t\t\tse[j][k] = Math.min(se[j][k], se[j][i] + se[i][k]);\n\t\t\t\t\t}\n\t\t\tint nq = scanner.nextInt();\n\t\t\tint[] q = new int[nq];\n\t\t\tfor (int i = 0; i < nq; i++)\n\t\t\t\tq[i] = scanner.nextInt() - 1;\n\t\t\tint[][] dp = new int[2][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tdp[0][i] = INF;\n\t\t\tdp[0][q[0]] = 0;\n\t\t\tfor (int i = 1; i < nq; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t\tdp[i % 2][j] = INF;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdp[i % 2][k] = Math.min(dp[i % 2][k],\n\t\t\t\t\t\t\t\tdp[(i + 1) % 2][j] + le[q[i - 1]][j] + se[j][k]\n\t\t\t\t\t\t\t\t\t\t+ le[k][q[i]]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i % 2][j] = Math.min(dp[i % 2][j], dp[(i + 1) % 2][j]\n\t\t\t\t\t\t\t+ le[q[i - 1]][q[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tans = Math.min(ans, dp[(nq + 1) % 2][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tint INF = 1 << 25;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int INF = 1 << 28;\n    double EPS = 1e-9;\n    int n, m;\n    int[][] w1, w2;\n    int r;\n    int[] z;\n\n    void run() {\n        for(;;){\n            n=sc.nextInt();\n            m=sc.nextInt();\n            if((n|m)==0){\n                break;\n            }\n            w1=new int[n][n];\n            w2=new int[n][n];\n            for(int i=0;i<n;i++){\n                fill(w1[i],INF);\n                fill(w2[i],INF);\n                w1[i][i]=w2[i][i]=0;\n            }\n            for(int i=0;i<m;i++){\n                int x=sc.nextInt()-1;\n                int y=sc.nextInt()-1;\n                int t=sc.nextInt();\n                String s=sc.next();\n                if(s.equals(\"L\")){\n                    w1[x][y]=w1[y][x]=min(w1[x][y],t);\n                }else{\n                    w2[x][y]=w2[y][x]=min(w2[x][y],t);\n                }\n            }\n            r=sc.nextInt();\n            z=new int[r];\n            for(int i=0;i<r;i++){\n                z[i]=sc.nextInt()-1;\n            }\n            solve();\n        }\n    }\n    \n    void solve(){\n        wf();\n        PriorityQueue<P> que=new PriorityQueue<P>();\n        int[][] d=new int[r][n]; // v ship\n        for(int i=0;i<r;i++){\n            fill(d[i],INF);\n        }\n        for(int i=0;i<n;i++){\n            debug(w1[i]);\n        }\n        debug();\n        for(int i=0;i<n;i++){\n            debug(w2[i]);\n        }\n        d[0][z[0]]=0;\n\n        for(int v=0;v<r-1;v++){\n            for(int s=0;s<n;s++){\n                // (v, s) -> (v+1, )\n                d[v+1][s]=min(d[v+1][s],d[v][s]+w1[z[v]][z[v+1]]);\n                for(int k=0;k<n;k++){\n                    d[v+1][k]=min(d[v+1][k], d[v][s]+w1[z[v]][s]+w2[s][k]+w1[k][z[v+1]]);\n                }\n            }\n        }\n        \n        int min=INF;\n        for(int i=0;i<n;i++){\n            min=min(min,d[r-1][i]);\n        }\n        for(int i=0;i<n;i++){\n            debug(i,d[i]);\n        }\n        debug(min);\n        println(\"\"+min);\n    }\n    \n    void wf(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    w1[j][i]=w1[i][j]=min(w1[j][i],w1[i][k]+w1[k][j]);\n                    w2[j][i]=w2[i][j]=min(w2[j][i],w2[i][k]+w2[k][j]);\n                }\n            }\n        }\n    }\n    \n    class P implements Comparable<P>{\n        int k, ship;\n        int d;\n\n        P(int k,int ship,int d){\n            this.k=k;\n            this.ship=ship;\n            this.d=d;\n        }\n        \n        @Override\n        public int compareTo(P p) {\n            return d-p.d;\n        }\n        \n    }\n    \n    void debug(Object... os) {\n        // System.err.println(deepToString(os));\n    }\n\n    void print(String s) {\n        System.out.print(s);\n    }\n\n    void println(String s) {\n        System.out.println(s);\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tint[][] dp;\n\n\tint dp(int k, int s) {\n\t\tif (k == r - 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp[k][s]) {\n\t\t\treturn dp[k][s];\n\t\t}\n\n\t\tint res = 0;\n\n\t\tint pos = perm[k];\n\t\tint npos = perm[k + 1];\n\n\t\tif (pos == s) {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, sd[pos][npos] + dp(k + 1, npos));\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, sd[pos][i] + ld[i][npos] + dp(k + 1, i));\n\t\t\t}\n\t\t} else {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, ld[pos][s] + sd[s][npos] + dp(k + 1, npos));\n\t\t}\n\n\t\treturn dp[k][s] = res;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(ld[i], 1 << 20);\n\t\t\t\tArrays.fill(sd[i], 1 << 20);\n\t\t\t\tld[i][i] = sd[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tld[i][j] = Math.min(ld[i][j], ld[i][k] + ld[k][j]);\n\t\t\t\t\t\tsd[i][j] = Math.min(sd[i][j], sd[i][k] + sd[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new int[r][n];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tint ans = dp(0, perm[0]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\t\n\tMyScanner sc;\n\tPrintWriter writer;\n\n\tpublic void solve() {\n\t\tfinal int INF = Integer.MAX_VALUE / 4;\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif (n == 0 && m == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] land = new int[n][n];\n\t\t\tint[][] sea = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = 0;\n\t\t\t\tsea[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tif (sc.nextChar() == 'L') {\n\t\t\t\t\tland[x][y] = land[y][x] = Math.min(land[x][y], t);\n\t\t\t\t} else {\n\t\t\t\t\tsea[x][y] = sea[y][x] = Math.min(sea[x][y], t);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] route = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\troute[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if the ship is at \"j\" when he reaches \"r[i]\", the total distance is dp[i][j].\n\t\t\tint[][] dp = new int[r][n];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[0][route[0]] = 0;\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (dp[i][j] == INF) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], \n\t\t\t\t\t\t\t\t\t\t\t\tdp[i][j] + land[route[i]][j] + sea[j][k] + land[k][route[i + 1]]);\n\t\t\t\t\t}\n\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[route[i]][route[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tans = Math.min(dp[r - 1][i], ans);\n\t\t\t}\n\t\t\twriter.println(ans);\n\t\t}\n\t}\n\n\tpublic Main() {\n\t\tsc = new MyScanner(System.in);\n\t\twriter = new PrintWriter(System.out);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.solve();\n\t\tm.writer.flush();\n\t}\n\n\tclass MyScanner {\n\t\tInputStream is;\n\t\tprivate byte[] buffer = new byte[1024];\n\t\tprivate int bufferPointer = 0;\n\t\tprivate int bufferLength = 0;\n\n\t\tMyScanner(InputStream is) {\n\t\t\tthis.is = is;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (bufferLength == -1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (bufferPointer >= bufferLength) {\n\t\t\t\tbufferPointer = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbufferLength = is.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (bufferLength <= -1) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (isChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\tint b = skip();\n\t\t\treturn (char) b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0;\n\t\t\tint b;\n\t\t\tboolean negative = false;\n\t\t\twhile ((b = readByte()) != -1 && !isDigit(b) && b != '-')\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn negative ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tint[] nextIntArray(int length) {\n\t\t\tint[] array = new int[length];\n\t\t\tfor (int i = 0; i < length; i++) {\n\t\t\t\tarray[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean negative = false;\n\t\t\twhile ((b = readByte()) != -1 && !isDigit(b) && b != '-')\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tnegative = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif (isDigit(b)) {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn negative ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\t// from '!' to '~'\n\t\tprivate boolean isChar(int b) {\n\t\t\treturn b >= 33 && b <= 126;\n\t\t}\n\n\t\tprivate boolean isDigit(int b) {\n\t\t\treturn b >= '0' && b <= '9';\n\t\t}\n\n\t\tprivate int skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && !isChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tint[][] dp;\n\n\tint dp(int k, int s) {\n\t\tif (k == r - 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp[k][s]) {\n\t\t\treturn dp[k][s];\n\t\t}\n\n\t\tint res = 0;\n\n\t\tint pos = perm[k];\n\t\tint npos = perm[k + 1];\n\n\t\tif (pos == s) {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, sd[pos][npos] + dp(k + 1, npos));\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, sd[pos][i] + ld[i][npos] + dp(k + 1, i));\n\t\t\t}\n\t\t} else {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, ld[pos][s] + sd[s][npos] + dp(k + 1, npos));\n\t\t}\n\n\t\treturn dp[k][s] = res;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(ld[i], 1 << 20);\n\t\t\t\tArrays.fill(sd[i], 1 << 20);\n\t\t\t\tld[i][i] = sd[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tld[i][j] = Math.min(ld[i][j], ld[i][k] + ld[k][j]);\n\t\t\t\t\t\tsd[i][j] = Math.min(sd[i][j], sd[i][k] + sd[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new int[n][r];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tint ans = dp(0, perm[0]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tfinal int INF = 1 << 24;\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif(n == 0 && m == 0) break;\n\t\t\tint [][] land = new int[n][n];\n\t\t\tint [][] sea = new int[n][n];\n\t\t\tfor(int i=0; i < n; i++){\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = 0;\n\t\t\t\tsea[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int i=0; i < m; i++){\n\t\t\t\tint from = sc.nextInt() -1;\n\t\t\t\tint to = sc.nextInt() -1;\n\t\t\t\tint dis = sc.nextInt();\n\t\t\t\tString mark = sc.next();\n\t\t\t\tif(mark.equals(\"L\")){\n\t\t\t\t\tland[from][to] = dis;\n\t\t\t\t\tland[to][from] = dis;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tsea[from][to] = dis;\n\t\t\t\t\tsea[to][from] = dis;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint [] route = new int[r];\n\t\t\tfor(int i=0; i < r; i++){\n\t\t\t\troute[i] = sc.nextInt() -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tland[i][k] = Math.min(land[i][k], land[i][j] + land[j][k]);\n\t\t\t\t\t\tsea[i][k] = Math.min(sea[i][k], sea[i][j] + sea[j][k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][]dp = new int[n][r];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(dp[i], INF);\n\t\t\t}\n\t\t\tdp[route[0]][0] = 0;\n\t\t\tfor(int i=0; i < r-1; i++){\n\t\t\t\tint from = route[i];\n\t\t\t\tint to = route[i+1];\n\t\t\t\tfor(int untilL = 0; untilL  < n; untilL++){\n\t\t\t\t\tfor(int untilS = 0; untilS < n; untilS++){\n\t\t\t\t\t\tint currentDis = land[from][untilL] + sea[untilL][untilS] + land[untilS][to];\n\t\t\t\t\t\tdp[untilS][i+1] = Math.min(dp[untilS][i+1], dp[untilL][i] + currentDis);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int i = 0; i < n;i ++){\n//\t\t\t\tfor(int j = 0; j < r; j++ ){\n//\t\t\t\t\tif(dp[i][j] == INF){\n//\t\t\t\t\t\tSystem.out.print(\"INF \");\n//\t\t\t\t\t}\n//\t\t\t\t\telse{\n//\t\t\t\t\t\tSystem.out.print(dp[i][j] + \" \");\n//\t\t\t\t\t}\n//\t\t\t\t\t\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tint ans = INF;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tans = Math.min(ans, dp[i][r-1]);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tint[][] dp;\n\n\tint dp(int k, int s) {\n\t\tif (k == r - 1) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (0 <= dp[k][s]) {\n\t\t\treturn dp[k][s];\n\t\t}\n\n\t\tint res = 0;\n\n\t\tint pos = perm[k];\n\t\tint npos = perm[k + 1];\n\n\t\tif (pos == s) {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, sd[pos][npos] + dp(k + 1, npos));\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres = Math.min(res, sd[pos][i] + ld[i][npos] + dp(k + 1, i));\n\t\t\t}\n\t\t} else {\n\t\t\tres = ld[pos][npos] + dp(k + 1, s);\n\t\t\tres = Math.min(res, ld[pos][s] + sd[s][npos] + dp(k + 1, npos));\n\t\t}\n\n\t\treturn dp[k][s] = res;\n\t}\n\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(ld[i], 1 << 20);\n\t\t\t\tArrays.fill(sd[i], 1 << 20);\n\t\t\t\tld[i][i] = sd[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tld[i][j] = Math.min(ld[i][j], ld[i][k] + ld[k][j]);\n\t\t\t\t\t\tsd[i][j] = Math.min(sd[i][j], sd[i][k] + sd[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new int[r][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(dp[i], -1);\n\t\t\t}\n\t\t\tint ans = dp(0, perm[0]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Mr. Rito Post Office\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tint[][] wf1 = new int[n][n], wf2 = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\twf1[i][j] = wf2[i][j] = INF;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)wf1[i][i] = wf2[i][i] = 0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, cost = sc.nextInt();\n\t\t\t\tString str = sc.next();\n\t\t\t\tif(\"L\".equals(str))wf1[s][t] = wf1[t][s] = Math.min(wf1[s][t], cost);\n\t\t\t\telse wf2[s][t] = wf2[t][s] = Math.min(wf2[s][t], cost);\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\twf1[i][j] = Math.min(wf1[i][j], wf1[i][k]+wf1[k][j]);\n\t\t\t\twf2[i][j] = Math.min(wf2[i][j], wf2[i][k]+wf2[k][j]);\n\t\t\t}\n\t\t\tint R = sc.nextInt();\n\t\t\tint[][] dp = new int[2][n];\n\t\t\tArrays.fill(dp[0], INF);\n\t\t\tint X = 1;\n\t\t\tint pre = sc.nextInt()-1;\n\t\t\tdp[0][pre] = 0;\n\t\t\tfor(;--R!=0;X=1-X){\n\t\t\t\tint k = sc.nextInt()-1;\n\t\t\t\tArrays.fill(dp[X], INF);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)dp[X][i] = Math.min(dp[X][i], dp[1-X][j]+wf1[pre][j]+wf2[j][i]+wf1[i][k]);\n\t\t\t\tpre = k;\n\t\t\t}\n\t\t\tint res = INF;\n\t\t\tfor(int i=0;i<n;i++)res = Math.min(res, dp[1-X][i]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\n\npublic class Main {\n\n\tstatic IO io = new IO();\n\tstatic int INF = 1 << 29;\n\tpublic static void main(String[] args) {\n\t\twhile(solve());\n\t\tio.flush();\n\t}\n\t\n\tpublic static boolean solve() {\n\t\tint n = io.nextInt();\n\t\tint m = io.nextInt();\n\t\tif (n == 0) return false;\n\t\t\n\t\tint[][] distLand = new int[n][n];\n\t\tint[][] distSea  = new int[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif (i != j) distLand[i][j] = distSea[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint x = io.nextInt() - 1;\n\t\t\tint y = io.nextInt() - 1;\n\t\t\tint t = io.nextInt();\n\t\t\tchar sl = io.nextChar();\n\t\t\tif (sl == 'L') {\n\t\t\t\tdistLand[x][y] = Math.min(distLand[x][y], t);\n\t\t\t\tdistLand[y][x] = Math.min(distLand[y][x], t);\n\t\t\t}else{\n\t\t\t\tdistSea[x][y] = Math.min(distSea[x][y], t);\n\t\t\t\tdistSea[y][x] = Math.min(distSea[y][x], t);\n\t\t\t}\n\t\t}\n\t\tfor(int k=0;k<n;k++) {\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\tdistLand[i][j] = Math.min(distLand[i][j], distLand[i][k] + distLand[k][j]);\n\t\t\t\t\tdistSea[i][j] = Math.min(distSea[i][j], distSea[i][k] + distSea[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint r = io.nextInt();\n\t\tint[] z = new int[r];\n\t\tfor(int i=0;i<r;i++) {\n\t\t\tz[i] = io.nextInt() - 1;\n\t\t}\n\t\tint[][] dp = new int[n][n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tArrays.fill(dp[i], INF);\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=0;i<r-1;i++) {\n\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\tif (dp[i][j] == INF) continue;\n\t\t\t\tfor(int k=0;k<n;k++) {\n\t\t\t\t\tif (j == k) {\n//\t\t\t\t\t\tSystem.out.println(i + \":\" + j + \"->\" + k + \":\" + (distLand[z[i]][z[i+1]]));\n\t\t\t\t\t\tdp[i+1][k] = Math.min(dp[i+1][k], dp[i][j] + distLand[z[i]][z[i+1]]);\n\t\t\t\t\t}else{\n//\t\t\t\t\t\tSystem.out.println(i + \":\" + j + \"->\" + k + \":\" + (distLand[z[i]][j] + distSea[j][k] + distLand[k][z[i+1]]));\n\t\t\t\t\t\tdp[i+1][k] = Math.min(dp[i+1][k], dp[i][j] + distLand[z[i]][j] + distSea[j][k] + distLand[k][z[i+1]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = INF;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans = Math.min(ans, dp[r-1][i]);\n\t\t}\n\t\tio.println(ans);\n\t\t\n\t\treturn true;\n\t}\n\n}\nclass IO extends PrintWriter {\n\tprivate final InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\t\n\tpublic IO() { this(System.in);}\n\tpublic IO(InputStream source) { super(System.out); this.in = source;}\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t}else{\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n\tprivate static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\tprivate static boolean isNewLine(int c) { return c == '\\n' || c == '\\r';}\n\tpublic boolean hasNext() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic boolean hasNextLine() { while(hasNextByte() && isNewLine(buffer[ptr])) ptr++; return hasNextByte();}\n\tpublic String next() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic char[] nextCharArray(int len) {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tchar[] s = new char[len];\n\t\tint i = 0;\n\t\tint b = readByte();\n\t\twhile(isPrintableChar(b)) {\n\t\t\tif (i == len) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\ts[i++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn s;\n\t}\n\tpublic String nextLine() {\n\t\tif (!hasNextLine()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile(!isNewLine(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile(true){\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t}else if(b == -1 || !isPrintableChar(b)){\n\t\t\t\treturn minus ? -n : n;\n\t\t\t}else{\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\treturn (int) nl;\n\t}\n\tpublic char nextChar() {\n\t\tif (!hasNext()) {\n\t\t\tthrow new NoSuchElementException();\n\t\t}\n\t\treturn (char) readByte();\n\t}\n\tpublic double nextDouble() { return Double.parseDouble(next());}\n\tpublic int[] nextIntArray(int n) { int[] a = new int[n]; for(int i=0;i<n;i++) a[i] = nextInt(); return a;}\n\tpublic long[] nextLongArray(int n) { long[] a = new long[n]; for(int i=0;i<n;i++) a[i] = nextLong(); return a;}\n\tpublic double[] nextDoubleArray(int n) { double[] a = new double[n]; for(int i=0;i<n;i++) a[i] = nextDouble(); return a;}\n\tpublic void nextIntArrays(int[]... a) { for(int i=0;i<a[0].length;i++) for(int j=0;j<a.length;j++) a[j][i] = nextInt();}\n\tpublic int[][] nextIntMatrix(int n,int m) { int[][] a = new int[n][]; for(int i=0;i<n;i++) a[i] = nextIntArray(m); return a;}\n\tpublic char[][] nextCharMap(int n,int m) { char[][] a = new char[n][]; for(int i=0;i<n;i++) a[i] = nextCharArray(m); return a;}\n\tpublic void close() { super.close(); try {in.close();} catch (IOException e) {}}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main\n{\n    private static final int INF = (int) 1e8;\n    public static void floyd(int[][] dl, int[][] ds)\n    {\n        int n = dl.length;\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                    ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt(), m = in.nextInt();\n            if (n == 0 && m == n)\n            {\n                break;\n            }\n            int[][] dp = new int[1024][n];\n            int[][] dl = new int[n][n];\n            int[][] ds = new int[n][n];\n\n            for (int i = 0; i < n; i++)\n            {\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                ds[i][i] = 0;\n                dl[i][i] = 0;\n            }\n            for (int i = 0; i < m; i++)\n            {\n                int v = in.nextInt(), w = in.nextInt(), t = in.nextInt();\n                String c = in.next();\n                v--;w--;\n                if (c.equals(\"L\"))\n                {\n                    dl[v][w] = Math.min(dl[v][w], t);\n                    dl[w][v] = dl[v][w];\n                }\n                else\n                {\n                    ds[v][w] = Math.min(ds[v][w], t);\n                    ds[w][v] = ds[v][w];\n                }\n            }\n            floyd(dl, ds);\n            int r = in.nextInt();\n            int[] nums = new int[r];\n            for (int i = 0; i < r; i++)\n            {\n                nums[i] = in.nextInt();\n                nums[i]--;\n            }\n            for (int i = 0; i < r; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dp[i][j] = INF;\n                }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                dp[0][i] = ds[nums[0]][i] + dl[i][nums[0]];\n            }\n\n            for (int i = 1; i < r; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    for (int k = 0; k < n; k++)\n                    {\n                        if (j != k)\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + dl[nums[i-1]][j] + ds[j][k] + dl[k][nums[i]]);\n                        }\n                        else\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j]+dl[nums[i-1]][nums[i]]);\n                        }\n                    }\n                }\n            }\n\n            int cost = INF;\n            for (int i = 0; i < n; i++)\n            {\n                cost = Math.min(dp[r-1][i], cost);\n            }\n\n            System.out.println(cost);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.BitSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\nclass Solve{\n\tfinal Scanner in = new Scanner(System.in);\n\tfinal static int INF = 10000000;\n\tboolean solve(){\n\t\tint n = in.nextInt();\n\t\tint m = in.nextInt();\n\t\tPos.n = n;\n\t\tif(n ==0) return false;\n\t\tint[][] land = new int[n][n];\n\t\tint[][] sea = new int[n][n];\n\t\tNode[] node = new Node[n];\n\t\tfor(int i=0; i<n; i++) node[i] = new Node(i);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tland[i][j] = INF;\n\t\t\t\tsea[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x = in.nextInt()-1;\n\t\t\tint y = in.nextInt()-1;\n\t\t\tint t = in.nextInt();\n\t\t\tchar sl = in.next().charAt(0);\n\t\t\tnode[x].createEdge(node[y]);\n\t\t\tnode[y].createEdge(node[x]);\n\t\t\tif(sl == 'L'){\n\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t}else{\n\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t}\n\t\tint r = in.nextInt();\n\t\tint[] z = new int[r];\n\t\tfor(int i=0; i<r; i++) z[i] = in.nextInt()-1;\n\t\tfor(int k=0; k<n; k++)\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]+land[k][j]);\n\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k]+sea[k][j]);\n\t\t\t\t}\n\t\t\n\t\tint[][] dp = new int[r][n];\n\t\tfor(int i=0; i<r; i++){\n\t\t\tfor(int j=0; j<r; j++){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i=0; i<r-1; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(land[z[i]][z[i+1]] < INF)\n\t\t\t\t\tdp[i+1][j] = Math.min(dp[i+1][j], dp[i][j]+land[z[i]][z[i+1]]);\n\t\t\t\tfor(int k=0; k<n; k++){\n\t\t\t\t\tif(land[z[i]][j] == INF\n\t\t\t\t\t\t\t|| sea[j][k] == INF\n\t\t\t\t\t\t\t|| land[k][z[i+1]] == INF) continue;\n\t\t\t\t\tdp[i+1][k] = Math.min(dp[i+1][k]\n\t\t\t\t\t\t\t, dp[i][j]+land[z[i]][j]+sea[j][k]+land[k][z[i+1]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint res = INF;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tres = Math.min(res, dp[r-1][i]);\n\t\t}\n\t\t\n//\t\tQueue<Pos> qu = new PriorityQueue<Pos>();\n//\t\tqu.add(new Pos(0, z[0], 0));\n//\t\tBitSet used = new BitSet(n*n);\n//\t\tint res = -1;\n//\t\twhile(!qu.isEmpty()){\n//\t\t\tPos p = qu.poll();\n//\t\t\tif(used.get(p.id)) continue;\n//\t\t\tif(p.z == r-1){\n//\t\t\t\tres = p.dist;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tused.set(p.id);\n//\t\t\tif(land[z[p.z]][z[p.z+1]] < INF){\n//\t\t\t\tqu.add(new Pos(p.z+1, p.boat, p.dist+land[z[p.z]][z[p.z+1]]));\n//\t\t\t}\n//\t\t\tfor(int i=0; i<n; i++){\n//\t\t\t\tif(land[z[p.z]][p.boat] == INF\n//\t\t\t\t\t\t|| sea[p.boat][i] == INF\n//\t\t\t\t\t\t|| land[i][z[p.z+1]] == INF) continue;\n//\t\t\t\tqu.add(new Pos(p.z+1, i\n//\t\t\t\t\t\t, p.dist+land[z[p.z]][p.boat]+sea[p.boat][i]+land[i][z[p.z+1]]));\n//\t\t\t}\n//\t\t}\n\t\tSystem.out.println(res);\n\t\treturn true;\n\t}\n}\n\nclass Pos implements Comparable<Pos>{\n\tint z;\n\tint boat;\n\tint dist;\n\tint id;\n\tstatic int n;\n\tPos(int z, int boat, int dist){\n\t\tthis.z = z;\n\t\tthis.boat = boat;\n\t\tthis.dist = dist;\n\t\tid = z*n + boat;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Pos o) {\n\t\treturn dist - o.dist;\n\t}\n}\n\nclass Node{\n\tint id;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tNode(int id){\n\t\tthis.id = id;\n\t}\n\tvoid createEdge(Node nd){\n\t\tedge.add(nd);\n\t}\n}\n\npublic class Main{\n\tpublic static void main(String[] args) throws IOException{\n\t\tSolve solve = new Solve();\n\t\twhile(solve.solve());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\t//public static Random rand=new Random();\n\n\tstatic final int INF =1<<28;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint from,to;\n\t\tint cost;\n\t\tEdge(int _from,int _to,int _cost){\n\t\t\tfrom=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"->\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tint prev,pos;\n\t\tint cost;\n\t\tTask(int _prev,int _pos,int _cost){\n\t\t\tprev=_prev;pos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost>T.cost?1:cost<T.cost?-1:0;\n\t\t}\n\t}\n\n\tpublic int[] dijkstra(Node[] graph,int s,int[] prev){\n\t\tfinal int V=graph.length;\n\t\tint[] d=new int[V];Arrays.fill(d,INF);d[s]=0;\n\t\tArrays.fill(prev,-2);\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(-1,s,0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\tif(prev[task.pos]!=-2)continue;\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tprev[task.pos]=task.prev;\n\t\t\tfor(Edge e:graph[task.pos].link){\n\t\t\t\t//if(decV(task.prev)==decV(e.to))continue;\n\t\t\t\tif(d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\tque.add(new Task(e.from,e.to,d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic int enc(int v,int prev,int l){\n\t\treturn N*(L+1)*v+prev*(L+1)+l;\n\t}\n\tpublic int decL(int id){\n\t\treturn id%(L+1);\n\t}\n\tpublic int decV(int id){\n\t\treturn id/(L+1);\n\t}\n\tvoid warshall_floyd(int[][] d){\n\t\tfinal int V=d.length;\n\t\tint[][] prev=new int[V][V];\n\t    for(int k=0;k<V;k++)\n\t    \tfor(int i=0;i<V;i++)for(int j=0;j<V;j++)\n\t    \t\tif(d[i][j]>d[i][k] + d[k][j]){\n\t    \t\t\td[i][j]=d[i][k] + d[k][j];\n\t    \t\t\tprev[i][j]=k;\n\t    \t\t}\n\t}\n\n\tint N,M,L;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();M=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tint[][] ld=new int[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\t\tld[i][j]=INF;\n\t\t\tfor(int i=0;i<N;i++)ld[i][i]=0;\n\t\t\tint[][] sd=new int[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\t\tsd[i][j]=INF;\n\t\t\tfor(int i=0;i<N;i++)sd[i][i]=0;\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint x=sc.nextInt()-1,y=sc.nextInt()-1,t=sc.nextInt();\n\t\t\t\tchar sl=sc.next().charAt(0);\n\t\t\t\tif(sl=='L'){\n\t\t\t\t\tld[x][y]=ld[y][x]=t;\n\t\t\t\t}else{\n\t\t\t\t\tsd[x][y]=sd[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\twarshall_floyd(ld);\n\t\t\twarshall_floyd(sd);\n\n\n\t\t\tint R=sc.nextInt();\n\t\t\tint[] zs=new int[R];\n\t\t\tfor(int i=0;i<R;i++)zs[i]=sc.nextInt()-1;\n\n\t\t\tint[] dp=new int[N];//sip pos\n\t\t\tArrays.fill(dp,INF);\n\t\t\tdp[zs[0]]=0;\n\t\t\tfor(int i=1;i<R;i++){\n\t\t\t\tint[] tmp=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\ttmp[j]=min(tmp[j],dp[j]+ld[zs[i-1]][zs[i]]);\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\t\t\ttmp[j]=min(tmp[j],dp[k]+ld[zs[i-1]][k]+sd[k][j]+ld[j][zs[i]]);\n\t\t\t\t\t}\n\t\t\t\t\ttmp[j]=min(tmp[j],dp[j]+ld[zs[i-1]][zs[i]]);\n\t\t\t\t}\n\t\t\t\tdp=tmp;\n\t\t\t\t//ln(str(dp));\n\t\t\t}\n\t\t\tint mv=INF;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tmv=min(mv,dp[i]);\n\n\t\t\tln(mv);\n\t\t}\n\t}\n\n\tpublic String strPath(List<Integer> path){\n\t\tString res=\"\";\n\t\tfor(Integer v:path){\n\t\t\tres+=\"(\"+decV(v)+\",\"+decL(v)+\")--\";\n\t\t}\n\t\treturn res;\n\t}\n\t//パスの出力\n\tpublic static List<Integer> path(int[] prev,int e){\n\t\tList<Integer> path=new ArrayList<Integer>();\n\t\tfor (int u = e; u >= 0; u = prev[u])\n\t\t\tpath.add(u);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Mr. Rito Post Office\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<28;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tint[][] wf1 = new int[n][n], wf2 = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\twf1[i][j] = wf2[i][j] = INF;\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)wf1[i][i] = wf2[i][i] = 0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt()-1, t = sc.nextInt()-1, cost = sc.nextInt();\n\t\t\t\tString str = sc.next();\n\t\t\t\tif(\"L\".equals(str))wf1[s][t] = wf1[t][s] = Math.min(wf1[s][t], cost);\n\t\t\t\telse wf2[s][t] = wf2[t][s] = Math.min(wf2[s][t], cost);\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\t\twf1[i][j] = Math.min(wf1[i][j], wf1[i][k]+wf1[k][j]);\n\t\t\t\twf2[i][j] = Math.min(wf2[i][j], wf2[i][k]+wf2[k][j]);\n\t\t\t}\n\t\t\tint R = sc.nextInt();\n\t\t\tint[][] dp = new int[2][n];\n\t\t\tArrays.fill(dp[0], INF);\n\t\t\tint X = 1;\n\t\t\tint pre = sc.nextInt()-1;\n\t\t\tdp[0][pre] = 0;\n\t\t\tfor(;--R!=0;X=1-X){\n\t\t\t\tint k = sc.nextInt()-1;\n\t\t\t\tArrays.fill(dp[X], INF);\n\t\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)dp[X][i] = Math.min(dp[X][i], dp[1-X][j]+wf1[pre][j]+wf2[j][i]+wf1[i][k]);\n\t\t\t\tpre = k;\n\t\t\t}\n\t\t\tint res = INF;\n\t\t\tfor(int i=0;i<n;i++)res = Math.min(res, dp[1-X][i]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n    Scanner sc = new Scanner(System.in);\n    int INF = 1 << 28;\n    double EPS = 1e-9;\n    int n, m;\n    int[][] w1, w2;\n    int r;\n    int[] z;\n\n    void run() {\n        for(;;){\n            n=sc.nextInt();\n            m=sc.nextInt();\n            if((n|m)==0){\n                break;\n            }\n            w1=new int[n][n];\n            w2=new int[n][n];\n            for(int i=0;i<n;i++){\n                fill(w1[i],INF);\n                fill(w2[i],INF);\n                w1[i][i]=w2[i][i]=0;\n            }\n            for(int i=0;i<m;i++){\n                int x=sc.nextInt()-1;\n                int y=sc.nextInt()-1;\n                int t=sc.nextInt();\n                String s=sc.next();\n                if(s.equals(\"L\")){\n                    w1[x][y]=w1[y][x]=min(w1[x][y],t);\n                }else{\n                    w2[x][y]=w2[y][x]=min(w2[x][y],t);\n                }\n            }\n            r=sc.nextInt();\n            z=new int[r];\n            for(int i=0;i<r;i++){\n                z[i]=sc.nextInt()-1;\n            }\n            solve();\n        }\n    }\n    \n    void solve(){\n        wf();\n        int[][] d=new int[r][n]; // v ship\n        for(int i=0;i<r;i++){\n            fill(d[i],INF);\n        }\n        for(int i=0;i<n;i++){\n            debug(w1[i]);\n        }\n        debug();\n        for(int i=0;i<n;i++){\n            debug(w2[i]);\n        }\n        d[0][z[0]]=0;\n\n        for(int v=0;v<r-1;v++){\n            for(int s=0;s<n;s++){\n                d[v+1][s]=min(d[v+1][s],d[v][s]+w1[z[v]][z[v+1]]);\n                for(int k=0;k<n;k++){\n                    d[v+1][k]=min(d[v+1][k], d[v][s]+w1[z[v]][s]+w2[s][k]+w1[k][z[v+1]]);\n                }\n            }\n        }\n        \n        int min=INF;\n        for(int i=0;i<n;i++){\n            min=min(min,d[r-1][i]);\n        }\n        for(int i=0;i<n;i++){\n            debug(i,d[i]);\n        }\n        debug(min);\n        println(\"\"+min);\n    }\n    \n    void wf(){\n        for(int k=0;k<n;k++){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    w1[j][i]=w1[i][j]=min(w1[j][i],w1[i][k]+w1[k][j]);\n                    w2[j][i]=w2[i][j]=min(w2[j][i],w2[i][k]+w2[k][j]);\n                }\n            }\n        }\n    }\n    \n    void debug(Object... os) {\n        // System.err.println(deepToString(os));\n    }\n\n    void print(String s) {\n        System.out.print(s);\n    }\n\n    void println(String s) {\n        System.out.println(s);\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport static java.lang.Math.*;\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\t//public static Random rand=new Random();\n\n\tstatic final int INF =1<<28;\n\n\tstatic class Node{\n\t\tint id;\n\t\tList<Edge> link=new LinkedList<Edge>();\n\t\tNode(int _id){\n\t\t\tid=_id;\n\t\t}\n\t}\n\tstatic class Edge{\n\t\tint from,to;\n\t\tint cost;\n\t\tEdge(int _from,int _to,int _cost){\n\t\t\tfrom=_from;to=_to;cost=_cost;\n\t\t}\n\t\tpublic String toString() {\n\t\t\treturn from+\"->\"+to;\n\t\t}\n\t}\n\tstatic class Task implements Comparable<Task>{\n\t\tint prev,pos;\n\t\tint cost;\n\t\tTask(int _prev,int _pos,int _cost){\n\t\t\tprev=_prev;pos=_pos;cost=_cost;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Task T) {\n\t\t\treturn cost>T.cost?1:cost<T.cost?-1:0;\n\t\t}\n\t}\n\n\tpublic int[] dijkstra(Node[] graph,int s,int[] prev){\n\t\tfinal int V=graph.length;\n\t\tint[] d=new int[V];Arrays.fill(d,INF);d[s]=0;\n\t\tArrays.fill(prev,-2);\n\t\tPriorityQueue<Task> que=new PriorityQueue<Task>();\n\t\tque.add(new Task(-1,s,0));\n\t\twhile(!que.isEmpty()){\n\t\t\tTask task=que.poll();\n\t\t\tif(prev[task.pos]!=-2)continue;\n\t\t\t//if(d[task.pos]<task.cost)continue;\n\t\t\tprev[task.pos]=task.prev;\n\t\t\tfor(Edge e:graph[task.pos].link){\n\t\t\t\t//if(decV(task.prev)==decV(e.to))continue;\n\t\t\t\tif(d[e.to]>d[e.from]+e.cost){\n\t\t\t\t\td[e.to]=d[e.from]+e.cost;\n\t\t\t\t\tque.add(new Task(e.from,e.to,d[e.to]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d;\n\t}\n\n\tpublic int enc(int v,int prev,int l){\n\t\treturn N*(L+1)*v+prev*(L+1)+l;\n\t}\n\tpublic int decL(int id){\n\t\treturn id%(L+1);\n\t}\n\tpublic int decV(int id){\n\t\treturn id/(L+1);\n\t}\n\tvoid warshall_floyd(int[][] d){\n\t\tfinal int V=d.length;\n\t\tint[][] prev=new int[V][V];\n\t    for(int k=0;k<V;k++)\n\t    \tfor(int i=0;i<V;i++)for(int j=0;j<V;j++)\n\t    \t\tif(d[i][j]>d[i][k] + d[k][j]){\n\t    \t\t\td[i][j]=d[i][k] + d[k][j];\n\t    \t\t\tprev[i][j]=k;\n\t    \t\t}\n\t}\n\n\tint N,M,L;\n\tpublic void run() {\n\t\tTCase:while(true){\n\t\t\tN=sc.nextInt();M=sc.nextInt();\n\t\t\tif(N==0)return;\n\t\t\tint[][] ld=new int[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\t\tld[i][j]=INF;\n\t\t\tfor(int i=0;i<N;i++)ld[i][i]=0;\n\t\t\tint[][] sd=new int[N][N];\n\t\t\tfor(int i=0;i<N;i++)for(int j=0;j<N;j++)\n\t\t\t\tsd[i][j]=INF;\n\t\t\tfor(int i=0;i<N;i++)sd[i][i]=0;\n\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tint x=sc.nextInt()-1,y=sc.nextInt()-1,t=sc.nextInt();\n\t\t\t\tchar sl=sc.next().charAt(0);\n\t\t\t\tif(sl=='L'){\n\t\t\t\t\tld[x][y]=ld[y][x]=t;\n\t\t\t\t}else{\n\t\t\t\t\tsd[x][y]=sd[y][x]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t\twarshall_floyd(ld);\n\t\t\twarshall_floyd(sd);\n\n\t\t\tint R=sc.nextInt();\n\t\t\tint[] zs=new int[R];\n\t\t\tfor(int i=0;i<R;i++)zs[i]=sc.nextInt()-1;\n\n\t\t\tint[] dp=new int[N];//sip pos\n\t\t\tArrays.fill(dp,INF);\n\t\t\tdp[zs[0]]=0;\n\t\t\tfor(int i=1;i<R;i++){\n\t\t\t\tint[] tmp=new int[N];\n\t\t\t\tArrays.fill(tmp,INF);\n\t\t\t\tfor(int k=0;k<N;k++)for(int j=0;j<N;j++){\n\t\t\t\t\ttmp[j]=min(tmp[j],dp[k]+ld[zs[i-1]][k]+sd[k][j]+ld[j][zs[i]]);\n\t\t\t\t}\n\t\t\t\tdp=tmp;\n\t\t\t}\n\t\t\tint mv=INF;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tmv=min(mv,dp[i]);\n\n\t\t\tln(mv);\n\t\t}\n\t}\n\n\tpublic String strPath(List<Integer> path){\n\t\tString res=\"\";\n\t\tfor(Integer v:path){\n\t\t\tres+=\"(\"+decV(v)+\",\"+decL(v)+\")--\";\n\t\t}\n\t\treturn res;\n\t}\n\t//パスの出力\n\tpublic static List<Integer> path(int[] prev,int e){\n\t\tList<Integer> path=new ArrayList<Integer>();\n\t\tfor (int u = e; u >= 0; u = prev[u])\n\t\t\tpath.add(u);\n\t\tCollections.reverse(path);\n\t\treturn path;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\t//output lib\n\tstatic final String br=System.getProperty(\"line.separator\");\n\tstatic final String[] asep=new String[]{\"\",\" \",br,br+br};\n\tstatic String str(Boolean o){\n\t\treturn o?\"YES\":\"NO\";\n\t}\n//\tstatic String str(Double o){\n//\t\treturn String.format(\"%.8f\",o);\n//\t}\n\tstatic <K,V> String str(Map<K, V> map){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(Entry<K,V> set:map.entrySet()){\n\t\t\tif(!isFirst)sb.append(br);\n\t\t\tsb.append(str(set.getKey())).append(\":\").append(str(set.getValue()));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic <E> String str(Collection<E> list){\n\t\tStringBuilder sb=new StringBuilder();\n\t\tboolean isFirst=true;\n\t\tfor(E e:list){\n\t\t\tif(!isFirst)sb.append(\" \");\n\t\t\tsb.append(str(e));\n\t\t\tisFirst=false;\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tstatic String str(Object o){\n\t\tint depth=_getArrayDepth(o);\n\t\tif(depth>0)return _strArray(o,depth);\n\t\tClass<?> c=o.getClass();\n\t\tif(c.equals(Boolean.class))return str((Boolean)o);\n\t\t//if(c.equals(Double.class))return str((Double)o);\n\n\t\treturn o.toString();\n\t}\n\tstatic int _getArrayDepth(Object o){\n\t\tif(!o.getClass().isArray() || Array.getLength(o)==0) return 0;\n\t\treturn \t1+_getArrayDepth(Array.get(o,0));\n\t}\n\tstatic String _strArray(Object o,int depth){\n\t\tif(depth==0) return str(o);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0,len=Array.getLength(o);i<len;i++){\n\t\t\tif(i!=0)sb.append(asep[depth]);\n\t\t\tsb.append(_strArray(Array.get(o,i),depth-1));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void pr(Object... os){\n\t\tboolean isFirst=true;\n\t\tfor(Object o:os){\n\t\t\tif(!isFirst)out.print(\" \");\n\t\t\tout.print(o);\n\t\t\tisFirst=false;\n\t\t}\n\t}\n\tstatic void ln(){\n\t\tout.println();\n\t}\n\tstatic void ln(Object... os){\n\t\tfor(Object o:os){\n\t\t\tpr(o);ln();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, r;\n    int[] z;\n    int INF = 1000000000;\n    int[][][] rikumi;\n    int[][] rikuOnly;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            rikumi = new int[n][n][2];//cost, riku or umi\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    for(int k=0; k<2; k++) rikumi[i][j][k] = INF;\n                }\n            }\n\n            rikuOnly = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(rikuOnly[i], INF);\n            for(int i=0; i<n; i++) rikuOnly[i][i] = 0;\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, tt = sc.nextInt();\n                String s = sc.next();\n                int ss = 0;\n\n                if(s.equals(\"S\")) ss = 1;\n                rikumi[x][y][ss] = tt;\n                rikumi[y][x][ss] = tt;\n                if(ss==0){\n                    rikuOnly[x][y] = tt;\n                    rikuOnly[y][x] = tt; \n                }\n            }\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++) rikuOnly[i][j] = Math.min(rikuOnly[i][j], rikuOnly[i][k] + rikuOnly[k][j]);\n                }\n            }\n\n            r = sc.nextInt();\n            z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int ans = dijkstra();\n            System.out.println(ans);\n        }\n    }\n\n    int dijkstra(){\n        //pos, time, next, fune\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[1] - b[1];\n                }\n            });\n        if(z[0]==0) q.add(new int[]{0,0,1,0,0});\n        else q.add(new int[]{0,0,0,0,0});\n\n\n        int[][] v = new int[n][n];\n        for(int i=0; i<n; i++){\n            //for(int j=0; j<r; j++){\n                for(int k=0; k<n; k++){\n                    v[i][k] = -1;\n                }\n                //}\n        }\n         \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], time = qq[1], next = qq[2], fune = qq[3];\n\n            if(next==r){\n                return time;\n            }\n            if(v[pos][fune]>=next) continue;\n            v[pos][fune] = next;\n\n            for(int i=0; i<n; i++){\n                for(int j=0; j<2; j++){\n                    if(rikumi[pos][i][j]==INF) continue;\n                    int cc = rikumi[pos][i][j];\n                    if(j==1){//umi\n                        if(rikuOnly[fune][pos]==INF) continue;\n                        if(i==z[next]) q.add(new int[]{i, time+cc+rikuOnly[fune][pos]*2, next+1, i});\n                        else q.add(new int[]{i, time+cc+rikuOnly[fune][pos]*2, next, i});\n                    }else{//riku\n                        if(i==z[next]) q.add(new int[]{i, time+cc, next+1, fune});\n                        else q.add(new int[]{i, time+cc, next, fune});\n                    }\n                }\n            }\n        }\n        return INF;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\nimport java.util.stream.Stream;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  class Node {\n    int dist;\n    long cost;\n\n    Node(int a, long b) {\n      dist = a;\n      cost = b;\n    }\n  }\n\n  void run() {\n    for (; ; ) {\n      int n = ni();\n      int m = ni();\n      if (n == 0) {\n        break;\n      }\n      ArrayList<LinkedList<Node>> rikuro = new ArrayList<>();\n      ArrayList<LinkedList<Node>> kairo = new ArrayList<>();\n      for (int i = 0; i <= n; ++i) {\n        rikuro.add(new LinkedList<>());\n        kairo.add(new LinkedList<>());\n      }\n      for (int i = 0; i < m; ++i) {\n        int x = ni();\n        int y = ni();\n        long t = ni();\n        char c = sc.next().charAt(0);\n        if (c == 'L') {\n          rikuro.get(x).add(new Node(y, t));\n          rikuro.get(y).add(new Node(x, t));\n        } else {\n          kairo.get(x).add(new Node(y, t));\n          kairo.get(y).add(new Node(x, t));\n        }\n      }\n      long[][] rikuDist = new long[n + 1][n + 1];\n      for (long[] a : rikuDist) Arrays.fill(a, LNF);\n      for (int i = 1; i <= n; ++i) {\n        rikuDist[i][i] = 0;\n        for (Node node : rikuro.get(i)) {\n          rikuDist[i][node.dist] = Math.min(rikuDist[i][node.dist], node.cost);\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n          for (int k = 1; k <= n; ++k) {\n            if (rikuDist[j][k] > rikuDist[j][i] + rikuDist[i][k]) {\n              rikuDist[j][k] = rikuDist[j][i] + rikuDist[i][k];\n            }\n          }\n        }\n      }\n      long[][] umiDist = new long[n + 1][n + 1];\n      for (long[] a : umiDist) Arrays.fill(a, LNF);\n      for (int i = 1; i <= n; ++i) {\n        umiDist[i][i] = 0;\n        for (Node node : kairo.get(i)) {\n          umiDist[i][node.dist] = Math.min(umiDist[i][node.dist], node.cost);\n        }\n      }\n      for (int i = 1; i <= n; ++i) {\n        for (int j = 1; j <= n; ++j) {\n          for (int k = 1; k <= n; ++k) {\n            if (umiDist[j][k] > umiDist[j][i] + umiDist[i][k]) {\n              umiDist[j][k] = umiDist[j][i] + umiDist[i][k];\n            }\n          }\n        }\n      }\n      int r = ni();\n      int[] z = new int[r + 1];\n      for (int i = 1; i <= r; ++i) {\n        z[i] = ni();\n      }\n      long[][] dp = new long[n + 1][r + 1];\n      for (long[] a : dp) Arrays.fill(a, LNF);\n      dp[z[1]][1] = 0;\n      for (int i = 1; i < r; ++i) {\n        for (int j = 1; j <= n; ++j) {\n          int now = z[i];\n          int next = z[i + 1];\n          dp[j][i + 1] = Math.min(dp[j][i + 1], dp[j][i] + rikuDist[now][next]);\n          for (int k = 1; k <= n; ++k) {\n            long gotoHune = rikuDist[now][j];\n            long gotoK = umiDist[j][k];\n            long gotoNext = rikuDist[k][next];\n            dp[k][i + 1] = Math.min(dp[k][i + 1], dp[j][i] + gotoHune + gotoK + gotoNext);\n          }\n        }\n      }\n      Stream.of(dp).min(Comparator.comparingLong(a -> a[r])).ifPresent(a -> System.out.println(a[r]));\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ??¨ b ????????§??¬?´???°\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)??¨???????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ??°?????????2???????????¨??????????????????????£?\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ??????????????¢?´¢\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ??¢?´¢????????¢??°\n   * @param comp  ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue)\n   *              ??????????????¢??°?????¢?´¢????????¨?????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\?????????§?¨?x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit????????£???????????°????°?????????????????????????????????¨???????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit????????£?????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ?????¨???bit???\n   * @return ?¬????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ?????¬??¢??????????????????????????´??????????????????\n     *\n     * @param a x????????°\n     * @param b y????????°\n     * @param c ?????°???\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)???????????´??????????????????\n     *\n     * @param x1 1?????????x??§?¨?\n     * @param y1 1?????????y??§?¨?\n     * @param x2 2?????????x??§?¨?\n     * @param y2 2?????????y??§?¨?\n     * @return ??´???\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ?????????????????´?????¨??????????????????\n     *\n     * @param l ??´???\n     * @return ?????????2??´?????????????????´??????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????´????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s??¨?????????????????´?????????????????´???\n        // s???????????????1???????????????????????????????????????????????°???s??????????????¨??±?????¨?????????????????§\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\????????´???\n        // CCW???????¬?????????°????????´??????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\?????§????????°????????¨?????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ?????????????????´??????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ???????????§??????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??´?????¨???????????¢\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ??¨?????????????????????????¨????????????´????????£?????????\n    // ????¨????????????´???????????????????????´???????????´?????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ????§???¢???????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree????§??????????\n     *\n     * @param n   ??????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v??§??´??°??????\n     *\n     * @param i index\n     * @param v ??°?????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????§f????????¨????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree????§??????????\n     *\n     * @param n_  ????±???????\n     * @param bif ?????¨???????????¢??°\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v??§??´??°??????\n     *\n     * @param k index\n     * @param v ??°?????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ?????¨??????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)??§?????????bif????????¨?????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(x);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\npublic class Main {\n\tint n, m, r;\n\tint[] perm;\n\tint[][] ld, sd;\n\tList<Integer>[] le, se;\n\n\tclass D implements Comparable<D> {\n\t\tint pos;\n\t\tint shp;\n\t\tint idx;\n\t\tint min;\n\n\t\tpublic D(int pos, int shp, int idx, int min) {\n\t\t\tthis.pos = pos;\n\t\t\tthis.shp = shp;\n\t\t\tthis.idx = idx;\n\t\t\tthis.min = min;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(D o) {\n\t\t\tif (this.min != o.min) {\n\t\t\t\treturn this.min - o.min;\n\t\t\t}\n\t\t\tif (this.pos != o.pos) {\n\t\t\t\treturn this.pos - o.pos;\n\t\t\t}\n\t\t\tif (this.shp != o.shp) {\n\t\t\t\treturn this.shp - o.shp;\n\t\t\t}\n\t\t\tif (this.idx != o.idx) {\n\t\t\t\treturn this.idx - o.idx;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\" + pos + \", \" + shp + \", \" + idx + \", \" + min + \")\";\n\t\t}\n\t}\n\n\tint dijkstra() {\n\t\tPriorityQueue<D> queue = new PriorityQueue<D>();\n\t\tboolean[][][] vis = new boolean[n][n][r + 1];\n\n\t\tint id = 0;\n\t\twhile (perm[0] == perm[id]) {\n\t\t\tid++;\n\t\t}\n\t\tqueue.add(new D(perm[0], perm[0], id, 0));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tD d = queue.poll();\n\t\t\tint pos = d.pos;\n\t\t\tint shp = d.shp;\n\t\t\tint idx = d.idx;\n\t\t\tint min = d.min;\n\n\t\t\tif (idx == r) {\n\t\t\t\treturn min;\n\t\t\t}\n\t\t\tif (vis[pos][shp][idx]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tvis[pos][shp][idx] = true;\n\n\t\t\tfor (Integer to : le[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nshp = shp;\n\t\t\t\tint nidx = idx;\n\t\t\t\tint nmin = min + ld[pos][npos];\n\t\t\t\twhile (nidx < r && perm[nidx] == npos) {\n\t\t\t\t\tnidx++;\n\t\t\t\t}\n\t\t\t\tif (!vis[npos][nshp][nidx]) {\n\t\t\t\t\tqueue.add(new D(npos, nshp, nidx, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (Integer to : se[pos]) {\n\t\t\t\tint npos = to;\n\t\t\t\tint nshp = shp;\n\t\t\t\tint nidx = idx;\n\t\t\t\tint nmin = min + sd[pos][npos];\n\t\t\t\tif (shp != pos) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (nidx < r && perm[nidx] == npos) {\n\t\t\t\t\tnidx++;\n\t\t\t\t}\n\t\t\t\tnshp = npos;\n\t\t\t\tif (!vis[npos][nshp][nidx]) {\n\t\t\t\t\tqueue.add(new D(npos, nshp, nidx, nmin));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() {\n\t\tMyScanner sc = new MyScanner();\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tm = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tle = new LinkedList[n];\n\t\t\tse = new LinkedList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tle[i] = new LinkedList<Integer>();\n\t\t\t\tse[i] = new LinkedList<Integer>();\n\t\t\t}\n\t\t\tld = new int[n][n];\n\t\t\tsd = new int[n][n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() - 1;\n\t\t\t\tint y = sc.nextInt() - 1;\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tchar c = sc.next().charAt(0);\n\t\t\t\tif (c == 'L') {\n\t\t\t\t\tle[x].add(y);\n\t\t\t\t\tle[y].add(x);\n\t\t\t\t\tld[x][y] = ld[y][x] = t;\n\t\t\t\t} else {\n\t\t\t\t\tse[x].add(y);\n\t\t\t\t\tse[y].add(x);\n\t\t\t\t\tsd[x][y] = sd[y][x] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr = sc.nextInt();\n\t\t\tperm = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tperm[i] = sc.nextInt() - 1;\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println(\"----------------------------\" + '\\n');\n\t}\n\n\tclass MyScanner {\n\t\tint read() {\n\t\t\ttry {\n\t\t\t\treturn System.in.read();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    ArrayList[] cost;\n    int n, m, r;\n    int[] z;\n    int INF = 1000000000;\n    int[][][] ts;\n    int[][] rikuOnly;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            cost = new ArrayList[n];\n            for(int i=0; i<n; i++) cost[i] = new ArrayList<Integer>();\n\n            ts = new int[n][n][2];\n            rikuOnly = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(rikuOnly[i], INF);\n            for(int i=0; i<n; i++) rikuOnly[i][i] = 0;\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, tt = sc.nextInt();\n                String s = sc.next();\n                int ss = 0;\n\n                if(s.equals(\"S\")) ss = 1;\n                //cost[x].add(new Integer[]{y, tt, ss});\n                //cost[y].add(new Integer[]{x, tt, ss});\n                cost[x].add(new Integer(y));\n                cost[y].add(new Integer(x));\n                ts[x][y][0] = tt;\n                ts[x][y][1] = ss;\n                ts[y][x][0] = tt;\n                ts[y][x][1] = ss;\n                if(ss==0){\n                    rikuOnly[x][y] = tt;\n                    rikuOnly[y][x] = tt; \n                }\n            }\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++) rikuOnly[i][j] = Math.min(rikuOnly[i][j], rikuOnly[i][k] + rikuOnly[k][j]);\n                }\n            }\n\n            r = sc.nextInt();\n            z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int ans = dijkstra();\n            System.out.println(ans);\n        }\n    }\n\n    int dijkstra(){\n        //pos, time, next, fune, cost back to fune\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[1] - b[1];\n                }\n            });\n        if(z[0]==0) q.add(new int[]{0,0,1,0,0});\n        else q.add(new int[]{0,0,0,0,0});\n\n\n        int[][][] v = new int[n][r][n];\n        for(int i=0; i<n; i++){\n            for(int j=0; j<r; j++){\n                for(int k=0; k<n; k++){\n                    v[i][j][k] = INF;\n                }\n            }\n        }\n         \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], time = qq[1], next = qq[2], fune = qq[3];\n\n            if(next==r){\n                return time;\n            }\n            if(v[pos][next][fune]<=time) continue;\n            v[pos][next][fune] = time;\n\n            for(int i=0; i<cost[pos].size(); i++){\n                //System.out.println(Arrays.toString(cost[pos].get(i)));\n                \n                int t1 = (int)cost[pos].get(i);\n                int t2 = ts[pos][t1][0];\n                int t3 = ts[pos][t1][1];\n                if(t3==1){//umi\n                    if(rikuOnly[fune][pos]==INF) continue;\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next+1, t1});\n                    else q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next, t1});\n                }else{//riku\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2, next+1, fune});\n                    else q.add(new int[]{t1, time+t2, next, fune});\n                }\n                \n            }\n        }\n        return INF;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int n, m, r;\n    int[] z;\n    int INF = 1000000000;\n    int[][][] rikumi;\n    int[][] rikuOnly;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            rikumi = new int[n][n][2];//cost, riku or umi\n            for(int i=0; i<n; i++){\n                for(int j=0; j<n; j++){\n                    for(int k=0; k<2; k++) rikumi[i][j][k] = INF;\n                }\n            }\n\n            rikuOnly = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(rikuOnly[i], INF);\n            for(int i=0; i<n; i++) rikuOnly[i][i] = 0;\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, tt = sc.nextInt();\n                String s = sc.next();\n                int ss = 0;\n\n                if(s.equals(\"S\")) ss = 1;\n                rikumi[x][y][ss] = tt;\n                rikumi[y][x][ss] = tt;\n                if(ss==0){\n                    rikuOnly[x][y] = tt;\n                    rikuOnly[y][x] = tt; \n                }\n            }\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++) rikuOnly[i][j] = Math.min(rikuOnly[i][j], rikuOnly[i][k] + rikuOnly[k][j]);\n                }\n            }\n\n            r = sc.nextInt();\n            z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int ans = dijkstra();\n            System.out.println(ans);\n        }\n    }\n\n    int dijkstra(){\n        //pos, time, next, fune\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[1] - b[1];\n                }\n            });\n        if(z[0]==0) q.add(new int[]{0,0,1,0,0});\n        else q.add(new int[]{0,0,0,0,0});\n\n\n        int[][][] v = new int[n][r][n];\n        for(int i=0; i<n; i++){\n            for(int j=0; j<r; j++){\n                for(int k=0; k<n; k++){\n                    v[i][j][k] = INF;\n                }\n            }\n        }\n         \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], time = qq[1], next = qq[2], fune = qq[3];\n\n            if(next==r){\n                return time;\n            }\n            if(v[pos][next][fune]<=time) continue;\n            v[pos][next][fune] = time;\n\n            for(int i=0; i<n; i++){\n                for(int j=0; j<2; j++){\n                    if(rikumi[pos][i][j]==INF) continue;\n                    int cc = rikumi[pos][i][j];\n                    if(j==1){//umi\n                        if(rikuOnly[fune][pos]==INF) continue;\n                        if(i==z[next]) q.add(new int[]{i, time+cc+rikuOnly[fune][pos]*2, next+1, i});\n                        else q.add(new int[]{i, time+cc+rikuOnly[fune][pos]*2, next, i});\n                    }else{//riku\n                        if(i==z[next]) q.add(new int[]{i, time+cc, next+1, fune});\n                        else q.add(new int[]{i, time+cc, next, fune});\n                    }\n                }\n            }\n        }\n        return INF;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] land_adj = new int[n][n];\n\t\t\tint[][] sea_adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tland_adj[i][j] = land_adj[j][i] = INF;\n\t\t\t\t\tsea_adj[i][j] = sea_adj[j][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\tfinal String str = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"L\".equals(str)){\n\t\t\t\t\tland_adj[x][y] = land_adj[y][x] = Math.min(land_adj[x][y], cost);\n\t\t\t\t}else{\n\t\t\t\t\tsea_adj[x][y] = sea_adj[y][x] = Math.min(sea_adj[x][y], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tland_adj[i][j] = Math.min(land_adj[i][j], land_adj[i][k] + land_adj[k][j]);\n\t\t\t\t\t\tsea_adj[i][j] = Math.min(sea_adj[i][j], sea_adj[i][k] + sea_adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tint[] purpos_place = new int[r];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tpurpos_place[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] time_dp  = new int[r][n];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\ttime_dp[i][j] = Integer.MAX_VALUE;;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttime_dp[0][purpos_place[0]] = 0;\n\t\t\t\n\t\t\tfor(int pur = 1; pur < r; pur++){\n\t\t\t\tfor(int boat_place = 0; boat_place < n; boat_place++){\n\t\t\t\t\tif(time_dp[pur-1][boat_place] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int next_boat = 0; next_boat < n; next_boat++){\n\t\t\t\t\t\tfinal int move_to_boat = land_adj[purpos_place[pur-1]][boat_place];\n\t\t\t\t\t\tfinal int ride_boat = sea_adj[boat_place][next_boat];\n\t\t\t\t\t\tfinal int move_to_next = land_adj[next_boat][purpos_place[pur]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ride_boat >= INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(move_to_next >= INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttime_dp[pur][next_boat] = Math.min(time_dp[pur][next_boat],\n\t\t\t\t\t\t\t\ttime_dp[pur-1][boat_place] + move_to_boat + ride_boat + move_to_next);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tSystem.out.println(Arrays.toString(time_dp[i]));\n\t\t\t}\n\t\t\t*/\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmin = Math.min(min, time_dp[r-1][i]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main\n{\n    private static final int INF = (int) 1e8;\n    public static void floyd(int[][] dl, int[][] ds)\n    {\n        int n = dl.length;\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                    ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt(), m = in.nextInt();\n            if (n == 0 && m == n)\n            {\n                break;\n            }\n            int[][] dp = new int[n][n];\n            int[][] dl = new int[n][n];\n            int[][] ds = new int[n][n];\n\n            for (int i = 0; i < n; i++)\n            {\n                Arrays.fill(dp[i], INF);\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                ds[i][i] = 0;\n                dl[i][i] = 0;\n            }\n            for (int i = 0; i < m; i++)\n            {\n                int v = in.nextInt(), w = in.nextInt(), t = in.nextInt();\n                String c = in.next();\n                v--;w--;\n                if (c.equals(\"L\"))\n                {\n                    dl[v][w] = t;\n                    dl[w][v] = t;\n                }\n                else\n                {\n                    ds[v][w] = t;\n                    ds[w][v] = t;\n                }\n            }\n            floyd(dl, ds);\n            int r = in.nextInt();\n            int[] nums = new int[r];\n            for (int i = 0; i < r; i++)\n            {\n                nums[i] = in.nextInt();\n                nums[i]--;\n            }\n            for (int i = 0; i < n; i++)\n            {\n                dp[0][i] = ds[nums[0]][i] + dl[i][nums[0]];\n            }\n\n            for (int i = 1; i < r; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    for (int k = 0; k < n; k++)\n                    {\n                        if (j != k)\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + dl[nums[i-1]][j] + ds[j][k] + dl[k][nums[i]]);\n                        }\n                        else\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j]+dl[nums[i-1]][nums[i]]);\n                        }\n                    }\n                }\n            }\n\n            int cost = INF;\n            for (int i = 0; i < n; i++)\n            {\n                cost = Math.min(dp[r-1][i], cost);\n            }\n\n            System.out.println(cost);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static final int INF = Integer.MAX_VALUE / 2 - 1;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] land_adj = new int[n][n];\n\t\t\tint[][] sea_adj = new int[n][n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = i + 1; j < n; j++){\n\t\t\t\t\tland_adj[i][j] = land_adj[j][i] = INF;\n\t\t\t\t\tsea_adj[i][j] = sea_adj[j][i] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int x = sc.nextInt() - 1;\n\t\t\t\tfinal int y = sc.nextInt() - 1;\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\tfinal String str = sc.next();\n\t\t\t\t\n\t\t\t\tif(\"L\".equals(str)){\n\t\t\t\t\tland_adj[x][y] = land_adj[y][x] = Math.min(land_adj[x][y], cost);\n\t\t\t\t}else{\n\t\t\t\t\tsea_adj[x][y] = sea_adj[y][x] = Math.min(sea_adj[x][y], cost);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tland_adj[i][j] = Math.min(land_adj[i][j], land_adj[i][k] + land_adj[k][j]);\n\t\t\t\t\t\tsea_adj[i][j] = Math.min(sea_adj[i][j], sea_adj[i][k] + sea_adj[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfinal int r = sc.nextInt();\n\t\t\t\n\t\t\tint[] purpos_place = new int[r];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tpurpos_place[i] = sc.nextInt() - 1;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] time_dp  = new int[r][n];\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\ttime_dp[i][j] = Integer.MAX_VALUE;;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ttime_dp[0][purpos_place[0]] = 0;\n\t\t\t\n\t\t\tfor(int pur = 1; pur < r; pur++){\n\t\t\t\tfor(int boat_place = 0; boat_place < n; boat_place++){\n\t\t\t\t\tif(time_dp[pur-1][boat_place] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int next_boat = 0; next_boat < n; next_boat++){\n\t\t\t\t\t\tfinal int move_to_boat = land_adj[purpos_place[pur-1]][boat_place];\n\t\t\t\t\t\tfinal int ride_boat = sea_adj[boat_place][next_boat];\n\t\t\t\t\t\tfinal int move_to_next = land_adj[next_boat][purpos_place[pur]];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(ride_boat == INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}else if(move_to_next == INF){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttime_dp[pur][next_boat] = Math.min(time_dp[pur][next_boat],\n\t\t\t\t\t\t\t\ttime_dp[pur-1][boat_place] + move_to_boat + ride_boat + move_to_next);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 0; i < r; i++){\n\t\t\t\tSystem.out.println(Arrays.toString(time_dp[i]));\n\t\t\t}\n\t\t\t*/\n\t\t\tint min = Integer.MAX_VALUE;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmin = Math.min(min, time_dp[r-1][i]);\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(min);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    private static IO io = new IO();\n    private static int dl[][] = new int[201][201];  // ???i,j??????????????????????????¢\n    private static int ds[][] = new int[201][201];  // ???i,j??????????????????????????¢\n    private static int dp[][] = new int[2][201];  // i????????????????????????????????????j???????????´??????????°??????????\n    private static int INF = 1145148;\n    public static void main(String[] args) {\n        while (true) {\n\n            int n = io.nextInt();\n            int m = io.nextInt();\n            if (n==0 && m==0) break;\n\n            // ?????????\n            for (int i=0; i<=n; i++) {\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n                dl[i][i] = ds[i][i] = 0;\n            }\n            Arrays.fill(dp[0], INF);\n            Arrays.fill(dp[1], INF);\n\n            // ??\\???\n            for (int i = 0; i < m; i++) {\n                int x = io.nextInt();\n                int y = io.nextInt();\n                int t = io.nextInt();\n                char s = io.nextChar();\n                if (s=='L') {\n                    dl[x][y] = dl[y][x] = Math.min(dl[x][y], t);\n                } else {\n                    ds[x][y] = ds[y][x] = Math.min(ds[x][y], t);\n                }\n            }\n            int r = io.nextInt();\n            int pre = io.nextInt();\n            dp[1][pre] = 0;\n\n            // ???????????£????????????????????§??????????????????/????????????????????¢????????????????±???????\n            for (int k = 1; k <= n; k++) {\n                for (int i = 1; i <= n; i++) {\n                    for (int j = 1; j <= n; j++) {\n                        dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                        ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                    }\n                }\n            }\n\n            // dp?????§??????????¨????\n            int pos;\n            for (int i = 1; i < r; i++) {\n                pos = io.nextInt();\n                for (int j = 1; j <= n; j++) {\n                    for (int k = 1; k <= n; k++) {\n                        if (j==k) dp[(i+1)&1][j] = Math.min(dp[(i+1)&1][j], dp[i&1][j] + dl[pre][pos]);\n                        else dp[(i+1)&1][j] = Math.min(dp[(i+1)&1][j], dp[i&1][k] + dl[pre][k] + ds[k][j] + dl[j][pos]);\n                    }\n                }\n                Arrays.fill(dp[i&1], INF);\n                pre = pos;\n            }\n\n            int ans = INF;\n            for (int i = 1; i <= n; i++) ans = Math.min(ans, dp[r&1][i]);\n            System.out.println(ans);\n        }\n    }\n\n    static class IO extends PrintWriter {\n        private final InputStream in;\n        private final byte[] buffer = new byte[1024];\n        private int ptr = 0;\n        private int buflen = 0;\n\n        IO() {\n            this(System.in);\n        }\n\n        IO(InputStream source) {\n            super(System.out);\n            this.in = source;\n        }\n\n        boolean hasNextByte() {\n            if (ptr < buflen) {\n                return true;\n            } else {\n                ptr = 0;\n                try {\n                    buflen = in.read(buffer);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (buflen <= 0) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        int readByte() {\n            if (hasNextByte()) return buffer[ptr++];\n            else return -1;\n        }\n\n        boolean isPrintableChar(int c) {\n            return 33 <= c && c <= 126;\n        }\n\n        boolean isNewLine(int c) {\n            return c == '\\n' || c == '\\r';\n        }\n\n        void skipUnprintable() {\n            while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n        }\n\n        void skipNewLine() {\n            while (hasNextByte() && isNewLine(buffer[ptr])) ptr++;\n        }\n\n        boolean hasNext() {\n            skipUnprintable();\n            return hasNextByte();\n        }\n\n        boolean hasNextLine() {\n            skipNewLine();\n            return hasNextByte();\n        }\n\n        String next() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        char[] nextCharArray(int len) {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            char[] s = new char[len];\n            int i = 0;\n            int b = readByte();\n            while (isPrintableChar(b)) {\n                if (i == len) {\n                    throw new InputMismatchException();\n                }\n                s[i++] = (char) b;\n                b = readByte();\n            }\n            return s;\n        }\n\n        String nextLine() {\n            if (!hasNextLine()) {\n                throw new NoSuchElementException();\n            }\n            StringBuilder sb = new StringBuilder();\n            int b = readByte();\n            while (!isNewLine(b)) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n        long nextLong() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            long n = 0;\n            boolean minus = false;\n            int b = readByte();\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            if (b < '0' || '9' < b) {\n                throw new NumberFormatException();\n            }\n            while (true) {\n                if ('0' <= b && b <= '9') {\n                    n *= 10;\n                    n += b - '0';\n                } else if (b == -1 || !isPrintableChar(b)) {\n                    return minus ? -n : n;\n                } else {\n                    throw new NumberFormatException();\n                }\n                b = readByte();\n            }\n        }\n\n        int nextInt() {\n            long nl = nextLong();\n            if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) {\n                throw new NumberFormatException();\n            }\n            return (int) nl;\n        }\n\n        char nextChar() {\n            if (!hasNext()) {\n                throw new NoSuchElementException();\n            }\n            return (char) readByte();\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] arrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long[] arrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = nextLong();\n            return a;\n        }\n\n        double[] arrayDouble(int n) {\n            double[] a = new double[n];\n            for (int i = 0; i < n; i++) a[i] = nextDouble();\n            return a;\n        }\n\n        void arrayInt(int[]... a) {\n            for (int i = 0; i < a[0].length; i++) for (int j = 0; j < a.length; j++) a[j][i] = nextInt();\n        }\n\n        int[][] matrixInt(int n, int m) {\n            int[][] a = new int[n][];\n            for (int i = 0; i < n; i++) a[i] = arrayInt(m);\n            return a;\n        }\n\n        char[][] charMap(int n, int m) {\n            char[][] a = new char[n][];\n            for (int i = 0; i < n; i++) a[i] = nextCharArray(m);\n            return a;\n        }\n\n        public void close() {\n            super.close();\n            try {\n                in.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n\t\n\tstatic int N, M, R;\n\tstatic int[] Z = new int[1001];\n\tstatic int[][] WL = new int[201][201], WS = new int[201][201];\n\tstatic final int INF = 1 << 25;\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tif (N == 0 && M == 0) return false;\n\t\t\n\t\tfor (int i = 0; i < 201; i++) {\n\t\t\tfill(WL[i], INF); \n\t\t\tfill(WS[i], INF);\n\t\t\tWL[i][i] = WS[i][i] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x, y, t;\n\t\t\tchar sl;\n\t\t\tx = sc.nextInt();\n\t\t\ty = sc.nextInt();\n\t\t\tt = sc.nextInt();\n\t\t\tsl = sc.next().charAt(0);\n\t\t\tif (sl == 'S') {\n\t\t\t\tWS[x][y] = WS[y][x] = t;\n\t\t\t} else {\n\t\t\t\tWL[x][y] = WL[y][x] = t;\n\t\t\t}\n\t\t}\n\t\t\n\t\tR = sc.nextInt();\n\t\tfor (int i = 0; i < R; i++) Z[i] = sc.nextInt();\n\t\treturn true;\n\t}\n\n\tstatic int[][] dist = new int[1010][201];\n\tstatic void solve() {\n\t\tPriorityQueue<State> que = new PriorityQueue<State>();\n\t\tque.offer(new State(0, Z[0], 0));\n\t\tint ans = INF;\n\t\tfor (int k = 1; k < 201; k++) {\n\t\t\tfor (int i = 1; i < 201; i++) { \n\t\t\t\tfor (int j = 1; j < 201; j++) {\n\t\t\t\t\tWL[i][j] = min(WL[i][j], WL[i][k] + WL[k][j]);\n\t\t\t\t\tWS[i][j] = min(WS[i][j], WS[i][k] + WS[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\t\n\t\t\n\t\t/*\n\t\tfor (int i = 0; i < 1000; i++) fill(dist[i], -1);\n\t\twhile (!que.isEmpty()) {\n\t\t\tState s = que.poll();\n\t\t\tif (dist[s.cur][s.ship] != -1) continue;\n\t\t\t\n\t\t\tdist[s.cur][s.ship] = s.cost;\n\t\t\t\n\t\t\tif (s.cur == R - 1) {\n\t\t\t\tans = s.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint cur = s.cur, from = Z[s.cur], to = Z[s.cur + 1], cost = s.cost, ship = s.ship;\n\t\t\t// ツ猟、ツ路ツづーツ使ツつ、\n\t\t\t\n\t\t\tint ncost = cost + WL[from][to], nship = ship;\n\t\t\tif (dist[s.cur + 1][nship] == -1 && ncost < INF) \n\t\t\t\tque.offer(new State(s.cur + 1, ship, cost + WL[from][to]));\n\t\t\t\n\t\t\t// ツ海ツ路ツづーツ使ツつ、\n\t\t\tfor (int k = 1; k < 201; k++) {\n\t\t\t\tncost = cost + WL[from][ship] + WS[ship][k] + WL[k][to];\n\t\t\t\tnship = k;\n\t\t\t\tif (dist[s.cur + 1][nship] == -1 && ncost < INF)\n\t\t\t\t\tque.offer(new State(s.cur + 1, nship, ncost));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t*/\n\t\t\n\t\tfor (int i = 0; i < 1000; i++) fill(dist[i], INF);\n\t\tdist[0][Z[0]] = 0;\n\t\t\n\t\tfor (int i = 1; i <= R; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tint from = Z[i - 1], to = Z[i]; \n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i - 1][j] + WL[from][to]);\n\t\t\t\tfor (int k = 1; k <= N; k++) {\n\t\t\t\t\tdist[i][j] = min(dist[i][j], dist[i - 1][k] + WL[from][k] + WS[k][j] + WL[j][to]); \n\t\t\t\t}\n\t\t\t\t//System.out.print(dist[i][j] + \" \");\n\t\t\t}\n\t\t\t//System.out.println();\n\t\t}\n\t\t\n\t\t\n\t\tans = INF;\n\t\tfor (int i = 1; i < 201; i++) \n\t\t\tans = min(ans, dist[R - 1][i]);\n\t\t\n\t\tSystem.out.println(ans);\n\t}\t\n}\n\nclass State implements Comparable<State> {\n\tint cur, ship, cost;\n\tState (int cur, int ship, int cost) {\n\t\tthis.cur = cur;\n\t\tthis.ship = ship;\n\t\tthis.cost = cost;\n\t}\n\t\n\tpublic int compareTo(State s) {\n\t\treturn this.cost - s.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    ArrayList[] cost;\n    int n, m, r;\n    int[] z;\n    int INF = 1000000000;\n    int[][][] ts;\n    int[][] rikuOnly;\n\n    @SuppressWarnings(\"unchecked\")\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            n = sc.nextInt();\n            m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            cost = new ArrayList[n];\n            for(int i=0; i<n; i++) cost[i] = new ArrayList<Integer>();\n\n            ts = new int[n][n][2];\n            rikuOnly = new int[n][n];\n            for(int i=0; i<n; i++) Arrays.fill(rikuOnly[i], INF);\n            for(int i=0; i<n; i++) rikuOnly[i][i] = 0;\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, tt = sc.nextInt();\n                String s = sc.next();\n                int ss = 0;\n\n                if(s.equals(\"S\")) ss = 1;\n                //cost[x].add(new Integer[]{y, tt, ss});\n                //cost[y].add(new Integer[]{x, tt, ss});\n                cost[x].add(new Integer(y));\n                cost[y].add(new Integer(x));\n                ts[x][y][0] = tt;\n                ts[x][y][1] = ss;\n                ts[y][x][0] = tt;\n                ts[y][x][1] = ss;\n                if(ss==0){\n                    rikuOnly[x][y] = tt;\n                    rikuOnly[y][x] = tt; \n                }\n            }\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++) rikuOnly[i][j] = Math.min(rikuOnly[i][j], rikuOnly[i][k] + rikuOnly[k][j]);\n                }\n            }\n\n            r = sc.nextInt();\n            z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int ans = dijkstra();\n            System.out.println(ans);\n        }\n    }\n\n    int dijkstra(){\n        //pos, time, next, fune, cost back to fune\n        PriorityQueue<int[]> q = new PriorityQueue<int[]>(10, new Comparator<int[]>(){\n                public int compare(int[] a, int[] b){\n                    return a[1] - b[1];\n                }\n            });\n        if(z[0]==0) q.add(new int[]{0,0,1,0,0});\n        else q.add(new int[]{0,0,0,0,0});\n\n\n        int[][][] v = new int[n][r][n];\n        for(int i=0; i<n; i++){\n            for(int j=0; j<r; j++){\n                for(int k=0; k<n; k++){\n                    v[i][j][k] = INF;\n                }\n            }\n        }\n         \n        while(q.size()>0){\n            int[] qq = q.poll();\n            int pos = qq[0], time = qq[1], next = qq[2], fune = qq[3];\n\n            if(next==r){\n                return time;\n            }\n            if(v[pos][next][fune]<=time) continue;\n            v[pos][next][fune] = time;\n\n            for(int i=0; i<cost[pos].size(); i++){\n                //System.out.println(Arrays.toString(cost[pos].get(i)));\n                \n                int t1 = (int)cost[pos].get(i);\n                int t2 = ts[pos][t1][0];\n                int t3 = ts[pos][t1][1];\n                if(t3==1){//umi\n                    if(rikuOnly[fune][pos]==INF) continue;\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next+1, t1});\n                    else q.add(new int[]{t1, time+t2+rikuOnly[fune][pos]*2, next, t1});\n                }else{//riku\n                    if(t1==z[next]) q.add(new int[]{t1, time+t2, next+1, fune});\n                    else q.add(new int[]{t1, time+t2, next, fune});\n                }\n                \n            }\n        }\n        return INF;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int INF = 1<<27;\n\n        while(true){\n            int n = sc.nextInt(), m = sc.nextInt();\n            if(n==0 && m==0) break;\n\n            int[][] riku = new int[n][n];\n            int[][] umi = new int[n][n];\n            for(int i=0; i<n; i++){\n                Arrays.fill(riku[i], INF);\n                Arrays.fill(umi[i], INF);\n            }\n\n\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1;\n                int t = sc.nextInt(); String s = sc.next();\n                if(s.equals(\"L\")){\n                    riku[x][y] = Math.min(riku[x][y], t);\n                    riku[y][x] = Math.min(riku[y][x], t);\n                }else{\n                    umi[x][y] = Math.min(umi[x][y], t);\n                    umi[y][x] = Math.min(umi[y][x], t);\n                }\n            }\n\n            for(int i=0; i<n; i++){\n                riku[i][i] = 0;\n                umi[i][i] = 0;\n            }\n\n            int r = sc.nextInt();\n            int[] z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            for(int k=0; k<n; k++){\n                for(int i=0; i<n; i++){\n                    for(int j=0; j<n; j++){\n                        riku[i][j] = Math.min(riku[i][j], riku[i][k] + riku[k][j]);\n                        umi[i][j] = Math.min(umi[i][j], umi[i][k] + umi[k][j]);\n                    }\n                }\n            }\n\n            int[][] dp = new int[r][n];\n            for(int i=0; i<r; i++) Arrays.fill(dp[i], INF);\n            dp[0][z[0]] = 0;\n\n            for(int k=0; k<r-1; k++){\n                for(int i=0; i<n; i++){\n                    if(dp[k][i]==INF) continue;\n                    for(int j=0; j<n; j++){\n                        dp[k+1][j] = Math.min(dp[k+1][j], \n                                              dp[k][i] + riku[z[k]][i] + umi[i][j] + riku[j][z[k+1]]);\n                    }\n                    dp[k+1][i] = Math.min(dp[k+1][i], dp[k][i] + riku[z[k]][z[k+1]]);\n                }\n            }\n\n            int min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[r-1][i]);\n            System.out.println(min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1 << 28;\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0)\n\t\t\t\tbreak;\n\t\t\tint land[][] = new int[n + 1][n + 1];\n\t\t\tint sea[][] = new int[n + 1][n + 1];\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tArrays.fill(land[i], INF);\n\t\t\t\tArrays.fill(sea[i], INF);\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\tint t = sc.nextInt();\n\t\t\t\tString sl = sc.next();\n\t\t\t\tif (sl.equals(\"L\")) {\n\t\t\t\t\tland[x][y] = land[y][x] = Math.min(t, land[x][y]);\n\t\t\t\t} else {\n\t\t\t\t\tsea[x][y] = sea[y][x] = Math.min(t, sea[x][y]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k]\n\t\t\t\t\t\t\t\t+ land[k][j]);\n\t\t\t\t\t\tsea[i][j] = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint r = sc.nextInt();\n\t\t\tint[] zs = new int[r];\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tzs[i] = sc.nextInt();\n\t\t\t}\n\t\t\tlong[][] dp = new long[r][n + 1]; // dp[i][j]\n\t\t\t\t\t\t\t\t\t\t\t\t// i番目までの配達を終え、船がjにあるときの最短時間。\n\t\t\tlong LINF = 1 << 61;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tArrays.fill(dp[i], LINF);\n\t\t\t}\n\t\t\tdp[0][zs[0]] = 0;\n\t\t\tfor (int i = 1; i < r; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tfor (int k = 1; k <= n; k++) {\n\t\t\t\t\t\tdp[i][j] = Math.min(dp[i][j], dp[i - 1][k]\n\t\t\t\t\t\t\t\t+ land[zs[i - 1]][k] + sea[k][j]\n\t\t\t\t\t\t\t\t+ land[j][zs[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = LINF;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tans = Math.min(dp[r - 1][i], ans);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int INF = 100000000;\n\tfinal int MAX_N = 200;\n\tfinal int MAX_R = 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\treturn;\n\n\t\t\tint[][] land = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tint[][] sea  = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tfor (int i = 0; i <= MAX_N; i++) {\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= MAX_N; i++)\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tint t = scan.nextInt();\n\t\t\t\tchar sl = scan.next().charAt(0);\n\t\t\t\tif (sl == 'L')\n\t\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t\telse\n\t\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\t\t\n\t\t\tfor (int k = 1; k <= MAX_N; k++) for (int i = 1; i <= MAX_N; i++) for (int j = 1; j <= MAX_N; j++) {\n\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\tsea[i][j]  = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"land\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((land[i][j] == INF ? \"X\" : land[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t\tSystem.out.println(\"sea\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((sea[i][j] == INF ? \"X\" : sea[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint[][] dp = new int[MAX_R][MAX_N + 1];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\n\t\t\tdp[0][z[0]] = 0;\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (land[z[i]][z[i + 1]] != INF)\n\t\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + land[z[i]][j] + sea[j][k] + land[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"dp\");\n\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((dp[i][j] == INF ? \"X\" : dp[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        int INF = Integer.MAX_VALUE/10;\n\n        while(true){\n            int n = sc.nextInt(), m =sc.nextInt();\n            if(n==0 && m==0) break;\n\n            int[][] aruki = new int[n][n];\n            int[][] fune = new int[n][n];\n            for(int i=0; i<n; i++){\n                Arrays.fill(aruki[i], INF);\n                Arrays.fill(fune[i], INF);\n                aruki[i][i] = 0; fune[i][i] = 0;\n            }\n            for(int i=0; i<m; i++){\n                int x = sc.nextInt()-1, y = sc.nextInt()-1, t = sc.nextInt();\n                char s = sc.next().charAt(0);\n                if(s=='L'){\n                    aruki[x][y] = t; aruki[y][x] = t;\n                }else{\n                    fune[x][y] = t; fune[y][x] = t;\n                }\n            }\n\n            for(int k=0; k<n; k++)\n                for(int i=0; i<n; i++)\n                    for(int j=0; j<n; j++){\n                        aruki[i][j] = Math.min(aruki[i][j], aruki[i][k]+aruki[k][j]);\n                        fune[i][j] = Math.min(fune[i][j], fune[i][k]+fune[k][j]);\n                    }\n            \n            int r = sc.nextInt();\n            int[] z = new int[r];\n            for(int i=0; i<r; i++) z[i] = sc.nextInt()-1;\n\n            int[][] dp = new int[r][n];\n            for(int i=0; i<r; i++) Arrays.fill(dp[i], INF);\n            dp[0][z[0]] = 0;\n            for(int i=1; i<r; i++){\n                for(int j=0; j<n; j++){\n                    dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + aruki[z[i-1]][z[i]]);\n                    for(int k=0; k<n; k++)\n                        dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + aruki[z[i-1]][j] + \n                                            fune[j][k] + aruki[k][z[i]]);\n                }\n            }\n\n            int min = INF;\n            for(int i=0; i<n; i++) min = Math.min(min, dp[r-1][i]);\n            System.out.println(min);\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int INF = 100000000;\n\tfinal int MAX_N = 200;\n\tfinal int MAX_R = 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\treturn;\n\n\t\t\tint[][] land = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tint[][] sea  = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tfor (int i = 0; i <= MAX_N; i++) {\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= MAX_N; i++)\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tint t = scan.nextInt();\n\t\t\t\tchar sl = scan.next().charAt(0);\n\t\t\t\tif (sl == 'L')\n\t\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t\telse\n\t\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\t\t\n\t\t\tfor (int k = 1; k <= MAX_N; k++) for (int i = 1; i <= MAX_N; i++) for (int j = 1; j <= MAX_N; j++) {\n\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\tsea[i][j]  = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"land\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((land[i][j] == INF ? \"X\" : land[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t\tSystem.out.println(\"sea\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((sea[i][j] == INF ? \"X\" : sea[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint[][] dp = new int[MAX_R][MAX_N + 1];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\n\t\t\tdp[0][1] = 0;\n\t\t\tfor (int i = 0; i < r - 1; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (land[z[i]][z[i + 1]] != INF)\n\t\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + land[z[i]][j] + sea[j][k] + land[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"dp\");\n\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((dp[i][j] == INF ? \"X\" : dp[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main\n{\n    private static final int INF = (int) 1e8;\n    public static void floyd(int[][] dl, int[][] ds)\n    {\n        int n = dl.length;\n        for (int k = 0; k < n; k++)\n        {\n            for (int i = 0; i < n; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    dl[i][j] = Math.min(dl[i][j], dl[i][k]+dl[k][j]);\n                    ds[i][j] = Math.min(ds[i][j], ds[i][k]+ds[k][j]);\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n\n        while (true)\n        {\n            int n = in.nextInt(), m = in.nextInt();\n            if (n == 0 && m == n)\n            {\n                break;\n            }\n            int[][] dp = new int[1024][n];\n            int[][] dl = new int[n][n];\n            int[][] ds = new int[n][n];\n\n            for (int i = 0; i < n; i++)\n            {\n                Arrays.fill(dp[i], INF);\n                Arrays.fill(dl[i], INF);\n                Arrays.fill(ds[i], INF);\n            }\n\n\n            for (int i = 0; i < n; i++)\n            {\n                ds[i][i] = 0;\n                dl[i][i] = 0;\n            }\n            for (int i = 0; i < m; i++)\n            {\n                int v = in.nextInt(), w = in.nextInt(), t = in.nextInt();\n                String c = in.next();\n                v--;w--;\n                if (c.equals(\"L\"))\n                {\n                    dl[v][w] = t;\n                    dl[w][v] = t;\n                }\n                else\n                {\n                    ds[v][w] = t;\n                    ds[w][v] = t;\n                }\n            }\n            floyd(dl, ds);\n            int r = in.nextInt();\n            int[] nums = new int[r];\n            for (int i = 0; i < r; i++)\n            {\n                nums[i] = in.nextInt();\n                nums[i]--;\n            }\n            for (int i = 0; i < n; i++)\n            {\n                dp[0][i] = ds[nums[0]][i] + dl[i][nums[0]];\n            }\n\n            for (int i = 1; i < r; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    for (int k = 0; k < n; k++)\n                    {\n                        if (j != k)\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j] + dl[nums[i-1]][j] + ds[j][k] + dl[k][nums[i]]);\n                        }\n                        else\n                        {\n                            dp[i][k] = Math.min(dp[i][k], dp[i-1][j]+dl[nums[i-1]][nums[i]]);\n                        }\n                    }\n                }\n            }\n\n            int cost = INF;\n            for (int i = 0; i < n; i++)\n            {\n                cost = Math.min(dp[r-1][i], cost);\n            }\n\n            System.out.println(cost);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tfinal boolean DEBUG = false;\n\tfinal int INF = 100000000;\n\tfinal int MAX_N = 200;\n\tfinal int MAX_R = 1000;\n\tvoid run() {\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scan.nextInt();\n\t\t\tint m = scan.nextInt();\n\t\t\tif (n + m == 0)\n\t\t\t\treturn;\n\n\t\t\tint[][] land = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tint[][] sea  = new int[MAX_N + 1][MAX_N + 1];\n\t\t\tfor (int i = 0; i <= MAX_N; i++) {\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tland[i][j] = sea[i][j] = INF;\n\t\t\t}\n\t\t\tfor (int i = 0; i <= MAX_N; i++)\n\t\t\t\tland[i][i] = sea[i][i] = 0;\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = scan.nextInt();\n\t\t\t\tint y = scan.nextInt();\n\t\t\t\tint t = scan.nextInt();\n\t\t\t\tchar sl = scan.next().charAt(0);\n\t\t\t\tif (sl == 'L')\n\t\t\t\t\tland[x][y] = land[y][x] = t;\n\t\t\t\telse\n\t\t\t\t\tsea[x][y] = sea[y][x] = t;\n\t\t\t}\n\t\t\n\t\t\tint r = scan.nextInt();\n\t\t\tint[] z = new int[MAX_R];\n\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\tz[i] = scan.nextInt();\n\t\t\n\t\t\tfor (int k = 1; k <= MAX_N; k++) for (int i = 1; i <= MAX_N; i++) for (int j = 1; j <= MAX_N; j++) {\n\t\t\t\tland[i][j] = Math.min(land[i][j], land[i][k] + land[k][j]);\n\t\t\t\tsea[i][j]  = Math.min(sea[i][j], sea[i][k] + sea[k][j]);\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"land\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((land[i][j] == INF ? \"X\" : land[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t\tSystem.out.println(\"sea\");\n\t\t\t\tfor (int i = 1; i <= n; i++)\n\t\t\t\t\tfor (int j = 1; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((sea[i][j] == INF ? \"X\" : sea[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint[][] dp = new int[MAX_R][MAX_N + 1];\n\t\t\tfor (int i = 0; i < MAX_R; i++)\n\t\t\t\tfor (int j = 0; j <= MAX_N; j++)\n\t\t\t\t\tdp[i][j] = INF;\n\n\t\t\tdp[0][1] = 0;\n\t\t\tfor (int i = 0; i < r; i++) {\n\t\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\t\tif (land[z[i]][z[i + 1]] != INF)\n\t\t\t\t\t\tdp[i + 1][j] = Math.min(dp[i + 1][j], dp[i][j] + land[z[i]][z[i + 1]]);\n\t\t\t\t\tfor (int k = 1; k <= n; k++)\n\t\t\t\t\t\tdp[i + 1][k] = Math.min(dp[i + 1][k], dp[i][j] + land[z[i]][j] + sea[j][k] + land[k][z[i + 1]]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (DEBUG) {\n\t\t\t\tSystem.out.println(\"dp\");\n\t\t\t\tfor (int i = 0; i < r; i++)\n\t\t\t\t\tfor (int j = 0; j <= n; j++)\n\t\t\t\t\t\tSystem.out.print((dp[i][j] == INF ? \"X\" : dp[i][j]) + (j == n ? \"\\n\" : \" \"));\n\t\t\t}\n\n\t\t\tint ans = INF;\n\t\t\tfor (int i = 0; i <= n; i++)\n\t\t\t\tans = Math.min(ans, dp[r - 1][i]);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nnamespace Program\n{\n    public class Solver\n    {\n        public void Solve()\n        {\n\n            for (;;)\n            {\n                var n = ri;\n                var m = ri;\n                if (n == 0) return;\n                var g = Enumerate(n, x => new long[n]);\n                var h = Enumerate(n, x => new long[n]);\n                for (int i = 0; i < n; i++)\n                    for (int j = i + 1; j < n; j++)\n                        g[i][j] = g[j][i] = h[i][j] = h[j][i] = 1L << 60;\n                for (int i = 0; i < m; i++)\n                {\n                    var x = ri - 1;\n                    var y = ri - 1;\n                    var z = ri;\n                    if (rs == \"L\") g[x][y] = g[y][x] = Math.Min(g[x][y], z);\n                    else h[x][y] = h[y][x] = Math.Min(h[x][y], z);\n                }\n                for (int k = 0; k < n; k++)\n                    for (int i = 0; i < n; i++)\n                        for (int j = 0; j < n; j++)\n                        {\n                            g[i][j] = Math.Min(g[i][j], g[i][k] + g[k][j]);\n                            h[i][j] = Math.Min(h[i][j], h[i][k] + h[k][j]);\n                        }\n                m = ri;\n                var a = Enumerate(m, x => ri - 1);\n                var dp = Enumerate(n, x => 1L << 60);\n                dp[a[0]] = 0;\n                for (int i = 1; i < m; i++)\n                {\n                    var f = a[i - 1];\n                    var t = a[i];\n                    var next = Enumerate(n, x => 1L << 60);\n                    for (int j = 0; j < n; j++)\n                    {\n                        next[j] = Math.Min(next[j], dp[j] + g[f][t]);\n                        for (int k = 0; k < n; k++)\n                            next[k] = Math.Min(next[k], dp[j] + g[f][j] + h[j][k] + g[k][t]);\n                    }\n                    dp = next;\n                }\n                IO.Printer.Out.WriteLine(dp.Min());\n\n            }\n        }\n\n        const long INF = 1L << 60;\n        //int[] dx = { -1, 0, 1, 0 };\n        //int[] dy = { 0, 1, 0, -1 };\n        //*\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        //*/\n\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n        static T[] Enumerate<T>(int n, Func<int, T> f) { var a = new T[n]; for (int i = 0; i < n; ++i) a[i] = f(i); return a; }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex\n{\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \")\n    {\n        return string.Join(st, ie.Select(x => x.ToString()).ToArray());\n        //return string.Join(st, ie);\n    }\n    static public void Main()\n    {\n        var solver = new Program.Solver();\n        solver.Solve();\n        Program.IO.Printer.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO\n{\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n    public class Printer: StreamWriter\n    {\n        static Printer() { Out = new Printer(Console.OpenStandardOutput()) { AutoFlush = false }; }\n        public static Printer Out { get; set; }\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(System.IO.Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n        public Printer(System.IO.Stream stream, Encoding encoding) : base(stream, encoding) { }\n        public void Write<T>(string format, T[] source) { base.Write(format, source.OfType<object>().ToArray()); }\n        public void WriteLine<T>(string format, T[] source) { base.WriteLine(format, source.OfType<object>().ToArray()); }\n    }\n    public class StreamScanner\n    {\n        public StreamScanner(Stream stream) { str = stream; }\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n        private byte read()\n        {\n            if (isEof) return 0;\n            if (ptr >= len) { ptr = 0; if ((len = str.Read(buf, 0, 1024)) <= 0) { isEof = true; return 0; } }\n            return buf[ptr++];\n        }\n        public char Char() { byte b = 0; do b = read(); while ((b < 33 || 126 < b) && !isEof); return (char)b; }\n\n        public string Scan()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read())\n                sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine()\n        {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n'; b = (char)read())\n                if (b == 0) break;\n                else if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long()\n        {\n            if (isEof) return long.MinValue;\n            long ret = 0; byte b = 0; var ng = false;\n            do b = read();\n            while (b != 0 && b != '-' && (b < '0' || '9' < b));\n            if (b == 0) return long.MinValue;\n            if (b == '-') { ng = true; b = read(); }\n            for (; true; b = read())\n            {\n                if (b < '0' || '9' < b)\n                    return ng ? -ret : ret;\n                else ret = ret * 10 + b - '0';\n            }\n        }\n        public int Integer() { return (isEof) ? int.MinValue : (int)Long(); }\n        public double Double() { var s = Scan(); return s != \"\" ? double.Parse(s, CultureInfo.InvariantCulture) : double.NaN; }\n        private T[] enumerate<T>(int n, Func<T> f)\n        {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f();\n            return a;\n        }\n\n        public char[] Char(int n) { return enumerate(n, Char); }\n        public string[] Scan(int n) { return enumerate(n, Scan); }\n        public double[] Double(int n) { return enumerate(n, Double); }\n        public int[] Integer(int n) { return enumerate(n, Integer); }\n        public long[] Long(int n) { return enumerate(n, Long); }\n    }\n}\n#endregion\n\n#region DisjointSet\npublic class DisjointSet\n{\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n)\n    {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id]\n    {\n        get\n        {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y)\n    {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y])\n        {\n            par[y] += par[x];\n            par[x] = y;\n        }\n        else\n        {\n            par[x] += par[y];\n            par[y] = x;\n            if (rank[x] == rank[y])\n                rank[x]++;\n        }\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Enu = System.Linq.Enumerable;\n\nclass Program\n{\n    static readonly int INF = (int)1e8;\n    int N, M;\n\n    void Solve()\n    {\n        while ((N = reader.Int()) > 0)\n        {\n            M = reader.Int();\n            int[][] walk = Enu.Range(0, N).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            int[][] ship = Enu.Range(0, N).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            for (int i = 0; i < N; i++) walk[i][i] = ship[i][i] = 0;\n            var A = new[] { walk, ship };\n\n            for (int i = 0; i < M; i++)\n            {\n                int a = reader.Int() - 1, b = reader.Int() - 1, d = reader.Int();\n                var dist = A[\"LS\".IndexOf(reader.Char())];\n                dist[a][b] = Math.Min(dist[a][b], d);\n                dist[b][a] = Math.Min(dist[b][a], d);\n            }\n            WF(walk);\n            WF(ship);\n            reader.Line();\n            var Dest = reader.IntArray().Select(x => x - 1).ToArray();\n            var dp = Enu.Range(0, Dest.Length).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            dp[Dest[0]][Dest[0]] = 0;\n\n            for (int i = 1; i < Dest.Length; i++)\n            {\n                int a = Dest[i - 1], b = Dest[i];\n                for (int s = 0; s < N; s++)\n                {\n                    // walk\n                    dp[i][s] = Math.Min(dp[i][s], dp[i - 1][s] + walk[a][b]);\n\n                    // walk + ship + walk\n                    for (int nextS = 0; nextS < N; nextS++)\n                    {\n                        int currDist = dp[i - 1][s] + walk[a][s] + ship[s][nextS] + walk[nextS][b];\n                        dp[i][nextS] = Math.Min(dp[i][nextS], currDist);\n                    }\n                }\n            }\n            int ans = Enu.Range(0, N).Min(i => dp[N - 1][i]);\n            Console.WriteLine(ans);\n        }\n    }\n\n    void WF(int[][] dist)\n    {\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    dist[i][j] = Math.Min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n\n    static void Main() { new Program().Solve(); }\n    static Reader reader = new Reader(Console.In);\n    class Reader\n    {\n        private readonly TextReader reader;\n        private readonly char[] splitter = new char[] { ' ' };\n        private string[] s = new string[0];\n        private int i;\n        public Reader(TextReader r) { reader = r; }\n        public bool HasNext() { return Enqueue(); }\n        public string String() { return Dequeue(); }\n        public char Char() { return Dequeue()[0]; }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private bool Enqueue()\n        {\n            if (i < s.Length) return true;\n            string line = reader.ReadLine();\n            if (string.IsNullOrEmpty(line)) return false;\n            s = line.Split(splitter, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return true;\n        }\n        private string Dequeue() { Enqueue(); return s[i++]; }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Enu = System.Linq.Enumerable;\n\nclass Program\n{\n    static readonly int INF = (int)1e8;\n    int N, M;\n\n    void Solve()\n    {\n        while ((N = reader.Int()) > 0)\n        {\n            M = reader.Int();\n            int[][] walk = Enu.Range(0, N).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            int[][] ship = Enu.Range(0, N).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            for (int i = 0; i < N; i++) walk[i][i] = ship[i][i] = 0;\n            var A = new[] { walk, ship };\n\n            for (int i = 0; i < M; i++)\n            {\n                int a = reader.Int() - 1, b = reader.Int() - 1, d = reader.Int();\n                var dist = A[\"LS\".IndexOf(reader.Char())];\n                dist[a][b] = Math.Min(dist[a][b], d);\n                dist[b][a] = Math.Min(dist[b][a], d);\n            }\n            WF(walk);\n            WF(ship);\n            int D = reader.Int();\n            var Dest = reader.IntArray().Select(x => x - 1).ToArray();\n            var dp = Enu.Range(0, D).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            dp[0][Dest[0]] = 0;\n\n            for (int i = 1; i < D; i++)\n            {\n                int a = Dest[i - 1], b = Dest[i];\n                for (int s = 0; s < N; s++)\n                {\n                    // walk\n                    dp[i][s] = Math.Min(dp[i][s], dp[i - 1][s] + walk[a][b]);\n\n                    // walk + ship + walk\n                    for (int nextS = 0; nextS < N; nextS++)\n                    {\n                        int currDist = dp[i - 1][s] + walk[a][s] + ship[s][nextS] + walk[nextS][b];\n                        dp[i][nextS] = Math.Min(dp[i][nextS], currDist);\n                    }\n                }\n            }\n            int ans = Enu.Range(0, N).Min(i => dp[D - 1][i]);\n            Console.WriteLine(ans);\n        }\n    }\n\n    void WF(int[][] dist)\n    {\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    dist[i][j] = Math.Min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n\n    static void Main() { new Program().Solve(); }\n    static Reader reader = new Reader(Console.In);\n    class Reader\n    {\n        private readonly TextReader reader;\n        private readonly char[] splitter = new char[] { ' ' };\n        private string[] s = new string[0];\n        private int i;\n        public Reader(TextReader r) { reader = r; }\n        public bool HasNext() { return Enqueue(); }\n        public string String() { return Dequeue(); }\n        public char Char() { return Dequeue()[0]; }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private bool Enqueue()\n        {\n            if (i < s.Length) return true;\n            string line = reader.ReadLine();\n            if (string.IsNullOrEmpty(line)) return false;\n            s = line.Split(splitter, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return true;\n        }\n        private string Dequeue() { Enqueue(); return s[i++]; }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing Enu = System.Linq.Enumerable;\n\nclass Program\n{\n    static readonly int INF = (int)1e8;\n    int N, M;\n\n    void Solve()\n    {\n        while ((N = reader.Int()) > 0)\n        {\n            M = reader.Int();\n            int[][] walk = Enu.Range(0, N).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            int[][] ship = Enu.Range(0, N).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            for (int i = 0; i < N; i++) walk[i][i] = ship[i][i] = 0;\n            var A = new[] { walk, ship };\n\n            for (int i = 0; i < M; i++)\n            {\n                int a = reader.Int() - 1, b = reader.Int() - 1, d = reader.Int();\n                var dist = A[\"LS\".IndexOf(reader.Char())];\n                dist[a][b] = Math.Min(dist[a][b], d);\n                dist[b][a] = Math.Min(dist[b][a], d);\n            }\n            WF(walk);\n            WF(ship);\n            reader.Line();\n            var Dest = reader.IntArray().Select(x => x - 1).ToArray();\n            var dp = Enu.Range(0, Dest.Length).Select(i => Enu.Repeat(INF, N).ToArray()).ToArray();\n            dp[0][Dest[0]] = 0;\n\n            for (int i = 1; i < Dest.Length; i++)\n            {\n                int a = Dest[i - 1], b = Dest[i];\n                for (int s = 0; s < N; s++)\n                {\n                    // walk\n                    dp[i][s] = Math.Min(dp[i][s], dp[i - 1][s] + walk[a][b]);\n\n                    // walk + ship + walk\n                    for (int nextS = 0; nextS < N; nextS++)\n                    {\n                        int currDist = dp[i - 1][s] + walk[a][s] + ship[s][nextS] + walk[nextS][b];\n                        dp[i][nextS] = Math.Min(dp[i][nextS], currDist);\n                    }\n                }\n            }\n            int ans = Enu.Range(0, N).Min(i => dp[N - 1][i]);\n            Console.WriteLine(ans);\n        }\n    }\n\n    void WF(int[][] dist)\n    {\n        for (int k = 0; k < N; k++)\n            for (int i = 0; i < N; i++)\n                for (int j = 0; j < N; j++)\n                    dist[i][j] = Math.Min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n\n    static void Main() { new Program().Solve(); }\n    static Reader reader = new Reader(Console.In);\n    class Reader\n    {\n        private readonly TextReader reader;\n        private readonly char[] splitter = new char[] { ' ' };\n        private string[] s = new string[0];\n        private int i;\n        public Reader(TextReader r) { reader = r; }\n        public bool HasNext() { return Enqueue(); }\n        public string String() { return Dequeue(); }\n        public char Char() { return Dequeue()[0]; }\n        public int Int() { return int.Parse(Dequeue()); }\n        public long Long() { return long.Parse(Dequeue()); }\n        public double Double() { return double.Parse(Dequeue()); }\n        public int[] IntArray() { return Array.ConvertAll(Line().Split(), int.Parse); }\n        public int[][] IntGrid(int H) { return Enumerable.Range(0, H).Select(i => IntArray()).ToArray(); }\n        public string[] StringArray(int N) { return Enumerable.Range(0, N).Select(i => Line()).ToArray(); }\n        public string Line() { return reader.ReadLine().Trim(); }\n        private bool Enqueue()\n        {\n            if (i < s.Length) return true;\n            string line = reader.ReadLine();\n            if (string.IsNullOrEmpty(line)) return false;\n            s = line.Split(splitter, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return true;\n        }\n        private string Dequeue() { Enqueue(); return s[i++]; }\n    }\n}"
  },
  {
    "language": "Ruby",
    "code": "sleep 3"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(n, from, route, time)\n  arr = [from]\n  dist = [INF]*n\n  dist[from] = 0\n  until arr.empty?\n    a = arr.min{ |x, y| dist[x] <=> dist[y] }\n    arr.delete(a)\n    route[a].each do |b|\n      d = dist[a] + time[a][b]\n      if (old = dist[b]) > d\n        dist[b] = d\n        if old == INF\n          arr << b \n        end\n      end\n    end\n  end\n  dist\nend\n \nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  route_l = n.times.map{ [] }\n  time_l = n.times.map{ [] }\n  route_s = n.times.map{ [] }\n  time_s = n.times.map{ [] }\n  m.times do\n    tmp = gets.split\n    x, y, t = tmp[0,3].map(&:to_i)\n    x -= 1; y -= 1\n    if tmp[-1] == \"L\"\n      route_l[x] << y; route_l[y] << x\n      time_l[x][y] = time_l[y][x] = t\n    else\n      route_s[x] << y; route_s[y] << x\n      time_s[x][y] = time_s[y][x] = t\n    end\n  end\n  l_time = n.times.map{ |i| dijkstra(n, i, route_l, time_l) }\n  s_time = n.times.map{ |i| dijkstra(n, i, route_s, time_s) }.map{|a| a.map.with_index{|x, i| [x, i] }.sort}\n  gets  \n  dest = gets.split.map(&:to_i).map{ |i| i-1 }\n  bpos = [INF]*n\n  bpos[dest[0]] = 0\n  dest.each_cons(2) do |s, t|\n    new_bpos = [INF]*n\n    n.times do |nxt|\n      min_t = bpos[nxt] + l_time[s][t]\n      s_time[nxt].each do |x, pre|\n        break if x + l_time[nxt][t] >= min_t\n        time = bpos[pre] + l_time[s][pre] + x + l_time[nxt][t]\n        min_t = [min_t, time].min\n      end\n      new_bpos[nxt] = min_t\n    end\n    bpos = new_bpos\n  end\n  p bpos.min\nend"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\t(0..n-1).each{|k|\n\t\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist[i][j]\n\t\t\t\ty = dist[i][k] + dist[k][j]\n\t\t\t\tnext_dist[i][j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\n\tland_dist = (1..n).map { [Float::INFINITY] * n }\n\tsea_dist = (1..n).map { [Float::INFINITY] * n }\n\t(0..n-1).each{|i| land_dist[i][i] = sea_dist[i][i] = 0}\n\n\tm.times {\n\t\ti, j, d, t = gets.chomp.split\n\t\ti = i.to_i-1\n\t\tj = j.to_i-1\n\t\td = d.to_i\n\t\tif t == ?L\n\t\t\tland_dist[i][j] = d\n\t\t\tland_dist[j][i] = d\n\t\telse\n\t\t\tsea_dist[i][j] = d\n\t\t\tsea_dist[j][i] = d\n\t\tend\n\t}\n\tland_dist = warshall_floyd(land_dist)\n\tsea_dist = warshall_floyd(sea_dist).map{|a| a.map.with_index{|x, i| [i, x] }.sort_by(&:last)}\n\n\tgets\n\treqs = gets.split.map(&:to_i).map{|x| x - 1}\n\ttable = (0..1).map{ [Float::INFINITY] * n }\n\ttable[0][reqs[0]] = 0\n\t(1..reqs.size-1).each{|i|\n\t\t(0..n-1).each{|next_boat_pos|\n\t\t\tmin = table[0][next_boat_pos] + land_dist[reqs[i-1]][reqs[i]]\n\t\t\tbase = land_dist[next_boat_pos][reqs[i]]\n\t\t\tsea_dist[next_boat_pos].each{|prev_boat_pos, x|\n\t\t\t\tbreak if x + base >= min\n\t\t\t\td = table[0][prev_boat_pos] + \n\t\t\t\t    land_dist[reqs[i-1]][prev_boat_pos] + \n\t\t\t\t    x + base\n\t\t\t\tmin = d if d < min\n\t\t\t}\n\t\t\ttable[1][next_boat_pos] = min\n\t\t}\n\t\ttable << table.shift\n\t}\n\tp table[0].min\n}"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\t(0..n-1).each{|k|\n\t\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist[i][j]\n\t\t\t\ty = dist[i][k] + dist[k][j]\n\t\t\t\tnext_dist[i][j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\n\tland_dist = (1..n).map { [Float::INFINITY] * n }\n\tsea_dist = (1..n).map { [Float::INFINITY] * n }\n\t(0..n-1).each{|i| land_dist[i][i] = sea_dist[i][i] = 0}\n\n\tm.times {\n\t\ti, j, d, t = gets.chomp.split\n\t\ti = i.to_i-1\n\t\tj = j.to_i-1\n\t\td = d.to_i\n\t\tif t == ?L\n\t\t\tland_dist[i][j] = d\n\t\t\tland_dist[j][i] = d\n\t\telse\n\t\t\tsea_dist[i][j] = d\n\t\t\tsea_dist[j][i] = d\n\t\tend\n\t}\n\tland_dist = warshall_floyd(land_dist)\n\tsea_dist = warshall_floyd(sea_dist)\n\n\tgets\n\treqs = gets.split.map(&:to_i).map{|x| x - 1}\n\ttable = (0..1).map{ [Float::INFINITY] * n }\n\ttable[0][reqs[0]] = 0\n\t(1..reqs.size-1).each{|i|\n\t\t(0..n-1).each{|next_boat_pos|\n\t\t\ttable[1][next_boat_pos] = Float::INFINITY\n\t\t\t(0..n-1).each{|prev_boat_pos|\n\t\t\t\td = nil\n\t\t\t\tif next_boat_pos == prev_boat_pos\n\t\t\t\t\td = table[0][prev_boat_pos] + \n\t\t\t\t        land_dist[reqs[i-1]][reqs[i]]\n\t\t\t\telse\n\t\t\t\t\td = table[0][prev_boat_pos] + \n\t\t\t\t        land_dist[reqs[i-1]][prev_boat_pos] + \n\t\t\t\t        sea_dist[prev_boat_pos][next_boat_pos] +\n\t\t\t\t        land_dist[next_boat_pos][reqs[i]]\n\t\t\t\tend\n\t\t\t\ttable[1][next_boat_pos] = d if d < table[1][next_boat_pos]\n\t\t\t}\n\t\t}\n\t\ttable << table.shift\n\t}\n\tp table[0].min\n}"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(n, from, route, time)\n  arr = [from]\n  dist = [INF]*n\n  dist[from] = 0\n  until arr.empty?\n    a = arr.min{ |x, y| dist[x] <=> dist[y] }\n    arr.delete(a)\n    route[a].each do |b|\n      d = dist[a] + time[a][b]\n      if (old = dist[b]) > d\n        dist[b] = d\n        if old == INF\n          arr << b \n        end\n      end\n    end\n  end\n  dist\nend\n \nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  route_l = n.times.map{ [] }\n  time_l = n.times.map{ [] }\n  route_s = n.times.map{ [] }\n  time_s = n.times.map{ [] }\n  m.times do\n    tmp = gets.split\n    x, y, t = tmp[0,3].map(&:to_i)\n    x -= 1; y -= 1\n    if tmp[-1] == \"L\"\n      route_l[x] << y; route_l[y] << x\n      time_l[x][y] = time_l[y][x] = t\n    else\n      route_s[x] << y; route_s[y] << x\n      time_s[x][y] = time_s[y][x] = t\n    end\n  end\n  l_time = n.times.map{ |i| dijkstra(n, i, route_l, time_l) }\n  s_time = n.times.map{ |i| dijkstra(n, i, route_s, time_s) }\n  gets  \n  dest = gets.split.map(&:to_i).map{ |i| i-1 }\n  bpos = [INF]*n\n  bpos[dest[0]] = 0\n  dest.each_cons(2) do |s, t|\n    new_bpos = [INF]*n\n    n.times do |nxt|\n      min_t = bpos[nxt] + l_time[s][t]\n      n.times do |pre|\n        time = bpos[pre] + l_time[s][pre] + s_time[pre][nxt] + l_time[nxt][t]\n        min_t = time if time < min_t\n      end\n      new_bpos[nxt] = min_t\n    end\n    bpos = new_bpos\n  end\n  p bpos.min\nend"
  },
  {
    "language": "Ruby",
    "code": "sleep 100"
  },
  {
    "language": "Ruby",
    "code": "def warshall_floyd(dist_matrix)\n\tdist = dist_matrix\n\tn = dist.size\n\traise \"dist_matrix is not square\" if dist.any?{|row| row.size != n}\n\n\t(0..n-1).each{|k|\n\t\tnext_dist = (1..n).map{ Array.new(n) }\t\n\t\t(0..n-1).each{|i|\n\t\t\t(0..n-1).each{|j|\n\t\t\t\tx = dist[i][j]\n\t\t\t\ty = dist[i][k] + dist[k][j]\n\t\t\t\tnext_dist[i][j] = (x < y ? x : y)\n\t\t\t}\n\t\t}\n\t\tdist = next_dist\n\t}\n\tdist\nend\n\nloop {\n\tn, m = gets.split.map &:to_i\n\tbreak if n == 0\n\n\tland_dist = (1..n).map { [Float::INFINITY] * n }\n\tsea_dist = (1..n).map { [Float::INFINITY] * n }\n\t(0..n-1).each{|i| land_dist[i][i] = sea_dist[i][i] = 0}\n\n\tm.times {\n\t\ti, j, d, t = gets.chomp.split\n\t\ti = i.to_i-1\n\t\tj = j.to_i-1\n\t\td = d.to_i\n\t\tif t == ?L\n\t\t\tland_dist[i][j] = d\n\t\t\tland_dist[j][i] = d\n\t\telse\n\t\t\tsea_dist[i][j] = d\n\t\t\tsea_dist[j][i] = d\n\t\tend\n\t}\n\tland_dist = warshall_floyd(land_dist)\n\tsea_dist = warshall_floyd(sea_dist)\n\n\tgets\n\treqs = gets.split.map(&:to_i).map{|x| x - 1}\n\ttable = (0..1).map{ [Float::INFINITY] * n }\n\ttable[0][reqs[0]] = 0\n\t(1..m-1).each{|i|\n\t\t(0..n-1).each{|next_boat_pos|\n\t\t\ttable[1][next_boat_pos] = Float::INFINITY\n\t\t\t(0..n-1).each{|prev_boat_pos|\n\t\t\t\td = nil\n\t\t\t\tif next_boat_pos == prev_boat_pos\n\t\t\t\t\td = table[0][prev_boat_pos] + \n\t\t\t\t        land_dist[reqs[i-1]][reqs[i]]\n\t\t\t\telse\n\t\t\t\t\td = table[0][prev_boat_pos] + \n\t\t\t\t        land_dist[reqs[i-1]][prev_boat_pos] + \n\t\t\t\t        sea_dist[prev_boat_pos][next_boat_pos] +\n\t\t\t\t        land_dist[next_boat_pos][reqs[i]]\n\t\t\t\tend\n\t\t\t\ttable[1][next_boat_pos] = d if d < table[1][next_boat_pos]\n\t\t\t}\n\t\t}\n\t\t#p table[1]\n\t\ttable << table.shift\n\t}\n\tp table[0].min\n}"
  },
  {
    "language": "Ruby",
    "code": "10000000.times do |i| puts i end"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(n, from, route, time)\n  arr = [from]\n  dist = [INF]*n\n  dist[from] = 0\n  until arr.empty?\n    a = arr.min{ |x, y| dist[x] <=> dist[y] }\n    arr.delete(a)\n    route[a].each do |b|\n      d = dist[a] + time[a][b]\n      if (old = dist[b]) > d\n        dist[b] = d\n        if old == INF\n          arr << b \n        end\n      end\n    end\n  end\n  dist\nend\n \nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  route_l = n.times.map{ [] }\n  time_l = n.times.map{ [] }\n  route_s = n.times.map{ [] }\n  time_s = n.times.map{ [] }\n  m.times do\n    tmp = gets.split\n    x, y, t = tmp[0,3].map(&:to_i)\n    x -= 1; y -= 1\n    if tmp[-1] == \"L\"\n      route_l[x] << y; route_l[y] << x\n      time_l[x][y] = time_l[y][x] = t\n    else\n      route_s[x] << y; route_s[y] << x\n      time_s[x][y] = time_s[y][x] = t\n    end\n  end\n  l_time = n.times.map{ |i| dijkstra(n, i, route_l, time_l) }\n  s_time = n.times.map{ |i| dijkstra(n, i, route_s, time_s) }.map{|a| a.map.with_index{|x, i| [x, i] }.sort}\n  gets  \n  dest = gets.split.map(&:to_i).map{ |i| i-1 }\n  bpos = [INF]*n\n  bpos[dest[0]] = 0\n  dest.each_cons(2) do |s, t|\n    new_bpos = [INF]*n\n    n.times do |nxt|\n      min_t = bpos[nxt] + l_time[s][t]\n      s_time[nxt].each do |x, pre|\n        break if x + l_time[nxt][t] >= min_t\n        time = bpos[pre] + l_time[s][pre] + x + l_time[nxt][t]\n        min_t = time if time < min_t\n      end\n      new_bpos[nxt] = min_t\n    end\n    bpos = new_bpos\n  end\n  p bpos.min\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 1<<29\ndef dijkstra(n, from, route, cost)\n  arr = [from]\n  dist = [INF]*n\n  dist[from] = 0\n  until arr.empty?\n    a = arr.min{ |x, y| dist[x] <=> dist[y] }\n    arr.delete(a)\n    route[a].each do |b|\n      d = dist[a] + cost[a][b]\n      if (old = dist[b]) > d\n        dist[b] = d\n        if old == INF\n          arr << b \n        end\n      end\n    end\n  end\n  dist\nend\n \nloop do\n  n, m = gets.split.map(&:to_i)\n  break if n == 0\n  route_l = n.times.map{ [] }\n  cost_l = n.times.map{ [] }\n  route_s = n.times.map{ [] }\n  cost_s = n.times.map{ [] }\n  m.times do\n    tmp = gets.split\n    x, y, t = tmp[0,3].map(&:to_i)\n    x -= 1; y -= 1\n    if tmp[-1] == \"L\"\n      route_l[x] << y; route_l[y] << x\n      cost_l[x][y] = cost_l[y][x] = t\n    else\n      route_s[x] << y; route_s[y] << x\n      cost_s[x][y] = cost_s[y][x] = t\n    end\n  end\n  l_time = n.times.map{ |i| dijkstra(n, i, route_l, cost_l) }\n  s_time = n.times.map{ |i| dijkstra(n, i, route_s, cost_s) }\n  gets  \n  dest = gets.split.map(&:to_i).map{ |i| i-1 }\n  bpos = [INF]*n\n  bpos[dest[0]] = 0\n  dest.each_cons(2) do |s, t|\n    new_bpos = [INF]*n\n    n.times do |nxt|\n      min_t = bpos[nxt] + l_time[s][t]\n      n.times do |pre|\n        time = bpos[pre] + l_time[s][pre] + s_time[pre][nxt] + l_time[nxt][t]\n        min_t = [min_t, time].min\n      end\n      new_bpos[nxt] = min_t\n    end\n    bpos = new_bpos\n  end\n  p bpos.min\nend"
  },
  {
    "language": "Ruby",
    "code": "100000000.times do end"
  },
  {
    "language": "Ruby",
    "code": "sleep 10"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.algorithm;\n\nvoid main() {\n\twhile(true) {\n\t\tauto NM = readln().split();\n\t\tint N = to!int(NM[0]);\n\t\tint M = to!int(NM[1]);\n\t\tif(N == 0)\n\t\t\tbreak;\n\t\tconst int INF = 200*1000*1000*2;\n\t\tint[200][200] ldist;\n\t\tint[200][200] sdist;\n\t\tfor(int i; i < N; ++i){\n\t\t\tfor(int j; j < N; ++j) {\n\t\t\t\tif(i == j) {\n\t\t\t\t\tldist[i][j] = sdist[i][j] = 0;\n\t\t\t\t} else {\n\t\t\t\t\tldist[i][j] = sdist[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i; i < M; ++i) {\n\t\t\tauto s = readln().split();\n\t\t\tint x = to!int(s[0])-1;\n\t\t\tint y = to!int(s[1])-1;\n\t\t\tint t = to!int(s[2]);\n\t\t\tauto sl = s[3];\n\t\t\tif(sl == \"L\") {\n\t\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t);\n\t\t\t} else {\n\t\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t);\n\t\t\t}\n\t\t}\n\t\tfor(int k; k < N; ++k){\n\t\t\tfor(int i; i < N; ++i){\n\t\t\t\tfor(int j; j < N; ++j){\n\t\t\t\t\tldist[i][j] = min(ldist[i][k] + ldist[k][j], ldist[i][j]);\n\t\t\t\t\tsdist[i][j] = min(sdist[i][k] + sdist[k][j], sdist[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint R = to!int(readln().chomp());\n\t\tauto sz = readln().chomp().split();\n\t\tint[1000] z;\n\t\tfor(int i; i < R; ++i){\n\t\t\tz[i] = to!int(sz[i])-1;\n\t\t}\n\n\t\tlong[200][1000] dp;\n\t\tfor(int i; i < R; ++i){\n\t\t\tfor(int j; j < N; ++j){\n\t\t\t\tdp[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tdp[0][z[0]] = 0;\n\t\tfor(int i = 1; i < R; ++i){\n\t\t\tfor(int j = 0; j < N; ++j){\n\t\t\t\tfor(int k = 0; k < N; ++k){\n\t\t\t\t\tif(j == k) {\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][j] + ldist[z[i-1]][z[i]]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdp[i][j] = min(dp[i][j], dp[i-1][k] + ldist[z[i-1]][k] + sdist[k][j] + ldist[j][z[i]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong ans = dp[R-1][0];\n\t\tfor(int i; i < N; ++i) {\n\t\t\tans = min(ans, dp[R-1][i]);\n\t\t}\n\t\twriteln(ans);\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "# # AOJ 2200\n#\n# INF = float('inf')\n#\n#\n# def floyd_warshall(d):\n#     v = len(d)\n#     for k in range(v):\n#         dk = d[k]\n#         for i in range(v):\n#             di = d[i]\n#             for j in range(v):\n#                 di[j] = min(di[j], di[k] + dk[j])\n#\n#\n# def main():\n#     while True:\n#         N, M = map(int, input().split())\n#         if N == M == 0:\n#             break\n#\n#         sea = [[INF] * N for i in range(N)]\n#         land = [[INF] * N for i in range(N)]\n#         for i in range(N):\n#             sea[i][i] = land[i][i] = 0\n#\n#         for i in range(M):\n#             x, y, t, sl = input().split()\n#             x = int(x) - 1\n#             y = int(y) - 1\n#             t = int(t)\n#             if sl == 'S':\n#                 sea[x][y] = sea[y][x] = min(sea[x][y], t)\n#             else:\n#                 land[x][y] = land[y][x] = min(land[x][y], t)\n#\n#         R = int(input())\n#         z = list(map(lambda x: int(x) - 1, input().split()))\n#\n#         floyd_warshall(sea)\n#         floyd_warshall(land)\n#\n#         dp = [INF] * N\n#         dp[z[0]] = 0\n#         for k in range(1, R):\n#             ndp = [INF] * N\n#             z1 = z[k-1]\n#             z2 = z[k]\n#             land_z1 = land[z1]\n#             land_z2 = land[z2]\n#             land_z1_z2 = land_z1[z2]\n#\n#             for i in range(N):\n#                 tmp = dp[i] + land_z1_z2\n#                 land_i_z2 = land_z2[i]\n#                 sea_i = sea[i]\n#\n#                 for j in range(N):\n#                     # ship originally at j\n#                     # z1 -> (land) -> j -> (sea) -> i -> (land) -> z2\n#                     tmp = min(tmp, dp[j] + land_z1[j] + sea_i[j] + land_i_z2)\n#\n#                 ndp[i] = tmp\n#             dp = ndp\n#         print(min(dp))\n#\n#\n# if __name__ == '__main__':\n#     main()\n\ninf = float(\"INF\")\n\nclass Warshall_Floyd:\n\n    def __init__(self, n, dist):\n        self.dist = dist\n        self.n = n\n\n    def search(self):\n        n = self.n\n        dist = self.dist\n        for i in range(n):\n            dist[i][i] = 0\n\n        for i in range(n):\n            di = dist[i]\n            for j in range(n):\n                dj = dist[j]\n                if i == j:\n                    continue\n                for k in range(n):\n                    if dj[k] > dj[i] + di[k]:\n                        dj[k] = dj[i] + di[k]\n\n        return dist\n\nimport sys\n\n\ndef main(n, m):\n    dps = [[inf] * n for i in range(n)]\n    dpl = [[inf] * n for i in range(n)]\n\n    for _ in range(m):\n        x, y, t, sl = input().split()\n        x, y, t = map(lambda x: int(x) - 1, [x, y, t])\n        t += 1\n        if sl == \"S\":\n            dps[x][y] = t\n            dps[y][x] = t\n        if sl == \"L\":\n            dpl[x][y] = t\n            dpl[y][x] = t\n\n    l = Warshall_Floyd(n, dpl)\n    s = Warshall_Floyd(n, dps)\n    dpl = l.search()\n    dps = s.search()\n\n    r = int(input())\n    v = list(map(lambda x: int(x) - 1, input().split()))\n    dp1 = [inf] * n\n    dp1[v[0]] = 0\n\n    for i in range(r-1):\n        b = v[i]\n        c = v[i + 1]\n        dp2 = [0] * n\n        dplb = dpl[b]\n        dpk = [dp1[k] + dplb[k] for k in range(n)]\n\n        for j in range(n):\n            # 陸路のみ\n            # 船の位置は変わらず\n            dp2[j] = dp1[j] + dplb[c]\n\n            dpljc = dpl[j][c]\n            dpsj = dps[j]\n            tmp = dp2[j]\n\n            for k in range(n):\n                # 海路あり\n                # kに船があるとき\n                # v[i-1]→(陸路)→k→(海路)→j→(陸路)→v[i]\n                # この時船はjに保管される\n                tmp1 = dpk[k] + dpsj[k] + dpljc\n                if tmp > tmp1:\n                    tmp = tmp1\n\n            dp2[j] = tmp\n\n        dp1 = dp2\n\n    print(min(dp1))\n\n\nwhile 1:\n    n, m = map(int, input().split())\n    if n == m == 0:\n        break\n    main(n, m)\n\n"
  },
  {
    "language": "Python",
    "code": "inf = 10**9\ndp = [[inf] * 210 for i in range(210)]\nldist = [[inf] * 210 for i in range(210)]\nsdist = [[inf] * 210 for i in range(210)]\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0:\n        break\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                ldist[i][j] = sdist[i][j] = 0\n            else:\n                ldist[i][j] = sdist[i][j] = inf\n    for i in range(m):\n        x, y, t, sl = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        t = int(t)\n        if sl == 'L':\n            ldist[x][y] = ldist[y][x] = min(ldist[x][y], t)\n        elif sl == 'S':\n            sdist[x][y] = sdist[y][x] = min(sdist[x][y], t)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                ldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j])\n                sdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j])\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = 0 if i == j else inf\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i])\n    r = int(input())\n    z = list(map(int, input().split()))\n    for i in range(r):\n        z[i] -= 1\n    for i in range(n):\n        if i != z[0]:\n            for j in range(n):\n                dp[i][j] = inf\n    for i in range(1, r):\n        for j in range(n):\n            for k in range(n):\n                if j != z[i - 1]:\n                    dp[j][k] = min(dp[j][k], dp[z[i - 1]]\n                                   [k] + ldist[z[i - 1]][j])\n        for j in range(n):\n            for k in range(n):\n                dp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k])\n        for j in range(n):\n            for k in range(n):\n                if j != k:\n                    dp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j])\n        for j in range(n):\n            if j != z[i]:\n                for k in range(n):\n                    dp[j][k] = inf\n    ret = inf\n    for i in range(n):\n        ret = min(ret, dp[z[r - 1]][i])\n    print(ret)"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [N,M]=[int(x) for x in raw_input().split()]\n    if N==0:\n        break\n    else:\n        landr=[[99999999 for x in range(N+1)] for y in range(N+1)]\n        sear=[[99999999 for x in range(N+1)] for y in range(N+1)]\n        islandname1=[i for i in range(N+1)] #ex.[0,0,2,3,3]\n        islandname2=[[i] for i in range(N+1)] #ex.[[0,1],[],[2],[3,4],[]]\n        for i in range(1,N+1):\n            landr[i][i]=0\n            sear[i][i]=0\n        for i in range(M):\n            dd=raw_input().split()\n            [a,b]=sorted([int(x) for x in dd[:2]])\n            d=int(dd[2])\n            t=dd[3]\n            if t=='S':\n                if sear[a][b]>d:\n                    sear[a][b]=d\n                    sear[b][a]=d\n            else:\n                if landr[a][b]>d:\n                    landr[a][b]=d\n                    landr[b][a]=d\n                #check if same island\n                if islandname1[a]!=islandname1[b]: #a<b\n                    islandnameold=islandname1[b]\n                    for port in islandname2[islandname1[b]]:\n                        islandname1[port]=islandname1[a]\n                    islandname2[islandname1[a]].extend(islandname2[islandnameold])\n        #floyd algorhythm\n        for k in range(1,N+1):\n            for i in range(1,N+1):\n               for j in range(i,N+1):\n                   if landr[i][j]>landr[i][k]+landr[k][j]:\n                       landr[i][j]=landr[i][k]+landr[k][j]\n                       landr[j][i]=landr[i][k]+landr[k][j]\n                   if sear[i][j]>sear[i][k]+sear[k][j]:\n                       sear[i][j]=sear[i][k]+sear[k][j]\n                       sear[j][i]=sear[i][k]+sear[k][j]\n        R=int(raw_input())\n        dest=[int(x) for x in raw_input().split()]\n        loc=dest[0]\n        portold=[[dest[0],0]]\n        for i in range(R-1):\n            portnew=[]\n            newloc=dest[i+1]\n            newport_temp=islandname2[islandname1[newloc]]\n            for np in newport_temp:\n                mintime=999999999\n                for opc in portold:\n                    op=opc[0]\n                    opt=opc[1]\n                    mintime=min(mintime,opt+landr[loc][op]+sear[op][np]+landr[np][newloc])\n                portnew.append([np,mintime])\n            portold=portnew\n            loc=dest[i+1]\n            i=i+1\n        ans=sorted(portold,key=lambda x:x[1])\n        print ans[0][1]"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nimport sys, operator\nINF = 10**18\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    N, M = map(int, readline().split())\n    if N == M == 0:\n        return False\n    def dijkstra(N, s, G):\n        dist = [INF]*N\n        dist[s] = 0\n        que = [(0, s)]\n        while que:\n            cost, v = heappop(que)\n            if dist[v] < cost:\n                continue\n            for w, d in G[v]:\n                if cost + d < dist[w]:\n                    dist[w] = r = cost + d\n                    heappush(que, (r, w))\n        return dist\n    rN = range(N)\n    GL = [[] for i in rN]\n    GS = [[] for i in rN]\n    for i in range(M):\n        x, y, t, sl = readline().split()\n        x = int(x)-1; y = int(y)-1; t = int(t)\n        if sl == 'L':\n            GL[x].append((y, t))\n            GL[y].append((x, t))\n        else:\n            GS[x].append((y, t))\n            GS[y].append((x, t))\n    EL = [dijkstra(N, i, GL) for i in rN]\n    ES = [dijkstra(N, i, GS) for i in rN]\n\n    R = int(readline())\n    *Z, = map(int, readline().split())\n    iv = [INF]*N\n    S = [INF]*N; T = [0]*N\n    D = [0]*N\n    prv = Z[0]-1\n    S[prv] = 0\n    oadd = operator.add\n    for z in Z[1:]:\n        z -= 1\n        A = EL[prv]; B = EL[z]\n        v = A[z]\n        D[:] = map(oadd, S, A)\n        for j in rN:\n            C = ES[j]\n            b = B[j]\n            T[j] = min(S[j] + v, min(map(oadd, D, C)) + b)\n        S, T = T, S\n        prv = z\n    write(\"%d\\n\" % min(S))\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "inf = 10**9\ndp = [[inf] * 200 for i in range(200)]\nldist = [[inf] * 200 for i in range(200)]\nsdist = [[inf] * 200 for i in range(200)]\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0:\n        break\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                ldist[i][j] = sdist[i][j] = 0\n            else:\n                ldist[i][j] = sdist[i][j] = inf\n    for i in range(m):\n        x, y, t, sl = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        t = int(t)\n        if sl == 'L':\n            ldist[x][y] = ldist[y][x] = min(ldist[x][y], t)\n        elif sl == 'S':\n            sdist[x][y] = sdist[y][x] = min(sdist[x][y], t)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                ldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j])\n                sdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j])\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = 0 if i == j else inf\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i])\n    r = int(input())\n    z = list(map(int, input().split()))\n    for i in range(n):\n        z[i] -= 1\n    for i in range(n):\n        if i != z[0]:\n            for j in range(n):\n                dp[i][j] = inf\n    for i in range(1, r):\n        for j in range(n):\n            for k in range(n):\n                if j != z[i - 1]:\n                    dp[j][k] = min(dp[j][k], dp[z[i - 1]][k] + ldist[z[i - 1]][j])\n        for j in range(n):\n            for k in range(n):\n                dp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k])\n        for j in range(n):\n            for k in range(n):\n                if j != k:\n                    dp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j])\n        for j in range(n):\n            if j != z[i]:\n                for k in range(n):\n                    dp[j][k] = inf\n    ret = inf\n    for i in range(n):\n        ret = min(ret, dp[z[r - 1]][i])\n    print(ret)"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass WarshallFloyd():\n    def __init__(self, e, n):\n        self.E = e\n        self.N = n\n\n    def search(self):\n        n = self.N\n        nl = list(range(n))\n        d = [[inf] * n for _ in nl]\n        for i in range(n):\n            d[i][i] = 0\n        for k,v in self.E.items():\n            dk = d[k]\n            for b,c in v:\n                # consider multiple edges\n                if dk[b] > c:\n                    dk[b] = c\n        for i in nl:\n            di = d[i]\n            for j in nl:\n                if i == j:\n                    continue\n                dj = d[j]\n                for k in nl:\n                    if i != k and j != k and dj[k] > dj[i] + di[k]:\n                        dj[k] = dj[i] + di[k]\n        return d\n\n\ndef main():\n    rr = []\n\n    def f(n,m):\n        le = collections.defaultdict(list)\n        se = collections.defaultdict(list)\n        for _ in range(m):\n            l = LS()\n            a,b,t = map(int, l[:-1])\n            a -= 1\n            b -= 1\n            if l[-1] == 'S':\n                se[a].append((b,t))\n                se[b].append((a,t))\n            else:\n                le[a].append((b,t))\n                le[b].append((a,t))\n        q = I()\n        qa = LI_()\n        lw = WarshallFloyd(le, n)\n        sw = WarshallFloyd(se, n)\n        ld = lw.search()\n        sd = sw.search()\n        dp = [inf] * n\n        dp[qa[0]] = 0\n        # print('ld')\n        # print('\\n'.join('\\t'.join(map(lambda x: '-' if x == inf else str(x), c)) for c in ld))\n        # print('sd')\n        # print('\\n'.join('\\t'.join(map(lambda x: '-' if x == inf else str(x), c)) for c in sd))\n        for i in range(q-1):\n            c = qa[i]\n            ne = qa[i+1]\n            lp = [inf] * n\n            np = [inf] * n\n            for j in range(n):\n                np[j] = dp[j] + ld[c][ne]\n                dj = dp[j] + ld[c][j]\n                sdj = sd[j]\n                for k in range(n):\n                    if lp[k] > dj + sdj[k]:\n                        lp[k] = dj + sdj[k]\n            for j in range(n):\n                if np[j] > lp[j] + ld[j][ne]:\n                    np[j] = lp[j] + ld[j][ne]\n            # print('cne', c, ne)\n            # print('dp', dp)\n            # print('lp', lp)\n            dp = np\n\n        # print('edp', dp)\n        return min(dp)\n\n    while 1:\n        n,m = LI()\n        if n == 0 and m == 0:\n            break\n        rr.append(f(n,m))\n        # print('rr', rr[-1])\n\n    return '\\n'.join(map(str,rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "inf = 10**9\ndp = [[inf] * 210 for i in range(210)]\nldist = [[inf] * 210 for i in range(210)]\nsdist = [[inf] * 210 for i in range(210)]\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0:\n\t\tbreak\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif i == j:\n\t\t\t\tldist[i][j] = sdist[i][j] = 0\n\t\t\telse:\n\t\t\t\tldist[i][j] = sdist[i][j] = inf\n\tfor i in range(m):\n\t\tx, y, t, sl = input().split()\n\t\tx = int(x) - 1\n\t\ty = int(y) - 1\n\t\tt = int(t)\n\t\tif sl == 'L':\n\t\t\tldist[x][y] = ldist[y][x] = min(ldist[x][y], t)\n\t\telif sl == 'S':\n\t\t\tsdist[x][y] = sdist[y][x] = min(sdist[x][y], t)\n\tfor k in range(n):\n\t\tfor i in range(n):\n\t\t\tfor j in range(n):\n\t\t\t\tldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j])\n\t\t\t\tsdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j])\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tdp[i][j] = 0 if i == j else inf\n\tfor i in range(n):\n\t\tfor j in range(n):\n\t\t\tif i != j:\n\t\t\t\tdp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i])\n\tr = int(input())\n\tz = list(map(int, input().split()))\n\tfor i in range(r):\n\t\tz[i] -= 1\n\tfor i in range(n):\n\t\tif i != z[0]:\n\t\t\tfor j in range(n):\n\t\t\t\tdp[i][j] = inf\n\tfor i in range(1, r):\n\t\tfor j in range(n):\n\t\t\tfor k in range(n):\n\t\t\t\tif j != z[i - 1]:\n\t\t\t\t\tdp[j][k] = min(dp[j][k], dp[z[i - 1]]\n\t\t\t\t\t\t\t\t\t\t\t   [k] + ldist[z[i - 1]][j])\n\t\tfor j in range(n):\n\t\t\tfor k in range(n):\n\t\t\t\tdp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k])\n\t\tfor j in range(n):\n\t\t\tfor k in range(n):\n\t\t\t\tif j != k:\n\t\t\t\t\tdp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j])\n\t\tfor j in range(n):\n\t\t\tif j != z[i]:\n\t\t\t\tfor k in range(n):\n\t\t\t\t\tdp[j][k] = inf\n\tret = inf\n\tfor i in range(n):\n\t\tret = min(ret, dp[z[r - 1]][i])\n\tprint(ret)"
  },
  {
    "language": "Python",
    "code": "from queue import PriorityQueue\ninf = 10**9\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0:\n        break\n    edgel = [[] for i in range(n)]\n    edges = [[] for i in range(n)]\n    for i in range(m):\n        x, y, t, sl = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        t = int(t)\n        if sl == 'L':\n            edgel[x].append([y, t])\n            edgel[y].append([x, t])\n        else:\n            edges[x].append([y, t])\n            edges[y].append([x, t])\n    r = int(input())\n    z = list(map(int, input().split()))\n    for i in range(r):\n        z[i] -= 1\n    dp = [[[inf] * n for i in range(n)] for j in range(r)]\n    dp[0][z[0]][z[0]] = 0\n    for i in range(1, r):\n        pq = PriorityQueue()\n        for j in range(n):\n            if dp[i - 1][z[i - 1]][j] != inf:\n                pq.put([-dp[i - 1][z[i - 1]][j], z[i - 1], j])\n                dp[i][z[i - 1]][j] = dp[i - 1][z[i - 1]][j]\n        while not pq.empty():\n            d, pos, f = pq.get()\n            d *= -1\n            if d > dp[i][pos][f]:\n                continue\n            for j in range(len(edgel[pos])):\n                to, add = edgel[pos][j]\n                if dp[i][to][f] > dp[i][pos][f] + add:\n                    dp[i][to][f] = dp[i][pos][f] + add\n                    pq.put([-dp[i][to][f], to, f])\n            if pos == f:\n                for j in range(len(edges[pos])):\n                    to, add = edges[pos][j]\n                    if dp[i][to][to] > dp[i][pos][f] + add:\n                        dp[i][to][to] = dp[i][pos][f] + add\n                        pq.put([-dp[i][to][to], to, to])\n    ret = inf\n    for i in range(n):\n        ret = min(ret, dp[r - 1][z[r - 1]][i])\n    print(ret)"
  },
  {
    "language": "Python",
    "code": "inf = float(\"INF\")\n\nclass Warshall_Floyd:\n\n    def __init__(self, n, dist):\n        self.dist = dist\n        self.n = n\n\n    def search(self):\n        n = self.n\n        dist = self.dist\n        for i in range(n):\n            dist[i][i] = 0\n\n        for i in range(n):\n            di = dist[i]\n            for j in range(n):\n                dj = dist[j]\n                if i == j:\n                    continue\n                for k in range(n):\n                    if dj[k] > dj[i] + di[k]:\n                        dj[k] = dj[i] + di[k]\n\n        return dist\n\nimport sys\n\n\ndef m():\n    def main(n, m):\n        dps = [[inf] * n for i in range(n)]\n        dpl = [[inf] * n for i in range(n)]\n\n        for _ in range(m):\n            x, y, t, sl = sys.stdin.readline().split()\n            x, y, t = map(lambda x: int(x) - 1, [x, y, t])\n            t += 1\n            if sl == \"S\":\n                dps[x][y] = t\n                dps[y][x] = t\n            if sl == \"L\":\n                dpl[x][y] = t\n                dpl[y][x] = t\n\n        l = Warshall_Floyd(n, dpl)\n        s = Warshall_Floyd(n, dps)\n        dpl = l.search()\n        dps = s.search()\n\n        r = int(input())\n        v = list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))\n        dp1 = [inf] * n\n        dp1[v[0]] = 0\n\n        for i in range(r-1):\n            b = v[i]\n            c = v[i + 1]\n            dp2 = [0] * n\n            dplb = dpl[b]\n            dpk = [dp1[k] + dplb[k] for k in range(n)]\n\n            for j in range(n):\n                # 陸路のみ\n                # 船の位置は変わらず \n                dp2[j] = dp1[j] + dplb[c]\n\n                dpljc = dpl[j][c]\n                dpsj = dps[j]\n                tmp = dp2[j]\n\n                for k in range(n):\n                    # 海路あり\n                    # kに船があるとき\n                    # v[i-1]→(陸路)→k→(海路)→j→(陸路)→v[i]\n                    # この時船はjに保管される\n                    tmp1 = dpk[k] + dpsj[k] + dpljc\n                    if tmp > tmp1:\n                        tmp = tmp1\n\n                dp2[j] = tmp\n\n            dp1 = dp2\n\n        print(min(dp1))\n\n    while 1:\n        n, m = map(int, input().split())\n        if n == m == 0:\n            break\n        main(n, m)\nif __name__ == \"__main__\":\n    m()\n"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [N,M]=[int(x) for x in raw_input().split()]\n    if N==0:\n        break\n    else:\n        landr=[[99999999 for x in range(N+1)] for y in range(N+1)]\n        sear=[[99999999 for x in range(N+1)] for y in range(N+1)]\n        islandname1=[i for i in range(N+1)] #ex.[0,0,2,3,3]\n        islandname2=[[i] for i in range(N+1)] #ex.[[0,1],[],[2],[3,4],[]]\n        for i in range(1,N+1):\n            landr[i][i]=0\n            sear[i][i]=0\n        for i in range(M):\n            dd=raw_input().split()\n            [a,b]=sorted([int(x) for x in dd[:2]])\n            d=int(dd[2])\n            t=dd[3]\n            if t=='S':\n                if sear[a][b]>d:\n                    sear[a][b]=d\n                    sear[b][a]=d\n            else:\n                if landr[a][b]>d:\n                    landr[a][b]=d\n                    landr[b][a]=d\n                #check if same island\n                if islandname1[a]!=islandname1[b]: #a<b\n                    islandnameold=islandname1[b]\n                    for port in islandname2[islandname1[b]]:\n                        islandname1[port]=islandname1[a]\n                    islandname2[islandname1[a]].extend(islandname2[islandnameold])\n        #floyd algorhythm\n        for k in range(1,N+1):\n            for i in range(1,N+1):\n               for j in range(i,N+1):\n                   if landr[i][j]>landr[i][k]+landr[k][j]:\n                       landr[i][j]=landr[i][k]+landr[k][j]\n                       landr[j][i]=landr[i][k]+landr[k][j]\n                   if sear[i][j]>sear[i][k]+sear[k][j]:\n                       sear[i][j]=sear[i][k]+sear[k][j]\n                       sear[j][i]=sear[i][k]+sear[k][j]\n        R=int(raw_input())\n        dest=[int(x) for x in raw_input().split()]\n        loc=dest[0]\n        portold=[[dest[0],0]]\n        for i in range(R-1):\n            portnew=[]\n            newloc=dest[i+1]\n            newport_temp=islandname2[islandname1[newloc]]\n            for np in newport_temp:\n                mintime=999999999\n                for opc in portold:\n                    op=opc[0]\n                    opt=opc[1]\n                    mintime=min(mintime,opt+landr[loc][op]+sear[op][np]+landr[np][newloc])\n                    if op==np:\n                        mintime=min(mintime,opt+landr[loc][newloc])\n                portnew.append([np,mintime])\n            portold=portnew\n            loc=dest[i+1]\n            i=i+1\n        ans=sorted(portold,key=lambda x:x[1])\n        print ans[0][1]"
  },
  {
    "language": "Python",
    "code": "inf = 10**9\ndp = [[inf] * 200 for i in range(200)]\nldist = [[inf] * 200 for i in range(200)]\nsdist = [[inf] * 200 for i in range(200)]\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0:\n        break\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                ldist[i][j] = sdist[i][j] = 0\n            else:\n                ldist[i][j] = sdist[i][j] = inf\n    for i in range(m):\n        x, y, t, sl = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        t = int(t)\n        if sl == 'L':\n            ldist[x][y] = ldist[y][x] = min(ldist[x][y], t)\n        elif sl == 'S':\n            sdist[x][y] = sdist[y][x] = min(sdist[x][y], t)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                ldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j])\n                sdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j])\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = 0 if i == j else inf\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i])\n    r = int(input())\n    z = list(map(int, input().split()))\n    for i in range(n):\n        z[i] -= 1\n    for i in range(n):\n        if i != z[0]:\n            for j in range(n):\n                dp[i][j] = inf\n    for i in range(1, r):\n        for j in range(n):\n            for k in range(n):\n                if j != z[i - 1]:\n                    dp[j][k] = min(dp[j][k], dp[z[i - 1]]\n                                   [k] + ldist[z[i - 1]][j])\n        for j in range(n):\n            for k in range(n):\n                dp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k])\n        for j in range(n):\n            for k in range(n):\n                if j != k:\n                    dp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j])\n        for j in range(n):\n            if j != z[i]:\n                for k in range(n):\n                    dp[j][k] = inf\n    ret = inf\n    for i in range(n):\n        ret = min(ret, dp[z[r - 1]][i])\n    print(ret)"
  },
  {
    "language": "Python",
    "code": "inf = 10**9\ndp = [[inf] * 210 for i in range(210)]\nldist = [[inf] * 210 for i in range(210)]\nsdist = [[inf] * 210 for i in range(210)]\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0:\n        break\n    for i in range(n):\n        for j in range(n):\n            if i == j:\n                ldist[i][j] = sdist[i][j] = 0\n            else:\n                ldist[i][j] = sdist[i][j] = inf\n    for i in range(m):\n        x, y, t, sl = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        t = int(t)\n        if sl == 'L':\n            ldist[x][y] = ldist[y][x] = min(ldist[x][y], t)\n        elif sl == 'S':\n            sdist[x][y] = sdist[y][x] = min(sdist[x][y], t)\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                ldist[i][j] = min(ldist[i][j], ldist[i][k] + ldist[k][j])\n                sdist[i][j] = min(sdist[i][j], sdist[i][k] + sdist[k][j])\n    for i in range(n):\n        for j in range(n):\n            dp[i][j] = 0 if i == j else inf\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                dp[i][j] = min(dp[i][j], dp[j][j] + ldist[j][i])\n    r = int(input())\n    z = list(map(int, input().split()))\n    for i in range(n):\n        z[i] -= 1\n    for i in range(n):\n        if i != z[0]:\n            for j in range(n):\n                dp[i][j] = inf\n    for i in range(1, r):\n        for j in range(n):\n            for k in range(n):\n                if j != z[i - 1]:\n                    dp[j][k] = min(dp[j][k], dp[z[i - 1]]\n                                   [k] + ldist[z[i - 1]][j])\n        for j in range(n):\n            for k in range(n):\n                dp[k][k] = min(dp[k][k], dp[j][j] + sdist[j][k])\n        for j in range(n):\n            for k in range(n):\n                if j != k:\n                    dp[j][k] = min(dp[j][k], dp[k][k] + ldist[k][j])\n        for j in range(n):\n            if j != z[i]:\n                for k in range(n):\n                    dp[j][k] = inf\n    ret = inf\n    for i in range(n):\n        ret = min(ret, dp[z[r - 1]][i])\n    print(ret)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\ndef wf(A,N):\n    for k in range(1,N+1):\n        for i in range(1,N+1):\n            for j in range(1,N+1):\n                if A[i][j] > A[i][k]+A[k][j]:\n                    A[i][j] = A[i][k]+A[k][j]\n                \nif __name__==\"__main__\":\n    while(1):\n        N,M=map(int, input().split())\n        if N==0: break\n        bignum=999999999999\n        L=[[bignum if x!=y else 0 for x in range(N+1)] for y in range(N+1)]\n        S=[[bignum if x!=y else 0  for x in range(N+1)] for y in range(N+1)]\n        for i in range(M):\n            l=input().split()\n            a,b,c = map(int, l[:-1])\n            if l[-1]==\"S\":\n                S[a][b]=min(S[a][b],c)\n                S[b][a]=min(S[b][a],c)\n            else:\n                L[b][a]=min(L[b][a],c)\n                L[a][b]=min(L[a][b],c)\n            \n        wf(L,N)\n        wf(S,N)\n        R=int(input())\n        Z=list(map(int, input().split()))\n        A=[[bignum for x in range(N+1)] for y in range(R)]\n        A[0][Z[0]]=0\n        for i in range(1,R):\n            src=Z[i-1]\n            dst=Z[i]\n            for n in range(1,N+1):\n                if L[n][dst]!=bignum:\n                    for k in range(1,N+1):\n                        A[i][n]=min(A[i][n],A[i-1][k]+L[src][k]+S[k][n]+L[n][dst])\n        print (min(A[R-1]))\n            \n"
  },
  {
    "language": "Python",
    "code": "from queue import PriorityQueue\ninf = 10**9\nwhile True:\n    n, m = map(int, input().split())\n    if n == 0:\n        break\n    edgel = [[] for i in range(n)]\n    edges = [[] for i in range(n)]\n    for i in range(m):\n        x, y, t, sl = input().split()\n        x = int(x) - 1\n        y = int(y) - 1\n        t = int(t)\n        if sl == 'L':\n            edgel[x].append([y, t])\n            edgel[y].append([x, t])\n        else:\n            edges[x].append([y, t])\n            edges[y].append([x, t])\n    r = int(input())\n    z = list(map(int, input().split()))\n    for i in range(r):\n        z[i] -= 1\n    dp = [[[inf] * n for i in range(n)] for j in range(r)]\n    dp[0][z[0]][z[0]] = 0\n    for i in range(1, r):\n        pq = PriorityQueue()\n        for j in range(n):\n            if dp[i - 1][z[i - 1]][j] != inf:\n                pq.put([dp[i - 1][z[i - 1]][j], z[i - 1], j])\n                dp[i][z[i - 1]][j] = dp[i - 1][z[i - 1]][j]\n        while not pq.empty():\n            d, pos, f = pq.get()\n            if d > dp[i][pos][f]:\n                continue\n            for j in range(len(edgel[pos])):\n                to, add = edgel[pos][j]\n                if dp[i][to][f] > dp[i][pos][f] + add:\n                    dp[i][to][f] = dp[i][pos][f] + add\n                    pq.put([dp[i][to][f], to, f])\n            if pos == f:\n                for j in range(len(edges[pos])):\n                    to, add = edges[pos][j]\n                    if dp[i][to][to] > dp[i][pos][f] + add:\n                        dp[i][to][to] = dp[i][pos][f] + add\n                        pq.put([dp[i][to][to], to, to])\n    ret = inf\n    for i in range(n):\n        ret = min(ret, dp[r - 1][z[r - 1]][i])\n    print(ret)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\ndef main():\n  while True:\n    n, m = map(int, input().split())\n    if n == 0:break\n    land_route = [[] for _ in range(n)]\n    sea_route = [[] for _ in range(n)]\n    for _ in range(m):\n      x, y, t, s = input().split()\n      x, y, t = int(x) - 1, int(y) - 1, int(t)\n      if s == \"L\":\n        land_route[x].append((y, t))\n        land_route[y].append((x, t))\n      if s == \"S\":\n        sea_route[x].append((y, t))\n        sea_route[y].append((x, t))\n    \n    r = int(input())\n    zlst = list(map(int, input().split()))\n    zlst = [i - 1 for i in zlst]\n    dic = {} #dic[(pos1, pos2, visited)]\n    dic[(zlst[0], zlst[0], 0)] = 0\n    que = []\n    heappush(que, (0, 0, zlst[0], zlst[0]))\n    while que:\n      score, index, pos1, pos2 = heappop(que)\n      if index == r - 1:\n        print(score)\n        break\n    \n      for to, cost in land_route[pos1]:\n        new_score = score + cost\n        if to == zlst[index + 1]:\n          if (to, pos2, index + 1) not in dic or dic[(to, pos2, index + 1)] > new_score:\n            dic[(to, pos2, index + 1)] = new_score\n            heappush(que, (new_score, index + 1, to, pos2))\n        else:\n          if (to, pos2, index) not in dic or dic[(to, pos2, index)] > new_score:\n            dic[(to, pos2, index)] = new_score\n            heappush(que, (new_score, index, to, pos2))\n    \n      if pos1 != pos2:continue\n    \n      for to, cost in sea_route[pos1]:\n        new_score = score + cost\n        if to == zlst[index + 1]:\n          if (to, to, index + 1) not in dic or dic[(to, to, index + 1)] > new_score:\n            dic[(to, to, index + 1)] = new_score\n            heappush(que, (new_score, index + 1, to, to))\n        else:\n          if (to, to, index) not in dic or dic[(to, to, index)] > new_score:\n            dic[(to, to, index)] = new_score\n            heappush(que, (new_score, index, to, to))\n    \nmain()\n"
  },
  {
    "language": "Rust",
    "code": "// AOJ 2200\n#![allow(non_snake_case)]\n\nfn read<T: std::str::FromStr>() -> T {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    s.trim().parse().ok().unwrap()\n}\n\nfn read_vec<T: std::str::FromStr>() -> Vec<T> {\n    read::<String>()\n        .split_whitespace()\n        .map(|e| e.parse().ok().unwrap())\n        .collect()\n}\n\nfn read_tuple<T: std::str::FromStr + Copy>() -> (T, T) {\n    let v: Vec<T> = read_vec();\n    (v[0], v[1])\n}\n\nfn floyd_warshall(d: &mut Vec<Vec<i32>>) {\n    let v = d.len();\n    for k in 0..v {\n        for i in 0..v {\n            for j in 0..v {\n                d[i][j] = std::cmp::min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n}\n\nfn main() {\n    let INF = i32::max_value() / 10;\n\n    loop {\n        let (N, M) = read_tuple::<usize>();\n        if N == 0 && M == 0 {\n            break;\n        }\n\n        let mut sea = vec![vec![INF; N]; N];\n        let mut land = vec![vec![INF; N]; N];\n        for i in 0..N {\n            sea[i][i] = 0;\n            land[i][i] = 0;\n        }\n\n        for i in 0..M {\n            let vec: Vec<String> = read_vec();\n            let x = vec[0].parse::<usize>().unwrap() - 1;\n            let y = vec[1].parse::<usize>().unwrap() - 1;\n            let t: i32 = vec[2].parse().unwrap();\n            if vec[3].eq(\"S\") {\n                sea[x][y] = t;\n                sea[y][x] = t;\n            } else {\n                land[x][y] = t;\n                land[y][x] = t;\n            }\n        }\n\n        let R: usize = read();\n        let z: Vec<usize> = read_vec::<usize>().iter().map(|&i| i - 1).collect();\n\n        floyd_warshall(&mut sea);\n        floyd_warshall(&mut land);\n\n        let mut dp = vec![INF; N];\n        dp[z[0]] = 0;\n        for k in 1..R {\n            let mut ndp = vec![INF; N];\n            for i in 0..N {\n                ndp[i] = dp[i] + land[z[k-1]][z[k]];\n                for j in 0..N {\n                    ndp[i] = std::cmp::min(ndp[i], dp[j] + land[z[k-1]][j] + sea[j][i] + land[i][z[k]]);\n                }\n            }\n            dp = ndp;\n        }\n        println!(\"{}\", dp.iter().min().unwrap());\n    }\n\n}\n\n"
  }
]