[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 1000000007\n\nint main() {\n    int H, W, sx, sy, lx, ly, gx, gy;\n    scanf(\"%d %d\", &H, &W);\n    scanf(\"%d %d\", &sx, &sy);\n    scanf(\"%d %d\", &lx, &ly);\n    scanf(\"%d %d\", &gx, &gy);\n\n    int dp[H+1][W+1][H+1][W+1];\n    memset(dp, 0, sizeof(dp));\n    dp[sx][sy][lx][ly] = 1;\n\n    for (int x1 = 1; x1 <= H; x1++) {\n        for (int y1 = 1; y1 <= W; y1++) {\n            for (int x2 = 1; x2 <= H; x2++) {\n                for (int y2 = 1; y2 <= W; y2++) {\n                    if (dp[x1][y1][x2][y2] == 0) continue;\n\n                    int dirs[4][2] = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n                    for (int k = 0; k < 4; k++) {\n                        int nx1 = x1 + dirs[k][0];\n                        int ny1 = y1 + dirs[k][1];\n                        if (nx1 < 1 || nx1 > H || ny1 < 1 || ny1 > W) continue;\n\n                        int nx2 = x2 + dirs[k][0];\n                        int ny2 = y2 + dirs[k][1];\n                        if (nx2 < 1 || nx2 > H || ny2 < 1 || ny2 > W) continue;\n\n                        dp[nx1][ny1][nx2][ny2] = (dp[nx1][ny1][nx2][ny2] + dp[x1][y1][x2][y2]) % MOD;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", dp[gx][gy][lx][ly]);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:17:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n#define MAX 2000000\n\nlong long fact[MAX], inv_fact[MAX];\n\nlong long mod_pow(long long base, long long exp) {\n    long long result = 1;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % MOD;\n        }\n        base = (base * base) % MOD;\n        exp /= 2;\n    }\n    return result;\n}\n\nvoid precompute() {\n    fact[0] = 1;\n    for (int i = 1; i < MAX; i++) {\n        fact[i] = (fact[i-1] * i) % MOD;\n    }\n    inv_fact[MAX-1] = mod_pow(fact[MAX-1], MOD-2);\n    for (int i = MAX-2; i >= 0; i--) {\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD;\n    }\n}\n\nlong long comb(int a, int b) {\n    if (a < 0 || b < 0 || a < b) return 0;\n    return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD;\n}\n\nlong long path_count(int x1, int y1, int x2, int y2) {\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n    return comb(dx + dy, dx);\n}\n\nint main() {\n    precompute();\n    int R, C, X, Y, D, L;\n    scanf(\"%d %d %d %d %d %d\", &R, &C, &X, &Y, &D, &L);\n    \n    long long total = 0;\n    for (int mask = 0; mask < 16; mask++) {\n        int x = X, y = Y;\n        int bits = __builtin_popcount(mask);\n        if (mask & 1) x--;\n        if (mask & 2) x--;\n        if (mask & 4) y--;\n        if (mask & 8) y--;\n        if (x < 0 || y < 0) continue;\n        long long ways = comb(x * y, D + L) * comb(D + L, D) % MOD;\n        if (bits % 2 == 0) {\n            total = (total + ways) % MOD;\n        } else {\n            total = (total - ways + MOD) % MOD;\n        }\n    }\n    \n    long long ans = total * (R - X + 1) % MOD;\n    ans = ans * (C - Y + 1) % MOD;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst long long MOD = 1e9 + 7;\n\nlong long comb[3000][3000];\n\nvoid precompute_comb() {\n    comb[0][0] = 1;\n    for (int i = 1; i < 3000; ++i) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; ++j) {\n            comb[i][j] = (comb[i-1][j-1] + comb[i-1][j]) % MOD;\n        }\n    }\n}\n\nlong long count_paths(int x1, int y1, int x2, int y2) {\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n    if (dx < 0 || dy < 0) return 0;\n    return comb[dx + dy][dx];\n}\n\nint main() {\n    precompute_comb();\n    int R, C, A, B;\n    cin >> R >> C >> A >> B;\n    \n    long long total = 0;\n    for (int x = B + 1; x <= C; ++x) {\n        long long path1 = count_paths(1, 1, A, x);\n        long long path2 = count_paths(A, x, R, C);\n        total = (total + path1 * path2) % MOD;\n    }\n    \n    cout << total << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:18:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    static final long MOD = 1000000007;\n    static long[] fact;\n    static long[] invFact;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int R = sc.nextInt();\n        int C = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n\n        int maxN = R + C - 2;\n        fact = new long[maxN + 1];\n        invFact = new long[maxN + 1];\n        fact[0] = 1;\n        for (int i = 1; i <= maxN; i++) {\n            fact[i] = fact[i - 1] * i % MOD;\n        }\n        invFact[maxN] = modInverse(fact[maxN], MOD);\n        for (int i = maxN - 1; i >= 0; i--) {\n            invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n        }\n\n        long res = 0;\n        for (int x = B; x < C; x++) {\n            long way1 = comb((A - 1) + x, A - 1);\n            long way2 = comb((R - A - 1) + (C - x - 1), R - A - 1);\n            res = (res + way1 * way2 % MOD) % MOD;\n        }\n        System.out.println(res);\n    }\n\n    static long comb(int n, int k) {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n\n    static long modInverse(long a, long mod) {\n        long m = mod;\n        long y = 0, x = 1;\n        while (a > 1) {\n            long q = a / mod;\n            long t = mod;\n            mod = a % mod;\n            a = t;\n            t = y;\n            y = x - q * y;\n            x = t;\n        }\n        if (x < 0) {\n            x += m;\n        }\n        return x;\n    }\n}",
    "timestamp": "2025-08-05 23:18:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TourPlanner {\n    static final int MOD = 1_000_000_007;\n\n    public static int countGoodTours(int startX1, int startY1, int startX2, int startY2,\n                                     int lunchX1, int lunchY1, int lunchX2, int lunchY2,\n                                     int endX1, int endY1, int endX2, int endY2) {\n        \n        long[][][] dp = new long[51][51][51];\n        \n        // Initialize base cases\n        dp[0][0][0] = 1;\n        \n        // Dynamic programming to count paths\n        for (int step = 0; step < 50; step++) {\n            for (int startPos = 0; startPos <= step; startPos++) {\n                for (int lunchPos = 0; lunchPos <= step; lunchPos++) {\n                    if (dp[step][startPos][lunchPos] == 0) continue;\n                    \n                    // Try moving in 4 directions\n                    int[][] dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};\n                    \n                    for (int[] dir : dirs) {\n                        int newStartX = startX1 + startPos * dir[0];\n                        int newStartY = startY1 + startPos * dir[1];\n                        int newLunchX = lunchX1 + lunchPos * dir[0];\n                        int newLunchY = lunchY1 + lunchPos * dir[1];\n                        int endStep = step + 1;\n                        \n                        // Check if in start and lunch ranges\n                        if (inRange(newStartX, startX1, startX2, newStartY, startY1, startY2) &&\n                            inRange(newLunchX, lunchX1, lunchX2, newLunchY, lunchY1, lunchY2)) {\n                            \n                            dp[step+1][startPos+1][lunchPos] += dp[step][startPos][lunchPos];\n                            dp[step+1][startPos+1][lunchPos] %= MOD;\n                        }\n                        \n                        // If lunch reached, move to end\n                        if (inRange(newLunchX, lunchX1, lunchX2, newLunchY, lunchY1, lunchY2)) {\n                            if (inRange(newLunchX, endX1, endX2, newLunchY, endY1, endY2)) {\n                                dp[step+1][startPos+1][lunchPos+1] += dp[step][startPos][lunchPos];\n                                dp[step+1][startPos+1][lunchPos+1] %= MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        // Sum valid end paths\n        long result = 0;\n        for (int startPos = 0; startPos <= 50; startPos++) {\n            for (int lunchPos = 0; lunchPos <= 50; lunchPos++) {\n                result += dp[50][startPos][lunchPos];\n                result %= MOD;\n            }\n        }\n        \n        return (int)result;\n    }\n    \n    static boolean inRange(int x, int x1, int x2, int y, int y1, int y2) {\n        return x >= Math.min(x1, x2) && x <= Math.max(x1, x2) &&\n               y >= Math.min(y1, y2) && y <= Math.max(y1, y2);\n    }\n}",
    "timestamp": "2025-08-05 23:19:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <climits>\n\nusing namespace std;\nconst int MOD = 1e9 + 7;\n\nclass Solution {\npublic:\n    int countGoodTouringPlans(int sx, int sy, int lx, int ly, int ex, int ey, \n                               int xMin, int xMax, int yMin, int yMax) {\n        vector<vector<int>> dp(xMax - xMin + 1, vector<int>(yMax - yMin + 1, 0));\n        \n        // Starting point initialization\n        dp[sx - xMin][sy - yMin] = 1;\n        \n        // Dynamic programming to calculate paths\n        for (int x = xMin; x <= xMax; x++) {\n            for (int y = yMin; y <= yMax; y++) {\n                if (x == sx && y == sy) continue;\n                \n                // Calculate paths from previous cells\n                int left = (x > xMin) ? dp[x - 1 - xMin][y - yMin] : 0;\n                int up = (y > yMin) ? dp[x - xMin][y - 1 - yMin] : 0;\n                \n                dp[x - xMin][y - yMin] = (left + up) % MOD;\n                \n                // Check if current point is lunch or end point\n                if ((x == lx && y == ly) || (x == ex && y == ey)) {\n                    dp[x - xMin][y - yMin] = max(1, dp[x - xMin][y - yMin]);\n                }\n            }\n        }\n        \n        return dp[ex - xMin][ey - yMin];\n    }\n};\n\nint main() {\n    Solution solution;\n    int sx, sy, lx, ly, ex, ey, xMin, xMax, yMin, yMax;\n    \n    cin >> sx >> sy >> lx >> ly >> ex >> ey;\n    cin >> xMin >> xMax >> yMin >> yMax;\n    \n    int result = solution.countGoodTouringPlans(sx, sy, lx, ly, ex, ey, xMin, xMax, yMin, yMax);\n    \n    cout << result << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:19:09"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef num_good_touring_plans(n, m, x_start_range, y_start_range, x_lunch_range, y_lunch_range, x_end_range, y_end_range):\n    def sum_of_integers(l, r):\n        if r < l:\n            return 0\n        return (r * (r + 1) // 2 - (l-1) * l // 2) % MOD\n\n    def range_sum(l_range, r_range, fixed):\n        l, r = max(l_range[0] - fixed, 0), min(l_range[1] - fixed, m-1)\n        if l > r:\n            return 0\n        return (r-l+1) * (fixed+1) % MOD\n    \n    total_plans = 0\n    for x_s_start in range(x_start_range[0], x_start_range[1]+1):\n        for y_s_start in range(y_start_range[0], y_start_range[1]+1):\n            for x_lunch in range(x_lunch_range[0], x_lunch_range[1]+1):\n                for y_lunch in range(y_lunch_range[0], y_lunch_range[1]+1):\n                    for x_end in range(x_end_range[0], x_end_range[1]+1):\n                        for y_end in range(y_end_range[0], y_end_range[1]+1):\n                            dist_start_to_lunch = abs(x_s_start - x_lunch) + abs(y_s_start - y_lunch)\n                            dist_lunch_to_end = abs(x_lunch - x_end) + abs(y_lunch - y_end)\n                            \n                            if dist_start_to_lunch + dist_lunch_to_end == \\\n                               abs(x_s_start - x_end) + abs(y_s_start - y_end):\n                                total_plans = (total_plans + 1) % MOD\n\n    return total_plans\n\n# Replace arguments with actual values\nn, m = 100, 100  # Dimensions of grid\nx_start_range = (1, 50)\ny_start_range = (1, 50)\nx_lunch_range = (25, 75)\ny_lunch_range = (25, 75)\nx_end_range = (50, 100)\ny_end_range = (50, 100)\n\nresult = num_good_touring_plans(n, m, x_start_range, y_start_range, x_lunch_range, y_lunch_range, x_end_range, y_end_range)\nprint(result)",
    "timestamp": "2025-08-13 14:29:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class TouringPlans {\n    private static final int MOD = 1_000_000_007;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int sx1 = scanner.nextInt();\n        int sy1 = scanner.nextInt();\n        int sx2 = scanner.nextInt();\n        int sy2 = scanner.nextInt();\n        int lx1 = scanner.nextInt();\n        int ly1 = scanner.nextInt();\n        int lx2 = scanner.nextInt();\n        int ly2 = scanner.nextInt();\n        int ex1 = scanner.nextInt();\n        int ey1 = scanner.nextInt();\n        int ex2 = scanner.nextInt();\n        int ey2 = scanner.nextInt();\n\n        long count = 0;\n\n        for (int startX = sx1; startX <= sx2; ++startX) {\n            for (int startY = sy1; startY <= sy2; ++startY) {\n                for (int lunchX = lx1; lunchX <= lx2; ++lunchX) {\n                    for (int lunchY = ly1; lunchY <= ly2; ++lunchY) {\n                        for (int endX = ex1; endX <= ex2; ++endX) {\n                            for (int endY = ey1; endY <= ey2; ++endY) {\n                                if (isGoodPlan(startX, startY, lunchX, lunchY, endX, endY)) {\n                                    count++;\n                                    count %= MOD;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(count);\n\n        scanner.close();\n    }\n\n    private static boolean isGoodPlan(int startX, int startY, int lunchX, int lunchY, int endX, int endY) {\n        int startToLunchDistance = distance(startX, startY, lunchX, lunchY);\n        int lunchToEndDistance = distance(lunchX, lunchY, endX, endY);\n        int startToEndDistance = distance(startX, startY, endX, endY);\n        return startToLunchDistance + lunchToEndDistance == startToEndDistance;\n    }\n\n    private static int distance(int x1, int y1, int x2, int y2) {\n        return Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    }\n}",
    "timestamp": "2025-08-13 14:29:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MOD 1000000007\n\ntypedef long long ll;\n\nll countWays(int sr, int sc, int lr, int lc, int er, int ec) {\n    // Initialize table to memoize ways to reach each point\n    ll dp[1001][1001] = {0};\n    dp[sr][sc] = 1;\n\n    // Fill dp table from start to lunch point\n    for (int i = sr; i <= lr; i++) {\n        for (int j = sc; j <= lc; j++) {\n            if (i > sr) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n            }\n            if (j > sc) {\n                dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n\n    // Count ways to lunch point\n    ll waysToLunch = dp[lr][lc];\n\n    // Reset the dp table for lunch to end calculation\n    for (int i = lr; i <= er; i++) {\n        for (int j = lc; j <= ec; j++) {\n            dp[i][j] = 0;\n        }\n    }\n\n    dp[lr][lc] = 1;\n\n    // Fill dp table from lunch to end point\n    for (int i = lr; i <= er; i++) {\n        for (int j = lc; j <= ec; j++) {\n            if (i > lr) {\n                dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD;\n            }\n            if (j > lc) {\n                dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD;\n            }\n        }\n    }\n\n    // Ways from lunch to end\n    ll waysToEnd = dp[er][ec];\n\n    return (waysToLunch * waysToEnd) % MOD;\n}\n\nint main() {\n    int rs, re, cs, ce;\n    scanf(\"%d%d%d%d\", &rs, &re, &cs, &ce); // Range for start sections\n\n    int rl, rr, cl, cr;\n    scanf(\"%d%d%d%d\", &rl, &rr, &cl, &cr); // Range for lunch sections\n\n    int rt, rb, ct, cb;\n    scanf(\"%d%d%d%d\", &rt, &rb, &ct, &cb); // Range for end sections\n\n    ll result = 0;\n\n    for (int sr = rs; sr <= re; sr++) {\n        for (int sc = cs; sc <= ce; sc++) {\n            for (int lr = rl; lr <= rr; lr++) {\n                for (int lc = cl; lc <= cr; lc++) {\n                    for (int er = rt; er <= rb; er++) {\n                        for (int ec = ct; ec <= cb; ec++) {\n                            if (sr <= lr && lr <= er && sc <= lc && lc <= ec)\n                                result = (result + countWays(sr, sc, lr, lc, er, ec)) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:29:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1000000007;\n\nfunction countGoodTourPlans(N, M, A, B, C, D, E, F, H, I, J, K) {\n    let count = 0;\n\n    for (let x1 = A; x1 <= B; x1++) {\n        for (let y1 = C; y1 <= D; y1++) {\n            for (let x2 = E; x2 <= F; x2++) {\n                for (let y2 = H; y2 <= I; y2++) {\n                    for (let x3 = J; x3 <= K; x3++) {\n                        for (let y3 = C; y3 <= D; y3++) {\n                            if (isValidPlan(x1, y1, x2, y2, x3, y3)) {\n                                count = (count + 1) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n\nfunction isValidPlan(x1, y1, x2, y2, x3, y3) {\n    const dist1 = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n    const dist2 = Math.abs(x2 - x3) + Math.abs(y2 - y3);\n    const totalDist = Math.abs(x1 - x3) + Math.abs(y1 - y3);\n    return dist1 + dist2 === totalDist;\n}\n\n// Example usage (replace N, M, A, B, C, D, E, F, H, I, J, K with actual values):\n// console.log(countGoodTourPlans(N, M, A, B, C, D, E, F, H, I, J, K));",
    "timestamp": "2025-08-13 14:29:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_tour_plans(sx, sy, lx, ly, gx, gy):\n    MOD = 10**9 + 7\n    \n    def manhattan_distance(x1, y1, x2, y2):\n        return abs(x1 - x2) + abs(y1 - y2)\n    \n    total_distance = manhattan_distance(sx, sy, lx, ly) + manhattan_distance(lx, ly, gx, gy)\n    \n    def count_paths(start_x, start_y, lunch_x, lunch_y, goal_x, goal_y):\n        dx = [0, 1, -1, 0]\n        dy = [1, 0, 0, -1]\n        \n        dp = {}\n        \n        def dfs(x, y, remaining_dist):\n            if x == lunch_x and y == lunch_y and remaining_dist == 0:\n                return 1\n            \n            if remaining_dist < 0:\n                return 0\n            \n            key = (x, y, remaining_dist)\n            if key in dp:\n                return dp[key]\n            \n            total_paths = 0\n            for i in range(4):\n                nx = x + dx[i]\n                ny = y + dy[i]\n                total_paths = (total_paths + dfs(nx, ny, remaining_dist - 1)) % MOD\n            \n            dp[key] = total_paths\n            return total_paths\n        \n        return dfs(start_x, start_y, total_distance)\n    \n    return count_paths(sx, sy, lx, ly, gx, gy)",
    "timestamp": "2025-08-13 14:30:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countTourPlans(startX, startY, lunchX, lunchY, endX, endY) {\n    const MOD = 1000000007;\n    const dp = Array.from({ length: 51 }, () => \n        Array.from({ length: 51 }, () => \n            Array.from({ length: 51 }, () => \n                Array.from({ length: 51 }, () => \n                    Array.from({ length: 51 }, () => \n                        Array.from({ length: 51 }, () => 0)\n                    )\n                )\n            )\n        )\n    );\n\n    dp[startX][startY][lunchX][lunchY][endX][endY] = 1;\n\n    for (let x1 = 0; x1 <= 50; x1++) {\n        for (let y1 = 0; y1 <= 50; y1++) {\n            for (let xl = 0; xl <= 50; xl++) {\n                for (let yl = 0; yl <= 50; yl++) {\n                    for (let x2 = 0; x2 <= 50; x2++) {\n                        for (let y2 = 0; y2 <= 50; y2++) {\n                            if (dp[x1][y1][xl][yl][x2][y2] === 0) continue;\n\n                            // Move from start to lunch\n                            if (xl > x1) {\n                                dp[xl][yl][xl][yl][x2][y2] = \n                                    (dp[xl][yl][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                            if (xl < x1) {\n                                dp[xl][yl][xl][yl][x2][y2] = \n                                    (dp[xl][yl][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                            if (yl > y1) {\n                                dp[xl][yl][xl][yl][x2][y2] = \n                                    (dp[xl][yl][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                            if (yl < y1) {\n                                dp[xl][yl][xl][yl][x2][y2] = \n                                    (dp[xl][yl][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n\n                            // Move from lunch to end\n                            if (x2 > xl) {\n                                dp[x1][y1][xl][yl][x2][y2] = \n                                    (dp[x1][y1][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                            if (x2 < xl) {\n                                dp[x1][y1][xl][yl][x2][y2] = \n                                    (dp[x1][y1][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                            if (y2 > yl) {\n                                dp[x1][y1][xl][yl][x2][y2] = \n                                    (dp[x1][y1][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                            if (y2 < yl) {\n                                dp[x1][y1][xl][yl][x2][y2] = \n                                    (dp[x1][y1][xl][yl][x2][y2] + dp[x1][y1][xl][yl][x2][y2]) % MOD;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    let totalPlans = 0;\n    for (let xl = 0; xl <= 50; xl++) {\n        for (let yl = 0; yl <= 50; yl++) {\n            totalPlans = (totalPlans + dp[startX][startY][xl][yl][endX][endY]) % MOD;\n        }\n    }\n\n    return totalPlans;\n}",
    "timestamp": "2025-08-13 14:30:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 10**9 + 7\n\ndef solve():\n    import sys\n    R, C = map(int, sys.stdin.readline().split())\n    a1, a2 = map(int, sys.stdin.readline().split())\n    b1, b2 = map(int, sys.stdin.readline().split())\n    \n    x = abs(a1 - b1)\n    y = abs(a2 - b2)\n    \n    if x > y:\n        x, y = y, x\n    \n    if x == 0 and y == 0:\n        print(0)\n        return\n    if x == 0:\n        print(1)\n        return\n    \n    # Precompute factorial, inverse factorial up to x+y\n    max_n = x + y\n    fact = [1] * (max_n + 1)\n    inv_fact = [1] * (max_n + 1)\n    \n    for i in range(1, max_n + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    inv_fact[max_n] = pow(fact[max_n], MOD-2, MOD)\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = inv_fact[i + 1] * (i + 1) % MOD\n    \n    def comb(a, b):\n        if a < 0 or b < 0 or a < b:\n            return 0\n        return fact[a] * inv_fact[b] % MOD * inv_fact[a - b] % MOD\n    \n    # Path from (0,0) to (x,y) * path from (x,y) to (0,0)\n    res = comb(x + y, x) ** 2 % MOD\n    \n    # Subtract paths that pass through (i,j) where i == j < x\n    for i in range(x):\n        j = i\n        c1 = comb(i + j, i)\n        rem_x = x - i\n        rem_y = y - j\n        c2 = comb(rem_x + rem_y, rem_x)\n        res = (res - c1 * c1 % MOD * c2 % MOD * c2 % MOD) % MOD\n    \n    print(res % MOD)\n\nsolve()",
    "timestamp": "2025-08-13 14:30:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 1e9 + 7;\n\nfunction solve() {\n    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\\n');\n    const [H, W] = input[0].split(' ').map(Number);\n    const [A, B, C, D] = input[1].split(' ').map(Number);\n    \n    // Precompute factorial, inverse factorial modulo MOD\n    const maxN = H + W - 2;\n    const fact = new Array(maxN + 1).fill(1);\n    const invFact = new Array(maxN + 1).fill(1);\n    \n    for (let i = 1; i <= maxN; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    invFact[maxN] = modInverse(fact[maxN], MOD);\n    for (let i = maxN - 1; i >= 0; i--) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n    \n    function comb(n, k) {\n        if (n < 0 || k < 0 || k > n) return 0;\n        return fact[n] * invFact[k] % MOD * invFact[n - k] % MOD;\n    }\n    \n    function pathCount(x1, y1, x2, y2) {\n        const dx = x2 - x1;\n        const dy = y2 - y1;\n        return comb(dx + dy, dx);\n    }\n    \n    const S = pathCount(1, 1, A, B);\n    const L = pathCount(A, B, C, D);\n    const E = pathCount(C, D, H, W);\n    \n    const total = S * L % MOD * E % MOD;\n    console.log(total);\n}\n\nfunction modInverse(a, mod) {\n    let [g, x, y] = extendedGcd(a, mod);\n    if (g !== 1) return 0; // No inverse exists\n    return (x % mod + mod) % mod;\n}\n\nfunction extendedGcd(a, b) {\n    if (b === 0) {\n        return [a, 1, 0];\n    }\n    const [g, x, y] = extendedGcd(b, a % b);\n    return [g, y, x - Math.floor(a / b) * y];\n}\n\nsolve();",
    "timestamp": "2025-08-13 14:30:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int MOD = 1e9 + 7;\n\nint countGoodPlans(int X1, int Y1, int X2, int Y2, int X3, int Y3) {\n    vector<vector<int>> dp(X3+1, vector<int>(Y3+1, 0));\n\n    auto comb = [&](int n, int k) {\n        if (k < 0 || k > n) return 0;\n        long long res = 1;\n        for (int i = 0; i < k; ++i) {\n            res = (res * (n - i)) % MOD;\n            res = (res * inverse(i + 1)) % MOD;\n        }\n        return res;\n    };\n\n    auto inverse = [&](int x) {\n        long long res = 1, base = x, exp = MOD - 2;\n        while (exp) {\n            if (exp % 2) res = res * base % MOD;\n            base = base * base % MOD;\n            exp /= 2;\n        }\n        return res;\n    };\n\n    auto countPaths = [&](int x1, int y1, int x2, int y2) {\n        int dx = x2 - x1, dy = y2 - y1;\n        return comb(dx + dy, dx);\n    };\n\n    for (int x = X1; x <= X2; ++x) {\n        for (int y = Y1; y <= Y2; ++y) {\n            long long sum = 0;\n            for (int x_mid = X1; x_mid <= X2; ++x_mid) {\n                for (int y_mid = Y1; y_mid <= Y2; ++y_mid) {\n                    sum = (sum +\n                           1LL * countPaths(x, y, x_mid, y_mid) *\n                           countPaths(x_mid, y_mid, x, y)) % MOD;\n                }\n            }\n            dp[x][y] = sum;\n        }\n    }\n\n    long long result = 0;\n    for (int x = X1; x <= X2; ++x) {\n        for (int y = Y1; y <= Y2; ++y) {\n            result = (result + dp[x][y]) % MOD;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int X1, Y1, X2, Y2, X3, Y3;\n    cin >> X1 >> Y1 >> X2 >> Y2 >> X3 >> Y3;\n    cout << countGoodPlans(X1, Y1, X2, Y2, X3, Y3) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 14:43:39"
  }
]